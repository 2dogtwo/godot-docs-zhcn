# Godot Engine Documentation in Chinese (Simplified)
# Copyright (C) 2014-2019, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
#
# AColdCube <761397398@qq.com>, 2018.
# asd789l <690367819@qq.com>, 2018.
# baiwu liu <bovy.liu@gmail.com>, 2018.
# bladesero <872461916@qq.com>, 2018.
# carlcc <carlmarxchen@foxmail.com>, 2018.
# cavenzhong <cavenzhong@gmail.com>, 2018.
# cloudapex <cloudapex@126.com>, 2018.
# congcong <3546952960@qq.com>, 2018.
# Dante Lucifer <firecloud888@gmail.com>, 2018.
# DKLost <514dklost@gmail.com>, 2018.
# Geequlim <geequlim@gmail.com>, 2018.
# Griant <goooosick@gmail.com>, 2018.
# griffenliu <tiansha7xing@163.com>, 2018.
# Haowen Liu <liu.haowen.andy@gmail.com>, 2018.
# Harlan Howell <lin_032@hotmail.com>, 2018.
# Hezekiah Ho <hyq1986@gmail.com>, 2018.
# hnclca <hnclca@qq.com>, 2019.
# Jack <skyturtur@gmail.com>, 2018.
# Jingtian Pan <panjingtian@126.com>, 2018.
# Joe Zhao <nikejaycn@gmail.com>, 2018.
# Jsheng <yangea@outlook.com>, 2019.
# kirk_king <kirk_kpt@163.com>, 2018.
# MrNewWorld <xcc1997@gmail.com>, 2018.
# neko mtclaw <mitsuclaws@gmail.com>, 2018.
# Oberon Zheng <360119124@qq.com>, 2018-2019.
# plumsky <x-wolf@163.com>, 2018.
# pokemonchw <admin@byayoi.org>, 2018.
# py_co <py_co@outlook.com>, 2018.
# RainVector <y2505418927@gmail.com>, 2018.
# redity su <2215523266@qq.com>, 2018.
# seanfy <everxiao@qq.com>, 2018.
# sersoong <seraphim945@qq.com>, 2018.
# SilMOON <chenminghui8899@gmail.com>, 2018.
# tangdou1 <1093505442@qq.com>, 2018.
# tf <1353699675@qq.com>, 2018.
# Toby <tianer2820@163.com>, 2018.
# ws00010203 <ws00010203@hotmail.com>, 2019.
# XQDD <1032453509@qq.com>, 2018.
# xuzheng <690089735@qq.com>, 2018.
# YANG <brankyy@gmail.com>, 2018.
# yuetian <18829280955@163.com>, 2018.
# yzt <834950797@qq.com>, 2018-2019.
# z <755287198@qq.com>, 2018.
# Zae Chao <zae.vito@live.com>, 2018.
# zaevi <526131722@qq.com>, 2018.
# Zhang Zhibo <zzhibo98@gmail.com>, 2019.
# zwj36028 <23732399@qq.com>, 2018.
# 七眼蜂 <txcism@gmail.com>, 2018.
# 刘庆文 <liuqingwen@163.com>, 2018.
# 小白newer <2551376741@qq.com>, 2018.
# 小菠萝粑粑 <2062152083@qq.com>, 2018.
# 秋纫 <dugucloud@qq.com>, 2019.
#
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: https://github.com/godotengine/godot-docs-l10n\n"
"POT-Creation-Date: 2019-03-28 09:54+0100\n"
"PO-Revision-Date: 2019-03-28 08:39+0000\n"
"Last-Translator: yzt <834950797@qq.com>\n"
"Language-Team: Chinese (Simplified) <https://hosted.weblate.org/projects/"
"godot-engine/godot-docs/zh_Hans/>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"
"X-Generator: Weblate 3.6-dev\n"

#: ../../docs/index.rst:2
msgid "Godot Docs – *master* branch"
msgstr "Godot 文档 - *主* 分支"

#: ../../docs/index.rst:6
msgid ""
"Godot's documentation is available in various languages and versions. Expand "
"the \"Read the Docs\" panel at the bottom of the sidebar to see the list."
msgstr ""
"戈多的帮助文档有多种语言和版本。打开侧栏底部的“阅读文档”按钮来查看可用列表。"

#: ../../docs/index.rst:10
msgid ""
"This is the documentation for the development (master) branch. Looking for "
"the documentation of the current **stable** branch? `Have a look here "
"<https://docs.godotengine.org/en/stable>`_."
msgstr ""
"这是不稳定(主)分支的文档。想要看当前 **稳定** 分支的文档? `请查看这里 "
"<http://docs.godotengine.org/en/stable>`_ 。"

#: ../../docs/index.rst:16
msgid ""
"This documentation is translated from the `original English one <https://"
"docs.godotengine.org/en/latest>`_ by community members on `Weblate <https://"
"hosted.weblate.org/projects/godot-engine/godot-docs>`_."
msgstr ""
"您可以帮助我们翻译或校对托管在 `Weblate <https://hosted.weblate.org/engage/"
"godot-engine/>`_ 上的官方Godot文档。"

#: ../../docs/index.rst:20
msgid ""
"Depending on the translation effort's completion level, you may find "
"paragraphs or whole pages which are still in English. You can help the "
"community by providing new translations or reviewing existing ones on "
"Weblate."
msgstr ""
"根据翻译工作的完成程度，您可能会发现段落或整页仍然是英文书写的。您可以通过在"
"Weblate上提供新的翻译或查看现有的翻译来帮助社区。"

#: ../../docs/index.rst:25
msgid ""
"For the time being, localized translations are only available for the "
"\"latest\" (development) branch, but should be suitable to learn how to use "
"stable Godot releases nevertheless."
msgstr ""
"目前，本地化翻译仅适用于最新(开发)分支版本，不过学习推荐使用Godot的稳定版本。"

#: ../../docs/index.rst:29
msgid ""
"Welcome to the official documentation of Godot Engine, the free and open "
"source community-driven 2D and 3D game engine! If you are new to this "
"documentation, we recommend that you read the :ref:`introduction page "
"<doc_about_intro>` to get an overview of what this documentation has to "
"offer."
msgstr ""
"欢迎来到Godot游戏引擎的官方文档，Godot引擎是一款免费，由开源社区驱动的2D和3D"
"游戏引擎！如果您是第一次看这个文档，我们建议您先阅读 :ref:`简介 "
"<doc_about_intro>` 以便对本文档所提供的内容有一个大概的了解。"

#: ../../docs/index.rst:34
msgid ""
"The table of contents below and in the sidebar should let you easily access "
"the documentation for your topic of interest. You can also use the search "
"function in the top left corner."
msgstr ""
"在内容下面和侧栏中的列表应让您可以轻松访问感兴趣主题的文档。您也可以使用左上"
"角的搜索功能。"

#: ../../docs/index.rst:38
msgid ""
"Godot Engine is an open source project developed by a community of "
"volunteers. The documentation team can always use your feedback and help to "
"improve the tutorials and class reference. If you don't understand "
"something, or cannot find what you are looking for in the docs, help us make "
"the documentation better by letting us know!"
msgstr ""
"Godot引擎是一个由自愿者社区开发的开源项目。文档团队可以随时使用您的反馈，并帮"
"助改进教程和类型参考。如果您有不明白，或无法在文档中找到您要查找的内容，请告"
"知我们以帮助我们更好地编写文档！"

#: ../../docs/index.rst:45
msgid ""
"Submit an issue or pull request on the `GitHub repository <https://github."
"com/godotengine/godot-docs/issues>`_, help us `translate the documentation "
"<https://hosted.weblate.org/engage/godot-engine/>`_ into your language, or "
"talk to us on either the ``#documentation`` channel on `Discord <https://"
"discord.gg/zH7NUgz>`_, or the ``#godotengine-doc`` channel on `irc.freenode."
"net <http://webchat.freenode.net/?channels=#godotengine-doc>`_!"
msgstr ""
"在 `GitHub仓库 <https://github.com/godotengine/godot-docs/issues>`_ 上提交问"
"题或提交请求，帮助我们将 `文档 <https://hosted.weblate.org/engage/godot-"
"engine/>`_ 翻译成您的语言，或者在 `Discord <https://discord.gg/zH7NUgz>`_ 的 "
"``#documentation`` 频道，或 `irc.freenode.net <http://webchat.freenode.net/?"
"channels=#godotengine-doc>`_ 的 ``#godotengine-doc`` 频道中和我们交流!"

#: ../../docs/index.rst:59
msgid ""
"The main documentation for the site is organized into the following sections:"
msgstr "该网站的文档主要是按照以下章节形式来组织的:"

#: ../../docs/index.rst:61
msgid "General"
msgstr "常规"

#: ../../docs/index.rst:69
msgid "Getting started"
msgstr "入门"

#: ../../docs/index.rst:80
msgid "Tutorials"
msgstr "教程"

#: ../../docs/index.rst:108
msgid "Development"
msgstr "开发"

#: ../../docs/index.rst:118
msgid "Community"
msgstr "社区"

#: ../../docs/about/index.rst:2
#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:7
#: ../../docs/tutorials/inputs/mouse_and_input_coordinates.rst:7
#: ../../docs/development/cpp/variant_class.rst:7
msgid "About"
msgstr "关于"

#: ../../docs/about/introduction.rst:4
#: ../../docs/getting_started/step_by_step/scenes_and_nodes.rst:7
#: ../../docs/getting_started/step_by_step/instancing.rst:7
#: ../../docs/getting_started/step_by_step/scripting.rst:7
#: ../../docs/getting_started/step_by_step/signals.rst:7
#: ../../docs/getting_started/step_by_step/animations.rst:7
#: ../../docs/getting_started/step_by_step/filesystem.rst:7
#: ../../docs/getting_started/step_by_step/scene_tree.rst:7
#: ../../docs/getting_started/step_by_step/singletons_autoload.rst:7
#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:7
#: ../../docs/getting_started/scripting/c_sharp/c_sharp_basics.rst:4
#: ../../docs/getting_started/workflow/project_setup/project_organization.rst:7
#: ../../docs/getting_started/workflow/export/feature_tags.rst:7
#: ../../docs/getting_started/workflow/best_practices/introduction_best_practices.rst:4
#: ../../docs/tutorials/2d/2d_transforms.rst:7
#: ../../docs/tutorials/2d/using_tilemaps.rst:7
#: ../../docs/tutorials/2d/2d_movement.rst:7
#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:7
#: ../../docs/tutorials/2d/2d_meshes.rst:7
#: ../../docs/tutorials/3d/using_transforms.rst:7
#: ../../docs/tutorials/3d/3d_performance_and_limitations.rst:7
#: ../../docs/tutorials/3d/spatial_material.rst:7
#: ../../docs/tutorials/3d/lights_and_shadows.rst:7
#: ../../docs/tutorials/3d/reflection_probes.rst:7
#: ../../docs/tutorials/3d/gi_probes.rst:7
#: ../../docs/tutorials/3d/baked_lightmaps.rst:7
#: ../../docs/tutorials/3d/high_dynamic_range.rst:7
#: ../../docs/tutorials/3d/using_gridmaps.rst:7
#: ../../docs/tutorials/3d/using_multi_mesh_instance.rst:7
#: ../../docs/tutorials/audio/audio_buses.rst:7
#: ../../docs/tutorials/audio/audio_streams.rst:7
#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:7
#: ../../docs/tutorials/physics/ray-casting.rst:7
#: ../../docs/tutorials/physics/ragdoll_system.rst:7
#: ../../docs/tutorials/physics/kinematic_character_2d.rst:7
#: ../../docs/tutorials/math/vector_math.rst:7
#: ../../docs/tutorials/math/matrices_and_transforms.rst:7
#: ../../docs/tutorials/animation/2d_skeletons.rst:7
#: ../../docs/tutorials/animation/animation_tree.rst:7
#: ../../docs/tutorials/io/saving_games.rst:7
#: ../../docs/tutorials/i18n/internationalizing_games.rst:7
#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:7
#: ../../docs/tutorials/viewports/viewports.rst:7
#: ../../docs/tutorials/viewports/using_viewport_as_texture.rst:7
#: ../../docs/tutorials/viewports/custom_postprocessing.rst:7
#: ../../docs/tutorials/shading/shading_reference/shaders.rst:7
#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:7
#: ../../docs/tutorials/shading/shader_materials.rst:7
#: ../../docs/tutorials/shading/screen-reading_shaders.rst:7
#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:7
#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:7
#: ../../docs/tutorials/shading/advanced_postprocessing.rst:7
#: ../../docs/tutorials/networking/ssl_certificates.rst:7
#: ../../docs/tutorials/assetlib/uploading_to_assetlib.rst:7
#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:7
#: ../../docs/tutorials/plugins/editor/import_plugins.rst:7
#: ../../docs/tutorials/plugins/editor/spatial_gizmos.rst:7
#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:7
#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:7
#: ../../docs/tutorials/misc/binary_serialization_api.rst:7
#: ../../docs/tutorials/debug/overview_of_debugging_tools.rst:7
#: ../../docs/development/cpp/custom_resource_format_loaders.rst:7
#: ../../docs/development/cpp/custom_audiostreams.rst:7
#: ../../docs/development/cpp/custom_godot_servers.rst:7
#: ../../docs/development/cpp/creating_android_modules.rst:7
msgid "Introduction"
msgstr "简介"

#: ../../docs/about/introduction.rst:11
msgid ""
"Welcome to the official documentation of Godot Engine, the free and open "
"source community-driven 2D and 3D game engine! Behind this mouthful, you "
"will find a powerful yet user-friendly tool that you can use to develop any "
"kind of game, for any platform and with no usage restriction whatsoever."
msgstr ""
"欢迎使用Godot引擎的正式文档, 这是一个由免费开源社区驱动的2D 和3D 游戏引擎!在"
"此之后, 您将发现一个功能强大但十分友好的工具, 您可以使用它开发任何类型的游"
"戏, 发布在任何平台, 并且没有任何使用限制。"

#: ../../docs/about/introduction.rst:16
msgid ""
"This page gives a broad presentation of the engine and of the contents of "
"this documentation, so that you know where to start if you are a beginner or "
"where to look if you need info on a specific feature."
msgstr ""
"本页旨在对引擎和本文档的内容进行广泛的介绍, 以便初学者知道从什么地方开始学习"
"和查找有关特定功能的信息。"

#: ../../docs/about/introduction.rst:21
msgid "About Godot Engine"
msgstr "关于Godot引擎"

#: ../../docs/about/introduction.rst:23
msgid ""
"A game engine is a complex tool, and it is therefore difficult to present "
"Godot in a few words. Here's a quick synopsis, which you are free to reuse "
"if you need a quick writeup about Godot Engine."
msgstr ""
"游戏引擎是一个复杂的工具, 因此很难用三言两语来概括Godot。不管怎样我们还是在这"
"提供了公关介绍, 如果您想写一篇关于Godot引擎的简短介绍，那么您可以自由的使用它"
"们。"

#: ../../docs/about/introduction.rst:27
msgid ""
"Godot Engine is a feature-packed, cross-platform game engine to create 2D "
"and 3D games from a unified interface. It provides a comprehensive set of "
"common tools, so users can focus on making games without having to reinvent "
"the wheel. Games can be exported in one click to a number of platforms, "
"including the major desktop platforms (Linux, macOS, Windows) as well as "
"mobile (Android, iOS) and web-based (HTML5) platforms."
msgstr ""
"Godot引擎是一个功能丰富，跨平台且使用友好界面来制作2D和3D游戏的引擎。它提供了"
"大量的工具让开发者可以将更多的心思花在做游戏上而不是开发这些工具。游戏支持一"
"键导出到多个平台，包括主流操作系统(Linux，macOS，Windows)以及移动端(Android，"
"iOS)和网页端(HTML5)。"

#: ../../docs/about/introduction.rst:34
msgid ""
"Godot is completely free and open source under the permissive MIT license. "
"No strings attached, no royalties, nothing. Users' games are theirs, down to "
"the last line of engine code. Godot's development is fully independent and "
"community-driven, empowering users to help shape their engine to match their "
"expectations. It is supported by the `Software Freedom Conservancy <https://"
"sfconservancy.org>`_ not-for-profit."
msgstr ""
"Godot在非常宽松的MIT许可证下完全免费且开源。没有附加条文，没有特许权使用费，"
"没有任何要求。用户的游戏乃至引擎的每一行代码，都属于他们自己。Godot的开发是完"
"全独立且社区驱动的，允许用户按照自己的期望去塑他们的引擎。它受到 `软件自由保"
"护 <https://sfconservancy.org>`_ 非营利组织的支持。"

#: ../../docs/about/introduction.rst:41
msgid ""
"For a more in-depth view of the engine, you are encouraged to read this "
"documentation further, especially the :ref:`Step by step <toc-learn-"
"step_by_step>` tutorial."
msgstr ""
"为了更深入地了解该引擎，建议您进一步阅读本文档，特别是 :ref:`Step by step "
"<toc-learn-step_by_step>` 教程。"

#: ../../docs/about/introduction.rst:46
msgid "About the documentation"
msgstr "关于文档"

#: ../../docs/about/introduction.rst:48
msgid ""
"This documentation is continuously written, corrected, edited, and revamped "
"by members of the Godot Engine community. It is edited via text files in the "
"`reStructuredText <http://www.sphinx-doc.org/en/stable/rest.html>`_ markup "
"language and then compiled into a static website/offline document using the "
"open source `Sphinx <http://www.sphinx-doc.org>`_ and `ReadTheDocs <https://"
"readthedocs.org/>`_ tools."
msgstr ""
"本文档由Godot Engine社区的成员持续编写，更正，编辑和修改。它的文本文件由 "
"`reStructuredText <http://www.sphinx-doc.org/en/stable/rest.html>`_ 标记语言"
"进行编辑，然后使用开源工具 `Sphinx <http://www.sphinx-doc.org>`_ 与 "
"`ReadTheDocs <https://readthedocs.org/>`_ 编译成一个静态网站和离线文档。"

#: ../../docs/about/introduction.rst:55
msgid ""
"You can contribute to Godot's documentation by opening issue tickets or "
"sending patches via pull requests on its GitHub `source repository <https://"
"github.com/godotengine/godot-docs>`_, or translating it into your language "
"on `Hosted Weblate <https://hosted.weblate.org/projects/godot-engine/godot-"
"docs/>`_."
msgstr ""
"您可以为Godot文档作出贡献，在GitHub `源码仓库 <https://github.com/"
"godotengine/godot-docs>`_ 中提出问题或提交推送请求。或者在 `Hosted Weblate "
"<https://hosted.weblate.org/projects/godot-engine/godot-docs/>`_ 上把它翻译成"
"您的语言。"

#: ../../docs/about/introduction.rst:61
msgid ""
"All the contents are under the permissive Creative Commons Attribution 3.0 "
"(`CC-BY 3.0 <https://creativecommons.org/licenses/by/3.0/>`_) license, with "
"attribution to \"Juan Linietsky, Ariel Manzur and the Godot Engine community"
"\"."
msgstr ""
"文档的所有内容都由Creative Commons Attribution 3.0(`CC-BY 3.0 <https://"
"creativecommons.org/licenses/by/3.0/>`_ )许可证签署, 版权归 \"娟(Juan "
"Linietsky), Ariel Manzur 和Godot引擎社区\" 所有。"

#: ../../docs/about/introduction.rst:66
msgid "Organization of the documentation"
msgstr "文件组织"

#: ../../docs/about/introduction.rst:68
msgid ""
"This documentation is organised in five sections with an impressively "
"unbalanced distribution of contents – but the way it is split up should be "
"relatively intuitive:"
msgstr ""
"文档由五部分组成。虽然内容分布很不均衡，但是内容分割的方法还是很直观的:"

#: ../../docs/about/introduction.rst:72
msgid ""
"The :ref:`sec-general` section contains this introduction as well as "
"information about the engine, its history, its licensing, authors, etc. It "
"also contains the :ref:`doc_faq`."
msgstr ""
":ref:`sec-general` 部分包括简介、关于引擎的信息、历史、许可证和作者等。这部分"
"也包含 :ref:`doc_faq` 。"

#: ../../docs/about/introduction.rst:75
msgid ""
"The :ref:`sec-learn` section is the main *raison d'être* of this "
"documentation, as it contains all the necessary information on using the "
"engine to make games. It starts with the :ref:`Step by step <toc-learn-"
"step_by_step>` tutorial which should be the entry point for all new users."
msgstr ""
":ref:`sec-learn` 部分是这份文档存在的主要理由，因为它包含如何使用引擎制作游戏"
"所需要的所有信息。这一部分以 :ref:`Step by step <toc-learn-step_by_step>` 教"
"程开始。这个教程是所有新用户的学习起点。"

#: ../../docs/about/introduction.rst:80
msgid ""
"The :ref:`sec-tutorials` section can be read as needed, in any order. It "
"contains feature-specific tutorials and documentation."
msgstr ""
"另外， :ref:`sec-tutorials` 部分则可以根据您的需要以任意顺序去查阅。它包含了"
"很多功能特性的教程和文档。"

#: ../../docs/about/introduction.rst:82
msgid ""
"The :ref:`sec-devel` section is intended for advanced users and contributors "
"to the engine development, with information on compiling the engine, "
"developing C++ modules or editor plugins."
msgstr ""
":ref:`sec-devel` 部分是为高级用户以及引擎开发人员提供的，它包含了如何编译引"
"擎，开发C++组件和编辑器插件等信息。"

#: ../../docs/about/introduction.rst:85
msgid ""
"The :ref:`sec-community` section gives information related to contributing "
"to engine development and the life of its community, e.g. how to report "
"bugs, help with the documentation, etc. It also points to various community "
"channels like IRC and Discord and contains a list of recommended third-party "
"tutorials outside of this documentation."
msgstr ""
":ref:`sec-community` 部分提供了引擎开发和社区生态的相关信息，例如，如何反馈错"
"误、帮助改善文档等等。它还列出了各种社区频道，如 IRC、Discord，并推荐了一些包"
"含了除本文档之外的第三方教程。"

#: ../../docs/about/introduction.rst:90
msgid ""
"Finally, the :ref:`sec-class-ref` is the documentation of the Godot API, "
"which is also available directly within the engine's script editor. It is "
"generated automatically from a file in the main source repository, therefore "
"the generated files of the documentation are not meant to be modified. See :"
"ref:`doc_updating_the_class_reference` for details."
msgstr ""
"最后， :ref:`sec-class-ref` 部分是Godot API文档，您也可以在引擎的脚本编辑器中"
"直接查看。这部分是由源代码中的一个文件自动生成，而不是人为撰写的。更多信息请"
"查看 :ref:`doc_updating_the_class_reference`。"

#: ../../docs/about/introduction.rst:96
msgid ""
"In addition to this documentation you may also want to take a look at the "
"various `Godot demo projects <https://github.com/godotengine/godot-demo-"
"projects>`_."
msgstr ""
"除此之外, 您还可以学习各种 `Godot 示例项目 <https://github.com/godotengine/"
"godot-demo-projects>`_ 。"

#: ../../docs/about/introduction.rst:99
msgid "Have fun reading and making games with Godot Engine!"
msgstr "祝您愉快的学习Godot引擎并用它制作游戏！"

#: ../../docs/about/faq.rst:4
#: ../../docs/tutorials/assetlib/what_is_assetlib.rst:29
msgid "Frequently asked questions"
msgstr "常见问题"

#: ../../docs/about/faq.rst:7
msgid ""
"What can I do with Godot? How much does it cost? What are the license terms?"
msgstr "我可以用Godot做什么？用它需要花多少钱？它有哪些许可条款？"

#: ../../docs/about/faq.rst:9
msgid ""
"Godot is `Free and Open-Source Software <https://en.wikipedia.org/wiki/"
"Free_and_open-source_software>`_ available under the `OSI-approved <https://"
"opensource.org/licenses/MIT>`_ MIT license. This means it is free as in "
"\"free speech\" as well as in \"free beer.\""
msgstr ""
"Godot是 `自由和开源的软件 <https://en.wikipedia.org/wiki/Free_and_open-"
"source_software>`_ 可在 `OSI认可的<https://opensource.org/licenses/MIT>`_ MIT"
"许可证下使用。就像“言论自由”或者“免费啤酒”一样，它是自由的。"

#: ../../docs/about/faq.rst:11
msgid "In short:"
msgstr "总之:"

#: ../../docs/about/faq.rst:13
msgid ""
"You are free to download and use Godot for any purpose, personal, non-"
"profit, commercial, or otherwise;"
msgstr "您可以免费下载并使用Godot，用于任何，个人，非营利，商业或其他目的;"

#: ../../docs/about/faq.rst:14
msgid ""
"You are free to modify, distribute, redistribute, and remix Godot to your "
"heart's content, for any reason, both non-commercially and commercially."
msgstr "您可以自由修改, (重新) 分发和组织Godot的代码项目."

#: ../../docs/about/faq.rst:16
msgid ""
"All the contents of this accompanying documentation are published under the "
"permissive Creative Commons Attribution 3.0 (`CC-BY 3.0 <https://"
"creativecommons.org/licenses/by/3.0/>`_) license, with attribution to \"Juan "
"Linietsky, Ariel Manzur and the Godot Engine community.\""
msgstr ""
"本附带文档的所有内容均在许可的知识共享署名3.0 ( `CC-BY 3.0 <https://"
"creativecommons.org/licenses/by/3.0/>`_ ) 许可下发布，署名为“Juan Linietsky、"
"Ariel Manzur和Godot引擎社区”。"

#: ../../docs/about/faq.rst:20
msgid ""
"Logos and icons are generally under the same Creative Commons license. Note "
"that some third-party libraries included with Godot's source code may have "
"different licenses."
msgstr ""
"Logo徽标和图标均在相同的CC共享许可下。注意, Godot的源代码中包含的某些第三方库"
"可能具有不同的许可。"

#: ../../docs/about/faq.rst:24
msgid ""
"For full details, look at the `COPYRIGHT.txt <https://github.com/godotengine/"
"godot/blob/master/COPYRIGHT.txt>`_ as well as the `LICENSE.txt <https://"
"github.com/godotengine/godot/blob/master/LICENSE.txt>`_ and `LOGO_LICENSE."
"txt <https://github.com/godotengine/godot/blob/master/LOGO_LICENSE.md>`_ "
"files in the Godot repository."
msgstr ""
"有关完整的详细信息, 请查看Godot仓库中的 `COPYRIGHT.txt <https://github.com/"
"godotengine/godot/blob/master/COPYRIGHT.txt>`_ 以及 `LICENSE.txt <https://"
"github.com/godotengine/godot/blob/master/LICENSE.txt>`_ 和 `LOGO_LICENSE "
"<https://github.com/godotengine/godot/blob/master/LOGO_LICENSE.md>`_ 等文件。"

#: ../../docs/about/faq.rst:28
msgid ""
"Also, see `the license page on the Godot website <https://godotengine.org/"
"license>`_."
msgstr ""
"还可以查阅 `Godot网站上的许可页面 <https://godotengine.org/license>`_ ."

#: ../../docs/about/faq.rst:31
msgid "Which platforms are supported by Godot?"
msgstr "Godot支持哪些平台？"

#: ../../docs/about/faq.rst:33
msgid "**For the editor:**"
msgstr "**编辑器:**"

#: ../../docs/about/faq.rst:35
#: ../../docs/getting_started/scripting/c_sharp/c_sharp_basics.rst:39
#: ../../docs/tutorials/misc/jitter_stutter.rst:53
msgid "Windows"
msgstr "Windows"

#: ../../docs/about/faq.rst:36 ../../docs/about/faq.rst:42
#: ../../docs/tutorials/misc/jitter_stutter.rst:78
msgid "macOS"
msgstr "macOS系统"

#: ../../docs/about/faq.rst:37 ../../docs/about/faq.rst:43
msgid "X11 (Linux, \\*BSD)"
msgstr "X11(Linux,，\\*BSD)"

#: ../../docs/about/faq.rst:39
msgid "**For exporting your games:**"
msgstr "**导出游戏:**"

#: ../../docs/about/faq.rst:41
msgid "Windows (and UWP)"
msgstr "Windows (包括 UWP)"

#: ../../docs/about/faq.rst:44
#: ../../docs/getting_started/step_by_step/exporting.rst:186
#: ../../docs/tutorials/misc/jitter_stutter.rst:84
msgid "Android"
msgstr "Android"

#: ../../docs/about/faq.rst:45
#: ../../docs/getting_started/step_by_step/exporting.rst:238
#: ../../docs/tutorials/misc/jitter_stutter.rst:90
msgid "iOS"
msgstr "iOS"

#: ../../docs/about/faq.rst:46
msgid "Web"
msgstr "Web"

#: ../../docs/about/faq.rst:48
msgid ""
"Both 32- and 64-bit binaries are supported where it makes sense, with 64 "
"being the default."
msgstr "同时支持32位和64位的二进制文件，默认为64位。"

#: ../../docs/about/faq.rst:51
msgid ""
"Some users also report building and using Godot successfully on ARM-based "
"systems with Linux, like the Raspberry Pi."
msgstr ""
"有一些用户还报告指出使用Linux等成功地在基于ARM的系统上构建和使用Godot，比如树"
"莓派."

#: ../../docs/about/faq.rst:54
msgid ""
"Additionally, there is some unofficial third-party work being done on "
"building for some consoles. However, none of this is included in the default "
"build scripts or export templates at this time."
msgstr ""
"一些用户也报告了他们能在基于ARM的Linux系统上成功编译构建和使用Godot，比如树莓"
"派(Raspberry Pi)。一些第三方也做了一些针对主机平台的编译构建的工作。不过，这"
"些工作都没有包含在默认的构建脚本和导出模板中。"

#: ../../docs/about/faq.rst:58
msgid ""
"For more on this, see the sections on :ref:`exporting <toc-learn-workflow-"
"export>` and :ref:`compiling Godot yourself <toc-devel-compiling>`."
msgstr ""
"欲了解更多信息, 请参阅 :ref:`导出 <toc-learn-workflow-export>` 和 :ref:`编译"
"Godot <toc-devel-compiling>`."

#: ../../docs/about/faq.rst:62
msgid "Which programming languages are supported in Godot?"
msgstr "Godot支持哪些编程语言?"

#: ../../docs/about/faq.rst:64
msgid ""
"The officially supported languages for Godot are GDScript, Visual Scripting, "
"C#, and C++. See the subcategories for each language in the :ref:`scripting "
"<toc-learn-scripting>` section."
msgstr ""
"Godot官方支持的语言有纯脚本(GDScript)、可视化脚本(Visual Scripting)、C#和C+"
"+。具体请参阅 :ref:`游戏脚本 <toc-learn-scripting>` 下对应各语言的子章节。"

#: ../../docs/about/faq.rst:68
msgid ""
"If you are just starting out with either Godot or game development in "
"general, GDScript is the recommended language to learn and use since it is "
"native to Godot. While scripting languages tend to be less performant than "
"lower-level languages in the long run, for prototyping, developing Minimum "
"Viable Products (MVPs), and focusing on Time-To-Market (TTM), GDScript will "
"provide a fast, friendly, and capable way of developing your games."
msgstr ""
"如果您刚开始学习游戏开发，或者刚开始学习Godot，那么推荐您学习GDScript，因为"
"Godot使用它作为本地语言。从长远来看，脚本语言虽然比低级语言性能差，但是为了尽"
"快做出产品原型，开发出最小可行产品，以及赶上上市时间，GDScript可以提供快速，"
"友好，并且强大的功能，用于开发游戏。"

#: ../../docs/about/faq.rst:75
msgid ""
"Note that C# support is still relatively new, and as such, you may encounter "
"some issues along the way. Our friendly and hard-working development "
"community is always ready to tackle new problems as they arise, but since "
"this is an open-source project, we recommend that you first do some due "
"diligence yourself. Searching through discussions on `open issues <https://"
"github.com/godotengine/godot/issues>`_ is a great way to start your "
"troubleshooting."
msgstr ""
"对C#的支持仍然相当初级，所以，您可能会在使用过程中发现一些问题。友好而勤奋的"
"开发社区随时准备追踪新的问题。但是，本着开源的精神，我们建议您首先自己解决您"
"发现的问题。您也可以在 `开放问题 <https://github.com/godotengine/godot/"
"issues>`_ 中讨论您的问题。"

#: ../../docs/about/faq.rst:82
msgid ""
"As for new languages, support is possible via third parties using the "
"GDNative / NativeScript / PluginScript facilities. (See the question about "
"plugins below.) Work is currently underway, for example, on unofficial "
"bindings for Godot to `Python <https://github.com/touilleMan/godot-python>`_ "
"and `Nim <https://github.com/pragmagic/godot-nim>`_."
msgstr ""
"对于新编程语言的支持已经由第三方通过GDNative/Native Script/PluginScript实现"
"(请参考下面关于插件的问题)。目前已经在开展一些工作了，比如非官方绑定Godot和 "
"`Python <https://github.com/touilleMan/godot-python>`_ 以及 `Nim <https://"
"github.com/pragmagic/godot-nim>`_ 。"

#: ../../docs/about/faq.rst:88
msgid "What is GDScript and why should I use it?"
msgstr "GDScript是什么？为什么我要用它？"

#: ../../docs/about/faq.rst:90
#, fuzzy
msgid ""
"GDScript is Godot's integrated scripting language. It was built from the "
"ground up to maximize Godot's potential in the least amount of code, "
"affording both novice and expert developers alike to capitalize on Godot's "
"strengths as fast as possible. If you've ever written anything in a language "
"like Python before then you'll feel right at home. For examples, history, "
"and a complete overview of the power GDScript offers you, check out the :ref:"
"`GDScript scripting guide <doc_gdscript>`."
msgstr ""
"GDScript是Godot的集成脚本语言。您可以使用最少的代码，使用Godot中从细小到强大"
"的所有功能，它既适用于初学者，也适用于专家，您可以快速熟悉它。如果您以前使用"
"过Python之类的语言写过任何东西，您将会感到熟悉。如果您想要了解关于GDScript的"
"示例，历史，完整介绍和功能，查看 `GDScript脚本指南 <gdscript_basics>`_ 。"

#: ../../docs/about/faq.rst:97
msgid ""
"There are several reasons to use GDScript--especially when you are "
"prototyping, in alpha/beta stages of your project, or are not creating the "
"next AAA title--but the most salient reason is the overall **reduction of "
"complexity.**"
msgstr ""
"推荐您使用GDScript有多个原因——包括在制作产品原型，或者您的项目处在测试阶段"
"时，或者您没有在制作下一个3A大作——但是最重要的原因是 **较少复杂度。**"

#: ../../docs/about/faq.rst:101
msgid ""
"The original intent of creating a tightly integrated, custom scripting "
"language for Godot was two-fold: first, it reduces the amount of time "
"necessary to get up and running with Godot, giving developers a rapid way of "
"exposing themselves to the engine with a focus on productivity; second, it "
"reduces the overall burden of maintenance, attenuates the dimensionality of "
"issues, and allows the developers of the engine to focus on squashing bugs "
"and improving features related to the engine core--rather than spending a "
"lot of time trying to get a small set of incremental features working across "
"a large set of languages."
msgstr ""
"为Godot创造一个紧密集成，自定义的脚本语言的最初目的有两方面:首先，它能够减少"
"学习Godot的时间，给了开发者快速熟悉游戏引擎的方式。第二，它减少了开发负担，较"
"少出现问题的可能性，允许开发人员消除漏洞，专心提升与引擎相关的特性，而不是为"
"了增加一个简单的新特性而编写大量代码。"

#: ../../docs/about/faq.rst:109
msgid ""
"Since Godot is an open-source project, it was imperative from the start to "
"prioritize a more integrated and seamless experience over attracting "
"additional users by supporting more familiar programming languages--"
"especially when supporting those more familiar languages would result in a "
"worse experience. We understand if you would rather use another language in "
"Godot (see the list of supported options above). That being said, if you "
"haven't given GDScript a try, try it for **three days**. Just like Godot, "
"once you see how powerful it is and rapid your development becomes, we think "
"GDScript will grow on you."
msgstr ""
"由于Godot是一个开源项目，因此从一开始就必须优先考虑更集成和无缝的体验，而不是"
"通过支持更熟悉的编程语言来吸引更多的用户——特别是当支持那些更熟悉的语言会导致"
"更糟糕的体验时。我们理解您是否愿意在Godot中使用另一种语言(请参阅上面支持的选"
"项列表)。也就是说，如果您还没有试过GDScript，那就尝试三天吧。就像Godot一样，"
"一旦您看到了它的强大和快速的发展，我们认为GDScript会在您身上得到成长。"

#: ../../docs/about/faq.rst:118
msgid ""
"More information about getting comfortable with GDScript or dynamically "
"typed languages can be found in the :ref:`doc_gdscript_more_efficiently` "
"tutorial."
msgstr ""
"有关使用GDScript或动态类型语言的更多信息，请参阅教程 :ref:"
"`doc_gdscript_more_efficiently`。"

#: ../../docs/about/faq.rst:122
msgid "What were the motivations behind creating GDScript?"
msgstr "为什么要Godot要自己造轮子(GDScript)呢？"

#: ../../docs/about/faq.rst:124
msgid ""
"The main reasons for creating a custom scripting language for Godot were:"
msgstr "为Godot创建自定义的脚本语言的原因是:"

#: ../../docs/about/faq.rst:126
msgid ""
"Poor thread support in most script VMs, and Godot uses threads (Lua, Python, "
"Squirrel, JS, AS, etc.)."
msgstr ""
"Godot引擎使用线程，但大多数虚拟机都没有很好的线程支持(比如:Lua、Python、"
"Squirrel、JS、AS等)。"

#: ../../docs/about/faq.rst:128
msgid ""
"Poor class-extending support in most script VMs, and adapting to the way "
"Godot works is highly inefficient (Lua, Python, JS)."
msgstr ""
"大多数虚拟机没有很好地支持类扩展，开发Godot时配合起来性能效率极低(Lua、"
"Python、JS)。"

#: ../../docs/about/faq.rst:130
msgid ""
"Many existing languages have horrible interfaces for binding to C++, "
"resulting in large amount of code, bugs, bottlenecks, and general "
"inefficiency (Lua, Python, Squirrel, JS, etc.) We wanted to focus on a great "
"engine, not a great amount of integrations."
msgstr ""
"与C++绑定而产生的糟糕接口会导致数量庞大的代码、BUG、瓶颈，以及普遍的效率低下"
"(Lua、Python、Squirrel、JS等)。我们希望专注于一个强大的引擎而不是大量的整合。"

#: ../../docs/about/faq.rst:133
msgid ""
"No native vector types (vector3, matrix4, etc.), resulting in highly reduced "
"performance when using custom types (Lua, Python, Squirrel, JS, AS, etc.)."
msgstr ""
"没有内置向量类型(vector3、matrix4等)，而用自定义类型实现这些类型会大幅降低性"
"能(Lua、Python、Squirrel、JS、AS等)。"

#: ../../docs/about/faq.rst:136
msgid ""
"Garbage collector results in stalls or unnecessarily large memory usage "
"(Lua, Python, JS, AS, etc.)."
msgstr "垃圾回收器不容易控制或浪费大量内存(Lua、Python、JS、AS等)。"

#: ../../docs/about/faq.rst:138
msgid ""
"Difficulty to integrate with the code editor for providing code completion, "
"live editing, etc. (all of them). This is well supported by GDScript."
msgstr ""
"难以与Godot代码编辑器集成从而支持代码补全、动态编辑等等。但这方面GDScript支持"
"得很好。"

#: ../../docs/about/faq.rst:142
msgid "GDScript was designed to curtail the issues above and more."
msgstr "GDScript的出现就是为了解决以上问题。"

#: ../../docs/about/faq.rst:145
msgid "What type of 3D model formats does Godot support?"
msgstr "Godot支持哪些3D模型格式?"

#: ../../docs/about/faq.rst:147
msgid ""
"Godot supports Collada via the `OpenCollada <https://github.com/KhronosGroup/"
"OpenCOLLADA/wiki/OpenCOLLADA-Tools>`_ exporter (Maya, 3DSMax)."
msgstr ""
"Godot 通过 `OpenCollada <https://github.com/KhronosGroup/OpenCOLLADA/wiki/"
"OpenCOLLADA-Tools>`_ 导出插件(Maya, 3DSMax)以支持Collada。"

#: ../../docs/about/faq.rst:149
msgid ""
"If you are using Blender, take a look at our own `Better Collada Exporter "
"<https://godotengine.org/download>`_."
msgstr ""
"如果您使用的是Blender，请查看我们自己的 `Better Collada Exporter <https://"
"godotengine.org/download>`_ 插件。"

#: ../../docs/about/faq.rst:151
msgid "As of Godot 3.0, glTF is supported."
msgstr "Godot从3.0版本开始支持gITF。"

#: ../../docs/about/faq.rst:153
msgid ""
"FBX SDK has a `restrictive license <https://www.blender.org/bf/"
"Autodesk_FBX_License.rtf>`_, that is incompatible with the `open license "
"<https://opensource.org/licenses/MIT>`_ provided by Godot. That being said, "
"FBX support could still be provided by third parties as a plugin. (See "
"Plugins question above.)"
msgstr ""
"FBX SDK具有 `限制性许可 <https://www.blender.org/bf/Autodesk_FBX_License."
"rtf>`_ ，与Godot提供的 `开放许可 <https://opensource.org/licenses/MIT>`_ 不兼"
"容。尽管如此，FBX支持仍然可以由第三方作为插件提供。(参见上面插件的问题。)"

#: ../../docs/about/faq.rst:159
msgid ""
"Will [insert closed SDK such as FMOD, GameWorks, etc.] be supported in Godot?"
msgstr "能否在Godot中加入闭源SDK，比如FMOD、GameWorks等？"

#: ../../docs/about/faq.rst:161
msgid ""
"The aim of Godot is to create a free and open-source MIT-licensed engine "
"that is modular and extendable. There are no plans for the core engine "
"development community to support any third-party, closed-source/proprietary "
"SDKs, as integrating with these would go against Godot's ethos."
msgstr ""
"Godot的目的是创建一个免费以MIT许可开源的引擎，而且是模块化和可拓展的。核心引"
"擎开发社区没有计划支持任何第三方闭源或专有SDK，因为这些SDK的集成会违背Godot的"
"精神。"

#: ../../docs/about/faq.rst:166
msgid ""
"That said, because Godot is open-source and modular, nothing prevents you or "
"anyone else interested in adding those libraries as a module and shipping "
"your game with them--as either open- or closed-source."
msgstr ""
"也就是说，因为它是开源的，模块化的，所以开发者们可以任意地添加使用这些库，并"
"发布游戏，无论开源或闭源。万事皆允。"

#: ../../docs/about/faq.rst:170
msgid ""
"To see how support for your SDK of choice could still be provided, look at "
"the Plugins question above."
msgstr "欲了解如何支持您想用的SDK，请查看上面的插件问题。"

#: ../../docs/about/faq.rst:173
msgid ""
"If you know of a third-party SDK that is not supported by Godot but that "
"offers free and open-source integration, consider starting the integration "
"work yourself. Godot is not owned by one person; it belongs to the "
"community, and it grows along with ambitious community contributors like you."
msgstr ""
"如果您知道Godot不支持但是想提供免费和开源集成的第三方SDK，请考虑自己开始集成"
"工作。Godot不属于一个人; 它属于社区，它与像您一样雄心勃勃的社区贡献者一起成"
"长。"

#: ../../docs/about/faq.rst:179
msgid ""
"How should assets be created to handle multiple resolutions and aspect "
"ratios?"
msgstr "如何处理多分辨率和长宽比的问题？"

#: ../../docs/about/faq.rst:181
msgid ""
"This question pops up often and it's probably thanks to the misunderstanding "
"created by Apple when they originally doubled the resolution of their "
"devices. It made people think that having the same assets in different "
"resolutions was a good idea, so many continued towards that path. That "
"originally worked to a point and only for Apple devices, but then several "
"Android and Apple devices with different resolutions and aspect ratios were "
"created, with a very wide range of sizes and DPIs."
msgstr ""
"这个问题很常见，可能要归功于苹果公司。苹果一开始将它们的设备分辨率加倍，让人"
"觉得不同分辨率使用相同的资源是个好主意，所以很多人就这么做下去了。起初只有苹"
"果设备这么做，但安卓和后来的苹果设备又有了不同的分辨率和宽高比，它们的大小和"
"DPI变得多种多样。"

#: ../../docs/about/faq.rst:189
msgid ""
"The most common and proper way to achieve this is to, instead, use a single "
"base resolution for the game and only handle different screen aspect ratios. "
"This is mostly needed for 2D, as in 3D it's just a matter of Camera XFov or "
"YFov."
msgstr ""
"然而，最常见且正确的处理方法是，在常规分辨率下开发游戏、然后只处理的屏幕适配"
"方面的问题。一般2D需要这么做，因为3D只需要处理相机的XFov或YFov。"

#: ../../docs/about/faq.rst:193
msgid ""
"Choose a single base resolution for your game. Even if there are devices "
"that go up to 2K and devices that go down to 400p, regular hardware scaling "
"in your device will take care of this at little or no performance cost. Most "
"common choices are either near 1080p (1920x1080) or 720p (1280x720). Keep in "
"mind the higher the resolution, the larger your assets, the more memory they "
"will take and the longer the time it will take for loading."
msgstr ""
"为游戏选一个常规分辨率。即使有高达2K或低至400p的设备，它们硬件缩放也能以低耗"
"甚至无消耗的性能来处理分辨率。通常选择1080p(1920x1080)或720p(1280x720)。注"
"意，分辨率越高，资源越多，它们需要的内存就越多，加载所需时间也会越长。"

#: ../../docs/about/faq.rst:201
msgid ""
"Use the stretch options in Godot, 2D stretching with keeping aspect works "
"best. Check the :ref:`doc_multiple_resolutions` tutorial on how to achieve "
"this."
msgstr ""
"使用Godot中的拉伸(Stretch)选项，2D的保持拉伸效果最好。参阅教程 :ref:"
"`doc_multiple_resolutions` 来学习如何实现它。"

#: ../../docs/about/faq.rst:205
msgid ""
"Determine a minimum resolution and then decide if you want your game to "
"stretch vertically or horizontally for different aspect ratios, or whether "
"there is a minimum one and you want black bars to appear instead. This is "
"also explained in the previous step."
msgstr ""
"确定最小分辨率，然后决定是否让游戏根据不同的纵横比进行垂直或水平拉伸，或者在"
"想要显示黑边的情况下确定一个最小分辨率。这在前面的步骤中有所解释。"

#: ../../docs/about/faq.rst:210
msgid ""
"For user interfaces, use the :ref:`anchoring <doc_size_and_anchors>` to "
"determine where controls should stay and move. If UIs are more complex, "
"consider learning about Containers."
msgstr ""
"对于用户界面，使用 :ref:`anchoring <doc_size_and_anchors>` 来确定控件应停留或"
"移动的位置。如果UI比较复杂，则考虑使用一下容器。"

#: ../../docs/about/faq.rst:214
msgid "And that's it! Your game should work in multiple resolutions."
msgstr "就是这样！您的游戏现在应该能适应多分辨率了。"

#: ../../docs/about/faq.rst:216
msgid ""
"If there is a desire to make your game also work on ancient devices with "
"tiny screens (fewer than 300 pixels in width), you can use the export option "
"to shrink images, and set that build to be used for certain screen sizes in "
"the App Store or Google Play."
msgstr ""
"如果真的要让您的游戏在超小屏幕(宽度小于300像素)的老设备上工作，可以在导出选项"
"中缩小图像，并且在App Store或Google Play中将它设为用于特定的屏幕大小。"

#: ../../docs/about/faq.rst:222
msgid "How can I extend Godot?"
msgstr "我要如何扩展Godot？"

#: ../../docs/about/faq.rst:224
msgid ""
"For extending Godot, like creating Godot Editor plugins or adding support "
"for additional languages, take a look at :ref:`EditorPlugins "
"<doc_making_plugins>` and tool scripts."
msgstr ""
"如果想开发编辑器插件，请参阅 :ref:`编辑器插件 <doc_making_plugins>` 和插件脚"
"本。"

#: ../../docs/about/faq.rst:228
msgid "Also, see the official blog posts on these topics:"
msgstr "另外，可在官方博客帖子查看这些话题:"

#: ../../docs/about/faq.rst:230
msgid ""
"`A look at the GDNative architecture <https://godotengine.org/article/look-"
"gdnative-architecture>`_"
msgstr ""
"`GDNative结构概览 <https://godotengine.org/article/look-gdnative-"
"architecture>`_"

#: ../../docs/about/faq.rst:231
msgid "`GDNative is here! <https://godotengine.org/article/dlscript-here>`_"
msgstr "`GDNative来了! <https://godotengine.org/article/dlscript-here>`_"

#: ../../docs/about/faq.rst:233
msgid ""
"You can also take a look at the GDScript implementation, the Godot modules, "
"as well as the `unofficial Python support <https://github.com/touilleMan/"
"godot-python>`_ for Godot. This would be a good starting point to see how "
"another third-party library integrates with Godot."
msgstr ""
"您还可以查看GDScript的实现，Godot模组以及 `Godot的非官方Python支持 <https://"
"github.com/touilleMan/godot-python>`_ 。这个将是您了解如何将第三方库整合到"
"Godot中的第一步。"

#: ../../docs/about/faq.rst:239
msgid "I would like to contribute! How can I get started?"
msgstr "我也想为Godot贡献，那么我可以从哪里开始呢？"

#: ../../docs/about/faq.rst:241
msgid ""
"Awesome! As an open-source project, Godot thrives off of the innovation and "
"ambition of developers like you."
msgstr ""
"太棒了!作为一个开源项目，Godot的发展得益于像您这样的开发者的创新和雄心。"

#: ../../docs/about/faq.rst:244
msgid ""
"The first place to get started is in the `issues <https://github.com/"
"godotengine/godot/issues>`_. Find an issue that resonates with you, then "
"proceed to the `How to Contribute <https://github.com/godotengine/godot/blob/"
"master/CONTRIBUTING.md#contributing-pull-requests>`_ guide to learn how to "
"fork, modify, and submit a Pull Request (PR) with your changes."
msgstr ""
"首先要从 `问题 <https://github.com/godotengine/godot/issues>`_ 开始。找到一个"
"与您产生共鸣的问题，然后继续阅读 `如何贡献 <https://github.com/godotengine/"
"godot/blob/master/CONTRIBUTING.md#contributing-pull-requests>`_ 指南，学习如"
"何使用更改派生、修改和提交Pull Request (PR)。"

#: ../../docs/about/faq.rst:249
msgid "I have a great idea for Godot. How can I share it?"
msgstr "我有一个关于Godot的好主意。我如何分享它?"

#: ../../docs/about/faq.rst:251
msgid ""
"It might be tempting to want to bring ideas to Godot, like ones that result "
"in massive core changes, some sort of mimicry of what another game engine "
"does, or alternative workflows that you'd like built into the editor. These "
"are great and we are thankful to have such motivated people want to "
"contribute, but Godot's focus is and always will be the core functionality "
"as outlined in the `Roadmap <https://github.com/godotengine/godot-roadmap/"
"blob/master/ROADMAP.md>`_, `squashing bugs and addressing issues <https://"
"github.com/godotengine/godot/issues>`_, and conversations between Godot "
"community members."
msgstr ""
"想要把一些想法带给Godot会很诱人，比如导致大量核心变化的想法，某种模仿其他游戏"
"引擎所做的事情，或者您想要在编辑器中构建另一种工作流程。 这些都是伟大的，我们"
"感谢有这些想要贡献的积极的人，但Godot的焦点的方向是并始终是在 ‘路线图 "
"<https://github.com/godotengine/godot-roadmap/blob/master/ROADMAP.md>`_ 中概"
"述的核心功能。 `解决bug和解决问题 <https://github.com/godotengine/godot/"
"issues>`_ ，以及与Godot社区成员之间的对话。"

#: ../../docs/about/faq.rst:260
msgid ""
"Most developers in the Godot community will be more interested to learn "
"about things like:"
msgstr "Godot社区的大多数开发者会更感兴趣的是:"

#: ../../docs/about/faq.rst:263
msgid ""
"Your experience using the software and the problems you have (we care about "
"this much more than ideas on how to improve it)."
msgstr "您的引擎使用经历和您遇到的问题(我们关心的远不止如何改进它)。"

#: ../../docs/about/faq.rst:265
msgid ""
"The features you would like to see implemented because you need them for "
"your project."
msgstr "您希望实现的功能，因为您想要用到您的项目上。"

#: ../../docs/about/faq.rst:267
msgid ""
"The concepts that were difficult to understand while learning the software."
msgstr "学习引擎时遇到的哪些难以理解的概念。"

#: ../../docs/about/faq.rst:268
msgid "The parts of your workflow you would like to see optimized."
msgstr "您希望优化的部分或者开发流程。"

#: ../../docs/about/faq.rst:269
msgid ""
"Parts where you missed clear tutorials or where the documentation wasn't "
"clear."
msgstr "教程不全的部分或者文档不清晰的部分。"

#: ../../docs/about/faq.rst:271
msgid ""
"Please don't feel like your ideas for Godot are unwelcome. Instead, try to "
"reformulate them as a problem first, so developers and the community have a "
"functional foundation to ground your ideas on."
msgstr ""
"因此，请不要觉得您对Godot的想法是不受欢迎的。相反，首先尝试将它们作为问题提出"
"来，这样开发人员和社区才能针对它们去讨论。"

#: ../../docs/about/faq.rst:275
msgid ""
"A good way to approach sharing your ideas and problems with the community is "
"as a set of user stories. Explain what you are trying to do, what behavior "
"you expect to happen, and then what behavior actually happened. Framing "
"problems and ideas this way will help the whole community stay focused on "
"improving developer experiences as a whole."
msgstr ""
"与社区分享您的想法和问题的一个好方法是用案例来说明。解释您想做什么，您期望发"
"生什么行为，然后实际发生什么行为。体现问题和想法，这样将有助于整个社区专注于"
"改善开发者的经验作为一个整体。"

#: ../../docs/about/faq.rst:281
msgid ""
"Bonus points for bringing screenshots, concrete numbers, test cases, or "
"example projects (if applicable)."
msgstr "最好可以附上截图、具体数值、测试用例或示例项目(如果有的话)。"

#: ../../docs/about/faq.rst:285
msgid "How can I support Godot development or contribute?"
msgstr "我要怎样支持或参与Godot的发展呢？"

#: ../../docs/about/faq.rst:287
msgid "See :ref:`doc_ways_to_contribute`."
msgstr "参阅 :ref:`doc_ways_to_contribute`。"

#: ../../docs/about/faq.rst:290
msgid "Who is working on Godot? How can I contact you?"
msgstr "谁在为Godot工作？我该如何联系你们？"

#: ../../docs/about/faq.rst:292
msgid ""
"See the corresponding page on the `Godot website <https://godotengine.org/"
"contact>`_."
msgstr "请参照 `Godot官网 <https://godotengine.org/contact>`_ 上的相应页面。"

#: ../../docs/about/docs_changelog.rst:4
#, fuzzy
msgid "Documentation changelog"
msgstr "文件指南"

#: ../../docs/about/docs_changelog.rst:6
msgid ""
"The documentation is continually being improved. The release of version 3.1 "
"includes many new tutorials, many fixes and updates for old tutorials, and "
"many updates to the class reference. Below is a list of new tutorials added "
"since version 3.0."
msgstr ""

#: ../../docs/about/docs_changelog.rst:10
msgid ""
"This document only contains new tutorials so not all changes are reflected, "
"many tutorials have been substantially updated but are not reflected in this "
"document."
msgstr ""

#: ../../docs/about/docs_changelog.rst:14
msgid "New tutorials since version 3.0"
msgstr ""

#: ../../docs/about/docs_changelog.rst:17
#, fuzzy
msgid "Step-by-step"
msgstr "入门教程"

#: ../../docs/about/docs_changelog.rst:19
#, fuzzy
msgid ":ref:`Signals <doc_signals>`"
msgstr ":ref:`Basis <class_Basis>`"

#: ../../docs/about/docs_changelog.rst:20
#, fuzzy
msgid ":ref:`Exporting <doc_exporting>`"
msgstr ":ref:`String <class_String>`"

#: ../../docs/about/docs_changelog.rst:23
#: ../../docs/getting_started/workflow/index.rst:2
msgid "Project workflow"
msgstr "项目工作流程"

#: ../../docs/about/docs_changelog.rst:34
#, fuzzy
msgid "Best Practices:"
msgstr "最佳做法"

#: ../../docs/about/docs_changelog.rst:25
msgid ":ref:`Introduction <doc_introduction_best_practices>`"
msgstr ""

#: ../../docs/about/docs_changelog.rst:26
msgid ":ref:`What are Godot classes <doc_what_are_godot_classes>`"
msgstr ""

#: ../../docs/about/docs_changelog.rst:27
#, fuzzy
msgid ":ref:`Scene organization <doc_scene_organization>`"
msgstr ":ref:`动画管线 <doc_animations>`"

#: ../../docs/about/docs_changelog.rst:28
msgid ":ref:`Scenes versus scripts <doc_scenes_versus_scripts>`"
msgstr ""

#: ../../docs/about/docs_changelog.rst:29
msgid ""
":ref:`Autoloads versus internal nodes <doc_autoloads_versus_internal_nodes>`"
msgstr ""

#: ../../docs/about/docs_changelog.rst:30
msgid ":ref:`Node alternatives <doc_node_alternatives>`"
msgstr ""

#: ../../docs/about/docs_changelog.rst:31
msgid ":ref:`Godot interfaces <doc_godot_interfaces>`"
msgstr ""

#: ../../docs/about/docs_changelog.rst:32
#, fuzzy
msgid ":ref:`Godot notifications <doc_godot_notifications>`"
msgstr ":ref:`动画管线 <doc_animations>`"

#: ../../docs/about/docs_changelog.rst:33
msgid ":ref:`Data preferences <doc_data_preferences>`"
msgstr ""

#: ../../docs/about/docs_changelog.rst:34
msgid ":ref:`Logic preferences <doc_logic_preferences>`"
msgstr ""

#: ../../docs/about/docs_changelog.rst:37
#: ../../docs/getting_started/step_by_step/scripting.rst:4
#: ../../docs/getting_started/scripting/index.rst:2
#: ../../docs/tutorials/networking/http_request_class.rst:22
msgid "Scripting"
msgstr "脚本"

#: ../../docs/about/docs_changelog.rst:39
#, fuzzy
msgid ":ref:`Typed GDscript <doc_gdscript_static_typing>`"
msgstr ":ref:`Built-in<gdscript_basics.html#built-in-types>`"

#: ../../docs/about/docs_changelog.rst:42 ../../docs/tutorials/2d/index.rst:2
msgid "2D"
msgstr "2D"

#: ../../docs/about/docs_changelog.rst:44
msgid ":ref:`2D lights and shadows <doc_2d_lights_and_shadows>`"
msgstr ""

#: ../../docs/about/docs_changelog.rst:45
msgid ":ref:`2D meshes <doc_2d_meshes>`"
msgstr ""

#: ../../docs/about/docs_changelog.rst:48 ../../docs/tutorials/3d/index.rst:2
msgid "3D"
msgstr "3D"

#: ../../docs/about/docs_changelog.rst:50
#, fuzzy
msgid ":ref:`CSG <doc_csg_tools>`"
msgstr ":ref:`CSGBox <class_CSGBox>`"

#: ../../docs/about/docs_changelog.rst:51
#, fuzzy
msgid ""
":ref:`Animating thousands of fish with MultiMesh "
"<doc_animating_thousands_of_fish>`"
msgstr "用渐变节点动画生命的损失"

#: ../../docs/about/docs_changelog.rst:52
msgid ""
":ref:`Controlling thousands of fish with Particles "
"<doc_controlling_thousands_of_fish>`"
msgstr ""

#: ../../docs/about/docs_changelog.rst:55
#: ../../docs/tutorials/physics/index.rst:2
msgid "Physics"
msgstr "物理"

#: ../../docs/about/docs_changelog.rst:57
msgid ":ref:`Ragdoll system <doc_ragdoll_system>`"
msgstr ""

#: ../../docs/about/docs_changelog.rst:58
msgid ":ref:`Softbody <doc_soft_body>`"
msgstr ""

#: ../../docs/about/docs_changelog.rst:61
#: ../../docs/getting_started/workflow/assets/escn_exporter/animation.rst:2
#: ../../docs/tutorials/animation/index.rst:2
#: ../../docs/tutorials/animation/cutout_animation.rst:279
#: ../../docs/development/file_formats/tscn.rst:365
msgid "Animation"
msgstr "动画"

#: ../../docs/about/docs_changelog.rst:63
msgid ":ref:`2D skeletons <doc_2d_skeletons>`"
msgstr ""

#: ../../docs/about/docs_changelog.rst:64
#, fuzzy
msgid ":ref:`AnimationTree <doc_animation_tree>`"
msgstr ":ref:`动画管线 <doc_animations>`"

#: ../../docs/about/docs_changelog.rst:67
#: ../../docs/tutorials/viewports/index.rst:2
#: ../../docs/tutorials/viewports/viewports.rst:4
msgid "Viewports"
msgstr "视区"

#: ../../docs/about/docs_changelog.rst:69
#, fuzzy
msgid ":ref:`Using a Viewport as a texture <doc_viewport_as_texture>`"
msgstr "使用视区作为纹理"

#: ../../docs/about/docs_changelog.rst:70
msgid ":ref:`Custom post-processing <doc_custom_postprocessing>`"
msgstr ""

#: ../../docs/about/docs_changelog.rst:73
#: ../../docs/tutorials/shading/index.rst:2
msgid "Shading"
msgstr "着色器"

#: ../../docs/about/docs_changelog.rst:75
msgid ""
":ref:`Intro to shaders: 2D and 3D water (7 video tutorials) "
"<doc_intro_to_shaders_water_workshop>`"
msgstr ""

#: ../../docs/about/docs_changelog.rst:76
msgid ""
":ref:`Migrating to Godot’s shading language "
"<doc_migrating_to_godot_shader_language>`"
msgstr ""

#: ../../docs/about/docs_changelog.rst:77
msgid ""
":ref:`Vertex displacement with shaders "
"<doc_vertex_displacement_with_shaders>`"
msgstr ""

#: ../../docs/about/docs_changelog.rst:78
msgid ":ref:`Advanced post-processing <doc_advanced_postprocessing>`"
msgstr ""

#: ../../docs/about/docs_changelog.rst:85
#, fuzzy
msgid "Shading Reference:"
msgstr "动画面板参考"

#: ../../docs/about/docs_changelog.rst:81
#, fuzzy
msgid ":ref:`Shaders <doc_shaders>`"
msgstr ":ref:`易于书写的着色器 <doc_shading_language>`"

#: ../../docs/about/docs_changelog.rst:82
#, fuzzy
msgid ":ref:`Shading language <doc_shading_language>`"
msgstr ":ref:`易于书写的着色器 <doc_shading_language>`"

#: ../../docs/about/docs_changelog.rst:83
#, fuzzy
msgid ":ref:`Spatial shaders <doc_spatial_shader>`"
msgstr "“spatial”:用于3D渲染。"

#: ../../docs/about/docs_changelog.rst:84
#, fuzzy
msgid ":ref:`CanvasItem shaders <doc_canvas_item_shader>`"
msgstr "“canvas_item”:用于2D渲染。"

#: ../../docs/about/docs_changelog.rst:85
#, fuzzy
msgid ":ref:`Particles shaders <doc_particle_shader>`"
msgstr "\"particles\":用于粒子系统。"

#: ../../docs/about/docs_changelog.rst:88 ../../docs/tutorials/vr/index.rst:2
msgid "VR"
msgstr "VR"

#: ../../docs/about/docs_changelog.rst:90
msgid ":ref:`VR starter tutorial <doc_vr_starter_tutorial>`"
msgstr ""

#: ../../docs/about/docs_changelog.rst:93
#: ../../docs/tutorials/platform/index.rst:2
msgid "Platform-specific"
msgstr "特定平台"

#: ../../docs/about/docs_changelog.rst:95
#, fuzzy
msgid ""
":ref:`Customizing the Web export HTML page <doc_customizing_html5_shell>`"
msgstr "自定义Web导出HTML页面"

#: ../../docs/about/docs_changelog.rst:98
#: ../../docs/tutorials/threads/index.rst:2
msgid "Multi-threading"
msgstr "多线程"

#: ../../docs/about/docs_changelog.rst:100
msgid ":ref:`Thread safe APIs <doc_thread_safe_apis>`"
msgstr ""

#: ../../docs/about/docs_changelog.rst:103
#: ../../docs/tutorials/misc/index.rst:2
msgid "Miscellaneous"
msgstr "杂项"

#: ../../docs/about/docs_changelog.rst:105
msgid ":ref:`Fixing jitter and stutter <doc_jitter_stutter>`"
msgstr ""

#: ../../docs/about/docs_changelog.rst:106
msgid ":ref:`Running code in the editor <doc_running_code_in_the_editor>`"
msgstr ""

#: ../../docs/about/docs_changelog.rst:107
msgid ":ref:`Change scenes manually <doc_change_scenes_manually>`"
msgstr ""

#: ../../docs/about/docs_changelog.rst:108
#, fuzzy
msgid ""
":ref:`Differences between GLES2 and GLES3 <doc_gles2_gles3_differences>`"
msgstr "C#和GDScript之间的一般差异"

#: ../../docs/about/docs_changelog.rst:111
#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:231
#: ../../docs/development/compiling/index.rst:2
#: ../../docs/development/compiling/compiling_for_windows.rst:90
#: ../../docs/development/compiling/compiling_for_x11.rst:83
#: ../../docs/development/compiling/compiling_for_osx.rst:23
#: ../../docs/development/compiling/compiling_for_ios.rst:19
#: ../../docs/development/compiling/compiling_for_uwp.rst:24
msgid "Compiling"
msgstr "开始编译"

#: ../../docs/about/docs_changelog.rst:113
#, fuzzy
msgid ":ref:`Optimizing a build for size <doc_optimizing_for_size>`"
msgstr "优化大小的构建"

#: ../../docs/about/docs_changelog.rst:114
msgid ""
":ref:`Compiling with script encryption key "
"<doc_compiling_with_script_encryption_key>`"
msgstr ""

#: ../../docs/about/docs_changelog.rst:117
#: ../../docs/development/cpp/index.rst:2
msgid "Engine development"
msgstr "引擎开发"

#: ../../docs/about/docs_changelog.rst:119
#, fuzzy
msgid ""
":ref:`Binding to external libraries <doc_binding_to_external_libraries>`"
msgstr ":ref:`可使用外部编辑器 <doc_external_editor>`"

#: ../../docs/about/docs_changelog.rst:122
#: ../../docs/tutorials/content/index.rst:2
#, fuzzy
msgid "Creating content"
msgstr "创建内容"

#: ../../docs/about/docs_changelog.rst:124
#, fuzzy
msgid ":ref:`Making trees <doc_making_trees>`"
msgstr ":ref:`动画管线 <doc_animations>`"

#: ../../docs/about/docs_changelog.rst:127
#: ../../docs/tutorials/plugins/index.rst:2
msgid "Plugins"
msgstr "插件"

#: ../../docs/about/docs_changelog.rst:129
msgid ":ref:`Making main screen plugins <doc_making_main_screen_plugins>`"
msgstr ""

#: ../../docs/about/docs_changelog.rst:130
#, fuzzy
msgid ":ref:`Spatial gizmo plugins <doc_spatial_gizmo_plugins>`"
msgstr ":ref:`动画管线 <doc_animations>`"

#: ../../docs/getting_started/step_by_step/index.rst:2
#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:108
msgid "Step by step"
msgstr "入门教程"

#: ../../docs/getting_started/step_by_step/intro_to_the_editor_interface.rst:4
msgid "Introduction to Godot’s editor"
msgstr "Godot编辑器介绍"

#: ../../docs/getting_started/step_by_step/intro_to_the_editor_interface.rst:6
msgid ""
"This tutorial will run you through Godot’s interface. We’re going to look at "
"the **Project Manager, docks, workspaces** and everything you need to know "
"to get started with the engine."
msgstr ""
"这篇教程将带您过一遍Godot的界面。我们来看一下 **项目管理器、 各面板、 工作区"
"** 以及开始使用引擎所需的一切。"

#: ../../docs/getting_started/step_by_step/intro_to_the_editor_interface.rst:11
msgid "Project manager"
msgstr "项目管理器"

#: ../../docs/getting_started/step_by_step/intro_to_the_editor_interface.rst:13
msgid ""
"When you launch Godot, the first window you’ll see is the Project Manager. "
"It lets you create, remove, import or play game projects."
msgstr ""
"当您启动Godot，看到的第一个窗口就是项目管理器。它可以让您创建、移除、导入或运"
"行游戏项目。"

#: ../../docs/getting_started/step_by_step/intro_to_the_editor_interface.rst:16
#: ../../docs/getting_started/step_by_step/godot_design_philosophy.rst:49
#: ../../docs/tutorials/assetlib/using_assetlib.rst:16
#: ../../docs/tutorials/assetlib/uploading_to_assetlib.rst:22
msgid "|image0|"
msgstr "|image0|"

#: ../../docs/getting_started/step_by_step/intro_to_the_editor_interface.rst:18
msgid ""
"In the top-right corner you’ll find a drop-down menu to change the editor’s "
"language."
msgstr "您可以在右上角找到下拉菜单切换编辑器语言。"

#: ../../docs/getting_started/step_by_step/intro_to_the_editor_interface.rst:21
#: ../../docs/getting_started/step_by_step/godot_design_philosophy.rst:57
#: ../../docs/tutorials/assetlib/using_assetlib.rst:48
msgid "|image1|"
msgstr "|image1|"

#: ../../docs/getting_started/step_by_step/intro_to_the_editor_interface.rst:23
msgid ""
"From the **Templates** tab you can download open source project templates "
"and demos to help you get started faster."
msgstr "在 **模板** 选项卡里您可以下载开源的项目模板和示例来帮助您更快入门。"

#: ../../docs/getting_started/step_by_step/intro_to_the_editor_interface.rst:26
#: ../../docs/getting_started/step_by_step/godot_design_philosophy.rst:71
#: ../../docs/tutorials/assetlib/using_assetlib.rst:58
msgid "|image2|"
msgstr "|image2|"

#: ../../docs/getting_started/step_by_step/intro_to_the_editor_interface.rst:29
msgid "Create or import a project"
msgstr "创建或导入项目"

#: ../../docs/getting_started/step_by_step/intro_to_the_editor_interface.rst:31
msgid ""
"To create a new project, click the ``New Project`` button on the right. Give "
"it a name and choose an empty folder on your computer to save it."
msgstr ""
"要创建新项目，点击右侧的 ``New Project`` 按钮。起一个名字然后选择一个空目录来"
"保存它。"

#: ../../docs/getting_started/step_by_step/intro_to_the_editor_interface.rst:34
#: ../../docs/getting_started/step_by_step/godot_design_philosophy.rst:91
#: ../../docs/tutorials/assetlib/using_assetlib.rst:83
msgid "|image3|"
msgstr "|image3|"

#: ../../docs/getting_started/step_by_step/intro_to_the_editor_interface.rst:36
msgid ""
"Click the Browse button to open Godot’s file browser and pick a location or "
"type the folder’s path in the Project Path field."
msgstr ""
"点击浏览按钮，打开Godot文件浏览器并选择位置。或者直接在路径一栏输入目录路径。"

#: ../../docs/getting_started/step_by_step/intro_to_the_editor_interface.rst:39
#: ../../docs/getting_started/step_by_step/godot_design_philosophy.rst:102
#: ../../docs/tutorials/assetlib/using_assetlib.rst:88
msgid "|image4|"
msgstr "|image4|"

#: ../../docs/getting_started/step_by_step/intro_to_the_editor_interface.rst:41
msgid ""
"When you see the green tick on the right, it means the engine detects an "
"empty folder and you may click ``Create``. Godot will create the project for "
"you and open it in the editor."
msgstr ""
"当您看到右侧出现绿色对号，表明引擎检测到了这个空目录，点击 `创建` ，Godot会为"
"您创建项目并打开编辑器。"

#: ../../docs/getting_started/step_by_step/intro_to_the_editor_interface.rst:45
msgid ""
"The next time you’ll open Godot, you’ll see your new project in the list. "
"Double click on it to open it in the editor."
msgstr ""
"下次打开Godot时，就可以看到列表里有您的新项目了。双击它可以打开编辑器。"

#: ../../docs/getting_started/step_by_step/intro_to_the_editor_interface.rst:48
#: ../../docs/getting_started/step_by_step/godot_design_philosophy.rst:154
#: ../../docs/tutorials/assetlib/using_assetlib.rst:92
msgid "|image5|"
msgstr "|image5|"

#: ../../docs/getting_started/step_by_step/intro_to_the_editor_interface.rst:50
msgid ""
"You can import existing projects in a similar way, using the Import button. "
"Locate the folder that contains the project or the ``project.godot`` file to "
"import and edit it."
msgstr ""
"您可以用类似方式导入现有项目。点击导入按钮，找到含有 ``project.godot`` 文件的"
"项目目录就可以导入并编辑它了。"

#: ../../docs/getting_started/step_by_step/intro_to_the_editor_interface.rst:54
#: ../../docs/tutorials/assetlib/using_assetlib.rst:113
msgid "|image7|"
msgstr "|image7|"

#: ../../docs/getting_started/step_by_step/intro_to_the_editor_interface.rst:56
msgid "When the folder path is correct, you'll see a green checkmark."
msgstr "如果目录路径正确您会看到绿色的对号。"

#: ../../docs/getting_started/step_by_step/intro_to_the_editor_interface.rst:58
#: ../../docs/tutorials/assetlib/using_assetlib.rst:121
msgid "|image8|"
msgstr "|image8|"

#: ../../docs/getting_started/step_by_step/intro_to_the_editor_interface.rst:61
msgid "Your first look at Godot’s editor"
msgstr "初识Godot编辑器"

#: ../../docs/getting_started/step_by_step/intro_to_the_editor_interface.rst:63
msgid ""
"Welcome to Godot! With your project open, you should see the editor’s "
"interface with the 3D viewport active. You can change the current workspace "
"at the top of the interface. Click on 2D to switch to the 2D workspace."
msgstr ""
"欢迎来到Godot！随着您的项目打开，您应该能看到编辑器界面正处于3D视图状态。您可"
"以在界面顶部切换当前工作区。点击2D切换到2D工作区。"

#: ../../docs/getting_started/step_by_step/intro_to_the_editor_interface.rst:68
#: ../../docs/tutorials/assetlib/using_assetlib.rst:142
msgid "|image9|"
msgstr "|image9|"

#: ../../docs/getting_started/step_by_step/intro_to_the_editor_interface.rst:70
msgid "Now you should see this interface, with empty docks on the right side."
msgstr "现在您应该能看到这个界面，在右侧有着空面板。"

#: ../../docs/getting_started/step_by_step/intro_to_the_editor_interface.rst:72
#: ../../docs/tutorials/assetlib/using_assetlib.rst:148
msgid "|image10|"
msgstr "|image10|"

#: ../../docs/getting_started/step_by_step/intro_to_the_editor_interface.rst:74
msgid ""
"At the top, from left to right, you can see the **main menus**, the "
"**workspaces**, and the **playtest buttons**."
msgstr ""
"在顶部，从左到右，您可以看到 **主菜单** 、**工作区** 以及 **各调试按钮** 。"

#: ../../docs/getting_started/step_by_step/intro_to_the_editor_interface.rst:77
msgid ""
"On the left side, you have the **FileSystem dock**, where you’ll manage your "
"project files and assets."
msgstr ""
"在左侧您可以看到 **文件系统面板** ，在这里您可以管理您的项目文件和资源。"

#: ../../docs/getting_started/step_by_step/intro_to_the_editor_interface.rst:80
#: ../../docs/tutorials/assetlib/using_assetlib.rst:153
msgid "|image11|"
msgstr "|image11|"

#: ../../docs/getting_started/step_by_step/intro_to_the_editor_interface.rst:82
msgid ""
"On the right side, you’ll find the **Scene dock**, which lists the active "
"scene’s content and the **Inspector** in the bottom right corner."
msgstr ""
"在右侧您可以找到 **场景面板**，列出了场景的内容。还可以找到 **属性面板**，在"
"右下方。"

#: ../../docs/getting_started/step_by_step/intro_to_the_editor_interface.rst:85
#: ../../docs/tutorials/assetlib/using_assetlib.rst:161
msgid "|image12|"
msgstr "|image12|"

#: ../../docs/getting_started/step_by_step/intro_to_the_editor_interface.rst:87
msgid ""
"In the center, you have the **Toolbar** at the top, where you’ll find tools "
"to move, scale or lock your scene’s objects. It changes as you jump to "
"different workspaces."
msgstr ""
"中间上方有 **工具栏**，您可以用它移动、缩放或锁定您的场景物件。它会随着工作区"
"的不同而切换。"

#: ../../docs/getting_started/step_by_step/intro_to_the_editor_interface.rst:91
#: ../../docs/tutorials/assetlib/using_assetlib.rst:168
msgid "|image13|"
msgstr "|image13|"

#: ../../docs/getting_started/step_by_step/intro_to_the_editor_interface.rst:93
msgid ""
"The **Bottom Panel** is the host for the debug console, the animation "
"editor, the audio mixer… They are wide and can take precious space. That’s "
"why they’re folded by default."
msgstr ""
"**底部栏** 有调试台、动画编辑器、混响器…它们比较宽，会占用宝贵的空间。所以它"
"们默认是折叠状态。"

#: ../../docs/getting_started/step_by_step/intro_to_the_editor_interface.rst:97
#: ../../docs/tutorials/assetlib/using_assetlib.rst:115
msgid "|image14|"
msgstr "|image14|"

#: ../../docs/getting_started/step_by_step/intro_to_the_editor_interface.rst:100
msgid "The workspaces"
msgstr "工作区"

#: ../../docs/getting_started/step_by_step/intro_to_the_editor_interface.rst:102
msgid ""
"You can see four workspace buttons at the top: 2D, 3D, Script and AssetLib."
msgstr "您可以看到顶部有四个工作区按钮:2D、3D、脚本和资源馆。"

#: ../../docs/getting_started/step_by_step/intro_to_the_editor_interface.rst:105
msgid ""
"You’ll use the **2D workspace** for all types of games. In addition to 2D "
"games, the 2D workspace is where you'll build your interfaces. Press F1 to "
"access it."
msgstr ""
"您将对所有类型的游戏使用 **2D 工作区** 。除了2d 游戏外, 2D 工作区也是构建接口"
"的地方。按 F1 访问它。"

#: ../../docs/getting_started/step_by_step/intro_to_the_editor_interface.rst:108
msgid "|image15|"
msgstr "|image15|"

#: ../../docs/getting_started/step_by_step/intro_to_the_editor_interface.rst:110
msgid ""
"In the **3D workspace**, you can work with meshes, lights, and design levels "
"for 3D games. Press F2 to access it."
msgstr "在 **3D工作区** 里，您可以使用网格、光照并设计3D游戏关卡。按下F2切换。"

#: ../../docs/getting_started/step_by_step/intro_to_the_editor_interface.rst:113
msgid "|image16|"
msgstr "|image16|"

#: ../../docs/getting_started/step_by_step/intro_to_the_editor_interface.rst:115
msgid ""
"Notice the text [perspective] under the toolbar, it is a button that opens a "
"list of options related to the 3D viewport."
msgstr "注意工具栏下面的[透视]，这是一个按钮，用于选择与3D视图有关的选项。"

#: ../../docs/getting_started/step_by_step/intro_to_the_editor_interface.rst:117
msgid "|image20|"
msgstr "|image20|"

#: ../../docs/getting_started/step_by_step/intro_to_the_editor_interface.rst:119
msgid ""
"Read :ref:`doc_introduction_to_3d` for more detail about **3D workspace**."
msgstr "更多关于 **3D 工作区** 的细节，请查看 :ref:`doc_introduction_to_3d`。"

#: ../../docs/getting_started/step_by_step/intro_to_the_editor_interface.rst:121
msgid ""
"The **Script** workspace is a complete code editor with a debugger, rich "
"auto-completion, and built-in code reference. Press F3 to access it, and F4 "
"to search the reference."
msgstr ""
"**脚本** 工作区是一个完整的代码编辑器，有着调试器、自动补全和内置的代码参阅。"
"按下F3切换。"

#: ../../docs/getting_started/step_by_step/intro_to_the_editor_interface.rst:125
msgid "|image17|"
msgstr "|image17|"

#: ../../docs/getting_started/step_by_step/intro_to_the_editor_interface.rst:127
msgid ""
"Finally the **AssetLib** is a library of Free add-ons, scripts and assets to "
"use in your projects."
msgstr "最后， **资源馆** 有免费的插件、脚本、资源可以用到您的项目中。"

#: ../../docs/getting_started/step_by_step/intro_to_the_editor_interface.rst:131
msgid "Modify the interface"
msgstr "调整界面"

#: ../../docs/getting_started/step_by_step/intro_to_the_editor_interface.rst:133
msgid ""
"Godot’s interface lives in a single window. You cannot split it across "
"multiple screens although you can work with an external code editor like "
"Atom or Visual Studio for instance."
msgstr ""
"Godot界面存在于单一窗口中。您不能把它分离到多个屏幕中，不过您可以使用外置的代"
"码编辑器如Atom或Visual Studio。"

#: ../../docs/getting_started/step_by_step/intro_to_the_editor_interface.rst:138
msgid "Move and resize docks"
msgstr "移动、修改面板大小"

#: ../../docs/getting_started/step_by_step/intro_to_the_editor_interface.rst:140
msgid ""
"Click and drag on the edge of any dock or panel to resize it horizontally or "
"vertically."
msgstr "点击并拖动面板边缘可以修改水平或垂直大小。"

#: ../../docs/getting_started/step_by_step/intro_to_the_editor_interface.rst:143
msgid "|image18|"
msgstr "|image18|"

#: ../../docs/getting_started/step_by_step/intro_to_the_editor_interface.rst:145
msgid ""
"Click the three-dotted icon at the top of any dock to change its location."
msgstr "按下面板上方的三点标志可以改变位置。"

#: ../../docs/getting_started/step_by_step/intro_to_the_editor_interface.rst:148
msgid "|image19|"
msgstr "|image19|"

#: ../../docs/getting_started/step_by_step/intro_to_the_editor_interface.rst:150
msgid ""
"Go to the ``Editor`` menu and ``Editor Settings`` to fine-tune the look and "
"feel of the editor."
msgstr "转到 ``编辑器`` 菜单和 ``编辑器设置`` 可以微调编辑器的外观。"

#: ../../docs/getting_started/step_by_step/scenes_and_nodes.rst:4
msgid "Scenes and nodes"
msgstr "场景与节点"

#: ../../docs/getting_started/step_by_step/scenes_and_nodes.rst:11
msgid ""
"Imagine for a second that you are not a game developer anymore. Instead, "
"you're a chef! Change your hipster outfit for a toque and a double breasted "
"jacket. Now, instead of making games, you create new and delicious recipes "
"for your guests."
msgstr ""
"试想一下您不再是一个游戏开发者。取而代之地，您是一个大厨！把您时髦的着装换成"
"无檐帽和双排扣夹克。现在，您是在为您的宾客打造一个美味的菜肴而不是在做游戏。"

#: ../../docs/getting_started/step_by_step/scenes_and_nodes.rst:16
msgid ""
"So, how does a chef create a recipe? Recipes are divided into two sections: "
"the first is the ingredients and the second is the instructions to prepare "
"it. This way, anyone can follow the recipe and savor your magnificent "
"creation."
msgstr ""
"所以，一个厨子如何打造一个菜品呢？菜谱被分为两部分，第一个是成分，第二个是关"
"于准备它的说明。以这种方式，任何人都能够遵照菜谱并调制出您的绝佳创意。"

#: ../../docs/getting_started/step_by_step/scenes_and_nodes.rst:21
msgid ""
"Making games in Godot feels pretty much the same way. Using the engine feels "
"like being in a kitchen. In this kitchen, *nodes* are like a refrigerator "
"full of fresh ingredients with which to cook."
msgstr ""
"在Godot中制作游戏和这种方式非常相同。使用这个引擎感觉就像是在厨房里。在这个厨"
"房里， *节点* 就是装满了用于烹饪的新鲜材料的冰箱。"

#: ../../docs/getting_started/step_by_step/scenes_and_nodes.rst:25
msgid ""
"There are many types of nodes. Some show images, others play sound, other "
"nodes display 3D models, etc. There are dozens of them."
msgstr ""
"有很多种类型的节点，有的显示图像、有的播放声音、有的节点显示3D模型等等。它们"
"有很多。"

#: ../../docs/getting_started/step_by_step/scenes_and_nodes.rst:29
#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:87
#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:46
#: ../../docs/development/file_formats/tscn.rst:26
msgid "Nodes"
msgstr "节点"

#: ../../docs/getting_started/step_by_step/scenes_and_nodes.rst:31
msgid ""
"But let's start with the basics. Nodes are fundamental building blocks for "
"creating a game. As mentioned above, a node can perform a variety of "
"specialized functions. However, any given node always has the following "
"attributes:"
msgstr ""
"但先让我们来走基础。节点是创建一个游戏的基本元素。像上面提到的，一个节点可以"
"执行很多特定的功能，但都具有以下属性:"

#: ../../docs/getting_started/step_by_step/scenes_and_nodes.rst:35
msgid "It has a name."
msgstr "有名字。"

#: ../../docs/getting_started/step_by_step/scenes_and_nodes.rst:36
msgid "It has editable properties."
msgstr "具有可编辑的属性。"

#: ../../docs/getting_started/step_by_step/scenes_and_nodes.rst:37
msgid "It can receive a callback to process every frame."
msgstr "每帧都能接收对进程的回调。"

#: ../../docs/getting_started/step_by_step/scenes_and_nodes.rst:38
msgid "It can be extended (to have more functions)."
msgstr "能够被继承(以便拥有更多的功能)。"

#: ../../docs/getting_started/step_by_step/scenes_and_nodes.rst:39
msgid "It can be added to another node as a child."
msgstr "它能够作为子节点被加到其他节点上。"

#: ../../docs/getting_started/step_by_step/scenes_and_nodes.rst:43
msgid ""
"The last one is important. Nodes can have other nodes as children. When "
"arranged in this way, the nodes become a **tree**."
msgstr ""
"最后一点很重要。节点能够持有其他节点作为子节点。以这种方式编排的话，这些节点"
"就会变成一个“树”。"

#: ../../docs/getting_started/step_by_step/scenes_and_nodes.rst:46
msgid ""
"In Godot, the ability to arrange nodes in this way creates a powerful tool "
"for organizing projects. Since different nodes have different functions, "
"combining them allows for the creation of more complex functions."
msgstr ""
"在Godot中，以这种方式来编排节点的特点为组织项目创造了一个强有力的工具。因为不"
"同的节点有不同的功能，将他们结合起来则允许了创建更多复杂的功能。"

#: ../../docs/getting_started/step_by_step/scenes_and_nodes.rst:50
msgid ""
"Don't worry if this doesn't click yet. We will continue to explore this over "
"the next few sections. The most important fact to remember for now is that "
"nodes exist and can be arranged this way."
msgstr ""
"如果现在没有领悟它，不要担心。我们会再接下来几节里继续探讨。目前要记住最重要"
"的一点是有节点这个东西存在，并且能够按这种方式来编排。"

#: ../../docs/getting_started/step_by_step/scenes_and_nodes.rst:55
#: ../../docs/tutorials/plugins/editor/making_main_screen_plugins.rst:75
msgid "Scenes"
msgstr "场景"

#: ../../docs/getting_started/step_by_step/scenes_and_nodes.rst:59
msgid ""
"Now that the concept of nodes has been defined, the next logical step is to "
"explain what a Scene is."
msgstr "既然定义了节点的概念，那么下一个合逻辑的步骤就是解释什么是场景了。"

#: ../../docs/getting_started/step_by_step/scenes_and_nodes.rst:62
msgid ""
"A scene is composed of a group of nodes organized hierarchically (in tree "
"fashion). Furthermore, a scene:"
msgstr "一个场景由一组被分层组织的节点组成(树形的方式)。此外，一个场景:"

#: ../../docs/getting_started/step_by_step/scenes_and_nodes.rst:65
msgid "always has one root node."
msgstr "只能有一个根节点。"

#: ../../docs/getting_started/step_by_step/scenes_and_nodes.rst:66
msgid "can be saved to disk and loaded back."
msgstr "能够被保存到磁盘上，也能被载入回来。"

#: ../../docs/getting_started/step_by_step/scenes_and_nodes.rst:67
msgid "can be *instanced* (more on that later)."
msgstr "场景能够被 *实例化* (后文详细说明)。"

#: ../../docs/getting_started/step_by_step/scenes_and_nodes.rst:69
msgid ""
"Running a game means running a scene. A project can contain several scenes, "
"but for the game to start, one of them must be selected as the main scene."
msgstr ""
"运行一个游戏意味着运行一个场景。一个项目可以有多个场景，但是为了游戏的启动，"
"必须有一个作为主场景。"

#: ../../docs/getting_started/step_by_step/scenes_and_nodes.rst:72
msgid ""
"Basically, the Godot editor is a **scene editor**. It has plenty of tools "
"for editing 2D and 3D scenes as well as user interfaces, but the editor is "
"based on the concept of editing a scene and the nodes that compose it."
msgstr ""
"基本上，Godot编辑器就是一个 **场景编辑器** 。它有很多工具来编辑2D和3D场景以及"
"用户界面，但是编辑器的所有内容都是围绕着编辑构成它的场景和节点的概念展开的。"

#: ../../docs/getting_started/step_by_step/scenes_and_nodes.rst:77
msgid "Creating a new project"
msgstr "创建一个新项目"

#: ../../docs/getting_started/step_by_step/scenes_and_nodes.rst:79
msgid ""
"Let's make these abstract concepts more concrete with an example. Following "
"a long tradition in tutorials, we'll start with a \"Hello World\" project. "
"This will introduce us to using the editor."
msgstr ""
"让我们通过一个示例来更加具体地描述这些抽象概念。遵循教程中的悠久传统，我们将"
"从 \"Hello World\" 项目开始。接下来将介绍如何使用编辑器。"

#: ../../docs/getting_started/step_by_step/scenes_and_nodes.rst:83
msgid ""
"If you run the Godot executable outside of a project, the Project Manager "
"appears. This helps developers manage their projects."
msgstr ""
"当Godot程序在项目之外运行时，项目管理器就出现了，它帮助开发者管理他们的项目。"

#: ../../docs/getting_started/step_by_step/scenes_and_nodes.rst:88
msgid ""
"To create a new project, click the \"New Project\" option. Choose and create "
"a path for the project and specify the project name \"New Project\":"
msgstr ""
"要创建一个新项目，点击 \"新建项目\" 选项。选择并创建一个路径然后指定项目名为 "
"\"New Project\":"

#: ../../docs/getting_started/step_by_step/scenes_and_nodes.rst:94
#: ../../docs/getting_started/editor/external_editor.rst:32
#: ../../docs/development/compiling/compiling_with_mono.rst:143
msgid "Editor"
msgstr "编辑器"

#: ../../docs/getting_started/step_by_step/scenes_and_nodes.rst:96
msgid ""
"Once you've created the \"New Project\", then open it. This will open the "
"Godot editor:"
msgstr ""
"一旦这个 \"New Project\" 被创建，下一步就是打开它。这将会打开Godot编辑器:"

#: ../../docs/getting_started/step_by_step/scenes_and_nodes.rst:101
msgid ""
"As mentioned before, making games in Godot feels like being in a kitchen, so "
"let's open the refrigerator and add some fresh nodes to the project. We'll "
"begin with a \"Hello World\" message that we'll put on the screen."
msgstr ""
"正如前面提到的，在Godot做游戏感觉就像在厨房，所以让我们打开冰箱，为项目添加一"
"些新的节点。我们将以在屏幕上显示 \"Hello World\" 消息开始。"

#: ../../docs/getting_started/step_by_step/scenes_and_nodes.rst:106
msgid ""
"To do this, press the \"New Node\" button (which looks like a plus symbol):"
msgstr "要实现它，先按下 \"新建节点\" 按钮(看着像+号的那个):"

#: ../../docs/getting_started/step_by_step/scenes_and_nodes.rst:110
msgid ""
"This will open the Create Node dialog, showing the long list of nodes that "
"can be created:"
msgstr "这将会打开创建节点对话框，展示了一长串能够被创建的节点列表:"

#: ../../docs/getting_started/step_by_step/scenes_and_nodes.rst:115
msgid ""
"From there, select the \"Label\" node first. Searching for it is probably "
"the fastest way:"
msgstr "在这里，先选择 \"标签\" 节点。直接搜索它可能是最快捷的方式:"

#: ../../docs/getting_started/step_by_step/scenes_and_nodes.rst:120
msgid "And finally, create the Label! A lot happens when Create is pressed:"
msgstr "最终，我们创建了一个标签！当创建按钮被按下时，很多事情就发生了:"

#: ../../docs/getting_started/step_by_step/scenes_and_nodes.rst:124
msgid ""
"First of all, the scene changes to the 2D editor (because Label is a 2D Node "
"type), and the Label appears, selected, at the top left corner of the "
"viewport."
msgstr ""
"首先，界面变成了一个2D编辑器(因为标签是一个2D节点类型)，并且标签出现，处于选"
"中状态，在视图的左上角。"

#: ../../docs/getting_started/step_by_step/scenes_and_nodes.rst:127
msgid ""
"The node appears in the scene tree editor (box in the top right corner), and "
"the label properties appear in the Inspector (box in the bottom right "
"corner)."
msgstr ""
"这个节点出现在了场景树编辑器(左上方的一栏里)，而且标签的属性出现在了检查工具"
"中(右侧的一栏)。"

#: ../../docs/getting_started/step_by_step/scenes_and_nodes.rst:131
msgid ""
"The next step will be to change the \"Text\" Property of the label. Let's "
"change it to \"Hello World\":"
msgstr "下一步就是去改变标签的“文本”属性了，我们来把它改成“Hello,World!”:"

#: ../../docs/getting_started/step_by_step/scenes_and_nodes.rst:136
msgid ""
"Ok, everything's ready to run the scene! Press the PLAY SCENE Button on the "
"top bar (or hit F6):"
msgstr ""
"好了，一切都已就绪来运行场景了！在顶栏按下“运行场景”(Play Scene)按钮(或敲击"
"F6):"

#: ../../docs/getting_started/step_by_step/scenes_and_nodes.rst:141
msgid "Aaaand... Oops."
msgstr "然后……噢天哪！"

#: ../../docs/getting_started/step_by_step/scenes_and_nodes.rst:145
msgid ""
"Scenes need to be saved to be run, so save the scene to something like Hello."
"tscn in Scene -> Save:"
msgstr ""
"场景需要被保存才能运行，所以在场景→保存(Scene->Save)菜单中将场景保存成文件如"
"Hello.tscn:"

#: ../../docs/getting_started/step_by_step/scenes_and_nodes.rst:150
msgid ""
"And here's when something funny happens. The file dialog is a special file "
"dialog, and only allows you to save inside the project. The project root is "
"\"res://\" which means \"resource path\". This means that files can only be "
"saved inside the project. For the future, when doing file operations in "
"Godot, remember that \"res://\" is the resource path, and no matter the "
"platform or install location, it is the way to locate where resource files "
"are from inside the game."
msgstr ""
"然后，有趣的事情发生了。这个文件对话框是一个特别的文件对话框，只允许保存在项"
"目内。项目根目录是“res://”，意为“资源路径”(Resource Path)。这也就意味着，文件"
"只可以被保存到项目的内部。以后，当进行文件操作的时候记住，“res://”就是资源的"
"路径，不论无论平台和安装位置，它都是游戏中的资源文件的定位方式。"

#: ../../docs/getting_started/step_by_step/scenes_and_nodes.rst:158
msgid ""
"After saving the scene and pressing run scene again, the \"Hello World\" "
"demo should finally execute:"
msgstr "在保存场景并再一次按下运行场景之后，“Hello, World!”演示应该被执行:"

#: ../../docs/getting_started/step_by_step/scenes_and_nodes.rst:163
msgid "Success!"
msgstr "成功！"

#: ../../docs/getting_started/step_by_step/scenes_and_nodes.rst:168
msgid "Configuring the project"
msgstr "配置项目"

#: ../../docs/getting_started/step_by_step/scenes_and_nodes.rst:170
msgid ""
"Ok, it's time to configure the project. Right now, the only way to run "
"something is to execute the current scene. Projects, however, may have "
"several scenes, so one of them must be set as the main scene. This is the "
"scene that will be loaded any time the project is run."
msgstr ""
"好了，是时候去给项目做点配置(Configuration)了。现在，唯一运行某些东西的方式就"
"是执行当前的场景。然而，项目有多个场景，因此其中一个必须被设定为主场景(Main "
"Scene)。这个场景是将会在项目运行时被载入的场景。"

#: ../../docs/getting_started/step_by_step/scenes_and_nodes.rst:175
msgid ""
"These settings are all stored in a project.godot file, which is a plaintext "
"file in win.ini format (for easy editing). There are dozens of settings that "
"you can change in this file to alter how a project executes. To simplify "
"this process, Godot provides a project settings dialog, which acts as a sort "
"of frontend to editing a project.godot file."
msgstr ""
"这些设定将全部被存在project.godot文件中，一个win.ini格式的普通文本文件(以便编"
"辑)。有一些设定可以在这个文件中修改，来更改项目的执行方式。为了方便修改，"
"Godot提供了项目设置对话框，作为project.godot文件的可视修改工具。"

#: ../../docs/getting_started/step_by_step/scenes_and_nodes.rst:181
msgid "To access that dialog, select Project -> Project Settings. Try it now."
msgstr "要打开这个对话框，选择 Project -> Project Settings。试试吧。"

#: ../../docs/getting_started/step_by_step/scenes_and_nodes.rst:183
msgid ""
"Once the window opens, let's select a main scene. Locate the `Application/"
"Run/Main Scene` property and click on it to select 'Hello.tscn'."
msgstr ""
"窗口打开后，让我们选择一个主场景。定位到`Application/Run/Main Scene` 属性然后"
"点击并选择 'Hello.tscn'。"

#: ../../docs/getting_started/step_by_step/scenes_and_nodes.rst:188
msgid ""
"Now, with this change, when you press the regular Play button (or F5), this "
"scene will run, no matter which scene is actively being edited."
msgstr ""
"随着这个改动，按下常规运行(Play)按钮(或者F5)就会运行这个场景，无论它现在是否"
"正被编辑。"

#: ../../docs/getting_started/step_by_step/scenes_and_nodes.rst:191
msgid ""
"The project settings dialog provides a lot of options that can be saved to a "
"project.godot file and shows their default values. If you change a value, a "
"tick is marked to the left of its name. This means that the property will be "
"saved to the project.godot file and remembered."
msgstr ""
"项目设置对话框提供了许多能够被保存至project.godot文件的选项并且显示出了他们的"
"默认值。当您改变了一个值，一个对勾被标记在属性名的左侧。这意味着这个属性将被"
"保存到project.godot文件中并被记住。"

#: ../../docs/getting_started/step_by_step/scenes_and_nodes.rst:196
msgid ""
"As a side note, it is also possible to add custom configuration options and "
"read them in at run-time using the :ref:`ProjectSettings "
"<class_ProjectSettings>` singleton."
msgstr ""
"另外，还可以添加自定义配置选项，并在运行时使用 :ref:`ProjectSettings "
"<class_ProjectSettings>` 单例来读取它们。"

#: ../../docs/getting_started/step_by_step/scenes_and_nodes.rst:200
msgid "To be continued..."
msgstr "接下来…"

#: ../../docs/getting_started/step_by_step/scenes_and_nodes.rst:202
msgid ""
"This tutorial talked about \"scenes and nodes\", but so far there has been "
"only *one* scene and *one* node! Don't worry, the next tutorial will expand "
"on that..."
msgstr ""
"这篇教程谈论了“场景和节点”，但是目前为止，还只有 *一个* 场景和 *一个* 节点！"
"别担心，下一篇教程将会继续延伸…"

#: ../../docs/getting_started/step_by_step/instancing.rst:4
msgid "Instancing"
msgstr "实例化"

#: ../../docs/getting_started/step_by_step/instancing.rst:9
msgid ""
"Creating a single scene and adding nodes into it might work for small "
"projects, but as a project grows in size and complexity, the number of nodes "
"can quickly become unmanageable. To address this, Godot allows a project to "
"be separated into any number of scenes. This provides you with a powerful "
"tool that helps you organize the different components of your game."
msgstr ""
"创建单个场景并向其中添加节点，这可能适用于小型项目，但随着项目规模和复杂度的"
"增长，节点数量可能很快变得无法管理。为了解决这个问题，Godot允许一个项目被分成"
"许多场景。这为您提供了一个强大的工具，能够帮助您组织游戏的不同组件。"

#: ../../docs/getting_started/step_by_step/instancing.rst:15
msgid ""
"In :ref:`doc_scenes_and_nodes` you learned that a scene is a collection of "
"nodes organized in a tree structure, with a single node as the tree root."
msgstr ""
"在 :ref:`doc_scenes_and_nodes` 里您了解了场景是以树结构组织的节点集合，并由一"
"个单独节点作为树的根节点。"

#: ../../docs/getting_started/step_by_step/instancing.rst:20
msgid ""
"You can create as many scenes as you like and save them to disk. Scenes "
"saved in this manner are called \"Packed Scenes\" and have a ``.tscn`` "
"filename extension."
msgstr ""
"您可以创建很多场景并将其保存到磁盘。以这种方式保存的场景被称为“压缩场"
"景”(Packed Scenes)，有着 ``.tscn`` 扩展名。"

#: ../../docs/getting_started/step_by_step/instancing.rst:26
msgid ""
"Once a scene has been saved, it can be instanced into another scene as if it "
"were any other node."
msgstr ""
"一旦场景被保存后，它就可以被实例化到另一个场景中，就相当于其他的普通节点那"
"样。"

#: ../../docs/getting_started/step_by_step/instancing.rst:31
msgid "In the above picture, Scene B was added to Scene A as an instance."
msgstr "在上面的图片中，场景B作为实例被加入到A中。"

#: ../../docs/getting_started/step_by_step/instancing.rst:34
msgid "Instancing by example"
msgstr "通过示例实例化"

#: ../../docs/getting_started/step_by_step/instancing.rst:36
msgid ""
"To learn how instancing works, let's start by downloading a sample project: :"
"download:`instancing.zip <files/instancing.zip>`."
msgstr ""
"要了解实例化如何工作，我们先下载一个示例项目 : :download:`instancing.zip "
"<files/instancing.zip>`。"

#: ../../docs/getting_started/step_by_step/instancing.rst:39
msgid ""
"Unzip this project anywhere you like. Then open Godot and add this project "
"to the project manager using the 'Import' button:"
msgstr ""
"解压到任意目录。然后打开Godot，用“导入”(Import)将项目加入到项目管理器中:"

#: ../../docs/getting_started/step_by_step/instancing.rst:44
msgid ""
"Browse to the folder you extracted and open the \"project.godot\" file you "
"can find inside it. After doing this, the new project will appear on the "
"list of projects. Edit the project by pressing the 'Edit' button."
msgstr ""
"浏览到您解压到的目录，打开“project.godot”。然后，这个新的项目就会出现在项目列"
"表里。按下“编辑”(Edit)来进入场景编辑器。"

#: ../../docs/getting_started/step_by_step/instancing.rst:48
msgid ""
"This project contains two scenes: \"Ball.tscn\" and \"Main.tscn\". The ball "
"scene uses a :ref:`RigidBody2D <class_RigidBody2D>` to provide physics "
"behavior while the main scene has a set of obstacles for the ball to collide "
"with (using :ref:`StaticBody2D <class_StaticBody2D>`)."
msgstr ""
"这个项目包含两个场景:“Ball.tscn”和“Main.tscn”。Ball场景用了 :ref:"
"`RigidBody2D <class_RigidBody2D>` 来提供物理运动，Main场景则有一些障碍来和球"
"体进行碰撞(使用 :ref:`StaticBody2D <class_StaticBody2D>`)。"

#: ../../docs/getting_started/step_by_step/instancing.rst:57
msgid "Open the ``Main`` scene, and then select the root node:"
msgstr "打开 ``Main`` 场景，然后选择根节点:"

#: ../../docs/getting_started/step_by_step/instancing.rst:61
msgid ""
"We want to add an instance of the ``Ball`` scene as a child of ``Main``. "
"Click the \"link\"-shaped button (its hover-text says \"Instance a scene "
"file as a Node.\") and select the ``Ball.tscn`` file."
msgstr ""
"我们要添加一个 ``Ball`` 场景的实例，作为 ``Main`` 场景的子节点。点击“链接”形"
"状的按钮(悬浮框写着“从场景文件实例化节点。”)然后选择 ``Ball.tscn`` 文件。"

#: ../../docs/getting_started/step_by_step/instancing.rst:67
msgid ""
"The ball will be placed at the top-left corner of the screen area (this is "
"``(0, 0)`` in screen coordinates). Click and drag the ball somewhere near "
"the top-center of the scene:"
msgstr ""
"这个球会被放置在屏幕区域的左上角(即屏幕坐标 ``(0, 0)``)。按下并拖动球到中间上"
"方:"

#: ../../docs/getting_started/step_by_step/instancing.rst:73
msgid "Press \"Play\" and watch the ball fall to the bottom of the screen:"
msgstr "按下“运行”(Play)，看到球落到屏幕底部:"

#: ../../docs/getting_started/step_by_step/instancing.rst:78
msgid "Multiple instances"
msgstr "多个实例"

#: ../../docs/getting_started/step_by_step/instancing.rst:80
msgid ""
"You can add as many instances as you like to a scene, either by using the "
"\"Instance\" button again, or by clicking on the ball instance and pressing "
"\"Duplicate\" (Ctrl-D):"
msgstr ""
"您可以添加任意多的实例到一个场景中，通过再次用“实例化”(Instance)按钮，或者点"
"击球的实力然后选择“拷贝”(Duplicate，快捷键Ctrl-D):"

#: ../../docs/getting_started/step_by_step/instancing.rst:86
msgid "Run the scene again and all of the balls will fall."
msgstr "再次运行场景，这些球都会落下来。"

#: ../../docs/getting_started/step_by_step/instancing.rst:91
msgid "Editing instances"
msgstr "编辑实例"

#: ../../docs/getting_started/step_by_step/instancing.rst:93
msgid ""
"Open the ``Ball`` scene and add a ``PhysicsMaterial`` by clicking on the "
"down arrow and selecting \"New PhysicsMaterial\"."
msgstr ""

#: ../../docs/getting_started/step_by_step/instancing.rst:98
msgid ""
"Then, expand the material by clicking on it, and set the ``Bounce`` property "
"to ``1``."
msgstr ""

#: ../../docs/getting_started/step_by_step/instancing.rst:103
#, fuzzy
msgid ""
"Press \"Play\" and notice that all of the instanced balls are now much more "
"bouncy. Because the instanced balls are based on the saved scene, changes to "
"that scene will affect all instances."
msgstr ""
"打开 ``Ball`` 场景并在属性面板(Inspector)里修改 ``Bounce`` 属性为1。运行，可"
"以注意到这些实例化小球变得更有弹性。这是因为这些实例化小球都是基于那个被保存"
"了的场景，修改它能影响所有的实例。"

#: ../../docs/getting_started/step_by_step/instancing.rst:107
msgid ""
"You can also adjust individual instances. Set the bounce value back to "
"``0.5`` and then in the ``Main`` scene, select one of the instanced balls. "
"Set its ``Bounce`` to ``1`` and press \"Play\"."
msgstr ""
"您也可以调整单个实例。把弹性调回 ``0.5`` 然后回到 ``Main`` 场景中，选择其中一"
"个小球，把它的 ``Bounce`` 设为 ``1`` ，然后运行。"

#: ../../docs/getting_started/step_by_step/instancing.rst:113
msgid ""
"Notice that a grey \"revert\" button appears next to the adjusted property. "
"When this button is present, it means you modified a property in the "
"instanced scene to override its value in the saved scene. Even if that "
"property is modified in the original scene, the custom value will remain. "
"Pressing the revert button will restore the property to the value in the "
"saved scene."
msgstr ""
"可以注意到调整后的属性旁边有一个“还原”按钮。当这个按钮出现，意味着您修改了这"
"个实例化场景属性，覆盖了它原有的值。即便再次修改原场景的属性，它的值也会保持"
"不变。按下还原按钮将会把属性值还原为原场景设定值。"

#: ../../docs/getting_started/step_by_step/instancing.rst:121
#: ../../docs/getting_started/step_by_step/signals.rst:323
#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:151
msgid "Conclusion"
msgstr "总结"

#: ../../docs/getting_started/step_by_step/instancing.rst:123
msgid ""
"Instancing can be useful when you want to create many copies of the same "
"object. It is also possible to create instances in code by using GDScript, "
"see :ref:`doc_instancing_continued`."
msgstr ""
"当您想创建同一对象的多个副本时，实例化会非常有用。您也可以使用GDScript创建实"
"例(请参阅 :ref:`doc_scripting_continued`)。"

#: ../../docs/getting_started/step_by_step/instancing_continued.rst:4
msgid "Instancing (continued)"
msgstr "实例化(续)"

#: ../../docs/getting_started/step_by_step/instancing_continued.rst:7
msgid "Recap"
msgstr "概要"

#: ../../docs/getting_started/step_by_step/instancing_continued.rst:9
msgid "Instancing has many handy uses. At a glance, with instancing you have:"
msgstr "实例化有很多便捷的用途。大致来说，实例化拥有:"

#: ../../docs/getting_started/step_by_step/instancing_continued.rst:11
msgid "The ability to subdivide scenes and make them easier to manage."
msgstr "细分场景并使其更简单地管理的能力。"

#: ../../docs/getting_started/step_by_step/instancing_continued.rst:12
msgid "A tool to manage and edit multiple node instances at once."
msgstr "一种同时管理和编辑多个节点实例的工具。"

#: ../../docs/getting_started/step_by_step/instancing_continued.rst:13
msgid ""
"A way to organize and embed complex game flows or even UIs (in Godot, UI "
"Elements are nodes, too)."
msgstr "一种方式来设计更复杂的游戏流程甚至是UI(UI元素在Godot中也是节点)。"

#: ../../docs/getting_started/step_by_step/instancing_continued.rst:17
msgid "Design language"
msgstr "设计语言"

#: ../../docs/getting_started/step_by_step/instancing_continued.rst:19
msgid ""
"But the greatest strength that comes with instancing scenes is that it works "
"as an excellent design language. This is pretty much what distinguishes "
"Godot from all the other engines out there. Godot was designed from the "
"ground up around this concept."
msgstr ""
"但实例场景带来的最大优势在于它可以作为一种优秀的设计语言。这也是Godot区别于其"
"他游戏引擎的主要因素。Godot引擎就是围绕着这个概念从头设计的。"

#: ../../docs/getting_started/step_by_step/instancing_continued.rst:24
msgid ""
"When making games with Godot, the recommended approach is to dismiss most "
"common design patterns, such as MVC or Entity-Relationship diagrams, and "
"instead think about your scenes in a more natural way. Start by imagining "
"the visible elements in your game, the ones that can be named not just by a "
"programmer, but by anyone."
msgstr ""
"当使用Godot制作游戏时，推荐的方法是把其他的设计风格例如MVC(模型-视图-控制器模"
"式)或者实体关系图(E-R图)抛开，并且开始以一种自然的方式思考游戏。开始想象游戏"
"中的所有可见元素，那些能够不只被程序员，而是能被任何人命名的东西。"

#: ../../docs/getting_started/step_by_step/instancing_continued.rst:30
msgid "For example, here's how a simple shooter game could be imagined:"
msgstr "比如说，想象一下有一个简单的射击游戏:"

#: ../../docs/getting_started/step_by_step/instancing_continued.rst:34
msgid ""
"You can come up with a diagram like this for almost any kind of game. Write "
"down the parts of the game that you can visualize, and then add arrows to "
"represent ownership of one component by another."
msgstr ""
"对于几乎任何类型的游戏，想出这样的图都很容易。只需要写下游戏中可以看到的部"
"分，然后加上箭头来表示它们的所属关系。"

#: ../../docs/getting_started/step_by_step/instancing_continued.rst:38
msgid ""
"Once you have a diagram like this, the recommended process for making a game "
"is to create a scene for each element listed in the diagram. You'll use "
"instancing (either by code or directly in the editor) for the ownership "
"relationships."
msgstr ""
"一旦形成了这样的图，制作一个游戏就可以是为每个图中的节点创建一个场景。然后使"
"用其实例(或通过代码，或通过编辑器)来表达所属关系。"

#: ../../docs/getting_started/step_by_step/instancing_continued.rst:42
msgid ""
"A lot of time spent in programming games (or software in general) is on "
"designing an architecture and fitting game components to that architecture. "
"Designing based on scenes replaces that approach and makes development much "
"faster and more straightforward, allowing you to concentrate on the game "
"logic itself. Because most game components map directly to a scene, using a "
"design based on scene instantiation means little other architectural code is "
"needed."
msgstr ""
"在编程游戏(或一般软件)上花费的大量时间主要用于设计架构并使游戏组件适合该架"
"构。基于场景的设计取代了这种方法，使开发更快，更直接，让您专注于游戏逻辑本"
"身。因为大多数游戏组件直接映射到场景，所以使用基于场景实例化的设计意味着需要"
"很少的其他架构代码。"

#: ../../docs/getting_started/step_by_step/instancing_continued.rst:48
msgid ""
"Let's take a look at one more, somewhat more complex, example of an open-"
"world type game with lots of assets and nested elements:"
msgstr "我们来看看另一个更复杂的开放世界类游戏的示例，它有很多资源和嵌套元素:"

#: ../../docs/getting_started/step_by_step/instancing_continued.rst:53
msgid ""
"Take a look at the room element. Let's say we started there. We could make a "
"couple of different room scenes, with different arrangements of furniture "
"(also scenes) in them. Later, we could make a house scene, connecting rooms "
"to make up its interior."
msgstr ""
"看一看房间(Room)元素。我们从这开始。我们制作几个不同的房间场景，里面有不同的"
"家具(和场景)布置。然后我们做一个房屋(House)场景，用这些房间来填充内部。"

#: ../../docs/getting_started/step_by_step/instancing_continued.rst:58
msgid ""
"Then, we could make a citadel scene, which is made out of many instanced "
"houses. Then, we could start working on the world map terrain, adding the "
"citadel onto it."
msgstr ""
"然后，我们可以制作一个城堡(Citadel)场景，有许多实例化的房屋在里面。然后我们可"
"以在世界地图地形(Terrain)上工作了，将城堡添加进来。"

#: ../../docs/getting_started/step_by_step/instancing_continued.rst:62
msgid ""
"Later, we could create scenes that represent guards (and other NPCs) and add "
"them to the citadel as well. As a result, they would be indirectly added to "
"the overall game world."
msgstr ""
"然后，我们可以创建代表卫兵(和其它NPC)的场景，并将它们添加到城堡中。因此，它们"
"会间接地被加入到整个游戏世界。"

#: ../../docs/getting_started/step_by_step/instancing_continued.rst:66
msgid ""
"With Godot, it's easy to iterate on your game like this, as all you need to "
"do is create and instance more scenes. Furthermore, the editor UI is "
"designed to be user friendly for programmers and non-programmers alike. A "
"typical team development process can involve 2D or 3D artists, level "
"designers, game designers, and animators, all working with the editor "
"interface."
msgstr ""
"使用Godot，就可以很容易像这样迭代您的游戏，因为您需要做的就是创建和实例化更多"
"的场景。编辑器UI也被设计成对程序员和非程序员都友好，一个典型的团队开发过程会"
"涉及2D或3D美术工作者、关卡设计师、游戏设计师、动画师，他们都可以这个编辑器界"
"面工作。"

#: ../../docs/getting_started/step_by_step/instancing_continued.rst:73
msgid "Information overload!"
msgstr "信息量太大了！"

#: ../../docs/getting_started/step_by_step/instancing_continued.rst:75
msgid ""
"This has been a lot of high level information dropped on you all at once. "
"However, the important part of this tutorial was to create an awareness of "
"how scenes and instancing are used in real projects."
msgstr ""
"本篇一直涉及到进阶的信息。然而本教程最重要的是让您领悟到实际项目中如何使用场"
"景和实例。"

#: ../../docs/getting_started/step_by_step/instancing_continued.rst:79
msgid ""
"Everything discussed here will become second nature to you once you start "
"making games and putting these concepts into practice. For now, don't worry "
"about it too much, and go on to the next tutorial!"
msgstr ""
"一旦您开始制作游戏并将这些理念付诸实践，这里讨论的一切将成为您的“第二天性\"。"
"现在，不要太担心，继续下一个教程吧！"

#: ../../docs/getting_started/step_by_step/scripting.rst:9
#, fuzzy
msgid ""
"Before Godot 3.0, the only choice for scripting a game was to use :ref:"
"`GDScript<doc_gdscript>`. Nowadays, Godot has four (yes, four!) official "
"languages and the ability to add extra scripting languages dynamically!"
msgstr ""
"在Godot3.0之前，编写游戏脚本的唯一选择是使用 :ref:`doc_gdscript`。而现在，"
"Godot官方支持四种(是的，四种！)语言，并且能够动态添加额外的语言！"

#: ../../docs/getting_started/step_by_step/scripting.rst:13
msgid ""
"This is great, mostly due to the large amount of flexibility provided, but "
"it also makes our work supporting languages more difficult."
msgstr ""
"这很好，主要在于提供了大量的灵活性，但也使得我们对语言的支持工作变得更加困"
"难。"

#: ../../docs/getting_started/step_by_step/scripting.rst:16
msgid ""
"The \"main\" languages in Godot, though, are GDScript and VisualScript. The "
"main reason to choose them is their level of integration with Godot, as this "
"makes the experience smoother; both have slick editor integration, while C# "
"and C++ need to be edited in a separate IDE. If you are a big fan of "
"statically typed languages, go with C# and C++ instead."
msgstr ""
"不过，Godot中的“主要”语言是GDScript和VisualScript。选择它们的主要原因是它们与"
"Godot的整合程度，它们使体验更佳顺畅；两者都有非常好的编辑器集成，而C#和C++需"
"要在外部IDE中进行编辑。如果您是静态语言的忠实粉丝，也可以使用C#和C++。"

#: ../../docs/getting_started/step_by_step/scripting.rst:22
#: ../../docs/getting_started/scripting/gdscript/index.rst:2
#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:30
#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:59
#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:188
#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:203
#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:215
#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:226
#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:234
#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:249
#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:261
#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:321
msgid "GDScript"
msgstr "GDScript"

#: ../../docs/getting_started/step_by_step/scripting.rst:24
#, fuzzy
msgid ""
":ref:`GDScript<doc_gdscript>` is, as mentioned above, the main language used "
"in Godot. Using it has some positive points compared to other languages due "
"to its high integration with Godot:"
msgstr ""
":ref:`doc_gdscript` 是上面提到的用于Godot的主要语言。和其他语言相比，它与"
"Godot高度整合，有许多优点:"

#: ../../docs/getting_started/step_by_step/scripting.rst:28
msgid ""
"It's simple, elegant, and designed to be familiar for users of other "
"languages such as Lua, Python, Squirrel, etc."
msgstr "简单，优雅，设计上为Lua、Python、Squirrel等语言用户所熟悉。"

#: ../../docs/getting_started/step_by_step/scripting.rst:29
msgid "Loads and compiles blazingly fast."
msgstr "加载和编译速度飞快。"

#: ../../docs/getting_started/step_by_step/scripting.rst:30
msgid ""
"The editor integration is a pleasure to work with, with code completion for "
"nodes, signals, and many other items pertaining to the scene being edited."
msgstr "编辑器集成非常令人愉快，有节点、信号、其它场景相关项目的代码完成。"

#: ../../docs/getting_started/step_by_step/scripting.rst:31
msgid ""
"Has vector types built-in (such as Vectors, transforms, etc.), making it "
"efficient for heavy use of linear algebra."
msgstr "有内建向量类型(比如Vector、Transform等)，大量使用线性代数时非常有效。"

#: ../../docs/getting_started/step_by_step/scripting.rst:32
msgid ""
"Supports multiple threads as efficiently as statically typed languages - one "
"of the limitations that made us avoid VMs such as Lua, Squirrel, etc."
msgstr ""
"支持多线程，像静态类型语言一样有效 - 这是我们避免使用诸如Lua、Squirrel等虚拟"
"机的原因之一。"

#: ../../docs/getting_started/step_by_step/scripting.rst:33
msgid ""
"Uses no garbage collector, so it trades a small bit of automation (most "
"objects are reference counted anyway), by determinism."
msgstr ""
"不使用垃圾回收器，所以它确定性地自动处理之这部分(大多数对象都是引用计数)。"

#: ../../docs/getting_started/step_by_step/scripting.rst:34
msgid ""
"Its dynamic nature makes it easy to optimize sections of code in C++ (via "
"GDNative) if more performance is required, all without recompiling the "
"engine."
msgstr ""
"它的动态特性使其需要提高性能时，可以很容易地优化C++代码段(通过GDNative)，而这"
"些不需要重新编译引擎。"

#: ../../docs/getting_started/step_by_step/scripting.rst:36
msgid ""
"If you're undecided and have experience with programming, especially "
"dynamically typed languages, go for GDScript!"
msgstr ""
"如果您还没决定好，并且对编程有经验，特别是动态类型语言，那就选择GDScript吧！"

#: ../../docs/getting_started/step_by_step/scripting.rst:40
#: ../../docs/getting_started/scripting/visual_script/index.rst:2
msgid "VisualScript"
msgstr "可视化脚本"

#: ../../docs/getting_started/step_by_step/scripting.rst:42
msgid ""
"Beginning with 3.0, Godot offers :ref:`Visual "
"Scripting<doc_what_is_visual_script>`. This is a typical implementation of a "
"\"blocks and connections\" language, but adapted to how Godot works."
msgstr ""
"从3.0开始，Godot开始支持 :ref:`可视化脚本<doc_what_is_visual_script>`。这是典"
"型的“节点和连线”语言的实现，但适用于Godot的开发方式。"

#: ../../docs/getting_started/step_by_step/scripting.rst:46
msgid ""
"Visual scripting is a great tool for non-programmers, or even for "
"experienced developers who want to make parts of the code more accessible to "
"others, like game designers or artists."
msgstr ""
"对非程序员来说，可视化编程是一个很好的工具，甚至对于经验丰富的开发人员来说也"
"是如此，他们想让部分代码易于被他人访问，比如游戏设计师和美术工作者。"

#: ../../docs/getting_started/step_by_step/scripting.rst:50
msgid ""
"It can also be used by programmers to build state machines or custom visual "
"node workflows - for example, a dialogue system."
msgstr "程序员也可以用它创建状态机或自定义可视节点工作流程，例如对话系统。"

#: ../../docs/getting_started/step_by_step/scripting.rst:55
msgid ".NET / C#"
msgstr ".NET / C#"

#: ../../docs/getting_started/step_by_step/scripting.rst:57
msgid ""
"As Microsoft's C# is a favorite amongst game developers, we have added "
"official support for it. C# is a mature language with tons of code written "
"for it, and support was added thanks to a generous donation from Microsoft."
msgstr ""
"由于微软的C#是游戏开发者的最爱，我们增加了官方支持。C#是一种成熟的语言，人们"
"为它编写了大量代码，而且支持得益于微软的慷慨捐赠。"

#: ../../docs/getting_started/step_by_step/scripting.rst:62
msgid ""
"It has an excellent tradeoff between performance and ease of use, although "
"one must be aware of its garbage collector."
msgstr "它在性能和易用性之间有很好的折衷，但必须注意它的垃圾收集器。"

#: ../../docs/getting_started/step_by_step/scripting.rst:65
msgid ""
"Since Godot uses the `Mono <https://mono-project.com>`_ .NET runtime, in "
"theory any third-party .NET library or framework can be used for scripting "
"in Godot, as well as any Common Language Infrastructure-compliant "
"programming language, such as F#, Boo or ClojureCLR. In practice however, C# "
"is the only officially supported .NET option."
msgstr ""
"由于Godot使用 `Mono <https://mono-project.com>`_ .NET运行时，因此理论上任何第"
"三方.NET库或框架都可用于编写Godot脚本，以及任何符合通用语言标准架构的语言，如"
"F#、Boo或ClojureCLR。但实际上，C#是唯一官方支持的.NET选项。"

#: ../../docs/getting_started/step_by_step/scripting.rst:71
msgid "GDNative / C++"
msgstr "GDNative / C++"

#: ../../docs/getting_started/step_by_step/scripting.rst:73
msgid ""
"Finally, one of our brightest additions for the 3.0 release: GDNative allows "
"scripting in C++ without needing to recompile (or even restart) Godot."
msgstr ""
"最后是3.0版本的一个亮点:GDNative允许在C++中编写脚本，无需重新编译(甚至都不用"
"重启)Godot。"

#: ../../docs/getting_started/step_by_step/scripting.rst:77
msgid ""
"Any C++ version can be used, and mixing compiler brands and versions for the "
"generated shared libraries works perfectly, thanks to our use of an internal "
"C API Bridge."
msgstr ""
"任意C++版本都可以使用，由于我们在内部使用了C API Bridge，混合编译器和生成的共"
"享库都可以完美工作。"

#: ../../docs/getting_started/step_by_step/scripting.rst:81
msgid ""
"This language is the best choice for performance and does not need to be "
"used throughout an entire game, as other parts can be written in GDScript or "
"Visual Script. However the API is clear and easy to use as it resembles, "
"mostly, Godot's actual C++ API."
msgstr ""
"这种语言是性能上的最佳选择，它不需要在整个游戏中都使用，因为其他部分可以用"
"GDScript或Visual Script编写。它的API清晰且易于使用，类似于Godot的C++ API。"

#: ../../docs/getting_started/step_by_step/scripting.rst:86
msgid ""
"More languages can be made available through the GDNative interface, but "
"keep in mind we don't have official support for them."
msgstr "通过GDNative接口可以使用更多语言，但请记住我们没有官方支持。"

#: ../../docs/getting_started/step_by_step/scripting.rst:90
msgid "Scripting a scene"
msgstr "编写场景脚本"

#: ../../docs/getting_started/step_by_step/scripting.rst:92
msgid ""
"For the rest of this tutorial we'll set up a GUI scene consisting of a "
"button and a label, where pressing the button will update the label. This "
"will demonstrate:"
msgstr ""
"在教程剩下的部分里，我们将建立一个GUI场景，包含一个按钮和一个标签，当按下按钮"
"时标签会更新。这将会演示:"

#: ../../docs/getting_started/step_by_step/scripting.rst:96
msgid "Writing a script and attaching it to a node."
msgstr "编写脚本并附加到节点上。"

#: ../../docs/getting_started/step_by_step/scripting.rst:97
msgid "Hooking up UI elements via signals."
msgstr "通过信号来连接到UI元素。"

#: ../../docs/getting_started/step_by_step/scripting.rst:98
msgid "Writing a script that can access other nodes in the scene."
msgstr "编写脚本，使其能访问场景中的其它节点。"

#: ../../docs/getting_started/step_by_step/scripting.rst:100
#, fuzzy
msgid ""
"Before continuing, please make sure to read the :ref:"
"`GDScript<doc_gdscript>` reference. It's a language designed to be simple, "
"and the reference is short, so it will not take more than a few minutes to "
"get an overview of the concepts."
msgstr ""
"在继续之前，请确保读了 :ref:`doc_gdscript` 资料。这是一种设计简单的语言，而且"
"资料很短，因此不用花几分钟的时间就可以了解这些概念。"

#: ../../docs/getting_started/step_by_step/scripting.rst:105
#: ../../docs/tutorials/physics/kinematic_character_2d.rst:79
#: ../../docs/tutorials/animation/introduction_2d.rst:112
msgid "Scene setup"
msgstr "建立场景"

#: ../../docs/getting_started/step_by_step/scripting.rst:107
msgid ""
"Use the \"Add Child Node\" dialogue accessed from the Scene tab (or by "
"pressing ``Ctrl+A``) to create a hierarchy with the following nodes:"
msgstr ""
"使用场景(Scene)选项卡来访问“添加子节点”(Add Child Node)对话框(或者按下 ``Ctrl"
"+A``)，创建以下节点结构:"

#: ../../docs/getting_started/step_by_step/scripting.rst:110
msgid "Panel"
msgstr "面板"

#: ../../docs/getting_started/step_by_step/scripting.rst:112
#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:141
msgid "Label"
msgstr "标签"

#: ../../docs/getting_started/step_by_step/scripting.rst:113
msgid "Button"
msgstr "按钮"

#: ../../docs/getting_started/step_by_step/scripting.rst:115
msgid "The scene tree should look like this:"
msgstr "场景树看起来应该是这个样子:"

#: ../../docs/getting_started/step_by_step/scripting.rst:119
msgid ""
"Use the 2D editor to position and resize the Button and Label so that they "
"look like the image below. You can set the text from the Inspector tab."
msgstr ""
"使用2D编辑器定位并调整按钮和标签的大小，使其看起来像下面的样子。您可以在属性"
"面板(Inspector)选项卡中设置文字。"

#: ../../docs/getting_started/step_by_step/scripting.rst:124
msgid "Finally, save the scene with a name such as ``sayhello.tscn``."
msgstr "最后，保存场景，用例如 ``sayhello.tscn`` 这样的名字。"

#: ../../docs/getting_started/step_by_step/scripting.rst:129
msgid "Adding a script"
msgstr "添加脚本"

#: ../../docs/getting_started/step_by_step/scripting.rst:131
msgid ""
"Right click on the Panel node, then select \"Attach Script\" from the "
"context menu:"
msgstr "右击Panel节点， 在弹出菜单中选择“附加脚本(Attach Script)”:"

#: ../../docs/getting_started/step_by_step/scripting.rst:136
msgid ""
"The script creation dialog will pop up. This dialog allows you to set the "
"script's language, class name, and other relevant options."
msgstr ""
"脚本创建对话框会弹出。这个对话框允许您设置脚本语言、类名和其它相关选项。"

#: ../../docs/getting_started/step_by_step/scripting.rst:139
msgid ""
"In GDScript, the file itself represents the class, so the class name field "
"is not editable."
msgstr "在GDScript里，文件本身代表了类，所以类名一栏无法编辑。"

#: ../../docs/getting_started/step_by_step/scripting.rst:142
msgid ""
"The node we're attaching the script to is a panel, so the Inherits field "
"will automatically be filled in with \"Panel\". This is what we want, as the "
"script's goal is to extend the functionality of our panel node."
msgstr ""
"我们要附加脚本的节点是个Panel(面板)，所以继承一栏会被自动填入“Panel”。这是我"
"们想要的，因为脚本的目的就是扩展这个面板节点的功能。"

#: ../../docs/getting_started/step_by_step/scripting.rst:146
msgid "Finally, enter a path name for the script and select Create:"
msgstr "最后，输入脚本的路径名然后选择新建(Create):"

#: ../../docs/getting_started/step_by_step/scripting.rst:150
msgid ""
"The script will then be created and added to the node. You can see this as "
"an \"Open script\" icon next to the node in the Scene tab, as well as in the "
"script property under Inspector:"
msgstr ""
"脚本会被创建并将添加至Panel节点上。您可以通过场景选项卡中节点旁边的“打开脚"
"本”图标或属性面板中的Script属性来查看这个脚本:"

#: ../../docs/getting_started/step_by_step/scripting.rst:156
msgid ""
"To edit the script, select either of these buttons, both of which are "
"highlighted in the above image. This will bring you to the script editor, "
"where a default template will be included:"
msgstr ""
"要编辑脚本，选择上述按钮之一，这两个按钮都在上图中突出显示。这会把您带到脚本"
"编辑器处，其中包含了默认模版:"

#: ../../docs/getting_started/step_by_step/scripting.rst:161
msgid ""
"There's not much there. The ``_ready()`` function is called when the node, "
"and all its children, enters the active scene. **Note:** ``_ready()`` is not "
"the constructor; the constructor is instead ``_init()``."
msgstr ""
"这里没有多少内容。 ``_ready()`` 函数在节点及其所有子节点进入活动场景时调用。 "
"**注意:** ``_ready()`` 并不是构造器；构造器是 ``_init()``。"

#: ../../docs/getting_started/step_by_step/scripting.rst:166
msgid "The role of the script"
msgstr "脚本的作用"

#: ../../docs/getting_started/step_by_step/scripting.rst:168
msgid ""
"A script adds behavior to a node. It is used to control how the node "
"functions as well as how it interacts with other nodes: children, parent, "
"siblings, and so on. The local scope of the script is the node. In other "
"words, the script inherits the functions provided by that node."
msgstr ""
"脚本为节点添加行为。它用于控制节点的功能以及它如何与其他节点交互:子节点、父节"
"点、同级节点等。脚本的作用域是(它附着的)节点。换句话说，该脚本继承了该节点提"
"供的功能。"

#: ../../docs/getting_started/step_by_step/scripting.rst:179
msgid "Handling a signal"
msgstr "处理信号"

#: ../../docs/getting_started/step_by_step/scripting.rst:181
msgid ""
"Signals are \"emitted\" when some specific kind of action happens, and they "
"can be connected to any function of any script instance. Signals are used "
"mostly in GUI nodes, although other nodes have them too, and you can even "
"define custom signals in your own scripts."
msgstr ""
"当某种特定行为发生时，信号会被“触发”，并且它们可以连接到任意脚本实例的任意函"
"数。信号主要用于GUI节点，不过其他节点也有信号，您甚至可以在自己的脚本里定义自"
"定义信号。"

#: ../../docs/getting_started/step_by_step/scripting.rst:186
msgid ""
"In this step, we'll connect the \"pressed\" signal to a custom function. "
"Forming connections is the first part and defining the custom function is "
"the second part. For the first part, Godot provides two ways to create "
"connections: through a visual interface the editor provides or through code."
msgstr ""
"在这一步中，我们将“pressed(按下)”信号连接到一个自定义函数上。形成连接是第一部"
"分，定义自定义函数是第二部分。对于第一部分，Godot提供了两种创建连接的方式:通"
"过编辑器的可视化界面或通过代码。"

#: ../../docs/getting_started/step_by_step/scripting.rst:191
msgid ""
"While we will use the code method for the remainder of this tutorial series, "
"let's cover how the editor interface works for future reference."
msgstr ""
"虽然我们会在本系列教程的其余部分中使用代码方法，但现在还是介绍一下如何用编辑"
"器界面操作以供将来参考。"

#: ../../docs/getting_started/step_by_step/scripting.rst:194
msgid ""
"Select the Button node in the scene tree and then select the \"Node\" tab. "
"Next, make sure that you have \"Signals\" selected."
msgstr ""
"在场景树中选择Button节点，然后选择“Node”选项卡。接下来，确保您选中"
"了“Signals”选项。"

#: ../../docs/getting_started/step_by_step/scripting.rst:199
msgid ""
"If you then select \"pressed()\" under \"BaseButton\" and click the "
"\"Connect...\" button in the bottom right, you'll open up the connection "
"creation dialogue."
msgstr ""
"选择“BaseButton”下的“pressed()”然后点击右下方的“Connect...(连接)”，会打开连接"
"创建对话框。"

#: ../../docs/getting_started/step_by_step/scripting.rst:204
msgid ""
"In the bottom-left are the key things you need to create a connection: a "
"node which implements the method you want to trigger (represented here as a "
"NodePath) and the name of the method to trigger."
msgstr ""
"左下方是创建连接所需的关键:实现您想要触发方法的节点(在此用NodePath表示)以及要"
"触发的方法的名字。"

#: ../../docs/getting_started/step_by_step/scripting.rst:208
msgid ""
"The top-left section displays a list of your scene's nodes with the emitting "
"node's name highlighted in red. Select the \"Panel\" node here. When you "
"select a node, the NodePath at the bottom will automatically update to point "
"to a relative path from the emitting node to the selected node."
msgstr ""
"左上部分显示了您的场景节点列表，其中触发节点的名称以红色突出显示。在这里选"
"择“Panel”节点。当您选择一个节点时，底部的NodePath将自动更新为触发节点到所选节"
"点的相对路径。"

#: ../../docs/getting_started/step_by_step/scripting.rst:213
msgid ""
"By default, the method name will contain the emitting node's name (\"Button"
"\" in this case), resulting in \"_on_[EmitterNode]_[signal_name]\". If you "
"do have the \"Make Function\" check button checked, then the editor will "
"generate the function for you before setting up the connection."
msgstr ""
"默认情况下，方法名称将包含触发节点的名称(这里为“Button”)，从而生成“_on_[触发"
"节点]_[信号名]”这样的名字。如果您选中了“生成函数”复选框，编辑器会在建立连接之"
"前生成这个函数。"

#: ../../docs/getting_started/step_by_step/scripting.rst:218
msgid ""
"And that concludes the guide on how to use the visual interface. However, "
"this is a scripting tutorial, so for the sake of learning, let's dive into "
"the manual process!"
msgstr ""
"这就结束了关于如何使用可视界面的指南。然而这是一个脚本教程，所以为了学习，让"
"我们使用代码方法！"

#: ../../docs/getting_started/step_by_step/scripting.rst:222
msgid ""
"To accomplish this, we will introduce a function that is probably the most "
"used by Godot programmers: :ref:`Node.get_node() "
"<class_Node_method_get_node>`. This function uses paths to fetch nodes "
"anywhere in the scene, relative to the node that owns the script."
msgstr ""
"为了达成目的，我们先介绍一个可能是被Godot程序员使用最多的函数: :ref:`Node."
"get_node() <class_Node_method_get_node>`。该函数使用路径来获取场景中相对于该"
"脚本的节点的任何位置的节点。"

#: ../../docs/getting_started/step_by_step/scripting.rst:227
msgid ""
"For the sake of convenience, delete everything underneath ``extends Panel``. "
"You will fill out the rest of the script manually."
msgstr ""
"为了方便起见，删除 ``extends Panel`` 下的所有内容。您要手动填写脚本的其余部"
"分。"

#: ../../docs/getting_started/step_by_step/scripting.rst:230
msgid ""
"Because the Button and Label are siblings under the Panel where the script "
"is attached, you can fetch the Button by typing the following underneath the "
"``_ready()`` function:"
msgstr ""
"由于Button和Label是有脚本附加的Panel下的兄弟节点，因此可以通过在 "
"``_ready()`` 函数下输入以下内容来获取Button引用:"

#: ../../docs/getting_started/step_by_step/scripting.rst:247
msgid "Next, write a function which will be called when the button is pressed:"
msgstr "接下来，写一个函数，按钮按下时它会被触发:"

#: ../../docs/getting_started/step_by_step/scripting.rst:262
msgid ""
"Finally, connect the button's \"pressed\" signal to ``_ready()`` by using :"
"ref:`Object.connect() <class_Object_method_connect>`."
msgstr ""
"最后，通过 :ref:`Object.connect() <class_Object_method_connect>` 来连接按钮"
"的 “pressed” 信号到 ``_ready()`` 。"

#: ../../docs/getting_started/step_by_step/scripting.rst:278
msgid "The final script should look like this:"
msgstr "脚本最终看起来是这个样子:"

#: ../../docs/getting_started/step_by_step/scripting.rst:311
msgid ""
"Run the scene and press the button. You should get the following result:"
msgstr "运行场景并按下按钮，您应该看到这个结果:"

#: ../../docs/getting_started/step_by_step/scripting.rst:315
msgid "Why, hello there! Congratulations on scripting your first scene."
msgstr "您好啊！恭喜您完成了您的第一个场景脚本。"

#: ../../docs/getting_started/step_by_step/scripting.rst:319
msgid ""
"A common misunderstanding regarding this tutorial is how ``get_node(path)`` "
"works. For a given node, ``get_node(path)`` searches its immediate children. "
"In the above code, this means that Button must be a child of Panel. If "
"Button were instead a child of Label, the code to obtain it would be:"
msgstr ""
"本教程的一个常见的误解是 ``get_node(path)`` 的工作原理。对于给定节点， "
"``get_node(path)`` 搜索它的直接子节点。在上面代码中，Button必须是Panel的子"
"项。如果Button是Label的子项，则获得它的代码是:"

#: ../../docs/getting_started/step_by_step/scripting.rst:337
msgid "Also, remember that nodes are referenced by name, not by type."
msgstr "另外，注意节点是通过节点名，而不是类型来获取的。"

#: ../../docs/getting_started/step_by_step/scripting.rst:341
msgid ""
"The right-hand panel of the connect dialogue is for binding specific values "
"to the connected function's parameters. You can add and remove values of "
"different types."
msgstr ""
"连接对话框的右侧面板用于将特定值绑定到连接函数的参数。您可以添加和删除不同类"
"型的值。"

#: ../../docs/getting_started/step_by_step/scripting.rst:345
msgid ""
"The code approach also enables this with a 4th ``Array`` parameter that is "
"empty by default. Feel free to read up on the ``Object.connect`` method for "
"more information."
msgstr ""
"代码方法下可以用默认为空的第四个 ``Array`` 参数来启用额外参数。参阅 ``Object."
"connect`` 方法以获取更多信息。"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:4
msgid "Scripting (continued)"
msgstr "脚本(续)"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:7
msgid "Processing"
msgstr "流程"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:9
msgid ""
"Several actions in Godot are triggered by callbacks or virtual functions, so "
"there is no need to write code that runs all the time."
msgstr ""
"Godot中的许多动作是由回调函数或虚函数触发，所以不需要编写那些总是运行的代码。"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:12
msgid ""
"However, it is still common to need a script to be processed on every frame. "
"There are two types of processing: idle processing and physics processing."
msgstr ""
"但是，在每一帧上都需要处理脚本仍然很常见。有两种类型的处理:空闲处理和物理处"
"理。"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:16
msgid ""
"Idle processing is activated when the method :ref:`Node._process() "
"<class_Node_method__process>` is found in a script. It can be turned off and "
"on with the :ref:`Node.set_process() <class_Node_method_set_process>` "
"function."
msgstr ""
"当 :ref:`Node._process() <class_Node_method__process>` 方法在函数中被定义时，"
"处理流程就会被激活.。可以通过 :ref:`Node.set_process() "
"<class_Node_method_set_process>` 函数来进行开关."

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:20
msgid ""
"This method will be called every time a frame is drawn, so it's fully "
"dependent on how many frames per second (FPS) the application is running at:"
msgstr ""
"每次绘制时都会调用此方法，因此调用频率完全取决于应用程序在每秒运行的帧数"
"(FPS):"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:37
msgid ""
"The delta parameter contains the time elapsed in seconds, as a floating "
"point, since the previous call to ``_process()``."
msgstr ""
"delta参数是自从上一次调用 ``_process()`` 以来以秒为单位的时间，类型是浮点数。"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:40
msgid ""
"This parameter can be used to make sure things always take the same amount "
"of time, regardless of the game's FPS."
msgstr "无论游戏的FPS如何，这个参数都可以用来确保事务总是占用相同的时间。"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:43
msgid ""
"For example, movement is often multiplied with a time delta to make movement "
"speed both constant and independent from the frame rate."
msgstr "例如，运动常常乘以时间增量以使运动速度既恒定又独立于帧速率。"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:46
msgid ""
"Physics processing with ``_physics_process()`` is similar, but it should be "
"used for processes that must happen before each physics step, such as "
"controlling a character. It always runs before a physics step and it is "
"called at fixed time intervals: 60 times per second by default. You can "
"change the interval from the Project Settings, under Physics -> Common -> "
"Physics Fps."
msgstr ""
"用 ``_physics_process()`` 进行物理处理是类似的，但它应该被用在那些必须在每个"
"物理迭代之前发生的过程上，比如控制一个角色。它会在每一个物理迭代之前运行，并"
"在固定的时间间隔内调用:默认情况下每秒60次。您可以从项目设置中更改这个间隔:物"
"理 ->常用 ->物理Fps。"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:52
msgid ""
"The function ``_process()``, however, is not synced with physics. Its frame "
"rate is not constant and is dependent on hardware and game optimization. Its "
"execution is done after the physics step on single-threaded games."
msgstr ""
"然而，函数 ``_process()`` 不与物理同步。它的帧频不是恒定的，并且取决于硬件和"
"游戏优化。在单线程游戏中它的执行是在的物理步骤之后完成的。"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:55
msgid ""
"A simple way to test this is to create a scene with a single Label node, "
"with the following script:"
msgstr "测试此方法的一种简单方法是使用以下脚本创建具有单个标签节点的场景:"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:82
msgid "Which will show a counter increasing each frame."
msgstr "这将显示一个每帧增加的计数器。"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:85
msgid "Groups"
msgstr "分组"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:87
msgid ""
"Nodes can be added to groups, as many as desired per node, and is a useful "
"feature for organizing large scenes. There are two ways to do this. The "
"first is from the UI, from the Groups button under the Node panel:"
msgstr ""
"随着节点数的增加，一个有用的管理方式是把节点添加到组里。有两种方法可以做到这"
"一点。第一个通过UI实现，在Node面板下的Groups按钮:"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:92
msgid ""
"And the second way is from code. One example would be to tag nodes which are "
"enemies:"
msgstr "第二种方法是通过代码实现。下面的示例是在场景中标记出敌人:"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:110
msgid ""
"This way, if the player is discovered sneaking into a secret base, all "
"enemies can be notified about its alarm sounding by using :ref:`SceneTree."
"call_group() <class_SceneTree_method_call_group>`:"
msgstr ""
"这样一来, 如果游戏角色在潜入一个秘密基地时被发现时, 可以通过使用 :ref:"
"`SceneTree.call_group() <class_SceneTree_method_call_group>` 发出的警报声来通"
"知到所有的敌人:"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:127
msgid ""
"The above code calls the function ``player_was_discovered`` on every member "
"of the group ``enemies``."
msgstr ""
"上面的代码会使在群组 ``enemies`` 里的每个成员都会调用函数 "
"``player_was_discovered`` 。"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:130
msgid ""
"It is also possible to get the full list of ``enemies`` nodes by calling :"
"ref:`SceneTree.get_nodes_in_group() "
"<class_SceneTree_method_get_nodes_in_group>`:"
msgstr ""
"也可以通过调用 :ref:`SceneTree.get_nodes_in_group() "
"<class_SceneTree_method_get_nodes_in_group>` 获得 ``enemies`` 节点的完整列"
"表："

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:143
msgid ""
"The :ref:`SceneTree <class_SceneTree>` class provides many useful methods, "
"like interacting with scenes, their node hierarchy and groups of nodes. It "
"allows you to easily switch scenes or reload them, to quit the game or pause "
"and unpause it. It even comes with interesting signals. So check it out if "
"you got some time!"
msgstr ""
"类 :ref:`SceneTree <class_SceneTree>` 提供了很多有用的方法，例如与场景、场景"
"中节点的层次、节点分组交互。它让您可以很方便切换场景，重载场景，退出游戏，暂"
"停和继续游戏。它还有一些有趣的信号，如果您有空可以详细去查看！"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:151
#: ../../docs/tutorials/gui/custom_gui_controls.rst:157
msgid "Notifications"
msgstr "通知"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:153
msgid ""
"Godot has a system of notifications. These are usually not needed for "
"scripting, as it's too low-level and virtual functions are provided for most "
"of them. It's just good to know they exist. For example, you may add an :ref:"
"`Object._notification() <class_Object_method__notification>` function in "
"your script:"
msgstr ""
"Godot 有一个通知系统。这个是非常底层的虚函数，通常不需要放入代码里。只需要知"
"道有这个系统的存在。例如，您可以添加 :ref:`Object._notification() "
"<class_Object_method__notification>` 到您的代码里:"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:188
msgid ""
"The documentation of each class in the :ref:`Class Reference <toc-class-"
"ref>` shows the notifications it can receive. However, in most cases "
"GDScript provides simpler overrideable functions."
msgstr ""
"在 :ref:`Class Reference <toc-class-ref>` 里的所有类的文档里说明了他们能接受"
"的通知。然而，在GDScript里有类似的更简便的可重写函数。"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:193
msgid "Overrideable functions"
msgstr "可覆写的函数"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:195
msgid ""
"Such overrideable functions, which are described as follows, can be applied "
"to nodes:"
msgstr "以下所描述的这些可覆写的函数，能够应用于节点:"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:267
msgid ""
"As mentioned before, it's better to use these functions instead of the "
"notification system."
msgstr "如前所诉，用这些函数替代通知系统是更好的选择。"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:271
msgid "Creating nodes"
msgstr "创建节点"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:273
msgid ""
"To create a node from code, call the ``.new()`` method, like for any other "
"class-based datatype. For example:"
msgstr ""
"如果要用代码方式创建一个节点， 只需调用 ``.new()`` 方法即可，这也适用于其他的"
"基于类的数据类型。举例说明:"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:297
msgid ""
"To delete a node, be it inside or outside the scene, ``free()`` must be used:"
msgstr ""
"若要删除一个节点，无论其是否在场景树之内， ``free()`` 方法一定会被调用:"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:313
msgid ""
"When a node is freed, it also frees all its children nodes. Because of this, "
"manually deleting nodes is much simpler than it appears. Free the base node "
"and everything else in the subtree goes away with it."
msgstr ""
"当一个节点被释放时, 它也会释放其所有子节点。因此, 手动删除节点比看起来简单得"
"多。释放基节点, 那么子树中的其他所有东西都会随之消失。"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:317
msgid ""
"A situation might occur where we want to delete a node that is currently "
"\"blocked\", because it is emitting a signal or calling a function. This "
"will crash the game. Running Godot with the debugger will often catch this "
"case and warn you about it."
msgstr ""
"当我们要删除一个当前处于“阻塞”状态的节点时，就可能发生这种情况， 因为此时它正"
"在发出信号或者在调用一个函数。这会导致游戏崩溃。使用调试器运行Godot通常能捕获"
"这种情况并向您发出警告。"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:322
msgid ""
"The safest way to delete a node is by using :ref:`Node.queue_free() "
"<class_Node_method_queue_free>`. This erases the node safely during idle."
msgstr ""
"删除一个节点最安全的方法是使用 :ref:`Node.queue_free() "
"<class_Node_method_queue_free>`。这会在程序空闲时安全地删除该节点。"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:340
msgid "Instancing scenes"
msgstr "实例化场景"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:342
msgid ""
"Instancing a scene from code is done in two steps. The first one is to load "
"the scene from your hard drive:"
msgstr "用代码方法实例化一个场景分为两步。 第一个步骤是从您的硬盘中加载场景:"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:355
msgid ""
"Preloading it can be more convenient, as it happens at parse time (GDScript "
"only):"
msgstr "预加载它会更方便，因为它发生在解析阶段(仅限GDScript):"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:363
msgid ""
"But ``scene`` is not yet a node. It's packed in a special resource called :"
"ref:`PackedScene <class_PackedScene>`. To create the actual node, the "
"function :ref:`PackedScene.instance() <class_PackedScene_method_instance>` "
"must be called. This will return the tree of nodes that can be added to the "
"active scene:"
msgstr ""
"但是 ``scene`` 还不是一个节点，它被打包在一类称为 :ref:`PackedScene "
"<class_PackedScene>` (封包场景)的资源。要想创建实际的节点，就必须调用函数 :"
"ref:`PackedScene.instance() <class_PackedScene_method_instance>` 。它会返回能"
"够被添加到该活动场景中的节点树:"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:381
msgid ""
"The advantage of this two-step process is that a packed scene may be kept "
"loaded and ready to use so that you can create as many instances as desired. "
"This is especially useful to quickly instance several enemies, bullets, and "
"other entities in the active scene."
msgstr ""
"这个步骤的好处在于，打包后的场景会一直被加载着，所以您可以随时用它创建实例。"
"这在需要快速创建一些敌人，子弹，或其他实例时尤其有用。"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:389
msgid "Register scripts as classes"
msgstr "将脚本注册为类"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:391
msgid ""
"Godot has a \"Script Class\" feature to register individual scripts with the "
"Editor. By default, you can only access unnamed scripts by loading the file "
"directly."
msgstr ""
"Godot有一个“脚本类”的功能，可以使用编辑器注册单个脚本。默认情况下，您只能通过"
"直接加载文件访问未命名的脚本。"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:395
msgid ""
"You can name a script and register it as a type in the editor with the "
"``class_name`` keyword followed by the class's name. You may add a comma and "
"an optional path to an image to use as an icon. You will then find your new "
"type in the Node or Resource creation dialog."
msgstr ""
"您可以命名一个脚本，并在编辑器中将脚本注册为带有 ``class_name`` 关键字后跟随"
"类名的指定类型。您还可以把一张图片添加一个逗号和图片的路径来当做图标来使用。"
"然后，您可以在Node 和Resource 下找到新的类型来创建对话(对象object)。"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:417
msgid "In Godot 3.1:"
msgstr "在Godot 3.1中:"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:419
msgid ""
"Only GDScript and NativeScript, i.e., C++ and other GDNative-powered "
"languages, can register scripts."
msgstr ""
"只有 GDScript 和 NativeScrip 可以注册脚本，也就是说，只有 C++ 和 其他 "
"GDNative 支持的语言可以注册脚本。"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:420
msgid "Only GDScript creates global variables for each named script."
msgstr "只有GDScript为每一个独立的脚本创建全局变量。"

#: ../../docs/getting_started/step_by_step/signals.rst:4
#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1461
#: ../../docs/getting_started/scripting/gdscript/gdscript_styleguide.rst:183
#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:164
#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:689
#: ../../docs/development/cpp/object_class.rst:211
msgid "Signals"
msgstr "信号"

#: ../../docs/getting_started/step_by_step/signals.rst:9
msgid ""
"Signals are Godot's version of the *observer* pattern. They allow a node to "
"send out a message that other nodes can listen for and respond to. For "
"example, rather than continuously checking a button to see if it's being "
"pressed, the button can emit a signal when it's pressed."
msgstr ""
"信号是Godot版本的观察者模式。它允许一个节点发送消息到其他节点，令其他节点也可"
"以监听和响应这个消息。举个示例，当按键按下时信号就会发出，而不是不停地检查按"
"键是否被按压。"

#: ../../docs/getting_started/step_by_step/signals.rst:14
msgid ""
"You can read more about the observer pattern here: http://"
"gameprogrammingpatterns.com/observer.html"
msgstr ""
"您可以在这里查看更多关于观察者模式: http://gameprogrammingpatterns.com/"
"observer.html"

#: ../../docs/getting_started/step_by_step/signals.rst:16
msgid ""
"Signals are a way to *decouple* your game objects, which leads to better "
"organized and more manageable code. Instead of forcing game objects to "
"expect other objects to always be present, they can instead emit signals "
"that any interested objects can subscribe to and respond."
msgstr ""
"信号是一种 *解耦* 游戏对象的方法，从而使代码更有条理，更易于管理。他们可以对"
"任何感兴趣的可以订阅的对象发出信号和响应，而不是强制游戏对象去期望其他对象始"
"终存在。"

#: ../../docs/getting_started/step_by_step/signals.rst:21
msgid ""
"Below you can see some examples of how you can use signals in your own "
"projects."
msgstr "接下来您可以看到一些如何在自己的项目中使用信号的示例。"

#: ../../docs/getting_started/step_by_step/signals.rst:24
msgid "Timer example"
msgstr "计时器示例"

#: ../../docs/getting_started/step_by_step/signals.rst:26
msgid ""
"To see how signals work, let's try using a :ref:`Timer <class_Timer>` node. "
"Create a new scene with a Node and two children: a Timer and a :ref:`Sprite "
"<class_Sprite>`. You can use the Godot icon for the Sprite's texture, or any "
"other image you like. Attach a script to the root node, but don't add any "
"code to it yet."
msgstr ""
"要查看信号是如何工作的，让我们尝试使用 :ref:`Timer <class_Timer>` 节点。使用"
"一个节点和两个子节点来创建一个新场景:一个是:Timer和一个 :ref:`Sprite "
"<class_Sprite>`。您可以使用Godot图标作为Sprite的纹理，或者其他您喜欢的任意图"
"像。"

#: ../../docs/getting_started/step_by_step/signals.rst:31
msgid "Your scene tree should look like this:"
msgstr "您的场景树应该是这样的:"

#: ../../docs/getting_started/step_by_step/signals.rst:35
msgid ""
"In the Timer node's properties, check the \"On\" box next to *Autostart*. "
"This will cause the timer to start automatically when you run the scene. You "
"can leave the *Wait Time* at 1 second."
msgstr ""
"在Timer节点的属性中，勾选 *自动启动* 旁边的选框。这会令计时器在您运行场景时自"
"动启动。您可以将 *等待时间* 保留为1秒。"

#: ../../docs/getting_started/step_by_step/signals.rst:39
msgid ""
"Next to the \"Inspector\" tab is a tab labeled \"Node\". Click on this tab "
"and you'll see all of the signals that the selected node can emit. In the "
"case of the Timer node, the one we're concerned with is \"timeout\". This "
"signal is emitted whenever the Timer reaches ``0``."
msgstr ""
"在 \"属性面板\" 选项卡旁边是一个标记为 \"节点\" 的标签。单击此选项卡，您将看"
"到所选节点可以发出的所有信号。在计时器节点的情况下，我们关心的是\"超时\"。每"
"当计时器到达 ``0`` 时，就会发出这个信号。"

#: ../../docs/getting_started/step_by_step/signals.rst:46
msgid ""
"Click on the \"timeout()\" signal and click \"Connect...\". You'll see the "
"following window, where you can define how you want to connect the signal:"
msgstr ""
"点击 \"timeout()\" 信号，点击 \"Connect...\"。您将看到以下窗口，您可以在其中"
"定义如何连接信号:"

#: ../../docs/getting_started/step_by_step/signals.rst:51
msgid ""
"On the left side, you'll see the nodes in your scene and can select the node "
"that you want to \"listen\" for the signal. Note that the Timer node is red "
"- this is *not* an error, but is a visual indication that it's the node that "
"is emitting the signal. Select the root node."
msgstr ""
"在左侧，您将看到您场景中的节点，并可以选择您想要“侦听”的节点信号。需要留意的"
"是，定时器节点变红——这不是一个错误，但它是节点发出信号的视觉提示。选择根节"
"点。"

#: ../../docs/getting_started/step_by_step/signals.rst:56
msgid ""
"The target node *must* have a script attached or you'll receive an error "
"message."
msgstr "目标节点 *必须* 附加一个脚本，否则您将收到一条错误消息。"

#: ../../docs/getting_started/step_by_step/signals.rst:59
msgid ""
"On the bottom of the window is a field labeled \"Method In Node\". This is "
"the name of the function in the target node's script that you want to use. "
"By default, Godot will create this function using the naming convention "
"``_on_<node_name>_<signal_name>`` but you can change it if you wish."
msgstr ""
"在窗口的底部有一个“节点中的方法”标签。这是您在目标节点脚本中要使用的函数名。"
"默认情况下，Godot将会按命名规则' ' _on_<node_name>_<signal_name> ' ' '创建这"
"个函数，但您可以按您的意愿更改它。"

#: ../../docs/getting_started/step_by_step/signals.rst:64
msgid ""
"Click \"Connect\" and you'll see that the function has been created in the "
"script:"
msgstr "单击“Connect”，您将看到该函数已在脚本中创建:"

#: ../../docs/getting_started/step_by_step/signals.rst:84
msgid ""
"Now we can replace the placeholder code with whatever code we want to run "
"when the signal is received. Let's make the Sprite blink:"
msgstr ""
"现在，我们可以将占位符代码替换为接收到信号时要运行的任何代码。让我们让精灵闪"
"烁:"

#: ../../docs/getting_started/step_by_step/signals.rst:106
msgid ""
"Run the scene and you'll see the Sprite blinking on and off every second. "
"You can change the Timer's *Wait Time* property to alter this."
msgstr ""
"运行这个场景，您会看到精灵每秒钟都在闪烁。您可以更改计时器的 *等待时间* 属性"
"来改变这一点。"

#: ../../docs/getting_started/step_by_step/signals.rst:110
msgid "Connecting signals in code"
msgstr "连接代码中的信号"

#: ../../docs/getting_started/step_by_step/signals.rst:112
msgid ""
"You can also make the signal connection in code rather than with the editor. "
"This is usually necessary when you're instancing nodes via code and so you "
"can't use the editor to make the connection."
msgstr ""
"您还可以在代码中进行信号连接而不是在编辑器中。当您通过代码实例化节点时，您并"
"不能使用编辑器进行连接，因此这通常是必要的。"

#: ../../docs/getting_started/step_by_step/signals.rst:116
msgid ""
"First, disconnect the signal by selecting the connection in the Timer's "
"\"Node\" tab and clicking disconnect."
msgstr "首先，在计时器的“节点”选项卡中选中’链接‘，并单击’断开连接‘来断开信号。"

#: ../../docs/getting_started/step_by_step/signals.rst:121
msgid ""
"To make the connection in code, we can use the ``connect`` function. We'll "
"put it in ``_ready()`` so that the connection will be made on run. The "
"syntax of the function is ``<source_node>.connect(<signal_name>, "
"<target_node>, <target_function_name>)``. Here is the code for our Timer "
"connection:"
msgstr ""
"要在代码中进行连接，我们可以使用 ``connect`` 函数。我们将把它放在 "
"``_ready()`` 函数中，这样连接就会在运行时进行。函数的语法是 ``<source_node>."
"connect(<signal_name>, <target_node>, <target_function_name>)`` 。下面是我们"
"的计时器连接的代码:"

#: ../../docs/getting_started/step_by_step/signals.rst:154
msgid "Custom signals"
msgstr "自定义信号"

#: ../../docs/getting_started/step_by_step/signals.rst:156
msgid "You can also declare your own custom signals in Godot:"
msgstr "您也可以在Godot中声明您的的自定义信号:"

#: ../../docs/getting_started/step_by_step/signals.rst:174
msgid ""
"Once declared, your custom signals will appear in the Inspector and can be "
"connected in the same way as a node's built-in signals."
msgstr ""
"一旦声明，您的自定义信号就会出现在属性面板中，并且可以用与节点内置信号以相同"
"的方式进行连接。"

#: ../../docs/getting_started/step_by_step/signals.rst:177
msgid "To emit a signal via code, use the ``emit`` function:"
msgstr "要通过代码发出信号，使用 ``emit`` 函数:"

#: ../../docs/getting_started/step_by_step/signals.rst:203
msgid "Shooting example"
msgstr "射击示例"

#: ../../docs/getting_started/step_by_step/signals.rst:205
msgid ""
"As another example of signal usage, let's consider a player character that "
"can rotate and shoot towards the mouse. Every time the mouse button is "
"clicked, we create an instance of the bullet at the player's location. See :"
"ref:`doc_instancing` for details."
msgstr ""
"作为信号使用的另一个示例，让我们考虑一个可以旋转并向鼠标射击的游戏角色角色。"
"每次单击鼠标按钮，我们都会在游戏角色的位置创建子弹的实例。详情请参阅 :ref:"
"`doc_instancing` 。"

#: ../../docs/getting_started/step_by_step/signals.rst:210
msgid ""
"However, if the bullets are added as children of the player, then they will "
"remain \"attached\" to the player as it rotates:"
msgstr ""
"然而，如果子弹作为游戏角色的子节点添加，那么当它旋转时，子弹将仍然保持“附"
"着”在游戏角色身上:"

#: ../../docs/getting_started/step_by_step/signals.rst:215
msgid ""
"Instead, we need the bullets to be independent of the player's movement - "
"once fired, they should continue traveling in a straight line and the player "
"can no longer affect them. Instead of being added to the scene tree as a "
"child of the player, it makes more sense to add the bullet as a child of the "
"\"main\" game scene, which may be the player's parent or even further up the "
"tree."
msgstr ""
"相反，我们需要子弹独立于游戏角色的移动——一旦发射，子弹就会继续沿着直线运动，"
"游戏角色就不能再影响它们了。与其作为游戏角色的子节点被添加到场景树中，不如将"
"子弹作为“主”游戏场景的子节点添加上去更有意义，后者可能是游戏角色的父节点，甚"
"至可能是更高层级的树。"

#: ../../docs/getting_started/step_by_step/signals.rst:221
msgid "You could do this by adding the bullet directly:"
msgstr "您可以通过直接添加子弹来做到这一点:"

#: ../../docs/getting_started/step_by_step/signals.rst:234
msgid ""
"However, this will lead to a different problem. Now if you try and test your "
"\"Player\" scene independently, it will crash on shooting, because there is "
"no parent node to access. This makes it a lot harder to test your player "
"code independently and also means that if you decide to change your main "
"scene's node structure, the player's parent may no longer be the appropriate "
"node to receive the bullets."
msgstr ""
"然而，这将导致一个不同的问题。现在如果您尝试独立测试您的“游戏角色”场景，它会"
"在射击时崩溃，因为没有父节点可以访问。这使得独立测试游戏角色角色代码变得更加"
"困难，也意味着如果您决定改变主场景的节点结构，游戏角色的父节点可能不再是接收"
"子弹的合适节点。"

#: ../../docs/getting_started/step_by_step/signals.rst:241
msgid ""
"The solution to this is to use a signal to \"emit\" the bullets from the "
"player. The player then has no need to \"know\" what happens to the bullets "
"after that - whatever node is connected to the signal can \"receive\" the "
"bullets and take the appropriate action to spawn them."
msgstr ""
"解决这个问题的方法是使用一个信号来“发射”游戏角色的子弹。游戏角色不需要“知"
"道”子弹在那之后发生了什么——任何连接到信号的节点都可以“接收”子弹并采取适当的行"
"动来产生它们。"

#: ../../docs/getting_started/step_by_step/signals.rst:247
msgid "Here is the code for the player using signals to emit the bullet:"
msgstr "下面是游戏角色使用信号发射子弹的代码:"

#: ../../docs/getting_started/step_by_step/signals.rst:293
msgid ""
"In the main scene, we then connect the player's signal (it will appear in "
"the \"Node\" tab)."
msgstr "在主场景中，我们连接游戏角色的信号(它将出现在“Node”选项卡中)。"

#: ../../docs/getting_started/step_by_step/signals.rst:317
msgid ""
"Now the bullets will maintain their own movement independent of the player's "
"rotation:"
msgstr "现在子弹将保持自己的运动独立于游戏角色的旋转:"

#: ../../docs/getting_started/step_by_step/signals.rst:325
msgid ""
"Many of Godot's built-in node types provide signals you can use to detect "
"events. For example, an :ref:`Area2D <class_Area2D>` representing a coin "
"emits a ``body_entered`` signal whenever the player's physics body enters "
"its collision shape, allowing you to know when the player collected it."
msgstr ""
"Godot的许多内置节点类型都提供可以用来检测事件的信号。例如，代表硬币的 :ref:"
"`Area2D <class_Area2D>` 在游戏角色的物理体进入碰撞形状时发出 "
"``body_entered`` 信号，让您知道游戏角色什么时候收集它。"

#: ../../docs/getting_started/step_by_step/signals.rst:330
msgid ""
"In the next section, :ref:`doc_your_first_game`, you'll build a complete "
"game including several uses of signals to connect different game components."
msgstr ""
"在下一节 :ref:`doc_your_first_game` 中，您将构建一个完整的游戏，其中包括连接"
"不同游戏组件的几种信号用法。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:4
msgid "Your first game"
msgstr "您的第一个游戏"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:7
#: ../../docs/getting_started/step_by_step/exporting.rst:7
#: ../../docs/tutorials/animation/introduction_2d.rst:7
#: ../../docs/tutorials/assetlib/using_assetlib.rst:10
msgid "Overview"
msgstr "概览"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:9
msgid ""
"This tutorial will guide you through making your first Godot project. You "
"will learn how the Godot editor works, how to structure a project, and how "
"to build a 2D game."
msgstr ""
"这个教学将会全程引导您做一个您的第一个Godot项目。您能从中学到Godot编辑器如何"
"工作，一个项目如何构造出来，还有2D游戏如何做出来。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:13
msgid ""
"This project is an introduction to the Godot engine. It assumes that you "
"have some programming experience already. If you're new to programming "
"entirely, you should start here: :ref:`doc_scripting`."
msgstr ""
"这个项目是Godot引擎的一个介绍。是以您已经有了一些编程经验为前提的。如果您对编"
"程完全是菜鸟，您应当从这一条开始: :ref:`doc_scripting` 。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:18
msgid ""
"The game is called \"Dodge the Creeps!\". Your character must move and avoid "
"the enemies for as long as possible. Here is a preview of the final result:"
msgstr ""
"这个游戏叫做“Dodge the Creeps!”。您的角色必须尽力的通过移动来避开敌人。下面是"
"最终效果的预览:"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:24
msgid ""
"**Why 2D?** 3D games are much more complex than 2D ones. You should stick to "
"2D until you have a good understanding of the game development process."
msgstr ""
"**为什么是2D游戏** 3D游戏比2D游戏复杂很多。您应当从2D游戏入手直到您能很好的理"
"解游戏开发工序。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:28
#: ../../docs/getting_started/workflow/project_setup/index.rst:2
#: ../../docs/development/cpp/configuring_an_ide.rst:182
msgid "Project setup"
msgstr "项目设置"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:30
msgid ""
"Launch Godot and create a new project. Then, download :download:"
"`dodge_assets.zip <files/dodge_assets.zip>` - the images and sounds you'll "
"be using to make the game. Unzip these files to your project folder."
msgstr ""
"运行Godot新建一个项目。然后下载 :download:`dodge_assets.zip <files/"
"dodge_assets.zip>` - 您会在游戏中用到的图片和声音。解压这个文件到您的项目文件"
"夹。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:34
msgid ""
"For this tutorial, we will assume you are familiar with the editor. If you "
"haven't read :ref:`doc_scenes_and_nodes`, do so now for an explanation of "
"setting up a project and using the editor."
msgstr ""
"对于本教程，我们假设您熟悉编辑器。如果您还没有阅读 :ref:"
"`doc_scenes_and_nodes` ，那么赶紧看看，以了解如何设置项目并使用编辑器。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:38
msgid ""
"This game will use portrait mode, so we need to adjust the size of the game "
"window. Click on Project -> Project Settings -> Display -> Window and set "
"\"Width\" to ``480`` and \"Height\" to ``720``."
msgstr ""
"这个游戏会使用竖屏模式，所以我们需要调整游戏窗口的大小。点击项目->项目设置->"
"显示->窗口，设置“宽度”为480，“高度”为720。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:43
msgid "Organizing the project"
msgstr "组织项目"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:45
msgid ""
"In this project, we will make 3 independent scenes: ``Player``, ``Mob``, and "
"``HUD``, which we will combine into the game's ``Main`` scene. In a larger "
"project, it might be useful to make folders to hold the various scenes and "
"their scripts, but for this relatively small game, you can save your scenes "
"and scripts in the project's root folder, referred to as ``res://``.  You "
"can see your project folders in the FileSystem Dock in the lower left corner:"
msgstr ""
"在这个项目里，我们会做出来3个独立的场景: ``Player`` , ``Mob`` 和 ``HUD`` ,我"
"们游戏的 ``Main`` 场景由这3个场景组合而成。在更大的项目里，一般会把不同的场景"
"及其脚本放到各自的文件夹里。但是对于这次的小游戏，您可以将您的场景和脚本都存"
"放在根目录 ``res://`` 下。您能在文件系统面板的左上角看到您的项目文件夹:"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:56
msgid "Player scene"
msgstr "游戏角色场景"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:58
msgid ""
"The first scene we will make defines the ``Player`` object. One of the "
"benefits of creating a separate Player scene is that we can test it "
"separately, even before we've created other parts of the game."
msgstr ""
"第一个场景，我们会定义“player”对象。创建一个分开的游戏角色场景的好处是我们可"
"以单独测试它，即使我们还没有创建游戏的其它部分。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:63
msgid "Node structure"
msgstr "节点结构"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:65
msgid ""
"To begin, click the \"Add/Create a New Node\" button and add an :ref:`Area2D "
"<class_Area2D>` node to the scene."
msgstr ""
"首先，单击“添加/创建一个新节点”按钮，并向场景添加一个 :ref:`Area2D "
"<class_Area2D>` 节点。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:70
msgid ""
"With ``Area2D`` we can detect objects that overlap or run into the player. "
"Change its name to ``Player`` by clicking on the node's name. This is the "
"scene's root node. We can add additional nodes to the player to add "
"functionality."
msgstr ""
"使用 ``Area2D`` 类我们可以检测物体是否跑到游戏角色之中或者与游戏角色发生交"
"叠。点击节点将其重命名为 ``Player`` ，它是场景的根节点，我们可以对该游戏角色"
"节点添加额外的节点来添加其功能。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:75
msgid ""
"Before we add any children to the ``Player`` node, we want to make sure we "
"don't accidentally move or resize them by clicking on them. Select the node "
"and click the icon to the right of the lock; its tooltip says \"Makes sure "
"the object's children are not selectable.\""
msgstr ""
"在我们向 ``Player`` 节点添加子节点之前，我们可能希望确保不会因为点击他们而不"
"小心移动或缩放他们，那就选中该节点然后点击锁头右侧的图标，它的工具提示描述"
"为“确保物体的子节点不会被选中。”"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:82
msgid ""
"Save the scene. Click Scene -> Save, or press ``Ctrl+S`` on Windows/Linux or "
"``Command+S`` on Mac."
msgstr ""
"保存场景，点击场景→保存，或者在Windows/Linux平台上按下 ``Ctrl+S`` 或是Mac上按"
"下 ``Command+S``。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:84
msgid "For this project, we will be following the Godot naming conventions."
msgstr "对于这个项目，我们将遵循Godot命名约定。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:86
msgid ""
"**GDScript**: Classes (nodes) use PascalCase, variables and functions use "
"snake_case, and constants use ALL_CAPS (See :ref:`doc_gdscript_styleguide`)."
msgstr ""
"对于该项目，我们会遵循Godot的命名规范，类(节点)使用 ``PascalCase`` (大写分隔)"
"命名，变量和函数使用 ``snake_case`` (下划线分隔)命名，常量使用 ``ALL_CAPS`` "
"(全大写)命名。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:90
msgid ""
"**C#**: Classes, export variables and methods use PascalCase, private fields "
"use _camelCase, local variables and parameters use camelCase (See :ref:"
"`doc_c_sharp_styleguide`).  Be careful to type the method names precisely "
"when connecting signals."
msgstr ""
"**C#**:类，导出变量和方法使用PascalCase，私有字段使用_camelCase，局部变量和参"
"数使用camelCase(参见 :ref:`doc_c_sharp_styleguide`)。连接信号时，请注意精确键"
"入方法名称。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:97
msgid "Sprite animation"
msgstr "精灵动画"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:99
#, fuzzy
msgid ""
"Click on the ``Player`` node and add an :ref:`AnimatedSprite "
"<class_AnimatedSprite>` node as a child. The ``AnimatedSprite`` will handle "
"the appearance and animations for our player. Notice that there is a warning "
"symbol next to the node. An ``AnimatedSprite`` requires a :ref:`SpriteFrames "
"<class_SpriteFrames>` resource, which is a list of the animations it can "
"display. To create one, find the ``Frames`` property in the Inspector and "
"click \"[empty]\" -> \"New SpriteFrames\". Next, in the same location, click "
"``<SpriteFrames>``, then click \"Open Editor\" to open the \"SpriteFrames\" "
"panel:"
msgstr ""
"点击 ``Player`` 节点然后添加一个 :ref:`AnimatedSprite "
"<class_AnimatedSprite>` (动画精灵)节点作为子节点， ``AnimateSprite`` 会处理我"
"们的游戏角色的外观与动画。请注意在该节点的旁边会出现一个警告标志，一个 "
"``AnimatedSprite`` 需要一个 :ref:`SpriteFrames <class_SpriteFrames>` (精灵帧"
"集)资源，作为它能够显示的动画图像。欲创建之，在属性窗格(Inspector)里找到 "
"``Frames`` 属性，然后点击\"<无>\"→\"新建精灵帧集\"。接下来在同一位置点击 "
"``<SpriteFrames>`` 打开\"SpriteFrames\"面板:"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:111
msgid ""
"On the left is a list of animations. Click the \"default\" one and rename it "
"to \"right\". Then click the \"Add\" button to create a second animation "
"named \"up\". Drag the two images for each animation, named "
"``playerGrey_up[1/2]`` and ``playerGrey_walk[1/2]``, into the \"Animation "
"Frames\" side of the panel:"
msgstr ""
"左边是一个动画列表。单击“默认”，并将其重命名为“right”。然后点击“添加”按钮，创"
"建第二个动画名为“up”。将每个动画的两个图像(名"
"为“playerGrey_up[1/2]”和“playerGrey_walk[1/2]”)拖到面板的“动画帧”一侧:"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:118
msgid ""
"The player images are a bit too large for the game window, so we need to "
"scale them down. Click on the ``AnimatedSprite`` node and set the ``Scale`` "
"property to ``(0.5, 0.5)``. You can find it in the Inspector under the "
"``Node2D`` heading."
msgstr ""
"游戏角色图像对于游戏窗口来说有点太大，所以我们需要缩小它们。 单击 "
"``AnimatedSprite`` 节点并将 ``Scale`` 属性设置为 ``(0.5,0.5)`` 。 您可以在 "
"``Node2D`` 标题下的属性面板中找到它。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:125
#, fuzzy
msgid ""
"Finally, add a :ref:`CollisionShape2D <class_CollisionShape2D>` as a child "
"of ``Player``. This will determine the player's \"hitbox\", or the bounds of "
"its collision area. For this character, a ``CapsuleShape2D`` node gives the "
"best fit, so next to \"Shape\" in the Inspector, click \"[empty]\"\" -> "
"\"New CapsuleShape2D\".  Using the two size handles, resize the shape to "
"cover the sprite:"
msgstr ""
"最终，添加一个 :ref:`CollisionShape2D <class_CollisionShape2D>` 对象作为 "
"``Player`` 的子节点。它用于决定游戏角色的“碰撞盒”，亦或者说是它碰撞区域的边"
"界。对于该角色，给他一个 ``CapsuleShape2D`` 节点再好不过了，因此接下来来到查"
"看器的“Shape”部分，点击“<null>”改为“新建 CapsuleShape2D”。然后重设形状的大小"
"以盖住精灵:"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:134
msgid "When you're finished, your ``Player`` scene should look like this:"
msgstr "完成后，您的 ``Player`` 场景看起来应该像这样:"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:139
msgid "Moving the player"
msgstr "移动游戏角色"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:141
msgid ""
"Now we need to add some functionality that we can't get from a built-in "
"node, so we'll add a script. Click the ``Player`` node and click the \"Add "
"Script\" button:"
msgstr ""
"现在我们需要添加一些内置节点所不具备的功能，因此我们要添加一个脚本。点击 "
"``Player`` 节点然后点击“添加脚本”按钮:"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:147
msgid ""
"In the script settings window, you can leave the default settings alone. "
"Just click \"Create\":"
msgstr "在脚本设定窗口中，您可以都留默认选项，只要点击“创建”就好:"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:150
msgid ""
"If you're creating a C# script or other languages, select the language from "
"the `language` drop down menu before hitting create."
msgstr ""
"如果您要创建一个C#脚本或者其他语言的脚本，那就在创建之前在 `语言` 下拉菜单中"
"选择语言。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:155
msgid ""
"If this is your first time encountering GDScript, please read :ref:"
"`doc_scripting` before continuing."
msgstr "如果这是您第一次使用GDScript，请在继续之前阅读 :ref:`doc_scripting`。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:158
msgid "Start by declaring the member variables this object will need:"
msgstr "首先声明该对象将会用到的成员变量:"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:179
#, fuzzy
msgid ""
"Using the ``export`` keyword on the first variable ``speed`` allows us to "
"set its value in the Inspector. This can be handy for values that you want "
"to be able to adjust just like a node's built-in properties. Click on the "
"``Player`` node and you'll see the property now appears in the \"Script "
"Variables\" section of the Inspector. Remember, if you change the value "
"here, it will override the value written in the script."
msgstr ""
"对于第一个变量 ``speed`` 使用 ``export`` 关键词可以让我们能够在查看器中设置该"
"变量的值，对于我们期望能够像节点内置属性一样去调整的值，这是一个非常便利的手"
"段。点击 ``Player`` 节点并将speed属性设置为 ``400``。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:186
msgid ""
"If you're using C#, you need to (re)build the project assemblies whenever "
"you want to see new export variables or signals. This build can be manually "
"triggered by clicking the word \"Mono\" at the bottom of the editor window "
"to reveal the Mono Panel, then clicking the \"Build Project\" button."
msgstr ""
"如果您正在使用C#，则需要(重新)构建项目程序集，只要您想查看新的导出变量或信"
"号。可以通过单击编辑器窗口底部的“Mono”一词来手动触发此构建，以显示Mono "
"Panel，然后单击“Build Project”按钮。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:194
msgid ""
"The ``_ready()`` function is called when a node enters the scene tree, which "
"is a good time to find the size of the game window:"
msgstr ""
"``_ready()`` 函数会在节点进入场景树的时候被调用，这也是我们用来获取游戏窗口大"
"小的好时候:"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:210
#, fuzzy
msgid ""
"Now we can use the ``_process()`` function to define what the player will "
"do. ``_process()`` is called every frame, so we'll use it to update elements "
"of our game, which we expect will change often. For the player, we need to "
"do the following:"
msgstr ""
"现在我们可以使用 ``_process()`` 函数来定义游戏角色将会做什么。 "
"``_process()`` 在每一帧都会被调用，因此我们需要使用它来更新我们游戏中期望被经"
"常改变的元素，这里我们就做到了:"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:215
msgid "Check for input."
msgstr "检测输入。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:216
msgid "Move in the given direction."
msgstr "以给定方向移动。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:217
msgid "Play the appropriate animation."
msgstr "播放适当的动画。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:219
#, fuzzy
msgid ""
"First, we need to check for input - is the player pressing a key? For this "
"game, we have 4 direction inputs to check. Input actions are defined in the "
"Project Settings under \"Input Map\". Here, you can define custom events and "
"assign different keys, mouse events, or other inputs to them. For this demo, "
"we will use the default events that are assigned to the arrow keys on the "
"keyboard."
msgstr ""
"首先我们需要检测输入——游戏角色是否在按着某个键？对于这个游戏来说，我们有四个"
"方向的输入需要检测。输入动作被定义在项目设定的“输入映射”页下。您可以自定义事"
"件并分配器不同的键位、鼠标亦或者是其他输入的事件。对于这个演示项目来说，我们"
"会使用已经分配给键盘方向键的默认事件。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:226
msgid ""
"You can detect whether a key is pressed using ``Input.is_action_pressed()``, "
"which returns ``true`` if it is pressed or ``false`` if it isn't."
msgstr ""
"您可以通过 ``Input.is_action_pressed()`` 检测一个按键是否被按下，该函数会在按"
"下时返回 ``true`` ，否则返回 ``false``。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:288
#, fuzzy
msgid ""
"We start by setting the ``velocity`` to ``(0, 0)`` - by default the player "
"should not be moving. Then we check each input and add/subtract from the "
"``velocity`` to obtain a total direction. For example, if you hold ``right`` "
"and ``down`` at the same time, the resulting ``velocity`` vector will be "
"``(1, 1)``. In this case, since we're adding a horizontal and a vertical "
"movement, the player would move *faster* than if it just moved horizontally."
msgstr ""
"我们会检测每一个输入并增加/减少 ``velocity`` 以获取总的方向。比如说如果您同时"
"按下了 ``→`` 和 ``↓`` ，那么最终的 ``velocity`` 就会是 ``(1,1)`` 。在这种情况"
"下因为我们叠加了水平和垂直方向的运动，游戏角色会比仅在水平方向上移动得 *更快"
"*。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:295
msgid ""
"We can prevent that if we *normalize* the velocity, which means we set its "
"*length* to ``1``, and multiply by the desired speed. This means no more "
"fast diagonal movement."
msgstr ""
"我们可以通过对速度向量 *归一化* 来防止这件事，这也就意味着我们会把它的 *模* "
"设置为 ``1`` ，并乘以想要的速度，这也就意味着不再有更快的对角线移动方式。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:299
msgid ""
"If you've never used vector math before, or need a refresher, you can see an "
"explanation of vector usage in Godot at :ref:`doc_vector_math`. It's good to "
"know but won't be necessary for the rest of this tutorial."
msgstr ""
"如果您从未使用过向量数学，亦或者需要温故知新，您可以看看这里 :ref:"
"`doc_vector_math` 关于向量在Godot中使用的解释说明。最好是了解一下尽管对于本教"
"程剩下的部分来说这并不必要。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:303
msgid ""
"We also check whether the player is moving so we can start or stop the "
"AnimatedSprite animation."
msgstr ""
"我们也会检测某个问价是否在移动，以便我们能够启动或停止AnimatedSprite的动画。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:306
#, fuzzy
msgid ""
"In GDScript, ``$`` returns the node at the relative path from the current "
"node, or returns ``null`` if the node is not found. Since AnimatedSprite is "
"a child of the current node, we can use ``$AnimatedSprite``."
msgstr ""
"``$`` 返回该节点的相对路径，若该节点未找到则返回 ``null`` ，因为"
"AnimatedSprite是当前节点的子节点，因此我们可以使用 ``$AnimatedSprite`` 。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:309
msgid ""
"``$`` is shorthand for ``get_node()``. So in the code above, ``"
"$AnimatedSprite.play()`` is the same as ``get_node(\"AnimatedSprite\")."
"play()``."
msgstr ""
"``$`` 是 ``get_node()`` 的简写，因此在上面的代码中， ``$AnimatedSprite."
"play()`` 与 ``get_node(\"AnimatedSprite\").play()`` 等效。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:312
#, fuzzy
msgid ""
"Now that we have a movement direction, we can update the player's position "
"and use ``clamp()`` to prevent it from leaving the screen by adding the "
"following to the bottom of the ``_process`` function:"
msgstr ""
"既然我们已经有了运动的方向，我们就可以更新 ``Player`` 的位置了并可以在 "
"``_process()` `函数的底部使用 ``clamp()`` 函数来防止它离开屏幕:"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:332
msgid "*Clamping* a value means restricting it to a given range."
msgstr "*夹住*一个值意味着将其限制在一个给定区间内。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:334
msgid ""
"Click \"Play Scene\" (``F6``) and confirm you can move the player around the "
"screen in all directions. The console output that opens upon playing the "
"scene can be closed by clicking ``Output`` (which should be highlighted in "
"blue) in the lower left of the Bottom Panel."
msgstr ""
"单击 \"播放场景\"( ``F6`` )并确认您可以在各个方向上围绕屏幕进行移动。 运行时"
"打开的控制台输出可以通过单击底部面板左下角的 ``日志`` (应该以蓝色突出显示)来"
"关闭。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:339
msgid ""
"If you get an error in the \"Debugger\" panel that refers to a \"null "
"instance\", this likely means you spelled the node name wrong. Node names "
"are case-sensitive and ``$NodeName`` or ``get_node(\"NodeName\")`` must "
"match the name you see in the scene tree."
msgstr ""
"如果您在“调试器”面板中得到一个错误说引用了一个“null实例”，似乎您节点的名字拼"
"写有误。节点名是对大小写敏感的并且 ``$NodeName`` 或 ``get_node(\"NodeName"
"\")`` 必须与您在场景书中见到的名字一致。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:344
msgid "Choosing animations"
msgstr "选择动画"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:346
msgid ""
"Now that the player can move, we need to change which animation the "
"AnimatedSprite is playing based on direction. We have a \"right\" animation, "
"which should be flipped horizontally using the ``flip_h`` property for left "
"movement, and an \"up\" animation, which should be flipped vertically with "
"``flip_v`` for downward movement. Let's place this code at the end of our "
"``_process()`` function:"
msgstr ""
"既然游戏角色能够移动，我们就需要基于方向来改变AnimatedSprite正在播放的动画。"
"我们有一个“right”动画，其应该在向左的运动中通过 ``flip_h`` 属性被左右翻转，以"
"及一个“up”动画，其应该在向下的运动中通过 ``flip_v`` 属性上下翻转。那我们就在 "
"``_process()`` 函数的结尾添加这些代码吧:"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:380
msgid ""
"The boolean assignments in the code above are a common shorthand for "
"programmers. Consider this code versus the shortened boolean assignment "
"above:"
msgstr ""
"上面代码中的布尔赋值是程序员的常用简写。 考虑此代码与上面缩短的布尔赋值:"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:399
msgid ""
"Play the scene again and check that the animations are correct in each of "
"the directions. When you're sure the movement is working correctly, add this "
"line to ``_ready()``, so the player will be hidden when the game starts:"
msgstr ""
"再次运行场景并检查各方向的动画是否正确，当您确定移动正常工作的话，将下面一行"
"代码加到 ``_ready()`` 中以便游戏角色在游戏开始时被隐藏:"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:414
msgid "Preparing for collisions"
msgstr "准备碰撞"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:416
msgid ""
"We want ``Player`` to detect when it's hit by an enemy, but we haven't made "
"any enemies yet! That's OK, because we're going to use Godot's *signal* "
"functionality to make it work."
msgstr ""
"我们希望 ``Player`` 能够检测它何时被一个敌人撞到，但是我们还没做敌人呢！没关"
"系，因为我们将要用Godot的 *信号* 功能来实现。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:420
msgid "Add the following at the top of the script, after ``extends Area2d``:"
msgstr "在脚本开头， ``extends Area2d`` 下添加:"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:434
msgid ""
"This defines a custom signal called \"hit\" that we will have our player "
"emit (send out) when it collides with an enemy. We will use ``Area2D`` to "
"detect the collision. Select the ``Player`` node and click the \"Node\" tab "
"next to the Inspector tab to see the list of signals the player can emit:"
msgstr ""
"这段代码定义了一个叫 “hit” 的自定义信号，当我们的游戏角色撞到某个敌人的时候，"
"我们就让 “hit” 发射(发送出去)。我们用 ``Area2D`` 来检测碰撞，选择 ``Player`` "
"节点并点击属性面板标签页旁的 “节点” 标签页来查看游戏角色能够发射的所有信号:"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:441
#, fuzzy
msgid ""
"Notice our custom \"hit\" signal is there as well! Since our enemies are "
"going to be ``RigidBody2D`` nodes, we want the ``body_entered( Object "
"body )`` signal; this will be emitted when a body contacts the player. Click "
"\"Connect..\" and then \"Connect\" again on the \"Connecting Signal\" "
"window. We don't need to change any of these settings - Godot will "
"automatically create a function in your player's script. This function will "
"be called whenever the signal is emitted - it *handles* the signal."
msgstr ""
"请注意，我们自定义的 “hit” 信号也在其中！因为我们的敌人会是 ``RigidBody2D`` "
"节点，因此我们要的是 ``body_entered( Object body )`` 信号；它会在一个实体与游"
"戏角色接触时被发射出去。点击 “连接到……” 然后在 “连接信号” 窗口下再次点击 “连"
"接” 。我们不需要对任何设定做改变——Godot会在您的游戏角色脚本中自动创建一个叫"
"做 ``_on_Player_body_entered`` 的函数。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:450
msgid ""
"When connecting a signal, instead of having Godot create a function for you, "
"you can also give the name of an existing function that you want to link the "
"signal to."
msgstr ""
"当连接一个信号时，除了Godot为您创建的函数之外，您也要给出一个已有函数的名称用"
"于将信号连接到它上。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:454
msgid "Add this code to the function:"
msgstr "为该节点添加函数:"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:473
msgid ""
"Each time an enemy hits the player, the signal is going to be emitted. We "
"need to disable the player's collision so that we don't trigger the ``hit`` "
"signal more than once."
msgstr ""
"每次敌人击中玩家时, 都会发出信号。我们需要禁用玩家的碰撞, 这样我们就不会多次"
"触发 ``hit`` 信号。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:477
msgid ""
"Disabling the area's collision shape can cause an error if it happens in the "
"middle of the engine's collision processing. Using ``call_deferred()`` "
"allows us to have Godot wait to disable the shape until it's safe to do so."
msgstr ""
"如果发生在发动机碰撞处理的中间, 禁用该区域的碰撞形状可能会导致错误。使用 "
"``call_deferred()`` 允许我们让 Godot 等待禁用形状, 直到这样做是安全的。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:482
msgid ""
"The last piece for our player is to add a function we can call to reset the "
"player when starting a new game."
msgstr "游戏角色的最后一部分就是添加一个功能，用于在开始新游戏时重置游戏角色。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:503
msgid "Enemy scene"
msgstr "敌人场景"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:505
msgid ""
"Now it's time to make the enemies our player will have to dodge. Their "
"behavior will not be very complex: mobs will spawn randomly at the edges of "
"the screen and move in a random direction in a straight line, then despawn "
"when they go offscreen."
msgstr ""
"现在是时候去做一些游戏角色必须躲避的敌人了。他们的行为并不复杂:怪物会在屏幕边"
"缘随机生成并以随机方向沿直线运动，然后会在离开屏幕时消失。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:510
msgid ""
"We will build this into a ``Mob`` scene, which we can then *instance* to "
"create any number of independent mobs in the game."
msgstr ""
"我们会将其构建到 ``Mob`` 场景中，我们稍后会实例化这个场景来在游戏中创建若干个"
"独立的怪物。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:514
msgid "Node setup"
msgstr "节点设置"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:516
msgid "Click Scene -> New Scene and we'll create the Mob."
msgstr "点击场景→新建场景，然后我们就可以创建Mob了。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:518
msgid "The Mob scene will use the following nodes:"
msgstr "Mob场景将会使用如下节点:"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:520
msgid ":ref:`RigidBody2D <class_RigidBody2D>` (named ``Mob``)"
msgstr ":ref:`RigidBody2D <class_RigidBody2D>` (名为 ``Mob``)"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:522
msgid ":ref:`AnimatedSprite <class_AnimatedSprite>`"
msgstr ":ref:`AnimatedSprite <class_AnimatedSprite>`"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:523
msgid ":ref:`CollisionShape2D <class_CollisionShape2D>`"
msgstr ":ref:`CollisionShape2D <class_CollisionShape2D>`"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:524
msgid ""
":ref:`VisibilityNotifier2D <class_VisibilityNotifier2D>` (named "
"``Visibility``)"
msgstr "\n"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:526
msgid ""
"Don't forget to set the children so they can't be selected, like you did "
"with the Player scene."
msgstr "别忘记设置其子节点以不被选中，就像您在处理Player场景时一样。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:529
msgid ""
"In the :ref:`RigidBody2D <class_RigidBody2D>` properties, set ``Gravity "
"Scale`` to ``0``, so the mob will not fall downward. In addition, under the "
"``PhysicsBody2D`` section, click the ``Mask`` property and uncheck the first "
"box. This will ensure the mobs do not collide with each other."
msgstr ""
"在 :ref:`RigidBody2D <class_RigidBody2D>` 属性中，设置 ``Gravity Scale`` 为 "
"``0``，以防止怪物向下移动。此外，在 ``PhysicsBody2D`` 部分下，点击 ``Mask`` "
"属性并去除第一个复选框的勾选，这会确保怪物不会彼此碰撞。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:536
msgid ""
"Set up the :ref:`AnimatedSprite <class_AnimatedSprite>` like you did for the "
"player. This time, we have 3 animations: ``fly``, ``swim``, and ``walk``. "
"Set the ``Playing`` property in the Inspector to \"On\" and adjust the "
"\"Speed (FPS)\" setting as shown below. We'll select one of these animations "
"randomly so that the mobs will have some variety."
msgstr ""
"设置 :ref:`AnimatedSprite <class_AnimatedSprite>` 就像您为游戏角色做的那样。"
"这一次, 我们有3动画: ``fly``, ``swim``, 和 ``walk``。将属性面板中的 "
"``Playing`` 属性设置为 \"On\" 并调整 \"速度 (FPS)\" 设置, 如下所示。我们将随"
"机选择这些动画之一, 使怪物将有一些变量。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:543
msgid ""
"``fly`` should be set to 3 FPS, with ``swim`` and ``walk`` set to 4 FPS."
msgstr "``fly`` 应设置为3 FPS, ``swim`` 和 ``walk``应设置为4 FPS."

#: ../../docs/getting_started/step_by_step/your_first_game.rst:545
msgid ""
"Like the player images, these mob images need to be scaled down. Set the "
"``AnimatedSprite``'s ``Scale`` property to ``(0.75, 0.75)``."
msgstr ""
"像游戏角色图片一样，这些怪物的图片也要缩小。设置 ``AnimatedSprite`` 的 "
"``Scale`` 属性为 ``(0.75, 0.75)``。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:548
msgid ""
"As in the ``Player`` scene, add a ``CapsuleShape2D`` for the collision. To "
"align the shape with the image, you'll need to set the ``Rotation Degrees`` "
"property to ``90`` under ``Node2D``."
msgstr ""
"正如在 \"游戏角色\" 场景中, 添加一个 \"CapsuleShape2D\" 的碰撞。要将形状与图"
"像对齐, 您需要将 \"Rotation Degrees\" 属性设置为 \"Node2D\" 下的 \"90\"。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:553
msgid "Enemy script"
msgstr "敌人的脚本"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:555
msgid "Add a script to the ``Mob`` and add the following member variables:"
msgstr "添加一条脚本到 ``Mob`` 然后添加以下成员变量:"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:581
#, fuzzy
msgid ""
"When we spawn a mob, we'll pick a random value between ``min_speed`` and "
"``max_speed`` for how fast each mob will move (it would be boring if they "
"were all moving at the same speed). We also have an array containing the "
"names of the three animations, which we'll use to select a random one. Make "
"sure you've spelled these the same in the script and in the SpriteFrames "
"resource."
msgstr ""
"我们将在\"min_speed\"和\"max_speed\"之间选择一个随机值来表示每个怪物移动的速"
"度(如果它们都以相同的速度移动会很无趣)。在属性面板里将他们设置成\"150\"和"
"\"250\"。我们还需要一个包含三个动画名字的数组，并随机选择其中一个。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:587
msgid ""
"Now let's look at the rest of the script. In ``_ready()`` we randomly choose "
"one of the three animation types:"
msgstr ""
"现在让我们来看看脚本的其余部分。在\"_ready()\" 中，我们从三个动画类型中随机选"
"择一个:"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:606
msgid ""
"You must use ``randomize()`` if you want your sequence of \"random\" numbers "
"to be different every time you run the scene. We're going to use "
"``randomize()`` in our ``Main`` scene, so we won't need it here. ``randi() % "
"n`` is the standard way to get a random integer between ``0`` and ``n-1``."
msgstr ""
"如果希望每次打开场景时，您的\"random\"成员顺序都不一样，则必须使用 "
"``randomize()`` 。我们将会在我们的 ``Main`` 场景中使用 ``randomize()``，所以"
"我们不会在这里使用。 ``randi() % n``是一种标准的方式，用于产生 ``0`` 到 "
"``n-1`` 的随机整数。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:612
msgid ""
"The last piece is to make the mobs delete themselves when they leave the "
"screen. Connect the ``screen_exited()`` signal of the ``Visibility`` node "
"and add this code:"
msgstr ""
"最后一部分就是，当怪物离开屏幕后，让他们删除掉自己，连接 ``Visibility`` 的 "
"``screen_exited()`` 信号节点然后增加代码:"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:629
msgid "This completes the `Mob` scene."
msgstr "这会完成 `Mob`场景。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:632
msgid "Main scene"
msgstr "主场景"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:634
msgid ""
"Now it's time to bring it all together. Create a new scene and add a :ref:"
"`Node <class_Node>` named ``Main``. Click the \"Instance\" button and select "
"your saved ``Player.tscn``."
msgstr ""
"现在是时候将其整合起来了。创建一个新场景并添加一个: :ref:`Node <class_Node>` "
"命名为“Main”。点击“实例”按钮并选择您保存的 ``Player.tscn``。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:640
msgid "See :ref:`doc_instancing` to learn more about instancing."
msgstr "查阅 :ref:`doc_instancing` 来学习更多关于实例的知识。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:642
msgid ""
"Now, add the following nodes as children of ``Main``, and name them as shown "
"(values are in seconds):"
msgstr ""
"现在, 将以下节点添加为 \"Main\" 的子级, 并按显示的名称命名它们 (值以秒为单"
"位):"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:645
msgid ""
":ref:`Timer <class_Timer>` (named ``MobTimer``) - to control how often mobs "
"spawn"
msgstr ""
":ref:`Timer <class_Timer>` (命名为 ``MobTimer`` ) - 可用来控制怪物产生的频率"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:646
msgid ""
":ref:`Timer <class_Timer>` (named ``ScoreTimer``) - to increment the score "
"every second"
msgstr ":ref:`Timer <class_Timer>` (命名为 ``ScoreTimer`` ) - 每秒钟增加分数"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:647
msgid ""
":ref:`Timer <class_Timer>` (named ``StartTimer``) - to give a delay before "
"starting"
msgstr ":ref:`Timer <class_Timer>` (命名为 ``StartTimer``)-在开始前给出延迟"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:648
msgid ""
":ref:`Position2D <class_Position2D>` (named ``StartPosition``) - to indicate "
"the player's start position"
msgstr ""
":ref:`Position2D <class_Position2D>` (命名为 ``StartPosition`` ) - 表示游戏角"
"色的起始位置"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:650
msgid ""
"Set the ``Wait Time`` property of each of the ``Timer`` nodes as follows:"
msgstr "设置每个 ``Timer`` 节点的 ``Wait Time`` 属性，如下所示:"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:653
msgid "``MobTimer``: ``0.5``"
msgstr "``MobTimer``: ``0.5``"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:654
msgid "``ScoreTimer``: ``1``"
msgstr "``ScoreTimer``: ``1``"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:655
msgid "``StartTimer``: ``2``"
msgstr "``StartTimer``: ``2``"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:657
msgid ""
"In addition, set the ``One Shot`` property of ``StartTimer`` to \"On\" and "
"set ``Position`` of the ``StartPosition`` node to ``(240, 450)``."
msgstr ""
"另外, 将 \"StartTimer\" 的 \"One Shot\" 属性设置为 \"On\", 并将 "
"\"StartPosition\" 节点的 \"Position\" 设置为 \"(240、450)\"。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:661
msgid "Spawning mobs"
msgstr "生成怪物"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:663
msgid ""
"The Main node will be spawning new mobs, and we want them to appear at a "
"random location on the edge of the screen. Add a :ref:`Path2D "
"<class_Path2D>` node named ``MobPath`` as a child of ``Main``. When you "
"select ``Path2D``, you will see some new buttons at the top of the editor:"
msgstr ""
"主节点将会生成新的怪物，并且我们需要他们出现在屏幕边缘的随机地点。添加一个 :"
"ref:`Path2D <class_Path2D>` 节点，命名为 ``MobPath``，作为 ``Main`` 的子节"
"点。当您选择 ``Path2D`` 后，您就能在编辑器的上方看到一些新按钮:"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:670
msgid ""
"Select the middle one (\"Add Point\") and draw the path by clicking to add "
"the points at the corners shown. To have the points snap to the grid, make "
"sure \"Snap to Grid\" is checked. This option can be found under the "
"\"Snapping options\" button to the left of the \"Lock\" button, appearing as "
"a series of three vertical dots."
msgstr ""
"选择中间的(“添加点”)然后在所示的拐角通过单击来新增点，绘制出路径。要使点吸附"
"到网格，确保“吸附到网格”被选中。此选项可以在“吸附选项(Snapping options)”按钮"
"下方，“锁定(Lock)”按钮的左边找到，以一系列三个垂直点的形式出现。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:678
msgid ""
"Draw the path in *clockwise* order, or your mobs will spawn pointing "
"*outwards* instead of *inwards*!"
msgstr "按 *顺时针* 顺序绘制路径，否则您的怪物会指向 *向外* 而不是 *向内* !"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:681
msgid ""
"After placing point ``4`` in the image, click the \"Close Curve\" button and "
"your curve will be complete."
msgstr "在图像中放置点“4”后，点击“闭合曲线”按钮，您的曲线就完成了。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:684
msgid ""
"Now that the path is defined, add a :ref:`PathFollow2D <class_PathFollow2D>` "
"node as a child of ``MobPath`` and name it ``MobSpawnLocation``. This node "
"will automatically rotate and follow the path as it moves, so we can use it "
"to select a random position and direction along the path."
msgstr ""
"现在已经定义了路径，添加一个 :ref:`PathFollow2D <class_PathFollow2D>` 节点作"
"为 ``MobPath`` 的子节点，并将其命名为 ``MobSpawnLocation``。此节点在移动时将"
"自动旋转并跟随路径，因此我们可以使用它沿路径选择一个随机位置和方向。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:690
msgid "Main script"
msgstr "主脚本"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:692
msgid ""
"Add a script to ``Main``. At the top of the script, we use ``export "
"(PackedScene)`` to allow us to choose the Mob scene we want to instance."
msgstr ""
"在“Main”中添加一个脚本。在脚本的顶部，我们使用' export (PackedScene) ' '来允"
"许我们选择我们想要实例化的Mob场景。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:732
msgid ""
"Drag ``Mob.tscn`` from the \"FileSystem\" panel and drop it in the ``Mob`` "
"property under the Script Variables of the ``Main`` node."
msgstr ""
"从“文件系统”面板中拖动“Mob.tscn”，并将其放在“Main”节点的脚本变量下的“Mob”属性"
"中。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:735
msgid ""
"Next, click on the Player and connect the ``hit`` signal. We want to make a "
"new function named ``game_over``, which will handle what needs to happen "
"when a game ends. Type \"game_over\" in the \"Method In Node\" box at the "
"bottom of the \"Connecting Signal\" window. Add the following code, as well "
"as a ``new_game`` function to set everything up for a new game:"
msgstr ""
"接下来，点击游戏角色并连接“hit”信号。我们希望创建一个名为‘game_over’的新函"
"数，它将处理游戏结束时需要发生的事情。在“连接信号”窗口底部的“方法在节点”框中"
"键入“game_over”。添加以下代码，以及' ' new_game ' '函数来设置新游戏的所有内"
"容:"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:772
#, fuzzy
msgid ""
"Now connect the ``timeout()`` signal of each of the Timer nodes "
"(``StartTimer``, ``ScoreTimer`` ,and ``MobTimer``) to the main script. "
"``StartTimer`` will start the other two timers. ``ScoreTimer`` will "
"increment the score by 1."
msgstr ""
"现在连接每个计时器节点的‘timeout()’信号(‘开始计时器’’、‘记分定时器’和‘移动定"
"时器’’)。“启动定时器”将启动其他两个定时器。‘记分计时器’将分数增加1。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:799
msgid ""
"In ``_on_MobTimer_timeout()``, we will create a mob instance, pick a random "
"starting location along the ``Path2D``, and set the mob in motion. The "
"``PathFollow2D`` node will automatically rotate as it follows the path, so "
"we will use that to select the mob's direction as well as its position."
msgstr ""
"在 ``_on_MobTimer_timeout()`` 函数中,我们将创建一个mob实例，沿着 ``Path2D`` "
"选择一个随机起始位置, 并设置mob的运动。``PathFollow2D`` 节点会随着路径自动旋"
"转，因此我们会使用它来选择mob的方向以及它的位置。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:805
msgid ""
"Note that a new instance must be added to the scene using ``add_child()``."
msgstr "注意，必须使用 ``add_child()`` 将新实例添加到场景中。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:808
msgid ""
"Now click on ``MobTimer`` in the scene window then head to inspector window, "
"switch to node view then click on ``timeout()`` and connect the signal."
msgstr ""
"现在在场景窗口中点击 ``MobTimer`` ，然后前往inspector窗口，切换到节点视图，然"
"后点击 ``timeout()`` 并连接signal。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:811
#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:1091
msgid "Add the following code:"
msgstr "添加以下代码:"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:859
msgid ""
"In functions requiring angles, GDScript uses *radians*, not degrees. If "
"you're more comfortable working with degrees, you'll need to use the "
"``deg2rad()`` and ``rad2deg()`` functions to convert between the two."
msgstr ""
"在需要角度的函数中，GDScript使用 *弧度* ，而不是角度。如果您更喜欢使用角度，"
"则需要使用 ``deg2rad()`` 和 ``rad2deg()`` 函数在角度和弧度之间进行转换。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:865
msgid "HUD"
msgstr "HUD"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:867
msgid ""
"The final piece our game needs is a UI: an interface to display things like "
"score, a \"game over\" message, and a restart button. Create a new scene, "
"and add a :ref:`CanvasLayer <class_CanvasLayer>` node named ``HUD``. \"HUD\" "
"stands for \"heads-up display\", an informational display that appears as an "
"overlay on top of the game view."
msgstr ""
"我们的游戏需要的最后一个部分是UI: 一个用来显示诸如分数，“游戏结束”消息和重新"
"开始按钮等的界面。创建一个新场景，并添加命名为 ``HUD`` 的 :ref:`CanvasLayer "
"<class_CanvasLayer>` 节点。\"HUD\"代表\"平视显示\", 一种显示在游戏视图上面的"
"信息显示。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:873
msgid ""
"The :ref:`CanvasLayer <class_CanvasLayer>` node lets us draw our UI elements "
"on a layer above the rest of the game, so that the information it displays "
"isn't covered up by any game elements like the player or mobs."
msgstr ""
":ref:`CanvasLayer <class_CanvasLayer>` 节点允许我们在游戏其余部分上面的层上绘"
"制UI元素， 以便其显示的信息不会被任何游戏元素覆盖，比如游戏角色或mobs。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:877
msgid "The HUD displays the following information:"
msgstr "HUD显示以下信息:"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:879
msgid "Score, changed by ``ScoreTimer``."
msgstr "分数，用 ``ScoreTimer`` 改变。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:880
msgid "A message, such as \"Game Over\" or \"Get Ready!\""
msgstr "一条信息，如”Game Over“或”Get Ready！“"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:881
msgid "A \"Start\" button to begin the game."
msgstr "一个“Start”按钮来开始游戏。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:883
msgid ""
"The basic node for UI elements is :ref:`Control <class_Control>`. To create "
"our UI, we'll use two types of :ref:`Control <class_Control>` nodes: :ref:"
"`Label <class_Label>` and :ref:`Button <class_Button>`."
msgstr ""
"UI元素的基本节点是 :ref:`Control <class_Control>`。要创造UI，我们会使用 :ref:"
"`Control <class_Control>` 的两种节点: :ref:`Label <class_Label>` 和 :ref:"
"`Button <class_Button>` 。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:887
msgid "Create the following as children of the ``HUD`` node:"
msgstr "创造以下节点作为 ``HUD`` 的子节点:"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:889
msgid ":ref:`Label <class_Label>` named ``ScoreLabel``."
msgstr ":ref:`Label <class_Label>` 命名为 ``ScoreLabel``。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:890
msgid ":ref:`Label <class_Label>` named ``MessageLabel``."
msgstr ":ref:`Label <class_Label>` 命名为 ``MessageLabel``。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:891
msgid ":ref:`Button <class_Button>` named ``StartButton``."
msgstr ":ref:`Button <class_Button>` 命名为 ``StartButton``。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:892
msgid ":ref:`Timer <class_Timer>` named ``MessageTimer``."
msgstr ":ref:`Timer <class_Timer>` 命名为 ``MessageTimer`` 。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:894
#, fuzzy
msgid ""
"Click on the ``ScoreLabel`` and type a number into the _Text_ field in the "
"Inspector. The default font for ``Control`` nodes is small and doesn't scale "
"well. There is a font file included in the game assets called \"Xolonium-"
"Regular.ttf\". To use this font, do the following for each of the three "
"``Control`` nodes:"
msgstr ""
"为了使 ``MessageLabel`` 中的文本适配游戏窗口，点击文本属性旁边的小图标。这会"
"打开一个新窗口，使您可以在单词之间添加新行。 ``Control`` 节点的默认字体很小并"
"且不能很好的缩放。在游戏资源中包含一个名为 \"Xolonium-Regular.ttf\" 的字体。"
"要使用这个字体，为三个 ``Control`` 节点分别执行以下操作:"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:900
msgid "Under \"Custom Fonts\", choose \"New DynamicFont\""
msgstr "在 \"Custom Fonts\" 的下拉选项中，选择 \"New DynamicFont\""

#: ../../docs/getting_started/step_by_step/your_first_game.rst:904
#, fuzzy
msgid ""
"Click on the \"DynamicFont\" you added, and under \"Font/Font Data\", choose "
"\"Load\" and select the \"Xolonium-Regular.ttf\" file. You must also set the "
"font's ``Size``. A setting of ``64`` works well."
msgstr ""
"点击您添加的 \"DynamicFont\" ，然后在 \"Font Data\" 的下拉选项中选择 \"Load"
"\" 并选择 \"Xolonium-Regular.ttf\" 文件。您还必须设置字体的 ``Size`` 。设置"
"为 ``64`` 就可以了。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:910
msgid ""
"**Anchors and Margins:** ``Control`` nodes have a position and size, but "
"they also have anchors and margins. Anchors define the origin - the "
"reference point for the edges of the node. Margins update automatically when "
"you move or resize a control node. They represent the distance from the "
"control node's edges to its anchor. See :ref:"
"`doc_design_interfaces_with_the_control_nodes` for more details."
msgstr ""
"**锚点和边距**: ``Control`` 节点不仅有位置和大小，也有锚点和边距。锚点定义了"
"原点 - 节点边缘的参考点。 当您移动或调整Control节点大小时，边距会自定更新。它"
"们表示从Control节点的边缘到其锚点的距离。详情请参阅 :ref:"
"`doc_design_interfaces_with_the_control_nodes` 。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:917
msgid ""
"Arrange the nodes as shown below. Click the \"Anchor\" button to set a "
"Control node's anchor:"
msgstr "按如下图所示排列节点。 点击\"Anchor\"按钮来设置Control节点的锚点:"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:922
msgid ""
"You can drag the nodes to place them manually, or for more precise "
"placement, use the following settings:"
msgstr "您可以手动拖动节点来放置它们，或者为了更精确的放置，使用以下设置:"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:926
msgid "ScoreLabel"
msgstr "记分牌"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:928
#, fuzzy
msgid "*Text* : ``0``"
msgstr "文本: ``0``"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:929
msgid "*Layout* : \"Top Wide\""
msgstr "*布局*: \"顶部宽\""

#: ../../docs/getting_started/step_by_step/your_first_game.rst:930
#: ../../docs/getting_started/step_by_step/your_first_game.rst:937
msgid "*Align* : \"Center\""
msgstr "*对齐*: \"居中\""

#: ../../docs/getting_started/step_by_step/your_first_game.rst:933
msgid "MessageLabel"
msgstr "消息标签"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:935
#, fuzzy
msgid "*Text* : ``Dodge the Creeps!``"
msgstr "文本: ``Dodge the Creeps!``"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:936
#, fuzzy
msgid "*Layout* : \"HCenter Wide\""
msgstr "``布局``: \"中心\""

#: ../../docs/getting_started/step_by_step/your_first_game.rst:940
msgid "StartButton"
msgstr "启动按钮"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:942
#, fuzzy
msgid "*Text* : ``Start``"
msgstr "文本: ``Start``"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:943
#, fuzzy
msgid "*Layout* : \"Center Bottom\""
msgstr "``布局``: \"中心 底部\""

#: ../../docs/getting_started/step_by_step/your_first_game.rst:944
#, fuzzy
msgid "*Margin* :"
msgstr "边距"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:946
msgid "Top: ``-200``"
msgstr "顶部: ``-200``"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:947
msgid "Bottom: ``-100``"
msgstr "底部: ``-100``"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:949
msgid "Now add this script to ``HUD``:"
msgstr "现在增加该脚本到 ``HUD``:"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:968
msgid ""
"The ``start_game`` signal tells the ``Main`` node that the button has been "
"pressed."
msgstr "“start_game”信号告诉“Main”节点按钮已经被按下。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:990
msgid ""
"This function is called when we want to display a message temporarily, such "
"as \"Get Ready\". On the ``MessageTimer``, set the ``Wait Time`` to ``2`` "
"and set the ``One Shot`` property to \"On\"."
msgstr ""
"当我们想要显示一条临时消息时，比如 \"Get Ready\" ，就会调用这个函数。在 "
"``MessageTimer`` 中，将 ``Wait Time`` 设置为 ``2`` 并将 ``One Shot`` 属性设置"
"为 \"On\" 。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:1021
#, fuzzy
msgid ""
"This function is called when the player loses. It will show \"Game Over\" "
"for 2 seconds, then return to the title screen and, after a brief pause, "
"show the \"Start\" button."
msgstr ""
"当游戏角色输掉时调用这个函数。它将显示 \"Game Over\" 2秒，然后返回标题屏幕并"
"显示 \"Start\" 按钮。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:1025
msgid ""
"When you need to pause for a brief time, an alternative to using a Timer "
"node is to use the SceneTree's ``create_timer()`` function. This can be very "
"useful to delay, such as in the above code, where we want to wait a little "
"bit of time before showing the \"Start\" button."
msgstr ""
"当您需要暂停很短的时间时, 使用 Timer 节点的替代方法是使用场景树的 "
"``create_timer()`` 功能。这对于延迟非常有用, 例如在上面的代码中, 我们要等待一"
"点时间后再显示 “Start” 按钮。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:1043
msgid "This function is called by ``Main`` whenever the score changes."
msgstr "每当分数改变，这个函数会在 ``Main`` 场景中被调用。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:1045
msgid ""
"Connect the ``timeout()`` signal of ``MessageTimer`` and the ``pressed()`` "
"signal of ``StartButton``."
msgstr "连接‘MessageTimer’的‘timeout()’信号和‘StartButton’的‘pressed()’信号。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:1072
msgid "Connecting HUD to Main"
msgstr "将HUD场景连接到Main场景"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:1074
msgid ""
"Now that we're done creating the ``HUD`` scene, save it and go back to "
"``Main``. Instance the ``HUD`` scene in ``Main`` like you did the ``Player`` "
"scene, and place it at the bottom of the tree. The full tree should look "
"like this, so make sure you didn't miss anything:"
msgstr ""
"现在我们完成了创建 ``HUD`` 场景，保存并返回 ``Main`` 场景。和 ``Player`` 场景"
"的做法一样在 ``Main`` 场景中实例化 ``HUD`` 场景， 并把它放置到场景树的底部。 "
"完整的场景树看起来应该像这样，所以确保您没有错过任何东西:"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:1081
msgid ""
"Now we need to connect the ``HUD`` functionality to our ``Main`` script. "
"This requires a few additions to the ``Main`` scene:"
msgstr ""
"现在我们需要将 ``HUD`` 功能与我们的 ``Main`` 脚本连接起来。这需要在 ``Main`` "
"场景中添加一些内容:"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:1084
msgid ""
"In the Node tab, connect the HUD's ``start_game`` signal to the "
"``new_game()`` function."
msgstr ""
"在Node选项卡中， 将HUD的 ``start_game`` 信号连接到 ``new_game()`` 函数。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:1087
msgid ""
"In ``new_game()``, update the score display and show the \"Get Ready\" "
"message:"
msgstr "在 ``new_game()`` 函数中， 更新分数显示并显示 \"Get Ready\" 消息:"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:1102
msgid "In ``game_over()`` we need to call the corresponding ``HUD`` function:"
msgstr "在 ``game_over()`` 中我们需要调用相应的 ``HUD`` 函数:"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:1113
msgid ""
"Finally, add this to ``_on_ScoreTimer_timeout()`` to keep the display in "
"sync with the changing score:"
msgstr ""
"最后，将下面的代码添加到 ``_on_ScoreTimer_timeout()`` 以保持不断变化的分数的"
"同步显示:"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:1125
msgid ""
"Now you're ready to play! Click the \"Play the Project\" button. You will be "
"asked to select a main scene, so choose ``Main.tscn``."
msgstr ""
"现在您准备好了！点击\"Play the Project\"按钮。您会被要求选择主场景，这里选择 "
"``Main.tscn`` 。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:1129
msgid "Finishing up"
msgstr "完成了"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:1131
msgid ""
"We have now completed all the functionality for our game. Below are some "
"remaining steps to add a bit more \"juice\" to improve the game experience. "
"Feel free to expand the gameplay with your own ideas."
msgstr ""
"现在我们已经完成了游戏的所有功能。下面是一些额外的步骤，添加更多的\"juice\"来"
"提升游戏体验。您可以用您自己的想法来扩展游戏玩法。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:1136
#: ../../docs/tutorials/3d/environment_and_post_processing.rst:59
msgid "Background"
msgstr "背景"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:1138
msgid ""
"The default gray background is not very appealing, so let's change its "
"color. One way to do this is to use a :ref:`ColorRect <class_ColorRect>` "
"node. Make it the first node under ``Main`` so that it will be drawn behind "
"the other nodes. ``ColorRect`` only has one property: ``Color``. Choose a "
"color you like and drag the size of the ``ColorRect`` so that it covers the "
"screen."
msgstr ""
"默认的灰色背景不是很吸引人， 让我们改变它的颜色。 一种方法是使用 :ref:"
"`ColorRect <class_ColorRect>` 节点。使它成为 ``Main`` 场景下的第一个节点，这"
"样它就会被绘制到其它节点的后面。 ``ColorRect`` 只有一个属性: ``Color`` 。选择"
"一个您喜欢的颜色并拖拽 ``ColorRect`` 的大小使它覆盖整个屏幕。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:1145
msgid ""
"You could also add a background image, if you have one, by using a "
"``Sprite`` node."
msgstr "如果您有背景图片，您也可以通过使用 ``Sprite`` 节点来添加背景图片。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:1149
msgid "Sound effects"
msgstr "声音效果"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:1151
msgid ""
"Sound and music can be the single most effective way to add appeal to the "
"game experience. In your game assets folder, you have two sound files: "
"\"House In a Forest Loop.ogg\" for background music, and \"gameover.wav\" "
"for when the player loses."
msgstr ""
"声音和音乐是增加游戏体验的吸引力的最有效的方式。在游戏资源文件夹中，有两个声"
"音文件:\"House In a Forest Loop.ogg\"用于背景音乐， \"gameover.wav\"将在游戏"
"角色输掉游戏时播放。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:1156
msgid ""
"Add two :ref:`AudioStreamPlayer <class_AudioStreamPlayer>` nodes as children "
"of ``Main``. Name one of them ``Music`` and the other ``DeathSound``. On "
"each one, click on the ``Stream`` property, select \"Load\", and choose the "
"corresponding audio file."
msgstr ""
"在 ``Main`` 场景中添加两个 :ref:`AudioStreamPlayer "
"<class_AudioStreamPlayer>` 节点。一个命名为 ``Music``，另一个命名为 "
"``DeathSound`` 。在每个节点选项上，点击 ``Stream``属性， 选择\"Load\"，然后选"
"择相应的音频文件。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:1161
msgid ""
"To play the music, add ``$Music.play()`` in the ``new_game()`` function and "
"``$Music.stop()`` in the ``game_over()`` function."
msgstr ""
"要播放音乐，在 ``new_game()`` 函数中添加 ``$Music.play()``，在 "
"``game_over()`` 函数中添加 ``$Music.stop()`` 。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:1164
msgid "Finally, add ``$DeathSound.play()`` in the ``game_over()`` function."
msgstr "最后， 在 ``game_over()`` 函数中添加 ``$DeathSound.play()`` 。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:1167
msgid "Keyboard Shortcut"
msgstr "键盘快捷键"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:1169
msgid ""
"Since the game is played with keyboard controls, it would be convenient if "
"we could also start the game by pressing a key on the keyboard. One way to "
"do this is using the \"Shortcut\" property of the ``Button`` node."
msgstr ""
"因为游戏是用键盘控制的，如果我们也能按下键盘上的一个键来开始游戏就会很方"
"便。\n"
"一种方法是使用`Button`节点的“快捷方式”属性。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:1173
msgid ""
"In the ``HUD`` scene, select the ``StartButton`` and find its _Shortcut_ "
"property in the Inspector. Select \"New Shortcut\" and click on the "
"\"Shortcut\" item. A second _Shortcut_ property will appear. Select \"New "
"InputEventAction\" and click the new \"InputEvent\". Finally, in the "
"_Action_ property, type the name \"ui_select\". This is the default input "
"event associated with the spacebar."
msgstr ""
"在`HUD`场景中，选择`StartButton`并在Inspector中找到它的_Shortcut_属性。\n"
"选择“新建快捷方式”，点击“快捷方式”项。\n"
"第二个_Shortcut_属性将出现。\n"
"选择“New InputEventAction”并单击新的“InputEvent”。\n"
"最后，在_Action_属性中输入名称“ui_select”。\n"
"这是与空格键关联的默认输入事件。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:1181
msgid ""
"Now when the start button appears, you can either click it or press the "
"spacebar to start the game."
msgstr "现在，当开始按钮出现时，您可以单击它或按空格键来启动游戏。"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:1185
msgid "Project files"
msgstr "项目文件"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:1188
msgid "You can find a completed version of this project at these locations:"
msgstr "您可以在这里找到这个项目的完整版本:"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:1188
msgid "https://github.com/kidscancode/Godot3_dodge/releases"
msgstr "https://github.com/kidscancode/Godot3_dodge/releases"

#: ../../docs/getting_started/step_by_step/your_first_game.rst:1189
msgid "https://github.com/godotengine/godot-demo-projects"
msgstr "https://github.com/godotengine/godot-demo-projects"

#: ../../docs/getting_started/step_by_step/exporting.rst:4
#: ../../docs/getting_started/editor/command_line_tutorial.rst:130
msgid "Exporting"
msgstr "导出"

#: ../../docs/getting_started/step_by_step/exporting.rst:9
msgid ""
"Now that you have a working game, you probably want to share your success "
"with others. However, it's not practical to ask your friends to download "
"Godot just so they can open your project. Instead, you can *export* your "
"project, converting it into a \"package\" that can be run by anyone."
msgstr ""
"现在您已经有了一个可以运行的游戏，您可能想要和别人分享您的成果。然而，让您的"
"朋友下载Godot而只是为了打开您的项目是不实际的。相反，您可以 *export* 您的项"
"目，将其转换为任何人都可以运行的\"package\"。"

#: ../../docs/getting_started/step_by_step/exporting.rst:14
msgid ""
"The way you export your game depends on what platform you are targeting. In "
"this tutorial, you'll learn how to export the \"Dodge the Creeps\" game for "
"a variety of platforms. First, however, we need to make some changes to the "
"way the game works."
msgstr ""
"导出游戏的方式取决于您的目标平台。本教程中，您将学习如何将\"Dodge the Creeps"
"\"游戏导出到各种平台。然而，首先我们需要对游戏的工作方式做一些改变。"

#: ../../docs/getting_started/step_by_step/exporting.rst:19
msgid ""
"If you haven't made \"Dodge the Creeps\" yourself yet, please read :ref:"
"`doc_your_first_game` before continuing with this tutorial."
msgstr ""
"如果您还没有自己完成\"Dodge the Creeps\"游戏，请阅读 :ref:"
"`doc_your_first_game` 后再继续本教程。"

#: ../../docs/getting_started/step_by_step/exporting.rst:23
msgid "Preparing the project"
msgstr "准备项目"

#: ../../docs/getting_started/step_by_step/exporting.rst:25
msgid ""
"In \"Dodge the Creeps\" we used keyboard controls to move the player's "
"character. This is fine if your game is being played on a PC platform, but "
"on a phone or tablet, you need to support touchscreen input. Because a click "
"event can be treated the same as a touch event, we'll convert the game to a "
"click-and-move input style."
msgstr ""
"在\"Dodge the Creeps\"中我们使用键盘控制游戏角色角色的移动。如果您的游戏是在"
"PC平台上玩的，这没问题，但在手机或平板上，您需要支持触屏输入。因为点击事件可"
"以被视为触摸事件，我们将把游戏转换为click-and-move输入风格。"

#: ../../docs/getting_started/step_by_step/exporting.rst:31
msgid ""
"By default Godot emulates mouse input from touch input. That means if "
"anything is coded to happen on a mouse event, touch will trigger it as well. "
"If you wish to disable that for whatever reason, or emulate touch from mouse "
"input, you can do that in the \"Project Settings\" under *Input Devices* and "
"*Pointing*"
msgstr ""

#: ../../docs/getting_started/step_by_step/exporting.rst:38
#, fuzzy
msgid ""
"Before we change the input method, in the project settings go to *Display*, "
"then click on *Window*. In the *Stretch* options, set *Mode* to \"2d\" and "
"*Aspect* to \"keep\". This ensures that the game scales consistently on "
"different sized screens."
msgstr ""
"在 *Stretch* 部分，设置 *Mode* 值为\"2d\"并设置 *Aspect* 值为 ”keep\" 。这确"
"保游戏在不同大小的屏幕上保持一致的缩放。"

#: ../../docs/getting_started/step_by_step/exporting.rst:44
msgid ""
"Next, we need to modify the ``Player.gd`` script to change the input method. "
"We'll remove the key inputs and make the player move towards a \"target\" "
"that's set by the touch (or click) event."
msgstr ""
"接下来，我们需要修改 ``Player.gd`` 脚本来改变输入方式。我们将移除键盘输入并使"
"游戏角色移动到触摸(或点击)事件设置的\"目标\"。"

#: ../../docs/getting_started/step_by_step/exporting.rst:48
msgid ""
"Here is the full script for the player, with comments noting what we've "
"changed:"
msgstr "这是游戏角色的完整脚本，注释指出了我们做了哪些改变:"

#: ../../docs/getting_started/step_by_step/exporting.rst:123
#: ../../docs/getting_started/workflow/export/exporting_projects.rst:92
#: ../../docs/development/compiling/introduction_to_the_buildsystem.rst:198
#: ../../docs/development/compiling/compiling_with_mono.rst:126
msgid "Export templates"
msgstr "导出模板"

#: ../../docs/getting_started/step_by_step/exporting.rst:125
msgid ""
"In order to export, you need to download the *export templates* from the "
"http://godotengine.org/download. These templates are optimized versions of "
"the engine without the editor pre-compiled for each platform . You can also "
"download them in Godot by clicking on *Editor -> Manage Export Templates*:"
msgstr ""
"为了导出，您需要从http://godotengine.org/download中下载 *export templates* 。"
"这些模板是编辑器没有为每个平台预编译的引擎的优化版本。您还可以在Godot中通过点"
"击 *Editor -> Manage Export Templates* 进行下载:"

#: ../../docs/getting_started/step_by_step/exporting.rst:132
msgid ""
"In the window that appears, you can click \"Download\" to get the template "
"version that matches your version of Godot."
msgstr ""
"在出现的窗口中，您可以点击 \"Download\" 以获得与您的Godot版本匹配的模板版本。"

#: ../../docs/getting_started/step_by_step/exporting.rst:137
msgid ""
"If you upgrade Godot, you must download templates that match the new version "
"or your exported projects may not work correctly."
msgstr ""
"如果您升级了Godot，您必须下载匹配新版本的模板否则导出的项目可能无法正常工作。"

#: ../../docs/getting_started/step_by_step/exporting.rst:141
msgid "Export presets"
msgstr "导出设置"

#: ../../docs/getting_started/step_by_step/exporting.rst:143
msgid ""
"Next, you can configure the export settings by clicking on *Project -> "
"Export*:"
msgstr "接下来，您可以通过点击 *Project -> Export* 来配置导出设置:"

#: ../../docs/getting_started/step_by_step/exporting.rst:147
msgid ""
"Create a new export preset by clicking \"Add...\" and selecting a platform. "
"You can make as many presets as you like with different settings."
msgstr ""
"通过点击 \"Add...\" 并选择一个平台来创建一个新的导出预设(preset)。您可以使用"
"不同的设置创建多个预设。"

#: ../../docs/getting_started/step_by_step/exporting.rst:150
msgid ""
"At the bottom of the window are two buttons. \"Export PCK/ZIP\" only creates "
"a packed version of your project's data. This doesn't include an executable "
"so the project can't be run on its own."
msgstr ""
"窗口的底部有两个按钮。 \"Export PCK/ZIP\" 只创建项目数据的打包版本。这并不包"
"括可执行文件，因此项目不能自行运行。"

#: ../../docs/getting_started/step_by_step/exporting.rst:154
msgid ""
"The second button, \"Export Project\", creates a complete executable version "
"of your game, such as an `.apk` for Android or an `.exe` for Windows."
msgstr ""
"第二个按钮， \"Export Project\" ，创建游戏的完整可执行版本，如Android平台的 "
"`.apk`或者 Windows 平台的 `.exe` 。"

#: ../../docs/getting_started/step_by_step/exporting.rst:157
msgid ""
"In the \"Resources\" and \"Features\" tabs, you can customize how the game "
"is exported for each platform. We can leave those settings alone for now."
msgstr ""
"在 \"Resources\" 和 ”Features\" 选项卡中，您可以自定义如何为每个平台导出游"
"戏。我们可以先不考虑这些设置。"

#: ../../docs/getting_started/step_by_step/exporting.rst:161
msgid "Exporting by platform"
msgstr "按平台导出"

#: ../../docs/getting_started/step_by_step/exporting.rst:163
msgid ""
"In this section, we'll walk through the process for each platform, including "
"any additional software or requirements you'll need."
msgstr "在本节中，我们将介绍每个平台的流程，包括您需要的任何其他软件或需求。"

#: ../../docs/getting_started/step_by_step/exporting.rst:167
msgid "PC (Linux/macOS/Windows)"
msgstr "桌面端 (Linux/macOS/Windows)"

#: ../../docs/getting_started/step_by_step/exporting.rst:169
msgid ""
"Exporting PC platforms works the same across the three supported operating "
"systems. Open the export window and click \"Add..\" to create the preset(s) "
"you want to make. Then click \"Export Project\" and choose a name and "
"destination folder. Choose a location *outside* of your project folder."
msgstr ""
"导出PC平台在三种支持的操作系统中的工作方式相同。 打开导出窗口，然后单击 "
"\"Add..\" 以创建要制作的预设。 然后单击 \"Export Project\" 并选择名称和目标文"
"件夹。 选择项目文件夹 *外* 的位置。"

#: ../../docs/getting_started/step_by_step/exporting.rst:174
msgid "Click \"Save\" and the engine will build the export files."
msgstr "单击“Save”，引擎将构建导出文件。"

#: ../../docs/getting_started/step_by_step/exporting.rst:176
msgid ""
"When exporting for macOS, if you export on a macOS computer, you'll end up "
"with a `.dmg` file, while using Linux or Windows produces a `.zip`. In "
"either case, the compressed file contains a macOS `.app` that you can double-"
"click and run."
msgstr ""
"当为macOS导出时，如果您在macOS计算机上导出，您会得到'.dmg'文件，当使用Linux或"
"Windows时产生一个' .zip '。无论哪种情况，压缩文件都包含一个在macOS下可以双击"
"并运行的'.app'。"

#: ../../docs/getting_started/step_by_step/exporting.rst:181
msgid ""
"On Windows, if you want your exported executable to have a different icon "
"than the default one, you need to change it manually. See: :ref:"
"`doc_changing_application_icon_for_windows`."
msgstr ""
"在Windows上，如果您希望导出的可执行文件具有与默认图标不同的图标，则需要手动更"
"改它。看: :ref:`doc_changing_application_icon_for_windows`。"

#: ../../docs/getting_started/step_by_step/exporting.rst:188
msgid ""
"Mobile devices come with a wide variety of capabilities. In most cases, "
"Godot's default settings will work, but mobile development is sometimes more "
"art than science, and you may need to do some experimenting and searching "
"for help in order to get everything working."
msgstr ""
"移动设备具有各种各样的功能。在大多数情况下，Godot的默认设置是可以工作的，但是"
"移动开发有时更多的是艺术而不是科学，您可能需要做一些试验和寻找帮助，以使一切"
"工作正常。"

#: ../../docs/getting_started/step_by_step/exporting.rst:194
msgid ""
"Before you can export your project for Android, you must download the "
"following software:"
msgstr "在导出Android项目之前，您必须下载以下软件:"

#: ../../docs/getting_started/step_by_step/exporting.rst:197
msgid "Android SDK: https://developer.android.com/studio/"
msgstr "Android SDK: https://developer.android.com/studio/"

#: ../../docs/getting_started/step_by_step/exporting.rst:198
msgid ""
"Java JDK: http://www.oracle.com/technetwork/java/javase/downloads/index.html"
msgstr ""
"Java的JDK: http://www.oracle.com/technetwork/java/javase/downloads/index.html"

#: ../../docs/getting_started/step_by_step/exporting.rst:200
msgid ""
"When you run Android Studio for the first time, click on *Configure -> SDK "
"Manager* and install \"Android SDK Platform Tools\". This installs the `adb` "
"command-line tool that Godot uses to communicate with your device."
msgstr ""
"第一次运行Android Studio时，点击*Configure -> SDK Manager*安装“Android SDK平"
"台工具”。这将安装Godot用来与设备通信的“adb”命令行工具。"

#: ../../docs/getting_started/step_by_step/exporting.rst:204
msgid ""
"Next, create a debug keystore by running the following command on your "
"system's command line:"
msgstr "接下来，通过在系统的命令行上运行以下命令，创建一个调试密钥库:"

#: ../../docs/getting_started/step_by_step/exporting.rst:211
msgid ""
"Click on *Editor -> Editor Settings* in Godot and select the *Export/"
"Android* section. Here, you need to set the paths to the Android SDK "
"applications on your system and the location of the keystore you just "
"created."
msgstr ""
"在Godot中单击*Editor ->Editor Settings *并选择* Export/Android*部分。这里，您"
"需要设置系统上Android SDK应用程序的路径和刚才创建的密钥存储库的位置。"

#: ../../docs/getting_started/step_by_step/exporting.rst:217
msgid ""
"Now you're ready to export. Click on *Project -> Export* and add a preset "
"for Android (see above)."
msgstr "现在可以导出了。点击*Project -> Export*并添加一个Android预设(见上文)。"

#: ../../docs/getting_started/step_by_step/exporting.rst:220
msgid ""
"Click the \"Export Project\" button and Godot will build an APK you can "
"download on your device. To do this on the command line, use the following:"
msgstr ""
"单击“Export Project”按钮，Godot将构建一个APK，您可以在设备上下载。要在命令行"
"上执行此操作，请使用以下命令:"

#: ../../docs/getting_started/step_by_step/exporting.rst:227
msgid ""
"Your device may need to be in *developer mode*. Consult your device's "
"documentation for details."
msgstr "您的设备可能需要处于 *developer模式* 。有关详细信息，请参阅设备文档。"

#: ../../docs/getting_started/step_by_step/exporting.rst:230
msgid ""
"If your system supports it, connecting a compatible Android device will "
"cause a \"One-click Deploy\" button to appear in Godot's playtest button "
"area:"
msgstr ""
"如果您的系统支持它，连接一个兼容的Android设备将导致“一键部署”按钮出现在Godot"
"的playtest按钮区域:"

#: ../../docs/getting_started/step_by_step/exporting.rst:235
msgid ""
"Clicking this button builds the APK and copies it onto your device in one "
"step."
msgstr "单击此按钮将构建APK并将其复制到您的设备上。"

#: ../../docs/getting_started/step_by_step/exporting.rst:240
msgid ""
"In order to build your game for iOS, you must have a computer running macOS "
"with Xcode installed."
msgstr "要为iOS构建游戏，您必须安装一台装有Xcode的macOS电脑。"

#: ../../docs/getting_started/step_by_step/exporting.rst:243
msgid ""
"Before exporting, there are some settings that you *must* complete for the "
"project to export successfully. First, the \"App Store Team Id\", which you "
"can find by logging in to your Apple developer account and looking in the "
"\"Membership\" section."
msgstr ""
"在导出之前，您必须完成一些设置才能成功导出项目。首先是“App Store团队Id”，您可"
"以登录到您的苹果开发者账户并在“会员”一栏中找到它。"

#: ../../docs/getting_started/step_by_step/exporting.rst:247
msgid "You must also provide icons and splash screen images as shown below:"
msgstr "您还必须提供图标和启动屏幕图像如下所示:"

#: ../../docs/getting_started/step_by_step/exporting.rst:251
msgid "Click \"Export Project\" and select a destination folder."
msgstr "单击“导出项目”并选择目标文件夹。"

#: ../../docs/getting_started/step_by_step/exporting.rst:253
msgid ""
"Once you have successfully exported the project, you'll find the following "
"folders and files have been created in your selected location:"
msgstr "一旦成功导出项目，您将发现以下文件夹和文件已创建在您选择的位置:"

#: ../../docs/getting_started/step_by_step/exporting.rst:258
msgid ""
"You can now open the project in Xcode and build the project for iOS. Xcode "
"build procedure is beyond the scope of this tutorial. See https://help.apple."
"com/xcode/mac/current/#/devc8c2a6be1 for more information."
msgstr ""
"现在可以在Xcode中打开项目并为iOS构建项目。Xcode构建过程超出了本教程的范围。有"
"关更多信息，请参阅https://help.apple.com/xcode/mac/current/#/devc8c2a6be1。"

#: ../../docs/getting_started/step_by_step/exporting.rst:264
msgid "HTML5 (web)"
msgstr "HTML5 (网页)"

#: ../../docs/getting_started/step_by_step/exporting.rst:266
msgid ""
"Click \"Export Project\" on the HTML5 preset. We don't need to change any of "
"the default settings."
msgstr "点击HTML5预置中的“导出项目”。我们不需要更改任何默认设置。"

#: ../../docs/getting_started/step_by_step/exporting.rst:269
msgid ""
"When the export is complete, you'll have a folder containing the following "
"files:"
msgstr "导出完成后，您将拥有一个包含以下文件的文件夹:"

#: ../../docs/getting_started/step_by_step/exporting.rst:274
msgid ""
"Viewing the `.html` file in your browser lets you play the game. However, "
"you can't open the file directly, it needs to be served by a web server. If "
"you don't have one set up on your computer, you can use Google to find "
"suggestions for your specific OS."
msgstr ""
"查看浏览器中的“.html”文件可以让您玩游戏。但是，不能直接打开文件，它将由Web服"
"务器提供服务。如果您的计算机上没有一个设置，您可以使用谷歌为您的特定OS找到建"
"议。"

#: ../../docs/getting_started/step_by_step/exporting.rst:279
msgid ""
"Point your browser at the URL where you've placed the html file. You may "
"have to wait a few moments while the game loads before you see the start "
"screen."
msgstr ""
"将浏览器指向放置html文件的URL。在游戏加载时，您可能需要等待几分钟才能看到开始"
"屏幕。"

#: ../../docs/getting_started/step_by_step/exporting.rst:284
msgid ""
"The console window beneath the game tells you if anything goes wrong. You "
"can disable it by setting \"Export With Debug\" off when you export the "
"project."
msgstr ""
"游戏下方的控制台窗口会告诉您是否出了什么问题。您可以在导出项目时关闭“Export "
"With Debug”来禁用它。"

#: ../../docs/getting_started/step_by_step/exporting.rst:287
msgid ""
"Browser support for WASM is not very widespread. Firefox and Chrome both "
"support it, but you may still find some things that don't work. Make sure "
"you have updated your browser to the most recent version, and report any "
"bugs you find at the `Godot Github repository <https://github.com/"
"godotengine/godot/issues>`_."
msgstr ""
"对WASM的浏览器支持并不广泛。Firefox和Chrome都支持这个功能，但您可能仍然会发现"
"一些无法使用的功能。确保您已经将浏览器更新到最新版本，并报告您在 `Godot "
"Github储存库 <https://github.com/godotengine/godot/issues>`_ 上发现的任何"
"bug。"

#: ../../docs/getting_started/step_by_step/godot_design_philosophy.rst:4
msgid "Godot’s design philosophy"
msgstr "Godot的设计理念"

#: ../../docs/getting_started/step_by_step/godot_design_philosophy.rst:6
msgid "Now that you've gotten your hands wet, let's talk about Godot's design."
msgstr "既然您已经把手弄湿了，让我们谈谈Godot的设计。"

#: ../../docs/getting_started/step_by_step/godot_design_philosophy.rst:8
msgid ""
"**Every game engine is different and fits different needs.** Not only do "
"they offer a range of features, but the design of each engine is unique. "
"This leads to different workflows and different ways to form your games’ "
"structures. This all stems from their respective design philosophies."
msgstr ""
"**每个游戏引擎都是不同的，并且适合不同的需求。** 它们不仅提供了一系列的特性，"
"而且每个引擎的设计都是独一无二的。这就导致了不同的工作流程和形成游戏结果的不"
"同方式。这都源于引擎各自的设计理念。"

#: ../../docs/getting_started/step_by_step/godot_design_philosophy.rst:13
msgid ""
"This page is here to help you understand how Godot works, starting with some "
"of its core pillars. It is not a list of available features, nor is it an "
"engine comparison. To know if any engine can be a good fit for your project, "
"you need to try it out for yourself and understand its design and "
"limitations."
msgstr ""
"这个页面是为了帮助您理解Godot的工作原理，从它的一些核心支柱开始。它不是可用特"
"性的列表，也不是引擎比较。要知道任何引擎是否适合您的项目，您需要亲自尝试一"
"下，了解它的设计和局限性。"

#: ../../docs/getting_started/step_by_step/godot_design_philosophy.rst:19
msgid ""
"Please watch `Discover Godot 3, the Free game engine <https://youtu."
"be/4v3qge-3CqQ>`_ if you're looking for an overview of the engine's features."
msgstr ""
"如果您想要了解这个引擎的特性，请看 `Discover Godot 3，免费游戏引擎 <https://"
"youtu.be/4v3qge-3CqQ>`_ 。"

#: ../../docs/getting_started/step_by_step/godot_design_philosophy.rst:23
msgid "Object-oriented design and composition"
msgstr "面向对象设计与组合"

#: ../../docs/getting_started/step_by_step/godot_design_philosophy.rst:25
msgid ""
"Godot embraces object-oriented design at its core with its flexible scene "
"system and Node hierarchy. It tries to stay away from strict programming "
"patterns to offer an intuitive way to structure your game."
msgstr ""
"Godot以其灵活的场景系统和节点层次结构来支持面向对象的设计。它尝试远离严格的编"
"程模式，提供一种直观的方式来构造您的游戏。"

#: ../../docs/getting_started/step_by_step/godot_design_philosophy.rst:29
msgid ""
"For one, Godot lets you **compose or aggregate** scenes. It's like nested "
"prefabs: you can create a BlinkingLight scene and a BrokenLantern scene that "
"uses the BlinkingLight. Then, create a city filled with BrokenLanterns. "
"Change the BlinkingLight's color, save, and all the BrokenLanterns in the "
"city will update instantly."
msgstr ""
"首先，Godot允许您 **组合或者聚合** 场景。这就像嵌套的预制件(prefabs):您可以创"
"建一个BlinkingLight场景以及一个使用BlinkingLight场景的BrokenLantern场景。然"
"后，创建一个满是BrokenLanterns的城市场景。改变BlinkingLight的颜色，保存，城市"
"中的所有的BrokenLanterns会立即更新。"

#: ../../docs/getting_started/step_by_step/godot_design_philosophy.rst:36
msgid "On top of that, you can **inherit** from any scene."
msgstr "最重要的是，您可以从任何场景 **继承** 。"

#: ../../docs/getting_started/step_by_step/godot_design_philosophy.rst:38
msgid ""
"A Godot scene could be a Weapon, a Character, an Item, a Door, a Level, part "
"of a level… anything you’d like. It works like a class in pure code, except "
"you’re free to design it by using the editor, using only the code, or mixing "
"and matching the two."
msgstr ""
"Godot场景可以是武器，角色，物品，门，关卡，关卡的一部分...任何您想要的东西。"
"它的工作方式就像纯代码中的类一样，只不过您可以通过使用编辑器，只用代码，或者"
"混合和匹配这两者来自由的设计它。"

#: ../../docs/getting_started/step_by_step/godot_design_philosophy.rst:43
msgid ""
"It’s different from prefabs you find in several 3D engines, as you can then "
"inherit from and extend those scenes. You may create a Magician that extends "
"your Character. Modify the Character in the editor and the Magician will "
"update as well. It helps you build your projects so that their structure "
"matches the game’s design."
msgstr ""
"它不同于您在几个3D引擎中发现的预制件，因为您可以继承和扩展这些场景。您可以创"
"建一个继承于您的角色的魔法师。在编辑器中修改角色，魔术师也会更新。它帮助您构"
"建您的项目，使他们的结构与游戏的设计相匹配。"

#: ../../docs/getting_started/step_by_step/godot_design_philosophy.rst:51
msgid ""
"Also note that Godot offers many different types of objects called nodes, "
"each with a specific purpose. Nodes are part of a tree and always inherit "
"from their parents up to the Node class. Although the engine does feature "
"components like collision shapes, they’re the exception, not the norm."
msgstr ""
"还要注意，Godot提供了许多不同类型的对象，称为节点，每个节点都有特定的用途。节"
"点是树的一部分，并且总是从它们的父节点继承节点类。虽然引擎确实具有像碰撞形状"
"这样的组建，但它们是例外，而不是标准。"

#: ../../docs/getting_started/step_by_step/godot_design_philosophy.rst:59
msgid ""
"Sprite is a Node2D, a CanvasItem and a Node. It has all the properties and "
"features of its three parent classes, like transforms or the ability to draw "
"custom shapes and render with a custom shader."
msgstr ""
"Sprite页是Node2D，CanvasItem和Node类型。它具有三个父类的所有属性和特性，比如 "
"transforms 或者绘制自定义shapes和渲染自定义shader的能力。"

#: ../../docs/getting_started/step_by_step/godot_design_philosophy.rst:64
msgid "All-inclusive package"
msgstr "详尽的计划"

#: ../../docs/getting_started/step_by_step/godot_design_philosophy.rst:66
msgid ""
"Godot tries to provide its own tools to answer most common needs. It has a "
"dedicated scripting workspace, an animation editor, a tilemap editor, a "
"shader editor, a debugger, a profiler, the ability to hot-reload locally and "
"on remote devices, etc."
msgstr ""
"Godot尝试提供自己的工具来满足最常见的需求。它具有专用的脚本工作区，动画编辑"
"器，tilemap编辑器，shader编辑器，调试器(debugger)，分析器(profiler)，在本地和"
"远程设备上热重载的能力等等。"

#: ../../docs/getting_started/step_by_step/godot_design_philosophy.rst:73
msgid ""
"The goal is to offer a full package to create games and a continuous user "
"experience. You can still work with external programs as long as there is an "
"import plugin for it. Or you can create one, like the `Tiled Map Importer "
"<https://github.com/vnen/godot-tiled-importer>`__."
msgstr ""
"我们的目标是提供一个完整的软件包来创建游戏以及持续的用户体验。您仍然可以和外"
"部程序一起工作，只要有一个导入插件做支持。或者您可以自己创建一个，比如 "
"`Tiled Map Importer <https://github.com/vnen/godot-tiled-importer>`__ 。"

#: ../../docs/getting_started/step_by_step/godot_design_philosophy.rst:78
msgid ""
"That is also partly why Godot offers its own programming languages GDscript "
"and VisualScript, along with C#. They’re designed for the needs of game "
"developers and game designers, and they’re tightly integrated in the engine "
"and the editor."
msgstr ""
"这也是为什么Godot提供自己的编程语言GDscript和VisualScript以及C#的部分原因。它"
"们是为游戏开发着和游戏设计者的需要而设计的，并且它们紧密的集成在引擎和编辑器"
"中。"

#: ../../docs/getting_started/step_by_step/godot_design_philosophy.rst:83
msgid ""
"GDscript lets you write simple code using Python-like syntax, yet it detects "
"types and offers a static language's quality of auto-completion. It is also "
"optimized for gameplay code with built-in types like Vectors and Colors."
msgstr ""
"GDscript允许使用类似于python的语法编写简单代码，但它检测类型并提供静态语言的"
"自动完成质量。它还针对内置类型(比如向量和颜色)的游戏代码进行了优化。"

#: ../../docs/getting_started/step_by_step/godot_design_philosophy.rst:87
msgid ""
"Note that with GDNative, you can write high-performance code using compiled "
"languages like C, C++, Rust, or Python (using the Cython compiler) without "
"recompiling the engine."
msgstr ""
"注意，使用GDNative，您可以使用C、C++、Rust或Python(使用Cython编译器)这样的编"
"译语言编写高性能代码，而无需重新编译引擎。"

#: ../../docs/getting_started/step_by_step/godot_design_philosophy.rst:93
msgid ""
"*VisualScript is a node-based programming language that integrates well in "
"the editor. You can drag and drop nodes or resources into the graph to "
"create new code blocks.*"
msgstr ""
"*VisualScript是一种基于节点的编程语言，很好地集成在编辑器中。您可以将节点或资"
"源拖放到图中来创建新的代码块。*"

#: ../../docs/getting_started/step_by_step/godot_design_philosophy.rst:97
msgid ""
"Note that the 3D workspace doesn’t feature as many tools as the 2D "
"workspace. You’ll need external programs or add-ons to edit terrains, "
"animate complex characters, and so on. Godot provides a complete API to "
"extend the editor’s functionality using game code. See `The Godot editor is "
"a Godot game`_ below."
msgstr ""
"请注意，3D工作空间没有2D工作空间那么多工具。您将需要外部程序或插件来编辑地"
"形、动画复杂字符，等等。Godot提供了一个完整的API来使用游戏代码扩展编辑器的功"
"能。参见下面的“Godot编辑器是一个Godot游戏”_。"

#: ../../docs/getting_started/step_by_step/godot_design_philosophy.rst:104
msgid ""
"*A State Machine editor plugin in Godot 2 by kubecz3k. It lets you manage "
"states and transitions visually.*"
msgstr ""
"* kubecz3k在Godot 2中的状态机编辑器插件。它允许您可视化地管理状态和转换。*"

#: ../../docs/getting_started/step_by_step/godot_design_philosophy.rst:108
msgid "Open source"
msgstr "开源"

#: ../../docs/getting_started/step_by_step/godot_design_philosophy.rst:110
msgid ""
"Godot offers a fully open source codebase under the **MIT license**. This "
"means all the technologies that ship with it have to be Free (as in freedom) "
"as well. For the most part, they’re developed from the ground up by "
"contributors."
msgstr ""
"Godot在 **MIT许可** 下提供了一个完全开源的代码库。这意味着所有的技术都必须是"
"自由的。在很大程度上，它们是由贡献者从头开始开发的。"

#: ../../docs/getting_started/step_by_step/godot_design_philosophy.rst:115
msgid ""
"Anyone can plug in proprietary tools for the needs of their projects — they "
"just won’t ship with the engine. This may include NVIDIA PhysX, Google "
"AdMob, or an FBX model importer. Any of these can come as third-party "
"plugins instead."
msgstr ""
"任何人都可以插入专用的工具来满足他们项目的需求——他们只是不会随同引擎一起发"
"布。这可能包括英伟达PhysX，谷歌AdMob，或FBX型号进口商。这些都可以作为第三方插"
"件来替代。"

#: ../../docs/getting_started/step_by_step/godot_design_philosophy.rst:120
msgid ""
"On the other hand, an open codebase means you can **learn from and extend "
"the engine** to your heart’s content. You can also debug games easily, as "
"Godot will print errors with a stack trace, even if they come from the "
"engine itself."
msgstr ""
"另一方面，一个开放的代码库意味着您可以学习和扩展引擎到您的核心内容。您还可以"
"很容易地调试游戏，因为Godot会使用堆栈跟踪打印错误，即使这些错误来自引擎本身。"

#: ../../docs/getting_started/step_by_step/godot_design_philosophy.rst:126
msgid ""
"This **does not affect the work you do with Godot** in any way: there’s no "
"strings attached to the engine or anything you make with it."
msgstr ""
"这个 **不会以任何方式影响您对Godot** 所做的工作:没有任何附加到引擎或您用它做"
"的任何事情。"

#: ../../docs/getting_started/step_by_step/godot_design_philosophy.rst:130
msgid "Community-driven"
msgstr "社区驱动"

#: ../../docs/getting_started/step_by_step/godot_design_philosophy.rst:132
msgid ""
"**Godot is made by its community, for the community, and for all game "
"creators out there.** It’s the needs of the users and open discussions that "
"drive the core updates. New features from the core developers often focus on "
"what will benefit the most users first."
msgstr ""
"**Godot是由它的社区、社区和所有游戏开发者制作的。驱动核心更新的是用户的需求和"
"公开讨论。来自核心开发人员的新特性通常会首先关注什么将使大多数用户受益。"

#: ../../docs/getting_started/step_by_step/godot_design_philosophy.rst:137
msgid ""
"That said, although a handful of core developers work on it full-time, the "
"project has over 600 contributors at the time of writing. Benevolent "
"programmers work on features they may need themselves, so you’ll see "
"improvements in all corners of the engine at the same time in every major "
"release."
msgstr ""
"也就是说，尽管有一些核心开发人员全职从事it工作，但在撰写本文时，该项目有超过"
"600名贡献者。仁慈的程序员致力于他们可能需要的特性，所以在每个主要版本中，您将"
"在引擎的各个角落同时看到改进。"

#: ../../docs/getting_started/step_by_step/godot_design_philosophy.rst:144
msgid "The Godot editor is a Godot game"
msgstr "Godot编辑器是一个Godot游戏"

#: ../../docs/getting_started/step_by_step/godot_design_philosophy.rst:146
msgid ""
"The Godot editor runs on the game engine. It uses the engine’s own UI "
"system, it can hot-reload code and scenes when you test your projects, or "
"run game code in the editor. This means you can **use the same code** and "
"scenes for your games, or **build plugins and extend the editor.**"
msgstr ""
"Godot编辑器运行在游戏引擎上。它使用引擎自己的UI系统，可以在测试项目或在编辑器"
"中运行游戏代码时热加载代码和场景。这意味着您可以为您的游戏使用 **相同的代码"
"** 和场景，或者**创建插件和扩展编辑器**"

#: ../../docs/getting_started/step_by_step/godot_design_philosophy.rst:151
msgid ""
"This leads to a reliable and flexible UI system, as it powers the editor "
"itself. With the ``tool`` keyword, you can run any game code in the editor."
msgstr ""
"这导致了一个可靠和灵活的UI系统，因为它为编辑器本身提供了动力。使用“tool”关键"
"字，您可以在编辑器中运行任何游戏代码。"

#: ../../docs/getting_started/step_by_step/godot_design_philosophy.rst:156
msgid ""
"*RPG in a Box is a voxel RPG editor made with Godot 2. It uses Godot’s UI "
"tools for its node-based programming system and for the rest of the "
"interface.*"
msgstr ""
"*RPG in a Box是一个用Godot 2制作的体素RPG编辑器。它将Godot的UI工具用于其基于"
"节点的编程系统和接口的其余部分。*"

#: ../../docs/getting_started/step_by_step/godot_design_philosophy.rst:160
msgid ""
"Put the ``tool`` keyword at the top of any GDScript file and it will run in "
"the editor. This lets you import and export plugins, create plugins like "
"custom level editors, or create scripts with the same nodes and API you use "
"in your projects."
msgstr ""
"将“tool”关键字放在任何GDScript文件的顶部，它将在编辑器中运行。这使您可以导入"
"和导出插件，创建插件(比如自定义级别编辑器)，或者创建具有与您在项目中使用的相"
"同节点和API的脚本。"

#: ../../docs/getting_started/step_by_step/godot_design_philosophy.rst:166
msgid "Separate 2D and 3D engines"
msgstr "独立的2D和3D引擎"

#: ../../docs/getting_started/step_by_step/godot_design_philosophy.rst:168
msgid ""
"Godot offers dedicated 2D and 3D rendering engines. As a result, **the base "
"unit for 2D scenes is pixels.** Even though the engines are separate, you "
"can render 2D in 3D, 3D in 2D, and overlay 2D sprites and interfaces over "
"your 3D world."
msgstr ""
"Godot提供专门的2D和3D渲染引擎。因此，** 2D场景的基本单位是像素。**即使引擎是"
"分开的，您可以渲染2D为3D, 3D为2D，并覆盖2D精灵和界面在您的3D世界。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:4
msgid "Design interfaces with the Control nodes"
msgstr "使用控制节点设计界面"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:6
msgid ""
"Computer displays, mobile phones, and TV screen come in all shapes and "
"sizes. To ship a game, you'll need to support different screen ratios and "
"resolutions. It can be hard to build responsive interfaces that adapt to all "
"platforms. Thankfully, Godot comes with robust tools to design and manage a "
"responsive User Interface. To design your UI, you'll use the Control nodes. "
"These are the nodes with green icons in the editor. There are dozens of "
"them, to create anything from life bars to complex applications. Godot's "
"entire editor and plugins use these nodes."
msgstr ""
"电脑显示器、手机和电视屏幕有各种形状和大小。要发布一款游戏，您需要支持不同的"
"屏幕比例和分辨率。构建适应所有平台的响应式界面可能很困难。值得庆幸的是，Godot"
"提供了强大的的工具来设计和管理响应性用户界面。要设计UI，您将使用控制节点。这"
"些是编辑器中带有绿色图标的节点。它们有几十个，可以创建从生命条到复杂应用程序"
"的任何东西。Godot的整个编辑器和插件都使用这些节点。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:17
msgid "Godot's editor is made with the engine's UI framework"
msgstr "Godot的编辑器是用引擎的UI框架制作的"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:19
msgid "This guide will get you started with UI design. You will learn:"
msgstr "本指南将让您从UI设计开始。您将学习:"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:21
msgid "The five most useful control nodes to build your games’ interface"
msgstr "五个最有用的控制节点来构建您的游戏界面"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:22
msgid "How to work with the anchor of UI elements"
msgstr "如何使用UI元素的锚点"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:23
msgid ""
"How to efficiently place and arrange your user interface using containers"
msgstr "如何使用容器有效地放置和安排用户界面"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:25
msgid "The five most common containers"
msgstr "5个最常见的容器"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:27
msgid ""
"To learn how to control the interface and connect it to other scripts, read :"
"ref:`Build your first game UI in Godot <doc_ui_game_user_interface>`."
msgstr ""
"要了解如何控制界面并将其连接到其他脚本，请阅读 :ref:`Build your first game "
"UI in Godot <doc_ui_game_user_interface>`。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:30
msgid ""
"Only use Control nodes when you design your interfaces. They have unique "
"properties that allow them to work with one another. Other nodes, like "
"Node2D, Sprite, etc. will not work. You can still use some nodes that work "
"with others, like the AnimationPlayer, Tween or the StreamPlayer. Control "
"nodes are CanvasItems like Node2D, so you can apply shaders to them."
msgstr ""
"在设计界面时只使用控制节点。它们具有独特的特性，使它们能够相互协作。其他节点"
"如Node2D、Sprite等将无法工作。您仍然可以使用一些与其他节点一起工作的节点，比"
"如AnimationPlayer、Tween或StreamPlayer。控件节点是类似于Node2D的画布，所以您"
"可以对它们应用着色器。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:37
msgid "All control nodes share the same main properties:"
msgstr "所有控件节点具有相同的主要属性:"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:39
msgid "Anchor"
msgstr "锚"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:40
msgid "Bounding rectangle"
msgstr "边界矩形"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:41
msgid "Focus and focus neighbor"
msgstr "焦点和焦点邻居"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:42
msgid "Size flags"
msgstr "大小标志"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:43
msgid "Margin"
msgstr "边距"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:44
msgid "The optional UI theme"
msgstr "可选的UI主题"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:46
msgid ""
"Once you understand the basics of the Control node, it will take you less "
"time to learn all the nodes that derive from it."
msgstr ""
"一旦您了解了控制节点的基础知识，学习所有从中派生的节点所需的时间就会减少。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:51
msgid "The 5 most common UI elements"
msgstr "5个最常见的UI元素"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:53
msgid ""
"Godot ships with dozens of Control nodes. A lot of them are here to help you "
"build editor plugins and applications."
msgstr ""
"Godot配备了数十个控制节点。这里有很多插件可以帮助您构建编辑器插件和应用程序。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:56
msgid ""
"For most games, you'll only need five types of UI elements, and a few "
"Containers. These five Control nodes are:"
msgstr "对于大多数游戏，您只需要五种类型的UI元素和一些容器。这五个控制节点是:"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:59
msgid "Label: for displaying text"
msgstr "标签:用于显示文本"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:60
msgid ""
"TextureRect: used mostly for backgrounds, or everything that should be a "
"static image"
msgstr "纹理竖立:主要用于背景，或所有应该是静态图像的东西"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:62
msgid ""
"TextureProgress: for lifebars, loading bars, horizontal, vertical or radial"
msgstr "纹理进展:适用于生命条、进度条、水平杆、垂直杆或径向杆"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:64
msgid "NinePatchRect: for scalable panels"
msgstr "NinePatchRect:可缩放面板"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:65
msgid "TextureButton: to create buttons"
msgstr "纹理按钮:用于创建按钮"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:69
msgid "The 5 most common Control nodes for UI design"
msgstr "UI设计中最常见的5个控制节点"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:72
msgid "TextureRect"
msgstr "纹理结构"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:74
msgid ""
"**TextureRect** displays a texture or image inside a UI. It seems similar to "
"the Sprite node, but it offers multiple scaling modes. Set the Stretch Mode "
"property to change its behavior:"
msgstr ""
"**纹理矩形**在UI中显示纹理或图像。它看起来类似于精灵节点，但它提供了多种缩放"
"模式。设置拉伸模式属性来改变其行为:"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:78
msgid ""
"``Scale On Expand (compat)`` scales the texture to fit the node’s bounding "
"rectangle, only if ``expand`` property is ``true``; otherwise, it behaves "
"like ``Keep`` mode. Default mode for backwards compatibility."
msgstr ""
"`Scale On Expand (compat)`缩放纹理以适应节点的边框，仅当`Expand`属性为`true`;"
"否则，它的行为就像`Keep`mode。向后兼容的默认模式。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:79
msgid "``Scale`` scales the texture to fit the node’s bounding rectangle"
msgstr "`Scale`缩放纹理以适合节点的边框"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:80
msgid "``Tile`` makes the texture repeat, but it won't scale"
msgstr "`Tile`使纹理重复，但它不会缩放"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:81
msgid ""
"``Keep`` and ``Keep Centered`` force the texture to remain at its original "
"size, in the top left corner or the center of the frame respectively"
msgstr ""
"`Keep`和`Keep Centered`迫使纹理保持其原始大小，分别在左上角或框架的中心"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:84
msgid ""
"``Keep Aspect`` and ``Keep Aspect Centered`` scales the texture but force it "
"to remain its original aspect ratio, in the top left corner or the center of "
"the frame respectively"
msgstr ""
"`Keep Aspect`和`Keep Aspect center`缩放纹理，但迫使它保持其原来的长宽比，分别"
"在左上角或框架的中心"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:85
msgid ""
"``Keep Aspect Covered`` works just like ``Keep Aspect Centered`` but the "
"shorter side fits the bounding rectangle and the other one clips to the "
"node’s limits"
msgstr ""
"`Keep Aspect Covered`的工作方式就像`Keep Aspect Centered`一样，但较短的边符合"
"矩形的边框，而另一边则与节点的限制相结合"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:87
msgid ""
"As with Sprite nodes, you can modulate the TextureRect's color. Click the "
"``Modulate`` property and use the color picker."
msgstr ""
"与精灵节点一样，您可以调节纹理的颜色。单击`Modulate(调制)`属性并使用颜色选择"
"器。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:92
msgid "TextureRect modulated with a red color"
msgstr "用红色调制的纹理"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:95
msgid "TextureButton"
msgstr "纹理按钮"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:97
msgid ""
"**TextureButton** is like TextureRect, except it has 5 texture slots: one "
"for each of the button's states. Most of the time, you'll use the Normal, "
"Pressed, and Hover textures. Focused is useful if your interface listens to "
"the keyboard's input. The sixth image slot, the Click Mask, lets you define "
"the clickable area using a 2-bit, pure black and white image."
msgstr ""
"**纹理按钮**类似于纹理矩形，只不过它有5个纹理槽:每个纹理槽对应一个按钮的状"
"态。大多数时候，您会使用普通的、按下的和悬停的纹理。如果您的界面监听键盘的输"
"入，集中注意力是很有用的。第六个图像插槽，单击Mask，允许您使用一个2位的纯黑白"
"图像定义可单击区域。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:104
msgid ""
"In the Base Button section, you'll find a few checkboxes that change how the "
"button behaves. When ``Toggle Mode`` is on, the button will toggle between "
"active and normal states when you press it. ``Disabled`` makes it disabled "
"by default, in which case it will use the ``Disabled`` texture. "
"TextureButton shares a few properties with the texture frame: it has a "
"``modulate`` property, to change its color, and ``Resize`` and ``Stretch`` "
"modes to change its scale behavior."
msgstr ""
"在基本按钮部分中，您会发现一些复选框，它们会改变按钮的行为。当`Toggle Mode`开"
"启时，按钮会在活动状态和正常状态之间切换。`Disabled`会让它默认被禁用，在这种"
"情况下，它会使用`Disabled`纹理。纹理按钮与纹理框架共享一些属性:它有"
"`modulate(调制)`属性来改变其颜色，`Resize(调整)`和`Stretch(伸展)`模式来改变其"
"缩放行为。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:114
msgid "TextureButton and its 5 texture slots"
msgstr "纹理按钮和它的5个纹理槽"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:117
msgid "TextureProgress"
msgstr "纹理的进展"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:119
msgid ""
"**TextureProgress** layers up to 3 sprites to create a progress bar. The "
"Under and Over textures sandwich the Progress one, which displays the bar's "
"value."
msgstr ""
"**TextureProgress**层多达3个精灵来创建进度条。下面和上面的贴图夹住了进度条，"
"显示了条的值。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:123
msgid ""
"The ``Mode`` property controls the direction in which the bar grows: "
"horizontally, vertically, or radially. If you set it to radial, the "
"``Initial Angle`` and ``Fill Degrees`` properties let you limit the range of "
"the gauge."
msgstr ""
"`Mode`属性控制条增长的方向:水平、垂直或径向。如果您把它设置为径向，`Initial "
"Angle(初始角度)`和`Fill Degrees(填充度)`属性让您限制量规的范围。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:128
msgid ""
"To animate the bar, you'll want to look at the Range section. Set the "
"``Min`` and ``Max`` properties to define the range of the gauge. For "
"instance, to represent a character's life, you'll want to set ``Min`` to ``0,"
"`` and ``Max`` to the character's maximum life. Change the ``Value`` "
"property to update the bar. If you leave the ``Min`` and ``Max`` values to "
"the default of ``1`` and ``100,`` and set the ``Value`` property to ``40``, "
"40% of the ``Progress`` texture will show up, and 60% of it will stay hidden."
msgstr ""
"要使栏动画化，您需要查看Range部分。设置`Min`和`Max`属性来定义量规的范围。例"
"如，为了表示一个角色的生命，您需要将`Min`设置为`0`，`Max`设置为角色的最大生"
"命。更改“值”属性以更新栏。如果将`Min`和`Max`的值设置为`1`和`100`的默认值，并"
"将`Value`属性设置为`40`，`Progress`纹理的40%会显示，60%会隐藏。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:138
msgid "TextureProgress bar, two thirds filled"
msgstr "文本进度条，三分之二填充"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:143
msgid ""
"**Label** prints text to the screen. You'll find all its properties in the "
"Label section, in the Inspector. Write the text in the ``Text`` property, "
"and check Autowrap if you want it to respect the textbox's size. If Autowrap "
"is off, you won't be able to scale the node. You can align the text "
"horizontally and vertically with Align and Valign, respectively."
msgstr ""
"**标签**打印文本到屏幕。您将在Label部分和Inspector中找到它的所有属性。在"
"`text`属性中写入文本，如果希望它遵守文本框的大小，请选中Autowrap。如果"
"Autowrap关闭，则无法缩放节点。您可以使用align和Valign分别水平和垂直对齐文本。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:152
msgid "Picture of a Label"
msgstr "标签图片"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:155
msgid "NinePatchRect"
msgstr "可缩放面板"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:157
msgid ""
"**NinePatchRect** takes a texture split in 3 rows and 3 columns. The center "
"and the sides tile when you scale the texture, but it never scales the "
"corners. It is useful to build panels, dialog boxes and scalable backgrounds "
"for your UI."
msgstr ""
"**NinePatchRect**在3行和3列中进行纹理分割。当您缩放纹理时，它的中心和侧面是平"
"铺的，但是它不会缩放角落。为UI构建面板、对话框和可伸缩的背景非常有用。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:164
msgid "NinePatchRect scaled with the min\\_size property"
msgstr "NinePatchRect使用min_size属性缩放"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:167
msgid "There are two workflows to build responsive UIs"
msgstr "有两个工作流程可以构建响应性UI"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:169
msgid ""
"There are two workflows to build scalable and flexible interfaces in Godot:"
msgstr "在Godot中，有两个工作流程可以构建可伸缩和灵活的界面:"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:171
msgid ""
"You have many container nodes at your disposal that scale and place UI "
"elements for you. They take control over their children."
msgstr ""
"您有许多容器节点可供使用，这些节点可伸缩并为您放置UI元素。他们控制他们的子节"
"点。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:172
msgid ""
"On the other side, you have the layout menu. It helps you to anchor, place "
"and resize a UI element within its parent."
msgstr ""
"另一方面，您有布局菜单。它帮助您锚定、放置和调整UI元素在其父级中的大小。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:174
msgid ""
"The two approaches are not always compatible. Because a container controls "
"its children, you cannot use the layout menu on them. Each container has a "
"specific effect, so you may need to nest several of them to get a working "
"interface. With the layout approach you work from the bottom up, on the "
"children. As you don't insert extra containers in the scene it can make for "
"cleaner hierarchies, but it's harder to arrange items in a row, column, "
"grid, etc."
msgstr ""
"这两种方法并不总是兼容的。因为容器控制其子节点，所以不能在其上使用布局菜单。"
"每个容器都有特定的效果，所以您可能需要嵌套其中几个来获得工作界面。用布局的方"
"法，您从下到上工作，在子节点身上。由于没有在场景中插入额外的容器，所以层次结"
"构会更加清晰，但是很难在行、列、网格等中排列项。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:176
msgid ""
"As you create UIs for your games and tools, you'll develop a sense for what "
"fits best in each situation."
msgstr "当您为您的游戏和工具创建ui时，您会发现什么是最适合每种情况的。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:180
msgid "Place UI elements precisely with anchors"
msgstr "用锚精确地放置UI元素"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:182
msgid ""
"Control nodes have a position and size, but they also have anchors and "
"margins. Anchors define the origin, or the reference point, for the Left, "
"Top, Right and Bottom edges of the node. Change any of the 4 anchors to "
"change the reference point of the margins."
msgstr ""
"控制节点有位置和大小，但它们也有锚和边距。锚定义节点的左、上、右和下边缘的原"
"点或参考点。更改4个锚中的任何一个，以更改边距的参考点。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:189
msgid "The anchor property"
msgstr "锚属性"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:192
msgid "How to change the anchor"
msgstr "如何更换锚"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:194
msgid ""
"Like any properties, you can edit the 4 anchor points in the Inspector, but "
"this is not the most convenient way. When you select a control node, the "
"layout menu appears above the viewport, in the toolbar. It gives you a list "
"of icons to set all 4 anchors with a single click, instead of using the "
"inspector’s 4 properties. The layout menu will only show up when you select "
"a control node."
msgstr ""
"与任何属性一样，您可以在属性面板中编辑4个锚点，但这不是最方便的方法。当您选择"
"控件节点时，布局菜单会出现在工具栏的视区上方。它为您提供了一个图标列表，通过"
"单击就可以设置所有4个锚点，而不是使用属性面板的4个属性。布局菜单只会在选择控"
"件节点时显示。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:203
msgid "The layout menu in the viewport"
msgstr "视图中的布局菜单"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:206
msgid "Anchors are relative to the parent container"
msgstr "锚相对于父容器"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:208
msgid ""
"Each anchor is a value between 0 and 1. For the left and top anchors, a "
"value of 0 means that without any margin, the node's edges will align with "
"the left and top edges of its parent. For the right and bottom edges, a "
"value of 1 means they'll align with the parent container's right and bottom "
"edges. On the other hand, margins represent a distance to the anchor "
"position in pixels, while anchors are relative to the parent container's "
"size."
msgstr ""
"每个锚都是0到1之间的值。对于左侧和顶部锚点，值为0意味着在没有任何边界的情况"
"下，节点的边缘将与其父节点的左侧和顶部边缘对齐。对于右边缘和底部边缘，值为1意"
"味着它们将与父容器的右边缘和底部边缘对齐。另一方面，边距表示到锚点位置的距离"
"(以像素为单位)，而锚点则相对于父容器的大小。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:218
msgid ""
"Margins are relative to the anchor position, which is relative to the "
"anchors. In practice, you'll often let the container update margins for you"
msgstr ""
"边缘与锚固位置有关，锚固位置相对于锚定。在实践中，您通常会让容器为您更新利润"
"率"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:223
msgid "Margins change with the anchor"
msgstr "边距随锚而变化"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:225
msgid ""
"Margins update automatically when you move or resize a control node. They "
"represent the distance from the control node's edges to its anchor, which is "
"relative to the parent control node or container. That's why your control "
"nodes should always be inside a container, as we'll see in a moment. If "
"there's no parent, the margins will be relative to the node's own bounding "
"Rectangle, set in the Rect section, in the inspector."
msgstr ""
"当您移动或调整控件节点的大小时，页边距将自动更新。它们表示从控制节点的边缘到"
"其锚点的距离，锚点相对于父控制节点或容器。这就是为什么控制节点应该总是在容器"
"中，我们稍后会看到。如果不存在父元素，则边界将相对于属性面板中在Rect部分中设"
"置的节点自己的边框。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:235
msgid "Margins on a CenterContainer set to the \"Full Rect\" anchor"
msgstr "将CenterContainer中的边距设置为“Full Rect”锚"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:237
msgid ""
"Try to change the anchors or nest your Control nodes inside Containers: the "
"margins will update. You'll rarely need to edit the margins manually. Always "
"try to find a container to help you first; Godot comes with nodes to solve "
"all the common cases for you. Need to add space between a lifebar and the "
"border of the screen? Use the MarginContainer. Want to build a vertical "
"menu? Use the VBoxContainer. More on these below."
msgstr ""
"尝试更改锚或将控制节点嵌套在容器中:边界将会更新。您很少需要手动编辑页边距。总"
"是试着先找一个容器来帮助您；Godot提供了解决所有常见问题的节点。需要在生命条和"
"屏幕边界之间添加空间?使用MarginContainer。想建立一个垂直菜单?使用"
"VBoxContainer。下面将详细介绍这些内容。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:246
msgid "Use size tags to change how UI elements fill the available space"
msgstr "使用大小标签来更改UI元素如何填充可用空间"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:248
msgid ""
"Every control node has Size Flags. They tell containers how the UI elements "
"should scale. If you add the \"Fill\" flag to the Horizontal or Vertical "
"property, the node's bounding box will take all the space it can, but it'll "
"respect its siblings and retain its size. If there are 3 TextureRect nodes "
"in an HBoxContainer, with the \"Fill\" flags on both axes, they'll each take "
"up to a third of the available space, but no more. The container will take "
"over the node and resize it automatically."
msgstr ""
"每个控件节点都有大小标志。它们告诉容器UI元素应该如何伸缩。如果将“填充”标志添"
"加到水平或垂直属性中，节点的边界框将占用它能占用的所有空间，但它将尊重其兄弟"
"节点并保留其大小。如果HBoxContainer中有3个textur节点，且两个轴上都有“填充”标"
"志，那么它们将占用三分之一的可用空间，但仅此而已。容器将接管节点并自动调整其"
"大小。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:258
msgid "3 UI elements in an HBoxContainer, they align horizontally"
msgstr "HBoxContainer中的3个UI元素，它们是水平对齐的"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:260
msgid ""
"The \"Expand\" flag lets the UI element take all the space it can, and push "
"against its siblings. Its bounding rectangle will grow against the edges of "
"its parent, or until it's blocked by another UI node."
msgstr ""
"“Expand(展开)”标志允许UI元素获得它所能获得的所有空间，并对其兄弟元素进行推"
"送。它的边框会随着父节点的边缘增长，或者直到被另一个UI节点阻塞为止。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:266
msgid ""
"The same example as above, but the center node has the \"Expand\" size flag"
msgstr "与上面的示例相同，但是中心节点有“Expand(展开)”大小标志"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:269
msgid ""
"You'll need some practice to understand the size tags, as their effect can "
"change quite a bit depending on how you set up your interface."
msgstr ""
"您需要一些实践来理解大小标签，因为它们的效果会根据您如何设置界面而发生很大的"
"变化。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:273
msgid "Arrange control nodes automatically with containers"
msgstr "使用容器自动排列控制节点"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:275
msgid ""
"Containers automatically arrange all children Control nodes including other "
"containers in rows, columns, and more. Use them to add padding around your "
"interface or center nodes in their bounding rectangles. All built-in "
"containers update in the editor, so you can see the effect instantly."
msgstr ""
"容器自动排列所有子控件节点，包括行、列等中的其他容器。使用它们在界面周围或中"
"心节点的边框中添加填充。所有内置容器在编辑器中更新，以便您可以立即看到效果。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:281
msgid ""
"Containers have a few special properties to control how they arrange UI "
"elements. To change them, navigate down to the Custom Constants section in "
"the Inspector."
msgstr ""
"容器有一些特殊的属性来控制它们如何配置UI元素。要更改它们，请向下导航到属性面"
"板中的自定义常量部分。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:286
msgid "The 5 most useful containers"
msgstr "5个最有用的容器"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:288
msgid ""
"If you build tools, you might need all of the containers. But for most "
"games, a handful will be enough:"
msgstr ""
"如果您构建工具，您可能需要所有的容器。但对于大多数游戏来说，少量就足够了:"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:291
msgid "MarginContainer, to add margins around part of the UI"
msgstr "MarginContainer，在部分UI周围添加边缘"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:292
msgid "CenterContainer, to center its children in its bounding box"
msgstr "CenterContainer，将其子元素置于其边框中"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:293
msgid ""
"VboxContainer and HboxContainer, to arrange UI elements in rows or columns"
msgstr "VboxContainer和HboxContainer，将UI元素排列在行或列中"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:295
msgid "GridContainer, to arrange Controls nodes in a grid-like pattern"
msgstr "GridContainer，以网格形式排列控件节点"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:297
msgid ""
"CenterContainer centers all its children inside of its bounding rectangle. "
"It's one you typically use for title screens, if you want the options to "
"stay in the center of the viewport. As it centers everything, you'll often "
"want a single container nested inside it. If you use textures and buttons "
"instead, they'll stack up."
msgstr ""
"CenterContainer把所有子元素集中在它的边框内。如果您想让选项保持在视孔的中心位"
"置，这是一个通常用于标题屏幕的选项。由于它集中于所有内容，您通常需要在其中嵌"
"套单个容器。如果您使用纹理和按钮，它们会堆积起来。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:305
msgid ""
"CenterContainer in action. The life bar centers inside its parent container."
msgstr "CenterContainer的作用。生命条位于它的父容器内部。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:308
msgid ""
"The MarginContainer adds a margin on any side of the child nodes. Add a "
"MarginContainer that encompasses the entire viewport to add a separation "
"between the edge of the window and the UI. You can set a margin on the top, "
"left, right, or bottom side of the container. No need to tick the checkbox: "
"click the corresponding value box and type any number. It will activate "
"automatically."
msgstr ""
"边缘型容器在子节点的任何一侧都添加了一个边距。添加一个包含整个viewport的边线"
"容器，以在窗口边缘和UI之间添加分隔符。您可以在容器的顶部、左侧、右侧或底部设"
"置一个边距。不需要勾选复选框:单击相应的值框并输入任何数字。它会自动激活。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:317
msgid "The MarginContainer adds a 40px margin around the Game User Interface"
msgstr "MarginContainer在游戏用户界面周围增加40px空白"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:319
msgid ""
"There are two BoxContainers: VBoxContainer and HBoxContainer. You cannot add "
"the BoxContainer node itself, as it is a helper class, but you can use "
"vertical and horizontal box containers. They arrange nodes either in rows or "
"columns. Use them to line up items in a shop, or to build complex grids with "
"rows and columns of different sizes, as you can nest them to your heart's "
"content."
msgstr ""
"有两个boxcontainer:VBoxContainer和HBoxContainer。您不能添加BoxContainer节点本"
"身，因为它是一个辅助类，但是您可以使用垂直和水平的box容器。它们以行或列的形式"
"排列节点。用它们来排列商店里的商品，或者用不同大小的行和列构建复杂的网格，因"
"为您可以将它们嵌套在您的核心内容中。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:328
msgid "The HBoxContainer horizontally aligns UI elements"
msgstr "HBoxContainer水平对齐UI元素"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:330
msgid ""
"VBoxContainer automatically arranges its children into a column. It puts "
"them one after the other. If you use the separation parameter, it will leave "
"a gap between its children. HBoxContainer arranges UI elements in a row. "
"It's similar to the VBoxContainer, with an extra ``add_spacer`` method to "
"add a spacer control node before its first child or after its last child, "
"from a script."
msgstr ""
"VBoxContainer自动将它的子元素排列到一个列中。它把它们一个接一个地放在一起。如"
"果使用分离参数，它将在其子元素之间留下间隙。HBoxContainer将UI元素排列成一行。"
"它类似于VBoxContainer，带有一个额外的`add_spacer`方法，可以从脚本中在第一个子"
"节点之前或最后一个子节点之后添加间隔控制节点。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:337
msgid ""
"The GridContainer lets you arrange UI elements in a grid-like pattern. You "
"can only control the number of columns it has, and it will set the number of "
"rows by itself, based on its children's count. If you have nine children and "
"three columns, you will have 9÷3 = 3 rows. Add three more children and "
"you'll have four rows. In other words, it will create new rows as you add "
"more textures and buttons. Like the box containers, it has two properties to "
"set the vertical and horizontal separation between the rows and columns "
"respectively."
msgstr ""
"GridContainer允许您将UI元素按网格模式排列。您只能控制它所拥有的列的数量，并且"
"它将根据其子元素的计数自行设置行数。如果您有9个子节点和三列,您将有9÷3 = 3行。"
"再加3个子行，就有4行了。换句话说，当您添加更多的纹理和按钮时，它将创建新的"
"行。与box容器一样，它有两个属性分别设置行和列之间的垂直和水平分隔。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:348
msgid "A GridContainer with 2 columns. It sizes each column automatically."
msgstr "一个有两列的GridContainer(网格容器)。它会自动调整每个列的大小。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:350
msgid ""
"Godot's UI system is complex, and has a lot more to offer. To learn how to "
"design more advanced interfaces, head to the :ref:`GUI section <toc-learn-"
"features-gui>` of the docs."
msgstr ""
"Godot的UI系统很复杂，还有很多东西可以提供。要了解如何设计更高级的界面，请访"
"问 :ref:`GUI section <toc-learn-features-gui>` 文档。"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:4
msgid "Design a title screen"
msgstr "设计标题屏幕"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:6
msgid ""
"In the next two tutorials, you will build two responsive UI (user interface) "
"scenes step-by-step using the engine's UI system:"
msgstr ""
"在接下来的两个教程中，您将使用引擎的UI系统逐步构建两个响应式UI(用户界面)场景:"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:9
msgid "A main menu"
msgstr "主菜单"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:10
msgid "A game UI with a health bar, energy bar, bomb and money counters"
msgstr "一个带有健康条、能量条、炸弹和金钱计数器的游戏UI"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:12
msgid ""
"You will learn how to design game UIs efficiently, and how to use Godot's "
"Control nodes. This page focuses on the visual part: everything you do from "
"the editor. To learn how to code a life bar, read :doc:`ui_code_a_life_bar`"
msgstr ""
"您将学习如何有效地设计游戏UI，以及如何使用Godot的控制节点。这个页面主要关注视"
"觉部分:您从编辑器中所做的一切。要学习如何编写生命条代码，请阅读::doc:"
"`ui_code_a_life_bar`"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:20
msgid "The GUI you're going to create"
msgstr "您将要创建的GUI"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:22
#, fuzzy
msgid ""
"Download the project files: :download:`ui_main_menu_design.zip <files/"
"ui_main_menu_design.zip>` and extract the archive. Import the ``start/`` "
"project in Godot to follow this tutorial. The ``end/`` folder contains the "
"final result. You'll find all the sprites in the ``start/assets/main_menu`` "
"folder."
msgstr ""
"下载项目文件: :download:`ui_main_menu_design.zip <files/ui_main_menu_design."
"zip>` ，并提取存档。在Godot中导入`start/`项目以遵循本教程。`end/`文件夹包含最"
"终结果。您会在`start/assets/main_menu`文件夹中找到所有的精灵。"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:33
msgid "How to design your game UI"
msgstr "如何设计您的游戏UI"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:35
msgid ""
"To design a good UI, you want to come up with a rough mockup first: a plain "
"drawing version that focuses on the placement of your UI components, their "
"size, and user interaction. Pen and paper is all you need. You shouldn't use "
"fancy and final graphics at this stage. Then, you only need simple "
"placeholder sprites and you're good to jump into Godot. You want to make "
"sure the players can find their way around the interface using those "
"placeholders."
msgstr ""
"要设计一个好的UI，您首先需要提供一个粗略的模型:一个简单的绘图版本，它关注UI组"
"件的位置、大小和用户交互。您只需要纸和笔。在这个阶段您不应该使用花哨的和最终"
"的图形。然后，您只需要简单的占位符精灵，就可以进入Godot了。您要确保游戏角色能"
"够通过这些占位符在界面中找到自己的路。"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:45
msgid "The UI's rough plan or mockup"
msgstr "UI的粗略计划或模型"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:47
msgid ""
"Placeholder doesn't have to mean ugly, but you should keep the graphics "
"simple and clean. Avoid special effects, animation, and detailed "
"illustration before you have players playtest your UI. Otherwise:"
msgstr ""
"占位符不一定意味着难看，但是您应该保持图形简单和干净。在让游戏角色测试您的UI"
"之前，避免使用特效、动画和详细说明。否则:"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:51
msgid ""
"The graphics might skew the players' perception of the experience and you'll "
"miss out on valuable feedback"
msgstr "图形可能会扭曲游戏角色对体验的感知，而您会错过有价值的反馈"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:53
msgid "If the User Experience doesn't work, you'll have to redo some sprites"
msgstr "如果用户体验不起作用，您将不得不重新做一些精灵"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:57
msgid ""
"Always try to make the interface work with simple text and boxes first. It's "
"easy to replace the textures later. Professional UX designers often work "
"with plain outlines and boxes in greyscale. When you take colors and fancy "
"visuals away, it's a lot easier to size and place UI elements properly. It "
"helps you refine the design foundation you'll build upon."
msgstr ""
"总是首先尝试让界面使用简单的文本和框。以后很容易替换纹理。专业的用户体验设计"
"师经常使用灰色的简单轮廓和盒子。当您去掉颜色和花哨的视觉效果时，大小和放置UI"
"元素就会容易得多。它帮助您完善您将要建立的设计基础。"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:64
msgid "There are two ways to design your UI in Godot. You can:"
msgstr "在Godot中有两种设计UI的方法。您可以:"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:66
msgid ""
"Build it all in a single scene, and eventually save some branches as "
"reusable scenes"
msgstr "在一个场景中构建它，并最终将一些分支保存为可重用的场景"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:68
msgid ""
"Build template scenes for reusable components and create specific components "
"that inherit from your base scenes"
msgstr "为可重用组件构建模板场景，并创建从基本场景继承的特定组件"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:71
msgid ""
"We will use the first approach, because the first version of your UI may not "
"work as well as you’d like. You’re likely to throw parts away and redesign "
"components as you go. When you're sure everything works, it's easy to make "
"some parts reusable, as you'll see below."
msgstr ""
"我们将使用第一种方法，因为您的UI的第一个版本可能不像您希望的那样工作。您可能"
"会扔掉零件，重新设计零件。当您确信一切工作正常时，很容易使某些部件重复使用，"
"如下所示。"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:78
msgid ""
"The files you'll find in Godot. The graphics look cleaner than on the rough "
"design, but they're still placeholders"
msgstr ""
"您可以在Godot找到的文件。图形看起来比粗糙的设计干净，但它们仍然是占位符"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:82
msgid "Design the main menu"
msgstr "设计主菜单"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:84
msgid ""
"Before we jump into the editor, we want to plan how we'll nest containers "
"based on our mockup image."
msgstr "在进入编辑器之前，我们要计划如何基于模型映像嵌套容器。"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:88
#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:279
msgid "Break down the UI mockup"
msgstr "分解UI模型"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:90
msgid "Here are my three rules of thumb to find the right containers:"
msgstr "以下是我找到合适容器的三条经验法则:"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:92
msgid ""
"Break down the UI into nested boxes, from the largest that contains "
"everything, to the smallest ones, that encompass one widget, like a bar with "
"its label, a panel or a button"
msgstr ""
"将UI分解为嵌套框，从包含所有内容的最大框到包含一个小部件的最小框，比如带有标"
"签的条形图、面板或按钮"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:95
msgid "If there's some padding around an area, use a ``MarginContainer``"
msgstr "如果一个区域周围有一些填充，使用`MarginContainer`"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:96
msgid ""
"If the elements are arranged in rows or columns, use an ``HBoxContainer`` or "
"``VBoxContainer``"
msgstr "如果元素以行或列的形式排列，则使用`HBoxContainer`或`VBoxContainer`"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:99
msgid ""
"These rules are enough to get us started, and work well for simple "
"interfaces."
msgstr "这些规则足以让我们开始，并且可以很好地用于简单的界面。"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:102
msgid ""
"For the main menu, the largest box is the entire game window. There's "
"padding between the edges of the window and the first components: this "
"should be a ``MarginContainer``. Then, the screen is split into two columns, "
"so we'll use an ``HBoxContainer``. In the left column, we'll manage the rows "
"with a ``VBoxContainer``. And in the right column, we'll center the "
"illustration with a ``CenterContainer``."
msgstr ""
"对于主菜单，最大的框是整个游戏窗口。在窗口边缘和第一个组件之间有填充:这应该是"
"一个`MarginContainer`。然后，屏幕被分成两列，因此我们将使用`HBoxContainer`。"
"在左列中，我们将使用`VBoxContainer`来管理行。在右边的一列中，我们将用"
"`CenterContainer`将插图居中。"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:111
msgid "Interface building blocks, broken down using the three rules of thumb"
msgstr "界面构建块，使用三个经验法则分解"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:115
msgid ""
"Containers adapt to the window's resolution and width-to-height ratio. "
"Although we could place UI elements by hand, containers are faster, more "
"precise, and **responsive**."
msgstr ""
"容器适应窗户的分辨率和宽高比。虽然我们可以手工放置UI元素，但是容器更快、更精"
"确、响应更快。"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:120
msgid "Prepare the Main Menu scene"
msgstr "准备主菜单场景"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:122
msgid ""
"Let's create the main menu. We'll build it in a single scene. To create an "
"empty scene, click on the Scene menu -> New Scene."
msgstr ""
"让我们创建主菜单。我们将在一个场景中构建它。要创建一个空场景，单击场景菜单->"
"新场景。"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:125
msgid ""
"We have to add a root node before we can save the scene. Your UI's root "
"should be the outermost container or element. In this case it's a "
"``MarginContainer``. ``MarginContainer`` is a good starting point for most "
"interfaces, as you often need padding around the UI. Press ``Meta+S`` to "
"save the scene to the disk. Name it *MainMenu*."
msgstr ""
"在保存场景之前，我们必须添加一个根节点。UI的根应该是最外层的容器或元素。在这"
"种情况下，它是一个`MarginContainer`。`MarginContainer`是大多数界面的良好起"
"点，因为您经常需要在UI周围填充。按下`Meta+S`将场景保存到磁盘。把它命名为 "
"*MainMenu* 。"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:131
msgid ""
"Select the ``MarginContainer`` again, and head to the inspector to define "
"the margins' size. Scroll down the ``Control`` class, to the ``Custom "
"Constants`` section. Unfold it. Set the margins as such:"
msgstr ""
"再次选择`MarginContainer`，然后转向属性面板来定义边距的大小。向下滚动"
"`Contro(控制)`类，到`Custom Constants(自定义常量)`部分。展开它。设置边缘如下:"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:135
msgid "Margin Right: *120*"
msgstr "边缘右侧: *120*"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:136
msgid "Margin Top: *80*"
msgstr "边缘顶部: *80*"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:137
msgid "Margin Left: *120*"
msgstr "边缘左侧: *120*"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:138
msgid "Margin Bottom: *80*"
msgstr "边缘底部: *80*"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:140
msgid ""
"We want the container to fit the window. In the Viewport, open the "
"``Layout`` menu and select the last option, ``Full Rect``."
msgstr ""
"我们希望容器能适合窗户。在视窗中，打开`Layout(布局)`菜单，选择最后一个选项"
"`Full Rect(完全矩形)`。"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:144
msgid "Add the UI sprites"
msgstr "添加UI精灵"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:146
msgid ""
"Select the ``MarginContainer``, and create the UI elements as "
"``TextureRect`` nodes. We need:"
msgstr "选择`MarginContainer`，并将UI元素创建为`TextureRect`节点。我们需要:"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:149
msgid "The title, or logo"
msgstr "标题或标志"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:150
msgid "The three text options, as individual nodes"
msgstr "三个文本选项，作为单独的节点"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:151
msgid "The version note"
msgstr "版本注释"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:152
msgid "And the main menu’s illustration"
msgstr "和主菜单的插图"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:154
msgid ""
"Click the ``Add Node`` button or press ``Meta+A`` on your keyboard. Start to "
"type ``TextureRect`` to find the corresponding node and press enter. With "
"the new node selected, press ``Meta+D`` five times to create five extra "
"``TextureRect`` instances."
msgstr ""
"点击键盘上的`Add Node(添加节点)`按钮或按下`CTRL+A`按钮。开始输入`TextureRect`"
"以找到相应的节点并按回车键。选中新节点后，按`CTRL+D`五次以创建(复制)额外的五"
"个`TextureRect`实例。"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:159
#, fuzzy
msgid ""
"Click each of the nodes to select it. In the inspector, find the ``Texture`` "
"property and click ``[empty]`` -> ``Load``. A file browser opens and lets "
"you pick a sprite to load into the texture slot."
msgstr ""
"单击每个节点以选择它。在属性面板中，单击纹理属性右侧的`…`图标，然后单击"
"`Load`。打开一个文件浏览器，让您选择一个精灵加载到纹理槽中。"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:165
msgid "The file browser lets you find and load textures"
msgstr "文件浏览器允许您查找和加载纹理"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:167
msgid ""
"Repeat the operation for all ``TextureRect`` nodes. You should have the "
"logo, the illustration, the three menu options and the version note, each as "
"a separate node. Then, double click on each of the nodes in the Scene tab to "
"rename them."
msgstr ""
"对所有`TextureRect`节点重复该操作。您应该有徽标、插图、三个菜单选项和版本说"
"明，每个都作为一个单独的节点。然后，双击Scene选项卡中的每个节点来重命名它们。"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:174
msgid "The six nodes, with textures loaded"
msgstr "6个节点，带有加载的纹理"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:178
msgid ""
"If you want to support localization in your game, use ``Labels`` for menu "
"options instead of ``TextureRect``."
msgstr ""
"如果您想在您的游戏中支持本地化，用`Labels(标签)`代替菜单`TextureRect`。"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:182
msgid "Add containers to place UI elements automatically"
msgstr "添加容器来自动放置UI元素"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:184
msgid ""
"Our main menu has some margin around the edges of the screen. It is split in "
"two parts: on the left, you have the logo and the menu options. On the "
"right, you have the characters. We can use one of two containers to achieve "
"this: ``HSplitContainer`` or ``HBoxContainer``. Split containers split the "
"area into two: a left and a right side or a top and a bottom side. They also "
"allow the user to resize the left and right areas using an interactive bar. "
"On the other hand, ``HBoxContainer`` just splits itself into as many columns "
"as it has children. Although you can deactivate the split container's resize "
"behaviour, I recommend to favour box containers."
msgstr ""
"我们的主菜单在屏幕边缘有一些空白。它被分成两部分:在左边，您有logo和菜单选项。"
"右边是人物。我们可以使用两个容器中的一个来实现这一点:`HSplitContainer`或"
"`HBoxContainer`。分裂的容器将区域分成两部分:左边和右边或者顶部和底部。它们还"
"允许用户使用交互栏调整左右区域的大小。另一方面，`HBoxContainer`只是将自己分割"
"成尽可能多的列。尽管您可以禁用分离容器的调整大小行为，但我建议使用箱形容器。"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:195
msgid ""
"Select the ``MarginContainer`` and add an ``HBoxContainer``. Then, we need "
"two containers as children of our ``HBoxContainer``: a ``VBoxContainer`` for "
"the menu options on the left, and a ``CenterContainer`` for the illustration "
"on the right."
msgstr ""
"选择`MarginContainer`并添加`HBoxContainer`。然后，我们需要两个容器作为"
"`HBoxContainer`的子容器:一个`VBoxContainer`用于左边的菜单选项，一个"
"`CenterContainer`用于右边的插图。"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:202
msgid ""
"You should have four nested containers, and the TextureRect nodes sitting "
"aside from it"
msgstr "您应该有四个嵌套的容器，以及放置在它旁边的文本竖立节点"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:205
#, fuzzy
msgid ""
"In the node tree, select all the ``TextureRect`` nodes that should go on the "
"left side: the logo, the menu options and the version note. Drag and drop "
"them into the ``VBoxContainer``. The nodes should position automatically."
msgstr ""
"在节点树中，选择应该位于左侧的所有`TextureRect`节点:徽标、菜单选项和版本说"
"明。将它们拖放到`VBoxContainer`中。然后，将插图节点拖放到`CenterContainer`"
"中。节点应该自动定位。"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:211
msgid "Containers automatically place and resize textures"
msgstr "容器自动放置和调整纹理大小"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:213
msgid "We're left with two problems to solve:"
msgstr "我们还有两个问题要解决:"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:215
msgid "The characters on the right aren't centered"
msgstr "右边的字符没有居中"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:216
msgid "There's no space between the logo and the other UI elements"
msgstr "logo和其他UI元素之间没有空间"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:218
#, fuzzy
msgid ""
"To center the characters on the right, first select the ``CenterContainer``. "
"Then in the Inspector, scroll down to the ``Size Flags`` category and click "
"on the field to the right of the ``Vertical`` property, and check ``Expand`` "
"in addition to ``Fill``. Do the same for the ``Horizontal`` property. This "
"makes the ``CenterContainer`` expand into all available space while "
"respecting its neighbour ``VBoxContainer``. Finally, drag and drop the "
"Characters node into the ``CenterContainer``. The Characters element will "
"center automatically."
msgstr ""
"为了使右边的字符居中，我们将使用`CenterContainer`。添加一个`CenterContainer`"
"节点作为`HBoxContainer`的子节点。然后在属性面板中，向下滚动到`Size Flags(大小"
"标志)`类别，单击`Vertical(垂直)`属性右侧的字段，并检查`Expand(展开)`。对"
"`Horizontal(水平)`属性执行相同的操作。最后将字符拖放到`CenterContainer`中。字"
"符元素将自动居中。"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:229
msgid ""
"The character node centers inside the right half of the screen as soon as "
"you place it inside the CenterContainer"
msgstr "只要将字符节点放在CenterContainer中，它就会集中在屏幕右侧"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:232
msgid ""
"To space out the menu options and the logo on the left, we'll use one final "
"container and its size flags. Select the ``VBoxContainer`` and press ``Meta"
"+A`` to add a new node inside it. Add a second ``VBoxContainer`` and name it "
"\"MenuOptions\". Select all three menu options, ``Continue``, ``NewGame`` "
"and ``Options``, and drag and drop them inside the new ``VBoxContainer``. "
"The UI's layout should barely change, if at all."
msgstr ""
"为了分隔菜单选项和左边的徽标，我们将使用最后一个容器及其大小标志。选择"
"`VBoxContainer`并按`Meta+A`在其中添加一个新节点。添加第二个`VBoxContainer`并"
"将其命名为`MenuOptions`。选择`Continue(继续)`、`NewGame(新游戏)`和`Options(选"
"项)`这三个菜单选项，并将它们拖放到新的`VBoxContainer`中。UI的布局应该几乎不会"
"改变。"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:242
msgid ""
"Place the new container between the other two nodes to retain the UI's layout"
msgstr "将新容器放在其他两个节点之间，以保持UI的布局"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:245
msgid ""
"Now we grouped the menu options together, we can tell their container to "
"expand to take as much vertical space as possible. Select the "
"``MenuOptions`` node. In the Inspector, scroll down to the ``Size Flags`` "
"category. Click on the field to the right of the ``Vertical`` property, and "
"check ``Expand`` in addition to ``Fill``. The container expands to take all "
"the available vertical space. But it respects its neighbors, the ``Logo`` "
"and ``Version`` elements."
msgstr ""
"现在我们将菜单选项组合在一起，我们可以告诉它们的容器扩展到尽可能多的垂直空"
"间。选择`MenuOptions`节点。在属性面板中，向下滚动到`Size Flags(大小标志)`类"
"别。单击`Vertical(垂直)`属性右侧的字段，并检查`Expand(展开)`。容器膨胀以获得"
"所有可用的垂直空间。但它尊重它的邻居，`Logo`和`Version(Version)`元素。"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:253
msgid ""
"To center the nodes in the ``VBoxContainer``, scroll to the top of the "
"Inspector and change the ``Alignment`` property to ``Center``."
msgstr ""
"要将`VBoxContainer`中的节点居中，请滚动到属性面板的顶部，并将`Alignment(对"
"齐)`属性更改为`Center(居中)`。"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:258
msgid "The menu options should center vertically in the UI's left column"
msgstr "菜单选项应该垂直居中在UI的左列中"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:260
msgid ""
"To wrap things up, let's add some separation between the menu options. "
"Expand the ``Custom Constants`` category below ``Size Flags``, and click the "
"field next to the ``Separation`` parameter. Set it to 30. Once you press "
"enter, the ``Separation`` property becomes active and Godot adds 30 pixels "
"between menu options."
msgstr ""
"为了总结，让我们在菜单选项之间添加一些分隔。展开`Size Flags(大小标志)`下面的"
"`Custom Constants(自定义常量)`类别，然后单击`Separation(分离)`参数旁边的字"
"段。设置为30。一旦您按下回车键，`Separation(分离)`属性就会激活，Godot会在菜单"
"选项之间增加30个像素。"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:268
msgid "The final interface"
msgstr "最终界面"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:270
msgid ""
"Without a single line of code, we have a precise and responsive main menu."
msgstr "没有一行代码，我们就有了一个精确且响应迅速的主菜单。"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:273
#, fuzzy
msgid ""
"Congratulations for getting there! You can download the final menu :download:"
"`ui_main_menu_design.zip <files/ui_main_menu_design.zip>` to compare with "
"your own. In the next tutorial, you'll create a Game User Interface with "
"bars and item counters."
msgstr ""
"恭喜您做到了!您可以下载`final menu <#>`__ 来与您自己的菜单进行比较。在下一个"
"教程中，您将创建一个带有栏和物品计数器的游戏用户界面。"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:281
msgid ""
"A responsive User Interface is all about making sure our UIs scale well on "
"all screen types. TV screens and computer displays have different sizes and "
"ratios. In Godot, we use containers to control the position and the size of "
"UI elements."
msgstr ""
"响应式用户界面就是要确保我们的ui在所有屏幕类型上都能很好地伸缩。电视屏幕和电"
"脑显示器有不同的大小和比例。在Godot中，我们使用容器来控制UI元素的位置和大小。"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:286
msgid ""
"The order in which you nest matters. To see if your UI adapts nicely to "
"different screen ratios, select the root node, press the Q key to activate "
"the Select Mode, select the container and click and drag on one of the "
"container's corners to resize it. The UI components should flow inside of it."
msgstr ""
"嵌套的顺序很重要。要查看UI是否能很好地适应不同的屏幕比例，请选择根节点，按Q键"
"激活选择模式，选择容器，然后单击并拖动容器的某个角落以调整其大小。UI组件应该"
"在其中流动。"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:292
msgid ""
"You'll notice that although containers move sprites around, they don't scale "
"them. This is normal. We want the UI system to handle different screen "
"ratios, but we also need the entire game to adapt to different screen "
"resolutions. To do this, Godot scales the entire window up and down."
msgstr ""
"您会注意到，尽管容器四处移动精灵，但它们不会缩放它们。这是正常的。我们希望UI"
"系统能够处理不同的屏幕比例，但我们也需要整个游戏来适应不同的屏幕分辨率。为"
"此，Godot将整个窗口上下缩放。"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:298
msgid ""
"You can change the scale mode in the project settings: click the Project "
"menu -> Project Settings. In the window's left column, look for the Display "
"category. Click on the Window sub-category. On the right side of the window, "
"you'll find a Stretch section. The three settings, Mode, Aspect, and Shrink, "
"control the screen size. For more information, see :ref:"
"`doc_multiple_resolutions`."
msgstr ""
"您可以在项目设置中更改缩放模式:单击项目菜单->项目设置。在窗口的左列中，查找显"
"示类别。单击窗口子类别。在窗户的右边，您会发现一个伸展的部分。三个设置，模"
"式，方面，和缩小，控制屏幕的大小。有关更多信息，请参见 :ref:"
"`doc_multiple_resolutions`。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:4
msgid "Design the GUI"
msgstr "设计GUI"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:6
#, fuzzy
msgid ""
"Now that you've nailed the basics, we're going to see how to build a game "
"Graphical User Interface (GUI) with reusable UI components: a life bar, an "
"energy bar, and bomb and emerald counters. By the end of this tutorial, "
"you'll have a game GUI, ready to control with GDscript or VisualScript:"
msgstr ""
"既然您已经掌握了基本知识, 我们将看到如何利用可复用的 UI 组件构建游戏用户界面 "
"(GUI): 生命条、能量条、炸弹和卢比计数器。直到本教程结束时, 您将拥有一个游戏 "
"GUI, 可以使用 GDscript 或 VisualScript 来控制:"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:13
#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:621
msgid "The final result"
msgstr "最终效果"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:15
msgid "You'll also learn to:"
msgstr "您还将学习:"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:17
msgid "Create flexible UI components"
msgstr "创建灵活的 UI 组件"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:18
msgid "Use scene inheritance"
msgstr "使用场景继承"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:19
msgid "Build a complex UI"
msgstr "构建一个复杂的UI"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:21
msgid ""
"Download the project files: :download:`ui_gui_design.zip <files/"
"ui_gui_design.zip>` and extract the archive. Import the `start/` project in "
"Godot to follow this tutorial. The `end/` folder contains the final result."
msgstr ""
"下载项目文件: :download:`ui_gui_design.zip <files/ui_gui_design.zip>` ，并提"
"取存档。导入Godot中的`start/`项目以遵循本教程。`end/`文件夹包含最终结果。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:25
msgid ""
"You can watch this tutorial as a `video on Youtube <https://www.youtube.com/"
"watch?v=y1E_y9AIqow>`_."
msgstr ""
"您可以在Youtube上观看这个教程的 `视频 <https://www.youtube.com/watch?"
"v=y1E_y9AIqow>`_ 。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:28
msgid "Breaking down the UI"
msgstr "分解UI"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:30
msgid ""
"Let's break down the final UI and plan the containers we'll use. As in the :"
"doc:`ui_main_menu`, it starts with a ``MarginContainer``. Then, we can see "
"up to three columns:"
msgstr ""
"让我们分解最终的UI并计划我们将使用的容器。在:doc:`ui_main_menu`中，它以"
"`MarginContainer`开头。然后，我们最多可以看到三列:"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:34
msgid "The life and energy counters on the left"
msgstr "左边是生命和能量的计数器"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:35
msgid "The life and energy bars"
msgstr "生命和能量条"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:36
#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:42
#, fuzzy
msgid "The bomb and emerald counters on the right"
msgstr "炸弹和卢比计数器在右边"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:38
msgid ""
"But the bar's label and the gauge are two parts of the same UI element. If "
"we think of them this way, we're left with two columns:"
msgstr ""
"但是条的标签和标尺是同一个UI元素的两个部分。如果我们这样想的话，就剩下两列了:"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:41
msgid "The life and energy bars on the left"
msgstr "左边是生命和能量条"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:44
#, fuzzy
msgid ""
"This makes it easier to nest containers: we have some margins around the "
"border of the screen using a ``MarginContainer``, followed by an "
"``HBoxContainer`` to manage our two columns. The two bars stack on top of "
"one another inside a ``VBoxContainer``. And we'll need a last "
"``HBoxContainer`` in the right column to place the bomb and emerald counters "
"side-by-side."
msgstr ""
"这使得嵌套容器变得更加容易:我们在屏幕的边界周围使用了一个`MarginContainer`，"
"后面跟着一个`HBoxContainer`来管理我们的两个列。这两个条在一个`VBoxContainer`"
"中堆叠在一起。我们还需要在右边一列最后一个`HBoxContaine`来将炸弹和卢比计数器"
"并排放置。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:53
msgid "We get a clean UI layout with only 4 containers"
msgstr "我们得到了一个简洁的UI布局，只有4个容器"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:55
msgid ""
"We will need extra containers inside the individual UI components, but this "
"gives us the main GUI scene's structure. With this plan in place, we can "
"jump into Godot and create our GUI."
msgstr ""
"我们需要在单独的UI组件中添加额外的容器，但这提供了主要GUI场景的结构。有了这个"
"计划，我们可以进入Godot并创建我们的GUI。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:60
msgid "Create the base GUI"
msgstr "创建基本GUI"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:62
msgid ""
"There are two possible approaches to the GUI: we can design elements in "
"separate scenes and put them together, or prototype everything in a single "
"scene and break it down later. I recommend working with a single scene as "
"you can play with your UI's placement and proportions faster this way. Once "
"it looks good, you can save entire sections of the node tree as reusable sub-"
"scenes. We'll do that in a moment."
msgstr ""
"对于GUI有两种可能的方法:我们可以在单独的场景中设计元素并将它们组合在一起，或"
"者在单个场景中原型化所有内容，然后将其分解。我建议使用单个场景，因为这样可以"
"更快地处理UI的位置和比例。一旦看起来不错，您就可以将节点树的整个部分保存为可"
"重用的子场景。我们马上就做。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:69
msgid "For now, let's start with a few containers."
msgstr "现在，让我们从几个容器开始。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:71
msgid ""
"Create a new scene and add a ``MarginContainer``. Select the node and name "
"it ``GUI``."
msgstr "创建一个新场景并添加一个`MarginContainer`。选择节点并将其命名为`GUI`。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:74
msgid ""
"We want our interface to anchor to the top of the screen. Select the ``GUI`` "
"node and click the Layout button at the top of the viewport. Select the "
"``Top Wide`` option. The ``GUI`` node will anchor to the top edge of its "
"parent, the viewport by default. It will resize automatically on the "
"vertical axis to make space for its child UI components."
msgstr ""
"我们希望我们的界面锚定到屏幕的顶部。选择`GUI`节点并单击视图顶部的布局按钮。选"
"择`Top Wide(顶部宽)`选项。默认情况下，`GUI`节点将锚定到其父端的视区顶部。它将"
"在垂直轴上自动调整大小，为其子UI组件腾出空间。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:80
msgid "Save the scene as ``GUI.tscn``. We will put the entire GUI in it."
msgstr "保存场景为`GUI.tscn`。我们将把整个GUI放入其中。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:82
msgid ""
"With the ``MarginContainer`` selected, head to the inspector and scroll down "
"to the custom constants section. Unfold it and click the field next to each "
"of the ``Margin`` properties. Set them all to ``20`` pixels. Next, add an "
"``HBoxContainer`` node. This one will contain our two bars on the left and "
"separate them from the two counters on the right."
msgstr ""
"选中`MarginContainer`后，转到属性面板并向下滚动到定制常量部分。展开它，然后单"
"击`Margin`属性旁边的字段。将它们都设置为`20`像素。接下来，添加一个"
"`HBoxContainer`节点。这个将包含左边的两个栏，并将它们与右边的两个柜台分开。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:88
#, fuzzy
msgid ""
"We want to stack the bars vertically inside the ``HBoxContainer``. Add a "
"``VBoxContainer`` as a child of ``HBoxContainer`` and name it ``Bars``. "
"Select the parent ``HBoxContainer`` again and this time, add another "
"``HBoxContainer`` as a child of it. Call it ``Counters``. With these four "
"containers, we have the base for our GUI scene."
msgstr ""
"我们想要在`HBoxContainer`中垂直堆叠栏。添加一个`VBoxContainer`作为`GUI`的子元"
"素，并将其命名为`Bars`。再次选择父`HBoxContainer`，这一次，添加另一个"
"`HBoxContainer`作为它的子元素。称之为`Counters(计数器)`。有了这四个容器，我们"
"就有了GUI场景的基础。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:95
msgid "You should have 4 containers that look like this"
msgstr "您应该有4个这样的容器"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:99
msgid ""
"We can work this way because we first broke down our UI design and took a "
"few moments to think about the containers we'd use. When you follow a "
"tutorial like this, it may seem weird. But once you're working on real "
"games, you'll see it's an efficient workflow."
msgstr ""
"我们可以这样做，因为我们首先分解了UI设计，并花了一些时间来考虑我们要使用的容"
"器。当您学习这样的教程时，可能会觉得很奇怪。但是一旦您在真正的游戏中工作，您"
"就会发现它是一个高效的工作流程。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:105
msgid "Create the bars' base"
msgstr "创建条形底座"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:107
msgid ""
"Each bar is split into two sub-elements that align horizontally: the label "
"with the health count on the left, and the gauge on the right. Once again, "
"the ``HBoxContainer`` is the perfect tool for the job. Select the ``Bars`` "
"node and add a new ``HBoxContainer`` inside of it. Name it ``Bar``."
msgstr ""
"每个条被分成两个水平对齐的子元素:左边的健康计数标签，右边的标尺。同样，"
"`HBoxContainer`是这项工作的完美工具。选择`bar`节点，并在其中添加一个新的"
"`HBoxContainer`。命名为`Bar`。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:113
msgid ""
"The label itself requires at least three nodes: a ``NinePatchRect`` for the "
"background, on top of which we'll add a texture on the left, either ``HP`` "
"or ``EP``, and a ``Label`` on the right for the value. We can nest "
"``Control`` nodes however we want. We could use the ``NinePatchRect`` as a "
"parent for the two other elements, as it encompasses them. In general, you "
"want to use containers instead, as their role is to help organize UI "
"components. We'll need a ``MarginContainer`` later anyway to add some space "
"between the life count and the gauge. Select the ``Bar`` and add a "
"``MarginContainer``. Name it ``Count``. Inside of it, add three nodes:"
msgstr ""
"标签本身至少需要三个节点:一个`NinePatchRect`作为背景，在上面我们在左边添加一"
"个纹理，要么是`HP`，要么是`EP`，右边是`label`。我们可以任意嵌套`Control(控"
"制)`节点。我们可以使用`NinePatchRect`作为其他两个元素的父元素，因为它包含了这"
"两个元素。通常，您需要使用容器，因为它们的角色是帮助组织UI组件。我们以后还需"
"要一个`MarginContainer`来在生命计数和量规之间增加一些空间。选择`Bar`，添加"
"`MarginContainer`。命名为`Count(数)`。在其中添加三个节点:"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:124
msgid "A ``NinePatchRect`` named ``Background``"
msgstr "一个`NinePatchRect`命名为`Background`"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:125
msgid "A ``TextureRect`` named ``Title``"
msgstr "一个`TextureRect`命名为`Title`"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:126
msgid "And a ``Label`` named ``Number``"
msgstr "和一个`Label`命名为`Number`"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:128
msgid "To add the nodes as siblings, always select the ``Count`` node first."
msgstr "要将节点添加为兄弟节点，始终先选择`Count`节点。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:132
msgid ""
"Your scene tree should look like this. We're ready to throw in some textures"
msgstr "您的场景树应该是这样的。我们准备加入一些纹理"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:135
msgid ""
"Our scene is still empty. It's time to throw in some textures. To load the "
"textures, head to the FileSystem dock to the left of the viewport. Browse "
"down to the res://assets/GUI folder."
msgstr ""
"我们的场景仍然是空的。是时候加入一些纹理了。要加载纹理，请转到视区左侧的文件"
"系统码头。浏览到res://assets/GUI文件夹。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:141
msgid "You should see a list of textures that we'll use to skin our interface."
msgstr "您应该会看到一个纹理列表，我们将使用的纹理列表来美化我们的界面。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:144
msgid ""
"Select the ``Background`` in the Scene dock. In the Inspector, you should "
"see a ``Texture`` property. In the FileSystem tab, click and drag "
"``label_HP_bg.png`` onto the ``Texture`` slot. It stays squashed. The parent "
"MarginContainer will force its size down to 0 until we force elements inside "
"the container to have a minimum size. Select the ``Background`` node. In the "
"Inspector, scroll down to the Rect section. Set ``Min Size`` to (100, 40). "
"You should see the ``Background`` resize along with its parent containers."
msgstr ""
"在场景面板中选择`Background(背景)`。在属性面板中，您应该看到一个`Texture(纹"
"理)`属性。在文件系统选项卡中，单击并拖动`label_HP_bg.png`到`Texture(纹理)`"
"槽。它保持压扁。父边缘化容器将强制其大小降为0，直到我们强制容器中的元素具有最"
"小大小。选择`Background(背景)`节点。在属性面板中，向下滚动到Rect部分。设置"
"`Min Size(最小大小)`为(100,40)。您应该会看到`Background(背景)`和它的父容器一"
"起调整大小。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:153
msgid ""
"Next, select the ``Title`` and drag and drop ``label_HP.png`` into its "
"``Texture`` slot. Select the ``Number`` node, click the field next to the "
"``Text`` property and type ``10``. This way, we can see both nodes in the "
"viewport. They should stack up in the top-left corner of their parent "
"``MarginContainer``."
msgstr ""
"接下来，选择`Title(标题)`，拖放`label_HP.png`到它的`Texture(纹理)`槽。选择"
"`Number(数字)`节点，单击`Text(文本)`属性旁边的字段，输入`10`。这样，我们可以"
"在viewport中看到两个节点。他们应该堆积在父母的`MarginContainer`的左上角。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:161
msgid "If you select both nodes, you should see something like this"
msgstr "如果您选择两个节点，您应该会看到这样的结果"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:163
msgid ""
"As they have a container as their direct parent, we cannot move them freely: "
"the ``Count`` node will always reset their anchors, their size and position. "
"Try to move and resize the nodes in the viewport. Then, select any of the "
"three textures and press Ctrl Up or Ctrl Down to reorder them in the Scene "
"dock. They'll snap back to their previous size and position."
msgstr ""
"由于它们有一个作为其直接父容器的容器，所以我们不能随意移动它们:`Count`节点总"
"是会重置它们的锚，它们的大小和位置。尝试移动和调整视图中的节点的大小。然后，"
"选择三种材质中的任何一种，按Ctrl Up或Ctrl Down在场景面板中重新排列它们。它们"
"会迅速恢复到以前的大小和位置。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:170
msgid ""
"Parent containers control the size, the scale, the margins, and the anchors "
"of their direct children. To modify the nodes, you must nest them inside a "
"regular Control or another UI element. We'll use the ``Background`` as a "
"parent for the ``Title`` and ``Number``. Select both the ``Title`` and "
"``Number``, and drag and drop them onto ``Background``."
msgstr ""
"父容器控制其直接子容器的大小、规模、边距和锚。要修改节点，必须将它们嵌套在常"
"规控件或其他UI元素中。我们将使用`Background`作为`Title`和`Number`的父元素。选"
"择`Title`和`Number`，然后拖放到`Background`上。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:179
msgid ""
"By using the Background node as the two textures' parent, we take control "
"away from the Count MarginContainer"
msgstr ""
"通过使用背景节点作为这两个纹理的父节点，我们将控制权从Count MarginContainer移"
"开"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:182
#, fuzzy
msgid ""
"Select the ``Title`` and in the Inspector, change its ``Stretch Mode`` "
"property to ``Keep Centered``. Next find the ``Rect`` category in the "
"Inspector and change the ``Size`` property to (50, 40) so it only takes the "
"left half of the background.  Next, select the ``Number`` node. In the "
"viewport, click the ``Layout`` menu and click ``Full Rect``. The node will "
"resize to fit the ``Background``. Head to the Inspector and change its "
"``Align`` property to ``Right``, and the ``VAlign`` property to ``Center``. "
"The text should snap to the center of the ``Background``'s right edge. "
"Resize the node horizontally, so it takes the right half of the "
"``Background`` and there's a bit of padding with the right edge."
msgstr ""
"选择 ``Title`` ，在属性面板中，改变它的`Stretch Mode伸展模式`属性为`Keep "
"Centered`。接下来，在属性面板中找到`Rect`类别，并将`Size`属性更改为(50,40)，"
"使其只接受背景的左半部分。接下来，选择`Number`节点。在视图中，单击`Layout布局"
"`菜单并单击`Full Rect完整矩形`。节点将调整大小以适应`Background背景`。前往属"
"性面板，将其`Align`属性改为`Right`，`VAlign`属性改为`Center`。文本应该对齐到"
"`Background背景`的右边缘的中心。横向调整节点的大小，使其占据`Background背景`"
"的右半部分，并有一些填充的右边缘。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:195
msgid ""
"Here's how the nodes' bounding boxes should look in the viewport. Keep it "
"rough, you don't need to place them too precisely for now."
msgstr ""
"下面是节点的边界框在视图中的样子。保持粗糙，您现在不需要太精确的放置它们。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:199
msgid "Replace the Label's font"
msgstr "替换标签的字体"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:201
msgid ""
"The label's font is too small. We need to replace it. Select the ``Number`` "
"node and in the Inspector, scroll down to the ``Control`` class, and find "
"the ``Custom Font`` category. Click the field next to the ``Font`` property "
"and click on ``New Dynamic Font``. Click on the field again and select Edit."
msgstr ""
"标签字体太小。我们需要更换它。选择`Number`节点，在属性面板中，向下滚动到"
"`Control`类，并找到`Custom Font`类别。单击`Font字体`属性旁边的字段，然后单击"
"`New Dynamic Font新动态字体`。再次单击该字段并选择Edit。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:207
msgid ""
"You will enter the ``Dynamic Font`` resource. Unfold the ``Font`` category "
"and click the field next to ``Font Data``. Click the ``Load`` button. In the "
"file browser, navigate down to the assets/font folder and double click "
"``Comfortaa-Bold.ttf`` to open it. You should see the font update in the "
"viewport. Unfold the settings category to change the font size. Set the "
"``Size`` property to a higher value, like ``24`` or ``28``."
msgstr ""
"您将输入`Dynamic Font动态字体`资源。展开`Font字型`类别，然后按一下`Font Data"
"字型资料`旁边的栏位。点击`Load加载`按钮。在文件浏览器中，向下导航到assets/"
"font文件夹，双击`Comfortaa-Bold.ttf`打开它。您应该在视图中看到字体更新。展开"
"设置类别以更改字体大小。将`Size`属性设置为更高的值，比如`24`或`28`。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:215
msgid ""
"We now need the text's baseline, the number's lower edge, to align with the "
"HP texture on the left. To do so, still in the ``DynamicFont`` resource, you "
"can tweak the ``Bottom`` property under the ``Extra Spacing`` category. It "
"adds some bottom padding to the text. Click the ``Number`` node in the Scene "
"tab to go back to the node's properties and change the ``VAlign`` to "
"``Bottom``. To adjust the text's baseline, click on the font field under the "
"``Custom Font`` category again and tweak the ``Bottom`` property until the "
"text aligns with the ``Title`` node. I used a value of ``2`` pixels."
msgstr ""
"现在我们需要文本的基线，数字的下边缘，来对齐左边的HP纹理。要做到这一点，仍然"
"在`DynamicFont`资源中，您可以在`Extra Spacing 额外间距`类别下调整`Bottom 底部"
"`属性。它在文本中添加了一些底部填充。点击Scene选项卡中的`Number`节点，回到节"
"点属性，将`VAlign`属性改为`Bottom 底部`。要调整文本的基线，再次单击`Custom "
"Font 自定义字体`类别下的字体字段，调整`Bottom 底部`属性，直到文本与`Title 标"
"题`节点对齐。我使用了`2`像素的值。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:227
msgid "With a Bottom value of 2 pixels, the Number aligns with the Title"
msgstr "底部值为2像素，数字与标题对齐"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:229
msgid ""
"With this, we finished the hardest part of the GUI. Congratulations! Let's "
"move on to the simpler nodes."
msgstr "至此，我们完成了GUI中最困难的部分。恭喜您!让我们继续讨论更简单的节点。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:233
msgid "Add the progress bar"
msgstr "添加进度条"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:235
msgid ""
"We need one last element to complete our life bar: the gauge itself. Godot "
"ships with a ``TextureProgress`` node that has everything we need."
msgstr ""
"我们需要最后一个元素来完成我们的生活:量规本身。Godot附带了一个"
"`TextureProgress`节点，它拥有我们需要的一切。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:238
msgid ""
"Select the Bar node and add a ``TextureProgress`` inside of it. Name it "
"``Gauge``. In the inspector unfold the ``Textures`` section. Head to the "
"FileSystem dock and drag and drop the ``lifebar_bg.png`` texture onto the "
"``Under`` slot. Do the same with the ``lifebar_fill.png`` image and drop it "
"onto the ``Progress`` slot. Under the ``Range`` class in the inspector, "
"change the ``Value`` property to ``50`` to see the gauge fill up."
msgstr ""
"选择Bar节点并在其中添加一个`TextureProgress`。命名为`Gauge 衡量`。在属性面板"
"中展开`Textures 纹理`部分。转到文件系统停靠站，拖放`lifebar_bg.png`纹理贴到"
"`Under 下`槽。对`lifebar_fill.png`图像做同样的操作,并将其放到`Progress`槽。在"
"属性面板的`Range 范围`类下，将`Value 值`属性更改为`50`，以查看量规是否被填"
"满。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:246
msgid "With only five ``Control`` nodes, our first bar is ready to use."
msgstr "只有5个`Control 控制`节点，我们的第一个bar就可以使用了。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:250
msgid ""
"That's it, our life bar is ready. This last part was quick, wasn't it? "
"That's thanks to our robust container setup."
msgstr ""
"就这样，我们的生命条准备好了。最后这一部分很快，不是吗?这要感谢我们强大的容器"
"设置。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:254
#, fuzzy
msgid "Design the bomb and emerald counters"
msgstr "设计炸弹和卢比计数器"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:256
#, fuzzy
msgid ""
"The bomb and emerald counters are like the bar's ``Count`` node. So we'll "
"duplicate it and use it as a template."
msgstr ""
"炸弹和卢比计数器就像条形栏的`Count 计数`节点。我们将复制它并将其用作模板。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:259
msgid ""
"Under the ``Bar`` node, select ``Count`` and press Ctrl D to duplicate it. "
"Drag and drop the new node under the ``Counters`` ``HBoxContainer`` at the "
"bottom of the scene tree. You should see it resize automatically. Don't "
"worry about this for now, we'll fix the size soon."
msgstr ""
"在`Bar`节点下，选择`Count`并按Ctrl D复制它。将新节点拖放到场景树底部的"
"`Counters 计数器` `HBoxContainer`下。您应该会看到它自动调整大小。现在别担心，"
"我们很快就会修好它的。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:264
msgid ""
"Rename the ``Count2`` node to ``Counter``. Unlike the bars, we want the "
"number to be on the left, and an icon to sit on the right. The setup is the "
"same: we need a background (a ``NinePatchRect``), the title, and the number "
"nodes. The ``Title`` node is a ``TextureRect``, so it's what we need to "
"display the icon. In the scene tree, select the ``Title`` node, and rename "
"it to ``Icon``."
msgstr ""
"将 ``Count2`` 节点重命名为 ``Counter`` 。与条形图不同，我们希望数字在左边，图"
"标在右边。设置是相同的:我们需要背景、 ``NinePatchRect`` 、标题和数字节点。 "
"``Title`` 节点是 ``TextureRect`` 节点，所以我们需要它来显示图标。在场景树中，"
"选择 ``Title`` 节点，并将其重命名为 ``Icon`` 。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:273
msgid "Here's how your node tree should look so far"
msgstr "下面是到目前为止您的节点树应该是什么样的"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:275
msgid ""
"With the ``Icon`` node selected, in the inspector, scroll to the top to see "
"the ``Texture`` slot. Head to the FileSystem dock on the left and select the "
"``bombs_icon.png``. Drag and drop it onto the ``Texture`` slot. In the Scene "
"Tab select both the ``Icon`` and the ``Number`` nodes. Click the Layout menu "
"in the toolbar at the top of the viewport and select ``Full Rect``. Both "
"nodes will update to fit the size of the ``Background``."
msgstr ""
"选中`Icon 图标`节点后，在属性面板中，滚动到顶部以查看`Texture 纹理`槽。转到左"
"边的文件系统停靠站，选择`bombs_icon.png`。拖放到`Texture 纹理`槽中。在Scene选"
"项卡中，选择`Icon`和`Number`节点。单击视图顶部工具栏中的布局菜单，并选择"
"`Full Rect`。两个节点都将更新以适应`Background 背景`的大小。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:285
msgid "The nodes anchor to the entire Background, but their position is off"
msgstr "节点锚定到整个背景，但它们的位置是错误的"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:287
msgid ""
"Let's change the ``Number``'s align properties to move it to the left and "
"center of the ``Background``. Select the ``Number`` node, change its "
"``Align`` property to left and the ``VAlign`` property to centre. Then "
"resize its left edge a little bit to add some padding between the left edge "
"of the ``Background`` and the text."
msgstr ""
"让我们改变`Number`的对齐属性，把它移动到``的左边和中间。选择`Number`节点，将"
"其`Align`属性改为`left`，将`VAlign`属性改为`center`。然后稍微调整一下它的左边"
"缘，在`Background`和文本的左边缘之间添加一些填充。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:295
msgid "The Number node aligned to the left and centre"
msgstr "数字节点对齐到左边和中间"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:297
msgid ""
"To overlap the Icon and the background, we need a few tweaks. First, our "
"background is a bit too tall. It's because it's inside a margin container "
"that is controlled by the top-most GUI node. Select the GUI node at the top "
"of the scene tree and downsize it vertically so that it's as thin as "
"possible. You'll see the gauge prevents you from making it too small. A "
"container cannot be smaller than the minimal size of its children. The "
"container's margins also weigh in."
msgstr ""
"为了重叠图标和背景，我们需要做一些调整。首先，我们的背景有点高。这是因为它位"
"于由最顶层GUI节点控制的margin容器中。选择场景树顶部的GUI节点，垂直缩小它，使"
"它尽可能薄。您会看到仪表防止您把它做得太小。容器不能小于其子容器的最小大小。"
"容器的边距也很重要。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:305
msgid ""
"Select the Icon, click the Layout menu, and select ``Full Rect`` to re-"
"center it. We need it to anchor to the ``Background``'s right edge. Open the "
"Layout menu again and select ``Center Right``. Move the icon up so it is "
"centered vertically with the ``Background``."
msgstr ""
"选择图标，单击布局菜单，并选择`Full Rect`重新居中。我们需要它锚定到"
"`Background`的右边缘。再次打开布局菜单，选择`Center Right`。将图标向上移动，"
"使其垂直居中于`Background`。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:313
msgid ""
"The bomb icon anchors to the Background's right edge. Resize the Counter "
"container to see the Icon node stick to its right side"
msgstr ""
"炸弹图标锚定在背景的右边。调整计数器容器的大小，以查看图标节点是否粘贴在其右"
"侧"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:316
msgid ""
"Because we duplicated the ``Counter`` from the bar's ``Count``, the "
"``Number`` node's font is off. Select the ``Number`` node again, head to the "
"``Font`` property, and click it to access the ``DynamicFont`` resource. In "
"the ``Extra Spacing`` section, change the ``Bottom`` value to ``0`` to reset "
"the font's baseline. Our counter now works as expected."
msgstr ""
"因为我们从条形图的`Count`中复制了`Counter`，所以`Number`节点的字体关闭了。再"
"次选择`Number`节点，转到`font`属性，然后单击它访问`DynamicFont`资源。在"
"`Extra Spacing`部分，将`Bottom`值改为`0`以重置字体的基线。我们的柜台现在运作"
"正常。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:323
#, fuzzy
msgid ""
"Let's make the ``Counters`` anchor to the right edge of the viewport. To do "
"so, we need to set the ``Bars`` container take all the available horizontal "
"space it can. Select the ``Bars`` node and scroll down to the ``Size Flags`` "
"category. In the ``Horizontal`` category, check the ``Expand`` value. The "
"``Bars`` node should resize and push the counter to the right side of the "
"screen."
msgstr ""
"让我们将`Counters`锚定到视图的右边缘。要做到这一点，我们需要设置`bar`容器，它"
"可以使用所有可用的水平空间。选择`bar`节点并向下滚动到`Size Flags`类别。在"
"`Horizontal`类别中，检查`Expand`值。`bar`节点应该调整大小并将计数器推到屏幕右"
"侧。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:331
msgid ""
"An expanding container eats all the space it can from its parent, pushing "
"everything else along the way"
msgstr ""
"一个膨胀的容器会吃掉它能从它的父容器那里得到的所有空间，一路推着其他的东西"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:335
msgid "Turn the bar and counter into reusable UI components"
msgstr "将bar和counter转换为可重用的UI组件"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:337
msgid ""
"We have one bar and one counter widget. But we need two of each. We may need "
"to change the bars' design or their functionality later on. It'd be great if "
"we could have a single scene to store a UI element's template, and child "
"scenes to work on variations. Godot lets us do this with Inherited Scenes."
msgstr ""
"我们有一个bar和一个counter widget。但我们每人需要两个。稍后，我们可能需要更改"
"这些条的设计或功能。如果我们能有一个场景来存储UI元素的模板，以及子场景来处理"
"变量，那就太好了。Godot让我们用继承的场景来做这个。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:343
#, fuzzy
msgid ""
"Let's save both the ``Counter`` and the ``Bar`` branches as separate scenes "
"that we'll reduce to create the ``LifeBar``, the ``EnergyBar``, the "
"``BombCounter``, and the ``EmeraldCounter``. Select the ``Bar`` "
"HBoxContainer. Right click on it and click on ``Save Branch as Scene``. Save "
"the scene as ``Bar.tscn``. You should see the node branch turn it to a "
"single ``Bar`` node."
msgstr ""
"让我们将`Counter`和`Bar`两个分支都保存为单独的场景，我们将减少它们，以创建"
"`LifeBar`、`EnergyBar`、`BombCounter`和`smashing - ounter`。选择"
"`Bar`HBoxContainer。右键点击它，点击`Save Branch as Scene 保存分支为场景`。保"
"存场景为`Bar.tscn`。您应该看到节点分支将它转换为一个`Bar`节点。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:352
#, fuzzy
msgid ""
"A scene is a tree of nodes. The topmost node is the tree's **root**, and the "
"children at the bottom of the hierarchy are **leaves**. Any node other than "
"the root along with one or more children is a **branch**. We can encapsulate "
"node branches into separate scenes, or load and merge them from other scenes "
"into the active one. Right click on any node in the Scene dock and select "
"``Save Branch as Scene`` or ``Merge from Scene``."
msgstr ""
"场景是节点树。最上面的节点是树的 **根** ，层次结构底部的子节点是 **叶** 。除"
"根节点之外的任何节点以及一个以上的子节点都是 **分支** 。我们可以将节点分支封"
"装到单独的场景中，或者从其他场景加载并合并到活动场景中。右键点击场景面板中的"
"任何节点，选择`Save Branch as Scene`或`Merge from Scene`。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:360
#, fuzzy
msgid ""
"Then, select the ``Counter`` node and do the same. Right click, ``Save "
"Branch as Scene``, and save it as ``Counter.tscn``. A new edit scene icon "
"appears to the right of the nodes in the scene tree. Click on the one next "
"to ``Bar`` to open the corresponding scene. Resize the ``Bar`` node so that "
"its bounding box fits its content. The way we named and placed the Control "
"nodes, we're ready to inherit this template and create the life bar. It's "
"the same for the ``Counter``."
msgstr ""
"然后，选择`Counter`节点并执行相同操作。右键点击，`Save Branch as Scene`，保存"
"为`Counter.tscn`。一个新的编辑场景图标出现在场景树节点的右侧。点击`Bar`旁边的"
"按钮，打开相应的场景。调整`Bar`节点的大小，使其边界框适合其内容。通过命名和放"
"置控制节点的方式，我们可以继承这个模板并创建生命条。`Counter`也一样。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:370
msgid "With no extra changes, our Bar is ready to use"
msgstr "没有额外的改变，我们的条形栏准备使用"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:373
#, fuzzy
msgid "Use scene inheritance to create the remaining elements"
msgstr "使用场景继承来创建剩余的元素"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:375
msgid ""
"We need two bars that work the same way: they should feature a label on the "
"left, with some value, and a horizontal gauge on the right. The only "
"difference is that one has the HP label and is green, while the other is "
"called EP and is yellow. Godot gives us a powerful tool to create a common "
"base to reuse for all bars in the game: **inherited scenes**."
msgstr ""
"我们需要两根以同样方式工作的棒:它们应该在左边有一个标签，有一些值，在右边有一"
"个水平标尺。唯一的区别是一个有HP标签，是绿色的，而另一个叫EP，是黄色的。Godot"
"为我们提供了一个强大的工具来创建一个公共基础来重用游戏中的所有栏:** 继承场景"
"**。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:383
msgid ""
"Inherited scenes help us keep the GUI scene clean. In the end, we will only "
"have containers and one node for each UI component."
msgstr ""
"继承的场景帮助我们保持GUI场景的干净。最后，每个UI组件只有容器和一个节点。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:386
#, fuzzy
msgid ""
"On an inherited scene, you can change any property of every node in the "
"inspector, aside from its name. If you modify and save the parent scene, all "
"the inherited scenes update to reflect the changes. If you change a value in "
"the inherited scene, it will always override the parent's property. It's "
"useful for UIs, as they often require variations of the same elements. In "
"general, in UI design, buttons, panels etc. share a common base style and "
"interactions. We don't want to copy it over to all variations manually."
msgstr ""
"在继承的场景中，除了属性面板的名称之外，还可以更改属性面板中每个节点的任何属"
"性。如果您修改并保存父场景，所有继承的场景都会更新以反映更改。如果在继承的场"
"景中更改一个值，它总是会覆盖父元素的属性。它对ui很有用，因为它们通常需要相同"
"元素的变体。通常，在UI设计中，按钮、面板等共享一个共同的基本样式和交互。我们"
"不想手工将它复制到所有的变体中。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:395
msgid ""
"A reload icon will appear next to the properties you override. Click it to "
"reset the value to the parent scene's default."
msgstr "重新加载图标将出现在您重写的属性旁边。单击它将值重置为父场景的默认值。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:400
msgid ""
"Think of scene inheritance like the node tree, or the ``extends`` keyword in "
"GDScript. An inherited scene does everything like its parent, but you can "
"override properties, resources and add extra nodes and scripts to extend its "
"functionality."
msgstr ""
"把场景继承想象成节点树，或者GDScript中的`extend`关键字。继承的场景做任何事情"
"都像它的父场景一样，但是您可以覆盖属性、资源并添加额外的节点和脚本来扩展其功"
"能。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:406
msgid "Inherit the Bar Scene to build the LifeBar"
msgstr "继承Bar场景来构建生命条"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:408
msgid ""
"Go to ``Scene -> New Inherited Scene`` to create a new type of ``Bar``. "
"Select the Bar scene and open it. You should see a new [unsaved] tab, that's "
"like your ``Bar``, but with all nodes except the root in grey. Press ``Meta"
"+S`` to save the new inherited scene and name it ``LifeBar``."
msgstr ""
"进入`Scene -> New Inherited Scene`来创建一个新的类型的`Bar`。选择Bar场景并打"
"开它。您应该会看到一个新的(未保存的)选项卡，它类似于您的`Bar`，但是除了根节点"
"以外的所有节点都是灰色的。按`Meta+S`保存新继承的场景并命名为`LifeBar`。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:416
msgid "You can't rename grey nodes. This tells you they have a parent scene"
msgstr "不能重命名灰色节点。这告诉您他们有一个父场景"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:418
msgid ""
"First, rename the root or top level node to ``LifeBar``. We always want the "
"root to describe exactly what this UI component is. The name differentiates "
"this bar from the ``EnergyBar`` we'll create next. The other nodes inside "
"the scene should describe the component's structure with broad terms, so it "
"works with all inherited scenes. Like our ``TextureProgress`` and ``Number`` "
"nodes."
msgstr ""
"首先，将根节点或顶层节点重命名为`LifeBar`。我们总是希望根用户能够准确地描述这"
"个UI组件是什么。这个名称将这个栏与我们接下来要创建的`EnergyBar`区分开来。场景"
"中的其他节点应该用宽泛的术语描述组件的结构，因此它可以处理所有继承的场景。比"
"如我们的`TextureProgress`和`Number`节点。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:427
msgid ""
"If you've ever done web design, it's the same spirit as working with CSS: "
"you create a base class, and add variations with modifier classes. From a "
"base button class, you'll have button-green and button-red variations for "
"the user to accept and refuse prompts. The new class contains the name of "
"the parent element and an extra keyword to explain how it modifies it. When "
"we create an inherited scene and change the name of the top level node, "
"we're doing the same thing."
msgstr ""
"如果您曾经做过web设计，那么它与使用CSS的精神是相同的:创建一个基类，并使用修饰"
"符类添加变体。在基本按钮类中，您将有按钮-绿色和按钮-红色的变体供用户接受和拒"
"绝提示。新类包含父元素的名称和一个额外的关键字来解释如何修改它。当我们创建一"
"个继承的场景并更改顶层节点的名称时，我们正在做同样的事情。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:436
msgid "Design the EnergyBar"
msgstr "设计能量条"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:438
msgid ""
"We already setup the ``LifeBar``'s design with the main ``Bar`` scene. Now "
"we need the ``EnergyBar``."
msgstr "我们已经设置了`LifeBar`的设计与主`Bar`场景。现在我们需要`EnergyBar`。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:441
msgid ""
"Let's create a new inherited scene, and once again select the ``Bar.tscn`` "
"scene and open it. Double-click on the ``Bar`` root node and rename it to "
"``EnergyBar``. Save the new scene as ``EnergyBar.tscn``. We need to replace "
"the HP texture with EP one, and to change the textures on the gauge."
msgstr ""
"让我们创建一个新的继承场景，再次选择`Bar.tscn`并打开它。双击`Bar`根节点，将其"
"重命名为`EnergyBar`。保存新场景为`EnergyBar.tscn`。我们需要用EP 1替换HP的纹"
"理，并且改变标尺上的纹理。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:447
msgid ""
"Head to the FileSystem dock on the left, select the ``Title`` node in the "
"Scene tree and drag and drop the ``label_EP.png`` file onto the texture "
"slot. Select the ``Number`` node and change the ``Text`` property to a "
"different value like ``14``."
msgstr ""
"转到左边的文件系统停靠站，在场景树中选择`Title`节点并拖放`label_EP.png`文件到"
"纹理槽。选择`Number`节点，并将`Text`属性更改为不同的值，如`14`。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:452
msgid ""
"You'll notice the EP texture is smaller than the HP one. We should update "
"the ``Number``'s font size to better fit it. A font is a resource. All the "
"nodes in the entire project that use this resource will be affected by any "
"property we change. You can try to change the size to a huge value like "
"``40`` and switch back to the ``LifeBar`` or the ``Bar`` scenes. You will "
"see the text increased in size."
msgstr ""
"您会注意到EP的纹理比HP的要小。我们应该更新`Number`的字体大小，以更好地适应"
"它。字体是一种资源。使用此资源的整个项目中的所有节点都将受到我们更改的任何属"
"性的影响。您可以试着把大小改成一个巨大的数值，比如`40`，然后切换回`LifeBar`或"
"者`Bar`。您将看到文本的大小增加了。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:461
msgid "If we change the font resource, all the nodes that use it are affected"
msgstr "如果我们改变字体资源，所有使用它的节点都会受到影响"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:464
msgid ""
"To change the font size on this node only, we must create a copy of the font "
"resource. Select the ``Number`` node again and click on the wrench and "
"screwdriver icon on the top right of the inspector. In the drop-down menu, "
"select the ``Make Sub-Resources Unique`` option. Godot will find all the "
"resources this node uses and create unique copies for us."
msgstr ""
"要仅更改此节点上的字体大小，我们必须创建字体资源的副本。再次选择`Number`节"
"点，点击属性面板右上角的扳手和螺丝刀图标。在下拉菜单中，选择`Make Sub-"
"Resources Unique`选项。Godot会找到这个节点使用的所有资源，并为我们创建唯一的"
"副本。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:472
msgid "Use this option to create unique copies of the resources for one node"
msgstr "使用此选项为一个节点创建资源的惟一副本"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:476
msgid ""
"When you duplicate a node from the Scene tree, with ``Meta+D``, it shares "
"its resources with the original node. You need to use ``Make Sub-Resources "
"Unique`` before you can tweak the resources without affecting the source "
"node."
msgstr ""
"当您在场景树中复制一个节点，使用`Meta+D`，它会与原始节点共享它的资源。在调整"
"资源而不影响源节点之前，需要使用`Make subresources Unique`。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:481
msgid ""
"Scroll down to the ``Custom Font`` section and open ``Font``. Lower the "
"``Size`` to a smaller value like ``20`` or ``22``. You may also need to "
"adjust the ``Bottom`` spacing value to align the text's baseline with the EP "
"label on the left."
msgstr ""
"向下滚动到`Custom Font`部分并打开`Font`。把`Size`降低到一个较小的值，如`20`或"
"`22`。您还可能需要调整`Bottom`间距值，以使文本的基线与左侧的EP标签对齐。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:488
msgid "The EP Count widget, with a smaller font than its HP counterpart"
msgstr "EP Count小部件，字体比HP小"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:490
msgid ""
"Now, select the ``TextureProgress`` node. Drag the ``energy_bar_bg.png`` "
"file onto the ``Under`` slot and do the same for ``energy_bar_fill.png`` and "
"drop it onto the ``Progress`` texture slot."
msgstr ""
"现在，选择`TextureProgress`节点。拖动`energy_bar_bg.png`文件到`Under`槽，并对"
"`energy_bar_fill.png`执行相同的操作。然后把它放到`Progress`纹理槽中。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:494
msgid ""
"You can resize the node vertically so that its bounding rectangle fits the "
"gauge. Do the same with the ``Count`` node until its size aligns with that "
"of the bar. Because the minimal size of ``TextureProgress`` is set based on "
"its textures, you won't be able to downsize the ``Count`` node below that. "
"That is also the size the ``Bar`` container will have. You may downscale "
"this one as well."
msgstr ""
"您可以垂直地调整节点的大小，使其边框适合于规范。对`Count`节点执行相同的操作，"
"直到其大小与bar的大小一致。因为`TextureProgress`的最小大小是根据它的纹理设置"
"的，所以您不能将`Count`节点缩小到这个节点以下。这也是`Bar`容器的大小。您也可"
"以缩小这个。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:501
msgid ""
"Last but not least, the ``Background`` container has a minimum size that "
"makes it a bit large. Select it and in the ``Rect`` section, change the "
"``Min Size`` property down to ``80`` pixels. It should resize automatically "
"and the ``Title`` and ``Number`` nodes should reposition as well."
msgstr ""
"最后但并非最不重要的一点是，`Background`容器的最小大小使它有点大。选择它，在"
"`Rect`部分，将`Min Size`属性设置为`80`像素。它应该自动调整大小，`Title`和"
"`Number`节点也应该重新定位。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:509
msgid "The Count looks better now it's a bit smaller"
msgstr "计数看起来好多了，现在小了一点"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:513
msgid ""
"The Count node's size affects the position of the TextureProgress. As we'll "
"align our bars vertically in a moment, we're better off using the Counter's "
"left margin to resize our EP label. This way both the EnergyBar's Count and "
"the LifeBar's Count nodes are one hundred pixels wide, so both gauges will "
"align perfectly."
msgstr ""
"计数节点的大小影响TextureProgress的位置。当我们将我们的条形栏垂直对齐一会儿，"
"我们最好使用计数器的左边缘来调整我们的EP标签。通过这种方式，EnergyBar的计数和"
"LifeBar的计数节点都是100像素宽，因此两种量规都可以完美地对齐。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:520
#, fuzzy
msgid "Prepare the bomb and emerald counters"
msgstr "准备炸弹和卢比计数器"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:522
msgid ""
"Let us now take care of the counters. Go to ``Scene -> New Inherited Scene`` "
"and select the ``Counter.tscn`` as a base. Rename the root node as "
"``BombCounter`` too. Save the new scene as ``BombCounter.tscn``. That's all "
"for this scene."
msgstr ""
"现在让我们来处理柜台。进入`Scene -> New Inherited Scene`，选择`Counter."
"tscn`。作为基础。也将根节点重命名为`BombCounter`。保存新场景为`BombCounter."
"tscn`。这就是这个场景的全部内容。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:529
msgid "The bomb counter is the same as the original Counter scene"
msgstr "炸弹计数器与原计数器场景相同"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:531
#, fuzzy
msgid ""
"Go to ``Scene -> New Inherited Scene`` again and select ``Counter.tscn`` "
"once more. Rename the root node ``EmeraldCounter`` and save the scene as "
"``EmeraldCounter.tscn``. For this one, we mainly need to replace the bomb "
"icon with the emerald icon. In the FileSystem tab, drag the ``emeralds_icon."
"png`` onto the ``Icon`` node's ``Texture`` slot. ``Icon`` already anchors to "
"the right edge of the ``Background`` node so we can change its position and "
"it will scale and reposition with the ``EmeraldCounter`` container. Shift "
"the emerald icon a little bit to the right and down. Use the Arrow Keys on "
"the keyboard to nudge its position. Save, and we're done with all the UI "
"elements."
msgstr ""
"转到`Scene -> New Inherited Scene`，再次选择`Counter.tscn`。将根节点重命名为"
"`ecounter`，并将场景保存为`ecounter .tscn`。对于这个，我们主要需要把炸弹图标"
"换成卢比图标。在文件系统选项卡中，拖动这个`rupees_icon.png`到`Icon``node's` "
"`Texture`槽。`Icon`已经锚定在`Background`节点的右边缘，所以我们可以改变它的位"
"置，它会缩放和重新定位，用`RupeeCounter`。将卢比图标向右向下移动一点。使用键"
"盘上的箭头键来推动它的位置。保存，所有UI元素都完成了。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:544
#, fuzzy
msgid "The emerald counter should look something like this"
msgstr "卢比计数器应该是这样的"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:547
msgid "Add the UI components to the final GUI"
msgstr "将UI组件添加到最终的GUI"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:549
msgid ""
"Time to add all the UI elements to the main GUI scene. Open the ``GUI.tscn`` "
"scene again, and delete the ``Bar`` and ``Counter`` nodes. In the FileSystem "
"dock, find the ``LifeBar.tscn`` and drag and drop it onto the ``Bars`` "
"container in the scene tree. Do the same for the ``EnergyBar``. You should "
"see them align vertically."
msgstr ""
"是时候将所有UI元素添加到主GUI场景中了。再次打开`GUI.tscn`场景，删除`Bar`和"
"`Counter`节点。在文件系统面板中，找到`LifeBar`。拖放到场景树中的`bar`容器中。"
"对`EnergyBar`做同样的操作。您应该看到它们垂直对齐。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:557
msgid "The LifeBar and the EnergyBar align automatically"
msgstr "生命条和能量条自动对齐"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:559
#, fuzzy
msgid ""
"Now, drag and drop the ``BombCounter.tscn`` and ``EmeraldCounter.tscn`` "
"scenes onto the ``Counters`` node. They'll resize automatically."
msgstr ""
"现在，将`BombCounter.tscn`和`RupeeCounter.tscn`场景拖放到`Counters`节点上。它"
"们会自动调整大小。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:564
msgid "The nodes resize to take all the available vertical space"
msgstr "节点调整大小以获取所有可用的垂直空间"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:566
#, fuzzy
msgid ""
"To let the ``EmeraldCounter`` and ``BombCounter`` use the size we defined in "
"``Counter.tscn``, we need to change the ``Size Flags`` on the ``Counters`` "
"container. Select the ``Counters`` node and unfold the ``Size Flags`` "
"section in the Inspector. Uncheck the ``Fill`` tag for the ``Vertical`` "
"property, and check ``Shrink Center`` so the container centers inside the "
"``HBoxContainer``."
msgstr ""
"为了让`RueCeopter`和`BobCuffe`使用我们在`Counter.tscn`中定义的大小，我们需要"
"在`Counters`容器上改变`Size Flags`。选择`Counters`节点并展开属性面板中的"
"`Size Flags`部分。取消`Vertica`属性的`Fill`标记，并检查`Shrink Center`，以便"
"容器在“HBBOX容器”内。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:575
msgid "Now both counters have a decent size"
msgstr "现在，这两个柜台都有一个像样的大小"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:579
msgid ""
"Change the ``Min Size`` property of the ``Counters`` container to control "
"the height of the counters' background."
msgstr "更改`Counters`容器的`Min Size`属性，以控制计数器背景的高度。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:582
#, fuzzy
msgid ""
"We have one small issue left with the EP label on the EnergyBar: the 2 bars "
"should align vertically. Click the icon next to the ``EnergyBar`` node to "
"open its scene. Select the ``Count`` node and scroll down to the ``Custom "
"Constants`` section. Add a ``Margin Left`` of ``20``. In the ``Rect`` "
"section set the node's ``Min Size`` back to 100, the same value as on the "
"LifeBar. The ``Count`` should now have some margin on the left. If you save "
"and go back to the GUI scene, it will be aligned vertically with the "
"``LifeBar``."
msgstr ""
"在EnergyBar的EP标签上还剩下一个小问题:2个条形图应该垂直对齐。点击`EnergyBar`"
"节点旁边的图标来打开场景。选择`Count`节点并向下滚动到`Custom Constant`部分。"
"添加一个`20`的`Margin Left`。在`Rect`部分，将节点的`Min Size`设置为100，与"
"LifeBar相同。`Count`现在应该在左边有一些空白。如果您保存并返回GUI场景，它将与"
"`LifeBar`垂直对齐。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:593
msgid "The 2 bars align perfectly"
msgstr "两个条形图对齐得很好"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:597
#, fuzzy
msgid ""
"We could have set up the ``EnergyBar`` this way a few moments ago. But this "
"shows you that you can go back to any scene anytime, tweak it, and see the "
"changes propagate through the project!"
msgstr ""
"我们可以在几分钟前这样设置EnergyBar。但这向您展示了您可以随时返回到任何场景，"
"调整它，并看到更改通过项目传播!"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:602
msgid "Place the GUI onto the game's mockup"
msgstr "把GUI放到游戏的模型上"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:604
msgid ""
"To wrap up the tutorial we're going to insert the GUI onto the game's mockup "
"scene."
msgstr "为了结束教程，我们将把GUI插入到游戏的模型场景中。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:607
msgid "Head to the FileSystem dock and open ``LevelMockup.tscn``."
msgstr "前往文件系统停靠站，打开`LevelMockup.tscn`。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:609
msgid ""
"Drag-and-drop the ``GUI.tscn`` scene right below the ``bg`` node and above "
"the ``Characters``. The GUI will scale to fit the entire viewport. Head to "
"the Layout menu and select the ``Center Top`` option so it anchors to the "
"top edge of the game window. Then resize the GUI to make it as small as "
"possible vertically. Now you can see how the interface looks in the context "
"of the game."
msgstr ""
"拖放`GUI.tscn`场景在`bg`节点下方，在`Characters`之上。GUI将缩放到适合整个视"
"区。转到布局菜单，选择`Center Top`选项，使其锚定到游戏窗口的顶部边缘。然后调"
"整GUI的大小，使其在垂直方向上尽可能小。现在您可以看到界面在游戏环境中的样子。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:616
#, fuzzy
msgid ""
"Congratulations for getting to the end of this long tutorial. You can find "
"the final project here: :download:`ui_gui_design.zip <files/ui_gui_design."
"zip>`."
msgstr "祝贺您完成了这篇冗长的教程。您可以在`here <#>`__找到最终项目。"

#: ../../docs/getting_started/step_by_step/ui_game_user_interface.rst:625
msgid ""
"**A final note about Responsive Design**. If you resize the GUI, you'll see "
"the nodes move, but the textures and text won't scale. The GUI also has a "
"minimum size, based on the textures inside of it. In games, we don’t need "
"the interface to be as flexible as that of a website. You almost never want "
"to support both landscape and portrait screen orientations. It’s one or the "
"other. In landscape orientation, the most common ratios range from 4:3 to "
"16:9. They are close to one another. That's why it’s enough for the GUI "
"elements to only move horizontally when we change the window size."
msgstr ""
"**关于响应式设计的最后说明**。如果您调整GUI的大小，您将看到节点移动，但是纹理"
"和文本不会缩放。GUI还有一个基于内部纹理的最小大小。在游戏中，我们不需要界面像"
"网站那样灵活。您几乎不希望同时支持横向和纵向屏幕定向。两者必有其一。在景观方"
"向上，最常见的比例在4:3到16:9之间。它们很接近。这就是为什么当我们改变窗口大小"
"时，GUI元素只能水平移动。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:4
msgid "Control the game's UI with code"
msgstr "用代码控制游戏UI"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:7
#: ../../docs/tutorials/2d/particle_systems_2d.rst:7
msgid "Intro"
msgstr "简介"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:9
msgid ""
"In this tutorial, you will connect a character to a life bar and animate the "
"health loss."
msgstr "在本教程中，您将生命条关联到一个角色，并动画化生命值损失。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:14
msgid ""
"Here's what you'll create: the bar and the counter animate when the "
"character takes a hit. They fade when it dies."
msgstr ""
"下面是您将创建的:当角色受到攻击时，工具条和计数器将显示动画。当它消失的时候，"
"它们就会褪色。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:18
msgid "You will learn:"
msgstr "您将学习:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:20
msgid "How to **connect** a character to a GUI with signals"
msgstr "如何用信号将一个角色 **连接** 到GUI"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:21
msgid "How to **control** a GUI with GDscript"
msgstr "如何用GDscript **控制** 一个GUI"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:22
msgid "How to **animate** a life bar with the :ref:`Tween <class_Tween>` node"
msgstr "如何用 :ref:`Tween <class_Tween>` 节点 **动画化** 生命条"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:25
msgid ""
"If you want to learn how to set up the interface instead, check out the step-"
"by-step UI tutorials:"
msgstr "如果您想学习如何设置界面，请查看按部就班的UI教程:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:28
msgid "Create a main menu screen"
msgstr "创建一个主菜单屏幕"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:29
msgid "Create a game user interface"
msgstr "创建一个游戏用户界面"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:32
msgid ""
"When you code a game, you want to build the core gameplay first: the main "
"mechanics, player input, win and loss conditions. The UI comes a bit later. "
"You want to keep all the elements that make up your project separate if "
"possible. Each character should be in its own scene, with its own scripts, "
"and so should the UI elements. This prevents bugs, keeps your project "
"manageable, and allows different team members to work on different parts of "
"the game."
msgstr ""
"当您编写一款游戏时，您首先要构建核心游戏玩法:主要机制，游戏角色输入，胜败条"
"件。UI要晚一些。如果可能的话，您希望将组成项目的所有元素分开。每个角色都应该"
"在自己的场景中，有自己的脚本，UI元素也应该如此。这可以防止bug，保持项目的可管"
"理性，并允许不同的团队成员在游戏的不同部分工作。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:40
msgid ""
"Once the core gameplay and the UI are ready, you'll need to connect them "
"somehow. In our example, we have the Enemy who attacks the Player at "
"constant time intervals. We want the life bar to update when the Player "
"takes damage."
msgstr ""
"一旦核心游戏玩法和UI准备就绪，您就需要以某种方式将它们连接起来。在我们的示例"
"中，我们有敌人以固定的时间间隔攻击游戏角色。当游戏角色受到伤害时，我们希望生"
"命条能够更新。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:45
msgid "To do this, we will use **signals**."
msgstr "为此，我们将使用 **信号** 。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:49
msgid ""
"Signals are Godot's version of the Observer pattern. They allow us to send "
"out some message. Other nodes can connect to the object that **emits** the "
"signal and receive the information. It's a powerful tool we use a lot for "
"User Interface and achievement systems. You don't want to use them "
"everywhere, though. Connecting two nodes adds some coupling between them. "
"When there's a lot of connections, they become hard to manage. For more "
"information, check out the `signals video tutorial <https://youtu.be/"
"l0BkQxF7X3E>`_ on GDquest."
msgstr ""
"信号是Godot观察者模式的版本。他们允许我们发出一些信息。其他节点可以连接到 "
"**emits(发出)** 信号并接收信息的对象。这是一个强大的工具，我们经常使用用户界"
"面和成就系统。但是，您不希望在任何地方都使用它们。连接两个节点增加了它们之间"
"的耦合。当有很多联系时，就很难管理了。有关更多信息，请在GDquest查看“信号视频"
"教程`signals video tutorial <https://youtu.be/l0BkQxF7X3E>`_ 。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:53
msgid "Download and explore the start project"
msgstr "下载并探索启动项目"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:55
msgid ""
"Download the Godot project: :download:`ui_code_life_bar.zip <files/"
"ui_code_life_bar.zip>`. It contains all the assets and scripts you need to "
"get started. Extract the .zip archive to get two folders: `start` and `end`."
msgstr ""
"下载Godot项目: :download:`ui_code_life_bar.zip <files/ui_code_life_bar."
"zip>`。它包含启动所需的所有资源和脚本。提取.zip归档文件以获得两个文件夹: "
"*start* 和 *end* 。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:58
msgid ""
"Load the ``start`` project in Godot. In the ``FileSystem`` dock, double "
"click on LevelMockup.tscn to open it. It's an RPG game's mockup where 2 "
"characters face each other. The pink enemy attacks and damages the green "
"square at regular time intervals, until its death. Feel free to try out the "
"game: the basic combat mechanics already work. But as the character isn't "
"connected to the life bar, the ``GUI`` doesn't do anything."
msgstr ""
"加载Godot中的 ``start`` 项目。在 ``FileSystem`` 面板中双击LevelMockup.tscn打"
"开它。这是一个RPG游戏的模型，两个角色面对面。粉色的敌人定期攻击并破坏绿色的正"
"方形，直到它死亡。请随意尝试游戏:基本的战斗机制已经工作。但由于角色没有连接到"
"生命条，`GUI`什么也做不了。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:68
msgid ""
"This is typical of how you'd code a game: you implement the core gameplay "
"first, handle the player's death, and only then you'll add the interface. "
"That's because the UI listens to what's happening in the game. So it can't "
"work if other systems aren't in place yet. If you design the UI before you "
"prototype and test the gameplay, chances are it won't work well and you'll "
"have to re-create it from scratch."
msgstr ""
"这是编写游戏代码的典型方式:首先实现核心玩法，处理游戏角色死亡，然后才添加界"
"面。这是因为UI会监听游戏中发生的事情。因此，如果其他系统还没有到位，它就无法"
"工作。如果您在原型和测试游戏玩法之前设计UI，很有可能它不能很好地工作，您必须"
"从头重新创建它。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:71
msgid "The scene contains a background sprite, a GUI, and two characters."
msgstr "场景包含一个背景精灵、一个GUI和两个角色。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:75
msgid "The scene tree, with the GUI scene set to display its children"
msgstr "场景树，用GUI场景设置来显示它的子对象"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:77
msgid ""
"The GUI scene encapsulates all of the game's Graphical User Interface. It "
"comes with a barebones script where we get the path to nodes that exist "
"inside the scene:"
msgstr ""
"GUI场景封装了所有的游戏用户界面。它附带了一个基本的脚本，我们可以在其中获得到"
"场景中存在的节点的路径:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:105
msgid ""
"``number_label`` displays a life count as a number. It's a ``Label`` node"
msgstr "``number_label`` 将生命计数显示为数字。它是一个 ``标签`` 节点"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:107
msgid "``bar`` is the life bar itself. It's a ``TextureProgress`` node"
msgstr "``bar`` 是生命条本身。它是一个 ``TextureProgress`` 节点"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:108
msgid ""
"``tween`` is a component-style node that can animate and control any value "
"or method from any other node"
msgstr ""
"``tween`` 是一个组件样式的节点，它可以动画和控制来自任何其他节点的任何值或方"
"法"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:113
msgid ""
"The project uses a simple organisation that works for game jams and tiny "
"games."
msgstr "该项目使用了一个简单的组织，可以用于游戏jams和小型游戏。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:115
msgid ""
"At the root of the project, in the `res://` folder, you will find the "
"`LevelMockup`. That's the main game scene and the one we will work with. All "
"the components that make up the game are in the `scenes/` folder. The "
"`assets/` folder contains the game sprites and the font for the HP counter. "
"In the `scripts/` folder you will find the enemy, the player, and the GUI "
"controller scripts."
msgstr ""
"在项目的根目录 *res://* 文件夹中，您将找到 *LevelMockup* 。这是主要的游戏场"
"景，也是我们要学习的内容。构成游戏的所有组件都在*scene /*文件夹中。*assets/*"
"文件夹包含游戏精灵和HP计数器的字体。在*scripts/*文件夹中，您会发现敌人、游戏"
"角色和GUI控制器脚本。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:117
msgid ""
"Click the edit scene icon to the right of the node in the scene tree to open "
"the scene in the editor. You'll see the LifeBar and EnergyBar are sub-scenes "
"themselves."
msgstr ""
"单击场景树中节点右侧的edit scene图标，在编辑器中打开场景。您会看到LifeBar和"
"EnergyBar本身就是子场景。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:121
msgid "The scene tree, with the Player scene set to display its children"
msgstr "场景树，用游戏角色场景设置来显示它的子节点"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:124
msgid "Set up the Lifebar with the Player's max\\_health"
msgstr "用游戏角色的最大生命值设置生命条"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:126
msgid ""
"We have to tell the GUI somehow what the player's current health is, to "
"update the lifebar's texture, and to display the remaining health in the HP "
"counter in the top left corner of the screen. To do this we send the "
"player's health to the GUI every time they take damage. The GUI will then "
"update the ``Lifebar`` and ``Number`` nodes with this value."
msgstr ""
"我们必须以某种方式告诉GUI游戏角色当前的健康状况，更新生命条的纹理，并在屏幕左"
"上角的HP计数器中显示剩余的健康状况。为了做到这一点，每当游戏角色的生命值受到"
"伤害时，我们就会将他们的生命值发送给GUI。然后GUI将用这个值更新`Lifebar`和"
"`Number`节点。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:132
msgid ""
"We could stop here to display the number, but we need to initialize the "
"bar's ``max_value`` for it to update in the right proportions. The first "
"step is thus to tell the ``GUI`` what the green character's ``max_health`` "
"is."
msgstr ""
"我们可以在这里停止来显示数字，但是我们需要初始化bar的 ``max_value`` ，让它以"
"正确的比例进行更新。因此，第一步是告诉 ``GUI`` 绿色角色的 ``max_health`` 是什"
"么。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:139
msgid ""
"The bar, a `TextureProgress`, has a `max_value` of `100` by default. If you "
"don't need to display the character's health with a number, you don't need "
"to change its `max_value` property. You send a percentage from the `Player` "
"to the `GUI` instead:  `health / max_health * 100`."
msgstr ""
"默认情况下，这个名为`TextureProgress`的工具条的max_value为`100`。如果不需要用"
"数字显示角色的健康状态，则不需要更改其`max_value`属性。从`Player`向`GUI`发送"
"一个百分比，而不是`health / max_health * 100`。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:143
msgid ""
"Click the script icon to the right of the ``GUI`` in the Scene dock to open "
"its script. In the ``_ready`` function, we're going to store the "
"``Player``'s ``max_health`` in a new variable and use it to set the "
"``bar``'s ``max_value``:"
msgstr ""
"点击场景面板中`GUI`右边的脚本图标，打开脚本。在`_ready`函数中，我们将把"
"`Player`'s`max_health`存储在一个新变量中，并使用它设置`bar`'s`max_value`:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:164
msgid ""
"Let's break it down. ``$\"../Characters/Player\"`` is a shorthand that goes "
"one node up in the scene tree, and retrieves the ``Characters/Player`` node "
"from there. It gives us access to the node. The second part of the "
"statement, ``.max_health``, accesses the ``max_health`` on the Player node."
msgstr ""
"让我们把它分解一下。`$\"../Characters/Player\"`是场景树中一个节点的简写，从那"
"里检索`Characters/Player`节点。它允许我们访问节点。陈述的第二部分，`."
"max_health`，访问游戏角色节点上的`max_health`。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:170
msgid ""
"The second line assigns this value to ``bar.max_value``. You could combine "
"the two lines into one, but we'll need to use ``player_max_health`` again "
"later in the tutorial."
msgstr ""
"第二行将该值赋给`bar.max_value`。您可以将这两行合并为一行，但是我们需要在本教"
"程后面再次使用`player_max_health`。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:174
msgid ""
"``Player.gd`` sets the ``health`` to ``max_health`` at the start of the "
"game, so we could work with this. Why do we still use ``max_health``? There "
"are two reasons:"
msgstr ""
"`Player.gd`在游戏开始时设置`health`到`max_health`，所以我们可以使用这个。为什"
"么我们仍然使用`max_health`？有两个原因:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:178
msgid ""
"We don't have the guarantee that ``health`` will always equal "
"``max_health``: a future version of the game may load a level where the "
"player already lost some health."
msgstr ""
"我们不能保证`health`总是等于`max_health`:未来版本的游戏可能会加载一个游戏角色"
"已经失去健康的关卡。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:184
msgid ""
"When you open a scene in the game, Godot creates nodes one by one, following "
"the order in your Scene dock, from top to bottom. `GUI` and `Player` are not "
"part of the same node branch. To make sure they both exist when we access "
"each other, we have to use the `_ready` function. Godot calls `_ready` right "
"after it loaded all nodes, before the game starts. It's the perfect function "
"to set everything up and prepare the game session. Learn more about _ready: :"
"doc:`scripting_continued`"
msgstr ""
"当您在游戏中打开一个场景时，Godot会按照您的场景面板的顺序，从上到下依次创建节"
"点。`GUI`和`Player`不是同一个节点分支的一部分。为了确保当我们访问对方时它们都"
"存在，我们必须使用`_ready`函数。Godot在加载所有节点之后，在游戏开始之前调用"
"`_ready`。这是一个完美的功能来设置和准备游戏会话。了解关于_ready: :doc:"
"`scripting_continued`的更多信息"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:188
msgid "Update health with a signal when the player takes a hit"
msgstr "当游戏角色受到攻击时，用信号更新生命值"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:190
msgid ""
"Our GUI is ready to receive the ``health`` value updates from the "
"``Player``. To achieve this we're going to use **signals**."
msgstr ""
"我们的GUI已经准备好接收来自`Player`的`health`值更新。为了实现这一点，我们将使"
"用 **信号** 。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:195
msgid ""
"There are many useful built-in signals like `enter_tree` and `exit_tree`, "
"that all nodes emit when they are respectively created and destroyed. You "
"can also create your own using the `signal` keyword. On the `Player` node, "
"you'll find two signals we created for you: `died` and `health_changed`."
msgstr ""
"有许多有用的内置信号，如`enter_tree`和`exit_tree`，当它们分别被创建和销毁时，"
"所有节点都会发出这些信号。您也可以使用`signal`关键字创建您自己的。在`Player`"
"节点上，您会发现我们为您创建的两个信号:`died`和`health_changed`。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:197
msgid ""
"Why don't we directly get the ``Player`` node in the ``_process`` function "
"and look at the health value? Accessing nodes this way creates tight "
"coupling between them. If you did it sparingly it may work. As your game "
"grows bigger, you may have many more connections. If you get nodes this way "
"it gets complex quickly. Not only that: you need to listen to the state "
"change constantly in the ``_process`` function. This check happens 60 times "
"a second and you'll likely break the game because of the order in which the "
"code runs."
msgstr ""
"我们为什么不直接在`_process`函数中获取`Player`节点并查看健康值呢?以这种方式访"
"问节点会在节点之间产生紧密耦合。如果您少做一点，它可能会起作用。当您的游戏越"
"来越大，您可能会有更多的连接。如果您用这种方法得到节点，它会很快变得复杂。不"
"仅如此:您需要在`_process`函数中不断地监听状态变化。这种检查每秒进行60次，您可"
"能会因为代码运行的顺序而中断游戏。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:206
msgid ""
"On a given frame you may look at another node's property *before* it was "
"updated: you get a value from the last frame. This leads to obscure bugs "
"that are hard to fix. On the other hand, a signal is emitted right after a "
"change happened. It **guarantees** you're getting a fresh piece of "
"information. And you will update the state of your connected node *right "
"after* the change happened."
msgstr ""
"在给定的框架中，您可以在更新 *前* 查看另一个节点的属性:从最后一个框架中获取"
"值。这会导致难以修复的模糊bug。另一方面，一个信号在发生变化后立即发出。它 **"
"保证** 您得到了一个新的信息。您将在更改 *发生后* 立即更新连接节点的状态。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:215
msgid ""
"The Observer pattern, that signals derive from, still adds a bit of coupling "
"between node branches. But it's generally lighter and more secure than "
"accessing nodes directly to communicate between two separate classes. It can "
"be okay for a parent node to get values from its children. But you'll want "
"to favor signals if you're working with two separate branches. Read Game "
"Programming Patterns for more information on the `Observer pattern <http://"
"gameprogrammingpatterns.com/observer.html>`_. The `full book <http://"
"gameprogrammingpatterns.com/contents.html>`_ is available online for free."
msgstr ""
"从信号派生而来的观察者模式仍然在节点分支之间添加了一些耦合。但是它通常比直接"
"访问节点来在两个单独的类之间通信更轻、更安全。父节点可以从其子节点获取值。但"
"是，如果您使用的是两个独立的分支，那么您会希望使用信号。在`Observer pattern "
"<http://gameprogrammingpatterns.com/observer.html>`_ 阅读游戏编程模式以获得更"
"多信息。`这本书 <http://gameprogrammingpatterns.com/contents.html>`_ 的全文可"
"在网上免费获得。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:219
msgid ""
"With this in mind, let's connect the ``GUI`` to the ``Player``. Click on the "
"``Player`` node in the scene dock to select it. Head down to the Inspector "
"and click on the Node tab. This is the place to connect nodes to listen to "
"the one you selected."
msgstr ""
"考虑到这一点，让我们将`GUI`连接到`Playe`。点击场景面板中的`Player`节点来选择"
"它。转到属性面板，单击Node选项卡。这是连接节点侦听所选节点的地方。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:224
msgid "The first section lists custom signals defined in ``Player.gd``:"
msgstr "第一部分列出了在`Player.gd`中定义的自定义信号:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:226
msgid ""
"``died`` is emitted when the character died. We will use it in a moment to "
"hide the UI."
msgstr "`died`在角色死亡时发出。我们稍后将使用它来隐藏UI。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:228
msgid "``health_changed`` is emitted when the character got hit."
msgstr "`health_changed`在角色被击中时发出。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:232
msgid "We're connecting to the health\\_changed signal"
msgstr "我们连接到health\\_changed信号"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:234
msgid ""
"Select ``health_changed`` and click on the Connect button in the bottom "
"right corner to open the Connect Signal window. On the left side you can "
"pick the node that will listen to this signal. Select the ``GUI`` node. The "
"right side of the screen lets you pack optional values with the signal. We "
"already took care of it in ``Player.gd``. In general I recommend not to add "
"too many arguments using this window as they're less convenient than doing "
"it from the code."
msgstr ""
"选择`health_changed`，然后单击右下角的Connect按钮，打开Connect信号窗口。在左"
"侧，您可以选择监听此信号的节点。选择`GUI`节点。屏幕的右侧允许您将可选值与信号"
"打包。我们已经在`Player.gd`中处理过了。一般来说，我建议不要使用这个窗口添加太"
"多的参数，因为它们比从代码中添加更不方便。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:244
msgid "The Connect Signal window with the GUI node selected"
msgstr "选择GUI节点的连接信号窗口"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:248
msgid ""
"You can optionally connect nodes from the code. However doing it from the "
"editor has two advantages:"
msgstr "您可以选择从代码中连接节点。然而，编辑这样做有两个好处:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:250
msgid "Godot can write new callback functions for you in the connected script"
msgstr "Godot可以在连接的脚本中为您编写新的回调函数"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:251
msgid ""
"An emitter icon appears next to the node that emits the signal in the Scene "
"dock"
msgstr "一个发射器图标出现在场景基座中发出信号的节点旁边"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:253
msgid ""
"At the bottom of the window you will find the path to the node you selected. "
"We're interested in the second row called \"Method in Node\". This is the "
"method on the ``GUI`` node that gets called when the signal is emitted. This "
"method receives the values sent with the signal and lets you process them. "
"If you look to the right, there is a \"Make Function\" radio button that is "
"on by default. Click the connect button at the bottom of the window. Godot "
"creates the method inside the ``GUI`` node. The script editor opens with the "
"cursor inside a new ``_on_Player_health_changed`` function."
msgstr ""
"在窗口的底部，您将找到您选择的节点的路径。我们对第二行`Node中的方法`感兴趣。"
"这是`GUI`节点上在发出信号时调用的方法。此方法接收随信号发送的值，并允许您处理"
"它们。如果您向右看，默认情况下有一个`Make Function`单选按钮。单击窗口底部的"
"connect按钮。Godot在`GUI`节点中创建方法。脚本编辑器在一个新的"
"`_on_Player_health_changed`函数中打开光标。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:265
msgid ""
"When you connect nodes from the editor, Godot generates a method name with "
"the following pattern: ``_on_EmitterName_signal_name``. If you wrote the "
"method already, the \"Make Function\" option will keep it. You may replace "
"the name with anything you'd like."
msgstr ""
"当您从编辑器中连接节点时，Godot会生成一个方法名，其模式是:"
"`_on_EmitterName_signal_name`。如果您已经编写了该方法，`Make Function`选项将"
"保留它。您可以用任何您想要的东西来代替这个名字。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:272
msgid "Godot writes the callback method for you and takes you to it"
msgstr "Godot为您编写回调方法并将您带到它"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:274
#, fuzzy
msgid ""
"Inside the parentheses after the function name, add a ``player_health`` "
"argument. When the player emits the ``health_changed`` signal, it will send "
"its current ``health`` alongside it. Your code should look like:"
msgstr ""
"在函数名后面的参数中，添加一个`player_health`参数。当游戏角色发出"
"`health_changed`信号时，它会将当前的`health`发送到旁边。您的代码应该如下所示:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:292
msgid ""
"The engine does not convert PascalCase to snake_case, for C# examples we'll "
"be using PascalCase for method names & camelCase for method parameters, "
"which follows the official `C# naming conventions. <https://docs.microsoft."
"com/en-us/dotnet/standard/design-guidelines/capitalization-conventions>`_"
msgstr ""
"引擎不会将PascalCase转换成snake_case，对于C#示例，我们将使用PascalCase来表示"
"方法名，而camelCase用于方法参数，这些参数遵循 `官方的C#命名约定。 <https://"
"docs.microsoft.com/en-us/dotnet/standard/design-guidelines/capitalization-"
"conventions>`_"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:299
msgid ""
"In Player.gd, when the Player emits the health\\_changed signal, it also "
"sends its health value"
msgstr ""
"在Player.gd。当游戏角色发出health\\_changed信号时，它也会发送其health值"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:302
msgid ""
"Inside ``_on_Player_health_changed``, let's call a second function called "
"``update_health`` and pass it the ``player_health`` variable."
msgstr ""
"在`_on_Player_health_changed`中，我们调用第二个函数`update_health`，并将"
"`player_health`变量传递给它。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:307
msgid ""
"We could directly update the health value on `LifeBar` and `Number`. There "
"are two reasons to use this method instead:"
msgstr "我们可以直接在`LifeBar`和`Number`上更新健康值。使用这种方法有两个原因:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:309
msgid ""
"The name makes it clear for our future selves and teammates that when the "
"player took damage, we update the health count on the GUI"
msgstr ""
"这个名字清楚地告诉我们未来的自己和队友，当游戏角色受到伤害时，我们会更新GUI的"
"生命值"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:310
msgid "We will reuse this method a bit later"
msgstr "稍后我们会重复使用这个方法"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:312
msgid ""
"Create a new ``update_health`` method below ``_on_Player_health_changed``. "
"It takes a new\\_value as its only argument:"
msgstr ""
"在`_on_Player_health_changed`下面创建一个新的`update_health`方法。它的唯一参"
"数是一个新的\\_value:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:327
msgid "This method needs to:"
msgstr "此方法需要:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:329
msgid ""
"set the ``Number`` node's ``text`` to ``new_value`` converted to a string"
msgstr "将`Number`节点的`text`设置为`new_value`转换为字符串"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:331
msgid "set the ``TextureProgress``'s ``value`` to ``new_value``"
msgstr "将`TextureProgress`的`value`设置为`new_value`"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:350
msgid ""
"``str`` is a built-in function that converts about any value to text. "
"``Number``'s ``text`` property requires a string, so we can't assign it to "
"``new_value`` directly"
msgstr ""
"``str`` 是一个内置函数，可以将任何值转换为文本。 ``Number`` 的 ``text`` 属性"
"需要一个字符串，所以我们不能直接将它分配给 ``new_value``"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:354
msgid ""
"Also call ``update_health`` at the end of the ``_ready`` function to "
"initialize the ``Number`` node's ``text`` with the right value at the start "
"of the game. Press F5 to test the game: the life bar updates with every "
"attack!"
msgstr ""
"还可以在 ``_ready`` 函数末尾调用 ``update_health`` 函数，以在游戏开始时用正确"
"的值初始化 ``Number`` 节点的 ``text`` 。按F5测试游戏:生命条更新与每次攻击!"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:361
msgid ""
"Both the Number node and the TextureProgress update when the Player takes a "
"hit"
msgstr "当游戏角色受到攻击时，数字节点和TextureProgress都会进行更新"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:365
msgid "Animate the loss of life with the Tween node"
msgstr "用渐变节点动画生命的损失"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:367
msgid ""
"Our interface is functional, but it could use some animation. That's a good "
"opportunity to introduce the ``Tween`` node, an essential tool to animate "
"properties. ``Tween`` animates anything you'd like from a start to an end "
"state over a certain duration. For example, it can animate the health on the "
"``TextureProgress`` from its current level to the ``Player``'s new "
"``health`` when the character takes damage."
msgstr ""
"我们的界面是功能性的，但它可以使用一些动画。这是引入`Tween`节点的好机会，这是"
"动画属性的一个基本工具。`Tween`在一定的持续时间内，使您从开始到结束的任何状态"
"都具有动画效果。例如，当角色受到伤害时，它可以将`TextureProgress`上的生命值从"
"当前级别激活到`Player`的新`health`。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:374
msgid ""
"The ``GUI`` scene already contains a ``Tween`` child node stored in the "
"``tween`` variable. Let's now use it. We have to make some changes to "
"``update_health``."
msgstr ""
"`GUI`场景已经包含一个`Tween`子节点存储在`Tween`变量中。现在让我们使用它。我们"
"必须对`update_health`做一些修改。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:378
msgid ""
"We will use the ``Tween`` node's ``interpolate_property`` method. It takes "
"seven arguments:"
msgstr "我们将使用`Tween` `node` `interpolate_property`方法。它需要七个参数:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:381
msgid "A reference to the node who owns the property to animate"
msgstr "对拥有该属性的节点进行动画的引用"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:382
msgid "The property's identifier as a string"
msgstr "属性的标识符作为字符串"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:383
msgid "The starting value"
msgstr "起始值"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:384
msgid "The end value"
msgstr "端值"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:385
msgid "The animation's duration in seconds"
msgstr "动画以秒为单位的持续时间"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:386
msgid "The type of the transition"
msgstr "过渡的类型"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:387
msgid "The easing to use in combination with the equation."
msgstr "与方程结合使用的缓和。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:389
#, fuzzy
msgid ""
"The last two arguments combined correspond to an easing equation. This "
"controls how the value evolves from the start to the end point."
msgstr ""
"最后两个参数组合起来相当于一个`easing equation <#>`__。这控制了值从开始到结束"
"的演化过程。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:393
msgid ""
"Click the script icon next to the ``GUI`` node to open it again. The "
"``Number`` node needs text to update itself, and the ``Bar`` needs a float "
"or an integer. We can use ``interpolate_property`` to animate a number, but "
"not to animate text directly. We're going to use it to animate a new ``GUI`` "
"variable named ``animated_health``."
msgstr ""
"单击`GUI`节点旁边的脚本图标，再次打开它。`Number`节点需要文本来更新自己，"
"`Bar`需要一个浮点数或整数。我们可以使用`interpolate_property 插值属性`来动画"
"一个数字，但不能直接动画文本。我们将使用它来动画一个新的`GUI`变量命名为"
"`animated_health`。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:399
msgid ""
"At the top of the script, define a new variable, name it "
"``animated_health``, and set its value to 0. Navigate back to the "
"``update_health`` method and clear its content. Let's animate the "
"``animated_health`` value. Call the ``Tween`` node's "
"``interpolate_property`` method:"
msgstr ""
"在脚本的顶部，定义一个新变量，将其命名为`animated_health`，并将其值设置为0。"
"导航回`update_health`方法并清除其内容。让我们对`animated_health`值进行动画处"
"理。调用`ween` `node` `interpolate_property`方法:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:421
msgid "Let's break down the call:"
msgstr "让我们把调用分解一下:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:427
msgid ""
"We target ``animated_health`` on ``self``, that is to say the ``GUI`` node. "
"``Tween``'s interpolate\\_property takes the property's name as a string. "
"That's why we write it as ``\"animated_health\"``."
msgstr ""
"我们的目标是`self`上的`animated_health`，也就是说`GUI`节点。`Tween`'s的插值"
"\\_property将属性的名称作为字符串。这就是为什么我们把它写成"
"`animated_health`。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:435
msgid ""
"The starting point is the current value the bar's at. We still have to code "
"this part, but it's going to be ``animated_health``. The end point of the "
"animation is the ``Player``'s ``health`` after the ``health_changed``: "
"that's ``new_value``. And ``0.6`` is the animation's duration in seconds."
msgstr ""
"起点是该条的当前值。我们仍然需要对这部分进行编码，但它将是`animated_health`。"
"动画的结束点是在`health_changed`之后的`Player`的`health`:这是`new_value`。"
"`0.6`是动画的持续时间，以秒为单位。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:445
msgid ""
"The last two arguments are constants from the ``Tween`` class. "
"``TRANS_LINEAR`` means the animation should be linear. ``EASE_IN`` doesn't "
"do anything with a linear transition, but we must provide this last argument "
"or we'll get an error."
msgstr ""
"最后两个参数是`Tween`类中的常量。`TRANS_LINEAR`意味着动画应该是线性的。"
"`EASE_IN`对于线性变换没有任何作用，但我们必须提供最后一个参数，否则会得到一个"
"错误。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:450
msgid ""
"The animation will not play until we activated the ``Tween`` node with "
"``tween.start()``. We only have to do this once if the node is not active. "
"Add this code after the last line:"
msgstr ""
"动画将不会播放，直到我们用`tween.start() `激活`Tween`节点。如果节点不活动，我"
"们只需要这样做一次。在最后一行之后添加以下代码:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:469
msgid ""
"Although we could animate the `health` property on the `Player`, we "
"shouldn't. Characters should lose life instantly when they get hit. It makes "
"it a lot easier to manage their state, like to know when one died. You "
"always want to store animations in a separate data container or node. The "
"`tween` node is perfect for code-controlled animations. For hand-made "
"animations, check out `AnimationPlayer`."
msgstr ""
"虽然我们可以在`Player`上激活`health`属性，但我们不应该。角色一旦被击中就会立"
"即失去生命。这使得管理他们的状态变得容易得多，比如知道他们的死亡时间。您总是"
"希望将动画存储在单独的数据容器或节点中。补间节点非常适合代码控制的动画。对于"
"手工制作的动画，请查看`AnimationPlayer`。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:472
msgid "Assign the animated\\_health to the LifeBar"
msgstr "将动画\\_health分配给LifeBar"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:474
msgid ""
"Now the ``animated_health`` variable animates but we don't update the actual "
"``Bar`` and ``Number`` nodes anymore. Let's fix this."
msgstr ""
"现在`animated_health`变量会启动，但是我们不再更新实际的`Bar`和`Number`节点。"
"让我们解决这个问题。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:477
msgid "So far, the update\\_health method looks like this:"
msgstr "到目前为止，update\\_health方法如下:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:501
msgid ""
"In this specific case, because ``number_label`` takes text, we need to use "
"the ``_process`` method to animate it. Let's now update the ``Number`` and "
"``TextureProgress`` nodes like before, inside of ``_process``:"
msgstr ""
"在这种情况下，因为`number_label`接受文本，我们需要使用`_process`方法来动画"
"它。现在让我们更新`Number`和`TextureProgress`节点像以前一样，在`_process`里"
"面:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:523
msgid ""
"`number_label` and `bar` are variables that store references to the `Number` "
"and `TextureProgress` nodes."
msgstr ""
"`number_label`和`bar`是存储对`Number`和`TextureProgress`节点的引用的变量。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:525
msgid ""
"Play the game to see the bar animate smoothly. But the text displays decimal "
"number and looks like a mess. And considering the style of the game, it'd be "
"nice for the life bar to animate in a choppier fashion."
msgstr ""
"玩这个游戏，可以看到条形图的动画是流畅的。但是文本显示的是十进制数，看起来很"
"乱。考虑到游戏的风格，生命条以一种更加起伏不定的方式进行动画是很好的。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:531
msgid "The animation is smooth, but the number is broken"
msgstr "动画很流畅，但是数字被打破了"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:533
msgid ""
"We can fix both problems by rounding out ``animated_health``. Use a local "
"variable named ``round_value`` to store the rounded ``animated_health``. "
"Then assign it to ``number_label.text`` and ``bar.value``:"
msgstr ""
"我们可以通过舍入`animated_health`来解决这两个问题。使用一个名为`round_value`"
"的局部变量来存储完整的`animated_health`。然后将其赋值给`number_label.text`和"
"`bar.value`:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:555
msgid "Try the game again to see a nice blocky animation."
msgstr "再次尝试游戏，看看一个不错的方块动画。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:559
msgid "By rounding out animated\\_health, we kill two birds with one stone"
msgstr "通过完成animated\\_health，我们达到了一石二鸟的效果"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:563
msgid ""
"Every time the player takes a hit, the ``GUI`` calls "
"``_on_Player_health_changed``, which in turn calls ``update_health``. This "
"updates the animation and the ``number_label`` and ``bar`` follow in "
"``_process``. The animated life bar that shows the health going down "
"gradually is a trick. It makes the GUI feel alive. If the ``Player`` takes 3 "
"damage, it happens in an instant."
msgstr ""
"每当游戏角色受到攻击时， ``GUI`` 就会调用 ``_on_Player_health_changed`` ，然"
"后调用 ``update_health``。这将更新动画和 ``number_label`` 和 ``bar`` 跟随 "
"``_process``。显示健康逐渐下降的动画生命条是一个技巧。它让GUI感觉自己是活着"
"的。如果 ``Player`` 受到3点伤害，就会在瞬间发生。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:571
msgid "Fade the bar when the Player dies"
msgstr "当游戏角色死亡时，淡出条形栏"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:573
msgid ""
"When the green character dies, it plays a death animation and fades out. At "
"this point, we shouldn't show the interface anymore. Let's fade the bar as "
"well when the character died. We will reuse the same ``Tween`` node as it "
"manages multiple animations in parallel for us."
msgstr ""
"当绿色角色死亡时，它会播放死亡动画并淡出。此时，我们不应该再显示界面。当角色"
"死亡时，让我们也淡出栏。我们将重用相同的`Tween`节点，因为它为我们同时管理多个"
"动画。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:578
msgid ""
"First, the ``GUI`` needs to connect to the ``Player``'s ``died`` signal to "
"know when it died. Press :kbd:`F1` to jump back to the 2D Workspace. Select "
"the ``Player`` node in the Scene dock and click on the Node tab next to the "
"Inspector."
msgstr ""
"首先，``GU`` 需要连接到 ``Player`` 的 ``died`` 信号，以知道它何时死亡。按 :"
"kbd:`F1` 跳转回2D工作区。在场景面板中选择 ``Player`` 节点，然后单击属性面板旁"
"边的节点选项卡。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:583
msgid "Find the ``died`` signal, select it, and click the Connect button."
msgstr "找到 ``died`` 信号，选择它，然后点击连接按钮。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:587
msgid "The signal should already have the Enemy connected to it"
msgstr "这个信号应该已经连上了敌人"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:589
msgid ""
"In the Connecting Signal window, connect to the ``GUI`` node again. The Path "
"to Node should be ``../../GUI`` and the Method in Node should show "
"``_on_Player_died``. Leave the Make Function option on and click Connect at "
"the bottom of the window. This will take you to the ``GUI.gd`` file in the "
"Script Workspace."
msgstr ""
"在连接信号窗口中，再次连接到`GUI`节点。节点的路径应该是`../../GUI`并且节点中"
"的方法应该显示`_on_Player_died`。保留Make函数选项并单击窗口底部的Connect。这"
"将把您带到脚本工作空间中的`GUI.gd`文件中。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:597
msgid "You should get these values in the Connecting Signal window"
msgstr "您应该在连接信号窗口中获得这些值"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:601
msgid ""
"You should see a pattern by now: every time the GUI needs a new piece of "
"information, we emit a new signal. Use them wisely: the more connections you "
"add, the harder they are to track."
msgstr ""
"您现在应该看到一个模式:每当GUI需要一条新的信息时，我们都会发出一个新的信号。"
"明智地使用它们:添加的连接越多，跟踪它们就越困难。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:603
msgid ""
"To animate a fade on a UI element, we have to use its ``modulate`` property. "
"``modulate`` is a ``Color`` that multiplies the colors of our textures."
msgstr ""
"要使UI元素的淡入动画，我们必须使用它的 ``modulate`` 属性。``modulate`` 是一"
"种 ``Color``，它可以使我们的纹理颜色倍增。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:609
msgid ""
"`modulate` comes from the `CanvasItem` class, All 2D and UI nodes inherit "
"from it. It lets you toggle the visibility of the node, assign a shader to "
"it, and modify it using a color with `modulate`."
msgstr ""
"``modulate`` 来自 ``CanvasItem`` 类，所有2D和UI节点都继承自它。它允许您切换节"
"点的可见性，给它分配一个着色器，然后用一个带有``modulate`` 的颜色来修改它。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:611
msgid ""
"``modulate`` takes a ``Color`` value with 4 channels: red, green, blue and "
"alpha. If we darken any of the first three channels it darkens the "
"interface. If we lower the alpha channel, our interface fades out."
msgstr ""
"`modulate`具有`Color`值，有4个通道:红色、绿色、蓝色和alpha。如果我们使前三个"
"通道中的任何一个都变暗，它就会使界面变暗。如果我们降低alpha通道，我们的界面就"
"会消失。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:615
msgid ""
"We're going to tween between two color values: from a white with an alpha of "
"``1``, that is to say at full opacity, to a pure white with an alpha value "
"of ``0``, completely transparent. Let's add two variables at the top of the "
"``_on_Player_died`` method and name them ``start_color`` and ``end_color``. "
"Use the ``Color()`` constructor to build two ``Color`` values."
msgstr ""
"我们将在两个颜色值之间进行渐变:从alpha值为`1`的白色，也就是说完全不透明，到"
"alpha值为`0`的纯白色，完全透明。让我们在`_on_player_die`方法的顶部添加两个变"
"量，并将它们命名为`start_color`和`end_color`。使用`Color()`构造函数构建两个"
"`Color`值。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:637
msgid ""
"``Color(1.0, 1.0, 1.0)`` corresponds to white. The fourth argument, "
"respectively ``1.0`` and ``0.0`` in ``start_color`` and ``end_color``, is "
"the alpha channel."
msgstr ""
"`Color(1.0, 1.0, 1.0)`对应于白色。第四个参数，分别是`start_color`和"
"`end_color`中的`1.0`和`0.0`，是alpha通道。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:641
msgid ""
"We then have to call the ``interpolate_property`` method of the ``Tween`` "
"node again:"
msgstr "然后我们必须再次调用`Tween`节点的`interpolate_property`方法:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:654
msgid ""
"This time, we change the ``modulate`` property and have it animate from "
"``start_color`` to the ``end_color``. The duration is of one second, with a "
"linear transition. Here again, because the transition is linear, the easing "
"does not matter. Here's the complete ``_on_Player_died`` method:"
msgstr ""
"这一次，我们改变了`modulate`属性，并将其从`start_color`动画为`end_color`。持"
"续时间为1秒，线性过渡。再一次，因为过渡是线性的，宽松并不重要。下面是完整的"
"`_on_Player_died`方法:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:679
msgid "And that is it. You may now play the game to see the final result!"
msgstr "就是这样。您现在可以玩游戏，看看最后的结果!"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:683
msgid "The final result. Congratulations for getting there!"
msgstr "最终结果。恭喜您做到了!"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:687
msgid ""
"Using the exact same techniques, you can change the color of the bar when "
"the Player gets poisoned, turn the bar red when its health drops low, shake "
"the UI when they take a critical hit... the principle is the same: emit a "
"signal to forward the information from the `Player` to the `GUI` and let the "
"`GUI` process it."
msgstr ""
"使用完全相同的技术，当游戏角色中毒时，您可以改变工具条的颜色，当生命值降低时"
"将工具条变成红色，当他们受到致命一击时摇动UI……原理是一样的:发射信号将信息从"
"`Player`转发到`GUI`，然后让`GUI`处理它。"

#: ../../docs/getting_started/step_by_step/splash_screen.rst:4
msgid "Splash screen"
msgstr "闪屏"

#: ../../docs/getting_started/step_by_step/splash_screen.rst:7
msgid "Tutorial"
msgstr "教程"

#: ../../docs/getting_started/step_by_step/splash_screen.rst:9
msgid ""
"This is a simple tutorial to establish the basic idea of how the GUI "
"subsystem works. The goal is to create a simple, static splash screen."
msgstr ""
"这是一个简单的教程，用来建立GUI子系统如何工作的基本概念。目标是创建一个简单的"
"静态启动屏幕。"

#: ../../docs/getting_started/step_by_step/splash_screen.rst:15
msgid ""
"Following is a file with the assets that will be used. The extracted files "
"can be placed directly in your project folder and Godot will import them "
"automatically."
msgstr ""
"下面是一个包含将要使用的资源的文件。提取的文件可以直接放在项目文件夹中，Godot"
"会自动导入它们。"

#: ../../docs/getting_started/step_by_step/splash_screen.rst:18
msgid ":download:`robisplash_assets.zip <files/robisplash_assets.zip>`."
msgstr ":download:`robisplash_assets.zip <files/robisplash_assets.zip>`。"

#: ../../docs/getting_started/step_by_step/splash_screen.rst:21
#: ../../docs/tutorials/3d/reflection_probes.rst:21
#: ../../docs/tutorials/3d/gi_probes.rst:32
#: ../../docs/tutorials/3d/baked_lightmaps.rst:40
#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:16
msgid "Setting up"
msgstr "设置"

#: ../../docs/getting_started/step_by_step/splash_screen.rst:23
msgid ""
"Set the display resolution to 800x450 in Project Settings, and set up a new "
"scene like this:"
msgstr "在项目设置中设置显示分辨率为800x450，新建场景如下:"

#: ../../docs/getting_started/step_by_step/splash_screen.rst:27
msgid ""
"The nodes \"background\" and \"logo\" are of :ref:`TextureRect "
"<class_TextureRect>` type. To display an image, drag the corresponding asset "
"to the texture property."
msgstr ""
"节点 `background` 和 `logo` 的类型为 :ref:`TextureRect <class_TextureRect>` "
"类型。若要显示图像，请将对应的资源拖动到纹理属性。"

#: ../../docs/getting_started/step_by_step/splash_screen.rst:32
msgid ""
"The node \"start\" is a :ref:`TextureButton <class_TextureButton>`. It takes "
"several images for different states, but only the normal and pressed will be "
"supplied in this example:"
msgstr ""
"节点`start`是 :ref:`TextureButton <class_TextureButton>` 。它为不同的状态拍了"
"几张照片，但是在这个示例中只提供了正常的和按下的图像:"

#: ../../docs/getting_started/step_by_step/splash_screen.rst:38
msgid "Finally, the node \"copyright\" is a :ref:`Label <class_Label>`."
msgstr "最后，节点 `copyright` 是一个 :ref:`Label <class_Label>`。"

#: ../../docs/getting_started/step_by_step/splash_screen.rst:40
msgid "Your final scene should look something like this."
msgstr "您最后的场景应该是这样的。"

#: ../../docs/getting_started/step_by_step/splash_screen.rst:44
msgid ""
"Go ahead and run the project.  If you're satisfied with the results, "
"continue to the next tutorial."
msgstr "继续运行这个项目。如果您对结果满意，请继续学习下一个教程。"

#: ../../docs/getting_started/step_by_step/animations.rst:4
msgid "Animations"
msgstr "动画"

#: ../../docs/getting_started/step_by_step/animations.rst:9
msgid "Godot's animation system is extremely powerful and flexible."
msgstr "Godot的动画系统非常强大和灵活。"

#: ../../docs/getting_started/step_by_step/animations.rst:11
msgid ""
"To begin, let's use the scene from the previous tutorial (:ref:"
"`doc_splash_screen`). The goal is to add a \"fade-in\" animation to the "
"splash image. Here's a copy just in case: :download:`robisplash.zip <files/"
"robisplash.zip>`."
msgstr ""
"首先，让我们使用前面教程中的场景( :ref:`doc_splash_screen` )。目标是添加一个 "
"`淡入` 动画到飞溅图像。这里有一个副本以防万一: :download:`robisplash.zip "
"<files/robisplash.zip>`。"

#: ../../docs/getting_started/step_by_step/animations.rst:16
msgid "Add an animation player"
msgstr "添加一个动画播放器"

#: ../../docs/getting_started/step_by_step/animations.rst:18
msgid ""
"First of all, add an :ref:`AnimationPlayer <class_AnimationPlayer>` node to "
"the scene as a child of \"background\" (the root node):"
msgstr ""
"首先，将一个: :ref:`AnimationPlayer <class_AnimationPlayer>` 节点作为 "
"`background` (根节点)的子节点添加到场景中:"

#: ../../docs/getting_started/step_by_step/animations.rst:23
msgid ""
"When a node of this type is selected, the animation editor panel will appear:"
msgstr "当选择这种类型的节点时，动画编辑器面板会出现:"

#: ../../docs/getting_started/step_by_step/animations.rst:28
msgid "The animation editor panel stays visible until manually hidden."
msgstr "动画编辑器面板保持可见，直到手动隐藏。"

#: ../../docs/getting_started/step_by_step/animations.rst:31
msgid "Creating the animation"
msgstr "创建动画"

#: ../../docs/getting_started/step_by_step/animations.rst:33
#, fuzzy
msgid ""
"It's time to create a new animation! Press the Animation button then select "
"new from the menu. Name the animation \"intro\" when the dialog appears."
msgstr ""
"是时候创建一个新的动画了!当对话框出现时，按下新的动画按钮并将动画命名为"
"`intro`。"

#: ../../docs/getting_started/step_by_step/animations.rst:40
msgid ""
"Now that we have an animation, the property editor enters \"animation editing"
"\" mode. In this mode, a key icon appears next to every property of the "
"property editor. In Godot, any property of an object can be animated:"
msgstr ""
"现在我们有一个动画，属性面板进入`动画编辑` 模式。在这种模式下，属性面板的每个"
"属性旁边都会出现一个键图标。在Godot中，对象的任何属性都可以被动画化:"

#: ../../docs/getting_started/step_by_step/animations.rst:48
msgid "Editing the animation"
msgstr "编辑动画"

#: ../../docs/getting_started/step_by_step/animations.rst:50
msgid "The logo will appear from the top of the screen."
msgstr "标志将出现在屏幕的顶部。"

#: ../../docs/getting_started/step_by_step/animations.rst:52
msgid ""
"With the animation editor panel open, select the \"logo\" node and set the "
"\"Rect / Position\" property to ``(118, -400)`` and press the key button "
"next to the property:"
msgstr ""
"打开动画编辑器面板，选择`logo`节点，将`Rect / Position`属性设置为"
"`(118，-400)`，按下属性旁边的按键:"

#: ../../docs/getting_started/step_by_step/animations.rst:58
msgid "When the dialog appears, confirm that you are creating a new track."
msgstr "当对话框出现时，确认您正在创建一个新轨道。"

#: ../../docs/getting_started/step_by_step/animations.rst:60
msgid "The keyframe will be added in the animation player editor:"
msgstr "关键帧将添加到动画播放器编辑器:"

#: ../../docs/getting_started/step_by_step/animations.rst:64
msgid "Move the editor cursor to the end by clicking here:"
msgstr "点击这里，将编辑器光标移到末尾:"

#: ../../docs/getting_started/step_by_step/animations.rst:68
msgid ""
"Change the logo position to ``(118, 0)`` and add a keyframe again. With two "
"keyframes, the animation happens."
msgstr ""
"将logo的位置改为·(118,0)·，并再次添加一个关键帧。有了两个关键帧，动画就发生"
"了。"

#: ../../docs/getting_started/step_by_step/animations.rst:73
msgid ""
"Pressing \"Play selected animation from start. (Shift-D)\" on the animation "
"panel will make the logo descend."
msgstr "按下“从开始播放播放选定动画。(SHIFT-D)“动画面板将使标志下降。"

#: ../../docs/getting_started/step_by_step/animations.rst:78
msgid ""
"Click the \"Autoplay on Load\" button to set the animation to start "
"automatically when the scene starts."
msgstr "点击“Autoplay on Load 自动加载”按钮，设置动画在场景开始时自动启动。"

#: ../../docs/getting_started/step_by_step/animations.rst:83
msgid ""
"And finally, when running the scene, the animation should look like this:"
msgstr "最后，当运行场景时，动画应该是这样的:"

#: ../../docs/getting_started/step_by_step/resources.rst:4
#: ../../docs/tutorials/threads/thread_safe_apis.rst:60
#: ../../docs/development/cpp/creating_android_modules.rst:204
#: ../../docs/development/file_formats/tscn.rst:249
#: ../../docs/community/tutorials.rst:24
msgid "Resources"
msgstr "资源"

#: ../../docs/getting_started/step_by_step/resources.rst:7
msgid "Nodes and resources"
msgstr "节点和资源"

#: ../../docs/getting_started/step_by_step/resources.rst:9
msgid ""
"Up to this tutorial, we focused on the :ref:`Node <class_Node>` class in "
"Godot as that's the one you use to code behavior and most of the engine's "
"features rely on it. There is another datatype that is just as important: :"
"ref:`Resource <class_Resource>`."
msgstr ""
"在本教程之前, 我们重点介绍了Godot中的 :ref:`Node <class_Node>` 类: 因为它是您"
"用来编写行为代码的类, 并且引擎的大多数功能都依赖于它们。还有另一种数据类型同"
"样重要 :ref:`Resource <class_Resource>`。"

#: ../../docs/getting_started/step_by_step/resources.rst:15
msgid ""
"*Nodes* give you functionality: they draw sprites, 3D models, simulate "
"physics, arrange user interfaces, etc. **Resources** are **data "
"containers**. They don't do anything on their own: instead, nodes use the "
"data contained in resources."
msgstr ""
"*节点*给您提供了功能:它们绘制精灵，3D模型，模拟物理，安排用户界面等。 *资源* "
"是*数据容器*。它们不会自己作任何事情，而节点会使用资源包含的数据。"

#: ../../docs/getting_started/step_by_step/resources.rst:19
msgid ""
"Anything Godot saves or loads from disk is a resource. Be it a scene (a ."
"tscn or an .scn file), an image, a script... Here are some ``Resource`` "
"examples: :ref:`Texture <class_Texture>`, :ref:`Script <class_Script>`, :ref:"
"`Mesh <class_Mesh>`, :ref:`Animation <class_Animation>`, :ref:`AudioStream "
"<class_AudioStream>`, :ref:`Font <class_Font>`, :ref:`Translation "
"<class_Translation>`."
msgstr ""
"Godot从磁盘保存或加载的任何内容都是一种资源。无论它是场景 (.tscn 或 .scn 文"
"件)、图像、脚本...下面是一些 ``资源`` 示例: :ref:`Texture <class_Texture>`, :"
"ref:`Script <class_Script>`, :ref:`Mesh <class_Mesh>`, :ref:`Animation "
"<class_Animation>`, :ref:`AudioStream <class_AudioStream>`, :ref:`Font "
"<class_Font>`, :ref:`Translation <class_Translation>`。"

#: ../../docs/getting_started/step_by_step/resources.rst:26
msgid ""
"When the engine loads a resource from disk, **it only loads it once**. If a "
"copy of that resource is already in memory, trying to load the resource "
"again will return the same copy every time. As resources only contain data, "
"there is no need to duplicate them."
msgstr ""
"当引擎从磁盘加载资源时, **它只加载一次**。如果该资源的副本已在内存中, 则尝试"
"再次加载该资源将每次返回相同的副本。由于资源只包含数据, 因此无需复制它们。"

#: ../../docs/getting_started/step_by_step/resources.rst:31
msgid ""
"Every object, be it a Node or a Resource, can export properties. There are "
"many types of Properties, like String, integer, Vector2, etc., and any of "
"these types can become a resource. This means that both nodes and resources "
"can contain resources as properties:"
msgstr ""
"每个对象 (无论是节点还是资源) 都可以导出属性。有许多类型的属性, 如 string、整"
"数、vector2等, 这些类型中的任何一种都可以成为资源。这意味着节点和资源都可以包"
"含作为属性的资源:"

#: ../../docs/getting_started/step_by_step/resources.rst:39
msgid "External vs built-in"
msgstr "外部与内置"

#: ../../docs/getting_started/step_by_step/resources.rst:41
msgid "There are two ways to save resources. They can be:"
msgstr "有两种方法可以保存资源。它们可以是:"

#: ../../docs/getting_started/step_by_step/resources.rst:43
msgid "**External** to a scene, saved on the disk as individual files."
msgstr "场景的 **外部** , 作为单个文件保存在磁盘上。"

#: ../../docs/getting_started/step_by_step/resources.rst:44
msgid ""
"**Built-in**, saved inside the \\*.tscn or the \\*.scn file they're attached "
"to."
msgstr "**内置**, 保存在他们所附加的\\*.tscn或\\*.scn文件中。"

#: ../../docs/getting_started/step_by_step/resources.rst:46
msgid ""
"To be more specific, here's a :ref:`Texture <class_Texture>` in a :ref:"
"`Sprite <class_Sprite>` node:"
msgstr ""
"更具体地说, 这里有一个 :ref:`精灵 <class_Sprite>` 节点中的 :ref:`纹理 "
"<class_Texture>` :"

#: ../../docs/getting_started/step_by_step/resources.rst:51
msgid ""
"Clicking the resource preview allows us to view and edit the resource's "
"properties."
msgstr "单击资源预览可以查看和编辑资源属性。"

#: ../../docs/getting_started/step_by_step/resources.rst:55
msgid ""
"The path property tells us where the resource comes from. In this case, it "
"comes from a PNG image called ``robi.png``. When the resource comes from a "
"file like this, it is an external resource. If you erase the path or this "
"path is empty, it becomes a built-in resource."
msgstr ""
"Path属性告诉我们资源来自何处。在这里，它来自一个叫 ``robi.png`` 的PNG图像。当"
"资源来自这样的文件时，它属于外部资源。如果您去掉这个路径或此路径为空，则它将"
"成为内置资源。"

#: ../../docs/getting_started/step_by_step/resources.rst:60
msgid ""
"The switch between built-in and external resources happens when you save the "
"scene. In the example above, if you erase the path \\`\"res://robi.png\"\\` "
"and save, Godot will save the image inside the .tscn scene file."
msgstr ""
"内置和外部资源之间的切换发生在保存场景时。在上面的示例中，如果去掉路径\\`"
"\"res://robi.png\"\\`并且保存，Godot将把图片保存在.tscn场景文件中。"

#: ../../docs/getting_started/step_by_step/resources.rst:66
msgid ""
"Even if you save a built-in resource, when you instance a scene multiple "
"times, the engine will only load one copy of it."
msgstr ""
"即使您把某个资源保存成内置资源，当您用这个场景创建多个实例时，引擎只会将资源"
"加载一次。"

#: ../../docs/getting_started/step_by_step/resources.rst:70
msgid "Loading resources from code"
msgstr "从代码中加载资源"

#: ../../docs/getting_started/step_by_step/resources.rst:72
msgid ""
"There are two ways to load resources from code. First, you can use the "
"``load()`` function anytime:"
msgstr ""
"您可以用两种方式在代码中加载资源。首先，您可以随时使用 ``load()`` 函数:"

#: ../../docs/getting_started/step_by_step/resources.rst:90
msgid ""
"You can also ``preload`` resources. Unlike ``load``, this function will read "
"the file from disk and load it at compile-time. As a result, you cannot call "
"preload with a variable path: you need to use a constant string."
msgstr ""
"您也可以预加载资源。与 ``load`` 不同， ``preload`` 会从硬盘中读取文件，并在编"
"译的时候加载它。因此调用 ``preload`` 时您不能用变量当做文件路径，您只能用固定"
"的字符串。"

#: ../../docs/getting_started/step_by_step/resources.rst:106
msgid "Loading scenes"
msgstr "加载场景"

#: ../../docs/getting_started/step_by_step/resources.rst:108
msgid ""
"Scenes are also resources, but there is a catch. Scenes saved to disk are "
"resources of type :ref:`PackedScene <class_PackedScene>`. The scene is "
"packed inside a resource."
msgstr ""
"场景也是资源, 但也有一个陷阱。保存到磁盘的场景是 :ref:`打包场景 "
"<class_PackedScene>` 类型的资源。场景被打包在资源内部。"

#: ../../docs/getting_started/step_by_step/resources.rst:112
msgid ""
"To get an instance of the scene, you have to use the :ref:`PackedScene."
"instance() <class_PackedScene_method_instance>` method."
msgstr ""
"要获取场景的实例，您必须使用 :ref:`PackedScene.instance() "
"<class_PackedScene_method_instance>` 方法。"

#: ../../docs/getting_started/step_by_step/resources.rst:133
msgid ""
"This method creates the nodes in the scene's hierarchy, configures them, and "
"returns the root node of the scene. You can then add it as a child of any "
"other node."
msgstr ""
"此方法在场景层次结构中创建节点, 对其进行配置, 并返回场景的根节点。然后, 您可"
"以将其添加为任何其他节点的子节点。"

#: ../../docs/getting_started/step_by_step/resources.rst:137
#, fuzzy
msgid ""
"The approach has several advantages. As the :ref:`PackedScene.instance() "
"<class_PackedScene_method_instance>` function is pretty fast, you can create "
"new enemies, bullets, effects, etc. without having to load them again from "
"disk each time. Remember that, as always, images, meshes, etc. are all "
"shared between the scene instances."
msgstr ""
"这种方法有几个优点。由于 :ref:`PackedScene.instance() "
"<class_PackedScene_method_instance>` 函数速度相当快, 您可以创建新的敌人、子"
"弹、效果等, 而无需每次都从磁盘再次加载它们。请记住, 像往常一样, 图像、网格等"
"都是在场景实例之间共享的。"

#: ../../docs/getting_started/step_by_step/resources.rst:144
msgid "Freeing resources"
msgstr "释放资源"

#: ../../docs/getting_started/step_by_step/resources.rst:146
msgid ""
"When a ``Resource`` is no longer in use, it will automatically free itself. "
"Since, in most cases, Resources are contained in Nodes, when you free a "
"node, the engine frees all the resources it owns as well if no other node "
"uses them."
msgstr ""
"当 ``资源`` 不再使用时, 它将自动释放自己。因为, 在大多数情况下, 资源包含在节"
"点中, 当您释放节点时, 如果没有其他节点使用它所拥有的所有资源, 引擎也会释放它"
"们。"

#: ../../docs/getting_started/step_by_step/resources.rst:151
msgid "Creating your own resources"
msgstr "创建自己的资源"

#: ../../docs/getting_started/step_by_step/resources.rst:153
msgid ""
"Like any Object in Godot, users can also script Resources. Resource scripts "
"inherit the ability to freely translate between object properties and "
"serialized text or binary data (/*.tres, /*.res). They also inherit the "
"reference-counting memory management from the Reference type."
msgstr ""
"与 godot 中的任何对象一样, 用户也可以编写参考资料脚本。资源脚本继承了在对象属"
"性和序列化文本或二进制数据(/*.tres, /*.res)之间自由转换的能力。它们还继承引用"
"类型的引用计数内存管理。"

#: ../../docs/getting_started/step_by_step/resources.rst:158
msgid ""
"This comes with many distinct advantages over alternative data structures, "
"such as JSON, CSV, or custom TXT files. Users can only import these assets "
"as a :ref:`Dictionary <class_Dictionary>` (JSON) or as a :ref:`File "
"<class_File>` to parse. What sets Resources apart is their inheritance of :"
"ref:`Object <class_Object>`, :ref:`Reference <class_Reference>`, and :ref:"
"`Resource <class_Resource>` features:"
msgstr ""
"与其他数据结构 (如 json、csv 或自定义 txt 文件) 相比, 这具有许多明显的优势。"
"用户只能将这些资源导入为 :ref:`字典 <class_Dictionary>` (JSON)或要分析的 :"
"ref:`文件 <class_File>` 。将资源区分开来的是它们对 :ref:`对象 "
"<class_Object>` 、 :ref:`引用 <class_Reference>` 和 :ref:`资源 "
"<class_Resource>` 功能的继承:"

#: ../../docs/getting_started/step_by_step/resources.rst:165
msgid ""
"They can define constants, so constants from other data fields or objects "
"are not needed."
msgstr "它们可以定义常量, 因此不需要其他数据字段或对象中的常量。"

#: ../../docs/getting_started/step_by_step/resources.rst:167
msgid ""
"They can define methods, including setter/getter methods for properties. "
"This allows for abstraction and encapsulation of the underlying data. If the "
"Resource script's structure needs to change, the game using the Resource "
"need not also change."
msgstr ""
"它们可以定义方法, 包括属性的 setter getter 方法。这允许对基础数据进行抽象和封"
"装。如果资源脚本结构需要更改, 则使用 \"资源\" 的游戏也不需要更改。"

#: ../../docs/getting_started/step_by_step/resources.rst:169
msgid ""
"They can define signals, so Resources can trigger responses to changes in "
"the data they manage."
msgstr "它们可以定义信号, 因此资源可以触发对其管理的数据更改的响应。"

#: ../../docs/getting_started/step_by_step/resources.rst:171
msgid ""
"They have defined properties, so users know 100% that their data will exist."
msgstr "他们定义了属性，所以用户100%知道他们的数据将存在。"

#: ../../docs/getting_started/step_by_step/resources.rst:173
msgid ""
"Resource auto-serialization and deserialization is a built-in Godot Engine "
"feature. Users do not need to implement custom logic to import/export a "
"resource file's data."
msgstr ""
"资源自动序列化和反序列化是一个内置的 godot 引擎功能。用户不需要实现自定义逻辑"
"来导入/导出资源文件数据。"

#: ../../docs/getting_started/step_by_step/resources.rst:175
msgid ""
"Resources can even serialize sub-Resources recursively, meaning users can "
"design even more sophisticated data structures."
msgstr "资源甚至可以递归序列化子资源, 这意味着用户可以设计更复杂的数据结构。"

#: ../../docs/getting_started/step_by_step/resources.rst:177
msgid ""
"Users can save Resources as version-control-friendly text files (\\*.tres). "
"Upon exporting a game, Godot serializes resource files as binary files (\\*."
"res) for increased speed and compression."
msgstr ""
"用户可以将资源另存为版本控制友好的文本文件(\\*.tres)。导出游戏后, godot 将资"
"源文件序列化为二进制文件(\\*.res), 以提高速度和压缩。"

#: ../../docs/getting_started/step_by_step/resources.rst:179
msgid ""
"Godot Engine's Inspector renders and edits Resource files out-of-the-box. As "
"such, users often do not need to implement custom logic to visualize or edit "
"their data. To do so, double-click the resource file in the FileSystem dock "
"or click the folder icon in the Inspector and open the file in the dialog."
msgstr ""
"godot 引擎属性面板用开箱即用的方式呈现和编辑资源文件。因此, 用户通常不需要实"
"现自定义逻辑来可视化或编辑其数据。为此, 请双击文件系统停靠中的资源文件, 或单"
"击属性面板中的文件夹图标, 然后在对话框中打开该文件。"

#: ../../docs/getting_started/step_by_step/resources.rst:181
msgid ""
"They can extend **other** resource types besides just the base Resource."
msgstr "除了基本资源之外, 它们还可以扩展 **其他** 资源类型。"

#: ../../docs/getting_started/step_by_step/resources.rst:185
#, fuzzy
msgid ""
"Resources and Dictionaries are both passed by reference, but only Resources "
"are reference-counted. This means that if a Dictionary is passed between "
"objects and the first object is deleted, all other objects' references to "
"the Dictinoary will be invalidated. Conversely, Resources will not be freed "
"from memory until *all* the objects are deleted."
msgstr ""
"资源和字典也是不同的, 因为两者都是通过引用传递的, 但只有资源是引用计数。这意"
"味着, 如果在对象之间传递字典, 并且删除第一个对象, 它将使第二个对象变量无效。"
"对于资源来说, 情况并非如此, 因为在所有实例消失之前, 资源不会释放他们的内存。"

#: ../../docs/getting_started/step_by_step/resources.rst:215
msgid "Godot makes it easy to create custom Resources in the Inspector."
msgstr "godot 使在属性面板中创建自定义资源变得很容易。"

#: ../../docs/getting_started/step_by_step/resources.rst:217
msgid ""
"Create a plain Resource object in the Inspector. This can even be a type "
"that derives Resource, so long as your script is extending that type."
msgstr ""
"在属性面板中创建一个普通的资源对象。这甚至可以是派生资源的类型, 只要您的脚本"
"扩展该类型。"

#: ../../docs/getting_started/step_by_step/resources.rst:218
msgid "Set the ``script`` property in the Inspector to be your script."
msgstr "将属性面板中的脚本属性设置为 ``script``。"

#: ../../docs/getting_started/step_by_step/resources.rst:220
msgid ""
"The Inspector will now display your Resource script's custom properties. If "
"one edits those values and saves the resource, the Inspector serializes the "
"custom properties too! To save a resource from the Inspector, click the "
"Inspector's tools menu (top right), and select \"Save\" or \"Save As...\"."
msgstr ""
"属性面板现在将显示您的资源脚本自定义属性。如果编辑了这些值并保存了资源, 属性"
"面板也会序列化自定义属性若要从属性面板中保存资源, 请单击 \"属性面板工具\" 菜"
"单 (右上角), 然后选择 \"保存\" 或 \"另存为...\"。"

#: ../../docs/getting_started/step_by_step/resources.rst:225
msgid ""
"If the script's language supports :ref:`script classes "
"<doc_scripting_continued_class_name>`, then it streamlines the process. "
"Defining a name for your script alone will add it to the Inspector's "
"creation dialog. This will auto-add your script to the Resource object you "
"create."
msgstr ""
"如果脚本语言支持脚本类, 则简化了过程。仅定义脚本的名称会将其添加到属性面板创"
"建对话框中。这将自动将脚本添加到您创建的资源对象中。"

#: ../../docs/getting_started/step_by_step/resources.rst:230
msgid "Let's see some examples."
msgstr "让我们看看一些示例。"

#: ../../docs/getting_started/step_by_step/resources.rst:303
msgid ""
"Resource scripts are similar to Unity's ScriptableObjects. The Inspector "
"provides built-in support for custom resources. If desired though, users can "
"even design their own Control-based tool scripts and combine them with an :"
"ref:`EditorPlugin <class_EditorPlugin>` to create custom visualizations and "
"editors for their data."
msgstr ""
"资源脚本类似于Unity的脚本对象。属性面板提供对自定义资源的内置支持。如果需要, "
"用户甚至可以设计自己的基于控件的工具脚本, 并将它们与 :ref:`EditorPlugin "
"<class_EditorPlugin>` 结合起来, 为其数据创建自定义可视化和编辑器。"

#: ../../docs/getting_started/step_by_step/resources.rst:309
msgid ""
"Unreal Engine 4's DataTables and CurveTables are also easy to recreate with "
"Resource scripts. DataTables are a String mapped to a custom struct, similar "
"to a Dictionary mapping a String to a secondary custom Resource script."
msgstr ""
"虚幻4引擎的数据表和 CurveTables 也很容易使用资源脚本重新创建。数据表是映射到"
"自定义结构的字符串, 类似于将字符串映射到辅助自定义资源脚本的字典。"

#: ../../docs/getting_started/step_by_step/resources.rst:345
msgid ""
"Instead of just inlining the Dictionary values, one could also, "
"alternatively..."
msgstr "而不是只是内联字典值, 您也可以, 或者..."

#: ../../docs/getting_started/step_by_step/resources.rst:347
msgid ""
"Import a table of values from a spreadsheet and generate these key-value "
"pairs, or..."
msgstr "从电子表格导入值的表, 并生成这些键值对, 或..."

#: ../../docs/getting_started/step_by_step/resources.rst:349
msgid ""
"Design a visualization within the editor and create a simple plugin that "
"adds it to the Inspector when you open these types of Resources."
msgstr ""
"在编辑器中设计可视化, 并创建一个简单的插件, 当您打开这些类型的资源时, 将其添"
"加到属性面板中。"

#: ../../docs/getting_started/step_by_step/resources.rst:352
msgid ""
"CurveTables are the same thing, except mapped to an Array of float values or "
"a :ref:`Curve <class_Curve>`/:ref:`Curve2D <class_Curve2D>` resource object."
msgstr ""
"CurveTables 是相同的事情, 除了映射到浮点值的数组或 :ref:`Curve "
"<class_Curve>`/ :ref:`Curve2D <class_Curve2D>` 资源对象。"

#: ../../docs/getting_started/step_by_step/resources.rst:357
msgid ""
"Beware that resource files (\\*.tres/\\*.res) will store the path of the "
"script they use in the file. When loaded, they will fetch and load this "
"script as an extension of their type. This means that trying to assign a "
"subclass, i.e. an inner class of a script (such as using the ``class`` "
"keyword in GDScript) won't work. Godot will not serialize the custom "
"properties on the script subclass properly."
msgstr ""
"请注意, 资源文件(\\*.tres/\\*.res)将存储在文件中的脚本的路径。加载时, 它们将"
"提取并加载此脚本作为其类型的扩展。这意味着尝试分配一个子类, 即脚本的内部类 "
"(例如在 gdscript 中使用``类``关键字) 是不起作用的。godot 不会正确序列化脚本子"
"类上的自定义属性。"

#: ../../docs/getting_started/step_by_step/resources.rst:363
msgid ""
"In the example below, Godot would load the ``Node`` script, see that it "
"doesn't extend ``Resource``, and then determine that the script failed to "
"load for the Resource object since the types are incompatible."
msgstr ""
"在下面的示例中, godot 将加载 ``节点`` 脚本, 查看它不会扩展 ``资源`` , 然后确"
"定该脚本未能为资源对象加载, 因为这些类型不兼容。"

#: ../../docs/getting_started/step_by_step/filesystem.rst:4
msgid "File system"
msgstr "文件系统"

#: ../../docs/getting_started/step_by_step/filesystem.rst:9
msgid ""
"File systems are yet another hot topic in engine development. The file "
"system manages how the assets are stored and how they are accessed. A well-"
"designed file system also allows multiple developers to edit the same source "
"files and assets while collaborating."
msgstr ""
"文件系统也是游戏引擎开发的热门话题之一。文件系统掌管着资源(assets)的存取。一"
"个好的文件系统能让团队中的成员们共同编辑相同的源文件和资源。"

#: ../../docs/getting_started/step_by_step/filesystem.rst:14
msgid ""
"Initial versions of the Godot engine (and previous iterations before it was "
"named Godot) used a database. Assets were stored in it and assigned an ID. "
"Other approaches were tried as well, such as local databases, files with "
"metadata, etc. In the end, the simple approach won and now Godot stores all "
"assets as files in the file system."
msgstr ""
"Godot在最初版本及以前使用过一个数据库。资源都被分配了ID存储在其中。后来我们也"
"尝试了各种其他方法，例如本地数据库、带元数据的文件等等。但最终，我们选择了将"
"Godot所有的资源存储于文件系统中这一简单途径。"

#: ../../docs/getting_started/step_by_step/filesystem.rst:21
msgid "Implementation"
msgstr "实现"

#: ../../docs/getting_started/step_by_step/filesystem.rst:23
msgid ""
"The file system stores resources on disk. Anything, from a script, to a "
"scene or a PNG image is a resource to the engine. If a resource contains "
"properties that reference other resources on disk, the paths to those "
"resources are also included. If a resource has sub-resources that are built-"
"in, the resource is saved in a single file together with all the bundled sub-"
"resources. For example, a font resource is often bundled together with the "
"font textures."
msgstr ""
"文件系统将资源(resources)存储在硬盘上。无论是某一个脚本(script)、还是某一个场"
"景(scene)、抑或是某一张PNG图片，任何东西，对于Godot引擎来说,都是一个资源"
"(resource)。如果一个资源包含着一些指向硬盘上的其他资源的属性(properties)，那"
"么指向那些资源的路径(paths)也同样包含在该资源当中。如果一个资源内建有一些子资"
"源(sub-resources)，那么所有的子资源都会和它一起打包在一个文件当中。"

#: ../../docs/getting_started/step_by_step/filesystem.rst:30
msgid ""
"In general, the Godot file system avoids using metadata files. The reason "
"for this is simple, existing asset managers and VCSs are simply much better "
"than anything we can implement, so Godot tries its best to play along with "
"SVN, Git, Mercurial, Perforce, etc."
msgstr ""
"总的来讲，Godot的文件系统并未使用元数据文件，理由很简单，现在的各种资源管理系"
"统和版本控制系统都远比我们自己实现的要好得多，所以Godot尽量去参与到SVN, Git, "
"Mercurial, Perforce等当中。"

#: ../../docs/getting_started/step_by_step/filesystem.rst:35
msgid "Example of a file system contents:"
msgstr "举个示例，一个文件系统内有:"

#: ../../docs/getting_started/step_by_step/filesystem.rst:46
msgid "project.godot"
msgstr "project.godot"

#: ../../docs/getting_started/step_by_step/filesystem.rst:48
msgid ""
"The project.godot file is the project description file, and it is always "
"found at the root of the project. In fact, its location defines where the "
"root is. This is the first file that Godot looks for when opening a project."
msgstr ""
"文件project.godot是一个项目描述文件，您总能在当前项目的根目录下找到它。事实"
"上，Godot正是根据它的位置定义当前项目根目录的位置。这正是在您打开某个项目时，"
"Godot最先寻找的文件。"

#: ../../docs/getting_started/step_by_step/filesystem.rst:52
msgid ""
"This file contains the project configuration in plain text, using the win."
"ini format. Even an empty project.godot can function as a basic definition "
"of a blank project."
msgstr ""
"这个文件是一个普通的文本文件，以win.ini的格式写着当前项目的各种配置信息。即使"
"是一个空的project.godot文件也可做为某个空项目的基本定义。"

#: ../../docs/getting_started/step_by_step/filesystem.rst:57
msgid "Path delimiter"
msgstr "路径分隔符"

#: ../../docs/getting_started/step_by_step/filesystem.rst:59
msgid ""
"Godot only supports ``/`` as a path delimiter. This is done for portability "
"reasons. All operating systems support this, even Windows, so a path such as "
"``c:\\project\\project.godot`` needs to be typed as ``c:/project/project."
"godot``."
msgstr ""
"Godot只支持用 ``/`` 做路径分隔符。这是为了最求更好的可移植性。所有的操作系统"
"都支持它，就算是Windows，所以像是 ``c:\\project\\project.godot`` 这种路径，在"
"Godot中必须写作 ``c:/project/project.godot`` 。"

#: ../../docs/getting_started/step_by_step/filesystem.rst:65
#: ../../docs/tutorials/io/data_paths.rst:16
msgid "Resource path"
msgstr "资源路径"

#: ../../docs/getting_started/step_by_step/filesystem.rst:67
msgid ""
"When accessing resources, using the host OS file system layout can be "
"cumbersome and non-portable. To solve this problem, the special path ``res://"
"`` was created."
msgstr ""
"当您需要去取用资源时，使用主机操作系统的文件系统布局可能会又繁琐又导致项目不"
"可移植。为了解决这个问题，我们创建了专有路径 ``res://`` 。"

#: ../../docs/getting_started/step_by_step/filesystem.rst:71
msgid ""
"The path ``res://`` will always point at the project root (where project."
"godot is located, so in fact ``res://project.godot`` is always valid)."
msgstr ""
"路径``res://``将始终指向项目根(project.godot所在的位置, 因此实际上``res://"
"project.godot``始终有效)。"

#: ../../docs/getting_started/step_by_step/filesystem.rst:75
msgid ""
"This file system is read-write only when running the project locally from "
"the editor. When exported or when running on different devices (such as "
"phones or consoles, or running from DVD), the file system will become read-"
"only and writing will no longer be permitted."
msgstr ""
"只有在从编辑器本地运行项目时, 此文件系统才是读写的。导出或在不同设备 (如手机"
"或控制台) 上运行时, 文件系统将变为只读, 不再允许写入。"

#: ../../docs/getting_started/step_by_step/filesystem.rst:81
msgid "User path"
msgstr "用户路径"

#: ../../docs/getting_started/step_by_step/filesystem.rst:83
msgid ""
"Writing to disk is often still needed for various tasks such as saving game "
"state or downloading content packs. To this end, the engine ensures that "
"there is a special path ``user://`` that is always writable."
msgstr ""
"对于保存游戏状态或下载内容包等各种任务, 通常仍然需要写入磁盘。为此, 引擎确保"
"有一个始终可写的特殊路径``user://``。"

#: ../../docs/getting_started/step_by_step/filesystem.rst:88
msgid "Host file system"
msgstr "主机文件系统"

#: ../../docs/getting_started/step_by_step/filesystem.rst:90
msgid ""
"Alternatively host file system paths can also be used, but this is not "
"recommended for a released product as these paths are not guaranteed to work "
"on all platforms. However, using host file system paths can be useful when "
"writing development tools in Godot!"
msgstr ""
"或者, 也可以使用主机文件系统路径, 但不建议对已发布的产品使用此路径, 因为不能"
"保证这些路径在所有平台上都能正常工作。但是, 在 godot 中编写开发工具时, 使用主"
"机文件系统路径非常有用!"

#: ../../docs/getting_started/step_by_step/filesystem.rst:96
msgid "Drawbacks"
msgstr "缺点"

#: ../../docs/getting_started/step_by_step/filesystem.rst:98
msgid ""
"There are some drawbacks to this simple file system design. The first issue "
"is that moving assets around (renaming them or moving them from one path to "
"another inside the project) will break existing references to these assets. "
"These references will have to be re-defined to point at the new asset "
"location."
msgstr ""
"这种简单的文件系统设计有一些缺点。第一个问题是, 移动资源 (重命名它们或将它们"
"从项目内的一个路径移动到另一个路径) 将破坏对这些资源的现有引用。必须重新定义"
"这些引用, 以指向新的资源位置。"

#: ../../docs/getting_started/step_by_step/filesystem.rst:103
msgid ""
"To avoid this, do all your move, delete and rename operations from within "
"Godot, on the FileSystem dock. Never move assets from outside Godot, or "
"dependencies will have to be fixed manually (Godot detects this and helps "
"you fix them anyway, but why go the hard route?)."
msgstr ""
"若要避免这种情况, 请在文件系统面板上的Godot内执行所有操作、删除和重命名操作。"
"永远不要从Godot外部移动资源, 否则必须手动修复依赖项(Godot检测到这一点, 并帮助"
"您修复它们, 但为什么要走艰难的路线？)。"

#: ../../docs/getting_started/step_by_step/filesystem.rst:108
#, fuzzy
msgid ""
"The second is that, under Windows and macOS, file and path names are case "
"insensitive. If a developer working in a case insensitive host file system "
"saves an asset as \"myfile.PNG\", but then references it as \"myfile.png\", "
"it will work fine on their platform, but not on other platforms, such as "
"Linux, Android, etc. This may also apply to exported binaries, which use a "
"compressed package to store all files."
msgstr ""
"第二种情况是, 在Windows和macOS文件和路径名下不区分大小写。如果在不区分大小写"
"的主机文件系统中工作的开发人员将资源另存为“myfile.PNG”, 但随后将其引用"
"为“myfile.png”, 它将在他们的平台上正常工作, 但在其他平台上不行, 如Linux、"
"Android等。这也可能适用于导出的二进制文件, 这些二进制文件使用压缩包来存储所有"
"文件。"

#: ../../docs/getting_started/step_by_step/filesystem.rst:114
#, fuzzy
msgid ""
"It is recommended that your team clearly define a naming convention for "
"files when working with Godot! One simple fool-proof convention is to only "
"allow lowercase file and path names."
msgstr ""
"建议您的团队在使用Godot时明确定义文件的命名约定!一个简单的万无一失的约定是只"
"允许小写文件和路径名。"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:4
#: ../../docs/getting_started/step_by_step/scene_tree.rst:41
#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:288
msgid "SceneTree"
msgstr "场景树"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:9
msgid ""
"This is where things start getting abstract, but don't panic. There's not "
"much more depth than this."
msgstr "这就是事情开始变得抽象的地方, 但不要慌张。没有比这更深入的了。"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:12
msgid ""
"In previous tutorials, everything revolved around the concept of nodes. "
"Scenes are simply a collection of nodes. They become active once they enter "
"the *scene tree*."
msgstr ""
"在前面的教程中, 一切都围绕节点的概念展开。场景只是节点的集合。一旦进入 *场景"
"树* , 它们就会被激活。"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:16
msgid ""
"This concept deserves going into a little more detail. In fact, the scene "
"system is not even a core component of Godot as it is possible to skip it "
"and write a script (or C++ code) that talks directly to the servers, but "
"making a game that way would be a lot of work."
msgstr ""
"这个概念值得更详细一些。事实上, 场景系统甚至不是Godot的核心组件, 因为可以跳过"
"它, 编写一个直接与服务器对话的脚本 (或 C++ 代码), 但以这种方式制作游戏将是一"
"项大量的工作。"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:22
msgid "MainLoop"
msgstr "主循环"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:24
msgid ""
"The way Godot works internally is as follows. There is the :ref:`OS "
"<class_OS>` class, which is the only instance that runs at the beginning. "
"Afterwards, all drivers, servers, scripting languages, scene system, etc are "
"loaded."
msgstr ""
"Godot内部的工作方式如下所示。有 :ref:`OS <class_OS>` 类, 它是在开始时运行的唯"
"一实例。之后, 加载所有驱动程序、服务器、脚本语言、场景系统等。"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:29
msgid ""
"When initialization is complete, :ref:`OS <class_OS>` needs to be supplied "
"a :ref:`MainLoop <class_MainLoop>` to run. Up to this point, all this is "
"internals working (you can check main/main.cpp file in the source code if "
"you are ever interested to see how this works internally)."
msgstr ""
"初始化完成后, 需要向 :ref:`OS <class_OS>` 提供一个 :ref:`MainLoop "
"<class_MainLoop>` 来运行。到目前为止, 所有这些都是内部工作 (您可以检查main/"
"main.cpp文件在源代码中, 如果您曾经有兴趣看到它是如何在内部工作)。"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:35
msgid ""
"The user program, or game, starts in the MainLoop. This class has a few "
"methods, for initialization, idle (frame-synchronized callback), fixed "
"(physics-synchronized callback), and input. Again, this is low level and "
"when making games in Godot, writing your own MainLoop seldom makes sense."
msgstr ""
"用户程序或游戏从主循环开始。此类有几个方法, 用于初始化、空闲 (框架同步回调)、"
"固定 (物理同步回调) 和输入。同样, 这是低级别的, 在Godot中制作游戏时, 编写自己"
"的主循环意义不大。"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:43
msgid ""
"One of the ways to explain how Godot works is that it's a high level game "
"engine over a low level middleware."
msgstr ""
"解释Godot如何工作的方法之一是, 它是一个高级的游戏引擎, 超过了一个低级中间件。"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:46
msgid ""
"The scene system is the game engine, while the :ref:`OS <class_OS>` and "
"servers are the low level API."
msgstr "场景系统是游戏引擎, 而 :ref:`OS <class_OS>` 和服务器是低级API。"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:49
msgid ""
"In any case, the scene system provides its own main loop to OS, :ref:"
"`SceneTree <class_SceneTree>`. This is automatically instanced and set when "
"running a scene, no need to do any extra work."
msgstr ""
"在任何情况下, 场景系统都为操作系统 :ref:`SceneTree <class_SceneTree>` 提供了"
"自己的主循环。这是在运行场景时自动进行实例化和设置的, 无需执行任何额外的工"
"作。"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:54
msgid ""
"It's important to know that this class exists because it has a few important "
"uses:"
msgstr "重要的是要知道此类的存在, 因为它有几个重要的用途:"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:57
msgid ""
"It contains the root :ref:`Viewport <class_Viewport>`, to which a scene is "
"added as a child when it's first opened to become part of the *Scene Tree* "
"(more on that next)"
msgstr ""
"它包含根 :ref:`Viewport <class_Viewport>`, 当场景第一次打开时, 场景将作为子对"
"象添加到其中 (接下来会有更多)"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:60
msgid ""
"It contains information about the groups and has the means to call all nodes "
"in a group or get a list of them."
msgstr "它包含有关组的信息, 并具有调用组中的所有节点或获取它们的列表的方法。"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:62
msgid ""
"It contains some global state functionality, such as setting pause mode or "
"quitting the process."
msgstr "它包含一些全局状态功能, 如设置暂停模式或退出进程。"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:65
#, fuzzy
msgid ""
"When a node is part of the Scene Tree, the :ref:`SceneTree "
"<class_SceneTree>` singleton can be obtained by simply calling :ref:`Node."
"get_tree() <class_Node_method_get_tree>`."
msgstr ""
"当节点是场景树的一部分时, 只需调用 :ref:`Node.get_tree() "
"<class_Node_method_get_tree>` 即可获得 :ref:`场景树 <class_SceneTree>` 单例。"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:71
msgid "Root viewport"
msgstr "根视区"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:73
msgid ""
"The root :ref:`Viewport <class_Viewport>` is always at the top of the scene. "
"From a node, it can be obtained in two different ways:"
msgstr ""
"根 :ref:`Viewport <class_Viewport>` 始终位于场景的顶部。从节点中, 可以通过两"
"种不同的方式获得它:"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:88
msgid ""
"This node contains the main viewport, anything that is a child of a :ref:"
"`Viewport <class_Viewport>` is drawn inside of it by default, so it makes "
"sense that the top of all nodes is always a node of this type otherwise "
"nothing would be seen!"
msgstr ""
"此节点包含主视区, 默认情况下, 任何作为 :ref:`Viewport <class_Viewport>` 子视"
"区的内容都将在其中绘制, 因此, 所有节点的顶部始终是此类型的节点是有意义的, 否"
"则不会看到任何内容！"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:93
msgid ""
"While other viewports can be created in the scene (for split-screen effects "
"and such), this one is the only one that is never created by the user. It's "
"created automatically inside SceneTree."
msgstr ""
"虽然可以在场景中创建其他视区 (用于拆分屏幕效果等), 但这是唯一一个从未由用户创"
"建的视区。它是在“场景树”内自动创建的。"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:98
#: ../../docs/tutorials/threads/thread_safe_apis.rst:22
msgid "Scene tree"
msgstr "场景树"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:100
msgid ""
"When a node is connected, directly or indirectly, to the root viewport, it "
"becomes part of the *scene tree*."
msgstr "当节点直接或间接连接到根视区时, 它将成为 *场景树* 的一部分。"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:103
msgid ""
"This means that as explained in previous tutorials, it will get the "
"_enter_tree() and _ready() callbacks (as well as _exit_tree())."
msgstr ""
"这意味着, 正如在前面的教程中所解释的, 它将得到 _enter_tree() 和 _ready() 回"
"调 (以及_exit_tree())。"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:108
msgid ""
"When nodes enter the *Scene Tree*, they become active. They get access to "
"everything they need to process, get input, display 2D and 3D, "
"notifications, play sound, groups, etc. When they are removed from the "
"*scene tree*, they lose access."
msgstr ""
"当节点进入 *场景树* 时, 它们将变为活动状态。他们可以访问处理、获取输入、显示"
"2d 和3d、通知、播放声音、组等所需的一切。当它们从 *场景树* 中删除时, 它们将失"
"去访问权限。"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:114
msgid "Tree order"
msgstr "树顺序"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:116
msgid ""
"Most node operations in Godot, such as drawing 2D, processing, or getting "
"notifications are done in tree order. This means that parents and siblings "
"with a smaller rank in the tree order will get notified before the current "
"node."
msgstr ""
"Godot中的大多数节点操作 (如绘制2d、处理或获取通知) 都是按树顺序完成的。这意味"
"着在树顺序中排名较小的家长和兄弟姐妹将在当前节点之前收到通知。"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:124
msgid "\"Becoming active\" by entering the *Scene Tree*"
msgstr "通过进入 *场景树* \"被激活\""

#: ../../docs/getting_started/step_by_step/scene_tree.rst:126
msgid "A scene is loaded from disk or created by scripting."
msgstr "场景是从磁盘加载或通过脚本创建的。"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:127
msgid ""
"The root node of that scene (only one root, remember?) is added as either a "
"child of the \"root\" Viewport (from SceneTree), or to any child or "
"grandchild of it."
msgstr ""
"该场景的根节点 (只记得一个根节点？) 被添加为“根”视区 (从场景树) 的子节点, 或"
"添加到该场景的任何子节点或孙子。"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:130
msgid ""
"Every node of the newly added scene, will receive the \"enter_tree\" "
"notification ( _enter_tree() callback in GDScript) in top-to-bottom order."
msgstr ""
"新添加的场景的每个节点都将按从上到底顺序收到“enter_tree”通知(GDScript中的 "
"_enter_tree 回调)。"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:133
msgid ""
"An extra notification, \"ready\" ( _ready() callback in GDScript) is "
"provided for convenience, when a node and all its children are inside the "
"active scene."
msgstr ""
"当节点及其所有子节点位于活动场景中时, 为方便起见, 提供了一个额外的通知, "
"即“ready”(GDScript中的 _ready() 回调)。"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:136
msgid ""
"When a scene (or part of it) is removed, they receive the \"exit scene\" "
"notification ( _exit_tree() callback in GDScript) in bottom-to-top order"
msgstr ""
"删除场景 (或其中一部分) 后, 它们将按从下到上的顺序收到“退出场景”通知(GDScript"
"中的 _exit_tree() 回调)"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:141
msgid "Changing current scene"
msgstr "更改当前场景"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:143
#, fuzzy
msgid ""
"After a scene is loaded, it is often desired to change this scene for "
"another one. The simple way to do this is to use the :ref:`SceneTree."
"change_scene() <class_SceneTree_method_change_scene>` function:"
msgstr ""
"加载场景后, 通常需要将此场景更改为另一个场景。简单的方法是使用 :ref:"
"`SceneTree.change_scene() <class_SceneTree_method_change_scene>` 方法:"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:161
#, fuzzy
msgid ""
"Rather than using file paths, one can also use ready-made :ref:`PackedScene "
"<class_PackedScene>` resources using the equivalent function :ref:`SceneTree."
"change_scene_to(PackedScene scene) <class_SceneTree_method_change_scene_to>`:"
msgstr ""
"除了使用文件路径, 也可以通过使用等效函数 :ref:`SceneTree."
"change_scene_to(PackedScene scene)<class_SceneTree_method_change_scene_to>` "
"来利用现成的 :ref:`PackedScene <class_PackedScene>` 资源:"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:182
msgid ""
"These are quick and useful ways to switch scenes but have the drawback that "
"the game will stall until the new scene is loaded and running. At some point "
"in your game, it may be desired to create proper loading screens with "
"progress bar, animated indicators or thread (background) loading. This must "
"be done manually using autoloads (see next chapter!) and :ref:"
"`doc_background_loading`."
msgstr ""
"这是一个快速和有用的方式来切换场景, 但有一个缺点, 游戏将停止, 直到新的场景加"
"载并运行。在游戏中的某个时刻, 可能需要创建适当的加载屏幕, 其中包含进度条、动"
"画指示器或线程 (后台) 加载。这必须使用自动加载手动完成 (请参阅下一章) 和 :"
"ref:`doc_background_loading` 。"

#: ../../docs/getting_started/step_by_step/singletons_autoload.rst:4
msgid "Singletons (AutoLoad)"
msgstr "单例模式(自动加载)"

#: ../../docs/getting_started/step_by_step/singletons_autoload.rst:9
msgid ""
"Godot's scene system, while powerful and flexible, has a drawback: there is "
"no method for storing information (e.g. a player's score or inventory) that "
"is needed by more than one scene."
msgstr ""
"Godot的场景系统虽然功能强大且灵活, 但有一个缺点:没有一种方法可以存储多个场景"
"所需的信息 (例如游戏角色的分数或库存)。"

#: ../../docs/getting_started/step_by_step/singletons_autoload.rst:13
msgid ""
"It's possible to address this with some workarounds, but they come with "
"their own limitations:"
msgstr "可以通过一些变通办法来解决这个问题, 但它们有自己的局限性:"

#: ../../docs/getting_started/step_by_step/singletons_autoload.rst:16
msgid ""
"You can use a \"master\" scene that loads and unloads other scenes as its "
"children. However, this means you can no longer run those scenes "
"individually and expect them to work correctly."
msgstr ""
"您可以使用 \"主\" 场景, 该场景作为子场景加载和卸载其他场景。但是, 这意味着您"
"不能再单独运行这些场景, 并期望它们正常工作。"

#: ../../docs/getting_started/step_by_step/singletons_autoload.rst:19
msgid ""
"Information can be stored to disk in ``user://`` and then loaded by scenes "
"that require it, but frequently saving and loading data is cumbersome and "
"may be slow."
msgstr ""
"信息可以存储在 ``user://`` 中的磁盘, 然后由需要它的场景加载, 但经常保存和加载"
"数据很麻烦, 并且可能很慢。"

#: ../../docs/getting_started/step_by_step/singletons_autoload.rst:23
msgid ""
"The `Singleton Pattern <https://en.wikipedia.org/wiki/Singleton_pattern>`_ "
"is a useful tool for solving the common use case where you need to store "
"persistent information between scenes. In our case it is possible re-use the "
"same scene or class for multiple singletons, so long as they have different "
"names."
msgstr ""
"`Singleton Pattern(单例模式) <https://en.wikipedia.org/wiki/"
"Singleton_pattern>`_ 是一个有用的工具, 用于解决需要在场景之间存储持久信息的常"
"见用例。在我们的示例中, 可以将同一个场景或类重新用于多个单例, 只要它们有不同"
"的名称。"

#: ../../docs/getting_started/step_by_step/singletons_autoload.rst:29
msgid "Using this concept, you can create objects that:"
msgstr "使用此概念, 您可以创建以下对象:"

#: ../../docs/getting_started/step_by_step/singletons_autoload.rst:31
msgid "Are always loaded, no matter which scene is currently running"
msgstr "始终加载, 无论当前正在运行的场景是哪个"

#: ../../docs/getting_started/step_by_step/singletons_autoload.rst:32
msgid "Can store global variables, such as player information"
msgstr "可以存储全局变量, 如游戏角色信息"

#: ../../docs/getting_started/step_by_step/singletons_autoload.rst:33
msgid "Can handle switching scenes and between-scene transitions"
msgstr "可以处理切换场景和场景之间的过渡"

#: ../../docs/getting_started/step_by_step/singletons_autoload.rst:34
msgid ""
"Act like a singleton, since GDScript does not support global variables by "
"design"
msgstr "表现得像一个单例对象，因为GDScript在设计上不支持全局变量"

#: ../../docs/getting_started/step_by_step/singletons_autoload.rst:36
msgid "Autoloading nodes and scripts caters to this need."
msgstr "自动加载节点和脚本可满足这一需求。"

#: ../../docs/getting_started/step_by_step/singletons_autoload.rst:39
msgid "AutoLoad"
msgstr "自动加载(AutoLoad)"

#: ../../docs/getting_started/step_by_step/singletons_autoload.rst:41
msgid ""
"You can use AutoLoad to load a scene or a script that inherits from :ref:"
"`Node <class_Node>`. Note: when autoloading a script, a Node will be created "
"and the script will be attached to it. This node will be added to the root "
"viewport before any other scenes are loaded."
msgstr ""
"可以使用“自动加载”加载从节点继承的场景或脚本。注意: 自动加载脚本时, 将创建一"
"个节点, 并将脚本附加到该脚本。在加载任何其他场景之前, 此节点将添加到根视区。"

#: ../../docs/getting_started/step_by_step/singletons_autoload.rst:48
msgid ""
"To autoload a scene or script, select ``Project -> Project Settings`` from "
"the menu and switch to the \"AutoLoad\" tab."
msgstr ""
"要自动加载场景或脚本, 请从菜单中选择 \"项目-> 项目设置\", 然后切换到 \"自动加"
"载\" 选项卡。"

#: ../../docs/getting_started/step_by_step/singletons_autoload.rst:53
msgid ""
"Here you can add any number of scenes or scripts. Each entry in the list "
"requires a name, which is assigned as the node's ``name`` property. The "
"order of the entries as they are added to the global scene tree can be "
"manipulated using the up/down arrow keys."
msgstr ""
"在这里, 您可以添加任意数量的场景或脚本。列表中的每个条目都需要一个名称, 该名"
"称分配给节点的 ``name`` 属性。可以使用向上箭头键操作添加到全局场景树中的条目"
"的顺序。"

#: ../../docs/getting_started/step_by_step/singletons_autoload.rst:60
msgid ""
"This means that any node can access a singleton named \"PlayerVariables\" "
"with:"
msgstr "这意味着任何节点都可以使用以下方式访问名为“PlayerVariables”的单例:"

#: ../../docs/getting_started/step_by_step/singletons_autoload.rst:73
msgid ""
"If the \"Enable\" column is checked (default true) then the singleton can "
"simply be accessed directly:"
msgstr "如果选中了“Enable”列 (默认为 true), 则只需直接访问单例:"

#: ../../docs/getting_started/step_by_step/singletons_autoload.rst:86
msgid ""
"Note that autoload objects (scripts and/or scenes) are accessed just like "
"any other node in the scene tree. In fact, if you look at the running scene "
"tree, you'll see the autoloaded nodes appear:"
msgstr ""
"请注意, 自动加载对象 (脚本和场景) 的访问方式与场景树中的任何其他节点相同。事"
"实上, 如果您查看正在运行的场景树, 您将看到自动加载的节点出现:"

#: ../../docs/getting_started/step_by_step/singletons_autoload.rst:93
msgid "Custom scene switcher"
msgstr "自定义场景切换器"

#: ../../docs/getting_started/step_by_step/singletons_autoload.rst:95
#, fuzzy
msgid ""
"This tutorial will demonstrate building a scene switcher using autoload. For "
"basic scene switching, you can use the :ref:`SceneTree.change_scene() "
"<class_SceneTree_method_change_scene>` method (see :ref:`doc_scene_tree` for "
"details). However, if you need more complex behavior when changing scenes, "
"this method provides more functionality."
msgstr ""
"本教程将演示如何使用自动加载构建场景切换器。对于基本场景切换, 您可以使用 :"
"ref:`SceneTree.change_scene() <class_SceneTree_method_change_scene>` 方法(有"
"关详细信息, 请参阅 :ref:`doc_scene_tree` )。但是, 如果在更改场景时需要更复杂"
"的行为, 此方法将提供更多功能。"

#: ../../docs/getting_started/step_by_step/singletons_autoload.rst:101
msgid ""
"To begin, download the template from here: :download:`autoload.zip <files/"
"autoload.zip>` and open it in Godot."
msgstr ""
"首先, 从这里下载模板: :download:`autoload.zip <files/autoload.zip>` 然后在"
"Godot中打开它。"

#: ../../docs/getting_started/step_by_step/singletons_autoload.rst:104
msgid ""
"The project contains two scenes: ``Scene1.tscn`` and ``Scene2.tscn``. Each "
"scene contains a label displaying the scene name and a button with its "
"``pressed()`` signal connected. When you run the project, it starts in "
"``Scene1.tscn``. However, pressing the button does nothing."
msgstr ""
"该项目包含两个场景: ``Scene1.tscn`` 和 ``Scene2.tscn``。每个场景都包含一个显"
"示场景名称的标签和一个连接了 ``pressed()`` 信号的按钮。当您运行该项目时, 它将"
"从 ``Scene1.tscn``开始。但是, 按下按钮不会执行任何操作。"

#: ../../docs/getting_started/step_by_step/singletons_autoload.rst:110
msgid "Global.gd"
msgstr "Global.gd"

#: ../../docs/getting_started/step_by_step/singletons_autoload.rst:112
msgid ""
"Switch to the \"Script\" tab and create a new script called Global.gd. Make "
"sure it inherits from ``Node``:"
msgstr ""
"切换到 \"Script\" 选项卡, 并创建一个名为“Global.gd”的新脚本。确保它从 "
"``Node`` 继承:"

#: ../../docs/getting_started/step_by_step/singletons_autoload.rst:117
msgid ""
"The next step is to add this script to the autoLoad list. Open ``Project > "
"Project Settings`` from the menu, switch to the \"AutoLoad\" tab and select "
"the script by clicking the ``..`` button or typing its path: ``res://Global."
"gd``. Press \"Add\" to add it to the autoload list:"
msgstr ""
"下一步是将此脚本添加到自动加载列表中。从菜单中打开 ``项目 > 项目设置`` , 切换"
"到“自动加载”选项卡, 然后单击 ``..``按钮或键入其路径: ``res://Global.gd``。"
"按“添加”将其添加到自动加载列表:"

#: ../../docs/getting_started/step_by_step/singletons_autoload.rst:124
msgid ""
"Now whenever we run any scene in the project, this script will always be "
"loaded."
msgstr "现在, 每当我们运行项目中的任何场景时, 都会始终加载此脚本。"

#: ../../docs/getting_started/step_by_step/singletons_autoload.rst:126
msgid ""
"Returning to the script, it needs to fetch the current scene in the "
"`_ready()` function. Both the current scene (the one with the button) and "
"``global.gd`` are children of root, but autoloaded nodes are always first. "
"This means that the last child of root is always the loaded scene."
msgstr ""
"返回到脚本, 它需要获取 `_ready()` 函数中的当前场景。当前场景 (带有按钮的场"
"景) 和 ``global.gd`` 都是根的子节点, 但自动加载的节点始终是第一位的。这意味着"
"根的最后一个子项始终是加载的场景。"

#: ../../docs/getting_started/step_by_step/singletons_autoload.rst:158
msgid ""
"Now we need a function for changing the scene. This function needs to free "
"the current scene and replace it with the requested one."
msgstr ""
"现在我们需要一个用于更改场景的函数。此函数需要释放当前场景, 并将其替换为请求"
"的场景。"

#: ../../docs/getting_started/step_by_step/singletons_autoload.rst:227
msgid ""
"Using :ref:`Object.call_deferred() <class_Object_method_call_deferred>`, the "
"second function will only run once all code from the current scene has "
"completed. Thus, the current scene will not be removed while it is still "
"being used (i.e. its code is still running)."
msgstr ""

#: ../../docs/getting_started/step_by_step/singletons_autoload.rst:232
msgid ""
"Finally, we need to fill the empty callback functions in the two scenes:"
msgstr "最后, 我们需要在两个场景中填充空回调函数:"

#: ../../docs/getting_started/step_by_step/singletons_autoload.rst:252
#: ../../docs/tutorials/math/vector_math.rst:276
msgid "and"
msgstr "以及"

#: ../../docs/getting_started/step_by_step/singletons_autoload.rst:272
msgid ""
"Run the project and test that you can switch between scenes by pressing the "
"button!"
msgstr "运行项目和测试, 您可以通过按下按钮在场景之间切换!"

#: ../../docs/getting_started/step_by_step/singletons_autoload.rst:275
msgid ""
"Note: When scenes are small, the transition is instantaneous. However, if "
"your scenes are more complex, they may take a noticeable amount of time to "
"appear. To learn how to handle this, see the next tutorial: :ref:"
"`doc_background_loading`"
msgstr ""
"注意:当场景较小时, 转换是即时的。但是, 如果您的场景比较复杂, 则可能需要相当长"
"的时间才能显示。若要了解如何处理此问题, 请参阅下一个教程: :ref:"
"`doc_background_loading`"

#: ../../docs/getting_started/editor/index.rst:2
msgid "Editor manual"
msgstr "编辑器手册"

#: ../../docs/getting_started/editor/unity_to_godot.rst:8
msgid "From Unity to Godot Engine"
msgstr "从 Unity3D 迁移到 Godot 引擎"

#: ../../docs/getting_started/editor/unity_to_godot.rst:10
msgid ""
"This guide provides an overview of Godot Engine from the viewpoint of a "
"Unity user, and aims to help you migrate your existing Unity experience into "
"the world of Godot."
msgstr ""
"该指南提供了从 Unity 用户的角度所作的概览,并旨在帮助您将现有的Unity体验迁移至"
"Godot的世界里。"

#: ../../docs/getting_started/editor/unity_to_godot.rst:14
msgid "Differences"
msgstr "不同"

#: ../../docs/getting_started/editor/unity_to_godot.rst:17
msgid "Unity"
msgstr "Unity"

#: ../../docs/getting_started/editor/unity_to_godot.rst:17
msgid "Godot"
msgstr "Godot"

#: ../../docs/getting_started/editor/unity_to_godot.rst:19
#: ../../docs/community/contributing/documentation_guidelines.rst:102
msgid "License"
msgstr "许可证"

#: ../../docs/getting_started/editor/unity_to_godot.rst:19
msgid ""
"Proprietary, closed, free license with revenue caps and usage restrictions"
msgstr "专有，封闭，有收入上限和使用限制的免费许可证"

#: ../../docs/getting_started/editor/unity_to_godot.rst:19
msgid "MIT license, free and fully open source without any restriction"
msgstr "MIT许可证，免费，完全开源，没有任何限制"

#: ../../docs/getting_started/editor/unity_to_godot.rst:21
msgid "OS (editor)"
msgstr "OS (编辑器)"

#: ../../docs/getting_started/editor/unity_to_godot.rst:21
msgid "Windows, macOS, Linux (unofficial and unsupported)"
msgstr "Windows, macOS, Linux (非正式的，不被支持的)"

#: ../../docs/getting_started/editor/unity_to_godot.rst:21
msgid "Windows, macOS, X11 (Linux, \\*BSD)"
msgstr "Windows，macOS，X11(Linux， \\*BSD)"

#: ../../docs/getting_started/editor/unity_to_godot.rst:23
msgid "OS (export)"
msgstr "OS (导出)"

#: ../../docs/getting_started/editor/unity_to_godot.rst:23
msgid "**Desktop:** Windows, macOS, Linux"
msgstr "**桌面端:** Windows，macOS，Linux"

#: ../../docs/getting_started/editor/unity_to_godot.rst:24
msgid "**Mobile:** Android, iOS, Windows Phone, Tizen"
msgstr "**移动端:** Android，iOS，Windows Phone，Tizen"

#: ../../docs/getting_started/editor/unity_to_godot.rst:25
msgid "**Web:** WebAssembly or asm.js"
msgstr "**网页:** WebAssembly 或 asm.js"

#: ../../docs/getting_started/editor/unity_to_godot.rst:26
msgid "**Consoles:** PS4, PS Vita, Xbox One, Xbox 360, Wii U, Nintendo 3DS"
msgstr "**游戏主机:** PS4, PS Vita, Xbox One, Xbox 360, Wii U, Nintendo 3DS"

#: ../../docs/getting_started/editor/unity_to_godot.rst:27
msgid ""
"**VR:** Oculus Rift, SteamVR, Google Cardboard, Playstation VR, Gear VR, "
"HoloLens"
msgstr ""
"**虚拟现实端:** Oculus Rift, SteamVR, Google Cardboard, Playstation VR, Gear "
"VR, HoloLens"

#: ../../docs/getting_started/editor/unity_to_godot.rst:28
msgid "**TV:** Android TV, Samsung SMART TV, tvOS"
msgstr "**电视端:** Android TV, Samsung SMART TV, tvOS"

#: ../../docs/getting_started/editor/unity_to_godot.rst:23
msgid "**Desktop:** Windows, macOS, X11"
msgstr "**桌面端:** Windows，macOS，X11"

#: ../../docs/getting_started/editor/unity_to_godot.rst:24
msgid "**Mobile:** Android, iOS"
msgstr "**移动端:** Android，iOS"

#: ../../docs/getting_started/editor/unity_to_godot.rst:25
msgid "**Web:** WebAssembly"
msgstr "**网页:** WebAssembly"

#: ../../docs/getting_started/editor/unity_to_godot.rst:26
msgid "**Console:** See :ref:`doc_consoles`"
msgstr "**游戏主机:** 见 :ref:`doc_consoles`"

#: ../../docs/getting_started/editor/unity_to_godot.rst:27
msgid "**VR:** Oculus Rift, SteamVR"
msgstr "**虚拟现实端:** Oculus Rift, SteamVR"

#: ../../docs/getting_started/editor/unity_to_godot.rst:30
msgid "Scene system"
msgstr "场景系统"

#: ../../docs/getting_started/editor/unity_to_godot.rst:30
msgid "Component/Scene (GameObject > Component)"
msgstr "组件/场景 (游戏物体 > 组件)"

#: ../../docs/getting_started/editor/unity_to_godot.rst:31
msgid "Prefabs"
msgstr "预制体"

#: ../../docs/getting_started/editor/unity_to_godot.rst:30
msgid ""
":ref:`Scene tree and nodes <doc_scenes_and_nodes>`, allowing scenes to be "
"nested and/or inherit other scenes"
msgstr ""
":ref:`场景树和节点<doc_scenes_and_nodes>`，允许场景被嵌套或继承其他场景"

#: ../../docs/getting_started/editor/unity_to_godot.rst:33
msgid "Third-party tools"
msgstr "第三方工具"

#: ../../docs/getting_started/editor/unity_to_godot.rst:33
msgid "Visual Studio or VS Code"
msgstr "Visual Studio 或 VS Code"

#: ../../docs/getting_started/editor/unity_to_godot.rst:33
msgid ":ref:`External editors are possible <doc_external_editor>`"
msgstr ":ref:`可使用外部编辑器 <doc_external_editor>`"

#: ../../docs/getting_started/editor/unity_to_godot.rst:34
msgid ":ref:`Android SDK for Android export <doc_exporting_for_android>`"
msgstr ":ref:`用于导出安卓平台的 Android SDK <doc_exporting_for_android>`"

#: ../../docs/getting_started/editor/unity_to_godot.rst:36
msgid "Killer features"
msgstr "杀手级的功能"

#: ../../docs/getting_started/editor/unity_to_godot.rst:36
msgid "Huge community"
msgstr "庞大的社区"

#: ../../docs/getting_started/editor/unity_to_godot.rst:37
msgid "Large assets store"
msgstr "大型的素材商店"

#: ../../docs/getting_started/editor/unity_to_godot.rst:36
msgid "Scene System"
msgstr "场景系统"

#: ../../docs/getting_started/editor/unity_to_godot.rst:37
msgid ":ref:`Animation Pipeline <doc_animations>`"
msgstr ":ref:`动画管线 <doc_animations>`"

#: ../../docs/getting_started/editor/unity_to_godot.rst:38
msgid ":ref:`Easy to write Shaders <doc_shading_language>`"
msgstr ":ref:`易于书写的着色器 <doc_shading_language>`"

#: ../../docs/getting_started/editor/unity_to_godot.rst:39
msgid "Debug on Device"
msgstr "在设备上排错"

#: ../../docs/getting_started/editor/unity_to_godot.rst:46
msgid "The editor"
msgstr "编辑器"

#: ../../docs/getting_started/editor/unity_to_godot.rst:48
msgid ""
"Godot Engine provides a rich-featured editor that allows you to build your "
"games. The pictures below display both editors with colored blocks to "
"indicate common functionalities."
msgstr ""
"Godot引擎提供了一个功能丰富的编辑器，可让您构建您的游戏。以下的图片展示了带有"
"表示常用功能的色彩块的编辑器。"

#: ../../docs/getting_started/editor/unity_to_godot.rst:55
msgid ""
"Note that Godot editor allows you to dock each panel at the side of the "
"scene editor you wish."
msgstr "请注意，Godot编辑器允许您任意将各个面板停靠在场景编辑器的一侧。"

#: ../../docs/getting_started/editor/unity_to_godot.rst:57
msgid ""
"While both editors may seem similar, there are many differences below the "
"surface. Both let you organize the project using the filesystem, but Godot's "
"approach is simpler with a single configuration file, minimalist text "
"format, and no metadata. All this contributes to Godot being much friendlier "
"to VCS systems, such as Git, Subversion, or Mercurial."
msgstr ""
"虽然这两个编辑器看上去相同，但是在外表之下有着许多的不同。两者都允许您使用文"
"件系统来组织项目，但是Godot的方法更简单，只需要一个非常小的文本格式文件，而不"
"需要元数据。所有这些都使得 Godot 对VCS系统(如 Git ， Subversion 或 "
"Mercurial )更友好。"

#: ../../docs/getting_started/editor/unity_to_godot.rst:62
msgid ""
"Godot's Scene panel is similar to Unity's Hierarchy panel but, as each node "
"has a specific function, the approach used by Godot is more visually "
"descriptive. In other words, it's easier to understand what a specific scene "
"does at a glance."
msgstr ""
"虽然Godot的场景面板和Unity的Hierarchy面板很相似，但是因为每个节点都有特殊的功"
"能，Godot的用法更具有视觉描述性。换句话说，看一眼就能理解一个特定场景的功能。"

#: ../../docs/getting_started/editor/unity_to_godot.rst:66
msgid ""
"The Inspector in Godot is more minimalist and designed to only show "
"properties. Thanks to this, objects can export a much larger amount of "
"useful parameters to the user without having to hide functionality in "
"language APIs. As a plus, Godot allows animating any of those properties "
"visually, so changing colors, textures, enumerations, or even links to "
"resources in real-time is possible without involving code."
msgstr ""
"Godot 的 Inspector 面板更为简单，且它的设计只为显示属性服务。得益于此，对象可"
"以向用户输出大量有用的参数，而无需把功能隐藏在语言 API 中。另外，Godot允许可"
"视化地为任何这些属性制作动画，所以可以在不使用代码的情况下实时改变颜色，纹"
"理，枚举甚至是实时链接资源。"

#: ../../docs/getting_started/editor/unity_to_godot.rst:71
msgid ""
"Finally, the Toolbar at the top of the screen is similar in the sense that "
"it allows controlling the project playback, but projects in Godot run in a "
"separate window, as they don't execute inside the editor (but the tree and "
"objects can still be explored in the debugger window)."
msgstr ""
"最后，屏幕上方的工具条都有着类似的功能，那就是控制项目的播放，但是 Godot 的项"
"目是在独立窗口中运行的，它们不会在编辑器中执行(但是树和对象仍然可以在调试窗口"
"中查看)。"

#: ../../docs/getting_started/editor/unity_to_godot.rst:75
msgid ""
"This approach has the disadvantage that the running game can't be explored "
"from different angles (though this may be supported in the future and "
"displaying collision gizmos in the running game is already possible), but in "
"exchange has several advantages:"
msgstr ""
"这种方法的缺点就是运行中的游戏不能从其他角度观察(尽管未来可能会得到支持，并在"
"运行中的游戏里显示碰撞体 gizmo也有可能)，但是作为交换有几个优点:"

#: ../../docs/getting_started/editor/unity_to_godot.rst:79
msgid ""
"Running the project and closing it is fast (Unity has to save, run the "
"project, close the project, and then reload the previous state)."
msgstr ""
"运行项目与关闭它会非常快( Unity 必须保存，再运行项目，关闭项目，然后重载之前"
"的状态)。"

#: ../../docs/getting_started/editor/unity_to_godot.rst:80
msgid ""
"Live editing is a lot more useful because changes done to the editor take "
"effect immediately in the game and are not lost (nor have to be synced) when "
"the game is closed. This allows fantastic workflows, like creating levels "
"while you play them."
msgstr ""
"实时编辑更加有用，因为对编辑器做的更改会立即在游戏中生效，并且在游戏关闭时不"
"会丢失(也不必同步)。这提供了出色的工作流程，比如在您运行的时候创建关卡。"

#: ../../docs/getting_started/editor/unity_to_godot.rst:81
msgid "The editor is more stable because the game runs in a separate process."
msgstr "编辑器更加稳定，因为游戏运行在一个单独的进程中。"

#: ../../docs/getting_started/editor/unity_to_godot.rst:83
msgid ""
"Finally, the top toolbar includes a menu for remote debugging. These options "
"make it simple to deploy to a device (connected phone, tablet, or browser "
"via HTML5), and debug/live edit on it after the game was exported."
msgstr ""
"最后，顶部的工具条包含了一个远程排错的菜单。这些选项让在设备上的部署变得简单"
"(连接到手机，平板或者是支持HTML5的浏览器)，并可以在游戏导出之后排错/实时编"
"辑。"

#: ../../docs/getting_started/editor/unity_to_godot.rst:88
msgid "The scene system"
msgstr "场景系统"

#: ../../docs/getting_started/editor/unity_to_godot.rst:90
msgid ""
"This is the most important difference between Unity and Godot and, actually, "
"the favourite feature of most Godot users."
msgstr ""
"这是Unity和Godot间最重要的不同点，实际上也是大多数 Godot 用户最喜爱的特性。"

#: ../../docs/getting_started/editor/unity_to_godot.rst:92
msgid ""
"Unity's scene system consists of embedding all the required assets in a "
"scene and linking them together by setting components and scripts to them."
msgstr ""
"Unity的场景系统包含了一个将所有需要的素材嵌入到其中的场景，并通过设置组件和脚"
"本将它们链接在一起。"

#: ../../docs/getting_started/editor/unity_to_godot.rst:95
msgid ""
"Godot's scene system is different: it actually consists of a tree made of "
"nodes. Each node serves a purpose: Sprite, Mesh, Light, etc. Basically, this "
"is similar to the Unity scene system. However, each node can have multiple "
"children, which makes each a subscene of the main scene. This means you can "
"compose a whole scene with different scenes stored in different files."
msgstr ""
"Godot 的场景系统与其不同:它实际上包含一个由节点组成的树。每一个节点都有它的用"
"途:精灵，网格，灯光，等。基本上，这与Unity场景系统类似。但是，每个节点可以有"
"多个子节点，这使得每个节点都成为主场景的子场景。这意味着您可以用不同的场景组"
"成一个完整的场景，存储在不同的文件中。"

#: ../../docs/getting_started/editor/unity_to_godot.rst:100
msgid ""
"For example, think of a platformer level. You would compose it with multiple "
"elements:"
msgstr "例如，一个平台游戏的关卡。您可以用多个元素来组合它:"

#: ../../docs/getting_started/editor/unity_to_godot.rst:102
msgid "Bricks"
msgstr "砖块"

#: ../../docs/getting_started/editor/unity_to_godot.rst:103
msgid "Coins"
msgstr "金币"

#: ../../docs/getting_started/editor/unity_to_godot.rst:104
msgid "The player"
msgstr "游戏角色"

#: ../../docs/getting_started/editor/unity_to_godot.rst:105
msgid "The enemies"
msgstr "敌人"

#: ../../docs/getting_started/editor/unity_to_godot.rst:108
msgid ""
"In Unity, you would put all the GameObjects in the scene: the player, "
"multiple instances of enemies, bricks everywhere to form the ground of the "
"level and then multiple instances of coins all over the level. You would "
"then add various components to each element to link them and add logic in "
"the level: For example, you'd add a BoxCollider2D to all the elements of the "
"scene so that they can collide. This principle is different in Godot."
msgstr ""
"在Unity中，您可以将所有 GameObjects 放入场景中:游戏角色，敌人的多个实例，组成"
"关卡各个地方的砖块，还有放在关卡中的金币的多个实例。然后，您可以将各种组件添"
"加到每个元素以将它们链接起来并添加关卡中的逻辑:例如，您应该会为场景的所有元素"
"各添加一个BoxCollider2D，以便它们可以发生碰撞。这个原则在 Godot中是不同的。"

#: ../../docs/getting_started/editor/unity_to_godot.rst:113
msgid ""
"In Godot, you would split your whole scene into 3 separate, smaller scenes, "
"which you would then instance in the main scene."
msgstr ""
"在Godot中，您要把整个场景分成3个独立的小场景，然后您将在主场景中实例化它们。"

#: ../../docs/getting_started/editor/unity_to_godot.rst:115
msgid "**First, a scene for the Player alone.**"
msgstr "**首先，一个只有游戏角色的场景。**"

#: ../../docs/getting_started/editor/unity_to_godot.rst:117
msgid ""
"Consider the player as a reusable element in other levels. It is composed of "
"one node in particular: an AnimatedSprite node, which contains the sprite "
"textures to form various animations (for example, walking animation)"
msgstr ""
"把游戏角色视为一个在其他关卡中可重用的元素。它通常由一个节点组成:一个精灵动画"
"节点，它包含可生成各种动画的精灵纹理(例如，步行动画)"

#: ../../docs/getting_started/editor/unity_to_godot.rst:120
msgid "**Second, a scene for the Enemy.**"
msgstr "**其次，一个敌人场景。**"

#: ../../docs/getting_started/editor/unity_to_godot.rst:122
msgid ""
"There again, an enemy is a reusable element in other levels. It is almost "
"the same as the Player node - the only differences are the script (that "
"manages AI, mostly) and sprite textures used by the AnimatedSprite."
msgstr ""
"敌人也是其他关卡的可重用元素。它与Player节点几乎相同 - 唯一的区别是 "
"AnimatedSprite 所使用的脚本(主要是管理AI的)和精灵纹理。"

#: ../../docs/getting_started/editor/unity_to_godot.rst:126
msgid "**Lastly, the Level scene.**"
msgstr "**最后，关卡场景。**"

#: ../../docs/getting_started/editor/unity_to_godot.rst:128
msgid ""
"It is composed of Bricks (for platforms), Coins (for the player to grab) and "
"a certain number of instances of the previous Enemy scene. These will be "
"different, separate enemies, whose behaviour and appearance will be the same "
"as defined in the Enemy scene. Each instance is then considered as a node in "
"the Level scene tree. Of course, you can set different properties for each "
"Enemy node (to change its color, for example)."
msgstr ""
"它由砖块(用于平台)，金币(供游戏角色抓取)和一定数量的前一个敌人场景的实例组"
"成。这些将是不同的，独立的敌人，其行为和外观将与“敌人”场景中定义的相同。然后"
"将每个实例视为关卡场景树中的节点。当然，您可以为每个敌人节点设置不同的属性(例"
"如改变它的颜色)。"

#: ../../docs/getting_started/editor/unity_to_godot.rst:134
msgid ""
"Finally, the main scene would then be composed of one root node with 2 "
"children: a Player instance node, and a Level instance node. The root node "
"can be anything, generally a \"root\" type such as \"Node\" which is the "
"most global type, or \"Node2D\" (root type of all 2D-related nodes), "
"\"Spatial\" (root type of all 3D-related nodes) or \"Control\" (root type of "
"all GUI-related nodes)."
msgstr ""
"最后，主场景将由一个有着两个子节点节点的根节点组成:游戏角色实例节点和关卡实例"
"节点。根节点可以是任何东西，通常是“根”类型，例如最高级别全局类型的“节点”，或"
"者“2D节点”(所有2D相关节点的根类型)，“空间”(所有3D相关节点的根类型)或“控制”(所"
"有GUI相关节点的根类型)。"

#: ../../docs/getting_started/editor/unity_to_godot.rst:140
msgid ""
"As you can see, every scene is organized as a tree. The same goes for nodes' "
"properties: you don't *add* a collision component to a node to make it "
"collidable like Unity does. Instead, you make this node a *child* of a new "
"specific node that has collision properties. Godot features various "
"collision types nodes, depending on the usage (see the :ref:`Physics "
"introduction <doc_physics_introduction>`)."
msgstr ""
"正如您所看到的，每个场景由一棵树所组成。节点的属性也是如此:您不必像Unity一样 "
"*添加* 一个碰撞组件到一个节点以使得它可以碰撞。相反，您要将此节点设置为一个具"
"有碰撞属性的新特定节点的 *子节点* 。Godot具有各种碰撞类型节点，具体取决于使用"
"情况(请参阅 :ref:`Physics introduction <doc_physics_introduction>`)。"

#: ../../docs/getting_started/editor/unity_to_godot.rst:145
msgid ""
"Question: What are the advantages of this system? Wouldn't this system "
"potentially increase the depth of the scene tree? Besides, Unity allows "
"organizing GameObjects by putting them in empty GameObjects."
msgstr ""
"问题:这个系统的优点是什么？这个系统不会增加场景树的深度吗？此外，Unity允许通"
"过将 GameObjects 放置在空的 GameObjects 中来组织他们。"

#: ../../docs/getting_started/editor/unity_to_godot.rst:147
msgid ""
"First, this system is closer to the well-known object-oriented paradigm: "
"Godot provides a number of nodes which are not clearly \"Game Objects\", but "
"they provide their children with their own capabilities: this is inheritance."
msgstr ""
"首先，这个系统更接近于众所周知的面向对象的标准: Godot 提供了许多不清楚“游戏对"
"象”的节点，但它们为子节点提供了自己本身的功能:这就是继承。"

#: ../../docs/getting_started/editor/unity_to_godot.rst:148
msgid ""
"Second, it allows the extraction of a subtree of the scene to make it a "
"scene of its own, which answers the second and third questions: even if a "
"scene tree gets too deep, it can be split into smaller subtrees. This also "
"allows a better solution for reusability, as you can include any subtree as "
"a child of any node. Putting multiple nodes in an empty GameObject in Unity "
"does not provide the same possibility, apart from a visual organization."
msgstr ""
"其次，它允许抽出场景的一个子树使其成为它自己的一个场景，这回答了第二个和第三"
"个问题:即使场景树变得太深，它也可以拆分成更小的子树。这也提供了有着可重用性的"
"更好的解决方案，因为您可以将任何子树作为任何节点的子节点。除了可视化组织外，"
"将多个节点放入Unity中的空 GameObject 中并不能提供相同的可能性。"

#: ../../docs/getting_started/editor/unity_to_godot.rst:151
msgid ""
"These are the most important concepts you need to remember: \"node\", "
"\"parent node\", and \"child node\"."
msgstr "这些是您需要记住的最重要的概念:“节点”，“父节点”和“子节点”。"

#: ../../docs/getting_started/editor/unity_to_godot.rst:155
#: ../../docs/getting_started/workflow/project_setup/project_organization.rst:4
msgid "Project organization"
msgstr "项目组织"

#: ../../docs/getting_started/editor/unity_to_godot.rst:159
msgid ""
"We previously observed that there is no perfect solution to set a project "
"architecture. Any solution will work for Unity and Godot, so this point has "
"a lesser importance."
msgstr ""
"我们之前观察到，没有完美的设置项目体系结构的解决方案。 任何解决方案都适用于 "
"Unity 和 Godot ，所以这一点不太重要。"

#: ../../docs/getting_started/editor/unity_to_godot.rst:162
msgid ""
"However, we often observe a common architecture for Unity projects, which "
"consists of having one Assets folder in the root directory that contains "
"various folders, one per type of asset: Audio, Graphics, Models, Materials, "
"Scripts, Scenes, etc."
msgstr ""
"但是，我们经常可以注意到Unity项目的一个通用体系结构，它包含一个在根目录中的"
"Assets文件夹，其中包含各种文件夹，每种资源类型各一个:音频，图形，模型，材质，"
"脚本，场景等。"

#: ../../docs/getting_started/editor/unity_to_godot.rst:165
msgid ""
"As described before, the Godot scene system allows splitting scenes into "
"smaller scenes. Since each scene and subscene is actually one scene file in "
"the project, we recommend organizing your project a bit differently. This "
"wiki provides a page for this: :ref:`doc_project_organization`."
msgstr ""
"如前所述，Godot场景系统允许将场景切割成更小的场景。 由于每个场景和子场景实际"
"上都是项目中的一个场景文件，因此我们建议用不同的方法组织您的项目。 这个wiki为"
"此提供了一个页面: :ref:`doc_project_organization` 。"

#: ../../docs/getting_started/editor/unity_to_godot.rst:171
msgid "Where are my prefabs?"
msgstr "我的预制体在哪里？"

#: ../../docs/getting_started/editor/unity_to_godot.rst:173
msgid ""
"The concept of prefabs as provided by Unity is a 'template' element of the "
"scene. It is reusable, and each instance of the prefab that exists in the "
"scene has an existence of its own, but all of them have the same properties "
"as defined by the prefab."
msgstr ""
"Unity 提供的预制体的概念是场景的“模板”元素。 它是可重复使用的，并且场景中存在"
"的预制体的每个实例都有其自己的存在，但它们都具有与预制体所定义的相同的属性。"

#: ../../docs/getting_started/editor/unity_to_godot.rst:177
msgid ""
"Godot does not provide prefabs as such, but this functionality is here, "
"again, filled thanks to its scene system: As we saw, the scene system is "
"organized as a tree. Godot allows you to save a subtree of a scene as its "
"own scene, thus saved into its own file. This new scene can then be "
"instanced as many times as you want. Any change you make to this new, "
"separate scene will be applied to its instances. However, any change you "
"make to the instance will not have any impact on the 'template' scene."
msgstr ""
"Godot不提供这样的预制体，但它的功能由它的场景系统所弥补:正如我们所看到的，场"
"景系统由一棵树组成。 Godot 允许您将场景的一个子树保存为自己的场景，并保存在自"
"己的文件中。这个新场景可以随意多次实例化。您对这个新的独立场景所做的任何更改"
"都将应用于其实例。但是，对实例所做的任何更改都不会对“模板”场景产生任何影响。"

#: ../../docs/getting_started/editor/unity_to_godot.rst:185
msgid ""
"To be precise, you can modify the parameters of the instance in the "
"Inspector panel. However, the nodes that compose this instance are locked "
"although you can unlock them if you need to by right-clicking the instance "
"in the Scene tree and selecting \"Editable children\" in the menu. You don't "
"need to do this to add new children nodes to this node, but it is possible. "
"Remember that these new children will belong to the instance, not the "
"'template' scene. If you want to add new children to all the instances of "
"your 'template' scene, then you need to add them in the 'template' scene."
msgstr ""
"确切地说，您可以在 Inspector 面板中修改实例的参数。但是，组成此实例的节点已锁"
"定，如果有必要请右键单击“场景”树中的实例并在菜单中选择“可编辑的子项”，即可以"
"解锁它们。 您不需要这样做来为此节点添加新的子节点，但请记住，这些新子节点将属"
"于该实例，而不是“模板”场景。"

#: ../../docs/getting_started/editor/unity_to_godot.rst:195
msgid "Glossary correspondence"
msgstr "术语对应"

#: ../../docs/getting_started/editor/unity_to_godot.rst:197
msgid "GameObject -> Node"
msgstr "游戏对象 -> 节点"

#: ../../docs/getting_started/editor/unity_to_godot.rst:198
msgid "Add a component -> Inheriting"
msgstr "添加组件 -> 继承"

#: ../../docs/getting_started/editor/unity_to_godot.rst:199
msgid "Prefab -> Externalized branch"
msgstr "预制 -> 外部化分支"

#: ../../docs/getting_started/editor/unity_to_godot.rst:203
msgid "Scripting: GDScript, C# and Visual Script"
msgstr "脚本:GDScript ，C# 和 Visual Script"

#: ../../docs/getting_started/editor/unity_to_godot.rst:206
msgid "Design"
msgstr "设计"

#: ../../docs/getting_started/editor/unity_to_godot.rst:208
msgid ""
"As you may know already, Unity supports C#. C# benefits from its integration "
"with Visual Studio and other features, such as static typing."
msgstr ""
"如您所知，Unity 支持 C#。C# 从与 Visual Studio 集成中受益和其他的功能中受益，"
"例如静态类型。"

#: ../../docs/getting_started/editor/unity_to_godot.rst:210
msgid ""
"Godot provides its own scripting language, :ref:`GDScript <doc_scripting>` "
"as well as support for :ref:`Visual Script <toc-learn-scripting-"
"visual_script>` and :ref:`C# <doc_c_sharp>`. GDScript borrows its syntax "
"from Python, but is not related to it. If you wonder about the reasoning for "
"a custom scripting language, please read the :ref:`doc_gdscript` and :ref:"
"`doc_faq` pages. GDScript is strongly attached to the Godot API and is "
"really easy to learn: Between one evening for an experienced programmer and "
"a week for a complete beginner."
msgstr ""
"Godot提供了自己的脚本语言: :ref:`GDScript <doc_scripting>` ，并且支持: :ref:"
"`Visual Script <toc-learn-scripting-visual_script>` 和 :ref:`C# "
"<doc_c_sharp>` 。 GDScript 从 Python 中借用了它的语法，但与它无关。如果您想知"
"道自定义脚本语言的原因，请阅读: :ref:`doc_gdscript`和 :ref:`doc_faq` 页面。"
"GDScript 非常依赖于Godot API，但它的确很容易学习:一个有经验的程序员一个晚上就"
"能学会，一个真正的初学者也只需一个星期。"

#: ../../docs/getting_started/editor/unity_to_godot.rst:216
msgid ""
"Unity allows you to attach as many scripts as you want to a GameObject. Each "
"script adds a behaviour to the GameObject: For example, you can attach a "
"script so that it reacts to the player's controls, and another that controls "
"its specific game logic."
msgstr ""
"Unity允许您将任意数量的脚本添加到 GameObject 上。每个脚本都会向 GameObject 添"
"加一个行为:例如，您可以添加一个脚本，以便它对游戏角色的控制作出反应，而另一个"
"脚本控制其特定的游戏逻辑。"

#: ../../docs/getting_started/editor/unity_to_godot.rst:220
msgid ""
"In Godot, you can only attach one script per node. You can use either an "
"external GDScript file or include the script directly in the node. If you "
"need to attach more scripts to one node, then you may consider two "
"solutions, depending on your scene and on what you want to achieve:"
msgstr ""
"在Godot中，每个节点只能附加一个脚本。您可以使用外部 GDScript 文件，也可以直接"
"将其包含在节点中。如果您需要将更多脚本附加到一个节点上，那么您可以考虑这两种"
"解决方案，具体取决于您的场景以及您想实现的目标:"

#: ../../docs/getting_started/editor/unity_to_godot.rst:224
msgid ""
"either add a new node between your target node and its current parent, then "
"add a script to this new node."
msgstr ""
"在目标节点和其当前父节点之间添加一个新节点，然后向该新节点添加一个脚本。"

#: ../../docs/getting_started/editor/unity_to_godot.rst:225
msgid ""
"or, you can split your target node into multiple children and attach one "
"script to each of them."
msgstr "或者，您可以将您的目标节点分成多个子节点并为其中的每一个添加一个脚本。"

#: ../../docs/getting_started/editor/unity_to_godot.rst:227
msgid ""
"As you can see, it can be easy to turn a scene tree to a mess. This is why "
"it is important to have a real reflection and consider splitting a "
"complicated scene into multiple, smaller branches."
msgstr ""
"正如您所看到的，把场景树变成一团糟可能很容易。 这就是拥有一个真正的反射的重要"
"性，并且考虑把一个复杂的场景分成多个小的分支。"

#: ../../docs/getting_started/editor/unity_to_godot.rst:231
msgid "Connections: groups and signals"
msgstr "连接:组和信号"

#: ../../docs/getting_started/editor/unity_to_godot.rst:233
#, fuzzy
msgid ""
"You can control nodes by accessing them via script and calling built-in or "
"user-defined functions on them. You can also place nodes in a group and call "
"functions on all nodes in this group. See more in the :ref:`scripting "
"documentation <doc_scripting_continued>`."
msgstr ""
"您可以通过使用脚本访问它们来控制节点，并调用它们上的函数(内置的或用户定义"
"的)。但还有:您也可以将它们放在一个组中，并调用一个在该组中包含的所有节点上的"
"函数！解释如下: :ref:`this page <doc_scripting_continued>` 。"

#: ../../docs/getting_started/editor/unity_to_godot.rst:238
#, fuzzy
msgid ""
"Nodes can send a signal when a specified action occurs. A signal can be set "
"to call any function. You can define custom signals and specify when they "
"are triggered. See more in the :ref:`signals documentation "
"<doc_gdscript_signals>`."
msgstr ""
"但还有！ 某些节点在某些操作发生时会抛出信号。您可以连接这些信号以便在触发的时"
"候来调用特定的函数。请注意，您可以定义自己的信号并随时发送。这个功能记录在`这"
"里 <../scripting/gdscript/gdscript_basics.html#signals>`_ 。"

#: ../../docs/getting_started/editor/unity_to_godot.rst:243
#, fuzzy
msgid "Script serialization"
msgstr "脚本序列化"

#: ../../docs/getting_started/editor/unity_to_godot.rst:245
msgid "Unity can handle script serialization in two ways:"
msgstr "Unity可以通过两种方式处理脚本序列化:"

#: ../../docs/getting_started/editor/unity_to_godot.rst:247
msgid ""
"Implicit: All public fields in a class are automatically serialized if the "
"type is a serializable type (``Dictionary`` is not serializable)."
msgstr ""
"隐式: 如果类型是可序列化类型 ( ``字典`` 是不可序列化的), 则类中的所有公共字段"
"都将自动序列化。"

#: ../../docs/getting_started/editor/unity_to_godot.rst:248
msgid ""
"Explicit: Non-public fields can be serialized using the ``[SerializeField]`` "
"attribute."
msgstr "显式: 可以使用 ``[SerializeField]`` 属性序列化非公共字段。"

#: ../../docs/getting_started/editor/unity_to_godot.rst:250
#, fuzzy
msgid ""
"Godot also has a built-in script serialization system, but it works only "
"explicitly. You can serialize any serializable type (:ref:`built-in and "
"various engine types <doc_binary_serialization_api>`, including :ref:"
"`class_Array` and :ref:`class_Dictionary`) using the ``export`` keyword. See "
"the :ref:`exports documentation <doc_gdscript_exports>` for details."
msgstr ""
"Godot还具有内置脚本序列化系统,，但它仅显式工作。您可以使用导出关键字序列化任"
"何可序列化类型 ( :ref:`built-in and various engine types "
"<doc_binary_serialization_api>` ，包括类 _ array 和类 _ dicary)。此工作流程"
"在 `这里 <../scripting/gdscript/gdscript_basics.html#exports>`_ 进行了说明。"

#: ../../docs/getting_started/editor/unity_to_godot.rst:255
msgid ""
"Unity also has a data type called ``ScriptableObject`` used to serialize "
"custom asset objects. Its equivalent in Godot is the base class for all "
"resources: :ref:`class_Resource`. Creating a script that inherits :ref:"
"`class_Resource` will allow you to create custom serializable objects. More "
"information about resources can be found :ref:`here <doc_resources>`."
msgstr ""
"Unity还具有一个名为 ``ScriptableObject`` 的数据类型, 用于序列化自定义资源对"
"象。它在Godot中的等效项是所有资源的基类: :ref:`class_Resource` 。创建继承 :"
"ref:`class_Resource` 的脚本将允许您创建可自定义可序列化对象。有关资源的更多信"
"息, 请参考 :ref:`这里 <doc_resources>` 。"

#: ../../docs/getting_started/editor/unity_to_godot.rst:260
msgid "Using Godot in C++"
msgstr "在 Godot 中使用 C++"

#: ../../docs/getting_started/editor/unity_to_godot.rst:262
#, fuzzy
msgid ""
"Godot allows you to develop your project directly in C++ by using its API, "
"which is not possible with Unity at the moment. As an example, you can "
"consider Godot Engine's editor as a \"game\" written in C++ using the Godot "
"API."
msgstr ""
"供您参考，Godot 还允许您直接使用其 API 和 C++ 来开发项目，而目前这不适用于 "
"Unity 。 例如，您可以将 Godot 引擎的编辑器视为使用 Godot API 用C++编写的“游"
"戏”。"

#: ../../docs/getting_started/editor/unity_to_godot.rst:265
msgid ""
"If you are interested in using Godot in C++, you may want to start reading "
"the :ref:`Developing in C++ <doc_introduction_to_godot_development>` page."
msgstr ""
"如果您有兴趣在 Godot 中使用 C++，您可能需要阅读 :ref:`用C++开发 "
"<doc_introduction_to_godot_development>` 页面。"

#: ../../docs/getting_started/editor/command_line_tutorial.rst:4
msgid "Command line tutorial"
msgstr "命令行教程"

#: ../../docs/getting_started/editor/command_line_tutorial.rst:8
msgid ""
"Some developers like using the command line extensively. Godot is designed "
"to be friendly to them, so here are the steps for working entirely from the "
"command line. Given the engine relies on almost no external libraries, "
"initialization times are pretty fast, making it suitable for this workflow."
msgstr ""
"一些开发人员喜欢广泛使用命令行。 Godot 被设计为对他们友好，所以这里是完全用命"
"令行工作的步骤。 鉴于引擎几乎没有依赖于外部库，所以初始化时间非常快，使得其适"
"用于此工作流程。"

#: ../../docs/getting_started/editor/command_line_tutorial.rst:15
msgid "Path"
msgstr "路径"

#: ../../docs/getting_started/editor/command_line_tutorial.rst:17
msgid ""
"It is recommended that your Godot binary be in your PATH environment "
"variable, so it can be executed easily from any place by typing ``godot``. "
"You can do so on Linux by placing the Godot binary in ``/usr/local/bin`` and "
"making sure it is called ``godot``."
msgstr ""
"建议您的 Godot 二进制文件位于PATH环境变量中，因此可以通过输入 ``godot`` 从任"
"意位置轻松执行它。 您可以在Linux上通过将Godot二进制文件放入``/ usr / local / "
"bin``中并确保它被命名为``godot``来实现。"

#: ../../docs/getting_started/editor/command_line_tutorial.rst:23
msgid "Setting the project path"
msgstr "设置项目路径"

#: ../../docs/getting_started/editor/command_line_tutorial.rst:25
msgid ""
"Depending on where your Godot binary is located and what your current "
"working directory is, you may need to set the path to your project for any "
"of the following commands to work correctly."
msgstr ""
"根据您的 Godot 二进制文件所在的位置以及您当前的工作目录，您可能需要将项目路径"
"设置为以下任一命令才能正常工作。"

#: ../../docs/getting_started/editor/command_line_tutorial.rst:29
msgid ""
"This can be done by giving the path to the ``project.godot`` file of your "
"project as either the first argument, like this:"
msgstr ""
"这需要通过将项目的`` project.godot ``文件的路径作为第一个参数来实现，如下所"
"示:"

#: ../../docs/getting_started/editor/command_line_tutorial.rst:36
msgid "Or by using the ``--path`` argument:"
msgstr "或者使用 ``--path`` 参数:"

#: ../../docs/getting_started/editor/command_line_tutorial.rst:42
msgid ""
"For example, the full command for exporting your game (as explained below) "
"might look like this:"
msgstr "例如，用于导出游戏的完整命令(如下所述)可能看上去是这样的:"

#: ../../docs/getting_started/editor/command_line_tutorial.rst:49
msgid "Creating a project"
msgstr "创建一个项目"

#: ../../docs/getting_started/editor/command_line_tutorial.rst:52
msgid ""
"Creating a project from the command line can be done by navigating the shell "
"to the desired place and making a project.godot file."
msgstr ""
"从命令行创建一个项目非常简单，只需将shell导航到所需的位置，并创建 project."
"godot 文件，即使其为空的。"

#: ../../docs/getting_started/editor/command_line_tutorial.rst:63
msgid "The project can now be opened with Godot."
msgstr "现在可以使用Godot打开该项目。"

#: ../../docs/getting_started/editor/command_line_tutorial.rst:67
msgid "Running the editor"
msgstr "运行编辑器"

#: ../../docs/getting_started/editor/command_line_tutorial.rst:69
msgid ""
"Running the editor is done by executing Godot with the ``-e`` flag. This "
"must be done from within the project directory or a subdirectory, otherwise "
"the command is ignored and the project manager appears."
msgstr ""
"运行编辑器是通过用 ``-e`` 标志执行Godot来完成的。 这必须在项目目录或子目录内"
"完成，否则该命令将被忽略并显示项目管理器。"

#: ../../docs/getting_started/editor/command_line_tutorial.rst:77
msgid ""
"If a scene has been created and saved, it can be edited later by running the "
"same code with that scene as argument."
msgstr ""
"如果已经创建并保存了一个场景，它可以通过运行把场景作为参数的同样的代码来进行"
"编辑。"

#: ../../docs/getting_started/editor/command_line_tutorial.rst:85
msgid "Erasing a scene"
msgstr "删除一个场景"

#: ../../docs/getting_started/editor/command_line_tutorial.rst:87
msgid ""
"Godot is friends with your filesystem and will not create extra metadata "
"files. Use ``rm`` to erase a scene file. Make sure nothing references that "
"scene or else an error will be thrown upon opening."
msgstr ""
"Godot对您的文件系统非常友好，不会创建额外的元数据文件，只需使用 ``rm`` 来删除"
"文件。 确保没有对该场景的引用，否则在打开时会抛出错误。"

#: ../../docs/getting_started/editor/command_line_tutorial.rst:96
msgid "Running the game"
msgstr "运行游戏"

#: ../../docs/getting_started/editor/command_line_tutorial.rst:98
msgid ""
"To run the game, simply execute Godot within the project directory or "
"subdirectory."
msgstr "要运行游戏，只需在项目目录或子目录中执行 Godot 即可。"

#: ../../docs/getting_started/editor/command_line_tutorial.rst:105
msgid ""
"When a specific scene needs to be tested, pass that scene to the command "
"line."
msgstr "当需要测试特定的场景时，将该场景传递给命令行。"

#: ../../docs/getting_started/editor/command_line_tutorial.rst:113
msgid "Debugging"
msgstr "调试"

#: ../../docs/getting_started/editor/command_line_tutorial.rst:115
msgid ""
"Catching errors in the command line can be a difficult task because they "
"just fly by. For this, a command line debugger is provided by adding ``-d``. "
"It works for running either the game or a simple scene."
msgstr ""
"捕捉命令行中的错误可能是一项艰巨的任务，因为它们一闪而过。 为此，通过添加 ``-"
"d`` 来提供命令行调试器。 它适用于运行游戏或简单的场景。"

#: ../../docs/getting_started/editor/command_line_tutorial.rst:132
msgid ""
"Exporting the project from the command line is also supported. This is "
"especially useful for continuous integration setups. The version of Godot "
"that is headless (server build, no video) is ideal for this."
msgstr ""
"从命令行导出项目也被支持。 这对建构持续集成特别有用。 headless的Godot版本(服"
"务器版本，无视频)对此非常理想。"

#: ../../docs/getting_started/editor/command_line_tutorial.rst:141
msgid ""
"The platform names recognized by the ``--export`` switch are the same as "
"displayed in the export wizard of the editor. To get a list of supported "
"platforms from the command line, try exporting to a non-recognized platform "
"and the full listing of platforms your configuration supports will be shown."
msgstr ""
"由 ``--export`` 开关识别的平台名称要与编辑器的导出向导中显示的相同。 要从命令"
"行获取受支持平台的列表，只需尝试导出到未识别的平台，然后就会显示配置支持的完"
"整平台列表。"

#: ../../docs/getting_started/editor/command_line_tutorial.rst:147
msgid ""
"To export a debug version of the game, use the ``--export-debug`` switch "
"instead of ``--export``. Their parameters and usage are the same."
msgstr ""
"要导出游戏的调试版本，请使用 ``--export-debug`` 开关而不是 ``--export`` 。 他"
"们的参数和用法是相同的。"

#: ../../docs/getting_started/editor/command_line_tutorial.rst:151
msgid "Running a script"
msgstr "运行脚本"

#: ../../docs/getting_started/editor/command_line_tutorial.rst:153
msgid ""
"It is possible to run a simple .gd script from the command line. This "
"feature is especially useful in large projects, for batch conversion of "
"assets or custom import/export."
msgstr ""
"可以从命令行运行简单的 .gd 脚本。 此功能在非常大的项目中特别有用，可用于批量"
"转换资源或自定义导入/导出。"

#: ../../docs/getting_started/editor/command_line_tutorial.rst:157
msgid "The script must inherit from SceneTree or MainLoop."
msgstr "该脚本必须继承了场景树或主循环。"

#: ../../docs/getting_started/editor/command_line_tutorial.rst:159
msgid "Here is a simple example of how it works:"
msgstr "下面是一个简单的示例，说明它是如何工作的:"

#: ../../docs/getting_started/editor/command_line_tutorial.rst:170
msgid "And how to run it:"
msgstr "以及如何运行它:"

#: ../../docs/getting_started/editor/command_line_tutorial.rst:177
msgid ""
"If no project.godot exists at the path, current path is assumed to be the "
"current working directory (unless ``-path`` is specified)."
msgstr ""
"如果路径中不存在 project.godot ，则假定当前路径是当前工作目录(除非指定了 ``-"
"path`` 参数)。"

#: ../../docs/getting_started/editor/external_editor.rst:4
msgid "Using an external text editor"
msgstr "使用外部的文本编辑器"

#: ../../docs/getting_started/editor/external_editor.rst:6
msgid ""
"While Godot has an inbuilt text editor, some developers have a tendency to "
"want to use a text editor they are familiar with. Godot provides this option "
"via the options under ``Editor -> Editor Settings -> Text Editor -> "
"External``"
msgstr ""
"虽然 Godot 拥有内置的文本编辑器，但一些开发人员倾向于使用他们熟悉的文本编辑"
"器。 Godot 通过 ``编辑器 ->编辑器设置 ->文本编辑器 ->外部`` 下的选项提供此选"
"项"

#: ../../docs/getting_started/editor/external_editor.rst:13
#, fuzzy
msgid ""
"There are two fields: the executable path and command line flags. The flags "
"allow you to better integrate the editor with Godot. Godot will replace the "
"following inside the flags parameter:"
msgstr ""
"有两个字段:可执行路径和命令行标志。这些标志允许您更好地将编辑器集成到Godot"
"上。 Godot将在标志参数中替换以下内容:"

#: ../../docs/getting_started/editor/external_editor.rst:18
msgid "Field in Exec Flags"
msgstr "Exec 标志中的字段"

#: ../../docs/getting_started/editor/external_editor.rst:18
msgid "Is replaced with"
msgstr "被替换为"

#: ../../docs/getting_started/editor/external_editor.rst:20
msgid "{project}"
msgstr "{project}"

#: ../../docs/getting_started/editor/external_editor.rst:20
msgid "The absolute path to the project directory"
msgstr "项目目录的绝对路径"

#: ../../docs/getting_started/editor/external_editor.rst:22
msgid "{file}"
msgstr "{file}"

#: ../../docs/getting_started/editor/external_editor.rst:22
msgid "The absolute path to the file"
msgstr "文件的绝对路径"

#: ../../docs/getting_started/editor/external_editor.rst:24
msgid "{col}"
msgstr "{col}"

#: ../../docs/getting_started/editor/external_editor.rst:24
msgid "The column number of the error"
msgstr "错误的列号"

#: ../../docs/getting_started/editor/external_editor.rst:26
msgid "{line}"
msgstr "{line}"

#: ../../docs/getting_started/editor/external_editor.rst:26
msgid "The line number of the error"
msgstr "错误的行号"

#: ../../docs/getting_started/editor/external_editor.rst:29
msgid "Some example Exec Flags for various editors include:"
msgstr "各种编辑器的一些示例Exec标志:"

#: ../../docs/getting_started/editor/external_editor.rst:32
msgid "Exec Flags"
msgstr "Exec 标志"

#: ../../docs/getting_started/editor/external_editor.rst:34
#, fuzzy
msgid "Geany/Kate"
msgstr "geany/kate"

#: ../../docs/getting_started/editor/external_editor.rst:34
msgid "{file} --line {line} --column {col}"
msgstr "{file} --行 {line} --列 {col}"

#: ../../docs/getting_started/editor/external_editor.rst:36
#, fuzzy
msgid "Atom/Sublime Text"
msgstr "atom/sublime text"

#: ../../docs/getting_started/editor/external_editor.rst:36
msgid "{file}:{line}"
msgstr "{file}:{line}"

#: ../../docs/getting_started/editor/external_editor.rst:38
#, fuzzy
msgid "JetBrains Rider"
msgstr "jetbrains车手"

#: ../../docs/getting_started/editor/external_editor.rst:38
msgid "--line {line} {file}"
msgstr "--行 {line} {file}"

#: ../../docs/getting_started/editor/external_editor.rst:40
#: ../../docs/development/cpp/configuring_an_ide.rst:267
msgid "Visual Studio Code"
msgstr "Visual Studio Code"

#: ../../docs/getting_started/editor/external_editor.rst:40
msgid "{project} --goto {file}:{line}:{col}"
msgstr "{project} --goto {file}:{line}:{col}"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:4
#, fuzzy
msgid "GDScript basics"
msgstr "GDScript"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:9
msgid ""
"*GDScript* is a high level, dynamically typed programming language used to "
"create content. It uses a syntax similar to `Python <https://en.wikipedia."
"org/wiki/Python_%28programming_language%29>`_ (blocks are indent-based and "
"many keywords are similar). Its goal is to be optimized for and tightly "
"integrated with Godot Engine, allowing great flexibility for content "
"creation and integration."
msgstr ""
"*GDScript* 是一种用于创建内容的高级动态类型化编程语言。它使用类似于 `Python "
"<https://en.wikipedia.org/wiki/Python_%28programming_language%29>`_ 的语法 "
"(块基于索引, 许多关键字相似)。它的目标是针对 godot 引擎进行优化并与之紧密集"
"成, 从而为内容创建和集成提供极大的灵活性。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:17
msgid "History"
msgstr "历史"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:19
msgid ""
"In the early days, the engine used the `Lua <http://www.lua.org>`__ "
"scripting language. Lua is fast, but creating bindings to an object oriented "
"system (by using fallbacks) was complex and slow and took an enormous amount "
"of code. After some experiments with `Python <https://www.python.org>`__, it "
"also proved difficult to embed."
msgstr ""
"在早期, 引擎使用脚本语言。 `Lua <http://www.lua.org>`__ 速度很快, 但创建面向"
"对象的系统的绑定 (通过使用回退) 既复杂又缓慢, 并且需要大量的代码。在用 "
"`Python <https://www.python.org>`__ 进行了一些实验后, 它也被证明是难以嵌入"
"的。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:25
msgid ""
"The last third party scripting language that was used for shipped games was "
"`Squirrel <http://squirrel-lang.org>`__, but it was dropped as well. At that "
"point, it became evident that a custom scripting language could more "
"optimally make use of Godot's particular architecture:"
msgstr ""
"最后一种第三方脚本语言是 `Squirrel <http://squirrel-lang.org>`__，但它也被删"
"除了。在这一点上，很明显定制脚本语言可以更好地利用Godot的特殊架构:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:30
msgid ""
"Godot embeds scripts in nodes. Most languages are not designed with this in "
"mind."
msgstr "Godot在节点中嵌入脚本。大多数语言的设计都没有考虑到这一点。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:32
msgid ""
"Godot uses several built-in data types for 2D and 3D math. Script languages "
"do not provide this, and binding them is inefficient."
msgstr ""
"Godot为2D和3D数学使用了几种内置的数据类型。脚本语言不提供这种功能，而且绑定它"
"们是低效的。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:34
msgid ""
"Godot uses threads heavily for lifting and initializing data from the net or "
"disk. Script interpreters for common languages are not friendly to this."
msgstr ""
"Godot大量使用线程来提升和初始化来自网络或磁盘的数据。公共语言的脚本解释器对此"
"并不友好。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:37
msgid ""
"Godot already has a memory management model for resources, most script "
"languages provide their own, which results in duplicate effort and bugs."
msgstr ""
"Godot已经为资源提供了一个内存管理模型，大多数脚本语言都提供了自己的内存管理模"
"型(这会导致重复的工作和错误)。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:40
msgid ""
"Binding code is always messy and results in several failure points, "
"unexpected bugs and generally low maintainability."
msgstr "绑定代码总是很混乱，会导致多个故障点、意外错误和通常较低的可维护性。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:43
msgid ""
"The result of these considerations is *GDScript*. The language and "
"interpreter for GDScript ended up being smaller than the binding code itself "
"for Lua and Squirrel, while having equal functionality. With time, having a "
"built-in language has proven to be a huge advantage."
msgstr ""
"这些考虑的结果是 *GDScript* 。GDScript的语言和解释器最终比Lua和Squirrel的绑定"
"代码本身要小，同时具有相同的功能。随着时间的推移，拥有一种内置的语言已经被证"
"明是一个巨大的优势。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:49
msgid "Example of GDScript"
msgstr "GDScript的示例"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:51
msgid ""
"Some people can learn better by taking a look at the syntax, so here's a "
"simple example of how GDScript looks."
msgstr "有些人可以通过查看语法来更好地学习，下面是GDScript的一个简单示例。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:129
msgid ""
"If you have previous experience with statically typed languages such as C, C+"
"+, or C# but never used a dynamically typed one before, it is advised you "
"read this tutorial: :ref:`doc_gdscript_more_efficiently`."
msgstr ""
"如果您以前有过静态类型语言(如C、C++或C语言)的经验，但以前从未使用过动态类型的"
"语言，建议您阅读本教程: :ref:`doc_gdscript_more_efficiently`."

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:134
msgid "Language"
msgstr "语言"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:136
msgid ""
"In the following, an overview is given to GDScript. Details, such as which "
"methods are available to arrays or other objects, should be looked up in the "
"linked class descriptions."
msgstr ""
"下面将对GDScript进行概述。有关数组或其他对象可用的方法等细节，应在链接类描述"
"中查找。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:141
msgid "Identifiers"
msgstr "标识符"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:143
msgid ""
"Any string that restricts itself to alphabetic characters (``a`` to ``z`` "
"and ``A`` to ``Z``), digits (``0`` to ``9``) and ``_`` qualifies as an "
"identifier. Additionally, identifiers must not begin with a digit. "
"Identifiers are case-sensitive (``foo`` is different from ``FOO``)."
msgstr ""
"任何限制自己为字母字符( ``a`` 到 ``z`` 和 ``A`` 到 ``Z`` )、数字( ``0`` 到 "
"``9`` )和 ``_`` 的字符串都可以作为标识符。此外，标识符不能以数字开头。标识符"
"区分大小写( ``foo`` 和 ``FOO`` 是不同的)。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:149
msgid "Keywords"
msgstr "关键词"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:151
msgid ""
"The following is the list of keywords supported by the language. Since "
"keywords are reserved words (tokens), they can't be used as identifiers. "
"Operators (like ``in``, ``not``, ``and`` or ``or``) and names of built-in "
"types as listed in the following sections are also reserved."
msgstr ""
"下面是该语言支持的关键字列表。由于关键字是保留字(令牌)，它们不能用作标识符。"
"操作符(如 ``in`` , ``not`` , ``and`` 或 ``or`` )以及下面列出的内置类型的名称"
"也是保留的。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:156
msgid ""
"Keywords are defined in the `GDScript tokenizer <https://github.com/"
"godotengine/godot/blob/master/modules/gdscript/gdscript_tokenizer.cpp>`_ in "
"case you want to take a look under the hood."
msgstr ""
"关键字定义在 `GDScript tokenizer <https://github.com/godotengine/godot/blob/"
"master/modules/gdscript/gdscript_tokenizer.cpp>`_ 中，以防您想了解其中的内"
"幕。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:160
msgid "Keyword"
msgstr "关键字"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:160
#: ../../docs/getting_started/scripting/gdscript/gdscript_styleguide.rst:7
#: ../../docs/getting_started/workflow/assets/importing_images.rst:50
#: ../../docs/tutorials/inputs/inputevent.rst:130
#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:27
#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:21
#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:322
#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:366
#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:434
#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:15
#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:121
#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:175
#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:288
#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:17
#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:95
#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:144
#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:193
#: ../../docs/tutorials/shading/shading_reference/particle_shader.rst:30
#: ../../docs/tutorials/shading/shading_reference/particle_shader.rst:51
#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:92
#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:158
#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:218
#: ../../docs/tutorials/plugins/editor/import_plugins.rst:242
#: ../../docs/tutorials/misc/binary_serialization_api.rst:92
#: ../../docs/tutorials/misc/binary_serialization_api.rst:101
#: ../../docs/tutorials/misc/binary_serialization_api.rst:110
#: ../../docs/tutorials/misc/binary_serialization_api.rst:119
#: ../../docs/tutorials/misc/binary_serialization_api.rst:132
#: ../../docs/tutorials/misc/binary_serialization_api.rst:143
#: ../../docs/tutorials/misc/binary_serialization_api.rst:158
#: ../../docs/tutorials/misc/binary_serialization_api.rst:171
#: ../../docs/tutorials/misc/binary_serialization_api.rst:190
#: ../../docs/tutorials/misc/binary_serialization_api.rst:205
#: ../../docs/tutorials/misc/binary_serialization_api.rst:220
#: ../../docs/tutorials/misc/binary_serialization_api.rst:239
#: ../../docs/tutorials/misc/binary_serialization_api.rst:264
#: ../../docs/tutorials/misc/binary_serialization_api.rst:295
#: ../../docs/tutorials/misc/binary_serialization_api.rst:310
#: ../../docs/tutorials/misc/binary_serialization_api.rst:319
#: ../../docs/tutorials/misc/binary_serialization_api.rst:330
#: ../../docs/tutorials/misc/binary_serialization_api.rst:340
#: ../../docs/tutorials/misc/binary_serialization_api.rst:359
#: ../../docs/tutorials/misc/binary_serialization_api.rst:371
#: ../../docs/tutorials/misc/binary_serialization_api.rst:383
#: ../../docs/tutorials/misc/binary_serialization_api.rst:396
#: ../../docs/tutorials/misc/binary_serialization_api.rst:407
#: ../../docs/tutorials/misc/binary_serialization_api.rst:418
#: ../../docs/tutorials/misc/binary_serialization_api.rst:426
#: ../../docs/tutorials/misc/binary_serialization_api.rst:439
#: ../../docs/tutorials/misc/binary_serialization_api.rst:452
#: ../../docs/tutorials/misc/binary_serialization_api.rst:467
msgid "Description"
msgstr "描述"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:162
msgid "if"
msgstr "if"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:162
#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:164
#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:166
msgid "See `if/else/elif`_."
msgstr "见 `if/else/elif`_."

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:164
msgid "elif"
msgstr "elif"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:166
msgid "else"
msgstr "else"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:168
#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:817
msgid "for"
msgstr "for"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:168
msgid "See for_."
msgstr "见 for_."

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:170
#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:806
msgid "while"
msgstr "while"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:170
msgid "See while_."
msgstr "见 while_."

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:172
#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:846
msgid "match"
msgstr "match"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:172
msgid "See match_."
msgstr "见 match_."

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:174
msgid "break"
msgstr "break"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:174
msgid "Exits the execution of the current ``for`` or ``while`` loop."
msgstr "退出当前 ``for`` 或 ``while`` 循环的执行。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:176
msgid "continue"
msgstr "continue"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:176
msgid ""
"Immediately skips to the next iteration of the ``for`` or ``while`` loop."
msgstr "立即跳到 ``for`` 或 ``while`` 循环的下一个迭代。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:178
msgid "pass"
msgstr "pass"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:178
msgid ""
"Used where a statement is required syntactically but execution of code is "
"undesired, e.g. in empty functions."
msgstr "在语法上要求语句但不希望执行代码的地方使用，例如在空函数中。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:180
msgid "return"
msgstr "return"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:180
msgid "Returns a value from a function."
msgstr "从函数返回一个值。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:182
msgid "class"
msgstr "class"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:182
msgid "Defines a class."
msgstr "定义一个类。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:184
msgid "extends"
msgstr "extends"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:184
msgid "Defines what class to extend with the current class."
msgstr "定义用当前类扩展什么类。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:186
#: ../../docs/tutorials/i18n/locales.rst:360
msgid "is"
msgstr "is"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:186
msgid ""
"Tests whether a variable extends a given class, or is of a given built-in "
"type."
msgstr "测试变量是扩展给定的类，还是具有给定的内置类型。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:188
msgid "as"
msgstr "as"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:188
msgid "Cast the value to a given type if possible."
msgstr "如果可能，将值转换为给定类型。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:190
msgid "self"
msgstr "self"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:190
msgid "Refers to current class instance."
msgstr "引用当前类实例。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:192
msgid "tool"
msgstr "tool"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:192
msgid "Executes the script in the editor."
msgstr "在编辑器中执行脚本。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:194
msgid "signal"
msgstr "signal"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:194
msgid "Defines a signal."
msgstr "定义一个信号。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:196
msgid "func"
msgstr "func"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:196
msgid "Defines a function."
msgstr "定义一个函数。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:198
msgid "static"
msgstr "static"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:198
msgid "Defines a static function. Static member variables are not allowed."
msgstr "定义一个静态函数。静态成员变量是不允许的。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:200
msgid "const"
msgstr "const"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:200
msgid "Defines a constant."
msgstr "定义一个常量。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:202
msgid "enum"
msgstr "enum"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:202
msgid "Defines an enum."
msgstr "定义一个枚举。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:204
msgid "var"
msgstr "var"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:204
msgid "Defines a variable."
msgstr "定义一个变量。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:206
msgid "onready"
msgstr "onready"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:206
msgid ""
"Initializes a variable once the Node the script is attached to and its "
"children are part of the scene tree."
msgstr "在脚本所附加的节点及其子节点成为场景树的一部分后初始化变量。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:208
msgid "export"
msgstr "export"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:208
msgid ""
"Saves a variable along with the resource it's attached to and makes it "
"visible and modifiable in the editor."
msgstr "保存一个变量及其附加的资源，并使其在编辑器中可见和可修改。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:210
msgid "setget"
msgstr "setget"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:210
msgid "Defines setter and getter functions for a variable."
msgstr "为变量定义setter和getter函数。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:212
msgid "breakpoint"
msgstr "breakpoint"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:212
msgid "Editor helper for debugger breakpoints."
msgstr "调试器断点的编辑器助手。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:214
msgid "preload"
msgstr "preload"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:214
msgid "Preloads a class or variable. See `Classes as resources`_."
msgstr "预加载类或变量。请参见 `Classes as resources`_."

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:216
msgid "yield"
msgstr "yield"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:216
msgid "Coroutine support. See `Coroutines with yield`_."
msgstr "协同程序支持。参见 `Coroutines with yield`_."

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:218
msgid "assert"
msgstr "assert"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:218
msgid ""
"Asserts a condition, logs error on failure. Ignored in non-debug builds. See "
"`Assert keyword`_."
msgstr ""
"声明一个条件，在失败时记录错误。在非调试构建中被忽略。参见 `Assert keyword`_."

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:220
msgid "remote"
msgstr "remote"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:220
#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:222
#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:224
#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:226
#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:228
#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:230
msgid ""
"Networking RPC annotation. See :ref:`high-level multiplayer docs "
"<doc_high_level_multiplayer>`."
msgstr ""
"网络RPC注释。参见 :ref:`high-level multiplayer docs "
"<doc_high_level_multiplayer>`."

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:222
msgid "master"
msgstr "master"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:224
msgid "puppet"
msgstr "puppet"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:226
msgid "remotesync"
msgstr "remotesync"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:228
msgid "mastersync"
msgstr "mastersync"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:230
msgid "puppetsync"
msgstr "puppetsync"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:232
msgid "PI"
msgstr "PI"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:232
msgid "PI constant."
msgstr "圆周率常量。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:234
msgid "TAU"
msgstr "TAU"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:234
msgid "TAU constant."
msgstr "TAU 常量。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:236
msgid "INF"
msgstr "INF"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:236
msgid "Infinity constant. Used for comparisons."
msgstr "无穷大常数。用于比较。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:238
msgid "NAN"
msgstr "NAN"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:238
msgid "NAN (not a number) constant. Used for comparisons."
msgstr "NAN(不是一个数字)常数。用于比较。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:242
#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:472
#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:179
msgid "Operators"
msgstr "运算符"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:244
msgid "The following is the list of supported operators and their precedence."
msgstr "下面是支持运算符的列表及其优先级。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:247
msgid "**Operator**"
msgstr "**运算符**"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:247
#: ../../docs/getting_started/workflow/export/feature_tags.rst:33
msgid "**Description**"
msgstr "**描述**"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:249
msgid "``x[index]``"
msgstr "``x[index]``"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:249
msgid "Subscription, Highest Priority"
msgstr "索引,最高优先级"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:251
msgid "``x.attribute``"
msgstr "``x.attribute``"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:251
msgid "Attribute Reference"
msgstr "属性引用"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:253
msgid "``is``"
msgstr "``is``"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:253
msgid "Instance Type Checker"
msgstr "实例类型属性面板"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:255
msgid "``~``"
msgstr "``~``"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:255
msgid "Bitwise NOT"
msgstr "按位取反"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:257
msgid "``-x``"
msgstr "``-x``"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:257
msgid "Negative / Unary Negation"
msgstr "负/一元否定"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:259
msgid "``*`` ``/`` ``%``"
msgstr "``*`` ``/`` ``%``"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:259
msgid "Multiplication / Division / Remainder"
msgstr "乘法/除法/余数"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:261
msgid ""
"These operators have the same behavior as C++. Integer division is truncated "
"rather than returning a fractional number, and the % operator is only "
"available for ints (\"fmod\" for floats)"
msgstr ""
"这些操作符具有与C++相同的行为。整数除法被截断，而不是返回一个小数，%运算符只"
"对整数可用(浮点数用“fmod”)"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:267
#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:134
msgid "``+``"
msgstr "``+``"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:267
msgid "Addition / Concatenation of Arrays"
msgstr "加法/数组的串联"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:269
#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:143
msgid "``-``"
msgstr "``-``"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:269
msgid "Subtraction"
msgstr "减法"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:271
msgid "``<<`` ``>>``"
msgstr "``<<`` ``>>``"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:271
msgid "Bit Shifting"
msgstr "位移位"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:273
msgid "``&``"
msgstr "``&``"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:273
msgid "Bitwise AND"
msgstr "按位与"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:275
msgid "``^``"
msgstr "``^``"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:275
msgid "Bitwise XOR"
msgstr "按位异或"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:277
msgid "``|``"
msgstr "``|``"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:277
msgid "Bitwise OR"
msgstr "按位或"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:279
msgid "``<`` ``>`` ``==`` ``!=`` ``>=`` ``<=``"
msgstr "``<`` ``>`` ``==`` ``!=`` ``>=`` ``<=``"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:279
msgid "Comparisons"
msgstr "比较"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:281
msgid "``in``"
msgstr "``in``"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:281
msgid "Content Test"
msgstr "内容测试"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:283
msgid "``!`` ``not``"
msgstr "``!`` ``not``"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:283
msgid "Boolean NOT"
msgstr "布尔NOT"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:285
msgid "``and`` ``&&``"
msgstr "``and`` ``&&``"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:285
msgid "Boolean AND"
msgstr "布尔AND"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:287
msgid "``or`` ``||``"
msgstr "``or`` ``||``"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:287
msgid "Boolean OR"
msgstr "布尔OR"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:289
msgid "``if x else``"
msgstr "``if x else``"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:289
msgid "Ternary if/else"
msgstr "三元 if/else"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:291
msgid "``=`` ``+=`` ``-=`` ``*=`` ``/=`` ``%=`` ``&=`` ``|=``"
msgstr "``=`` ``+=`` ``-=`` ``*=`` ``/=`` ``%=`` ``&=`` ``|=``"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:291
msgid "Assignment, Lowest Priority"
msgstr "赋值，最低优先级"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:295
msgid "Literals"
msgstr "字面量"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:298
msgid "**Literal**"
msgstr "**字面量**"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:298
#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:242
#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:264
msgid "**Type**"
msgstr "**类型**"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:300
msgid "``45``"
msgstr "``45``"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:300
msgid "Base 10 integer"
msgstr "基数为10的整数"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:302
msgid "``0x8F51``"
msgstr "``0x8F51``"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:302
msgid "Base 16 (hex) integer"
msgstr "基数16(十六进制)整数"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:304
msgid "``3.14``, ``58.1e-10``"
msgstr "``3.14``, ``58.1e-10``"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:304
msgid "Floating point number (real)"
msgstr "浮点数(实数)"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:306
msgid "``\"Hello\"``, ``\"Hi\"``"
msgstr "``\"Hello\"``, ``\"Hi\"``"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:306
msgid "Strings"
msgstr "字符串"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:308
msgid "``\"\"\"Hello\"\"\"``"
msgstr "``\"\"\"您好\"\"\"``"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:308
msgid "Multiline string"
msgstr "多行字符串"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:310
msgid "``@\"Node/Label\"``"
msgstr "``@\"Node/Label\"``"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:310
msgid "NodePath or StringName"
msgstr "节点路径和字符串名称"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:312
msgid "``$NodePath``"
msgstr "``$NodePath``"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:312
msgid "Shorthand for ``get_node(\"NodePath\")``"
msgstr "``get_node(\"NodePath\")`` 的速记"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:316
msgid "Comments"
msgstr "注释"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:318
msgid ""
"Anything from a ``#`` to the end of the line is ignored and is considered a "
"comment."
msgstr "任何从 ``＃`` 开始到行尾的内容都会被忽略，并被视为注释。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:326
msgid ""
"Multi-line comments can be created using \"\"\" (three quotes in a row) at "
"the beginning and end of a block of text. Note that this creates a string, "
"therefore, it will not be stripped away when the script is compiled."
msgstr ""
"可以在文本块的开头和结尾使用\"\"\"(一行三个引号)创建多行注释。注意，这将创建"
"一个字符串，因此，在编译脚本时它不会被删除。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:339
msgid "Built-in types"
msgstr "内置类型"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:341
msgid ""
"Built-in types are stack-allocated. They are passed as values. This means a "
"copy is created on each assignment or when passing them as arguments to "
"functions. The only exceptions are ``Array``\\ s and ``Dictionaries``, which "
"are passed by reference so they are shared. (Not ``PoolArray``\\ s like "
"``PoolByteArray`` though, those are passed as values too, so consider this "
"when deciding which to use!)"
msgstr ""
"内置类型是堆栈分配的。它们作为值传递。这意味着在每次赋值或将赋值作为参数传递"
"给函数时都会创建一个副本。唯一的例外是 ``数组`` \\ s 和 ``字典`` ，它们是通过"
"引用传递的，所以它们是共享的。(不是像 ``PoolArray``\\ s ``PoolByteArray`` 那"
"样，这些也是作为值传递的，所以在决定使用哪个时要考虑这个!)"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:348
msgid "Basic built-in types"
msgstr "基本内置类型"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:350
msgid "A variable in GDScript can be assigned to several built-in types."
msgstr "GDScript中的变量可以分配给多个内置类型。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:353
#: ../../docs/tutorials/misc/binary_serialization_api.rst:25
msgid "null"
msgstr "null"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:355
msgid ""
"``null`` is an empty data type that contains no information and can not be "
"assigned any other value."
msgstr "``null`` 是一个空数据类型，不包含任何信息，不能分配任何其他值。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:359
#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:104
#: ../../docs/tutorials/misc/binary_serialization_api.rst:27
msgid "bool"
msgstr "bool"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:361
msgid "The Boolean data type can only contain ``true`` or ``false``."
msgstr "布尔数据类型只能包含 ``true`` 或 ``false``。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:364
msgid "int"
msgstr "int"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:366
msgid ""
"The integer data type can only contain integer numbers, (both negative and "
"positive)."
msgstr "整数数据类型只能包含整数(包括负数和正数)。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:370
#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:100
#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:166
#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:168
#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:170
#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:172
#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:226
#: ../../docs/tutorials/misc/binary_serialization_api.rst:31
msgid "float"
msgstr "float"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:372
msgid "Used to contain a floating point value (real numbers)."
msgstr "用于包含浮点值(实数)。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:375
msgid ":ref:`String <class_String>`"
msgstr ":ref:`String <class_String>`"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:377
msgid ""
"A sequence of characters in `Unicode format <https://en.wikipedia.org/wiki/"
"Unicode>`_. Strings can contain the `standard C escape sequences <https://en."
"wikipedia.org/wiki/Escape_sequences_in_C>`_. GDScript supports :ref:`format "
"strings aka printf functionality <doc_gdscript_printf>`."
msgstr ""
"`Unicode格式 <https://en.wikipedia.org/wiki/Unicode>`_ 中的字符序列。字符串可"
"以包含 `标准C转义序列 <https://en.wikipedia.org/wiki/"
"Escape_sequences_in_C>`_ 。GDScript支持 :ref:`格式化字符串即printf功能 "
"<doc_gdscript_printf>`。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:383
msgid "Vector built-in types"
msgstr "内置向量类型"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:386
msgid ":ref:`Vector2 <class_Vector2>`"
msgstr ":ref:`Vector2 <class_Vector2>`"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:388
msgid ""
"2D vector type containing ``x`` and ``y`` fields. Can also be accessed as "
"array."
msgstr "2D向量类型包含 ``x`` 和 ``y`` 字段，也可以像数组一样访问。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:392
msgid ":ref:`Rect2 <class_Rect2>`"
msgstr ":ref:`Rect2 <class_Rect2>`"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:394
msgid ""
"2D Rectangle type containing two vectors fields: ``position`` and ``size``. "
"Alternatively contains an ``end`` field which is ``position+size``."
msgstr ""
"二维矩形类型包含两个向量字段: ``position`` 和 ``size``。或者包含一个 ``end`` "
"字段，该字段是 ``position+size``。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:398
msgid ":ref:`Vector3 <class_Vector3>`"
msgstr ":ref:`Vector3 <class_Vector3>`"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:400
msgid ""
"3D vector type containing ``x``, ``y`` and ``z`` fields. This can also be "
"accessed as an array."
msgstr "3D向量类型包含 ``x`` , ``y`` 与 ``z`` 字段，也能够像数组一样访问。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:404
msgid ":ref:`Transform2D <class_Transform2D>`"
msgstr ":ref:`Transform2D <class_Transform2D>`"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:406
msgid "3x2 matrix used for 2D transforms."
msgstr "用于二维变换的3x2矩阵。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:409
msgid ":ref:`Plane <class_Plane>`"
msgstr ":ref:`Plane <class_Plane>`"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:411
msgid ""
"3D Plane type in normalized form that contains a ``normal`` vector field and "
"a ``d`` scalar distance."
msgstr ""
"3D平面类型的标准形式包含一个 ``normal`` 法向量字段以及一个 ``d`` 距离标量。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:415
msgid ":ref:`Quat <class_Quat>`"
msgstr ":ref:`Quat <class_Quat>`"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:417
msgid ""
"Quaternion is a datatype used for representing a 3D rotation. It's useful "
"for interpolating rotations."
msgstr "四元数是一种用于表示3D旋转的数据类型。它对于内插旋转很有用。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:421
msgid ":ref:`AABB <class_AABB>`"
msgstr ":ref:`AABB <class_AABB>`"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:423
msgid ""
"Axis-aligned bounding box (or 3D box) contains 2 vectors fields: "
"``position`` and ``size``. Alternatively contains an ``end`` field which is "
"``position+size``."
msgstr ""
"轴向包围框(或3D框)包含两个向量字段: ``position`` 和 ``size``。或者包含一个 "
"``end`` 字段，该字段是 ``position+size``。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:428
msgid ":ref:`Basis <class_Basis>`"
msgstr ":ref:`Basis <class_Basis>`"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:430
msgid ""
"3x3 matrix used for 3D rotation and scale. It contains 3 vector fields "
"(``x``, ``y`` and ``z``) and can also be accessed as an array of 3D vectors."
msgstr ""
"3×3矩阵被用于3D旋转与缩放，其包含3个向量字段(``x``, ``y`` 和 ``z``) 并且可以"
"像3D向量组那样访问。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:435
msgid ":ref:`Transform <class_Transform>`"
msgstr ":ref:`Transform <class_Transform>`"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:437
msgid ""
"3D Transform contains a Basis field ``basis`` and a Vector3 field ``origin``."
msgstr "三维变换包含一个基字段 ``basis`` 和一个向量字段 ``origin``。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:441
msgid "Engine built-in types"
msgstr "引擎内置类型"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:444
msgid ":ref:`Color <class_Color>`"
msgstr ":ref:`Color <class_Color>`"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:446
msgid ""
"Color data type contains ``r``, ``g``, ``b``, and ``a`` fields. It can also "
"be accessed as ``h``, ``s``, and ``v`` for hue/saturation/value."
msgstr ""
"颜色数据类型包含 ``r``, ``g``, ``b``, 和 ``a`` 字段。它也可以作为 ``h``, "
"``s``, 和 ``v`` 来访问色相/饱和度/值。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:450
msgid ":ref:`NodePath <class_NodePath>`"
msgstr ":ref:`NodePath <class_NodePath>`"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:452
msgid ""
"Compiled path to a node used mainly in the scene system. It can be easily "
"assigned to, and from, a String."
msgstr ""
"编译路径，到一个主要用在场景系统中的节点。它可以很容易地分配给字符串，或用字"
"符串赋值。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:456
msgid ":ref:`RID <class_RID>`"
msgstr ":ref:`RID <class_RID>`"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:458
msgid "Resource ID (RID). Servers use generic RIDs to reference opaque data."
msgstr "资源ID(RID)。服务器使用通用的RID来引用不透明数据。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:461
msgid ":ref:`Object <class_Object>`"
msgstr ":ref:`Object <class_Object>`"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:463
msgid "Base class for anything that is not a built-in type."
msgstr "任何非内置类型的基类。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:466
msgid "Container built-in types"
msgstr "容器内置类型"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:469
msgid ":ref:`Array <class_Array>`"
msgstr ":ref:`Array <class_Array>`"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:471
msgid ""
"Generic sequence of arbitrary object types, including other arrays or "
"dictionaries (see below). The array can resize dynamically. Arrays are "
"indexed starting from index ``0``. Starting with Godot 2.1, indices may be "
"negative like in Python, to count from the end."
msgstr ""
"任意对象类型的泛型序列，包括其他数组或字典(见下文)。数组可以动态调整大小。数"
"组从索引 ``0`` 开始建立索引。从Godot 2.1开始，索引可能是负的，就像在Python中"
"一样，从尾部开始计数。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:485
msgid ""
"GDScript arrays are allocated linearly in memory for speed. Large arrays "
"(more than tens of thousands of elements) may however cause memory "
"fragmentation. If this is a concern, special types of arrays are available. "
"These only accept a single data type. They avoid memory fragmentation and "
"also use less memory but are atomic and tend to run slower than generic "
"arrays. They are therefore only recommended to use for large data sets:"
msgstr ""
"GDScript数组在内存中按速度线性分配。然而，大型数组(超过数万个元素)可能导致内"
"存碎片。如果这是一个值得关注的特殊类型的数组是可用的。它们只接受单个数据类"
"型。它们避免内存碎片，并且使用较少的内存，但是是原子型的，并且通常比通用数组"
"运行得慢。因此，它们只推荐用于大数据集:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:492
msgid ""
":ref:`PoolByteArray <class_PoolByteArray>`: An array of bytes (integers from "
"0 to 255)."
msgstr ""
":ref:`PoolByteArray <class_PoolByteArray>`: 一个字节数组(从0到255的整数)."

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:493
msgid ":ref:`PoolIntArray <class_PoolIntArray>`: An array of integers."
msgstr ":ref:`PoolIntArray <class_PoolIntArray>`: 一个整数数组."

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:494
msgid ":ref:`PoolRealArray <class_PoolRealArray>`: An array of floats."
msgstr ":ref:`PoolRealArray <class_PoolRealArray>`: 一个浮动数组."

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:495
msgid ":ref:`PoolStringArray <class_PoolStringArray>`: An array of strings."
msgstr ":ref:`PoolStringArray <class_PoolStringArray>`: 一个字符串数组."

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:496
msgid ""
":ref:`PoolVector2Array <class_PoolVector2Array>`: An array of :ref:`Vector2 "
"<class_Vector2>` objects."
msgstr ""
":ref:`PoolVector2Array <class_PoolVector2Array>`: 一个 :ref:`Vector2 "
"<class_Vector2>` 对象的数组."

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:497
msgid ""
":ref:`PoolVector3Array <class_PoolVector3Array>`: An array of :ref:`Vector3 "
"<class_Vector3>` objects."
msgstr ""
":ref:`PoolVector3Array <class_PoolVector3Array>`: 一个 :ref:`Vector3 "
"<class_Vector3>` 对象数组."

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:498
msgid ""
":ref:`PoolColorArray <class_PoolColorArray>`: An array of :ref:`Color "
"<class_Color>` objects."
msgstr ""
":ref:`PoolColorArray <class_PoolColorArray>`: 一个 :ref:`Color "
"<class_Color>` 对象的数组."

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:501
msgid ":ref:`Dictionary <class_Dictionary>`"
msgstr ":ref:`Dictionary <class_Dictionary>`"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:503
msgid "Associative container which contains values referenced by unique keys."
msgstr "包含唯一关键字引用的值的关联容器。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:516
msgid ""
"Lua-style table syntax is also supported. Lua-style uses ``=`` instead of ``:"
"`` and doesn't use quotes to mark string keys (making for slightly less to "
"write). Note however that like any GDScript identifier, keys written in this "
"form cannot start with a digit."
msgstr ""
"还支持Lua风格的表语法。Lua-style使用 ``=`` 而不是 ``:`` ，并且不使用引号来标"
"记字符串键(这样写起来会稍微少一些)。但是请注意，与任何GDScript标识符一样，以"
"这种形式编写的键不能以数字开头。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:530
msgid ""
"To add a key to an existing dictionary, access it like an existing key and "
"assign to it::"
msgstr "若要向现有字典添加键，请像访问现有键一样访问它，并给它赋值::"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:539
#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:228
msgid "Data"
msgstr "数据"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:542
#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:131
#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:86
#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:148
#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:212
msgid "Variables"
msgstr "变量"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:544
msgid ""
"Variables can exist as class members or local to functions. They are created "
"with the ``var`` keyword and may, optionally, be assigned a value upon "
"initialization."
msgstr ""
"变量可以作为类成员存在，也可以作为函数的局部变量存在。它们是用 ``var`` 关键字"
"创建的，并且可以在初始化时指定一个值。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:555
msgid ""
"Variables can optionally have a type specification. When a type is "
"specified, the variable will be forced to have always that same type, and "
"trying to assign an incompatible value will raise an error."
msgstr ""
"变量可以选择具有类型规范。指定类型时，变量将被迫始终保持相同的类型，并且试图"
"分配不兼容的值将引发错误。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:559
msgid ""
"Types are specified in the variable declaration using a ``:`` (colon) symbol "
"after the variable name, followed by the type."
msgstr "类型在变量声明中使用“:”(冒号)符号在变量名后面指定，后面是类型。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:567
msgid ""
"If the variable is initialized within the declaration, the type can be "
"inferred, so it's possible to omit the type name::"
msgstr "如果在声明中初始化了变量，则可以推断类型，因此可以省略类型名称::"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:573
msgid ""
"Type inference is only possible if the assigned value has a defined type, "
"otherwise it will raise an error."
msgstr "类型推断只有在指定的值具有定义的类型时才可能，否则将引发错误。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:576
#: ../../docs/tutorials/shading/shading_reference/shaders.rst:39
msgid "Valid types are:"
msgstr "有效的类型有:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:578
msgid "Built-in types (Array, Vector2, int, String, etc.)"
msgstr "内置类型 (Array, Vector2, int, String, 等.)"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:579
msgid "Engine classes (Node, Resource, Reference, etc.)"
msgstr "引擎类 (Node, Resource, Reference, 等.)"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:580
msgid ""
"Constant names if they contain a script resource (``MyScript`` if you "
"declared ``const MyScript = preload(\"res://my_script.gd\")``)."
msgstr ""
"常量名，如果它们包含脚本资源(``MyScript`` 如果声明 ``const MyScript = "
"preload(\"res://my_script.gd\")``)。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:581
msgid ""
"Other classes in the same script, respecting scope (``InnerClass."
"NestedClass`` if you declared ``class NestedClass`` inside the ``class "
"InnerClass`` in the same scope)"
msgstr ""
"在同一个脚本中的其他类，尊重作用域(如果在相同的范围内，在 ``class "
"InnerClass`` 中声明 ``class NestedClass`` 得到 ``InnerClass.NestedClass`` )"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:582
msgid "Script classes declared with the ``class_name`` keyword."
msgstr "脚本类使用 ``class_name`` 关键字声明。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:585
#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:73
msgid "Casting"
msgstr "转换"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:587
msgid ""
"Values assigned to typed variables must have a compatible type. If it's "
"needed to coerce a value to be of a certain type, in particular for object "
"types, you can use the casting operator ``as``."
msgstr ""
"分配给类型化变量的值必须具有兼容的类型。如果需要强制某个值为某种类型，特别是"
"对象类型，则可以使用类型转换操作符 ``as``。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:591
msgid ""
"Casting between object types results in the same object if the value is of "
"the same type or a subtype of the cast type."
msgstr ""
"如果值属于相同类型或类型转换的子类型，则在相同对象上进行对象类型之间的转换。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:599
msgid ""
"If the value is not a subtype, the casting operation will result in a "
"``null`` value."
msgstr "如果该值不是子类型，则强制转换操作将导致“null”值。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:606
msgid ""
"For built-in types, they will be forcibly converted if possible, otherwise "
"the engine will raise an error."
msgstr "对于内置类型，如果可能，它们将被强制转换，否则引擎将引发错误。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:615
msgid ""
"Casting is also useful to have better type-safe variables when interacting "
"with tree::"
msgstr "在与树交互时，类型转换还有助于拥有更好的类型安全变量::"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:625
#: ../../docs/getting_started/scripting/gdscript/gdscript_styleguide.rst:193
#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:211
#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:22
#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:71
#: ../../docs/development/cpp/object_class.rst:94
msgid "Constants"
msgstr "常量"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:627
msgid ""
"Constants are similar to variables, but must be constants or constant "
"expressions and must be assigned on initialization."
msgstr "常量与变量类似，但必须是常量或常量表达式，并且必须在初始化时分配。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:641
msgid ""
"Although the type of constants is inferred from the assigned value, it's "
"also possible to add explicit type specification::"
msgstr "虽然常量的类型是从指定的值推断出来的，但是也可以添加显式的类型规范::"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:647
msgid "Assigning a value of an incompatible type will raise an error."
msgstr "分配不兼容类型的值将引发错误。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:650
msgid "Enums"
msgstr "枚举"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:652
msgid ""
"Enums are basically a shorthand for constants, and are pretty useful if you "
"want to assign consecutive integers to some constant."
msgstr ""
"枚举基本上是常量的简写，如果您想为某个常量分配连续整数，那么枚举非常有用。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:655
#, fuzzy
msgid ""
"If you pass a name to the enum, it will put all the keys inside a constant "
"dictionary of that name."
msgstr "如果向枚举传递一个名称，那么它也会将所有值放入该名称的常量字典中。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:678
#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:391
#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:245
msgid "Functions"
msgstr "函数"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:680
msgid ""
"Functions always belong to a `class <Classes_>`_. The scope priority for "
"variable look-up is: local → class member → global. The ``self`` variable is "
"always available and is provided as an option for accessing class members, "
"but is not always required (and should *not* be sent as the function's first "
"argument, unlike Python)."
msgstr ""
"函数总是属于 `class <Classes_>`_ 。优先考虑变量查找范围:本地→类成员→全局。 "
"``self`` 变量总是可用的，并作为访问类成员的选项提供，但并不总是必需的(与"
"Python不同， *不* 应该将作为函数的第一个参数发送)。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:693
msgid ""
"A function can ``return`` at any point. The default return value is ``null``."
msgstr "函数可以在任何时候 ``return`` 。默认返回值是 ``null``。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:695
msgid ""
"Functions can also have type specification for the arguments and for the "
"return value. Types for arguments can be added in a similar way to "
"variables::"
msgstr ""
"函数还可以具有参数和返回值的类型规范。参数的类型可以以类似于变量的方式添加::"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:701
msgid ""
"If a function argument has a default value, it's possible to infer the type::"
msgstr "如果函数参数有默认值，可以推断类型::"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:706
msgid ""
"The return type of the function can be specified after the arguments list "
"using the arrow token (``->``)::"
msgstr "函数的返回类型可以在参数列表之后使用箭头标记(``->``)指定::"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:712
msgid ""
"Functions that have a return type **must** return a proper value. Setting "
"the type as ``void`` means the function doesn't return anything. Void "
"functions can return early with the ``return`` keyword, but they can't "
"return any value."
msgstr ""
"有返回类型的函数 **必须** 返回正确的值。将类型设置为 ``void`` 意味着函数不返"
"回任何内容。Void函数可以使用 ``return`` 关键字提前返回，但不能返回任何值。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:721
msgid ""
"Non-void functions must **always** return a value, so if your code has "
"branching statements (such as an ``if``/``else`` construct), all the "
"possible paths must have a return. E.g., if you have a ``return`` inside an "
"``if`` block but not after it, the editor will raise an error because if the "
"block is not executed, the function won't have a valid value to return."
msgstr ""
"非void函数必须 **总是** 返回一个值，所以如果您的代码有分支语句(例如 ``if``/"
"``else`` 构造)，那么所有可能的路径都必须返回一个值。例如，如果在 ``if`` 块中"
"有一个 ``return`` ，但在 ``if`` 块之后没有，编辑器就会抛出一个错误，因为如果"
"没有执行这个块，函数就不会有一个返回的有效值。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:729
msgid "Referencing Functions"
msgstr "引用函数"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:731
msgid ""
"Contrary to Python, functions are *not* first class objects in GDScript. "
"This means they cannot be stored in variables, passed as an argument to "
"another function or be returned from other functions. This is for "
"performance reasons."
msgstr ""
"与Python相反，函数不是GDScript中的第一类对象。这意味着它们不能存储在变量中，"
"不能作为参数传递给另一个函数，也不能从其他函数返回。这是出于性能原因。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:735
msgid ""
"To reference a function by name at runtime, (e.g. to store it in a variable, "
"or pass it to another function as an argument) one must use the ``call`` or "
"``funcref`` helpers::"
msgstr ""
"若要在运行时按名称引用一个函数(例如，将其存储在一个变量中，或将其作为参数传递"
"给另一个函数)，必须使用 ``call`` 或``funcref`` 帮助器::"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:748
msgid ""
"Remember that default functions, like  ``_init``, and most notifications, "
"such as ``_enter_tree``, ``_exit_tree``, ``_process``, ``_physics_process``, "
"etc. are called in all base classes automatically. So there is only a need "
"to call the function explicitly when overloading them in some way."
msgstr ""
"记住，像 ``_init`` 这样的默认函数，以及 ``_enter_tree`` , ``_exit_tree`` , "
"``_process`` , ``_physics_process`` 等大多数通知都是在所有基类中自动调用的。"
"因此，当以某种方式重载它们时，只需要显式地调用函数。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:756
msgid "Static functions"
msgstr "静态函数"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:758
msgid ""
"A function can be declared static. When a function is static, it has no "
"access to the instance member variables or ``self``. This is mainly useful "
"to make libraries of helper functions:"
msgstr ""
"函数可以声明为静态的。当一个函数是静态的，它不能访问实例成员变量或 "
"``self`` 。这主要用于帮助助手函数库:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:769
msgid "Statements and control flow"
msgstr "声明和控制流程"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:771
msgid ""
"Statements are standard and can be assignments, function calls, control flow "
"structures, etc (see below). ``;`` as a statement separator is entirely "
"optional."
msgstr ""
"语句是标准的，可以是赋值、函数调用、控制流结构等(见下面)。``;`` 作为语句分隔"
"符是完全可选的。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:776
msgid "if/else/elif"
msgstr "if/else/elif"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:778
msgid ""
"Simple conditions are created by using the ``if``/``else``/``elif`` syntax. "
"Parenthesis around conditions are allowed, but not required. Given the "
"nature of the tab-based indentation, ``elif`` can be used instead of "
"``else``/``if`` to maintain a level of indentation."
msgstr ""
"简单的条件是通过使用 ``if``/``else``/``elif`` 语法创建的。条件的括号是允许"
"的，但不是必需的。考虑到基于表的缩进的性质，可以使用 ``elif`` 而不是 "
"``else``/``if`` 来维持缩进的级别。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:792
msgid "Short statements can be written on the same line as the condition::"
msgstr "简短陈述可以写在与条件相同的行上::"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:799
msgid ""
"Sometimes you might want to assign a different initial value based on a "
"boolean expression. In this case, ternary-if expressions come in handy::"
msgstr ""
"有时您可能希望基于布尔表达式分配不同的初始值。在这种情况下，ternary-if表达式"
"派上用场::"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:808
msgid ""
"Simple loops are created by using ``while`` syntax. Loops can be broken "
"using ``break`` or continued using ``continue``:"
msgstr ""
"简单的循环是使用 ``while`` 语法创建的。可以使用 ``break`` 来中断循环，或者使"
"用 ``continue`` 来继续:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:819
msgid ""
"To iterate through a range, such as an array or table, a *for* loop is used. "
"When iterating over an array, the current array element is stored in the "
"loop variable. When iterating over a dictionary, the *index* is stored in "
"the loop variable."
msgstr ""
"要遍历一个范围(如数组或表)，使用 *for* 循环。在数组上迭代时，当前数组元素存储"
"在循环变量中。在遍历字典时， *index* 存储在循环变量中。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:848
msgid ""
"A ``match`` statement is used to branch execution of a program. It's the "
"equivalent of the ``switch`` statement found in many other languages, but "
"offers some additional features."
msgstr ""
"``match`` 语句用于转移程序的执行。它相当于在许多其他语言中出现的 ``switch`` "
"语句，但提供了一些附加功能。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:851
msgid "Basic syntax:"
msgstr "基本语法:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:864
msgid "**Crash-course for people who are familiar with switch statements**:"
msgstr "**对于熟悉开关语句的人的速成课程**:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:866
msgid "Replace ``switch`` with ``match``"
msgstr "将 ``switch`` 替换为 ``match``"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:867
msgid "Remove ``case``"
msgstr "删除 ``case``"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:868
#, fuzzy
msgid ""
"Remove any ``break``\\ s. If you don't want to ``break`` by default, you can "
"use ``continue`` for a fallthrough."
msgstr ""
"删除任何 ``break`` 。如果默认情况下不想用 ``break`` ，可以使用 ``continue`` "
"作为故障转移。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:869
msgid "Change ``default`` to a single underscore."
msgstr "将 ``default`` 更改为单个下划线。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:872
msgid "**Control flow**:"
msgstr "**控制流**:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:874
msgid ""
"The patterns are matched from top to bottom. If a pattern matches, the "
"corresponding block will be executed. After that, the execution continues "
"below the ``match`` statement. If you want to have a fallthrough, you can "
"use ``continue`` to stop execution in the current block and check the ones "
"below it."
msgstr ""
"图案从上到下都是匹配的。如果模式匹配，则执行相应的块。然后，在 ``match`` 语句"
"下面继续执行。如果您希望有一个下降，您可以使用 ``continue`` 来停止当前块中的"
"执行，并检查它下面的那些。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:878
msgid "There are 6 pattern types:"
msgstr "有6中模式类型:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:890
msgid "constant pattern"
msgstr "常数模式"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:881
msgid "constant primitives, like numbers and strings ::"
msgstr "常量原语，如数字和字符串::"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:902
msgid "variable pattern"
msgstr "变量模式"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:893
msgid "matches the contents of a variable/enum ::"
msgstr "匹配变量/枚举的内容::"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:916
msgid "wildcard pattern"
msgstr "通配符模式"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:905
msgid "This pattern matches everything. It's written as a single underscore."
msgstr "这个模式匹配所有内容。它被写成一个下划线。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:907
msgid ""
"It can be used as the equivalent of the ``default`` in a ``switch`` "
"statement in other languages. ::"
msgstr "在其他语言中，它可以用作 ``switch`` 语句中 ``default`` 的等效项。::"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:929
msgid "binding pattern"
msgstr "绑定模式"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:919
msgid ""
"A binding pattern introduces a new variable. Like the wildcard pattern, it "
"matches everything - and also gives that value a name. It's especially "
"useful in array and dictionary patterns. ::"
msgstr ""
"绑定模式引入了一个新变量。与通配符模式类似，它匹配所有内容，并为该值提供一个"
"名称。它在数组和字典模式中特别有用。::"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:948
msgid "array pattern"
msgstr "数组模式"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:932
msgid ""
"matches an array. Every single element of the array pattern is a pattern "
"itself, so you can nest them."
msgstr "匹配一个数组。数组模式的每个元素本身就是一个模式，因此可以嵌套它们。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:934
msgid ""
"The length of the array is tested first, it has to be the same size as the "
"pattern, otherwise the pattern doesn't match."
msgstr "首先测试数组的长度，它必须与模式相同大小，否则模式不匹配。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:936
msgid ""
"**Open-ended array**: An array can be bigger than the pattern by making the "
"last subpattern ``..``"
msgstr "**开放式数组**: 数组可以通过使最后一个子模式 ``..`` 大于模式"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:938
msgid "Every subpattern has to be comma separated. ::"
msgstr "每个子模式必须用逗号分隔。::"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:973
msgid "dictionary pattern"
msgstr "字典模式"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:951
msgid ""
"Works in the same way as the array pattern. Every key has to be a constant "
"pattern."
msgstr "工作方式与数组模式相同。每个键必须是一个常量模式。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:953
msgid ""
"The size of the dictionary is tested first, it has to be the same size as "
"the pattern, otherwise the pattern doesn't match."
msgstr "首先测试字典的大小，它必须与模式的大小相同，否则模式不匹配。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:955
msgid ""
"**Open-ended dictionary**: A dictionary can be bigger than the pattern by "
"making the last subpattern ``..``"
msgstr "**开放式字典**: 字典可以通过创建最后一个子模式 ``..`` 来大于模式"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:957
msgid "Every subpattern has to be comma separated."
msgstr "每个子模式必须用逗号分隔。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:959
msgid ""
"If you don't specify a value, then only the existence of the key is checked."
msgstr "如果不指定值，则只检查键的存在。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:961
msgid "A value pattern is separated from the key pattern with a ``:`` ::"
msgstr "值模式与键模式之间用一个 ``:`` 分隔开 ::"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:984
msgid "Multipatterns:"
msgstr "多重模式:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:976
msgid ""
"You can also specify multiple patterns separated by a comma. These patterns "
"aren't allowed to have any bindings in them. ::"
msgstr "您还可以指定由逗号分隔的多个模式。这些模式中不允许有任何绑定。::"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:987
msgid "Classes"
msgstr "类型"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:989
msgid ""
"By default, all script files are unnamed classes. In this case, you can only "
"reference them using the file's path, using either a relative or an absolute "
"path. For example, if you name a script file ``character.gd``"
msgstr ""
"默认情况下，所有脚本文件都是未命名的类。在这种情况下，只能使用文件的路径引用"
"它们，使用相对路径或绝对路径。例如，如果您将脚本文件命名为 ``character.gd``"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1004
msgid ""
"Instead, you can give your class a name to register it as a new type in "
"Godot's editor. For that, you use the 'class_name' keyword. You can add an "
"optional comma followed by a path to an image, to use it as an icon. Your "
"class will then appear with its new icon in the editor:"
msgstr ""
"相反，您可以为类指定一个名称，以便在Godot的编辑器中将其注册为新类型。为此，您"
"将使用 'class_name' 关键字。您可以向图像添加一个可选逗号和一个路径，以便将其"
"用作图标。然后，您的类将在编辑器中显示它的新图标:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1019
msgid "Here's a class file example:"
msgstr "下面是一个简单的示例，说明它是如何工作的:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1038
msgid ""
"Godot's class syntax is compact: it can only contain member variables or "
"functions. You can use static functions, but not static member variables. In "
"the same way, the engine initializes variables every time you create an "
"instance, and this includes arrays and dictionaries. This is in the spirit "
"of thread safety, since scripts can be initialized in separate threads "
"without the user knowing."
msgstr ""
"Godot的类语法非常紧凑:它只能包含成员变量或函数。可以使用静态函数，但不能使用"
"静态成员变量。同样，每次创建实例时，引擎都会初始化变量，这包括数组和字典。这"
"是线程安全的精神，因为脚本可以在单独的线程中初始化，而用户并不知道。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1046
msgid "Inheritance"
msgstr "继承"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1048
msgid "A class (stored as a file) can inherit from"
msgstr "类(存储为文件)可以继承"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1050
msgid "A global class"
msgstr "一个全局的类"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1051
msgid "Another class file"
msgstr "另一类文件"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1052
msgid "An inner class inside another class file."
msgstr "另一个类文件中的内部类。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1054
msgid "Multiple inheritance is not allowed."
msgstr "不允许多重继承。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1056
msgid "Inheritance uses the ``extends`` keyword:"
msgstr "继承使用 ``extends`` 关键字:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1070
msgid ""
"To check if a given instance inherits from a given class, the ``is`` keyword "
"can be used:"
msgstr "要检查给定实例是否从给定类继承，可以使用 ``is`` 关键字:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1084
msgid ""
"To call a function in a *base class* (i.e. one ``extend``-ed in your current "
"class), prepend ``.`` to the function name:"
msgstr ""
"要调用 *基类* 中的函数(即当前类 ``extend`` 后的类)，请在函数名前面加上``.``:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1091
msgid ""
"This is especially useful because functions in extending classes replace "
"functions with the same name in their base classes. So if you still want to "
"call them, you can use ``.`` like the ``super`` keyword in other languages:"
msgstr ""
"这特别有用，因为扩展类中的函数会替换基类中同名的函数。所以如果您仍然想调用它"
"们，您可以使用 ``.`` ，这就像其他语言中的 ``super`` 关键字一样:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1101
msgid "Class Constructor"
msgstr "Class Constructor"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1103
msgid ""
"The class constructor, called on class instantiation, is named ``_init``. As "
"mentioned earlier, the constructors of parent classes are called "
"automatically when inheriting a class. So there is usually no need to call "
"``._init()`` explicitly."
msgstr ""
"在类实例化时调用的类构造函数名为“_init”。如前所述，父类的构造函数在继承类时被"
"自动调用。所以通常不需要显式调用' ' ._init() ' '。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1107
msgid ""
"Unlike the call of a regular function, like in the above example with ``."
"some_func``, if the constructor from the inherited class takes arguments, "
"they are passed like this:"
msgstr ""
"不像在上面的示例中调用正则函数 ``some_func ' ' ，如果从继承类的构造函数接受参"
"数，他们被传递如下:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1115
msgid "This is better explained through examples. Say we have this scenario:"
msgstr "通过示例可以更好地解释这一点。假设我们有这样一个场景:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1137
msgid "There are a few things to keep in mind here:"
msgstr "这里有几件事需要记住:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1139
msgid ""
"if the inherited class (``State.gd``) defines a ``_init`` constructor that "
"takes arguments (``e`` in this case), then the inheriting class (``Idle."
"gd``) *has* to define ``_init`` as well and pass appropriate parameters to "
"``_init`` from ``State.gd``"
msgstr ""
"如果继承的类(' State.gd ')定义了一个 ``_init`` 构造函数，该构造函数接受参数"
"(' ' e ' ')，那么继承的类(' ' id .gd ') *必须*定义' ' _init ' '，并从' ' "
"State.gd ' '传递适当的参数给' ' _init ' '"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1142
msgid ""
"``Idle.gd`` can have a different number of arguments than the base class "
"``State.gd``"
msgstr "``Idle.gd`` 可以有与基类 ``State.gd``不同数量的参数"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1143
msgid ""
"in the example above, ``e`` passed to the ``State.gd`` constructor is the "
"same ``e`` passed in to ``Idle.gd``"
msgstr ""
"在上面的示例中，传递到 ``State.gd`` 构造函数的 ``e`` 与传递给 ``Idle.gd`` 的 "
"``e`` 是相同的"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1145
msgid ""
"if ``Idle.gd``'s ``_init`` constructor takes 0 arguments, it still needs to "
"pass some value to the ``State.gd`` base class even if it does nothing. "
"Which brings us to the fact that you can pass literals in the base "
"constructor as well, not just variables. Eg.:"
msgstr ""
"如果 ``Idle.gd`` 的 ``_init`` 构造函数接受0个参数，即使它什么也不做仍然需要将"
"一些值传递到 ``State.gd`` 基类。这就告诉我们，您还可以在基本构造函数中传递文"
"字，而不仅仅是变量。如:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1157
msgid "Inner classes"
msgstr "内部类"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1159
msgid ""
"A class file can contain inner classes. Inner classes are defined using the "
"``class`` keyword. They are instanced using the ``ClassName.new()`` function."
msgstr ""
"类文件可以包含内部类。内部类使用 ``class`` 关键字定义。它们使用 ``ClassName."
"new()`` 函数实例化。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1179
msgid "Classes as resources"
msgstr "类资源"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1181
msgid ""
"Classes stored as files are treated as :ref:`resources <class_GDScript>`. "
"They must be loaded from disk to access them in other classes. This is done "
"using either the ``load`` or ``preload`` functions (see below). Instancing "
"of a loaded class resource is done by calling the ``new`` function on the "
"class object::"
msgstr ""
"以文件形式存储的类被视为 :ref:`resources <class_GDScript>`。必须从磁盘加载它"
"们，才能在其他类中访问它们。这可以使用 ``load`` 或 ``preload`` 函数来完成(见"
"下面)。加载类资源的实例化是通过调用类对象上的 ``new`` 函数来完成的::"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1199
msgid "Exports"
msgstr "导出"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1201
msgid ""
"Class members can be exported. This means their value gets saved along with "
"the resource (e.g. the :ref:`scene <class_PackedScene>`) they're attached "
"to. They will also be available for editing in the property editor. "
"Exporting is done by using the ``export`` keyword::"
msgstr ""
"类成员可以导出。这意味着它们的值与它们所连接的资源一起被保存(例如 :ref:"
"`scene <class_PackedScene>`)。它们还可以在属性面板中进行编辑。导出是通过使"
"用“导出”关键字::"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1210
msgid ""
"An exported variable must be initialized to a constant expression or have an "
"export hint in the form of an argument to the export keyword (see below)."
msgstr ""
"导出的变量必须初始化为常量表达式，或者以导出关键字参数的形式具有导出提示(参见"
"下面)。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1213
msgid ""
"One of the fundamental benefits of exporting member variables is to have "
"them visible and editable in the editor. This way, artists and game "
"designers can modify values that later influence how the program runs. For "
"this, a special export syntax is provided."
msgstr ""
"导出成员变量的基本好处之一是使它们在编辑器中可见并可编辑。通过这种方式，艺术"
"家和游戏设计师可以修改影响程序运行的值。为此，提供了一种特殊的导出语法。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1299
msgid ""
"It must be noted that even if the script is not being run while at the "
"editor, the exported properties are still editable (see below for \"tool\")."
msgstr ""
"必须注意的是，即使脚本在编辑器中没有运行，导出的属性仍然是可编辑的(参见下面"
"的“工具”)。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1304
msgid "Exporting bit flags"
msgstr "导出位标志"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1306
msgid ""
"Integers used as bit flags can store multiple ``true``/``false`` (boolean) "
"values in one property. By using the export hint ``int, FLAGS``, they can be "
"set from the editor:"
msgstr ""
"作为位标志的整数可以在一个属性中存储多个“true”/“false”(boolean)值。通过使用导"
"出提示' ' int, FLAGS ' '，它们可以从编辑器中设置:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1315
msgid ""
"Restricting the flags to a certain number of named flags is also possible. "
"The syntax is similar to the enumeration syntax:"
msgstr "也可以将标志限制为指定数量的标志。语法类似于枚举语法:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1323
msgid ""
"In this example, ``Fire`` has value 1, ``Water`` has value 2, ``Earth`` has "
"value 4 and ``Wind`` corresponds to value 8. Usually, constants should be "
"defined accordingly (e.g. ``const ELEMENT_WIND = 8`` and so on)."
msgstr ""
"在这个示例中， ``Fire`` 的值是1， ``Water`` 的值是2， ``Earth`` 的值是4， "
"``Wind`` 的值是8。通常，常数应该相应地定义。(例如: ``const ELEMENT_WIND = "
"8`` ，以此类推)。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1328
msgid ""
"Using bit flags requires some understanding of bitwise operations. If in "
"doubt, boolean variables should be exported instead."
msgstr "使用位标志需要了解位操作。如果有疑问，应该导出布尔变量。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1332
msgid "Exporting arrays"
msgstr "导出数组"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1334
msgid ""
"Exporting arrays works, but with an important caveat: While regular arrays "
"are created local to every class instance, exported arrays are *shared* "
"between all instances. This means that editing them in one instance will "
"cause them to change in all other instances. Exported arrays can have "
"initializers, but they must be constant expressions."
msgstr ""
"导出数组是可行的，但有一个重要的注意事项:虽然常规数组是在每个类实例本地创建"
"的，但导出的数组是在所有实例之间“共享”的。这意味着在一个实例中编辑它们将导致"
"在所有其他实例中更改它们。导出的数组可以有初始化器，但它们必须是常量表达式。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1371
msgid "Setters/getters"
msgstr "Setters/getters"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1373
msgid ""
"It is often useful to know when a class' member variable changes for "
"whatever reason. It may also be desired to encapsulate its access in some "
"way."
msgstr ""
"知道类的成员变量何时因某种原因发生变化通常很有用。也可能需要以某种方式封装其"
"访问。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1376
msgid ""
"For this, GDScript provides a *setter/getter* syntax using the ``setget`` "
"keyword. It is used directly after a variable definition:"
msgstr ""
"为此，GDScript使用 ``setget`` 关键字提供了一个 *setter/getter* 语法。在变量定"
"义后可直接使用:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1383
msgid ""
"Whenever the value of ``variable`` is modified by an *external* source (i.e. "
"not from local usage in the class), the *setter* function (``setterfunc`` "
"above) will be called. This happens *before* the value is changed. The "
"*setter* must decide what to do with the new value. Vice versa, when "
"``variable`` is accessed, the *getter* function (``getterfunc`` above) must "
"``return`` the desired value. Below is an example:"
msgstr ""
"当 ``变量`` 的值需要被 *外部的* 源(即不是来自类中的本地用法)修改时，必须调用 "
"*setter* 函数(上面的 ``setterfunc`` )。 这发生在值 *改变之前* 。必须用 * "
"setter * 来设置新值。 反之亦然，当访问 ``变量`` 时，必须用 *getter * 函数(上"
"面的 ``getterfunc`` ) ``返回`` 所需的值。 下面是一个示例:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1400
msgid "Either of the *setter* or *getter* functions can be omitted:"
msgstr "*setter* 或者 *getter* 函数都可省略:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1409
msgid ""
"Get/Setters are especially useful when exporting variables to editor in tool "
"scripts or plugins, for validating input."
msgstr ""
"在工具脚本或插件中， Get/Setters可将变量导出到编辑器，这可以用于验证输入。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1412
msgid ""
"As said, *local* access will *not* trigger the setter and getter. Here is an "
"illustration of this:"
msgstr "如上所述， *本地* 访问 *不* 需要触发setter和getter。 这里有个说明:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1427
msgid "Tool mode"
msgstr "工具模式"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1429
msgid ""
"Scripts, by default, don't run inside the editor and only the exported "
"properties can be changed. In some cases, it is desired that they do run "
"inside the editor (as long as they don't execute game code or manually avoid "
"doing so). For this, the ``tool`` keyword exists and must be placed at the "
"top of the file:"
msgstr ""
"默认情况下，脚本不在编辑器中运行，只能更改导出的属性。在某些情况下，确实希望"
"在编辑器中运行脚本(只要它们不执行游戏代码或手动避免那样做)。为此，可以用 "
"``tool`` 关键字并将它放在文件的顶部:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1444
msgid "Memory management"
msgstr "内存管理"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1446
msgid ""
"If a class inherits from :ref:`class_Reference`, then instances will be "
"freed when no longer in use. No garbage collector exists, just reference "
"counting. By default, all classes that don't define inheritance extend "
"**Reference**. If this is not desired, then a class must inherit :ref:"
"`class_Object` manually and must call instance.free(). To avoid reference "
"cycles that can't be freed, a ``weakref`` function is provided for creating "
"weak references."
msgstr ""
"如果一个类继承自 :ref:`class_Reference` , 则实例将在不再使用时被自动释放。 没"
"有垃圾收集器，只有引用计数。 默认情况下，所有未定义继承的类都会扩展 "
"**Reference** 。 如果不希望这样，那么类必须手动继承 :ref:`class_Object` 并且"
"必须调用 instance.free()。 为了避免无法释放的引用循环，一个 ``weakref`` 函数"
"被用来来创建弱引用。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1454
msgid ""
"Alternatively, when not using references, the "
"``is_instance_valid(instance)`` can be used to check if an object has been "
"freed."
msgstr ""
"或者，当不使用引用时，可以使用 ``is_instance_valid(instance)`` 来检查对象是否"
"已被释放。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1463
msgid ""
"Signals are a way to send notification messages from an object that other "
"objects can listen to in a generic way. Create custom signals for a class "
"using the ``signal`` keyword."
msgstr ""
"信号是一种从对象发送通知消息的方式，其他对象可以以通用方式侦听该对象。使用"
"``signal``关键字为类创建自定义信号。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1475
msgid ""
"These signals may be connected to methods in the same manner as you connect "
"built-in signals of nodes such as :ref:`class_Button` or :ref:"
"`class_RigidBody`."
msgstr ""
"这些信号的连接方式可能与连接节点的内置信号相同, 例如： :ref:`class_Button` "
"或 :ref:`class_RigidBody`。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1478
msgid ""
"Here's an example that creates a custom signal in one script and connects "
"the custom signal to a method in a separate script, using the :ref:`Object."
"connect() <class_Object_method_connect>` method:"
msgstr ""
"下面是一个示例, 它在一个脚本中创建自定义信号, 并使用 :ref:`Object.connect() "
"<class_Object_method_connect>` 方法将自定义信号连接到单独脚本中的方法："

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1507
msgid ""
"GDScript can bind arguments to connections between a signal and a method. "
"When the signal is emitted, calling the connected method, the bound argument "
"is given to the method. These bound arguments are specific to the connection "
"rather than the signal or the method, meaning that each connection has "
"unique bindings."
msgstr ""
"gdscript 可以将参数绑定到信号和方法之间的连接。当发出信号时, 调用连接的方法, "
"绑定参数被赋予该方法。这些绑定参数特定于连接, 而不是信号或方法, 这意味着每个"
"连接都有唯一的绑定。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1513
msgid ""
"Here is an example that creates a connection between a button's ``pressed`` "
"signal and a method, binding the button instance to the connection. The "
"handler uses the bound argument to print which button instance was pressed."
msgstr ""
"下面的示例在按钮的 ``pressed`` 信号和方法之间创建连接，将按钮实例绑定到该连"
"接。\n"
"处理程序使用绑定参数打印按下了哪个按钮实例。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1528
msgid ""
"Signals are generated by the :ref:`Object.emit_signal() "
"<class_Object_method_emit_signal>` method which broadcasts the signal and "
"arguments."
msgstr ""
"信号由 :ref:`Object.emit_signal() <class_Object_method_emit_signal>` 方法生"
"成，该方法广播信号和参数。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1531
msgid ""
"Extending a previous example to use all the features of GDScript signals:"
msgstr "扩展前面的示例，使用GDScript信号的所有特性："

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1563
msgid "Coroutines with yield"
msgstr "有yield的协同程序"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1565
msgid ""
"GDScript offers support for `coroutines <https://en.wikipedia.org/wiki/"
"Coroutine>`_ via the ``yield`` built-in function. Calling ``yield()`` will "
"immediately return from the current function, with the current frozen state "
"of the same function as the return value. Calling ``resume`` on this "
"resulting object will continue execution and return whatever the function "
"returns. Once resumed, the state object becomes invalid. Here is an example:"
msgstr ""
"GDScript通过 ``yield`` 内置函数支持 `coroutines <https://en.wikipedia.org/"
"wiki/Coroutine>`_ 。调用 ``yield`` 将立即从当前函数返回，返回值是当前函数的冻"
"结状态。在结果对象上调用 ``resume`` 将会继续执行，并返回函数返回的任何内容。"
"一旦恢复，状态对象就变得无效。下面是一个示例:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1587
#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1611
msgid "Will print:"
msgstr "将打印:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1595
msgid ""
"It is also possible to pass values between yield() and resume(), for example:"
msgstr "还可以在 yield() 和 resume() 之间传递值，例如:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1620
msgid "Coroutines & signals"
msgstr "协程&信号"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1622
msgid ""
"The real strength of using ``yield`` is when combined with signals. "
"``yield`` can accept two arguments, an object and a signal. When the signal "
"is received, execution will recommence. Here are some examples:"
msgstr ""
"使用 ``yield`` 的真正强度是在与信号结合时。 ``yield`` 可以接受两个参数，一个"
"物体和一个信号。当接收到信号时，执行将重新开始。下面是一些示例:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1637
msgid ""
"Coroutines themselves use the ``completed`` signal when they transition into "
"an invalid state, for example:"
msgstr "协同程序本身在转换到无效状态时使用 ``completed`` 信号，例如:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1650
msgid ""
"``my_func`` will only continue execution once both buttons have been pressed."
msgstr "``my_func`` 将只在按钮被按下后继续执行。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1653
msgid "Onready keyword"
msgstr "Onready关键词"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1655
msgid ""
"When using nodes, it's common to desire to keep references to parts of the "
"scene in a variable. As scenes are only warranted to be configured when "
"entering the active scene tree, the sub-nodes can only be obtained when a "
"call to Node._ready() is made."
msgstr ""
"当使用节点时，通常希望在变量中保留对场景部分的引用。由于场景只允许在进入活动"
"场景树时配置，所以子节点只能在 Node._ready() 准备后获得。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1667
msgid ""
"This can get a little cumbersome, especially when nodes and external "
"references pile up. For this, GDScript has the ``onready`` keyword, that "
"defers initialization of a member variable until _ready is called. It can "
"replace the above code with a single line:"
msgstr ""
"这可能会变得有点麻烦，尤其是当节点和外部引用堆积起来时。为此，GDScript具有 "
"``onready`` 关键字，它将成员变量的初始化推迟到调用 until _ready 后。它可以用"
"一行代码替换上面的代码:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1677
msgid "Assert keyword"
msgstr "Assert关键字"

#: ../../docs/getting_started/scripting/gdscript/gdscript_basics.rst:1679
msgid ""
"The ``assert`` keyword can be used to check conditions in debug builds. "
"These assertions are ignored in non-debug builds."
msgstr ""
"``assert`` 关键字可以用来检查调试构建中的条件。这些断言在非调试生成中被忽略。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:4
msgid "GDScript: An introduction to dynamic languages"
msgstr "GDScript:动态语言导论"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:9
msgid ""
"This tutorial aims to be a quick reference for how to use GDScript more "
"efficiently. It focuses on common cases specific to the language, but also "
"covers a lot of information on dynamically typed languages."
msgstr ""
"本教程旨在快速介绍如何更有效地使用GDScript。它只关注该语言的常见情况，但是也"
"涉及许多关于动态类型语言的信息。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:13
msgid ""
"It's meant to be especially useful for programmers with little or no "
"previous experience with dynamically typed languages."
msgstr "对于以前很少或没有使用动态类型语言经验的程序员来说，它特别有用。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:17
msgid "Dynamic nature"
msgstr "动态性"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:20
msgid "Pros & cons of dynamic typing"
msgstr "动态类型的优缺点"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:22
msgid ""
"GDScript is a Dynamically Typed language. As such, its main advantages are "
"that:"
msgstr "GDScript是一种动态类型语言。因此，它的主要优点是:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:25
msgid "The language is simple and easy to learn."
msgstr "这种语言简单易学。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:26
msgid "Most code can be written and changed quickly and without hassle."
msgstr "大多数代码都可以快速地编写和更改，而且没有任何麻烦。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:27
msgid "Less code written means less errors & mistakes to fix."
msgstr "更少的代码编写意味着更少的错误和失误。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:28
msgid "Easier to read the code (less clutter)."
msgstr "更容易阅读代码(减少混乱)。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:29
msgid "No compilation is required to test."
msgstr "测试不需要编译。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:30
msgid "Runtime is tiny."
msgstr "Runtime很小。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:31
msgid "Duck-typing and polymorphism by nature."
msgstr "本质上是鸭子类型和多态性。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:33
msgid "While the main disadvantages are:"
msgstr "主要缺点是:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:35
msgid "Less performance than statically typed languages."
msgstr "比静态类型语言的性能要低。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:36
msgid "More difficult to refactor (symbols can't be traced)"
msgstr "重构更困难(符号无法跟踪)"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:37
msgid ""
"Some errors that would typically be detected at compile time in statically "
"typed languages only appear while running the code (because expression "
"parsing is more strict)."
msgstr ""
"在静态类型语言中，一些通常在编译时检测到的错误只会在运行代码时出现(因为表达式"
"解析更严格)。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:40
msgid ""
"Less flexibility for code-completion (some variable types are only known at "
"run-time)."
msgstr "代码完成的灵活性较低(一些变量类型只在运行时知道)。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:43
msgid ""
"This, translated to reality, means that Godot+GDScript are a combination "
"designed to create games quickly and efficiently. For games that are very "
"computationally intensive and can't benefit from the engine built-in tools "
"(such as the Vector types, Physics Engine, Math library, etc), the "
"possibility of using C++ is present too. This allows you to still create "
"most of the game in GDScript and add small bits of C++ in the areas that "
"need a performance boost."
msgstr ""
"这意味着Godot+GDScript是一个旨在快速高效创造游戏的组合。对于那些计算密集且不"
"能从引擎内置工具(如向量类型、物理引擎、数学库等)中获益的游戏，也可以使用C++。"
"这仍然允许在GDScript中创建整个游戏，并在需要性能提升的地方添加少量C++。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:52
msgid "Variables & assignment"
msgstr "变量与赋值"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:54
msgid ""
"All variables in a dynamically typed language are \"variant\"-like. This "
"means that their type is not fixed, and is only modified through assignment. "
"Example:"
msgstr ""
"动态类型语言中的所有变量都是“变体”的。这意味着它们的类型不是固定的，而是通过"
"赋值修改的。示例:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:58
#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:80
msgid "Static:"
msgstr "静态的:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:66
#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:94
msgid "Dynamic:"
msgstr "动态的:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:75
msgid "As function arguments:"
msgstr "作为函数参数:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:77
msgid ""
"Functions are of dynamic nature too, which means they can be called with "
"different arguments, for example:"
msgstr "函数也是动态的，这意味着它们可以用不同的参数调用，例如:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:107
msgid "Pointers & referencing:"
msgstr "指针和引用:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:109
msgid ""
"In static languages, such as C or C++ (and to some extent Java and C#), "
"there is a distinction between a variable and a pointer/reference to a "
"variable. The latter allows the object to be modified by other functions by "
"passing a reference to the original one."
msgstr ""
"在静态语言(如C或C++)(以及在一定程度上，Java和C#)中，变量和指针/引用与变量之间"
"存在区别。后者通过传递对原始函数的引用，允许其他函数修改对象。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:114
msgid ""
"In C# or Java, everything not a built-in type (int, float, sometimes String) "
"is always a pointer or a reference. References are also garbage-collected "
"automatically, which means they are erased when no longer used. Dynamically "
"typed languages tend to use this memory model, too. Some Examples:"
msgstr ""
"在C# 或Java中，不是内置类型(int，float，有时的String)的任何东西都是指针或引"
"用。引用也是自动收集的垃圾，这意味着它们在不再使用时被删除。动态类型的语言也"
"倾向于使用这种内存模型。一些示例:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:120
msgid "C++:"
msgstr "C++:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:136
msgid "Java:"
msgstr "Java:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:154
msgid "GDScript:"
msgstr "GDScript:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:166
msgid ""
"In GDScript, only base types (int, float, string and the vector types) are "
"passed by value to functions (value is copied). Everything else (instances, "
"arrays, dictionaries, etc) is passed as reference. Classes that inherit :ref:"
"`class_Reference` (the default if nothing is specified) will be freed when "
"not used, but manual memory management is allowed too if inheriting manually "
"from :ref:`class_Object`."
msgstr ""
"在GDScript中，只有基本类型(int、float、string和vector类型)通过值传递给函数(值"
"被复制)。其他所有(实例、数组、字典等)作为引用传递。继承 :ref:"
"`class_Reference` (如果没有指定任何内容，则默认)的类在不使用时将被释放，对手"
"动继承 :ref:`class_Object`的类也允许手动管理内存。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:174
msgid "Arrays"
msgstr "数组"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:176
msgid ""
"Arrays in dynamically typed languages can contain many different mixed "
"datatypes inside and are always dynamic (can be resized at any time). "
"Compare for example arrays in statically typed languages:"
msgstr ""
"动态类型语言中的数组可以包含许多不同的混合数据类型，并且始终是动态的(可以随时"
"调整大小)。 比较静态类型语言中的示例数组:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:203
msgid "And in GDScript:"
msgstr "在GDScript中:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:212
msgid ""
"In dynamically typed languages, arrays can also double as other datatypes, "
"such as lists:"
msgstr "在动态类型语言中，数组也可以作为其他数据类型的两倍存在，例如列表:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:222
msgid "Or unordered sets:"
msgstr "或无序集合:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:231
msgid "Dictionaries"
msgstr "字典"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:233
msgid ""
"Dictionaries are a powerful tool in dynamically typed languages. Most "
"programmers that come from statically typed languages (such as C++ or C#) "
"ignore their existence and make their life unnecessarily more difficult. "
"This datatype is generally not present in such languages (or only in limited "
"form)."
msgstr ""
"字典是动态类型化语言中的一个强大工具。来自静态类型化语言(如C++或C#)的大多数程"
"序员忽略了它们的存在，使它们的工作变得不必要地更加困难。这种数据类型通常不存"
"在于此类语言中(或仅以有限的形式)。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:239
msgid ""
"Dictionaries can map any value to any other value with complete disregard "
"for the datatype used as either key or value. Contrary to popular belief, "
"they are efficient because they can be implemented with hash tables. They "
"are, in fact, so efficient that some languages will go as far as "
"implementing arrays as dictionaries."
msgstr ""
"字典可以将任何值映射到任何其他值，完全不考虑用作键或值的数据类型。与流行的观"
"点相反，它们是有效的，因为它们可以通过哈希表实现。事实上，它们非常高效，一些"
"语言甚至可以像实现字典一样实现数组。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:245
msgid "Example of Dictionary:"
msgstr "字典的示例:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:252
msgid ""
"Dictionaries are also dynamic, keys can be added or removed at any point at "
"little cost:"
msgstr "字典也是动态的，键可以在任何一点添加或删除，花费很少:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:261
msgid ""
"In most cases, two-dimensional arrays can often be implemented more easily "
"with dictionaries. Here's a simple battleship game example:"
msgstr ""
"在大多数情况下，使用字典可以更容易地实现二维数组。这里有一个简单的战舰游戏的"
"示例:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:294
msgid ""
"Dictionaries can also be used as data markup or quick structures. While "
"GDScript's dictionaries resemble python dictionaries, it also supports Lua "
"style syntax and indexing, which makes it useful for writing initial states "
"and quick structs:"
msgstr ""
"字典还可以用作数据标记或快速结构。虽然GDScript字典类似于python字典，但它也支"
"持Lua风格的语法和索引，这使得它对于编写初始状态和快速结构非常有用:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:318
msgid "For & while"
msgstr "For & while"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:320
msgid "Iterating in some statically typed languages can be quite complex:"
msgstr "在一些静态类型的语言中迭代可能非常复杂:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:341
msgid "This is usually greatly simplified in dynamically typed languages:"
msgstr "这通常在动态类型语言中得到极大简化:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:348
msgid ""
"Container datatypes (arrays and dictionaries) are iterable. Dictionaries "
"allow iterating the keys:"
msgstr "容器数据类型(数组和字典)是可迭代的。字典允许迭代键:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:356
msgid "Iterating with indices is also possible:"
msgstr "迭代索引也是可能的:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:363
msgid "The range() function can take 3 arguments:"
msgstr "range()函数可以有3个参数:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:371
msgid "Some statically typed programming language examples:"
msgstr "在一些静态类型的语言中迭代可能非常复杂:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:381
msgid "Translate to:"
msgstr "转变成:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:394
msgid "And backwards looping is done through a negative counter:"
msgstr "反向循环是通过一个负计数器完成的:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:400
msgid "Becomes:"
msgstr "变成:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:408
#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:384
msgid "While"
msgstr "While"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:410
msgid "while() loops are the same everywhere:"
msgstr "while()循环在任何地方都是相同的:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:421
msgid "Custom iterators"
msgstr "自定义迭代器"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:422
msgid ""
"You can create custom iterators in case the default ones don't quite meet "
"your needs by overriding the Variant class's ``_iter_init``, ``_iter_next``, "
"and ``_iter_get`` functions in your script. An example implementation of a "
"forward iterator follows:"
msgstr ""
"如果默认的迭代器不能完全满足您的需求，您可以通过在脚本中覆盖Variant类"
"的“_iter_init”、“_iter_next”和“_iter_get”函数来创建自定义迭代器。前向迭代器的"
"一个示例实现如下:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:454
msgid "And it can be used like any other iterator:"
msgstr "它可以像任何其他迭代器一样使用:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:462
msgid ""
"Make sure to reset the state of the iterator in ``_iter_init``, otherwise "
"nested for-loops that use custom iterators will not work as expected."
msgstr ""
"确保在 ``_iter_init``中重置迭代器的状态，否则使用自定义迭代器的嵌套for循环将"
"无法正常工作。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:466
msgid "Duck typing"
msgstr "鸭子类型"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:468
msgid ""
"One of the most difficult concepts to grasp when moving from a statically "
"typed language to a dynamic one is duck typing. Duck typing makes overall "
"code design much simpler and straightforward to write, but it's not obvious "
"how it works."
msgstr ""
"当从静态类型语言迁移到动态类型语言时，最难掌握的概念之一是鸭子类型。鸭子类型"
"使整个代码设计更加简单和直接，但是它的工作方式并不明显。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:473
msgid ""
"As an example, imagine a situation where a big rock is falling down a "
"tunnel, smashing everything on its way. The code for the rock, in a "
"statically typed language would be something like:"
msgstr ""
"举个示例，想象一个大石头从隧道里掉下来，在路上砸碎了一切。在静态类型语言中石"
"头的代码有点像:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:484
msgid ""
"This way, everything that can be smashed by a rock would have to inherit "
"Smashable. If a character, enemy, piece of furniture, small rock were all "
"smashable, they would need to inherit from the class Smashable, possibly "
"requiring multiple inheritance. If multiple inheritance was undesired, then "
"they would have to inherit a common class like Entity. Yet, it would not be "
"very elegant to add a virtual method ``smash()`` to Entity only if a few of "
"them can be smashed."
msgstr ""
"这样，任何能被岩石砸碎的东西都必须继承Smashable。如果一个人物、敌人、家具、小"
"石块都易碎，他们需要从Smashable类继承，可能需要多次继承。如果不希望进行多重继"
"承，那么它们必须继承像Entity这样的公共类。然而，如果只是其中几个能被粉碎的"
"话，仅仅在Entity中添加一个虚拟方法 ``smash()`` 并不十分优雅。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:492
msgid ""
"With dynamically typed languages, this is not a problem. Duck typing makes "
"sure you only have to define a ``smash()`` function where required and "
"that's it. No need to consider inheritance, base classes, etc."
msgstr ""
"使用动态类型的语言，这将不是问题。鸭子类型确保您只需在需要的地方定义一个 "
"``smash()`` 函数，就行了。无需考虑继承、基类等。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:501
msgid ""
"And that's it. If the object that hit the big rock has a smash() method, it "
"will be called. No need for inheritance or polymorphism. Dynamically typed "
"languages only care about the instance having the desired method or member, "
"not what it inherits or the class type. The definition of Duck Typing should "
"make this clearer:"
msgstr ""
"就是这样。如果击中大岩石的对象有一个 smash() 方法，它将被调用。不需要考虑继承"
"或多态性。动态类型化语言只关心具有所需方法或成员的实例，而不关心它继承什么类"
"型。鸭子类型的定义应该使这一点更清楚:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:507
msgid ""
"*\"When I see a bird that walks like a duck and swims like a duck and quacks "
"like a duck, I call that bird a duck\"*"
msgstr ""
"*\"当我看到一只鸟像鸭子一样走路，像鸭子一样游泳，像鸭子一样呱呱叫时，我就叫它"
"鸭子\"*"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:510
msgid "In this case, it translates to:"
msgstr "在这种情况下，它可转变成:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:512
msgid ""
"*\"If the object can be smashed, don't care what it is, just smash it.\"*"
msgstr "*\"如果物体可以被砸碎，不要在意它是什么，只管砸碎它。\"*"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:514
msgid "Yes, we should call it Hulk typing instead."
msgstr "是的，称它为“绿巨人”类型适合更合适。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:516
msgid ""
"It's possible that the object being hit doesn't have a smash() function. "
"Some dynamically typed languages simply ignore a method call when it doesn't "
"exist (like Objective C), but GDScript is stricter, so checking if the "
"function exists is desirable:"
msgstr ""
"有可能被击中的对象没有smash()函数。一些动态类型语言在方法调用不存在时简单地忽"
"略它(如Objective C)，但是GDScript更严格，因此需要检查函数是否存在:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_advanced.rst:527
msgid ""
"Then, simply define that method and anything the rock touches can be smashed."
msgstr "然后，简单地定义这个方法，岩石触碰的任何东西都可以被粉碎了。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_styleguide.rst:4
msgid "GDScript style guide"
msgstr "GDScript 风格指南"

#: ../../docs/getting_started/scripting/gdscript/gdscript_styleguide.rst:9
msgid ""
"This styleguide lists conventions to write elegant GDScript. The goal is to "
"encourage writing clean, readable code and promote consistency across "
"projects, discussions, and tutorials. Hopefully, this will also encourage "
"development of auto-formatting tools."
msgstr ""
"该样式指南列出了编写优雅GDScript的约定。目标是鼓励编写干净、可读的代码，并促"
"进项目、讨论和教程之间的一致性。希望这也会鼓励开发自动格式化工具。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_styleguide.rst:14
msgid ""
"Since GDScript is close to Python, this guide is inspired by Python's `PEP 8 "
"<https://www.python.org/dev/peps/pep-0008/>`__ programming styleguide."
msgstr ""
"由于GDScript与Python非常接近，因此本指南的灵感来自Python的 `PEP 8 <https://"
"www.python.org/dev/peps/pep-0008/>`__ 编程风格。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_styleguide.rst:18
msgid ""
"Godot's built-in script editor uses a lot of these conventions by default. "
"Let it help you."
msgstr "Godot的内置脚本编辑器默认使用了很多这些约定。 让它帮助您。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_styleguide.rst:22
msgid "Code structure"
msgstr "节点结构"

#: ../../docs/getting_started/scripting/gdscript/gdscript_styleguide.rst:25
msgid "Indentation"
msgstr "缩进"

#: ../../docs/getting_started/scripting/gdscript/gdscript_styleguide.rst:27
msgid "Indent type: Tabs *(editor default)*"
msgstr "缩进类型:Tabs *(编辑器默认)*"

#: ../../docs/getting_started/scripting/gdscript/gdscript_styleguide.rst:29
msgid "Indent size: 4 *(editor default)*"
msgstr "缩进大小:4 *(编辑器默认)*"

#: ../../docs/getting_started/scripting/gdscript/gdscript_styleguide.rst:31
msgid "Each indent level should be one greater than the block containing it."
msgstr "每个缩进级别必须大于包含它的代码块。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_styleguide.rst:33
#: ../../docs/getting_started/scripting/gdscript/gdscript_styleguide.rst:53
#: ../../docs/getting_started/scripting/gdscript/gdscript_styleguide.rst:83
#: ../../docs/getting_started/scripting/gdscript/gdscript_styleguide.rst:107
#: ../../docs/getting_started/scripting/gdscript/gdscript_styleguide.rst:127
msgid "**Good**:"
msgstr "**良好的**:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_styleguide.rst:40
#: ../../docs/getting_started/scripting/gdscript/gdscript_styleguide.rst:61
#: ../../docs/getting_started/scripting/gdscript/gdscript_styleguide.rst:93
#: ../../docs/getting_started/scripting/gdscript/gdscript_styleguide.rst:114
#: ../../docs/getting_started/scripting/gdscript/gdscript_styleguide.rst:137
msgid "**Bad**:"
msgstr "**糟糕的**:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_styleguide.rst:50
msgid ""
"Use 2 indent levels to distinguish continuation lines from regular code "
"blocks."
msgstr "使用2缩进级别把延续的行和普通代码块区分开来。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_styleguide.rst:70
msgid "Blank lines"
msgstr "空白行"

#: ../../docs/getting_started/scripting/gdscript/gdscript_styleguide.rst:72
msgid "Surround functions and class definitions with a blank line."
msgstr "用空行包围函数和类定义。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_styleguide.rst:74
msgid "Use one blank line inside functions to separate logical sections."
msgstr "在函数内部使用一个空行来分隔逻辑部分。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_styleguide.rst:77
msgid "One statement per line"
msgstr "一条语句一行"

#: ../../docs/getting_started/scripting/gdscript/gdscript_styleguide.rst:79
msgid ""
"Never combine multiple statements on a single line. No, C programmers, not "
"with a single line conditional statement (except with the ternary operator)!"
msgstr ""
"不要在一行上合并多个语句 。不要用单行条件语句 (除了三元运算符)， C 程序员 !"

#: ../../docs/getting_started/scripting/gdscript/gdscript_styleguide.rst:102
msgid "Avoid unnecessary parentheses"
msgstr "避免不必要的圆括号"

#: ../../docs/getting_started/scripting/gdscript/gdscript_styleguide.rst:104
msgid ""
"Avoid parentheses in expressions and conditional statements. Unless "
"necessary for order of operations, they only reduce readability."
msgstr ""
"避免表达式和条件语句中的括号。除非对运算顺序有要求, 否则它们只会降低可读性。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_styleguide.rst:122
msgid "Whitespace"
msgstr "空格"

#: ../../docs/getting_started/scripting/gdscript/gdscript_styleguide.rst:124
msgid ""
"Always use one space around operators and after commas. Avoid extra spaces "
"in dictionary references and function calls, or to create \"columns.\""
msgstr ""
"总在运算符和逗号之后使用一个空格。避免在字典引用和函数调用，或创建 \"列\"时增"
"加空格"

#: ../../docs/getting_started/scripting/gdscript/gdscript_styleguide.rst:147
msgid "**NEVER**:"
msgstr "**决不要**:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_styleguide.rst:156
#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:193
msgid "Naming conventions"
msgstr "命名约定"

#: ../../docs/getting_started/scripting/gdscript/gdscript_styleguide.rst:158
msgid ""
"These naming conventions follow the Godot Engine style. Breaking these will "
"make your code clash with the built-in naming conventions, which is ugly."
msgstr ""
"这些命名约定遵循 Godot 引擎风格。打破这些将使您的代码与内置的命名约定冲突, 这"
"是丑陋的。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_styleguide.rst:163
msgid "Classes and nodes"
msgstr "类与节点"

#: ../../docs/getting_started/scripting/gdscript/gdscript_styleguide.rst:165
msgid "Use PascalCase: ``extends KinematicBody``"
msgstr "使用PascalCase:``extends KinematicBody``"

#: ../../docs/getting_started/scripting/gdscript/gdscript_styleguide.rst:167
msgid "Also when loading a class into a constant or variable:"
msgstr "将类加载到常量或变量时:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_styleguide.rst:174
msgid "Functions and variables"
msgstr "函数与变量"

#: ../../docs/getting_started/scripting/gdscript/gdscript_styleguide.rst:176
msgid "Use snake\\_case: ``get_node()``"
msgstr "使用 snake\\_case: ``get_node()``"

#: ../../docs/getting_started/scripting/gdscript/gdscript_styleguide.rst:178
msgid ""
"Prepend a single underscore (\\_) to virtual methods (functions the user "
"must override), private functions, and private variables: ``func _ready()``"
msgstr ""
"在虚拟方法(用户必须覆盖的函数)中，私有函数和私有变量之前加上一个下划线 "
"(\\_) : ``func _ready()``"

#: ../../docs/getting_started/scripting/gdscript/gdscript_styleguide.rst:185
msgid "Use past tense:"
msgstr "使用过去时态:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_styleguide.rst:195
msgid ""
"Use CONSTANT\\_CASE, all caps, with an underscore (\\_) to separate words: "
"``const MAX_SPEED = 200``"
msgstr ""
"使用CONSTANT\\_CASE，全部大写，用下划线 (\\_) 分隔单词 ``const MAX_SPEED = "
"200``"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:4
msgid "Static typing in GDScript"
msgstr "GDScript 中静态类型"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:6
#: ../../docs/tutorials/physics/physics_introduction.rst:16
msgid "In this guide, you will learn:"
msgstr "在本指南中，您将学会:"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:8
msgid "**How to use types in GDScript**"
msgstr "**如何在GDScript中使用类型**"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:9
msgid "That **static types can help you avoid bugs**"
msgstr "这种 **静态类型可以帮助您避免bug**"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:11
msgid ""
"Where and how you use this new language feature is entirely up to you: you "
"can use it only in some sensitive GDScript files, use it everywhere, or "
"write code like you always did!"
msgstr ""
"您在哪里以及如何使用这个新语言特性完全取决于您:您只在一些敏感的GDScript文件中"
"使用它，在任何地方使用它，或者像以前一样编写代码！"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:15
msgid ""
"Static types can be used on variables, constants, functions, parameters, and "
"return types."
msgstr "静态类型可用于变量、常量、函数、参数和返回类型。"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:20
msgid "Typed GDScript is available since Godot 3.1."
msgstr "自从Godot3.1以来，可以使用类型化的GDScript。"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:23
msgid "A brief look at static typing"
msgstr "静态类型简介"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:25
msgid ""
"With typed GDScript, Godot can detect even more errors as you write code! It "
"gives you and your teammates more information as you’re working, as the "
"arguments’ types show up when you call a method."
msgstr ""
"使用键入的GDScript，当您编写代码时，Godot可以检测到更多错误！ 它会在您工作时"
"为您和您的队友提供更多信息，因为当您调用方法时，参数的类型会显示出来。"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:29
msgid ""
"Imagine you’re programming an inventory system. You code an ``Item`` node, "
"then an ``Inventory``. To add items to the inventory, the people who work "
"with your code should always pass an ``Item`` to the ``Inventory.add`` "
"method. With types, you can enforce this:"
msgstr ""
"想象一下，您正在编制库存系统。 您编写一个 ``Item`` 节点，然后编写一个 "
"``Inventory`` 。 要将项目添加到清单中，使用代码的人员应始终将 ``Item`` 传递"
"给 ``Inventory.add`` 方法。 使用类型，您可以强制执行以下操作:"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:48
msgid ""
"Another significant advantage of typed GDScript is the new **warning "
"system**. From version 3.1, Godot gives you warnings about your code as you "
"write it: the engine identifies sections of your code that may lead to "
"issues at runtime, but lets you decide whether or not you want to leave the "
"code as it is. More on that in a moment."
msgstr ""
"键入的GDScript的另一个显着优点是新的 **警告系统** 。 从版本3.1开始，Godot会在"
"您编写代码时向您发出有关代码的警告:引擎会识别代码中可能导致运行时出现问题的部"
"分，但您可以决定是否要保留代码。 稍后详细介绍。"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:54
msgid ""
"Static types also give you better code completion options. Below, you can "
"see the difference between a dynamic and a static typed completion options "
"for a class called ``PlayerController``."
msgstr ""
"静态类型还为您提供了更好的代码完成选项。 下面，您可以看到名为 "
"``PlayerController`` 的类的动态和静态类型完成选项之间的区别。"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:58
msgid ""
"You’ve probably stored a node in a variable before, and typed a dot to be "
"left with no autocomplete suggestions:"
msgstr "您可能之前在变量中存储了一个节点，并键入了一个没有自动完成建议的点:"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:64
msgid ""
"This is due to dynamic code. Godot cannot know what node or value type "
"you’re passing to the function. If you write the type explicitly however, "
"you will get all public methods and variables from the node:"
msgstr ""
"这是因为动态代码。 Godot无法知道您传递给函数的节点或值类型。 但是，如果您明确"
"地编写了类型，则将从节点获取所有公共方法和变量:"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:71
msgid ""
"In the future, typed GDScript will also increase code performance: Just-In-"
"Time compilation and other compiler improvements are already on the roadmap!"
msgstr ""
"将来，键入的GDScript还将提高代码性能:实时编译和其他编译器改进已经在路线图上"
"了！"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:75
msgid ""
"Overall, typed programming gives you a more structured experience. It helps "
"prevent errors and improves the self-documenting aspect of your scripts. "
"This is especially helpful when you’re working in a team or on a long-term "
"project: studies have shown that developers spend most of their time reading "
"other people’s code, or scripts they wrote in the past and forgot about. The "
"clearer and the more structured the code, the faster it is to understand, "
"the faster you can move forward."
msgstr ""
"将来，类型化的GDScript还将提高代码性能:即时编译和其他编译器改进已经在规划图上"
"了。"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:84
msgid "How to use static typing"
msgstr "如何使用静态类型"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:86
msgid ""
"To define the type of a variable or a constant, write a colon after the "
"variable’s name, followed by its type. E.g. ``var health: int``. This forces "
"the variable's type to always stay the same:"
msgstr ""
"要定义变量或常量的类型，请在变量名后面写一个冒号，后面跟着它的类型。例如 "
"``var health: int`` 。这迫使变量的类型始终保持不变:"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:95
msgid ""
"Godot will try to infer types if you write a colon, but you omit the type:"
msgstr "如果您写冒号但省略写类型时，Godot将尝试推测类型:"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:104
msgid "Currently you can use three types of… types:"
msgstr "目前，您可以使用三种…类型的类型:"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:106
#, fuzzy
msgid ":ref:`Built-in <doc_gdscript_builtin_types>`"
msgstr ":ref:`Built-in<gdscript_basics.html#built-in-types>`"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:107
msgid ""
"Core classes and nodes (``Object``, ``Node``, ``Area2D``, ``Camera2D``, etc.)"
msgstr "核心类和节点( ``Object``, ``Node``, ``Area2D``, ``Camera2D``, 等)"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:109
msgid ""
"Your own, custom classes. Look at the new :ref:`class_name "
"<doc_scripting_continued_class_name>` feature to register types in the "
"editor."
msgstr ""
"您自己定义的类。查看新的 `class_name <https://godot.readthedocs.io/en/latest/"
"getting_started/step_by_step/scripting_continued.html#register-scripts-as-"
"classes>`__ 特性以便在编辑器中注册类型。"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:114
msgid ""
"You don't need to write type hints for constants, as Godot sets it "
"automatically from the assigned value. But you can still do so to make the "
"intent of your code clearer."
msgstr ""
"您不需要为常量编写类型提示，因为Godot会根据分配的值自动设置常数。但是，您仍然"
"可以这样做，以使代码的意图更加清晰。"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:117
msgid "Custom variable types"
msgstr "自定义变量类型"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:119
msgid ""
"You can use any class, including your custom classes, as types. There are "
"two ways to use them in scripts. The first method is to preload the script "
"you want to use as a type in a constant:"
msgstr ""
"可以使用任何类(包括自定义类)作为类型。在脚本中有两种方法来使用它们。第一个方"
"法是预加载要用作常量中的类型的脚本:"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:128
msgid ""
"The second method is to use the ``class_name`` keyword when you create. For "
"the example above, your Rifle.gd would look like this:"
msgstr ""
"第二种方法是在创建时使用 ``class_name`` 关键字。对于上面的示例，您的 Rifle."
"gd 看起来就像这样:"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:136
msgid ""
"If you use ``class_name``, Godot registers the Rifle type globally in the "
"editor, and you can use it anywhere, without having to preload it into a "
"constant:"
msgstr ""
"如果使用 ``class_name`` ，Godot会在编辑器中注册一个全局Rifle类型，您可以在任"
"何地方使用它而无需将其预加载到常量中:"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:145
msgid "Variable casting"
msgstr "变量转换"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:147
msgid ""
"Type casting is a key concept in typed languages. Casting is the conversion "
"of a value from one type to another."
msgstr "类型转换是键入语言的关键概念。 转换是将值从一种类型转换为另一种类型。"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:150
msgid ""
"Imagine an Enemy in your game, that ``extends Area2D``. You want it to "
"collide with the Player, a ``KinematicBody2D`` with a script called "
"``PlayerController`` attached to it. You use the ``on_body_entered`` signal "
"to detect the collision. With typed code, the body you detect is going to be "
"a generic ``PhysicsBody2D``, and not your ``PlayerController`` on the "
"``_on_body_entered`` callback."
msgstr ""
"想象一下您的游戏中的敌人，即 ``extends Area2D`` 。 您希望它与游戏角色碰撞，一"
"个挂上 ``PlayerController`` 脚本的 ``KinematicBody2D`` 。 您使用 "
"``on_body_entered`` 信号来检测碰撞。 使用类型代码，您检测到的物体将是一个通用"
"的 ``PhysicsBody2D`` ，而不是 ``_on_body_entered`` 回调中的 "
"``PlayerController`` 。"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:157
msgid ""
"You can check if this ``PhysicsBody2D`` is your Player with the ``as`` "
"casting keyword, and using the colon ``:`` again to force the variable to "
"use this type. This forces the variable to stick to the ``PlayerController`` "
"type:"
msgstr ""
"您可以检查这个 ``PhysicsBody2D`` 是否是带有 ``as`` 转换关键字的游戏角色，再次"
"使用冒号 ``:`` 来强制变量使用这种类型。 这会强制变量坚持使用 "
"``PlayerController`` 类型:"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:170
msgid ""
"As we’re dealing with a custom type, if the ``body`` doesn’t extend "
"``PlayerController``, the ``player``\\ variable will be set to ``null``. We "
"can use this to check if the body is the player or not. We will also get "
"full autocompletion on the player variable thanks to that cast."
msgstr ""
"当我们处理自定义类型时，如果 ``body`` 没有扩展 ``PlayerController``， ``游戏"
"角色`` \\ 变量将被设置为 ``null`` 。 我们可以用它来检查物体是否是游戏角色。 "
"感谢类型转换，我们还将获得游戏角色变量的全部的自动完成功能。"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:177
msgid ""
"If you try to cast with a built-in type and it fails, Godot will throw an "
"error."
msgstr "如果您尝试使用内置类型进行强制转换但失败时，那么Godot会抛出一个错误。"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:180
msgid "Safe lines"
msgstr "安全行"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:182
msgid ""
"You can also use casting to ensure safe lines. Safe lines are a new tool in "
"Godot 3.1 to tell you when ambiguous lines of code are type-safe. As you can "
"mix and match typed and dynamic code, at times, Godot doesn’t have enough "
"information to know if an instruction will trigger an error or not at "
"runtime."
msgstr ""
"您也可以使用转换来确保安全行。 安全行是Godot 3.1中的一个新工具，可以告诉您何"
"时模糊的代码行是类型安全的。 因为您可以混合和匹配类型和动态代码，有时如果指令"
"在运行时触发错误，Godot可能没有足够的信息判断。"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:188
msgid ""
"This happens when you get a child node. Let’s take a timer for example: with "
"dynamic code, you can get the node with ``$Timer``. GDScript supports `duck-"
"typing <https://stackoverflow.com/a/4205163/8125343>`__, so even if your "
"timer is of type ``Timer``, it is also a ``Node`` and an ``Object``, two "
"classes it extends. With dynamic GDScript, you also don’t care about the "
"node’s type as long as it has the methods you need to call."
msgstr ""
"当您获得子节点时会发生这种情况。 我们以计时器为例:使用动态代码，您可以使用 ``"
"$Timer`` 获取节点。 GDScript支持 `鸭子类型 <https://stackoverflow.com/"
"a/4205163/8125343>`__，所以即使您的计时器是 ``Timer`` 类型，它也是一个 "
"``Node`` 和 ``Object`` ，它扩展了两个类。 使用动态GDScript，只要它具有您需要"
"调用的方法，您也可以不关心节点的类型。"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:196
msgid ""
"You can use casting to tell Godot the type you expect when you get a node: "
"``($Timer as Timer)``, ``($Player as KinematicBody2D)``, etc. Godot will "
"ensure the type works and if so, the line number will turn green at the left "
"of the script editor."
msgstr ""
"当您得到一个节点时，您可以使用强制转换告诉Godot您期望的类型: ``($Timer as "
"Timer)`` ， ``($Player as KinematicBody2D)`` 等。Godot将确保这种类型有效，如"
"果有的话 ，行号将在脚本编辑器的左侧变为绿色。"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:204
msgid "Safe vs Unsafe Line"
msgstr "安全与不安全行"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:208
msgid ""
"You can turn off safe lines or change their color in the editor settings."
msgstr "可以在编辑器设置中关闭安全行或更改其颜色。"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:211
msgid "Define the return type of a function with the arrow ->"
msgstr "使用箭头 ->定义函数的返回类型"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:213
#, fuzzy
msgid ""
"To define the return type of a function, write a dash and a right angle "
"bracket ``->`` after its declaration, followed by the return type:"
msgstr ""
"要定义函数的返回类型，请在声明后写一个破折号和一个右尖括号 ``->`` ，然后写返"
"回类型:"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:221
msgid ""
"The type ``void`` means the function does not return anything. You can use "
"any type, as with variables:"
msgstr "类型 ``void`` 表示函数不返回任何内容。 您可以使用任何类型作为变量:"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:230
msgid "You can also use your own nodes as return types:"
msgstr "您还可以使用自己的节点作为返回类型:"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:245
msgid "Typed or dynamic: stick to one style"
msgstr "类型或动态类型:坚持一种风格"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:247
msgid ""
"Typed GDScript and dynamic GDScript can coexist in the same project. But I "
"recommended to stick to either style for consistency in your codebase, and "
"for your peers. It’s easier for everyone to work together if you follow the "
"same guidelines, and faster to read and understand other people’s code."
msgstr ""
"键入的GDScript和动态GDScript可以在同一个项目中共存。 但我建议坚持使用任何一种"
"样式来保持代码库和同行的一致性。 如果您遵循相同的指导方针，并且更快地阅读和理"
"解其他人的代码，那么每个人都可以更轻松地协同工作。"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:253
msgid ""
"Typed code takes a little more writing, but you get the benefits we "
"discussed above. Here’s an example of the same, empty script, in a dynamic "
"style:"
msgstr ""
"静态的代码需要更多的写作，但您可以获得我们上面讨论过的好处。 以下是动态样式中"
"相同的空脚本的示例:"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:265
msgid "And with static typing:"
msgstr "和静态类型:"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:275
msgid ""
"As you can see, you can also use types with the engine’s virtual methods. "
"Signal callbacks, like any methods, can also use types. Here’s a "
"``body_entered`` signal in a dynamic style:"
msgstr ""
"如您所见，您还可以使用引擎虚拟方法的类型。 与任何方法一样，信号回调也可以使用"
"类型。 这是一个动态样式的 ``body_entered`` 信号:"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:284
msgid "And the same callback, with type hints:"
msgstr "相同的回调，具有类型提示:"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:291
msgid ""
"You’re free to replace, e.g. the ``PhysicsBody2D``, with your own type, to "
"cast parameters automatically:"
msgstr ""
"您可以自由更换，例如 具有您自己风格的 ``PhysicsBody2D`` 可自动转换参数:"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:301
msgid ""
"The ``bullet`` variable could hold any ``CollisionObject2D`` here, but we "
"make sure it is our ``Bullet``, a node we created for our project. If it’s "
"anything else, like an ``Area2D``, or any node that doesn’t extend "
"``Bullet``, the ``bullet`` variable will be ``null``."
msgstr ""
"``bullet`` 变量可以在这里保存任何 ``CollisionObject2D`` ，但我们需要确保它是"
"我们的 ``Bullet` `，即那个我们为项目创建的节点。 如果它是其他任何东西，比如 "
"``Area2D`` ，或任何不扩展 ``Bullet`` 的节点， ``bullet`` 变量将是 ``null`` 。"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:307
msgid "Warning system"
msgstr "警告系统"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:309
msgid ""
"The warning system complements typed GDScript. It’s here to help you avoid "
"mistakes that are hard to spot during development, and that may lead to "
"runtime errors."
msgstr ""
"警告系统补充了键入的GDScript。 它可以帮助您避免在开发过程中难以发现的错误，以"
"避免运行时的错误。"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:313
msgid ""
"You can configure warnings in the Project Settings under a new section "
"called ``GDScript``:"
msgstr "您可以在名为 ``GDScript`` 的新部分的 “项目设置” 中配置警告:"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:319
msgid "warning system project settings"
msgstr "警告系统项目设置"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:321
msgid ""
"You can find a list of warnings for the active GDScript file in the script "
"editor’s status bar. The example below has 3 warnings:"
msgstr ""
"您可以在脚本编辑器的状态栏中找到活动GDScript文件的警告列表。 以下示例有3个警"
"告:"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:327
msgid "warning system example"
msgstr "警告系统示例"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:329
msgid ""
"To ignore specific warnings in one file, insert a special comment of the "
"form ``#warning-ignore:warning-id``, or click on the ignore link to the "
"right of the warning’s description. Godot will add a comment above the "
"corresponding line and the code won’t trigger the corresponding warning "
"anymore:"
msgstr ""
"要忽略一个文件中的特定警告，请插入 ``#warning-ignore:warning-id`` 形式的特殊"
"注释，或单击警告描述右侧的忽略链接。 Godot将在相应的行上方添加注释，代码将不"
"再触发相应的警告:"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:338
msgid "warning system ignore example"
msgstr "警告系统忽略示例"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:340
msgid ""
"Warnings won’t prevent the game from running, but you can turn them into "
"errors if you’d like. This way your game won’t compile unless you fix all "
"warnings. Head to the ``GDScript`` section of the Project Settings to turn "
"on this option. Here’s the same file as the previous example with warnings "
"as errors turned on:"
msgstr ""
"警告不会阻止游戏运行，但如果您愿意，可以将它们变成错误。 这样，除非您修复所有"
"警告，否则您的游戏将无法编译。 前往项目设置的 ``GDScript`` 部分打开此选项。 "
"这是与前一个示例相同的文件，并在启用了警告转成错误:"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:349
msgid "warnings as errors"
msgstr "警告变为错误"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:352
msgid "Cases where you can’t specify types"
msgstr "您无法指定类型的情况"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:354
msgid ""
"To wrap up this introduction, let’s cover a few cases where you can’t use "
"type hints. All the examples below **will trigger errors**."
msgstr ""
"为了总结这个介绍，我们将介绍一些不能使用类型提示的情况。 以下所有示例 **都会"
"触发错误** 。"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:357
msgid "You can’t use Enums as types:"
msgstr "您不能将Enums用作类型:"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:364
msgid ""
"You can’t specify the type of individual members in an array. This will give "
"you an error:"
msgstr "您无法指定数组中单个成员的类型。 这会给您一个错误:"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:371
msgid ""
"You can’t force the assignment of types in a ``for`` loop, as each element "
"the ``for`` keyword loops over already has a different type. So you "
"**cannot** write:"
msgstr ""
"您不能在 ``for`` 循环中强制分配类型，因为 ``for`` 关键字循环已经有不同的类"
"型。 所以您 **不能** 写:"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:381
msgid "Two scripts can’t depend on each other in a cyclic fashion:"
msgstr "两个脚本不能以循环方式相互依赖:"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:400
#: ../../docs/getting_started/workflow/export/exporting_pcks.rst:124
#: ../../docs/tutorials/2d/2d_movement.rst:347
msgid "Summary"
msgstr "总结"

#: ../../docs/getting_started/scripting/gdscript/static_typing.rst:402
msgid ""
"Typed GDScript is a powerful tool. Available as of version 3.1 of Godot, it "
"helps you write more structured code, avoid common errors, and create "
"scalable systems. In the future, static types will also bring you a nice "
"performance boost thanks to upcoming compiler optimizations."
msgstr ""
"具有类型的GDScript是一个强大的工具。 使用Godot 3.1，它已经可以帮助您编写更多"
"结构化代码，帮助您避免常见错误，并创建可扩展系统。 在未来，由于即将进行的编译"
"器优化，静态类型也将为您带来不错的性能提升。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:4
msgid "GDScript format strings"
msgstr "GDScript 格式化字符串"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:6
msgid ""
"GDScript offers a feature called *format strings*, which allows reusing text "
"templates to succinctly create different but similar strings."
msgstr ""
"GDScript 提供 *格式化字符串* 的特性，使运用重用字符串模板，简练地创造不同但相"
"似的字符串成为可能。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:9
msgid ""
"Format strings are just like normal strings, except they contain certain "
"placeholder character-sequences. These placeholders can then easily be "
"replaced by parameters handed to the format string."
msgstr ""
"格式化字符串就像正常的字符串，除了他们包含某些占位符字符片段。 这些占位符可以"
"轻易地被传递过来的参数替代。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:13
msgid ""
"As an example, with ``%s`` as a placeholder, the format string ``\"Hello %s, "
"how are you?`` can easily be changed to ``\"Hello World, how are you?\"``. "
"Notice the placeholder is in the middle of the string; modifying it without "
"format strings could be cumbersome."
msgstr ""
"举一个示例，使用 ``%s`` 作为占位符，格式化字符串 ``\"Hello %s, how are you?"
"`` 可以很容易改为 ``\"Hello World, how are you?\"`` 。注意占位符在字符串的中"
"间，如果不使用格式化字符串去修改这个字符串可能会有点麻烦。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:20
msgid "Usage in GDScript"
msgstr "在GDScript中的用法"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:22
msgid "Examine this concrete GDScript example:"
msgstr "来仔细看看这个具体的GDScript示例:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:35
msgid ""
"Placeholders always start with a ``%``, but the next character or "
"characters, the *format specifier*, determines how the given value is "
"converted to a string."
msgstr ""
"占位符总是以 ``%`` 为开头，由下一个字符或字符串，即 *格式说明符* ，决定给定值"
"如何转化为一个字符串。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:39
msgid ""
"The ``%s`` seen in the example above is the simplest placeholder and works "
"for most use cases: it converts the value by the same method by which an "
"implicit String conversion or ``str()`` would convert it. Strings remain "
"unchanged, Booleans turn into either ``\"True\"`` or ``\"False\"``, an "
"integral or real number becomes a decimal, other types usually return their "
"data in a human-readable string."
msgstr ""
"上述示例中的 ``%s`` 是最简单的占位符， 在大多数情况下使用:它通过隐式字符串转"
"换方法或 ``str()`` 来转换值。 字符串保持不变， 布尔运算变为 ``\"True\"`` 或 "
"``\"False\"``， 整数或实数变为小数，其他类型通常以可读的字符串返回它们的数"
"据。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:46
msgid ""
"There is also another way to format text in GDScript, namely the ``String."
"format()`` method. It replaces all occurrences of a key in the string with "
"the corresponding value. The method can handle arrays or dictionaries for "
"the key/value pairs."
msgstr ""
"在 GDScript 中还有另一种格式化文本的方式，也就是 ``String.format()`` 方法。它"
"用相应的值替换所有在字符串中出现的键。这个方法可以处理键/值对应的数组或字典。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:50
msgid ""
"Arrays can be used as key, index, or mixed style (see below examples). Order "
"only matters when the index or mixed style of Array is used."
msgstr ""
"数组可以用作键，索引或混合样式(请参见下面的示例)。仅当使用数组的索引或混合样"
"式时，顺序才是重要的。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:53
msgid "A quick example in GDScript:"
msgstr "一个简单的 GDScript 示例:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:66
msgid ""
"There are other `format specifiers`_, but they are only applicable when "
"using the ``%`` operator."
msgstr "还有其他的 `格式说明符`, 但只有在使用 ``%`` 操作符的情况下才适用。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:71
msgid "Multiple placeholders"
msgstr "多个占位符"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:73
msgid ""
"Format strings may contain multiple placeholders. In such a case, the values "
"are handed in the form of an array, one value per placeholder (unless using "
"a format specifier with ``*``, see `dynamic padding`_):"
msgstr ""
"格式字符串可能包含多个占位符。 在这种情况下，值是以数组的形式传递的，每个占位"
"符占一个值(除非使用带 ``*`` 的格式说明符，请参阅 `dynamic padding`_):"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:85
msgid ""
"Note the values are inserted in order. Remember all placeholders must be "
"replaced at once, so there must be an appropriate number of values."
msgstr ""
"请注意，这些值是按顺序插入的。请记住所有占位符被同时替换，因此必须有恰当数量"
"的值。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:90
msgid "Format specifiers"
msgstr "格式说明符"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:92
msgid ""
"There are format specifiers other than ``s`` that can be used in "
"placeholders. They consist of one or more characters. Some of them work by "
"themselves like ``s``, some appear before other characters, some only work "
"with certain values or characters."
msgstr ""
"除 ``s`` 之外， 还有其他格式说明符可以在占位符中使用。它们由一个或多个字符组"
"成。其中一些像 ``s`` 一样自行工作，另一些出现在其他字符之前，还有一些只与特定"
"的值或字符一起工作。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:99
msgid "Placeholder types"
msgstr "占位符类型"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:101
msgid ""
"One and only one of these must always appear as the last character in a "
"format specifier. Apart from ``s``, these require certain types of "
"parameters."
msgstr ""
"有且只有其中一个作为最后一个字符在格式说明符中出现。除了 ``s`` 外， 这些格式"
"说明符还需要某些类型的参数。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:105
msgid "``s``"
msgstr "``s``"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:105
msgid ""
"**Simple** conversion to String by the same method as implicit String "
"conversion."
msgstr "简单的字符串转换，通过相同的隐式字符串转换方法。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:108
msgid "``c``"
msgstr "``c``"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:108
msgid ""
"A single **Unicode character**. Expects an unsigned 8-bit integer (0-255) "
"for a code point or a single-character string."
msgstr ""
"单个 **Unicode 字符**。对于代码点或单个字符， 需要一个无符号的8位整数 "
"(0-255) 。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:111
msgid "``d``"
msgstr "``d``"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:111
msgid ""
"A **decimal integral** number. Expects an integral or real number (will be "
"floored)."
msgstr "一个 **十进制** 整数。 需要一个整数或实数(向下取整)。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:114
msgid "``o``"
msgstr "``o``"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:114
msgid ""
"An **octal integral** number. Expects an integral or real number (will be "
"floored)."
msgstr "一个 **八进制** 整数。 需要一个整数或实数(向下取整)。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:117
msgid "``x``"
msgstr "``x``"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:117
msgid ""
"A **hexadecimal integral** number with **lower-case** letters. Expects an "
"integral or real number (will be floored)."
msgstr "一个小写字母的 **十六进制** 整数。 需要一个整数或实数(向下取整)。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:120
msgid "``X``"
msgstr "``X``"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:120
msgid ""
"A **hexadecimal integral** number with **upper-case** letters. Expects an "
"integral or real number (will be floored)."
msgstr "一个大写字母的 **十六进制** 整数。 需要一个整数或实数(向下取整)。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:123
msgid "``f``"
msgstr "``f``"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:123
msgid "A **decimal real** number. Expects an integral or real number."
msgstr "一个 **十进制** 实数。 需要一个整数或实数。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:128
msgid "Placeholder modifiers"
msgstr "占位符的修饰符"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:130
msgid ""
"These characters appear before the above. Some of them work only under "
"certain conditions."
msgstr "这些字符在上述占位符前出现。 其中一些只在特定情况下生效。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:134
msgid "In number specifiers, **show + sign** if positive."
msgstr "用在数字说明符中，如果为正 **显示+号** 。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:136
#: ../../docs/tutorials/misc/binary_serialization_api.rst:94
#: ../../docs/tutorials/misc/binary_serialization_api.rst:103
#: ../../docs/tutorials/misc/binary_serialization_api.rst:121
#: ../../docs/tutorials/misc/binary_serialization_api.rst:312
#: ../../docs/tutorials/misc/binary_serialization_api.rst:332
#: ../../docs/tutorials/misc/binary_serialization_api.rst:334
#: ../../docs/tutorials/misc/binary_serialization_api.rst:342
#: ../../docs/tutorials/misc/binary_serialization_api.rst:361
#: ../../docs/tutorials/misc/binary_serialization_api.rst:373
#: ../../docs/tutorials/misc/binary_serialization_api.rst:385
#: ../../docs/tutorials/misc/binary_serialization_api.rst:398
#: ../../docs/tutorials/misc/binary_serialization_api.rst:400
#: ../../docs/tutorials/misc/binary_serialization_api.rst:409
#: ../../docs/tutorials/misc/binary_serialization_api.rst:411
#: ../../docs/tutorials/misc/binary_serialization_api.rst:420
#: ../../docs/tutorials/misc/binary_serialization_api.rst:428
#: ../../docs/tutorials/misc/binary_serialization_api.rst:441
#: ../../docs/tutorials/misc/binary_serialization_api.rst:454
#: ../../docs/tutorials/misc/binary_serialization_api.rst:469
msgid "Integer"
msgstr "Integer"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:136
msgid ""
"Set **padding**. Padded with spaces or with zeroes if integer starts with "
"``0`` in an integer placeholder. When used after ``.``, see ``.``."
msgstr ""
"设置 **填充** 。用空格填充，或如果整数 ``0`` 写在一个整数占位符中用0填充。当 "
"``.`` 使用时见 ``.`` 。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:140
msgid "``.``"
msgstr "``.``"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:140
msgid ""
"Before ``f``, set **precision** to 0 decimal places. Can be followed up with "
"numbers to change. Padded with zeroes."
msgstr "``f``之前,设置 **精度** 到0位小数。可以跟进数量改变。用零填充。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:143
msgid "**Pad to the right** rather than the left."
msgstr "**向右填充** 而不是向左。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:145
msgid "``*``"
msgstr "``*``"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:145
msgid ""
"**Dynamic padding**, expect additional integral parameter to set padding or "
"precision after ``.``, see `dynamic padding`_."
msgstr ""
"**动态填充**, 期望额外的整数参数来设置填充或 ``.`` 后的精度。见 `dynamic "
"padding`_。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:151
msgid "Padding"
msgstr "填充"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:153
msgid ""
"The ``.`` (*dot*), ``*`` (*asterisk*), ``-`` (*minus sign*) and digit (``0``-"
"``9``) characters are used for padding. This allows printing several values "
"aligned vertically as if in a column, provided a fixed-width font is used."
msgstr ""
"字符 ``.`` (点), ``*`` (星号), ``-`` (减号) 和 数字 (``0``-``9``) 被用作占位"
"符。使一列定宽字体的值在垂直方向上可以保持对齐。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:158
msgid "To pad a string to a minimum length, add an integer to the specifier:"
msgstr "要使字符串满足一个最小长度，需要在标识符前添加一个整数:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:166
msgid ""
"If the integer starts with ``0``, integral values are padded with zeroes "
"instead of white space:"
msgstr "如果这个整数以0开头，那么整数值字符串将前置填充0，而不是空格:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:174
msgid ""
"Precision can be specified for real numbers by adding a ``.`` (*dot*) with "
"an integer following it. With no integer after ``.``, a precision of 0 is "
"used, rounding to integral value. The integer to use for padding must appear "
"before the dot."
msgstr ""
"可以通过添加 ``.`` (*点*)和一个整数来指定实数的精度。 ``.`` 后没整数时，精度"
"为0，舍入为整数值。要用于填充的整数则必须出现在点之前。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:186
msgid ""
"The ``-`` character will cause padding to the right rather than the left, "
"useful for right text alignment:"
msgstr "``-`` 字符将导致向右而不是向左填充，对右文本对齐很有用:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:197
msgid "Dynamic padding"
msgstr "动态填充"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:199
msgid ""
"By using the ``*`` (*asterisk*) character, the padding or precision can be "
"set without modifying the format string. It is used in place of an integer "
"in the format specifier. The values for padding and precision are then "
"passed when formatting:"
msgstr ""
"通过使用 ``*`` ( *星号* )字符，可以在不修改格式字符串的情况下设置填充或精"
"度。 它用于代替格式说明符中的整数。 然后在格式化时传递填充和精度的值:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:212
msgid ""
"It is still possible to pad with zeroes in integer placeholders by adding "
"``0`` before ``*``:"
msgstr "通过在 ``*`` 之前添加 ``0`` ，仍然可以在整数占位符中填充零:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:222
msgid "Escape sequence"
msgstr "逃脱序列"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:224
msgid ""
"To insert a literal ``%`` character into a format string, it must be escaped "
"to avoid reading it as a placeholder. This is done by doubling the character:"
msgstr ""
"要在文本字符串中插入文字 ``%`` 字符，必须对其进行转义以避免将其作为占位符读"
"取。 这是通过加倍符号来完成的:"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:235
msgid "Format method examples"
msgstr "格式化方法示例"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:237
msgid ""
"The following are some examples of how to use the various invocations of the "
"``String.format``  method."
msgstr "以下是如何使用 ``String.format`` 方法的各种调用的一些示例。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:242
msgid "**Style**"
msgstr "**样式**"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:242
#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:264
#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:277
msgid "**Example**"
msgstr "**示例**"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:242
#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:264
#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:277
msgid "**Result**"
msgstr "**结果**"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:244
#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:246
#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:248
#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:277
msgid "Dictionary"
msgstr "字典"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:244
#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:250
msgid "key"
msgstr "键"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:244
msgid ""
"``\"Hi, {name} v{version}!\".format({\"name\":\"Godette\", \"version\":"
"\"3.0\"})``"
msgstr ""
"``\"Hi, {name} v{version}!\".format({\"name\":\"Godette\", \"version\":"
"\"3.0\"})``"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:244
#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:246
#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:248
#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:250
#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:252
#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:254
#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:256
msgid "Hi, Godette v3.0!"
msgstr "Hi, Godette v3.0!"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:246
#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:252
msgid "index"
msgstr "索引"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:246
msgid "``\"Hi, {0} v{1}!\".format({\"0\":\"Godette\", \"1\":\"3.0\"})``"
msgstr "``\"Hi, {0} v{1}!\".format({\"0\":\"Godette\", \"1\":\"3.0\"})``"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:248
#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:254
msgid "mix"
msgstr "混合"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:248
msgid ""
"``\"Hi, {0} v{version}!\".format({\"0\":\"Godette\", \"version\":\"3.0\"})``"
msgstr ""
"``\"Hi, {0} v{version}!\".format({\"0\":\"Godette\", \"version\":\"3.0\"})``"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:250
#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:252
#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:254
#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:256
#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:256
msgid "Array"
msgstr "数组"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:250
msgid ""
"``\"Hi, {name} v{version}!\".format([[\"version\",\"3.0\"], [\"name\","
"\"Godette\"]])``"
msgstr ""
"``\"Hi, {name} v{version}!\".format([[\"version\",\"3.0\"], [\"name\","
"\"Godette\"]])``"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:252
msgid "``\"Hi, {0} v{1}!\".format([\"Godette\",\"3.0\"])``"
msgstr "``\"Hi, {0} v{1}!\".format([\"Godette\",\"3.0\"])``"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:254
msgid "``\"Hi, {name} v{0}!\".format([3.0, [\"name\",\"Godette\"]])``"
msgstr "``\"Hi, {name} v{0}!\".format([3.0, [\"name\",\"Godette\"]])``"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:256
msgid "no index"
msgstr "没有索引"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:256
msgid "``\"Hi, {} v{}!\".format([\"Godette\", 3.0], \"{}\")``"
msgstr "``\"Hi, {} v{}!\".format([\"Godette\", 3.0], \"{}\")``"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:259
msgid ""
"Placeholders can also be customized when using ``String.format``, here's "
"some examples of that functionality."
msgstr ""
"占位符也可以在使用 ``String.format`` 时进行自定义, 下面是该功能的一些示例。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:266
msgid "Infix (default)"
msgstr "中缀(默认)"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:266
msgid "``\"Hi, {0} v{1}\".format([\"Godette\", \"3.0\"], \"{_}\")``"
msgstr "``\"Hi, {0} v{1}\".format([\"Godette\", \"3.0\"], \"{_}\")``"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:266
#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:268
#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:270
msgid "Hi, Godette v3.0"
msgstr "Hi, Godette v3.0"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:268
msgid "Postfix"
msgstr "后缀"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:268
msgid "``\"Hi, 0% v1%\".format([\"Godette\", \"3.0\"], \"_%\")``"
msgstr "``\"Hi, 0% v1%\".format([\"Godette\", \"3.0\"], \"_%\")``"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:270
msgid "Prefix"
msgstr "前缀"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:270
msgid "``\"Hi, %0 v%1\".format([\"Godette\", \"3.0\"], \"%_\")``"
msgstr "``\"Hi, %0 v%1\".format([\"Godette\", \"3.0\"], \"%_\")``"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:273
msgid ""
"Combining both the ``String.format`` method and the ``%`` operator could be "
"useful, as ``String.format`` does not have a way to manipulate the "
"representation of numbers."
msgstr ""
"结合 ``String.format`` 方法和 ``％`` 运算符可能很有用，因为 ``String."
"format`` 没有办法操纵数字的表示。"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:279
msgid ""
"``\"Hi, {0} v{version}\".format({0:\"Godette\", \"version\":\"%0.2f\" % "
"3.114})``"
msgstr ""
"``\"Hi, {0} v{version}\".format({0:\"Godette\", \"version\":\"%0.2f\" % "
"3.114})``"

#: ../../docs/getting_started/scripting/gdscript/gdscript_format_string.rst:279
msgid "Hi, Godette v3.11"
msgstr "Hi, Godette v3.11"

#: ../../docs/getting_started/scripting/visual_script/what_is_visual_scripting.rst:4
msgid "What is Visual Scripting"
msgstr "什么是可视化脚本"

#: ../../docs/getting_started/scripting/visual_script/what_is_visual_scripting.rst:6
msgid ""
"Visual Scripting is a tool designed to make the entry barrier to programming "
"much lower. As code is more visual, it needs less abstract thinking to be "
"understood. Any artist, animator, game designer, etc. can look at it and "
"quickly grasp the flow of logic."
msgstr ""
"可视化脚本是一种工具，用于降低编程的入口壁垒。由于代码更直观，它需要较少的抽"
"象思维来理解。任何艺术家、动画师、游戏设计师等都可以看到它，并快速掌握逻辑流"
"程。"

#: ../../docs/getting_started/scripting/visual_script/what_is_visual_scripting.rst:11
msgid ""
"The reason it does not make existing programming obsolete is, simply, that "
"it does not scale as well. It takes considerably more time to create code "
"with it, and it's often more difficult to modify than just writing a few "
"characters."
msgstr ""
"它没有使现有编程过时的原因很简单，就是它拓展性不强。用它来创建代码要花费相当"
"多的时间，并且修改它通常比仅仅编写几个字符更困难。"

#: ../../docs/getting_started/scripting/visual_script/what_is_visual_scripting.rst:15
msgid ""
"With the misunderstanding cleared up, the question that remains is what are "
"the practical uses for Visual Scripting."
msgstr "随着误解的消除，剩下的问题是可视化脚本的实际用途是什么。"

#: ../../docs/getting_started/scripting/visual_script/what_is_visual_scripting.rst:18
msgid "The most common use cases are as follows:"
msgstr "最常见的使用情况如下:"

#: ../../docs/getting_started/scripting/visual_script/what_is_visual_scripting.rst:20
msgid ""
"Game development beginners who want to learn an engine but have no "
"programming experience yet."
msgstr "游戏开发新手，想要学习引擎，但还没有编程经验。"

#: ../../docs/getting_started/scripting/visual_script/what_is_visual_scripting.rst:21
msgid ""
"Artists and Game Designers who have no experience in programming and want to "
"create quick prototypes or simple games."
msgstr "没有编程经验的艺术家和游戏设计师，希望快速创建游戏原型或简单的游戏。"

#: ../../docs/getting_started/scripting/visual_script/what_is_visual_scripting.rst:22
msgid ""
"Programmers working in a team that want to make part of the game logic "
"available to Artists or Game Designers in order to offload some of their "
"work."
msgstr ""
"在一个团队中工作的程序员，希望将游戏逻辑的一部分提供给艺术家或游戏设计师，以"
"便减少他们的工作负担。"

#: ../../docs/getting_started/scripting/visual_script/what_is_visual_scripting.rst:24
msgid ""
"These scenarios are far more common than one might think, so this is why "
"Godot has added this feature."
msgstr "这些场景远比人们想象的更常见，所以这就是Godot添加该特性的原因。"

#: ../../docs/getting_started/scripting/visual_script/getting_started.rst:4
msgid "Getting started with Visual Scripting"
msgstr "开始使用可视化脚本吧"

#: ../../docs/getting_started/scripting/visual_script/getting_started.rst:6
msgid ""
"As with everything in Godot, we prioritize a good experience over copying or "
"integrating third party solutions which might not fit nicely in the current "
"workflow. This led us to write our own version of how we believe this "
"feature would work best with the engine."
msgstr ""
"与Godot中的所有内容一样，我们优先考虑好的体验而不是复制或集成可能不适合当前工"
"作流程的第三方解决方案。这导致我们编写了自己的版本，说明我们相信该特性将如何"
"与引擎最佳配合。"

#: ../../docs/getting_started/scripting/visual_script/getting_started.rst:10
msgid ""
"In Godot, a Visual Script fits smoothly together with regular scripts in the "
"Editor tab"
msgstr "在Godot中，在Editor选项卡中，可视化脚本与常规脚本配合得很好"

#: ../../docs/getting_started/scripting/visual_script/getting_started.rst:15
msgid ""
"In fact, Visual Scripting integrates so well to Godot that it's hard to "
"believe it was added only in version 3.0. This is because, when editing, the "
"rest of Godot panels and docks act like a palette from where you can drag "
"and drop all sorts of information to the script canvas:"
msgstr ""
"事实上，可视化脚本非常好地集成到了Godot中，以至于很难相信它只是在3.0版本中添"
"加的。这是因为，在编辑时，Godot面板和窗口的其余部分就像一个调色板，您可以从中"
"将各种信息拖放到脚本画布中:"

#: ../../docs/getting_started/scripting/visual_script/getting_started.rst:23
#, fuzzy
msgid "Creating a script"
msgstr "创建脚本"

#: ../../docs/getting_started/scripting/visual_script/getting_started.rst:25
msgid ""
"Creating scripts works the same as with other scripting languages: Select "
"any node in the scene and push the \"New Script\" button at the top right "
"corner of the Scene Tree dock:"
msgstr ""
"创建脚本的工作原理与其他脚本语言相同:选择场景中的任何节点，然后按场景树面板右"
"上角的“New Script”按钮:"

#: ../../docs/getting_started/scripting/visual_script/getting_started.rst:31
msgid ""
"Once it opens, the script type \"Visual Script\" must be selected from the "
"drop down list. The script extension must be \".vs\" (for Visual Script!)."
msgstr ""
"打开后，必须从下拉列表中选择脚本类型“Visual Script”。脚本扩展必须是“.vs”(对于"
"VisualScript！)."

#: ../../docs/getting_started/scripting/visual_script/getting_started.rst:37
msgid ""
"Finally, the Script Editor will open, allowing you to start editing the "
"visual script:"
msgstr "最后，脚本编辑器将打开，允许开始编辑可视脚本:"

#: ../../docs/getting_started/scripting/visual_script/getting_started.rst:43
#, fuzzy
msgid "Adding a function"
msgstr "添加函数"

#: ../../docs/getting_started/scripting/visual_script/getting_started.rst:45
msgid ""
"Unlike other visual scripting implementations, Visual Scripting in Godot is "
"heavily based on functions. This happens because it uses the same interface "
"to communicate with the engine as other scripting engines. In Godot, the "
"scripting interface is universal and all implementations conform to it."
msgstr ""
"与其他可视化脚本实现不同，Godot中的可视化脚本在很大程度上基于函数。这是因为它"
"使用与其他脚本引擎相同的接口与引擎进行通信。在Godot中，脚本接口是通用的，并且"
"所有实现都遵循它。"

#: ../../docs/getting_started/scripting/visual_script/getting_started.rst:49
msgid "A function is an individual canvas with nodes connected."
msgstr "函数是一个具有节点连接的个人画布。"

#: ../../docs/getting_started/scripting/visual_script/getting_started.rst:51
msgid ""
"A single script can contain many functions, each of which will have a canvas "
"of its own, allowing for more organization."
msgstr ""
"单个脚本可以包含许多函数，每个函数都有自己的画布，从而允许进行更多的组织。"

#: ../../docs/getting_started/scripting/visual_script/getting_started.rst:53
msgid "There are three main ways to add functions in a script:"
msgstr "在脚本中添加函数的主要方法有三种:"

#: ../../docs/getting_started/scripting/visual_script/getting_started.rst:56
#, fuzzy
msgid "Overriding a virtual function"
msgstr "重写虚函数"

#: ../../docs/getting_started/scripting/visual_script/getting_started.rst:58
msgid ""
"Most types of nodes and other types of objects in Godot contain virtual "
"functions. These are functions that will be called (run your code) when "
"something happens and can be looked up in the reference. Virtual functions "
"are listed when pressing the \"Override\" icon in the member panel:"
msgstr ""
"Godot中大多数类型的节点和其他类型的对象都包含虚拟函数。这些函数在发生某些事情"
"时将被调用(运行代码)，并且可以在引用中查找。当按下成员面板中的“覆盖”图标时，"
"将列出虚拟功能:"

#: ../../docs/getting_started/scripting/visual_script/getting_started.rst:65
msgid ""
"In the following example, a function will be executed when the node is "
"loaded and added to the running scene. For this, the _ready() virtual method "
"will be overridden:"
msgstr ""
"在下面的示例中，当节点被加载并添加到运行场景时，将执行一个函数。为此，将重写 "
"_ready() 虚拟方法:"

#: ../../docs/getting_started/scripting/visual_script/getting_started.rst:71
msgid "Finally, a canvas appears for this function, showing the override:"
msgstr "最后，一个画布出现在这个函数上，显示了覆盖:"

#: ../../docs/getting_started/scripting/visual_script/getting_started.rst:76
msgid ""
"As some functions expect you to return a value, they will also add a return "
"node where such value is supposed to be provided:"
msgstr ""
"由于一些函数期望您返回一个值，因此它们还将添加一个返回节点，其中应该提供这样"
"的值:"

#: ../../docs/getting_started/scripting/visual_script/getting_started.rst:83
#, fuzzy
msgid "Connecting a signal to a function"
msgstr "将信号连接到函数上"

#: ../../docs/getting_started/scripting/visual_script/getting_started.rst:85
msgid ""
"Nodes in a tree emit signals when something happens. Godot uses signals for "
"all sorts of things. A typical example would be a button that emits a "
"\"pressed\" signal when actually pressed."
msgstr ""
"树中的节点在发生某些事情时发出信号。Godot用各种各样的信号。一个典型的示例就是"
"按钮，当实际按下时，它会发出“按下”的信号。"

#: ../../docs/getting_started/scripting/visual_script/getting_started.rst:88
msgid ""
"For this, a node must be selected and the Node tab opened. This will allow "
"inspecting the signals. Once they are displayed, connect the \"pressed\" "
"signal:"
msgstr ""
"为此，必须选择一个节点并打开节点选项卡。这将允许检查信号。一旦它们被显示，连"
"接“按下”信号:"

#: ../../docs/getting_started/scripting/visual_script/getting_started.rst:94
msgid ""
"This will open the connection dialog. In this dialog, you must select the "
"node where the signal will be connected to, and the function that will "
"receive the signal:"
msgstr ""
"这将打开连接对话框。在这个对话框中，您必须选择信号将被连接到的节点，以及接收"
"信号的函数:"

#: ../../docs/getting_started/scripting/visual_script/getting_started.rst:100
msgid ""
"If this is done right, a new function will be created in our script and a "
"signal will automatically be connected to it:"
msgstr ""
"如果完全按照这样做，一个新的函数将创建在我们的脚本中和一个信号将自动连接到它:"

#: ../../docs/getting_started/scripting/visual_script/getting_started.rst:107
#, fuzzy
msgid "Creating a function manually"
msgstr "手动创建函数"

#: ../../docs/getting_started/scripting/visual_script/getting_started.rst:109
msgid ""
"The last way to create functions is to do it manually. In general, this is "
"not as common unless you really need it. Custom functions work when another "
"(or the same) script calls them manually. The main use cases for this are "
"breaking a larger function up into several manageable chunks and reusing "
"your visual code."
msgstr ""
"创建函数的最后一种方法是手动完成。一般来说，除非您真的需要，否则这是不常见"
"的。当另一个(或同一个)脚本手动调用它们时，自定义函数会起作用。这样做的主要用"
"例是将一个函数分成多个，或者重用您的可视化代码。"

#: ../../docs/getting_started/scripting/visual_script/getting_started.rst:113
msgid ""
"To create a function manually, push the big \"Plus\" button, and a new "
"function will be added with a default name:"
msgstr "要手动创建函数，请按下“Plus”按钮，然后将添加一个具有默认名称的新函数:"

#: ../../docs/getting_started/scripting/visual_script/getting_started.rst:119
msgid ""
"This will add a new function, which can be renamed by simply double clicking "
"its name:"
msgstr "这将添加一个新函数，只需双击其名称即可重命名该函数:"

#: ../../docs/getting_started/scripting/visual_script/getting_started.rst:125
msgid ""
"To edit the \"arguments\" this function can get (the values you pass to it "
"when you call this function), simply click the Function node and check the "
"inspector:"
msgstr ""
"要编辑此函数得到的“参数”(调用此函数时传递给它的值)，只需单击“函数”节点并检查"
"属性面板:"

#: ../../docs/getting_started/scripting/visual_script/getting_started.rst:131
msgid "More on that will be explained later in this document."
msgstr "关于这一点的更多内容，将在本文后面解释。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:4
msgid "Nodes and terminology"
msgstr "节点与术语"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:6
msgid ""
"Before continuing, it must be noted that the *Node* terminology needs to be "
"used with care. When referring to *Visual Script Nodes* (or generally "
"*Nodes*) this text will refer to the little boxes you connect with lines, "
"which are part of a graph. When referring to *Scene Nodes*, it is implied "
"that the elements that make up a Scene are being referred, which are part of "
"a tree. Their naming is similar but their function is different. When "
"referring to *Node* here, it will be implied that a *Visual Script Node* is "
"referred to unless indicated otherwise."
msgstr ""
"在继续之前，必须注意 *节点* 术语需要谨慎使用。 当引用 *可视化脚本节点* (或通"
"常为 *节点* )时，此文本是指与线连接的小方框，它是图的一部分。 当引用 *场景节"
"点* 时，它暗指构成场景的元素，它是树的一部分。 他们的命名类似，但他们的功能是"
"不同的。 在此处谈到 *节点* 时，除非另有说明，否则将暗指 *可视化脚本节点* 。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:15
msgid "Node properties"
msgstr "节点属性"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:17
msgid ""
"Like in most visual scripting implementations, each node has editable "
"properties. In Godot, though, we try to avoid bloating the nodes with "
"editable controls for the sake of readability."
msgstr ""
"与大多数可视化脚本实现一样，每个节点都具有可编辑的属性。 但是，在Godot中，为"
"了便于阅读，我们尽量避免使用可编辑的控件来复杂化节点。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:20
msgid ""
"Nodes still display the required information as text, but editing is done "
"via the *Inspector*. To edit them, select any node and edit its properties "
"in the *Inspector*."
msgstr ""
"节点仍然以文本形式显示所需信息，但编辑是通过 *属性面板* 完成的。 要编辑它们，"
"请选择任何节点并在 *属性面板* 中编辑其属性。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:25
msgid "Ports and connections"
msgstr "端口和连接"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:27
msgid ""
"Programming in Godot Visual Scripting is done via *Nodes* and *Port "
"Connections* inside each function."
msgstr "Godot的可视化编程，是通过每个函数内的 *节点* 和 *端口连接* 来完成的。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:31
msgid "Ports"
msgstr "端口"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:33
msgid ""
"Nodes in Godot Visual Scripting have *Ports*. These are endpoints that "
"appear to the left and right of nodes and which can be used to make "
"*Connections*: There are two types of *Ports*: *Sequence* and *Data*."
msgstr ""
"Godot可视化编程中的节点有 *端口* 。 它们是出现在节点左侧和右侧的端点，可用于"
"制作 *连接* :有两种类型的 *端口* : *顺序* 和 *数据* 。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:40
msgid ""
"*Sequence Ports* indicate the order in which operations are executed. "
"Typically when a *Node* is done processing, it will go to the next node from "
"one of the ports at the right. If nothing is connected, the function may "
"end, or another output *Sequence Port* might be tried (this depends on the "
"node). Thanks to this, you can follow the logic flow within a function by "
"following the white lines. Not every *Node* has *Sequence Ports*. In fact, "
"most do not."
msgstr ""
"*顺序端口* 表示执行操作的顺序。 通常当 *节点* 完成处理时，它将从右边的一个端"
"口进入下一个节点。 如果没有连接，则该函数可能结束，或者可能尝试另一个输出 *顺"
"序端口*(这取决于节点)。 多亏了这一点，您可以通过遵循白线来跟踪函数内的逻辑流"
"程。 并非每个 *节点* 都有 *顺序端口* 。 事实上，大多数没有。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:46
msgid ""
"*Data Ports* ports contain typed values. Types can be any regular Godot "
"types, such as a boolean, an integer, a string, a Vector3, an array, any "
"Object or Scene Node, etc. A *Data Port* on the right side of a node is "
"considered an output, while, a port on the left side is an input. Connecting "
"them allows information to flow to the next node."
msgstr ""
"*数据端口* 包含具有类型的值。 类型可以是任何常规的Godot类型，例如布尔值，整"
"数，字符串，Vector3，数组，任何对象或场景节点等。节点右侧的 *数据端口* 被视为"
"输出， 而左侧的端口是输入。 连接它们，从而使得信息流到下一个节点。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:51
msgid ""
"Not all *Data Port* types are compatible and will allow connections, though. "
"Pay special attention to colors and icons, as each type has a different "
"representation:"
msgstr ""
"但并非所有的 *数据端口* 类型都兼容并且允许连接。 要特别注意颜色和图标，因为每"
"种类型都有不同的表示形式:"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:58
#: ../../docs/development/file_formats/tscn.rst:27
msgid "Connections"
msgstr "连接"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:60
msgid ""
"Connecting is a relatively simple process. Drag an *Output Port* towards an "
"*Input Port*."
msgstr "连接是一个相对简单的过程。 将 *输出端口* 拖向 *输入端口* 。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:65
msgid ""
"Disconnecting takes a bit more practice. Disconnecting in *Data Ports* "
"happens by dragging the *Input* away, while for *Sequence Ports*, this "
"happens by dragging the *Output* away."
msgstr ""
"断开连接需要一点练习。 断开 *数据端口* 是通过拖离 *输入* 来实现的，而对于 *顺"
"序端口*，则通过拖离 *输出* 来实现。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:71
msgid ""
"This may seem strange at first, but it happens because *Data Ports* are 1:N "
"(A single output port can connect to many inputs), while *Sequence Ports* "
"are N:1 (Many sequence outputs can be connected to a single input)."
msgstr ""
"这在开始时可能看起来很奇怪，但它发生是因为 *数据端口* 是1:N(单个输出端口可以"
"连接到许多输入)，而 *顺序端口* 是 N:1(许多顺序输出可以连接到单个输入)。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:75
msgid ""
"Connecting to empty space (drag to connect but unpress over empty space) is "
"also context sensitive, it will supply a list of most common operations. For "
"sequences, it will be conditional nodes:"
msgstr ""
"连接到空白区域(拖动以连接但是在空白区域上按下)也是上下文敏感的，它将提供最常"
"见操作的列表。 对顺序，它将是条件节点:"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:81
msgid "While, for data, a contextual set/get/call menu will open:"
msgstr "而对于数据，将打开上下文设置/获取/调用菜单:"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:87
msgid "Adding nodes"
msgstr "添加节点"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:89
msgid ""
"Finally! We got to the fun part! But, before explaining in more detail what "
"each type of node does, let's take a short look at how nodes are most "
"commonly added and dealt with."
msgstr ""
"最后！ 我们到了有趣的部分！ 但是，在更详细地解释每种类型节点的作用之前，让我"
"们简单地看一下节点最常添加和处理的方式。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:94
msgid "Accessing scene nodes"
msgstr "访问场景节点"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:96
msgid ""
"One of the most common tasks is accessing Scene Tree Nodes (again, not to "
"mistake with *Visual Script Nodes*). Dragging from the Scene Tree and "
"dropping into the canvas will ask you to *call a method* (sometimes referred "
"to as *member function*) on this node."
msgstr ""
"最常见的任务之一是访问场景树节点(同样，不要误认为是 *可视脚本节点 * )。 从场"
"景树拖动并放入画布将要求您 *在此节点上调用方法* (有时称为 *成员函数* )。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:102
msgid ""
"While accessing properties is desired in most cases (more on that below), "
"sometimes *calling methods* can be useful too. Methods execute specific "
"actions on objects. In the above case, the mouse pointer can be warped to a "
"position in local coordinates to the control. Another common use case is "
"queueing a node for deletion, which is done with the *queue_free* method."
msgstr ""
"虽然在大多数情况下需要访问属性(下面有更多内容)，但有时 *调用方法* 也很有用。 "
"方法对对象执行特定操作。 在上述情况下，鼠标指针可以扭曲到控件的本地坐标中的位"
"置。 另一个常见用例是将节点排队以进行删除，这是使用 *queue_free* 方法完成的。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:109
msgid ""
"Care must be taken that this only works if the scene being edited contains "
"your *Visual Script* in one of the nodes! Otherwise, a warning will be shown."
msgstr ""
"必须注意，这只适用于正在编辑的场景在其中一个节点中包含 *可视化脚本* 的情况！ "
"否则，将显示警告。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:113
msgid "Accessing scene node properties"
msgstr "访问场景节点属性"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:115
msgid ""
"This is the most common way to edit *Scene Nodes* in Visual Scripting. "
"Select a *Scene Node* from the *Scene Tree*, go to the Inspector, find *the "
"Name* of the property you want to edit (hint, *not* the value!) and drag it "
"to the canvas:"
msgstr ""
"这是在可视化脚本中编辑 *场景节点* 的最常用方法。 从 *场景树* 中选择 *场景节点"
"* ，转到属性面板，找到要编辑的属性的名称(提示， *不* 是值！)并将其拖到画布上:"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:120
msgid ""
"The result is that this value can be changed from your script by writing to "
"a *Data Port*."
msgstr "结果是可以通过写入 *数据端口* 从脚本更改此值。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:122
msgid ""
"If instead reading this value is desired, drag the node again but hold the "
"*Control* key (or Command on Mac). This will create a getter:"
msgstr ""
"如果需要读取此值，请再次拖动节点，但按住 *Control* 键(或Mac上的Command)。 这"
"将创建一个getter:"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:127
msgid "In this case, the value can be read from a *Data Port*."
msgstr "在这种情况下，可以从 *数据端口* 读取值。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:133
msgid ""
"Variables are memory containers local to the script which can hold a value. "
"This value can be read from any of the functions of the script or from other "
"scripts via the method described in the previous step."
msgstr ""
"变量是脚本本地的内存容器，可以容纳一个值。 可以通过上一步中描述的方法从脚本的"
"任何功能或其他脚本中读取此值。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:135
msgid ""
"To add a Variable, push the \"+\" button on the *Variables* section of the "
"Members panel. Double-click the new variable to rename it:"
msgstr ""
"要添加变量，请按成员面板的 *变量* 部分中的“+”按钮。 双击新变量以重命名它:"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:140
msgid "Right-clicking the variable allows you to configure its properties:"
msgstr "右键单击该变量可以配置其属性:"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:147
msgid ""
"As it can be seen above, the type and initial value of the variable can be "
"changed, as well as some property hints. Ticking the \"Export\" option makes "
"the variable visible in the Inspector when selecting the node. This also "
"makes it available to other scripts via the method described in the previous "
"step."
msgstr ""
"如上所示，可以更改变量的类型和初始值，以及一些属性提示。 选择“导出”选项会在选"
"择节点时使属性面板中的变量可见。 这也可以通过上一步中描述的方法将其提供给其他"
"脚本。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:153
msgid ""
"To use the variable in the script, simply drag it to the canvas to create a "
"getter:"
msgstr "要在脚本中使用该变量，只需将其拖到画布上即可创建一个getter:"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:158
msgid "Likewise, hold *Control* (*Command* on Mac) to drop a setter:"
msgstr "同样，按住 *Control* (Mac上的 *Command* )删除一个setter:"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:166
msgid ""
"It is also possible to create your own signals in a script and use them. For "
"this, do the same steps you did for variables in the previous step, except "
"for *Signals*:"
msgstr ""
"也可以在脚本中创建自己的信号并使用它们。 为此，除了 *Signals* 之外，执行与上"
"一步中的变量相同的步骤:"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:171
msgid ""
"A signal can also be edited via the right-click menu to customize its "
"arguments:"
msgstr "也可以通过右键单击菜单编辑信号以自定义其参数:"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:176
msgid ""
"The signal you have created will appear in the Inspector, along with the "
"built-in node signals. This allows you to connect it from another script "
"from another *Scene Node*:"
msgstr ""
"您创建的信号将与内置节点信号一起显示在Inspector中。 这允许您从另一个 *Scene "
"Node* 的另一个脚本连接它:"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:181
msgid "Finally, to emit the signal, simply drag it to the canvas:"
msgstr "最后，要发出信号，只需将其拖到画布上:"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:186
msgid ""
"Remember that emitting a signal is a sequenced operation, so it must come "
"from a Sequence port."
msgstr "请记住，发出信号是一个有序操作，因此它必须来自一个Sequence端口。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:190
msgid "Adding more nodes"
msgstr "添加更多节点"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:192
msgid ""
"Now that the basics are covered, let's discuss the large amount of utility "
"nodes available for your canvas! Below the member panel, exists the list of "
"all available node types:"
msgstr ""
"既然已经涵盖了基础知识，那么让我们讨论一下可用于画布的大量实用程序节点！ 在成"
"员面板下方，存在所有可用节点类型的列表:"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:198
msgid "Ctrl-F (Command-F on Mac) allows you to search the list."
msgstr "Ctrl-F(Mac上的Command-F)允许您搜索列表。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:200
msgid ""
"Any of them can be dragged to the scene. Unlike nodes (e.g. dragging a "
"property from the Inspector sets the context to the node being edited "
"automatically), these are added without any \"contextual\" information, so "
"this has to be done manually."
msgstr ""
"其中任何一个都可以拖到现场。 与节点(例如，从Inspector拖动属性将上下文设置为正"
"在自动编辑的节点)不同，这些节点在没有任何“上下文”信息的情况下添加，因此必须手"
"动完成。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:206
msgid ""
"Remember that you can check the class reference for what each node does, as "
"they are documented there. That mentioned, a brief overview of node types "
"follows:"
msgstr ""
"请记住，您可以检查每个节点的类参考，因为它们在那里记录。 提到的，节点类型的简"
"要概述如下:"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:213
msgid ""
"Constant nodes are nodes that provide values that, while not changing over "
"time, can be useful as reference values. Most of the time they are integer "
"or float."
msgstr ""
"常量节点是提供值的节点，这些值虽然不随时间变化，但可用作参考值。 大多数情况下"
"它们是整数或浮点数。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:219
msgid ""
"The first one is \"Constant\", which allows you to select any value of any "
"type as constant, from an integer (42) to a String (\"Hello!\"). In general, "
"this node is not used that often because of default input values in *Data "
"Ports*, but it's good to know it exists."
msgstr ""
"第一个是“常量”，它允许您选择任何类型的任何值作为常量，从整数(42)到字符串"
"(“Hello！”)。 通常，由于 *Data Ports* 中的默认输入值，通常不使用此节点，但知"
"道它存在是很好的。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:221
msgid ""
"The second is the GlobalConstant node, which contains a long list of "
"constants for global types in Godot. In there you can find some useful "
"constants to refer to key names, joystick or mouse buttons, etc."
msgstr ""
"第二个是GlobalConstant节点，它包含Godot中全局类型的一长串常量。 在那里您可以"
"找到一些有用的常量来引用键名，操纵杆或鼠标按钮等。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:224
msgid ""
"The third one is MathConstant, which provides typical mathematical "
"constants, such as PI, E, etc."
msgstr "第三个是MathConstant，它提供典型的数学常数，如PI，E等。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:230
msgid ""
"Data nodes deal with all sorts of access to information. Any information in "
"Godot is accessed via these nodes, so they are some of the most important "
"ones to use and pretty diverse."
msgstr ""
"数据节点处理各种信息访问。 Godot中的任何信息都可以通过这些节点访问，因此它们"
"是一些最重要的使用和非常多样化的节点。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:236
msgid ""
"There are many types of nodes of interest here, so a short attempt to "
"describe them will follow:"
msgstr "这里有许多类型的感兴趣的节点，因此将对其进行简短的描述:"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:240
msgid "Action"
msgstr "动作"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:242
msgid ""
"Action nodes are vital when dealing with input from a device. You can read "
"more about actions in the (@TODO ACTION TUTE LINK). In the following example "
"below, the control is moved to the right when the \"move_right\" action is "
"pressed."
msgstr ""
"在处理来自设备的输入时，动作节点是至关重要的。 您可以在 (@TODO ACTION TUTE "
"LINK) 中阅读有关操作的更多信息。 在下面的示例中，当按下“move_right”动作时，控"
"件将移动到右侧。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:249
msgid "Engine Singleton"
msgstr "引擎单例"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:251
msgid ""
"Engine singletons are global interfaces (meaning they can be accessed "
"without a reference; unlike Scene Nodes, they are always available). They "
"have several purposes, but in general, they are useful for low-level access "
"or OS-related access."
msgstr ""
"引擎单例是全局接口(意味着它们可以在没有引用的情况下访问，与场景节点不同，它们"
"始终可用)。 它们有多种用途，但通常它们对于低级访问或与操作系统相关的访问很有"
"用。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:257
msgid ""
"Remember that dragging a connection to empty space will help you call "
"functions or set/get properties on these:"
msgstr "请记住，将连接拖动到空白区域将帮助您调用函数或设置/获取以下属性:"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:263
msgid "Local Variables"
msgstr "局部变量"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:265
msgid ""
"These are nodes you can use as temporary storage for your graphs. Make sure "
"they all have the same name and type when using them and they will reference "
"the same piece of memory."
msgstr ""
"这些节点可用作图形的临时存储。 确保它们在使用时都具有相同的名称和类型，它们将"
"引用相同的内存。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:270
msgid ""
"As it can be seen above, there are two nodes available: A simple getter, and "
"a sequenced getter (setting requires a sequence port)."
msgstr ""
"从上面可以看出，有两个节点可用:一个简单的getter和一个有序的getter(设置需要一"
"个序列端口)。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:274
msgid "Scene Node"
msgstr "场景节点"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:276
msgid ""
"This is just a reference to a node in the tree, but it's easier to use this "
"node by dragging the actual node from the scene tree to the canvas (this "
"will create it and configure it)."
msgstr ""
"这只是对树中节点的引用，但通过将实际节点从场景树拖动到画布(这将创建并配置"
"它)，可以更轻松地使用此节点。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:281
msgid "Self"
msgstr "自身"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:283
msgid ""
"In some rare occasions, it may be desired to pass this Scene Node as "
"argument. It can be used to call functions and set/get properties, or drag "
"nodes (or event the node itself that has the script) from the Scene Tree to "
"the canvas for this."
msgstr ""
"在极少数情况下，可能需要将此场景节点作为参数传递。 它可用于调用函数和设置/获"
"取属性，或将节点(或将具有脚本的节点本身的事件)从“场景树”拖动到画布。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:290
msgid ""
"This node is similar to the Singleton node because it references the "
"SceneTree, which contains the active scene. SceneTree, however, only works "
"when the node is sitting in the scene and active, otherwise accessing it "
"will return an error."
msgstr ""
"此节点类似于Singleton节点，因为它引用包含活动场景的SceneTree。 但是，"
"SceneTree仅在节点位于场景中并且处于活动状态时才起作用，否则访问它将作为错误返"
"回。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:294
msgid ""
"SceneTree allows for many low-level things, like setting stretch options, "
"calling groups, make timers, or even load another scene. It's a good class "
"to get familiar with."
msgstr ""
"SceneTree允许许多低级别的事情，比如设置拉伸选项，调用组，制作计时器，甚至加载"
"另一个场景。 熟悉这是一个很好的课程。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:299
msgid "Preload"
msgstr "预载"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:301
msgid ""
"This does the same function as preload() in GDScript. It maintains this "
"resource loaded and ready to use. Rather than instancing the node, it's "
"simpler to drag the desired resource from the filesystem dock to the canvas."
msgstr ""
"这与GDScript中的preload()功能相同。 它维护此资源已加载并可以使用。 而不是实例"
"化节点，将所需资源从文件系统停靠点拖到画布上更简单。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:306
msgid "Resource Path"
msgstr "资源路径"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:308
msgid ""
"This node is a simple helper to get a string with a path to a resource you "
"can pick. It's useful in functions that load things from disk."
msgstr ""
"此节点是一个简单的帮助器，用于获取包含可以选择的资源的路径的字符串。 它在从磁"
"盘加载东西的函数中很有用。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:313
msgid "Comment"
msgstr "注释"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:315
msgid ""
"A Comment node works as a node you can resize to put around other nodes. It "
"will not try to get focus or be brought to top when selecting it. It can "
"also be used to write text on it."
msgstr ""
"Comment节点用作可以调整大小以放置其他节点的节点。 在选择它时，它不会试图获得"
"焦点或被放到首位。 它也可以用来在上面写文字。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:322
msgid "Flow Control"
msgstr "流程控制"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:324
msgid ""
"Flow control nodes allow the execution to take different branches, usually "
"depending on a given condition."
msgstr "流控制节点允许执行采用不同的分支，通常取决于给定的条件。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:331
msgid "Condition"
msgstr "Condition"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:333
msgid ""
"This is a simple node that checks a bool port. If true, it will go via the "
"\"true\" sequence port. If false, the second. After going for either of "
"them, it goes via the \"done\" port. Leaving sequence ports disconnected is "
"fine if not all of them are used."
msgstr ""
"这是一个检查bool端口的简单节点。 如果为true，它将通过“true”序列端口。 如果是"
"假的话，第二个。 在找到其中任何一个后，它通过“done”端口。 如果不是全部使用，"
"则断开序列端口的连接是很好的。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:339
msgid "Iterator"
msgstr "迭代器"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:341
msgid ""
"Some data types in Godot (ie, arrays, dictionaries) are iterable. This means "
"that a bit of code can run for each element that it has."
msgstr ""
"Godot中的一些数据类型(即数组，字典)是可迭代的。 这意味着可以为它拥有的每个元"
"素运行一些代码。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:344
msgid ""
"The Iterator node goes through all elements and, for each of them, it goes "
"via the \"each\" sequence port, making the element available in the \"elem\" "
"data port."
msgstr ""
"Iterator节点遍历所有元素，并且对于每个元素，它通过“each”序列端口，使元素"
"在“elem”数据端口中可用。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:347
msgid "When done, it goes via the \"exit\" sequence port."
msgstr "完成后，它通过“exit”序列端口。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:351
msgid "Return"
msgstr "Return"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:353
msgid ""
"Some functions can return values. In general for virtual ones, Godot will "
"add the Return node for you. A return node forces the function to end."
msgstr ""
"某些函数可以返回值。 一般来说，对于虚拟的，Godot会为您添加Return节点。 返回节"
"点强制函数结束。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:358
msgid "Sequence"
msgstr "Sequence"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:360
msgid ""
"This node is useful mostly for organizing your graph. It calls its sequence "
"ports in order."
msgstr "此节点主要用于组织图形。 它按顺序调用其序列端口。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:364
msgid "TypeCast"
msgstr "类型转换"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:366
msgid ""
"This is a useful and commonly used node. You can use it to cast arguments or "
"other objects to the type you desire. Afterwards, you can even drag the "
"object output to get full completion."
msgstr ""
"这是一个有用且常用的节点。 您可以使用它将参数或其他对象转换为您想要的类型。 "
"之后，您甚至可以拖动对象输出以完全完成。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:372
msgid ""
"It is also possible to cast to a script, which will allow complete script "
"properties and functions:"
msgstr ""
"也可以转换为脚本，这将允许完整的脚本属性和功能:也可以转换为脚本，这将允许完整"
"的脚本属性和功能:"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:378
msgid "Switch"
msgstr "选择"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:380
msgid ""
"The Switch node is similar to the Condition node, but it matches many values "
"at the same time."
msgstr "Switch节点类似于Condition节点，但它同时匹配许多值。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:386
msgid ""
"This is a more primitive form of iteration. \"repeat\" sequence output will "
"be called as long as the condition in the \"cond\" data port is met."
msgstr ""
"这是一种更原始的迭代形式。 只要满足“cond”数据端口中的条件，就会调用“重复”序列"
"输出。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:393
msgid ""
"Functions are simple helpers, most of the time deterministic. They take some "
"arguments as input and return an output. They are almost never sequenced."
msgstr ""
"这是一个有用且常用的节点。 您可以使用它将参数或其他对象转换为您想要的类型。 "
"之后，您甚至可以拖动对象输出以完全完成。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:398
msgid "Built-In"
msgstr "内置"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:400
msgid ""
"There is a list of built-in helpers. The list is almost identical to the one "
"from GDScript (@TODO, link to gdscript methods?). Most of them are "
"mathematical functions, but others can be useful helpers. Make sure to take "
"a look at the list at some point."
msgstr ""
"有一个内置帮助器列表。 该列表几乎与GDScript中的列表相同 (@TODO, link to "
"gdscript methods?) 。 其中大多数是数学函数，但其他人可能是有用的助手。 请务必"
"在某个时候查看列表。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:406
msgid "By Type"
msgstr "按类型"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:408
msgid ""
"Those are the methods available to basic types. For example, if you want a "
"dot-product, you can search for \"dot\" instead of the Vector3 category. In "
"most cases just search the list of nodes, it should be faster."
msgstr ""
"这些是基本类型可用的方法。例如，如果您想要一个点积，您可以搜索“点”而不是"
"Vector3类型。在大多数情况下，只需搜索节点列表，就应该更快。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:413
msgid "Call"
msgstr "调用"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:415
msgid ""
"This is the generic calling node. It is rarely used directly but by dragging "
"to empty space on an already configured node."
msgstr ""
"这是通用调用节点。它很少直接使用，而是通过拖动到已配置的节点上的空白空间来使"
"用。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:419
msgid "Constructors"
msgstr "构造函数"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:421
msgid ""
"These are all the functions needed to create Godot basic datatypes. For "
"example, If you need to create a Vector3 out of 3 floats, a constructor must "
"be used."
msgstr ""
"这些是创建Godot基本数据类型所需的所有函数。例如，如果需要从3个浮点数中创建一"
"个Vector3，则必须使用构造函数。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:427
msgid "Destructor"
msgstr "析构函数"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:429
msgid ""
"This is the opposite to Constructor, it allows to separate any basic type "
"(ie, Vector3) into its sub-elements."
msgstr "这与构造函数相反，它允许将任何基本类型(即Vector3)分离到子元素中。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:435
msgid "Emit Signal"
msgstr "发射信号"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:437
msgid ""
"Emits signals from any object. In general it's not that useful, as dragging "
"a signal to the canvas works better."
msgstr ""
"从任何物体发出信号。一般来说，这并不是很有用，因为拖动信号到画布的效果更好。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:441
msgid "Get/Set"
msgstr "获取/设置"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:443
msgid ""
"Generic Getter/Setter node. Dragging properties from the Inspector works "
"better, as they appear properly configured on drop."
msgstr ""
"通用的Getter/Setter节点。从属性面板中拖拽属性效果更好，因为在拖放时它们就被正"
"确配置。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:447
msgid "Wait"
msgstr "等待"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:449
msgid ""
"The Wait nodes will suspend execution of the function until something "
"happens (many frames can pass until resuming, in fact). Default nodes allow "
"you to wait for a frame to pass, a fixed frame or a given amount of time "
"until execution is resumed."
msgstr ""
"等待节点将暂停执行函数直到发生某些事情(实际上，许多帧可以通过，直到恢复)。默"
"认节点允许您等待帧通过、固定帧或给定的时间量，直到执行恢复为止。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:454
#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:298
msgid "Yield"
msgstr "Yield"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:456
msgid ""
"This node completely suspends the execution of the script, and it will make "
"the function return a value that can be used to resume execution."
msgstr "这个节点完全暂停脚本的执行，它将使函数返回一个值，该值可用于恢复执行。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:460
msgid "Yield Signal"
msgstr "Yield 信号"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:462
msgid "Same as Yield, but will wait until a given signal is emitted."
msgstr "与Yield相同，但要等到一个给定的信号发出。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:466
msgid "Index"
msgstr "索引"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:468
msgid ""
"Generic indexing operator, not often used but it's good that it exists just "
"in case."
msgstr "泛型索引操作符，不常用，但它的存在是好的，以防万一。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:474
msgid ""
"These are mostly generic operators, such as addition, multiplication, "
"comparison, etc. By default, these mostly accept any datatype (and will "
"throw an error at run-time if the types fed do not match those expected by "
"the operator). It is always recommended to set the right type for operators "
"to catch errors faster and make the graph easier to read."
msgstr ""
"这些操作符主要是通用的操作符，如加法、乘法、比较等。默认情况下，这些操作符主"
"要接受任何数据类型(如果输入的类型与操作符不匹配，则会在运行时出错)。建议始终"
"为操作符设置正确的类型，以更快地捕捉错误并使图形更易于阅读。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:483
msgid "Expression Node"
msgstr "表达式节点"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:485
msgid ""
"Among the operators, the *Expression* node is the most powerful. If well "
"used, it allows you to enormously simplify visual scripts that are math or "
"logic heavy. Type any expression on it and it will be executed in real-time."
msgstr ""
"在运算符中， *Expression* 节点是最强大的。 如果使用得当，它可以让您获得数学或"
"逻辑繁重的视觉可视化脚本。 在其上键入任何表达式，它将实时执行。"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:488
msgid "Expression nodes can:"
msgstr "表达式节点可以:"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:490
msgid ""
"Perform math and logic expressions based on custom inputs (eg: \"a*5+b\", "
"where a and b are custom inputs):"
msgstr ""
"基于自定义输入执行数学和逻辑表达式(例如:“a*5 + b”，其中a和b是自定义输入):"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:495
msgid "Access local variables or properties:"
msgstr "访问局部变量或属性:"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:500
msgid ""
"Use most of the existing built-in functions that are available to GDScript, "
"such as sin(),cos(),print(), as well as constructors, such as Vector3(x,y,z),"
"Rect2(..), etc.:"
msgstr ""
"使用GDScript可用的大多数现有内置函数，例如 sin(),cos(),print()，以及构造函"
"数，例如Vector3(x，y，z)，Rect2(..) 等:"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:505
msgid "Call API functions:"
msgstr "调用API函数:"

#: ../../docs/getting_started/scripting/visual_script/nodes_purposes.rst:510
msgid ""
"Use sequenced mode, which makes more sense in case of respecting the "
"processing order:"
msgstr "使用顺序模式，在遵守处理顺序的情况下更有意义:"

#: ../../docs/getting_started/scripting/c_sharp/index.rst:2
#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:30
#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:59
#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:188
#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:203
#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:215
#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:226
#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:234
#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:249
#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:261
#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:321
#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:115
msgid "C#"
msgstr "C#"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_basics.rst:6
#, fuzzy
msgid ""
"C# support is a new feature available since Godot 3.0. As such, you may "
"still run into some issues, or find spots where the documentation could be "
"improved. Please report issues with C# in Godot on the `engine GitHub page "
"<https://github.com/godotengine/godot/issues>`_, and any documentation "
"issues on the `documentation GitHub page <https://github.com/godotengine/"
"godot-docs/issues>`_."
msgstr ""
"C#支持是Godot 3.0的一个新功能。 因此，您可能仍会遇到一些问题，或者找到可以改"
"进文档的位置。 请在 `引擎Github页面 <https://github.com/godotengine/godot/"
"issues>`_ 上报告Godot中C#的问题。 关于 `文档Github Page <https://github.com/"
"godotengine/godot-docs/issues>`_ 的任何文档问题。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_basics.rst:14
#, fuzzy
msgid ""
"This page provides a brief introduction to C#, both what it is and how to "
"use it in Godot. Afterwards, you may want to look at :ref:`how to use "
"specific features <doc_c_sharp_features>`, read about the :ref:`differences "
"between the C# and the GDScript API <doc_c_sharp_differences>` and (re)visit "
"the :ref:`Scripting section <doc_scripting>` of the step-by-step tutorial."
msgstr ""
"这个页面简要介绍了C#，它是什么以及如何在Godot中使用它。 之后，您可能需要查"
"看 :ref:`如何使用特定功能 <doc_c_sharp_features>`，阅读 :ref:`C#和GDScript "
"API之间的差异 <doc_c_sharp_differences>` 和(重新)访问 :ref:`逐步教程的脚本部"
"分 <doc_scripting>`。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_basics.rst:21
msgid ""
"C# is a high-level programming language developed by Microsoft. In Godot, it "
"is implemented with the Mono 5.x .NET framework, including full support for "
"C# 7.0. Mono is an open source implementation of Microsoft's .NET Framework "
"based on the ECMA standards for C# and the Common Language Runtime. A good "
"starting point for checking its capabilities is the `Compatibility <http://"
"www.mono-project.com/docs/about-mono/compatibility/>`_ page in the Mono "
"documentation."
msgstr ""
"C#是Microsoft开发的一种高级编程语言。 在Godot中，它是使用Mono 5.x .NET框架实"
"现的，包括对C#7.0的完全支持。 Mono是Microsoft .NET Framework的开源实现，基于"
"ECMA的C#标准和公共语言运行时。 检查其功能的一个很好的起点是Mono文档中的“兼容"
"性<http://www.mono-project.com/docs/about-mono/compatibility/>`_ 页面。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_basics.rst:29
msgid ""
"This is **not** a full-scale tutorial on the C# language as a whole. If you "
"aren't already familiar with its syntax or features, see the `Microsoft C# "
"guide <https://docs.microsoft.com/en-us/dotnet/csharp/index>`_ or look for a "
"suitable introduction elsewhere."
msgstr ""
"这不是一个关于C#语言整体的全面教程。 如果您还不熟悉其语法或功能，请参阅 "
"`Microsoft C#指南 <https://docs.microsoft.com/en-us/dotnet/csharp/index>`_ 或"
"在其他地方寻找合适的介绍。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_basics.rst:36
#, fuzzy
msgid "Setting up C# for Godot"
msgstr "为Godot设置C#"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_basics.rst:41
msgid ""
"Download and install the latest version of `Visual Studio <https://"
"visualstudio.microsoft.com/downloads/>`_ (*not* Visual Studio Code), which "
"contains utilities required to use C# in Godot. If you don't plan on using "
"the Visual Studio IDE, you can download just the `Visual Studio Build Tools "
"<https://visualstudio.microsoft.com/thank-you-downloading-visual-studio/?"
"sku=BuildTools&rel=15>`_ instead. Make sure you at least have the .NET "
"Framework 4.5 targeting pack installed, you can get it using any of the "
"installers mentioned above inside the \"Individual components\" tab."
msgstr ""
"下载并安装最新版本的`Visual Studio <https://visualstudio.microsoft.com/"
"downloads/>`_ （*不是* Visual Studio Code！），它会包含Godot中用到的C#工具。"
"如果你不打算用Visual Studio IDE的话，也可以只用下载 `Visual Studio Build "
"Tools <https://visualstudio.microsoft.com/thank-you-downloading-visual-"
"studio/?sku=BuildTools&rel=15>`_ 。你可以在上述任何安装程序中的“独立组件”选项"
"卡里找到 .NET Framework 4.5 targeting pack，请确保安装。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_basics.rst:51
#, fuzzy
msgid "macOS and Linux"
msgstr "在Linux上:"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_basics.rst:53
msgid ""
"Download and install the latest version of the `Mono SDK <http://www.mono-"
"project.com/download/>`_. As of Godot 3.1 beta 3, the version number doesn't "
"matter since Godot bundles its own Mono 5.18 installation. We only need the "
"Mono installation for NuGet and MSBuild which are required to use C# in "
"Godot."
msgstr ""
"下载并安装最新版本的 `Mono SDK <http://www.mono-project.com/download/>`_ 。对"
"于Godot 3.1 beta 3，下载的哪个版本都无所谓，因为Godot自身就捆绑了Mono 5.18的"
"安装。我们只需要为NuGet和MSBuild安装Mono就可以，那正是Godot中C#需要的。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_basics.rst:59
#, fuzzy
msgid ""
"To download Mono on macOS, use the \"Stable Channel\" link from the `Mono "
"Downloads Page <http://www.mono-project.com/download/>`_. The Visual Studio "
"channel is an earlier version of Mono and will not work."
msgstr ""
"要在Mac上下载Mono v5.12 +，请从“Mono Downloads Page <http://www.mono-project."
"com/download/>`_ 找到”稳定通道“链接。 Visual Studio频道是Mono的早期版本，不适"
"用于Godot 3.0.3+。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_basics.rst:65
#, fuzzy
msgid "Additional notes"
msgstr "附加信息:"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_basics.rst:67
#, fuzzy
msgid ""
"Your Godot version must have Mono support enabled, so make sure to download "
"the **Mono version** of Godot. If you are building Godot from source, make "
"sure to follow the steps to enable Mono support in your build as outlined in "
"the :ref:`doc_compiling_with_mono` page."
msgstr ""
"如果您从源代码构建Godot，请确保按照以下步骤在您的构建中包含Mono支持 :ref:"
"`doc_compiling_with_mono` 页面。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_basics.rst:73
#, fuzzy
msgid ""
"In summary, you must have installed Visual Studio or Mono (depending on your "
"operating system) **and** the Mono-enabled version of Godot."
msgstr ""
"总之，您必须已经为您的Godot版本安装了1)正确的Mono SDK版本，以及2)Godo的Mono版"
"本。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_basics.rst:77
msgid "Configuring an external editor"
msgstr "配置外部编辑器"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_basics.rst:79
#, fuzzy
msgid ""
"C# support in Godot's script editor is minimal. Consider using an external "
"IDE or editor, such as  `Visual Studio Code <https://code.visualstudio.com/"
">`_ or MonoDevelop. These provide autocompletion, debugging, and other "
"useful features for C#. To select an external editor in Godot, click on "
"**Editor → Editor Settings** and scroll down to **Mono**. Under **Mono**, "
"click on **Editor**, and select your external editor of choice."
msgstr ""
"虽然Godot确实有自己的脚本编辑器，但它对C#的支持很少，建议您使用外部IDE或编辑"
"器，如Microsoft Visual Studio Code或MonoDevelop，它们提供自动完成，调试和其他"
"有用的功能 使用C#时。 要进行设置，请在Godot中单击“编辑器”，然后单击“编辑器设"
"置”。 向下滚动到“Mono”设置。 在Mono下单击 ``Editor`` ，然后在该页面上选择您选"
"择的外部编辑器。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_basics.rst:87
msgid ""
"If you are using Visual Studio Code, ensure you download and install the `C# "
"extension <https://marketplace.visualstudio.com/items?itemName=ms-vscode."
"csharp>`_ to enable features like syntax highlighting and IntelliSense."
msgstr ""
"如果你在使用Visual Studio Code，请确保下载了 `C# 插件 <https://marketplace."
"visualstudio.com/items?itemName=ms-vscode.csharp>`_ 以启用诸如IntelliSense和"
"语法高亮的特性。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_basics.rst:92
msgid "Creating a C# script"
msgstr "创建C#脚本"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_basics.rst:94
#, fuzzy
msgid ""
"After you successfully set up C# for Godot, you should see the following "
"option when selecting ``Attach script`` in the context menu of a node in "
"your scene:"
msgstr ""
"成功为Godot设置C#后，在场景中节点的上下文菜单中选择“Attach script”时，应该会"
"看到以下选项:"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_basics.rst:99
#, fuzzy
msgid ""
"Note that while some specifics change, most concepts work the same when "
"using C# for scripting. If you're new to Godot, you may want to follow the "
"tutorials on :ref:`doc_scripting` at this point. While some places in the "
"documentation still lack C# examples, most concepts can be transferred "
"easily from GDScript."
msgstr ""
"请注意，虽然某些细节发生了变化，但在使用C#进行脚本编写时，大多数情况都是一样"
"的。 如果您是Godot的新手，您可能需要仔细阅读以下教程 :ref:`doc_scripting`。 "
"虽然文档中的某些地方仍缺少C#示例，但大多数内容都可以从GDScript轻松转移。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_basics.rst:106
msgid "Project setup and workflow"
msgstr "项目设置和工作流程"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_basics.rst:108
#, fuzzy
msgid ""
"When you create the first C# script, Godot initializes the C# project files "
"for your Godot project. This includes generating a C# solution (``.sln``) "
"and a project file (``.csproj``), as well as some utility files and folders "
"(``.mono`` and ``Properties/AssemblyInfo.cs``). All of these but ``.mono`` "
"are important and should be committed to your version control system. ``."
"mono`` can be safely added to the ignore list of your VCS. When "
"troubleshooting, it can sometimes help to delete the ``.mono`` folder and "
"let it regenerate."
msgstr ""
"当您创建第一个C#脚本时，Godot会为您的Godot项目初始化C#项目文件。 这包括生成C#"
"解决方案( ``.sln`` )和项目( ``.csproj`` )以及一些实用程序文件和文件夹( ``."
"mono`` ，有时是 ``Properties`` )。 除了 ``.mono`` 之外的所有这些都很重要，应"
"该保存在您的版本控制系统中。 ``.mono``可以安全地添加到VCS的忽略列表中。 在进"
"行故障排除时，有时可以帮助删除 ``.mono`` 文件夹并让它重新生成。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_basics.rst:117
#, fuzzy
msgid ""
"Note that currently, there are some issues where Godot and the C# project "
"don't stay in sync; if you delete, rename or move a C# script, the change "
"may not be reflected in the C# project file. In cases like this, you will "
"have to edit the C# project file manually."
msgstr ""
"请注意，目前Godot和C#项目存在一些不同步的问题; 如果删除，重命名或移动脚本或节"
"点等内容，它们可能不再匹配。 在这种情况下，可以帮助手动编辑解决方案文件。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_basics.rst:122
#, fuzzy
msgid ""
"For example, if you created a script (e.g. ``Test.cs``) and delete it in "
"Godot, compilation will fail because the missing file is still expected to "
"be there by the C# project file. For now, you can simply open up the ``."
"csproj`` file and look for the ``ItemGroup``, there should be a line "
"included like the following:"
msgstr ""
"示例:如果您创建了一个脚本(例如 ``Test.cs`` )并在Godot中将其删除，则编译将失"
"败，因为现在仍然希望CS项目存在丢失的文件。 您现在可以简单地打开 ``.csproj`` "
"并查找 ``ItemGroup`` ，应该包含如下所示的一行:"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_basics.rst:136
#, fuzzy
msgid ""
"Simply remove that line and your project should build correctly again. Same "
"for renaming and moving things, simply rename and move them in the project "
"file if needed."
msgstr ""
"只需删除该行，您的项目现在应该再次构建正常。 对于重命名和移动内容，只需重命名"
"并在项目文件中移动它们(如果需要)。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_basics.rst:141
#: ../../docs/tutorials/io/background_loading.rst:87
#: ../../docs/tutorials/misc/pausing_games.rst:71
msgid "Example"
msgstr "示例"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_basics.rst:143
msgid ""
"Here's a blank C# script with some comments to demonstrate how it works."
msgstr "这是一个空白的C#脚本，带有一些注释来演示它是如何工作的。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_basics.rst:170
#, fuzzy
msgid ""
"As you can see, functions normally in global scope in GDScript like Godot's "
"``print`` function are available in the ``GD`` class which is part of the "
"``Godot`` namespace. For a list of methods in the ``GD`` class, see the "
"class reference pages for :ref:`@GDScript <class_@gdscript>` and :ref:"
"`@GlobalScope <class_@globalscope>`."
msgstr ""
"正如您所看到的，GDScript中通常位于全局范围内的东西，如Godot的 ``print`` 函"
"数，可以在 ``GD`` 命名空间中找到。 有关这些的列表，请参阅类参考页面 :ref:"
"`@GDScript <class_ @ gdscript>` 和 :ref:`@GlobalScope <class_ @ "
"globalscope>`。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_basics.rst:177
#, fuzzy
msgid ""
"Keep in mind that the class you wish to attach to your node should be named "
"as the ``.cs`` file. Otherwise, you will get the following error and won't "
"be able to run the scene: *\"Cannot find class XXX for script res://XXX.cs\"*"
msgstr ""
"请记住，您希望附加到节点的类应命名为 ``.cs`` 文件。 如果没有，您将收到以下错"
"误，并且无法运行场景:``找不到类XXX的脚本res:// XXX.cs``。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_basics.rst:183
msgid "General differences between C# and GDScript"
msgstr "C#和GDScript之间的一般差异"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_basics.rst:185
msgid ""
"The C# API uses ``PascalCase`` instead of ``snake_case`` in GDScript/C++. "
"Where possible, fields and getters/setters have been converted to "
"properties. In general, the C# Godot API strives to be as idiomatic as is "
"reasonably possible."
msgstr ""
"C#API在GDScript / C++中使用 ``PascalCase`` 而不是 ``snake_case`` 。 在可能的"
"情况下，字段和getter / setter已转换为属性。 一般来说，C#Godot API力求尽可能合"
"理。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_basics.rst:189
#, fuzzy
msgid "For more information, see the :ref:`doc_c_sharp_differences` page."
msgstr "有关更多信息，请参阅 :ref:`doc_c_sharp_differences` 页面。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_basics.rst:192
msgid "Current gotchas and known issues"
msgstr "目前的陷阱和已知问题"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_basics.rst:194
#, fuzzy
msgid ""
"As C# support is quite new in Godot, there are some growing pains and things "
"that need to be ironed out. Below is a list of the most important issues you "
"should be aware of when diving into C# in Godot, but if in doubt, also take "
"a look over the official `issue tracker for Mono issues <https://github.com/"
"godotengine/godot/labels/topic%3Amono>`_."
msgstr ""
"由于C#支持对Godot来说是一个新手，因此仍有一些成长的痛苦和事情需要解决。 下面"
"列出了在Godot潜入C#时应该注意的最重要的问题，但是如果有疑问的话还要看一下Mono"
"问题的官方 `问题跟踪器 <https://github.com/godotengine/godot/labels/topic"
"%3Amono>`_ 。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_basics.rst:200
#, fuzzy
msgid ""
"As explained above, the C# project isn't always kept in sync automatically "
"when things are deleted, renamed or moved in Godot (`#12917 <https://github."
"com/godotengine/godot/issues/12917>`_)."
msgstr ""
"如上所述，当在Godot中删除，重命名或移动内容时，C#项目并不总是自动保持同步(`＃"
"12917 <https://github.com/godotengine/godot/issues/12917>`_ )"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_basics.rst:203
#, fuzzy
msgid ""
"Writing editor plugins is possible, but it is currently quite convoluted."
msgstr "目前尚不支持在C#中编写编辑器插件和工具脚本"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_basics.rst:204
msgid ""
"State is currently not saved and restored when hot-reloading, with the "
"exception of exported variables."
msgstr "在热重装中，当前状态不会得到保存并且会被恢复，除了已经导出的变量之外。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_basics.rst:206
#, fuzzy
msgid ""
"Exporting Mono projects is only supported for desktop platforms (Linux, "
"Windows and macOS). Android, iOS, HTML5 and UWP are not currently supported "
"(`#20267 <https://github.com/godotengine/godot/issues/20267>`_, `#20268 "
"<https://github.com/godotengine/godot/issues/20268>`_ `#20270 <https://"
"github.com/godotengine/godot/issues/20270>`_ `#20271 <https://github.com/"
"godotengine/godot/issues/20271>`_)."
msgstr ""
"仅桌面平台(Linux，Windows和macOS)支持导出Mono项目。 目前不支持HTML5，"
"Android，iOS和UWP( `＃18364评论 <https://github.com/godotengine/godot/"
"issues/18364#issuecomment-406222102>`_ )"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_basics.rst:212
msgid ""
"Attached C# scripts should refer to a class that has a class name that "
"matches the file name."
msgstr "附加C#脚本需要引用一个类，该类名需要匹配其文件名。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_basics.rst:216
msgid "Performance of C# in Godot"
msgstr "在Godot中表现C#"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_basics.rst:218
#, fuzzy
msgid ""
"According to some preliminary `benchmarks <https://github.com/cart/godot3-"
"bunnymark>`_, the performance of C# in Godot — while generally in the same "
"order of magnitude — is roughly **~4×** that of GDScript in some naive "
"cases. C++ is still a little faster; the specifics are going to vary "
"according to your use case. GDScript is likely fast enough for most general "
"scripting workloads. C# is faster, but requires some expensive marshalling "
"when talking to Godot."
msgstr ""
"根据一些初步的 `基准测试 <https://github.com/cart/godot3-bunnymark>`_ ，在"
"Godot中C#的性能 - 虽然通常在相同的数量级 - 大约是**〜4x ** GDScript在一些天真"
"的情况下。 为了获得完整的性能，C++仍然快一点; 具体情况将根据您的使用情况而有"
"所不同。 对于大多数通用脚本工作负载而言，GDScript可能足够快。 C#更快，但在与"
"Godot交谈时需要一些昂贵的编组。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_basics.rst:226
#, fuzzy
msgid "Using NuGet packages in Godot"
msgstr "在Godot中使用Nuget包"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_basics.rst:228
#, fuzzy
msgid ""
"`NuGet <https://www.nuget.org/>`_ packages can be installed and used with "
"Godot, as with any C# project. Many IDEs are able to add packages directly. "
"They can also be added manually by adding the package reference in the ``."
"csproj`` file located in the project root:"
msgstr ""
"`Nuget <https://www.nuget.org/>`_ 可以像Godot一样安装和使用Godot，就像任何项"
"目一样。 许多IDE(例如vs代码)可以直接添加包。 也可以通过在项目根目录中的."
"csproj文件中添加包引用来手动添加它们:"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_basics.rst:243
#, fuzzy
msgid ""
"Whenever packages are added or modified, run ``nuget restore`` in the root "
"of the project directory. To ensure that NuGet packages will be available "
"for msbuild to use, run:"
msgstr ""
"每当添加或修改包时，在项目目录的根目录中运行nuget restore，以确保nuget包可供"
"msbuild使用，运行::"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_features.rst:4
msgid "Features"
msgstr "功能"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_features.rst:6
msgid ""
"This page provides an overview of the commonly used features of both C# and "
"Godot and how they are used together."
msgstr "本页概述了C#和Godot的常用功能以及它们如何一起使用。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_features.rst:10
msgid "Type conversion and casting"
msgstr "类型转换和铸造"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_features.rst:12
msgid ""
"C# is a statically typed language. Therefore, you can't do the following:"
msgstr "C#是一种静态类型语言。 因此，您无法执行以下操作:"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_features.rst:19
msgid ""
"The method ``GetNode()`` returns a ``Node`` instance. You must explicitly "
"convert it to the desired derived type, ``Sprite`` in this case."
msgstr ""
"方法 ``GetNode()`` 返回一个 ``Node`` 实例。 在这种情况下，您必须将其显式转换"
"为所需的派生类型， ``Sprite`` 。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_features.rst:22
msgid "For this, you have various options in C#."
msgstr "为此，您在C#中有多种选择。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_features.rst:24
msgid "**Casting and Type Checking**"
msgstr "**铸造和型式检查**"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_features.rst:26
msgid ""
"Throws ``InvalidCastException`` if the returned node cannot be cast to "
"Sprite. You would use it instead of the ``as`` operator if you are pretty "
"sure it won't fail."
msgstr ""
"如果返回的节点无法转换为Sprite，则抛出 ``InvalidCastException`` 。 如果您非常"
"确定它不会失败，您可以使用它而不是 ``as`` 运算符。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_features.rst:34
msgid "**Using the AS operator**"
msgstr "**使用AS运算符**"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_features.rst:36
msgid ""
"The ``as`` operator returns null if the node cannot be cast to Sprite, and "
"for that reason, it cannot be used with value types."
msgstr ""
"如果节点无法转换为Sprite，则 ``as`` 运算符返回null，因此它不能与值类型一起使"
"用。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_features.rst:45
msgid "**Using the generic methods**"
msgstr "**使用通用方法**"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_features.rst:47
msgid ""
"Generic methods are also provided to make this type conversion transparent."
msgstr "还提供了通用方法以使该类型转换透明。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_features.rst:49
msgid ""
"``GetNode<T>()`` casts the node before returning it. It will throw an "
"``InvalidCastException`` if the node cannot be cast to the desired type."
msgstr ""
"``GetNode <T>()`` 在返回之前强制转换节点。 如果节点无法转换为所需类型，它将抛"
"出一个 ``InvalidCastException``。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_features.rst:56
msgid ""
"``GetNodeOrNull<T>()`` uses the ``as`` operator and will return ``null`` if "
"the node cannot be cast to the desired type."
msgstr ""
"``GetNodeOrNull <T>()`` 使用 ``as`` 运算符，如果节点无法转换为所需类型，则返"
"回 ``null``。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_features.rst:64
msgid "**Type checking using the IS operator**"
msgstr "**使用IS运算符进行类型检查**"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_features.rst:66
msgid ""
"To check if the node can be cast to Sprite, you can use the ``is`` operator. "
"The ``is`` operator returns false if the node cannot be cast to Sprite, "
"otherwise it returns true."
msgstr ""
"要检查节点是否可以转换为Sprite，可以使用 ``is`` 运算符。 如果节点无法转换为"
"Sprite，则 ``is`` 运算符返回false，否则返回true。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_features.rst:77
msgid ""
"For more advanced type checking, you can look into `Pattern Matching "
"<https://docs.microsoft.com/en-us/dotnet/csharp/pattern-matching>`_."
msgstr ""
"对于更高级的类型检查，您可以查看 `模式匹配 <https://docs.microsoft.com/en-us/"
"dotnet/csharp/pattern-matching>`_ 。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_features.rst:82
msgid "C# signals"
msgstr "C# 信号"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_features.rst:84
msgid ""
"For a complete C# example, see the **Handling a signal** section in the step "
"by step :ref:`doc_scripting` tutorial."
msgstr ""
"有关完整的C#示例，请参阅步骤中的 **处理信号** 部分 :ref:`doc_scripting`教程。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_features.rst:86
msgid ""
"Declaring a signal in C# is done with the ``[Signal]`` attribute on a "
"delegate."
msgstr "在C#中声明一个信号是通过委托上的 ``[Signal]`` 属性完成的。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_features.rst:96
msgid ""
"These signals can then be connected either in the editor or from code with "
"``Connect``."
msgstr "然后可以在编辑器中或通过“Connect”连接代码连接这些信号。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_features.rst:116
msgid "Emitting signals is done with the ``EmitSignal`` method."
msgstr "发射信号是通过 ``EmitSignal`` 方法完成的。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_features.rst:126
msgid ""
"Notice that you can always reference a signal name with the ``nameof`` "
"keyword (applied on the delegate itself)."
msgstr "请注意，您始终可以使用 ``nameof`` 关键字引用信号名称(应用于委托本身)。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_features.rst:128
msgid ""
"It is possible to bind values when establishing a connection by passing an "
"object array."
msgstr "通过传递对象数组，可以在建立连接时绑定值。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_features.rst:148
msgid ""
"Signals support parameters and bound values of all the `built-in types "
"<https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/"
"built-in-types-table>`_ and Classes derived from :ref:`Godot.Object "
"<class_Object>`. Consequently, any ``Node`` or ``Reference`` will be "
"compatible automatically, but custom data objects will need to extend from "
"`Godot.Object` or one of its subclasses."
msgstr ""
"信号支持所有 `内置类型 <https://docs.microsoft.com/en-us/dotnet/csharp/"
"language-reference/keywords/built-in-types-table>`_ 的参数和绑定值 派生自的"
"类 :ref:`Godot.Object <class_Object>`。 因此，任何 ``Node`` 或 ``Reference`` "
"都将自动兼容，但自定义数据对象需要从 `Godot.Object` 或其子类之一扩展。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_features.rst:160
msgid ""
"Finally, signals can be created by calling ``AddUserSignal``, but be aware "
"that it should be executed before any use of said signals (with ``Connect`` "
"or ``EmitSignal``)."
msgstr ""
"最后，可以通过调用 ``AddUserSignal`` 来创建信号，但要注意它应该在使用所述信号"
"之前执行(使用 ``Connect`` 或 ``EmitSignal`` )。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:4
msgid "API differences to GDScript"
msgstr "与GDScript的API差异"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:6
msgid "This is a (incomplete) list of API differences between C# and GDScript."
msgstr "这是C#和GDScript之间API差异的(不完整)列表。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:9
msgid "General differences"
msgstr "不同之处"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:11
#, fuzzy
msgid ""
"As explained in the :ref:`doc_c_sharp`, C# generally uses ``PascalCase`` "
"instead of the ``snake_case`` used in GDScript and C++."
msgstr ""
"正如在 :ref:`doc_c_sharp` 中所解释的，C#通常在GDScript和C++中使用 "
"``PascalCase`` 而不是 ``snake_case`` 。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:15
#: ../../docs/tutorials/threads/thread_safe_apis.rst:15
msgid "Global scope"
msgstr "全局范围"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:17
msgid ""
"Global functions and some constants had to be moved to classes, since C# "
"does not allow declaring them in namespaces. Most global constants were "
"moved to their own enums."
msgstr ""

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:24
msgid ""
"Global constants were moved to their own enums. For example, ``ERR_*`` "
"constants were moved to the ``Error`` enum."
msgstr ""

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:27
#, fuzzy
msgid "Special cases:"
msgstr "空间节点"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:32
msgid "``SPKEY``"
msgstr ""

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:32
msgid "``GD.SpKey``"
msgstr ""

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:33
msgid "``TYPE_*``"
msgstr ""

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:33
msgid "``Variant.Type`` enum"
msgstr ""

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:34
msgid "``OP_*``"
msgstr ""

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:34
msgid "``Variant.Operator`` enum"
msgstr ""

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:38
#, fuzzy
msgid "Math functions"
msgstr "静态函数"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:40
#, fuzzy
msgid ""
"Math global functions, like ``abs``, ``acos``, ``asin``, ``atan`` and "
"``atan2``, are located under ``Mathf`` as ``Abs``, ``Acos``, ``Asin``, "
"``Atan`` and ``Atan2``. The ``PI`` constant can be found as ``Mathf.Pi``."
msgstr ""
"像 ``abs``， ``acos`` ， ``asin`` ，``atan`` 和 ``atan2`` 这样的数学函数位于 "
"``Mathf`` 下面，作为 ``Abs`` ，``Acos ``， ``Asin`` ，``Atan`` 和 ``Atan2``，"
"而不是全局范围。 ``PI`` 是 ``Mathf.Pi``"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:45
#, fuzzy
msgid "Random functions"
msgstr "变换函数"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:47
#, fuzzy
msgid ""
"Random global functions, like ``rand_range`` and ``rand_seed``, are located "
"under ``GD``. Example: ``GD.RandRange`` and ``GD.RandSeed``."
msgstr ""
"如“rand_range”和“rand_seed”等随机函数位于“Random”下，所以使用“Random."
"RandRange”而不是“rand_range”。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:51
#, fuzzy
msgid "Other functions"
msgstr "弧函数"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:53
#, fuzzy
msgid ""
"Many other global functions like ``print`` and ``var2str`` are located under "
"``GD``. Example: ``GD.Print`` and ``GD.Var2Str``."
msgstr ""
"像 ``print`` ， ``var2str`` 和 ``weakref`` 这样的全局函数位于C#中的 ``GD`` "
"下。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:56
#, fuzzy
msgid "Exceptions:"
msgstr "Actions"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:61
msgid "``weakref(obj)``"
msgstr ""

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:61
msgid "``Object.WeakRef(obj)``"
msgstr ""

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:62
msgid "``is_instance_valid(obj)``"
msgstr ""

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:62
msgid "``Object.IsInstanceValid(obj)``"
msgstr ""

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:66
msgid "Tips"
msgstr ""

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:68
msgid ""
"Sometimes it can be useful to use the ``using static`` directive. This "
"directive allows to access the members and nested types of a class without "
"specifying the class name."
msgstr ""

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:71
#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:90
#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:121
#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:132
#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:144
#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:305
#: ../../docs/tutorials/math/matrices_and_transforms.rst:467
#: ../../docs/tutorials/io/background_loading.rst:268
#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:78
#: ../../docs/tutorials/platform/services_for_ios.rst:203
#: ../../docs/tutorials/platform/services_for_ios.rst:250
#: ../../docs/community/contributing/code_style_guidelines.rst:150
msgid "Example:"
msgstr "例:"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:86
msgid "Export keyword"
msgstr "导出关键字"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:88
msgid ""
"Use the ``[Export]`` attribute instead of the GDScript ``export`` keyword."
msgstr "使用 ``[Export]`` 属性代替GDScript ``export`` 关键字。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:103
msgid "Signal keyword"
msgstr "信号关键字"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:105
#, fuzzy
msgid ""
"Use the ``[Signal]`` attribute to declare a signal instead of the GDScript "
"``signal`` keyword. This attribute should be used on a `delegate`, whose "
"name signature will be used to define the signal."
msgstr ""
"使用 ``[Signal]`` 属性代替GDScript ``signal`` 关键字。 该属性应该用在 "
"`delegate` 上，其名称签名将用于定义信号。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:113
msgid "See also: :ref:`c_sharp_signals`"
msgstr "另见: :ref:`c_sharp_signals`"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:116
msgid "Singletons"
msgstr "单例"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:118
#, fuzzy
msgid ""
"Singletons are available as static classes rather than using the singleton "
"pattern. This is to make code less verbose than it would be with an "
"``Instance`` property."
msgstr ""
"单例提供静态方法而不是在C#中使用单例模式。 这是为了使代码更简洁，与GDScript类"
"似。 例:"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:127
msgid ""
"However, in some very rare cases this is not enough. For example, you may "
"want to access a member from the base class ``Godot.Object``, like "
"``Connect``. For such use cases we provide a static property named "
"``Singleton`` that returns the singleton instance. The type of this instance "
"is ``Godot.Object``."
msgstr ""

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:139
#: ../../docs/tutorials/plugins/editor/import_plugins.rst:244
#: ../../docs/tutorials/plugins/editor/import_plugins.rst:250
#: ../../docs/development/cpp/core_types.rst:174
msgid "String"
msgstr "字符串"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:141
#, fuzzy
msgid ""
"Use ``System.String`` (``string``). Most of Godot's String methods are "
"provided by the ``StringExtensions`` class as extension methods."
msgstr ""
"使用 ``System.String`` ( ``string`` )。 所有Godot String方法都由 "
"``StringExtensions`` 类作为扩展方法提供。 例:"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:151
msgid "There are a few differences, though:"
msgstr "但是有一些不同之处:"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:153
msgid ""
"``erase``: Strings are immutable in C#, so we cannot modify the string "
"passed to the extension method. For this reason, ``Erase`` was added as an "
"extension method of ``StringBuilder`` instead of string. Alternatively, you "
"can use ``string.Remove``."
msgstr ""
"``erase`` :字符串在C#中是不可变的，所以我们不能修改传递给扩展方法的字符串。 "
"出于这个原因， ``Erase`` 被添加为 ``StringBuilder`` 的扩展方法而不是字符串。 "
"或者您可以使用 ``string.Remove`` 。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:157
msgid ""
"``IsSubsequenceOf``/``IsSubsequenceOfi``: An additional method is provided, "
"which is an overload of ``IsSubsequenceOf``, allowing you to explicitly "
"specify case sensitivity:"
msgstr ""
"``IsSubsequenceOf`` / ``IsSubsequenceOfi`` :提供了另一种方法，它是 "
"``IsSubsequenceOf`` 的重载，允许明确指定区分大小写:"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:168
msgid ""
"``Match``/``Matchn``/``ExprMatch``: An additional method is provided besides "
"``Match`` and ``Matchn``, which allows you to explicitly specify case "
"sensitivity:"
msgstr ""
"``Match`` / ``Matchn`` / ``ExprMatch`` :除了 ``Match`` 和 ``Matchn`` 之外还提"
"供了另一种方法，它允许明确指定区分大小写:"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:179
#: ../../docs/tutorials/math/matrices_and_transforms.rst:126
#: ../../docs/tutorials/math/matrices_and_transforms.rst:614
msgid "Basis"
msgstr "基"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:181
msgid ""
"Structs cannot have parameterless constructors in C#. Therefore, ``new "
"Basis()`` initializes all primitive members to their default value. Use "
"``Basis.Identity`` for the equivalent of ``Basis()`` in GDScript and C++."
msgstr ""
"结构在C#中不能有无参数构造函数，因此 ``new Basis()`` 将所有原始成员初始化为其"
"默认值。 使用 ``Basis.Identity`` 相当于GDScript和C++中的 ``Basis()`` 。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:185
#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:231
msgid "The following method was converted to a property with a different name:"
msgstr "以下方法已转换为属性，其各自的名称已更改:"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:190
#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:206
#, fuzzy
msgid "``get_scale()``"
msgstr "get_scale()"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:190
#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:206
#, fuzzy
msgid "``Scale``"
msgstr "规模"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:194
#: ../../docs/tutorials/math/matrices_and_transforms.rst:157
msgid "Transform2D"
msgstr "Transform2D"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:196
msgid ""
"Structs cannot have parameterless constructors in C#. Therefore, ``new "
"Transform2D()`` initializes all primitive members to their default value. "
"Please use ``Transform2D.Identity`` for the equivalent of ``Transform2D()`` "
"in GDScript and C++."
msgstr ""
"结构在C#中不能有无参数构造函数，因此 ``new Transform2D()`` 将所有原始成员初始"
"化为其默认值。 请使用 ``Transform2D.Identity`` 代替GDScript和C++中的 "
"``Transform2D()`` 。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:200
msgid ""
"The following methods were converted to properties with their respective "
"names changed:"
msgstr "以下方法已转换为属性，其各自的名称已更改:"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:205
#, fuzzy
msgid "``get_rotation()``"
msgstr "get_rotation()"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:205
#, fuzzy
msgid "``Rotation``"
msgstr "旋转"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:210
msgid "Plane"
msgstr "平面"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:212
msgid ""
"The following method was converted to a property with a *slightly* different "
"name:"
msgstr "以下方法已转换为属性，其各自的名称已更改:"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:217
#, fuzzy
msgid "``center()``"
msgstr "center()"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:217
#, fuzzy
msgid "``Center``"
msgstr "中心"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:221
msgid "Rect2"
msgstr "Rect2"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:223
msgid ""
"The following field was converted to a property with a *slightly* different "
"name:"
msgstr "以下字段已转换为属性，其各自的名称已更改:"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:228
msgid "``end``"
msgstr ""

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:228
msgid "``End``"
msgstr ""

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:236
#, fuzzy
msgid "``get_area()``"
msgstr "get_area()"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:236
#, fuzzy
msgid "``Area``"
msgstr "区域"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:240
msgid "Quat"
msgstr "Quat"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:242
msgid ""
"Structs cannot have parameterless constructors in C#. Therefore, ``new "
"Quat()`` initializes all primitive members to their default value. Please "
"use ``Quat.Identity`` for the equivalent of ``Quat()`` in GDScript and C++."
msgstr ""
"结构在C#中不能有无参数构造函数，因此 ``new Quat()`` 将所有原始成员初始化为其"
"默认值。 请使用 ``Quat.Identity`` 相当于GDScript和C++中的 ``Quat()`` 。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:246
#, fuzzy
msgid ""
"The following methods were converted to a property with a different name:"
msgstr "以下方法已转换为属性，其各自的名称已更改:"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:251
#, fuzzy
msgid "``length()``"
msgstr "length"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:251
#, fuzzy
msgid "``Length``"
msgstr "length"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:252
msgid "``length_squared()``"
msgstr ""

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:252
msgid "``LengthSquared``"
msgstr ""

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:258
#, fuzzy
msgid ""
"*This is temporary. PoolArrays will need their own types to be used the way "
"they are meant to.*"
msgstr ""
"*这是暂时的。 数组被重新计数，因此它需要自己的包装本机端的类型。 PoolArrays也"
"需要按照自己的方式使用自己的类型。*"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:263
#, fuzzy
msgid "``Array``"
msgstr "数组"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:263
msgid "``Godot.Array``"
msgstr ""

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:264
#, fuzzy
msgid "``PoolIntArray``"
msgstr "PoolIntArray"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:264
#, fuzzy
msgid "``int[]``"
msgstr "``in``"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:265
#, fuzzy
msgid "``PoolByteArray``"
msgstr "PoolByteArray"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:265
#, fuzzy
msgid "``byte[]``"
msgstr "byte[]"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:266
#, fuzzy
msgid "``PoolFloatArray``"
msgstr "PoolFloatArray"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:266
#, fuzzy
msgid "``float[]``"
msgstr "float[]"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:267
#, fuzzy
msgid "``PoolStringArray``"
msgstr "PoolStringArray"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:267
#, fuzzy
msgid "``String[]``"
msgstr "String[]"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:268
#, fuzzy
msgid "``PoolColorArray``"
msgstr "PoolColorArray"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:268
#, fuzzy
msgid "``Color[]``"
msgstr "Color[]"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:269
#, fuzzy
msgid "``PoolVector2Array``"
msgstr "PoolVector2Array"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:269
#, fuzzy
msgid "``Vector2[]``"
msgstr "Vector2[]"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:270
#, fuzzy
msgid "``PoolVector3Array``"
msgstr "PoolVector3Array"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:270
#, fuzzy
msgid "``Vector3[]``"
msgstr "Vector3[]"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:273
msgid ""
"``Godot.Array<T>`` is a type-safe wrapper around ``Godot.Array``. Use the "
"``Godot.Array<T>(Godot.Array)`` constructor to create one."
msgstr ""

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:279
#, fuzzy
msgid "Use ``Godot.Dictionary``."
msgstr "使用 ``Dictionary <object，object>``。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:281
msgid ""
"``Godot.Dictionary<T>`` is a type-safe wrapper around ``Godot.Dictionary``. "
"Use the ``Godot.Dictionary<T>(Godot.Dictionary)`` constructor to create one."
msgstr ""

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:285
msgid "Variant"
msgstr "变种"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:287
msgid "``System.Object`` (``object``) is used instead of ``Variant``."
msgstr "``System.Object`` ( ``object`` )用来代替 ``Variant`` 。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:290
msgid "Communicating with other scripting languages"
msgstr "与其他脚本语言通信"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:292
#, fuzzy
msgid ""
"The methods ``object Object.Call(string method, params object[] args)``, "
"``object Object.Get(string field)`` and ``object Object.Set(string field, "
"object value)`` are provided to communicate with instances of other "
"scripting languages via the Variant API."
msgstr ""
"方法 ``object Object.call(string method，params object [] args)`` ， "
"``object Object.get(string field)`` 和 ``object Object.set(string field，"
"object value)`` are 提供通过Variant API与其他脚本语言的实例进行通信。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:300
msgid ""
"Something similar to GDScript's ``yield`` with a single parameter can be "
"achieved with C#'s `yield keyword <https://docs.microsoft.com/en-US/dotnet/"
"csharp/language-reference/keywords/yield>`_."
msgstr ""

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:303
msgid ""
"The equivalent of yield on signal can be achieved with async/await and "
"``Godot.Object.ToSignal``."
msgstr ""

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:313
msgid "Other differences"
msgstr "其他差异"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:315
msgid ""
"``preload``, as it works in GDScript, is not available in C#. Use ``GD."
"Load`` or ``ResourceLoader.Load`` instead."
msgstr ""

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:318
msgid "Other differences:"
msgstr "其他差异:"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:323
#, fuzzy
msgid "``Color8``"
msgstr "Color8"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:323
#, fuzzy
msgid "``Color.Color8``"
msgstr "Color.Color8"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:324
#, fuzzy
msgid "``is_inf``"
msgstr "is_inf"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:324
#, fuzzy
msgid "``float.IsInfinity``"
msgstr "float.IsInfinity"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:325
#, fuzzy
msgid "``is_nan``"
msgstr "is_nan"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:325
#, fuzzy
msgid "``float.IsNaN``"
msgstr "float.IsNaN"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:326
#, fuzzy
msgid "``dict2inst``"
msgstr "dict2inst"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:326
#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:327
#, fuzzy
msgid "TODO"
msgstr "要做。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_differences.rst:327
#, fuzzy
msgid "``inst2dict``"
msgstr "inst2dict"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:4
msgid "C# style guide"
msgstr "C# 风格指南"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:6
msgid ""
"Having well-defined and consistent coding conventions is important for every "
"project, and Godot is no exception to this rule."
msgstr "具有明确定义和一致的编码约定对于每个项目都很重要，Godot也不例外。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:9
msgid ""
"This page contains a coding style guide, which is followed by developers of "
"and contributors to Godot itself. As such, it is mainly intended for those "
"who want to contribute to the project, but since the conventions and "
"guidelines mentioned in this article are those most widely adopted by the "
"users of the language, we encourage you to do the same, especially if you do "
"not have such a guide yet."
msgstr ""
"这个页面包含一个编码风格指南，Godot本身的开发人员和贡献者也是如此。 因此，它"
"主要面向那些想要为项目做出贡献的人，但由于本文中提到的惯例和指南是该语言用户"
"最广泛采用的那些，我们鼓励您这样做，特别是如果您 还没有这样的指南。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:14
msgid ""
"This article is by no means an exhaustive guide on how to follow the "
"standard coding conventions or best practices. If you feel unsure of an "
"aspect which is not covered here, please refer to more comprehensive "
"documentation, such as `C# Coding Conventions <https://docs.microsoft.com/en-"
"us/dotnet/csharp/programming-guide/inside-a-program/coding-conventions>`_ or "
"`Framework Design Guidelines <https://docs.microsoft.com/en-us/dotnet/"
"standard/design-guidelines/naming-guidelines>`_."
msgstr ""
"本文绝不是关于如何遵循标准编码约定或最佳实践的详尽指南。 如果您不确定此处未涉"
"及的方面，请参阅更全面的文档，例如 `C#编码约定 <https://docs.microsoft.com/"
"en-us/dotnet/csharp/programming-guide/inside-a-program/coding-conventions>`_ "
"或 `框架设计指南 <https://docs.microsoft.com/en-us/dotnet/standard/design-"
"guidelines/naming-guidelines>`_ 。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:21
msgid "Language specification"
msgstr "语言规范"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:23
msgid ""
"Currently, Godot uses C# version 6.0 in its engine and example source code. "
"So, before we move to a newer version, care must be taken to avoid mixing "
"language features only available in C# 7.0 or later, such as pattern "
"matching or expression-bodied members inside get/set accessors."
msgstr ""
"目前，Godot在其引擎和示例源代码中使用C#6.0版。 因此，在我们迁移到更新版本之"
"前，必须注意避免混合仅在C#7.0或更高版本中可用的语言功能，例如模式匹配或get / "
"set访问器中的表达式身份成员。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:27
msgid ""
"For detailed information on C# features in different versions, please see "
"`What's New in C# <https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/"
">`_."
msgstr ""
"有关不同版本的C#功能的详细信息，请参阅 `C#中的新功能 <https://docs.microsoft."
"com/en-us/dotnet/csharp/whats-new/>`_ 。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:31
msgid "Formatting conventions"
msgstr "命名约定"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:33
msgid ""
"If you create a new file, make sure that it uses linefeed (*LF*) characters "
"to break lines, not *CRLF* or *CR*."
msgstr ""
"如果您创建一个新文件，请确保它使用换行符( *LF* )来断行，而不是 *CRLF* 或 "
"*CR* 。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:34
msgid ""
"Use UTF-8 encoding without a byte order mark (BOM <https://en.wikipedia.org/"
"wiki/Byte_order_mark>)."
msgstr ""
"使用没有字节顺序标记的UTF-8编码(BOM <https://en.wikipedia.org/wiki/"
"Byte_order_mark>)。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:35
msgid ""
"Use 4 spaces instead of tabs for indentation (which is referred to as 'soft "
"tabs')."
msgstr "使用4个空格而不是标签进行缩进(称为 '软标签' )。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:38
msgid "Line breaks and blank lines"
msgstr "换行符和空白行"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:40
msgid ""
"For a general indentation rule, follow `The 'Allman Style' <https://en."
"wikipedia.org/wiki/Indentation_style#Allman_style>`_ which recommends "
"placing the brace associated with a control statement on the next line, "
"indented to the same level:"
msgstr ""
"对于一般缩进规则，请遵循 `The Allman Style <https://en.wikipedia.org/wiki/"
"Indentation_style#Allman_style>`_ ，它建议将与控制语句关联的大括号放在下一"
"行，缩进到同一水平:"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:57
msgid "However, you may choose to omit line breaks inside brackets:"
msgstr "但是，您可以选择省略括号内的换行符:"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:59
msgid "For simple property accessors."
msgstr "对于简单的属性访问者。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:60
msgid "For simple object, array, or collection initializers."
msgstr "对于简单对象，数组或集合初始值设定项。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:61
msgid "For abstract auto property, indexer, or event declarations."
msgstr "对于抽象的自动属性，索引器或事件声明。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:83
msgid "Insert a blank line:"
msgstr "插入一个空行:"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:85
msgid "After *using* statement list."
msgstr "之后 *using* 语句列表。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:86
msgid "Between method, properties, and inner type declarations."
msgstr "在方法，属性和内部类型声明之间。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:88
msgid ""
"Field and constant declarations can be grouped together according to "
"relevance. In that case, consider inserting a blank line between the groups "
"for easier reading."
msgstr ""
"字段和常量声明可以根据相关性组合在一起。 在这种情况下，请考虑在组之间插入一个"
"空行以便于阅读。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:91
msgid "Avoid inserting a blank line:"
msgstr "避免插入空行:"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:93
msgid "After ``{``, the opening brace."
msgstr "在开括号 ``{`` 之后。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:94
msgid "Before ``}``, the closing brace."
msgstr "在结束括号 ``}`` 之前。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:95
msgid "After a comment block, or a single line comment."
msgstr "发表评论后，或单行评论。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:96
msgid "Adjacent to another blank line."
msgstr "毗邻另一条空白行。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:133
msgid ""
"Consider breaking a line when it's longer than 100 characters. And it's also "
"a good practice to insert a line feed (LF) character at the end of a file "
"because some utilities have trouble recognizing the last line without it (e."
"g. the *cat* command on Linux)."
msgstr ""
"当长度超过100个字符时，请考虑断开一条线。 在文件末尾插入换行符(LF)也是一种很"
"好的做法，因为有些实用程序在没有它的情况下无法识别最后一行(即Linux的 *cat* 命"
"令)。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:138
msgid "Using spaces"
msgstr "使用空格"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:140
msgid "Insert a space:"
msgstr "插入空格:"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:142
msgid "Around a binary and tertiary operator."
msgstr "围绕二元和三元运算符。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:143
msgid ""
"Between an opening parenthesis and *if*, *for*, *foreach*, *catch*, *while*, "
"*lock* or *using* keywords."
msgstr ""
"在左括号和 *if*, *for*, *foreach*, *catch*, *while*, *lock* 或 *using* 关键字"
"之间。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:144
msgid "Before and within a single line accessor block."
msgstr "在单行访问器块之前和之内。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:145
msgid "Between accessors in a single line accessor block."
msgstr "在单行访问器块中的访问器之间。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:146
msgid "After a comma."
msgstr "逗号后。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:147
msgid "After a semi-colon in a *for* statement."
msgstr "在 *for* 语句中使用分号后。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:148
msgid "After a colon in a single line *case* statement."
msgstr "在单行 *case* 语句中冒号后。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:149
msgid "Around a colon in a type declaration."
msgstr "在类型声明中的冒号周围。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:150
msgid "Around a lambda arrow."
msgstr "围绕一个lambda箭头。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:151
msgid ""
"After a single line comment symbol ('//'), and before it if used at the end "
"of a line."
msgstr "在单行注释符号('//')之后，如果在行结束时使用它。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:153
msgid "Do not use a space:"
msgstr "不要使用空间:"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:155
msgid "After type cast parentheses."
msgstr "在类型转换括号后。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:156
msgid "Within single line initializer braces."
msgstr "在单行初始化程序括号内。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:158
msgid ""
"The following example shows a proper use of spaces, according to some of the "
"above mentioned conventions:"
msgstr "根据上面提到的一些约定，以下示例显示了空格的正确使用:"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:195
msgid ""
"Use *PascalCase* for all namespaces, type names and member level identifiers "
"(i.e. methods, properties, constants, events), except for private fields:"
msgstr ""
"对所有名称空间，类型名称和成员级别标识符(即方法，属性，常量，事件)使用 "
"*PascalCase* ，私有字段除外:"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:216
msgid ""
"Use *camelCase* for all other identifiers (i.e. local variables, method "
"arguments), and use underscore('_') as a prefix for private fields (but not "
"for methods or properties, as explained above):"
msgstr ""
"对所有其他标识符(即局部变量，方法参数)使用 *camelCase* ，并使用下划线('_')作"
"为私有字段的前缀(但不适用于方法或属性，如上所述):"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:230
msgid ""
"There's an exception with acronyms which consist of two letters, like "
"*'UI'*, which should be written in uppercase letters when used where Pascal "
"case would be expected, and in lowercase letters otherwise."
msgstr ""
"首字母缩略词有一个例外，它由两个字母组成，例如 *'UI'* ，当使用Pascal案例时，"
"应使用大写字母书写，否则使用小写字母。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:233
msgid ""
"Note that *'id'* is **not** an acronym, so it should be treated as a normal "
"identifier:"
msgstr "请注意，*'id'* **不是** 首字母缩略词，因此应将其视为普通标识符:"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:244
msgid ""
"It is generally discouraged to use a type name as a prefix of an identifier, "
"like *'string strText'* or *'float fPower'*, for example. An exception is "
"made, however, for interfaces, which **should**, in fact, have an uppercase "
"letter *'I'* prefixed to their names, like *'IInventoryHolder'* or "
"*'IDamageable'*."
msgstr ""
"例如，通常不鼓励使用类型名称作为标识符的前缀，例如*'string strText'*或"
"*'float fPower'*。 但是，有一个关于接口的例外，在这种情况下，它们**应该使用大"
"写 *'I'* 作为前缀命名，如 *'IInventoryHolder'* 或 *'IDamageable'*。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:248
msgid ""
"Lastly, consider choosing descriptive names and do not try to shorten them "
"too much if it affects readability."
msgstr "最后，考虑选择描述性名称，如果它影响可读性，不要试图将它们缩短太多。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:251
msgid ""
"For instance, if you want to write code to find a nearby enemy and hit it "
"with a weapon, prefer"
msgstr "例如，如果您想编写一个代码来寻找附近的敌人并用武器击中，那就更喜欢了"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:257
msgid "Rather than,"
msgstr "而不是，"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:264
msgid "Implicitly typed local variables"
msgstr "隐式输入的局部变量"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:266
msgid ""
"Consider using implicitly typing (*'var'*) for declaration of a local "
"variable, but do so **only when the type is evident** from the right side of "
"the assignment:"
msgstr ""
"考虑使用隐式输入(*'var'*)来声明局部变量，但只有在类型明显的情况下** **才能从"
"赋值的右侧执行:"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:296
msgid "Other considerations"
msgstr "其他考虑"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:298
msgid "Use explicit access modifiers."
msgstr "使用显式访问修饰符。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:299
msgid "Use properties instead of non-private fields."
msgstr "使用属性而不是非私有字段。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:300
msgid ""
"Use modifiers in this order: *'public/protected/private/internal virtual/"
"override/abstract/new static readonly'*."
msgstr ""
"按此顺序使用修饰符:*'public / protected / private / internal virtual / "
"override / abstract / new static readonly'*。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:301
msgid ""
"Avoid using fully qualified names or *'this.'* prefix for members when it's "
"not necessary."
msgstr "在没有必要的情况下，避免使用完全限定名称或 *'this.'* 前缀。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:302
msgid "Remove unused *'using'* statements and unnecessary parentheses."
msgstr "删除未使用的 *'using'* 语句和不必要的括号。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:303
msgid "Consider omitting default initial value for a type."
msgstr "考虑省略类型的默认初始值。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:304
msgid ""
"Consider using null-conditional operators or type initializers to make the "
"code more compact."
msgstr "考虑使用空条件运算符或类型初始化器来使代码更紧凑。"

#: ../../docs/getting_started/scripting/c_sharp/c_sharp_style_guide.rst:305
msgid ""
"Use safe cast when there is a possibility of the value being a different "
"type, and use direct cast otherwise."
msgstr "当值可能是不同类型时使用安全演员，否则使用直接演员。"

#: ../../docs/getting_started/workflow/project_setup/project_organization.rst:8
msgid ""
"Since Godot has no restrictions on project structure or filesystem usage, "
"organizing files when learning the engine can seem challenging. This "
"tutorial suggests a workflow which should be a good starting point. We will "
"also cover using version control with Godot."
msgstr ""

#: ../../docs/getting_started/workflow/project_setup/project_organization.rst:14
msgid "Organization"
msgstr "组织"

#: ../../docs/getting_started/workflow/project_setup/project_organization.rst:16
msgid ""
"Godot is scene-based in nature, and uses the filesystem as-is, without "
"metadata or an asset database."
msgstr "Godot 本身是基于场景的，并使用了文件系统，没有元数据或资源数据库。"

#: ../../docs/getting_started/workflow/project_setup/project_organization.rst:19
msgid ""
"Unlike other engines, many resources are contained within the scene itself, "
"so the amount of files in the filesystem is considerably lower."
msgstr ""
"不像其他的引擎，场景本身包含了大量资源，因此文件系统中的文件数量要少得多。"

#: ../../docs/getting_started/workflow/project_setup/project_organization.rst:22
msgid ""
"Considering that, the most common approach is to group assets as close to "
"scenes as possible; when a project grows, it makes it more maintainable."
msgstr ""
"考虑到这一点，最常见的方法是将资源按照场景分组，当项目变大时，更易于维护。"

#: ../../docs/getting_started/workflow/project_setup/project_organization.rst:26
msgid ""
"As an example, one can usually place into a single folder their basic "
"assets, such as sprite images, 3D model meshes, materials, and music, etc. "
"They can then use a separate folder to store built levels that use them."
msgstr ""
"例如，基本的精灵图像，3D 模型场景或网格，材质等通常可以组织到一起，使用单独的"
"文件夹来存储它们，从而将它们用于构建关卡。"

#: ../../docs/getting_started/workflow/project_setup/project_organization.rst:47
msgid "Importing"
msgstr "导入"

#: ../../docs/getting_started/workflow/project_setup/project_organization.rst:49
msgid ""
"Godot versions prior to 3.0 did the import process from files outside the "
"project. While this can be useful in large projects, it resulted in an "
"organization hassle for most developers."
msgstr ""
"3.0版之前的 Godot 版本从项目外的文件中进行导入过程。 虽然这对于大型项目非常有"
"用，但却导致了大多数开发人员的组织问题。"

#: ../../docs/getting_started/workflow/project_setup/project_organization.rst:53
msgid ""
"Because of this, assets are now transparently imported from within the "
"project folder."
msgstr "因此，资源现在可以透明地从项目文件夹中导入。"

#: ../../docs/getting_started/workflow/project_setup/project_organization.rst:56
msgid ""
"If a folder shouldn't be imported into Godot, an exception can be made with "
"a .gdignore file."
msgstr ""
"如果一个文件夹不应该被导入Godot，可以使用 .gdignore 文件来进行异常处理。"

#: ../../docs/getting_started/workflow/assets/escn_exporter/index.rst:2
#, fuzzy
msgid "Blender ESCN exporter"
msgstr "Godot-Blender-导出器"

#: ../../docs/getting_started/workflow/assets/escn_exporter/index.rst:4
#, fuzzy
msgid ""
"This chapter relates to the Blender plugin called \"Godot Blender Exporter"
"\", which can be downloaded here: https://github.com/godotengine/godot-"
"blender-exporter"
msgstr ""
"本章涉及名为“Godot-Blender-Exporter”的blender插件，可在此处下载:https://"
"github.com/godotengine/godot-blender-exporter"

#: ../../docs/getting_started/workflow/assets/escn_exporter/index.rst:7
#, fuzzy
msgid ""
"This plugin can be used to export Blender scenes in a Godot-specific scene "
"format called ESCN, which is similar to TSCN (text format) but will be "
"imported as binary SCN for performance."
msgstr ""
"这个插件可用于Blender中以导出Godot的专有场景格式ESCN——与TSCN（文本格式）相似"
"但作为二进制导入以提升性能。"

#: ../../docs/getting_started/workflow/assets/escn_exporter/index.rst:12
msgid "Details on exporting"
msgstr "导出细节"

#: ../../docs/getting_started/workflow/assets/escn_exporter/index.rst:27
msgid "Disabling specific objects"
msgstr "禁用特定对象"

#: ../../docs/getting_started/workflow/assets/escn_exporter/index.rst:29
#, fuzzy
msgid ""
"Sometimes you don't want some objects exported (e.g. high-res models used "
"for baking). An object will not be exported if it is not rendered in the "
"scene. This can be set in the outliner:"
msgstr ""
"有时您不希望导出某些对象(例如用于烘焙的高分辨率模型)。 如果未在场景中渲染对"
"象，则不会导出该对象。 这可以在大纲中设置:"

#: ../../docs/getting_started/workflow/assets/escn_exporter/index.rst:35
msgid ""
"Objects hidden in the viewport will be exported, but will be hidden in the "
"Godot scene."
msgstr "隐藏在视区中的对象将被导出，但将隐藏在Godot场景中。"

#: ../../docs/getting_started/workflow/assets/escn_exporter/index.rst:40
msgid "Build pipeline integration"
msgstr "构建管线集成"

#: ../../docs/getting_started/workflow/assets/escn_exporter/index.rst:42
msgid ""
"If you have hundreds of model files, you don't want your artists to waste "
"time manually exporting their blend files. To combat this, the exporter "
"provides a python function ``io_scene_godot.export(out_file_path)`` that can "
"be called to export a file. This allows easy integration with other build "
"systems. An example Makefile and python script that exports all the blends "
"in a directory are present in the Godot-Blender-exporter repository."
msgstr ""
"如果您有数百个模型文件，则不希望您的艺术家浪费时间手动导出其混合文件。 为了解"
"决这个问题，导出器提供了一个python函数 ``io_scene_godot."
"export(out_file_path)`` ，可以调用它来导出文件。 这样可以轻松地与其他构建系统"
"集成。 导出目录中所有混合的Makefile和python脚本示例存在于Godot-Blender-"
"exporter存储库中。"

#: ../../docs/getting_started/workflow/assets/escn_exporter/material.rst:2
#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:132
#: ../../docs/tutorials/3d/using_gridmaps.rst:60
msgid "Materials"
msgstr "材质"

#: ../../docs/getting_started/workflow/assets/escn_exporter/material.rst:5
msgid "Using existing Godot materials"
msgstr "使用现有的Godot材质"

#: ../../docs/getting_started/workflow/assets/escn_exporter/material.rst:7
msgid ""
"One way in which the exporter can handle materials is to attempt to match "
"the Blender material with an existing Godot material. This has the advantage "
"of being able to use all of the features of Godot's material system, but it "
"means that you cannot see your model with the material applied inside "
"Blender."
msgstr ""
"出口商可以处理材质的一种方法是尝试将Blender材质与现有的Godot材质相匹配。 这样"
"做的好处是能够使用Godot材质系统的所有功能，但这意味着您无法使用Blender中应用"
"的材质看到您的模型。"

#: ../../docs/getting_started/workflow/assets/escn_exporter/material.rst:12
msgid ""
"To do this, the exporter attempts to find Godot materials with names that "
"match those of the material name in Blender. So if you export an object in "
"Blender with the material name ``PurpleDots`` then the exporter will search "
"for the file ``PurpleDots.tres`` and assign it to the object. If this file "
"is not a ``SpatialMaterial`` or ``ShaderMaterial`` or if it cannot be found, "
"then the exporter will fall back to exporting the material from Blender."
msgstr ""
"为此，导出器会尝试查找名称与Blender中的材质名称相匹配的Godot材质。 因此，如果"
"您在Blender中使用材质名称 ``PurpleDots`` 导出对象，则导出器将搜索文件 "
"``PurpleDots.tres`` 并将其分配给该对象。 如果此文件不是 ``SpatialMaterial`` "
"或 ``ShaderMaterial`` ，或者如果找不到，则导出器将退回到从Blender导出材质。"

#: ../../docs/getting_started/workflow/assets/escn_exporter/material.rst:20
msgid ""
"Where the exporter searches for the ``.tres`` file is determined by the "
"\"Material Search Paths\" option:"
msgstr "导出器搜索 ``.tres`` 文件的位置由“材质搜索路径”选项确定:"

#: ../../docs/getting_started/workflow/assets/escn_exporter/material.rst:34
msgid "This can take the value of:"
msgstr "这可以取以下值:"

#: ../../docs/getting_started/workflow/assets/escn_exporter/material.rst:26
msgid ""
"Project Directory - Attempts to find the ``project.Godot`` and recursively "
"searches through subdirectories. If ``project.Godot`` cannot be found it "
"will throw an error. This is useful for most projects where naming conflicts "
"are unlikely."
msgstr ""
"项目目录 - 尝试查找 ``project.Godot`` 并递归搜索子目录。 如果找不到 "
"``project.Godot`` ，则会抛出错误。 这对于不太可能存在命名冲突的大多数项目非常"
"有用。"

#: ../../docs/getting_started/workflow/assets/escn_exporter/material.rst:30
msgid ""
"Export Directory - Look for materials in subdirectories of the export "
"location. This is useful for projects where you may have duplicate material "
"names and need more control over what material gets assigned."
msgstr ""
"导出目录 - 在导出位置的子目录中查找材质。 这对于您可能具有重复材质名称并需要"
"更多控制所分配材质的项目非常有用。"

#: ../../docs/getting_started/workflow/assets/escn_exporter/material.rst:33
msgid "None - Do not search for materials. Export them from the Blender file."
msgstr "无 - 不搜索材质。 从Blender文件中导出它们。"

#: ../../docs/getting_started/workflow/assets/escn_exporter/material.rst:37
#, fuzzy
msgid "Export of Cycles/EEVEE materials"
msgstr "导出Blender材质"

#: ../../docs/getting_started/workflow/assets/escn_exporter/material.rst:39
msgid ""
"The exporter has a primitive support for converting Cycles/EEVEE material "
"node tree to Godot Shader Material. Note that some of the Shader Node are "
"not supported yet due to difficulties in implementation, which are:"
msgstr ""

#: ../../docs/getting_started/workflow/assets/escn_exporter/material.rst:43
msgid "all the ``noisy textures``"
msgstr ""

#: ../../docs/getting_started/workflow/assets/escn_exporter/material.rst:44
msgid "``generated texture coordinates``"
msgstr ""

#: ../../docs/getting_started/workflow/assets/escn_exporter/material.rst:45
msgid "``group node``"
msgstr ""

#: ../../docs/getting_started/workflow/assets/escn_exporter/material.rst:46
msgid ""
"shader nodes except ``PrincipledBSDF``, ``Diffuse``, ``Glossy``, ``Glass``, "
"``add shader`` and ``mix shader``"
msgstr ""

#: ../../docs/getting_started/workflow/assets/escn_exporter/material.rst:49
msgid ""
"If possible try to use PrincipledBSDF node with GGX distribution as the "
"output shader node, it is the only one guarantee to be exactly correctly. "
"Others are just based on approximation."
msgstr ""

#: ../../docs/getting_started/workflow/assets/escn_exporter/material.rst:52
#, fuzzy
msgid ""
"Sometimes materials may not be valid for exporting (e.g. has some "
"unsupported node) or it is using Blender Internal Engine, only the diffuse "
"color and a few flags (e.g. unshaded) are exported and form a Spatial "
"Material."
msgstr ""
"处理材质的另一种方式是让导出器从Blender中导出它们。 目前仅导出漫反射颜色和一"
"些标志(例如，无阴影)。"

#: ../../docs/getting_started/workflow/assets/escn_exporter/material.rst:58
#, fuzzy
msgid "Generate external materials"
msgstr "着色器材质"

#: ../../docs/getting_started/workflow/assets/escn_exporter/material.rst:60
msgid ""
"The default configuration of material exporting would keep all the materials "
"internal to the ``escn`` file. There is an option which could enable "
"generating external ``.material`` file when the ``escn`` file opens in Godot."
msgstr ""

#: ../../docs/getting_started/workflow/assets/escn_exporter/material.rst:66
msgid ""
"``.material`` file can be assigned to any material slot to be a external "
"resource."
msgstr ""

#: ../../docs/getting_started/workflow/assets/escn_exporter/physics.rst:2
msgid "Physics properties"
msgstr "物理特性"

#: ../../docs/getting_started/workflow/assets/escn_exporter/physics.rst:4
msgid ""
"Exporting physics properties is done by enabling \"Rigid Body\" in Blender's "
"physics tab:"
msgstr "通过在Blenders物理选项卡中启用“Rigid Body”来导出物理属性:"

#: ../../docs/getting_started/workflow/assets/escn_exporter/physics.rst:10
msgid ""
"By default, a single Blender object with rigid body enabled will export as "
"three nodes: a PhysicsBody, a CollisionShape, and a MeshInstance."
msgstr ""
"默认情况下，启用刚体的单个Blender对象将导出为三个节点:PhysicsBody，"
"CollisionShape和MeshInstance。"

#: ../../docs/getting_started/workflow/assets/escn_exporter/physics.rst:14
msgid "Body type"
msgstr "物体类型"

#: ../../docs/getting_started/workflow/assets/escn_exporter/physics.rst:16
msgid ""
"Blender only has the concept of \"Active\" and \"Passive\" rigid bodies. "
"These turn into Static and RigidBody nodes. To create a kinematic body, "
"enable the \"animated\" checkbox on an \"Active\" body:"
msgstr ""
"Blender只有“主动”和“被动”刚体的概念。 这些转变为Static和RigidBody节点。 要创"
"建运动体，请在“活动”物体上启用“动画”复选框:"

#: ../../docs/getting_started/workflow/assets/escn_exporter/physics.rst:23
#: ../../docs/tutorials/physics/physics_introduction.rst:55
msgid "Collision shapes"
msgstr "碰撞形状"

#: ../../docs/getting_started/workflow/assets/escn_exporter/physics.rst:25
msgid ""
"Many of the parameters for collision shapes are missing from Blender, and "
"many of the collision shapes are also not present. However, almost all of "
"the options in Blender's rigid body collision and rigid body dynamics "
"interfaces are supported:"
msgstr ""
"Blender中缺少碰撞形状的许多参数，并且许多碰撞形状也不存在。 但是，支持Blender"
"刚体碰撞和刚体动力学界面的几乎所有选项:"

#: ../../docs/getting_started/workflow/assets/escn_exporter/physics.rst:39
msgid "There are the following caveats:"
msgstr "以下是需要注意的事项:"

#: ../../docs/getting_started/workflow/assets/escn_exporter/physics.rst:33
msgid ""
"Not all of the collision shapes are supported. Only ``Mesh``, ``Convex "
"Hull``, ``Capsule``, ``Sphere`` and ``Box`` are supported in both Blender "
"and Godot"
msgstr ""
"并非所有碰撞形状都受支持。 Blender和Godot只支持 ``Mesh``, ``Convex Hull``, "
"``Capsule``, ``Sphere`` 和 ``Box``"

#: ../../docs/getting_started/workflow/assets/escn_exporter/physics.rst:36
msgid ""
"In Godot, you can have different collision groups and collision masks. In "
"Blender you only have collision groups. As a result, the exported object's "
"collision mask is equal to its collision group. Most of the time, this is "
"what you want."
msgstr ""
"在Godot中，您可以有不同的碰撞组和碰撞遮罩。 在Blender中，您只有碰撞组。 因"
"此，导出对象的冲突掩码等于其冲突组。 大多数时候，这就是您想要的。"

#: ../../docs/getting_started/workflow/assets/escn_exporter/physics.rst:42
msgid ""
"To build compound physics shapes, parent together multiple objects with "
"rigid body enabled. The physics properties are taken from the parent-most "
"rigid body, and the rest are used as collision shapes."
msgstr ""
"要构建复合物理形状，请将启用了刚体的多个对象组合在一起。 物理属性取自父级最刚"
"体，其余用作碰撞形状。"

#: ../../docs/getting_started/workflow/assets/escn_exporter/physics.rst:47
msgid "Collision geometry only"
msgstr "仅碰撞几何"

#: ../../docs/getting_started/workflow/assets/escn_exporter/physics.rst:49
msgid ""
"Frequently you want different geometry for your collision meshes and your "
"graphical meshes, but by default the exporter will export a mesh along with "
"the collision shape. To only export the collision shape, set the object's "
"maximum draw type to Wire:"
msgstr ""
"通常，您需要不同的几何体用于碰撞网格和图形网格，但默认情况下，导出器将导出网"
"格以及碰撞形状。 要仅导出碰撞形状，请将对象的最大绘制类型设置为Wire:"

#: ../../docs/getting_started/workflow/assets/escn_exporter/physics.rst:56
msgid ""
"This will also influence how the object is shown in Blender's viewport. Most "
"of the time, you want your collision geometry to be shown see-through when "
"working on the models, so this works out fairly nicely."
msgstr ""
"这也会影响对象在Blender视区中的显示方式。 大多数情况下，您希望在处理模型时显"
"示透视几何体，这样就可以很好地完成。"

#: ../../docs/getting_started/workflow/assets/escn_exporter/lights.rst:2
#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:68
#: ../../docs/tutorials/3d/introduction_to_3d.rst:223
msgid "Lights"
msgstr "灯光"

#: ../../docs/getting_started/workflow/assets/escn_exporter/lights.rst:4
msgid ""
"By default, lamps in Blender have shadows enabled. This can cause "
"performance issues in Godot."
msgstr "默认情况下，Blender中的灯泡启用了阴影。 这可能会导致Godot的性能问题。"

#: ../../docs/getting_started/workflow/assets/escn_exporter/lights.rst:8
msgid ""
"Lamps are exported using their \"Blender Render\" settings. When Blender 2.8 "
"is released, this will be removed and this part of the exporter will change."
msgstr ""
"使用“Blender Render”设置导出灯。 当Blender 2.8发布时，这将被删除，导出器的这"
"一部分将会改变。"

#: ../../docs/getting_started/workflow/assets/escn_exporter/lights.rst:11
msgid ""
"Sun, point and spot lamps are all exported from Blender along with many of "
"their properties:"
msgstr "太阳光，点光源和聚光灯都是从Blender导出的，带有许多属性:"

#: ../../docs/getting_started/workflow/assets/escn_exporter/lights.rst:16
msgid "There are some things to note:"
msgstr "有一些事情需要注意:"

#: ../../docs/getting_started/workflow/assets/escn_exporter/lights.rst:18
msgid ""
"In Blender, a light casts light all the way to infinity. In Godot, it is "
"clamped by the attenuation distance. To most closely match between the "
"viewport and Godot, enable the \"Sphere\" checkbox. (Highlighted green)"
msgstr ""
"在Blender中，一盏灯一直照射到无限远处。 在Godot中，它被衰减距离钳制。 要在视"
"区和Godot之间进行最紧密匹配，请启用“球体”复选框。 (以绿色高亮显示)"

#: ../../docs/getting_started/workflow/assets/escn_exporter/lights.rst:21
msgid ""
"Light attenuation models differ between Godot and Blender. The exporter "
"attempts to make them match, but it isn't always very good."
msgstr ""
"Godot和Blender之间的光衰减模型不同。 导出器试图使它们匹配，但并不总是很好。"

#: ../../docs/getting_started/workflow/assets/escn_exporter/lights.rst:23
msgid ""
"Spotlight angular attenuation models also differ between Godot and Blender. "
"The exporter attempts to make them similar, but it doesn't always look the "
"same."
msgstr ""
"Godot和Blender之间的聚光角度衰减模型也有所不同。 导出器试图使它们相似，但它看"
"起来并不总是相同。"

#: ../../docs/getting_started/workflow/assets/escn_exporter/lights.rst:26
msgid ""
"There is no difference between buffer shadow and ray shadow in the export."
msgstr "导出中的缓冲区阴影和光线阴影之间没有区别。"

#: ../../docs/getting_started/workflow/assets/escn_exporter/mesh.rst:2
msgid "Mesh"
msgstr "网络"

#: ../../docs/getting_started/workflow/assets/escn_exporter/mesh.rst:5
msgid "Modifiers"
msgstr "修饰符"

#: ../../docs/getting_started/workflow/assets/escn_exporter/mesh.rst:6
msgid ""
"There is an exporting option :code:`Apply Modifiers` to control whether mesh "
"modifiers are applied to the exported mesh."
msgstr ""
"有一个导出选项 :code:`Apply Modifiers` 来控制是否将网格修改器应用于导出的网"
"格。"

#: ../../docs/getting_started/workflow/assets/escn_exporter/mesh.rst:11
msgid "Shape Key"
msgstr "形状键"

#: ../../docs/getting_started/workflow/assets/escn_exporter/mesh.rst:12
msgid ""
"Exporting mesh shape key is supported, however exporting each shape key is "
"almost like exporting the mesh again, so don't be surprised it takes a "
"relatively long time."
msgstr ""
"支持导出网格形状键，但是导出每个形状键几乎就像再次导出网格一样，所以不要惊讶"
"它需要相对长的时间。"

#: ../../docs/getting_started/workflow/assets/escn_exporter/mesh.rst:17
msgid ""
"A lot of modifiers are not compatible with shape keys (e.g. subsurface "
"modifier), so if you found you have incorrect shape keys exported, try to "
"disable :code:`Apply Modifiers` and do the exporting again. Besides, it is "
"worthwhile to report the incompatible modifier to the `issue list <https://"
"github.com/godotengine/godot-blender-exporter/issues>`__, which helps to "
"develop the exporter to have a more precise check of modifiers."
msgstr ""
"很多修饰符与形状键不兼容(例如，次表面修饰符)，因此如果您发现导出的形状键不正"
"确，请尝试禁用 :code:`Apply Modifiers` 并再次导出。 此外，值得将不兼容的修饰"
"符报告给`问题列表 <https://github.com/godotengine/godot-blender-exporter/"
"issues>`__，这有助于开发导出器以更精确地检查改性剂。"

#: ../../docs/getting_started/workflow/assets/escn_exporter/skeleton.rst:2
#: ../../docs/development/file_formats/tscn.rst:153
msgid "Skeleton"
msgstr "骨架"

#: ../../docs/getting_started/workflow/assets/escn_exporter/skeleton.rst:7
msgid "Rest Bone"
msgstr "尾椎骨骼"

#: ../../docs/getting_started/workflow/assets/escn_exporter/skeleton.rst:9
msgid ""
"Armature object in Blender is exported as a Skeleton node along with rest "
"position (transform in Godot) of bones."
msgstr "Blender中的骨架对象与骨骼的静止位置(Godot变换)一起导出为Skeleton节点。"

#: ../../docs/getting_started/workflow/assets/escn_exporter/skeleton.rst:13
msgid ""
"The three check boxes :code:`Inherit Rotation`, :code:`Inherit Scale`, :code:"
"`Local Location` (colored in red) must be ticked when building armature in "
"Blender, so that the exported bone transform be consistent between Blender "
"and Godot"
msgstr ""
"三个复选框 :code:`Inherit Rotation`, :code:`Inherit Scale`, :code:`Local "
"Location` (红色)必须在Blender中构建骨架时勾选，以便导出的骨骼变换一致 在"
"Blender和Godot之间"

#: ../../docs/getting_started/workflow/assets/escn_exporter/skeleton.rst:19
msgid "Bone Weights"
msgstr "骨骼权重"

#: ../../docs/getting_started/workflow/assets/escn_exporter/skeleton.rst:21
msgid ""
"Blender put rigged mesh vertices which has no bone weights at its original "
"position, but these vertices would be placed at (0, 0, 0) in Godot, making "
"the mesh deformed. Therefore, the exporter would raise an error for any "
"vertex with no bone weights detected in a rigged mesh."
msgstr ""
"Blender放置了在其原始位置没有骨骼权重的装配网格顶点，但是这些顶点将放置在"
"Godot中的 (0, 0, 0) 处，这使得网格变形。 因此，导出器会在绑定网格中检测到任何"
"无骨骼权重顶点时引发错误。"

#: ../../docs/getting_started/workflow/assets/escn_exporter/skeleton.rst:27
msgid "Non-Deform Bone"
msgstr "非变形骨骼"

#: ../../docs/getting_started/workflow/assets/escn_exporter/skeleton.rst:29
msgid ""
"Note that the non-deform bone can be configured as not exported by enabling "
"the :code:`Exclude Control Bones`; the deform bone checkbox is shown in the "
"picture."
msgstr ""
"请注意，可以通过启用 :code:`Exclude Control Bones` 将非变形骨骼配置为不导出，"
"变形骨骼复选框显示在图片中。"

#: ../../docs/getting_started/workflow/assets/escn_exporter/skeleton.rst:35
msgid "Bone Attachment"
msgstr "骨附件"

#: ../../docs/getting_started/workflow/assets/escn_exporter/skeleton.rst:36
msgid ""
"A bone can be the parent of an object in Blender; this relation is exported "
"as a BoneAttachment node in the Godot scene."
msgstr ""
"Bone可以是Blender中对象的父对象，此关系将作为Godot场景中的BoneAttachment节点"
"导出。"

#: ../../docs/getting_started/workflow/assets/escn_exporter/animation.rst:8
msgid "Animation supported:"
msgstr "支持的动画:"

#: ../../docs/getting_started/workflow/assets/escn_exporter/animation.rst:4
msgid "transform animation of all types of objects"
msgstr "所有类型对象的变换动画"

#: ../../docs/getting_started/workflow/assets/escn_exporter/animation.rst:5
msgid "transform animation of pose bones"
msgstr "姿势骨骼的变换动画"

#: ../../docs/getting_started/workflow/assets/escn_exporter/animation.rst:6
msgid "shape key animation"
msgstr "形状的关键动画"

#: ../../docs/getting_started/workflow/assets/escn_exporter/animation.rst:7
msgid "light animation"
msgstr "轻动画"

#: ../../docs/getting_started/workflow/assets/escn_exporter/animation.rst:8
msgid "camera animation"
msgstr "摄像机动画"

#: ../../docs/getting_started/workflow/assets/escn_exporter/animation.rst:11
msgid "Multiple Actions For Single Object"
msgstr "单个对象的多个动作"

#: ../../docs/getting_started/workflow/assets/escn_exporter/animation.rst:12
msgid ""
"In most games, one object would have several animations to switch between. "
"This add-on has support for exporting multiple actions all at once into a "
"single AnimationPlayer and makes it easy to switch actions."
msgstr ""
"在大多数游戏中，一个对象会有几个动画来切换。这个插件支持将多个动作同时导出到"
"单个动画播放器中，使切换动作变得很容易。"

#: ../../docs/getting_started/workflow/assets/escn_exporter/animation.rst:16
msgid ""
"This workflow makes use of blender nla_tracks. Here is a brief guide on how "
"to use this feature:"
msgstr "此工作流程使用blender nla_tracks。 以下是如何使用此功能的简要指南:"

#: ../../docs/getting_started/workflow/assets/escn_exporter/animation.rst:19
#, fuzzy
msgid "**1. Stash active action**"
msgstr "**2. 存放主动行动**"

#: ../../docs/getting_started/workflow/assets/escn_exporter/animation.rst:21
msgid ""
"New created action is always an active action binded to object. There are "
"several ways to place an active action into NLA track, one is of course "
"doing it in ``NLA Editor``"
msgstr ""

#: ../../docs/getting_started/workflow/assets/escn_exporter/animation.rst:28
msgid "Or it can be done stashing the action in ``Dope Sheet``"
msgstr ""

#: ../../docs/getting_started/workflow/assets/escn_exporter/animation.rst:33
msgid "**2. Check mute status of NLA tracks**"
msgstr ""

#: ../../docs/getting_started/workflow/assets/escn_exporter/animation.rst:35
msgid ""
"An NLA track can be ``mute`` or ``unmute``, the exporter will export all the "
"``mute`` NLA track as a separate action, while blends all the ``unmute`` NLA "
"tracks into every action (including the action action) being exported."
msgstr ""

#: ../../docs/getting_started/workflow/assets/escn_exporter/animation.rst:41
#, fuzzy
msgid "**3. Export the scene**"
msgstr "**4. 导出场景**"

#: ../../docs/getting_started/workflow/assets/escn_exporter/animation.rst:43
msgid "Make sure the ``Export Stashed Actions`` option has been turned on."
msgstr ""

#: ../../docs/getting_started/workflow/assets/escn_exporter/animation.rst:47
#, fuzzy
msgid ""
"Then all the stashed actions, as well as the active action, are exported to "
"an AnimationPlayer."
msgstr "所有存储的操作以及活动操作都将导出到AnimationPlayer。"

#: ../../docs/getting_started/workflow/assets/escn_exporter/animation.rst:54
msgid "Constraints"
msgstr "约束"

#: ../../docs/getting_started/workflow/assets/escn_exporter/animation.rst:55
#, fuzzy
msgid ""
"Sometimes complicated animation is built with object constraint; a usual "
"example is inverse kinematics. The add-on would automatically check if an "
"object has some constraint; if it does, all the constraints are baked into "
"actions and then exported along with the object."
msgstr ""
"有时使用对象约束构建复杂动画，通常的示例是反向运动学。 插件会自动检查对象是否"
"有某些约束，如果有，则所有约束都被烘焙到对象具有的每个操作中，然后导出。"

#: ../../docs/getting_started/workflow/assets/escn_exporter/animation.rst:62
msgid "Animation Mode"
msgstr "动画模式"

#: ../../docs/getting_started/workflow/assets/escn_exporter/animation.rst:63
msgid ""
"Godot and Blender have different structure to store animation data. In Godot "
"animation data is stored in an AnimationPlayer node, instead of in each "
"animated node. In order to fix this inconsistence and still make the "
"animation play versatile, this add-on has three animation exporting modes."
msgstr ""
"Godot和Blender有不同的结构来存储动画数据。在Godot中，动画数据存储在一个"
"AnimationPlayer节点中，而不是存储在每个动画节点里。为了修复这种不一致性，并使"
"动画发挥多才多艺，这个插件有三种动画导出模式。"

#: ../../docs/getting_started/workflow/assets/escn_exporter/animation.rst:70
msgid "**Mode 'Animation as Actions'**"
msgstr "**'动作动画'模式**"

#: ../../docs/getting_started/workflow/assets/escn_exporter/animation.rst:72
msgid ""
"Treat all the animations as object actions, so in the exported scene, every "
"object would have its own AnimationPlayer and hold its actions."
msgstr ""
"将所有动画视为对象动作，因此在导出的场景中，每个对象都有自己的AnimationPlayer"
"并保持其动作。"

#: ../../docs/getting_started/workflow/assets/escn_exporter/animation.rst:76
msgid "**Mode 'Scene Animation'**"
msgstr "**模式 '场景动画' **"

#: ../../docs/getting_started/workflow/assets/escn_exporter/animation.rst:78
msgid ""
"If you want your animation to generate the same result as playing at "
"Blender's timeline, this is what you want. In this mode, all the animations "
"in the scene are placed in just one AnimationPlayer in the scene root."
msgstr ""
"如果您希望动画生成与在Blender的时间轴上播放相同的结果，这就是您想要的。 在此"
"模式下，场景中的所有动画都只放置在场景根中的一个AnimationPlayer中。"

#: ../../docs/getting_started/workflow/assets/escn_exporter/animation.rst:82
msgid "**Mode 'Animation as Action with Squash'**"
msgstr "**模式 '动画与压缩行为' **"

#: ../../docs/getting_started/workflow/assets/escn_exporter/animation.rst:84
msgid ""
"This mode has very similar behaviour of mode 'Animation as Action', but it "
"can generate fewer AnimationPlayers; objects in parent-children relationship "
"would share their AnimationPlayer. It is useful when you have several rigs, "
"and each Skeleton and Mesh has actions; then one rig would have just one "
"AnimationPlayer."
msgstr ""
"此模式与“动画为动作”模式的行为非常相似，但它可以生成较少的AnimationPlayers，"
"父子关系中的对象将共享其AnimationPlayer。 当您有几个装备，每个Skeleton和Mesh"
"都有动作时，它很有用，那么一个装备只有一个AnimationPlayer。"

#: ../../docs/getting_started/workflow/assets/index.rst:2
msgid "Assets workflow"
msgstr "资源工作流程"

#: ../../docs/getting_started/workflow/assets/import_process.rst:4
msgid "Import process"
msgstr "导入过程"

#: ../../docs/getting_started/workflow/assets/import_process.rst:7
msgid "Importing assets in Godot 3.0+"
msgstr "在 Godot 3.0+ 中导入资源"

#: ../../docs/getting_started/workflow/assets/import_process.rst:9
msgid ""
"Previously, importing assets in Godot 2.x required manual maintenance of a "
"separate directory with source assets. Without doing this, it was impossible "
"to specify how to convert and change import flags for textures, audio files, "
"scenes, etc."
msgstr ""
"以前，在Godot 2.x中导入资源需要手动维护一个包含源资源的单独目录。 如果不这样"
"做，就无法指定如何转换和更改纹理，音频，场景等的导入标志。"

#: ../../docs/getting_started/workflow/assets/import_process.rst:14
msgid ""
"In Godot 3.0, we use a more modern approach to importing: Simply drop your "
"assets (image files, scenes, audio files, fonts, etc) directly in the "
"project folder (copy them manually with your OS file explorer). Godot will "
"automatically import these files internally and keep the imported resources "
"hidden in a res://.import folder."
msgstr ""
"在Godot 3.0中，我们使用更现代的导入方法:只需将您的资源(图像文件，场景，音频，"
"字体等)直接放到项目文件夹中(使用系统文件浏览器手动复制它们)。 Godot会自动在内"
"部导入这些文件，并将导入的资源隐藏在res://.import文件夹中。"

#: ../../docs/getting_started/workflow/assets/import_process.rst:20
msgid "This allows changing all the import parameters transparently."
msgstr "这允许透明地更改所有导入参数。"

#: ../../docs/getting_started/workflow/assets/import_process.rst:23
msgid "Changing import parameters"
msgstr "更改导入参数"

#: ../../docs/getting_started/workflow/assets/import_process.rst:25
msgid ""
"Changing the import parameters of an asset in Godot (again, keep in mind "
"import parameters are only present in non-native Godot resource types) is "
"easy. Select the relevant resource in the filesystem dock:"
msgstr ""
"在Godot中更改资源的导入参数(再次记住，导入参数仅存在于非内置的 Godot 资源类型"
"中)很容易。 只需在文件系统面板中选择相关资源即可:"

#: ../../docs/getting_started/workflow/assets/import_process.rst:31
msgid ""
"Then, after adjusting the parameters, press \"Reimport\". These parameters "
"will only be used for this asset and on future reimports."
msgstr ""
"并且，在调整参数后，按下“重新导入”。 所使用的参数将仅用于此资源，并将用于未来"
"的重新导入。"

#: ../../docs/getting_started/workflow/assets/import_process.rst:34
msgid ""
"Changing the import parameters of several assets at the same time is also "
"possible. Simply select all of them together in the resources dock and the "
"exposed parameters will apply to all of them when reimporting."
msgstr ""
"同时更改多个资源的导入参数也是可能的。 只需在资源面板中一起选择所有这些资源，"
"当重新导入时, 所暴露的参数将应用于它们。"

#: ../../docs/getting_started/workflow/assets/import_process.rst:39
msgid "Automatic reimport"
msgstr "自动重新导入"

#: ../../docs/getting_started/workflow/assets/import_process.rst:41
msgid ""
"When the MD5 checksum of the source asset changes, Godot will perform an "
"automatic reimport of it, applying the preset configured for that specific "
"asset."
msgstr ""
"当源资源的 MD5 校验发生变化时，Godot 将执行自动重新导入，应用为该特定资源配置"
"的预设。"

#: ../../docs/getting_started/workflow/assets/import_process.rst:46
msgid "Files generated"
msgstr "生成的文件"

#: ../../docs/getting_started/workflow/assets/import_process.rst:48
msgid ""
"Importing will add an extra <asset>.import file, containing the import "
"configuration. Make sure to commit these to your version control system!"
msgstr ""
"导入将添加一个额外的<asset> .import 文件，其中包含导入配置。 确保将这些提交到"
"您的版本控制系统！"

#: ../../docs/getting_started/workflow/assets/import_process.rst:53
msgid ""
"Additionally, extra assets will be preset in the hidden res://.import folder:"
msgstr "此外，额外的资源将预设在隐藏的res://.import文件夹中:"

#: ../../docs/getting_started/workflow/assets/import_process.rst:57
msgid ""
"If any of the files present in this folder is erased (or the whole folder), "
"the asset or assets will be reimported automatically. As such, committing "
"this folder to the version control system is optional. It can shorten "
"reimporting time when checking out on another computer, but it takes "
"considerably more space and transfer time. Pick your poison!"
msgstr ""
"如果此文件夹中的任何文件被删除(或整个文件夹)，则资源将自动重新导入。 因此，将"
"此文件夹提交给版本控制系统是可选的。 在另一台计算机上检查时，它可以节省重新导"
"入的时间，但需要更多的空间和传输时间。 请自己决定！"

#: ../../docs/getting_started/workflow/assets/import_process.rst:64
msgid "Changing import resource type"
msgstr "更改导入资源类型"

#: ../../docs/getting_started/workflow/assets/import_process.rst:66
msgid ""
"Some source assets can be imported as different types of resources. For "
"this, select the relevant type of resource desired and press \"Reimport\":"
msgstr ""
"一些源资源可以作为不同类型的资源导入。 为此，只需选择所需的相关资源类型并"
"按“重新导入”即可:"

#: ../../docs/getting_started/workflow/assets/import_process.rst:74
msgid "Changing default import parameters"
msgstr "更改默认导入参数"

#: ../../docs/getting_started/workflow/assets/import_process.rst:76
msgid ""
"Different types of games might require different defaults. Changing the "
"defaults per project can be achieved by using the \"Preset..\" Menu. Besides "
"some resource types offering presets, the default setting can be saved and "
"cleared too:"
msgstr ""
"不同类型的游戏可能需要不同的默认值。 通过使用“Preset ..”菜单可以更改每个项目"
"的默认值。 除了某些提供预设的资源类型外，还可以保存和清除默认设置:"

#: ../../docs/getting_started/workflow/assets/import_process.rst:84
msgid "Simplicity is key!"
msgstr "简单是关键!"

#: ../../docs/getting_started/workflow/assets/import_process.rst:86
msgid ""
"This is a very simple workflow which should take very little time to get "
"used to. It also enforces a more correct way to deal with resources."
msgstr ""
"这是一个非常简单的工作流程，只需很短的时间来习惯。 它还能以更加正确的方式来处"
"理资源。"

#: ../../docs/getting_started/workflow/assets/import_process.rst:89
msgid ""
"There are many types of assets available for import, so please continue "
"reading to understand how to work with all of them!"
msgstr "有许多类型的资源可供导入，因此请继续阅读以了解如何使用这些资源！"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:4
msgid "Importing images"
msgstr "导入图像"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:7
msgid "Why import them?"
msgstr "为什么要导入它们？"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:9
msgid ""
"In Godot 3+, image files are no longer native resources and they must be "
"imported. The reason behind this is the large amount of configuration "
"parameters that image files can be imported with."
msgstr ""
"在 Godot 3+ 中，图像文件不再是内置类型资源，它们必须被导入。 这背后的原因是可"
"以导入图像文件的大量配置参数。"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:13
msgid ""
"This small tutorial will explain what these parameters are and how to best "
"make use of them."
msgstr "这个小教程将解释这些参数是什么以及如何最好地利用它们。"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:17
msgid "Importing textures"
msgstr "导入纹理"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:19
msgid ""
"The default action in Godot is to import images as textures. Textures are "
"stored in video memory and can't be accessed directly. This is what makes "
"drawing them efficient."
msgstr ""
"Godot 中的默认操作是将图像导入为纹理。 纹理存储在显存中，不能直接访问。 这就"
"是使得绘制它们变得高效的原因。"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:23
msgid "Import options are vast:"
msgstr "导入选项非常广泛:"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:28
msgid "Compression"
msgstr "压缩"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:30
msgid ""
"Images are one of the largest assets in a game. To handle them efficiently, "
"they need to be compressed. Godot offers several compression methods, "
"depending on the use case."
msgstr ""
"图像是游戏中最大的资源之一。为了有效地被处理, 需要压缩它们。根据用户的需求, "
"Godot 提供了几种压缩方法。"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:34
msgid "Compress Mode"
msgstr "压缩模式"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:36
msgid ""
"VRAM Compression: This is the most common compression mode for 3D assets. "
"File on disk is reduced and video memory usage is also reduced considerably. "
"For 3D, it may present unwanted artifacts, though."
msgstr ""
"VRAM 压缩:这是 3D 资源最常见的压缩模式。 磁盘上的文件减少，显存使用量也大大减"
"少。 但对 3D 来说，它可能会因此出现不期望的失真。"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:38
msgid ""
"Lossless Compression: This is the most common compression for 2D assets. It "
"shows assets without any kind of artifacting, and disk compression is "
"decent. It will use considerably more amount of video memory than VRAM, "
"though."
msgstr ""
"无损压缩:这是 2D 资源最常见的压缩。 这说明资源没有任何形式的失真，并且磁盘压"
"缩率也不错。 不过，它将使用比 VRAM 更多的显存。"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:40
msgid ""
"Lossy Compression: For games with lots of large 2D assets, lossy compression "
"can be a great choice. It has some artifacting, but less than VRAM and the "
"file size is almost a tenth of Lossless."
msgstr ""
"有损压缩:对于拥有大量 2D 资源的游戏，有损压缩可能是一个不错的选择。 它有一些"
"失真，但少于 VRAM ，文件大小几乎是Lossless的十分之一。"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:42
msgid ""
"Uncompressed: Only useful for formats that can't be compressed (like, raw "
"float)."
msgstr "未压缩:仅适用于无法压缩的格式(如raw float)。"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:44
msgid ""
"In this table, each of the four options are described together with their "
"advantages and disadvantages ( |good| = Best, |bad| =Worst ):"
msgstr ""
"在这张表中，四个选项中的每一个都描述了它们的优缺点(| good | = 最好的，| bad "
"| = 最差的):"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:48
msgid "Uncompressed"
msgstr "未压缩"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:48
msgid "Compress Lossless (PNG)"
msgstr "无损压缩( PNG )"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:48
msgid "Compress Lossy (WebP)"
msgstr "有损压缩( WebP )"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:48
msgid "Compress VRAM"
msgstr "压缩 VRAM"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:50
msgid "Stored as raw pixels"
msgstr "存储为原始像素"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:50
msgid "Stored as PNG"
msgstr "存储为 PNG"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:50
msgid "Stored as WebP"
msgstr "存储为 WebP"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:50
msgid "Stored as S3TC/BC,PVRTC/ETC, depending on platform"
msgstr "存储为 S3TC/BC,PVRTC/ETC, 具体取决于平台"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:52
msgid "Size on Disk"
msgstr "占用磁盘大小"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:52
#: ../../docs/getting_started/workflow/assets/importing_images.rst:54
msgid "|bad| Large"
msgstr "|糟糕| 大"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:52
msgid "|regular| Small"
msgstr "|常规|小"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:52
msgid "|good| Very Small"
msgstr "|好|非常小"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:54
msgid "Memory Usage"
msgstr "内存使用情况"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:54
msgid "|good| Small"
msgstr "|好| 小"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:56
#: ../../docs/tutorials/2d/canvas_layers.rst:70
msgid "Performance"
msgstr "性能"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:56
#: ../../docs/getting_started/workflow/assets/importing_images.rst:60
msgid "|regular| Normal"
msgstr "|常规|普通"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:56
#: ../../docs/getting_started/workflow/assets/importing_images.rst:60
msgid "|good| Fast"
msgstr "|良好|快速"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:58
msgid "Quality Loss"
msgstr "质量损耗"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:58
msgid "|good| None"
msgstr "|良好|无"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:58
msgid "|regular| Slight"
msgstr "|常规|轻微"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:58
msgid "|bad| Moderate"
msgstr "|糟糕|中等"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:60
msgid "Load Time"
msgstr "加载时间"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:60
msgid "|bad| Slow"
msgstr "|糟糕| 缓慢"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:70
msgid "HDR Mode"
msgstr "HDR 模式"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:72
msgid ""
"Godot supports high dynamic range textures (as .HDR or .EXR). These are "
"mostly useful as high dynamic range equirectangular panorama skies (the "
"internet has plenty if you search for them), which replace Cubemaps in Godot "
"2.x. Modern PCs support the BC6H VRAM format, but there are still plenty "
"that do not."
msgstr ""
"Godot支持高动态范围图像纹理(如 .HDR或 .EXR)。 这些图像作为高动态范围 EPR 投影"
"全景天空是非常有用的(如果您试着去找，互联网上有很多)，它取代了Godot 2.x的 "
"Cubemaps 。 现代个人电脑支持 BC6H VRAM 格式，但仍有很多电脑不支持。"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:75
msgid ""
"If you want Godot to ensure full compatibility in terms of the kind of "
"textures, enable the \"Force RGBE\" option."
msgstr "如果您希望 Godot 确保完全兼容各种纹理，请启用“强制 RGBE ”选项。"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:78
msgid "Normal Map"
msgstr "法线贴图"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:80
msgid ""
"When using a texture as normal map, only the red and green channels are "
"required. Given regular texture compression algorithms produce artifacts "
"that don't look that nice in normal maps, the RGTC compression format is the "
"best fit for this data. Forcing this option to \"Enabled\" will make Godot "
"import the image as RGTC compressed. By default, it's set to \"Detect\", "
"which means that if the texture is ever used as a normal map, it will be "
"changed to \"Enabled\" and reimported automatically."
msgstr ""
"当使用纹理作为法线贴图时，只需要红色和绿色通道。 鉴于常规纹理压缩算法产生的失"
"真在法线贴图中看起来不太好，RGTC 压缩格式最适合这种数据。 将此选项强制为“已启"
"用”将使Godot导入 RGTC 压缩的图像。 默认情况下，它被设置为“Detect”，这意味着如"
"果纹理一旦被用作法线贴图，则会将其更改为“Enabled”并自动重新导入。"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:86
#: ../../docs/tutorials/3d/spatial_material.rst:19
msgid "Flags"
msgstr "标志"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:88
msgid ""
"There are plenty of settings that can be toggled when importing an image as "
"a texture, depending on the use case."
msgstr "根据使用情况，将图像作为纹理导入时可以切换很多设置。"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:91
msgid "Repeat"
msgstr "重复"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:93
msgid ""
"This setting is most commonly used in 3D, and is therefore generally "
"disabled in 2D. It sets UV coordinates going beyond the 0,0 - 1,1 range to "
"\"loop\"."
msgstr ""
"这种设置在 3D 中比 2D 更常用(因此它通常在 2D 中禁用)。 它使得UV坐标超出了0,0 "
"- 1,1范围“循环”。 重复可选为设置成镜像模式。"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:95
msgid "Repeating can optionally be set to mirrored mode."
msgstr "可以选择将重复设置为镜像模式。"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:98
msgid "Filter"
msgstr "过滤器"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:100
msgid ""
"When pixels become larger than the screen pixels, this option enables linear "
"interpolation for them. The result is a smoother (less blocky) texture. This "
"setting can be commonly used in 2D and 3D, but it's usually disabled when "
"making pixel perfect games."
msgstr ""
"当像素大于屏幕像素时，此选项可为它们启用线性插值。结果是更平滑的(更少块状)纹"
"理。此设置可以在 2D 和 3D 中常用，但在制作像素匹配的游戏时通常会被禁用。"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:103
msgid "Mipmaps"
msgstr "Mipmaps"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:105
msgid ""
"When pixels become smaller than the screen, mipmaps kick in. This helps "
"reduce the grainy effect when shrinking the textures. Keep in mind that, in "
"older hardware (GLES2, mainly mobile), there are some requirements to use "
"mipmaps:"
msgstr ""
"当像素变得比屏幕小时，mipmap 会启用。这有助于减少纹理收缩时的颗粒感效应。 请"
"记住，在较旧的硬件(GLES2，主要是移动设备)中，使用 mipmap 需要满足一些要求:"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:108
msgid "Texture width and height must be powers of 2"
msgstr "纹理宽度和高度必须是2的幂"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:109
msgid "Repeat must be enabled"
msgstr "必须启用Repeat"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:111
msgid ""
"Keep in mind the above when making phone games and applications, want to aim "
"for full compatibility, and need mipmaps."
msgstr ""
"在制作手机游戏和应用程序时，希望完全兼容并使用 mipmap，请牢记以上内容。"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:113
msgid ""
"When doing 3D, mipmap should be turned on, as this also improves performance "
"(smaller versions of the texture are used for objects further away)."
msgstr ""
"在 3D 模式下，应该打开 mipmap，因为这也会提高性能(更小大小的纹理用于更远的对"
"象)。"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:116
msgid "Anisotropic"
msgstr "各向异性"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:118
msgid ""
"When textures are near parallel to the view (like floors), this option makes "
"them have more detail by reducing blurriness."
msgstr ""
"当纹理几乎与视图平行时(如地板)，该选项通过减少模糊程度使它们具有更多细节。"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:121
msgid "SRGB"
msgstr "SRGB 色彩空间"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:123
msgid ""
"Godot uses Linear colorspace when rendering 3D. Textures mapped to albedo or "
"detail channels need to have this option turned on in order for colors to "
"look correct. When set to \"Detect\" mode, the texture will be marked as "
"SRGB when used in albedo channels."
msgstr ""
"渲染 3D 图像时，Godot使用线性颜色空间。 映射到 albedo (反照率)或细节通道的纹"
"理需要打开此选项才能使颜色看起来正确。 当设置为“Detect”模式时，纹理将在反照率"
"通道中使用时标记为 SRGB 。"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:127
msgid "Process"
msgstr "过程"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:129
msgid ""
"Some special processes can be applied to images when imported as textures."
msgstr "当作为纹理导入时, 某些特殊过程可以应用于图像。"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:132
msgid "Fix Alpha Border"
msgstr "修复 Alpha 边框"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:134
msgid ""
"This puts pixels of the same surrounding color in transition from "
"transparency to non transparency. It helps mitigate the outline effect when "
"exporting images from Photoshop and the like."
msgstr ""
"这将周围相同颜色的像素从透明转换为非透明。 它有助于减轻从 Photoshop 等导出图"
"像时的轮廓效果。"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:139
msgid ""
"It's a good idea to leave it on by default, unless specific values are "
"needed."
msgstr "除非需要特定的值，否则最好在默认情况下保持开启。"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:142
msgid "Premultiplied Alpha"
msgstr "预乘Alpha"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:144
msgid ""
"An alternative to fix darkened borders is to use premultiplied alpha. By "
"enabling this option, the texture will be converted to this format. Keep in "
"mind that a material will need to be created that uses the PREMULT ALPHA "
"blend mode on canvas items that need it."
msgstr ""
"修复黑暗边界的替代方法是使用预乘alpha。 通过启用此选项，纹理将转换为此格式。 "
"请记住，在画布物体上使用预乘 ALPHA 混合模式需要创建一个材质。"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:148
msgid "HDR as sRGB"
msgstr "HDR 转为 SRGB"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:150
msgid ""
"A few HDR files are broken and contain sRGB color data. It is advised not to "
"use them, but, in the worst-case scenario, toggling this option on will make "
"them look right."
msgstr ""
"一些 HDR 文件可能被破坏并包含 SRGB 颜色数据。 一般不建议使用它们，但在最坏的"
"情况下，切换此选项将使它们看起来正确。"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:153
msgid "Invert Color"
msgstr "反转颜色"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:155
msgid ""
"Reverses the image's color. This is useful, for example, to convert a height "
"map generated by external programs to depth map to use with :ref:"
"`doc_spatial_material`."
msgstr ""
"反转图像的颜色。 例如，将外部程序生成的高度图转换为深度图以用于 :ref:"
"`doc_spatial_material` 非常有用。"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:158
msgid "Detect 3D"
msgstr "检测3D"

#: ../../docs/getting_started/workflow/assets/importing_images.rst:160
msgid ""
"This option makes Godot be aware of when a texture (which is imported for 2D "
"as default) is used in 3D. If this happens, setting are changed so the "
"texture flags are friendlier to 3D (mipmaps, filter and repeat become "
"enabled and compression is changed to VRAM). Texture is also reimported "
"automatically."
msgstr ""
"这个选项让 Godot 知道在 3D 中何时使用纹理(默认情况下导入为 2D )。 如果开启这"
"个选项，设置会发生改变，所以纹理标记对 3D 更友好( mipmap ，过滤器和repeat变为"
"启用，压缩变为 VRAM )。 纹理也自动重新导入。"

#: ../../docs/getting_started/workflow/assets/importing_audio_samples.rst:4
msgid "Importing audio samples"
msgstr "导入音频采样"

#: ../../docs/getting_started/workflow/assets/importing_audio_samples.rst:7
msgid "Why import?"
msgstr "为什么要导入？"

#: ../../docs/getting_started/workflow/assets/importing_audio_samples.rst:9
msgid ""
"Raw audio data in general is large and undesired. Godot provides two main "
"options to import your audio data: WAV and OGG Vorbis."
msgstr ""
"原始音频数据通常很大且不受欢迎。 Godot 提供了两个主要选项来导入您的音频数据:"
"WAV 和 OGG Vorbis。"

#: ../../docs/getting_started/workflow/assets/importing_audio_samples.rst:12
msgid ""
"Each has different advantages. * Wav files use raw data or light "
"compression, make few demands on the CPU to play back (hundreds of "
"simultaneous voices in this format are fine), but take up significant space. "
"* Ogg Vorbis files use a stronger compression that results in much smaller "
"file size, but require significantly more processing power to play back."
msgstr ""
"每个都有不同的优点。 * Wav 文件使用原始数据或轻量级压缩，需要少量 CPU 播放(数"
"百个同时以这种格式播放的声音很好)，但占用大量空间。 * Ogg Vorbis 文件使用更强"
"大的压缩功能，文件大小更小，但使用的处理器数量更多。"

#: ../../docs/getting_started/workflow/assets/importing_audio_samples.rst:19
msgid "Here is a comparative chart."
msgstr "这有一个比较图表。"

#: ../../docs/getting_started/workflow/assets/importing_audio_samples.rst:22
msgid "Format"
msgstr "格式"

#: ../../docs/getting_started/workflow/assets/importing_audio_samples.rst:22
msgid "1 Second of Audio"
msgstr "1秒的音频"

#: ../../docs/getting_started/workflow/assets/importing_audio_samples.rst:24
msgid "WAV 24 bits, 96 kHz, Stereo"
msgstr "WAV 24 bits, 96 kHz, 立体声"

#: ../../docs/getting_started/workflow/assets/importing_audio_samples.rst:24
msgid "576kb"
msgstr "576kb"

#: ../../docs/getting_started/workflow/assets/importing_audio_samples.rst:26
msgid "WAV 16 bits, 44 kHz, Mono"
msgstr "WAV 16 bits, 44 kHz, 单声道"

#: ../../docs/getting_started/workflow/assets/importing_audio_samples.rst:26
msgid "88kb"
msgstr "88kb"

#: ../../docs/getting_started/workflow/assets/importing_audio_samples.rst:28
msgid "WAV 16 bits, IMA-ADPCM, Mono"
msgstr "WAV 16 位, IMA-ADPCM, 单声道"

#: ../../docs/getting_started/workflow/assets/importing_audio_samples.rst:28
msgid "22kb"
msgstr "22kb"

#: ../../docs/getting_started/workflow/assets/importing_audio_samples.rst:30
msgid "OGG 128kbps, Stereo"
msgstr "OGG 128kbps, 立体声"

#: ../../docs/getting_started/workflow/assets/importing_audio_samples.rst:30
msgid "16kb"
msgstr "16kb"

#: ../../docs/getting_started/workflow/assets/importing_audio_samples.rst:32
msgid "OGG Vorbis 96kbps, Stereo"
msgstr "OGG Vorbis 96kbps, 立体声"

#: ../../docs/getting_started/workflow/assets/importing_audio_samples.rst:32
msgid "12kb"
msgstr "12kb"

#: ../../docs/getting_started/workflow/assets/importing_audio_samples.rst:35
#, fuzzy
msgid ""
"Consider using WAV for short and repetitive sound effects, and OGG for "
"music, speech, and long sound effects."
msgstr ""
"一般来说，建议使用 WAV 处理大多数音效，特别是那些短而重复的音效，OGG 用于音"
"乐，声音和长音效。"

#: ../../docs/getting_started/workflow/assets/importing_audio_samples.rst:39
#: ../../docs/getting_started/workflow/best_practices/index.rst:2
#, fuzzy
msgid "Best practices"
msgstr "最佳做法"

#: ../../docs/getting_started/workflow/assets/importing_audio_samples.rst:41
msgid ""
"Godot 3+ has an amazing bus system with built-in effects. This saves SFX "
"artists the need to add reverb to the sound effects, reducing their size "
"greatly and ensuring correct trimming. Say no to SFX with baked reverb!"
msgstr ""
"Godot 3+ 拥有令人惊叹的内置效果的总线系统。 这略去了 SFX 艺术家需要添加混响到"
"音效的步骤，大大减少它们的大小，并确保了正确的修剪。 用烘焙混响对 SFX 说不！"

#: ../../docs/getting_started/workflow/assets/importing_audio_samples.rst:48
msgid "As you can see above, sound effects become huge with reverb added."
msgstr "正如您在上面看到的，添加混响后音效变得庞大。"

#: ../../docs/getting_started/workflow/assets/importing_audio_samples.rst:51
msgid "Trimming"
msgstr "修剪"

#: ../../docs/getting_started/workflow/assets/importing_audio_samples.rst:53
msgid ""
"One issue that happens often is that the waveform is exported with long "
"silences at the beginning and at the end. These are inserted by DAWs when "
"saving to a waveform, increase their size unnecessarily and add latency to "
"the moment they are played back."
msgstr ""
"经常发生的一个问题是波形在开始和结束时都会长时间静音输出。 当保存为波形时，它"
"们由 DAW(数字音频工作站) 插入，不必要地增加了它们的大小，并在播放时增加延迟。"

#: ../../docs/getting_started/workflow/assets/importing_audio_samples.rst:58
msgid "Importing as WAV with the Trimming option enabled solves this."
msgstr "启用 \"修剪\" 选项导入为 WAV 可以解决此情况。"

#: ../../docs/getting_started/workflow/assets/importing_audio_samples.rst:62
msgid "Looping"
msgstr "循环"

#: ../../docs/getting_started/workflow/assets/importing_audio_samples.rst:64
#, fuzzy
msgid ""
"Godot supports looping in the samples (tools such as Sound Forge or Audition "
"can add loop points to wav files). This is useful for sound effects, such as "
"engines, machine guns etc. Ping-pong looping is also supported."
msgstr ""
"Godot 支持在采样中循环(Sound Forge或Audition等工具可以将循环点添加到 wav 文件"
"中)。 这对发动机，机枪等音效非常有用。乒乓循环也受支持。"

#: ../../docs/getting_started/workflow/assets/importing_audio_samples.rst:69
msgid ""
"As an alternative, the import screen has a \"loop\" option that enables "
"looping for the entire sample when importing."
msgstr "作为替代方案，导入屏幕具有“循环”选项，可在导入时启用整个采样的循环。"

#: ../../docs/getting_started/workflow/assets/importing_translations.rst:4
msgid "Importing translations"
msgstr "导入翻译"

#: ../../docs/getting_started/workflow/assets/importing_translations.rst:7
msgid "Games and internationalization"
msgstr "游戏与国际化"

#: ../../docs/getting_started/workflow/assets/importing_translations.rst:9
msgid ""
"The world is full of different markets and cultures and, to maximize "
"profits™, nowadays games are released in several languages. To solve this, "
"internationalized text must be supported in any modern game engine."
msgstr ""
"世界充满了不同的市场和文化，为了实现利润最大化，现在的游戏以多种语言发布。 为"
"了解决这个问题，任何现代游戏引擎都必须支持国际化文本。"

#: ../../docs/getting_started/workflow/assets/importing_translations.rst:14
msgid ""
"In regular desktop or mobile applications, internationalized text is usually "
"located in resource files (or .po files for GNU stuff). Games, however, can "
"use several orders of magnitude more text than applications, so they must "
"support efficient methods for dealing with loads of multilingual text."
msgstr ""
"在普通的桌面或移动应用程序中，国际化文本通常位于资源文件(或用于GNU内容的 .po "
"文件)中。 然而，游戏可以使用比应用程序多几个数量级的文本，因此它们必须支持处"
"理多语言文本加载的有效方法。"

#: ../../docs/getting_started/workflow/assets/importing_translations.rst:20
msgid ""
"There are two approaches to generate multilingual language games and "
"applications. Both are based on a key:value system. The first is to use one "
"of the languages as the key (usually English), the second is to use a "
"specific identifier. The first approach is probably easier for development "
"if a game is released first in English, later in other languages, but a "
"complete nightmare if working with many languages at the same time."
msgstr ""
"有两种方法来生成多语言的游戏和应用程序。 两者都基于键值对系统。 第一种是使用"
"其中一种语言作为关键词(通常是英语)，第二种是使用特定的标识符。 如果首先用英语"
"发布游戏，后来以其他语言发布游戏，则第一种方法可能更易于开发，但如果同时使用"
"多种语言则完全是一场噩梦。"

#: ../../docs/getting_started/workflow/assets/importing_translations.rst:28
msgid ""
"In general, games use the second approach and a unique ID is used for each "
"string. This allows you to revise the text while it is being translated to "
"other languages. The unique ID can be a number, a string, or a string with a "
"number (it's just a unique string anyway)."
msgstr ""
"一般来说，游戏使用第二种方法，并为每个字符串使用唯一的ID。 这允许您在翻译为其"
"他语言的同时修改文本。 唯一ID可以是数字，字符串或带有数字的字符串(无论如何它"
"只是一个唯一的字符串)。"

#: ../../docs/getting_started/workflow/assets/importing_translations.rst:33
msgid "Translators also usually prefer to work with spreadsheets."
msgstr "翻译者通常更喜欢使用电子表格。"

#: ../../docs/getting_started/workflow/assets/importing_translations.rst:36
msgid "Translation format"
msgstr "翻译格式"

#: ../../docs/getting_started/workflow/assets/importing_translations.rst:38
msgid ""
"To complete the picture and allow efficient support for translations, Godot "
"has a special importer that can read CSV files. All spreadsheet editors (be "
"it Libreoffice, Microsoft Office, Google Docs, etc.) can export to this "
"format, so the only requirement is that the files have a special "
"arrangement. The CSV files must be saved in UTF-8 encoding and be formatted "
"as follows:"
msgstr ""
"为了完成图片并为翻译提供有效的支持，Godot 有一个特殊的导入器，可以读取CSV文"
"件。 所有电子表格编辑器(无论是 Libreoffice，Microsoft Office，Google Docs等)"
"都可以导出为这种格式，因此唯一的要求是这些文件有特殊的安排。 CSV 文件必须以 "
"UTF-8 编码格式保存，格式如下:"

#: ../../docs/getting_started/workflow/assets/importing_translations.rst:46
msgid "<lang1>"
msgstr "<lang1>"

#: ../../docs/getting_started/workflow/assets/importing_translations.rst:46
msgid "<lang2>"
msgstr "<lang2>"

#: ../../docs/getting_started/workflow/assets/importing_translations.rst:46
msgid "<langN>"
msgstr "<langN>"

#: ../../docs/getting_started/workflow/assets/importing_translations.rst:48
msgid "KEY1"
msgstr "KEY1"

#: ../../docs/getting_started/workflow/assets/importing_translations.rst:48
#: ../../docs/getting_started/workflow/assets/importing_translations.rst:50
#: ../../docs/getting_started/workflow/assets/importing_translations.rst:52
#: ../../docs/tutorials/misc/binary_serialization_api.rst:33
msgid "string"
msgstr "字符串"

#: ../../docs/getting_started/workflow/assets/importing_translations.rst:50
msgid "KEY2"
msgstr "KEY2"

#: ../../docs/getting_started/workflow/assets/importing_translations.rst:52
msgid "KEYN"
msgstr "KEYN"

#: ../../docs/getting_started/workflow/assets/importing_translations.rst:55
msgid ""
"The \"lang\" tags must represent a language, which must be one of the :ref:"
"`valid locales <doc_locales>` supported by the engine. The \"KEY\" tags must "
"be unique and represent a string universally (they are usually in uppercase, "
"to differentiate from other strings). Here's an example:"
msgstr ""
"<lang*> 标签必须表示一种语言, 它必须选自 :ref:`valid locales <doc_locales>` "
"中的Locale列的有效值才能被引擎支持。KEY 标签必须是唯一的, 并普遍地代表某个字"
"符串 (它们通常是全大写, 以区别于其他字符串)。下面是一个示例:"

#: ../../docs/getting_started/workflow/assets/importing_translations.rst:61
#: ../../docs/tutorials/i18n/locales.rst:352
msgid "id"
msgstr "id"

#: ../../docs/getting_started/workflow/assets/importing_translations.rst:61
#: ../../docs/tutorials/i18n/locales.rst:178
msgid "en"
msgstr "en"

#: ../../docs/getting_started/workflow/assets/importing_translations.rst:61
#: ../../docs/tutorials/i18n/locales.rst:220
msgid "es"
msgstr "es"

#: ../../docs/getting_started/workflow/assets/importing_translations.rst:61
#: ../../docs/tutorials/i18n/locales.rst:372
msgid "ja"
msgstr "ja"

#: ../../docs/getting_started/workflow/assets/importing_translations.rst:63
msgid "GREET"
msgstr "GREET"

#: ../../docs/getting_started/workflow/assets/importing_translations.rst:63
msgid "Hello, friend!"
msgstr "Hello, friend!"

#: ../../docs/getting_started/workflow/assets/importing_translations.rst:63
msgid "Hola, Amigo!"
msgstr "Hola, Amigo!"

#: ../../docs/getting_started/workflow/assets/importing_translations.rst:63
msgid "こんにちは"
msgstr "こんにちは"

#: ../../docs/getting_started/workflow/assets/importing_translations.rst:65
msgid "ASK"
msgstr "ASK"

#: ../../docs/getting_started/workflow/assets/importing_translations.rst:65
msgid "How are you?"
msgstr "How are you?"

#: ../../docs/getting_started/workflow/assets/importing_translations.rst:65
msgid "Cómo está?"
msgstr "Cómo está?"

#: ../../docs/getting_started/workflow/assets/importing_translations.rst:65
msgid "元気ですか"
msgstr "元気ですか"

#: ../../docs/getting_started/workflow/assets/importing_translations.rst:67
msgid "BYE"
msgstr "BYE"

#: ../../docs/getting_started/workflow/assets/importing_translations.rst:67
msgid "Good Bye"
msgstr "Good Bye"

#: ../../docs/getting_started/workflow/assets/importing_translations.rst:67
msgid "Adiós"
msgstr "Adiós"

#: ../../docs/getting_started/workflow/assets/importing_translations.rst:67
msgid "さようなら"
msgstr "さようなら"

#: ../../docs/getting_started/workflow/assets/importing_translations.rst:71
#, fuzzy
msgid "CSV importer"
msgstr "CSV导入器"

#: ../../docs/getting_started/workflow/assets/importing_translations.rst:73
msgid ""
"Godot will treat CSV files as translations by default. It will import them "
"and generate one or more compressed translation resource files next to it."
msgstr ""
"Godot 将 CSV 文件默认作为译文处理。它将导入该文件并在其旁边位置生成一个或多个"
"压缩过的翻译资源文件。"

#: ../../docs/getting_started/workflow/assets/importing_translations.rst:76
msgid ""
"Importing will also add the translation to the list of translations to load "
"when the game runs, specified in project.godot (or the project settings). "
"Godot allows loading and removing translations at runtime as well."
msgstr ""
"导入过程还会将翻译添加到在游戏运行时加载的翻译列表中, 在 project.godot文件 "
"(或项目设置) 中指定。Godot还允许在运行时加载和删除翻译。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:4
msgid "Importing 3D scenes"
msgstr "导入3D场景"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:7
#, fuzzy
msgid "Godot scene importer"
msgstr "Godot 场景导入器"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:9
msgid ""
"When dealing with 3D assets, Godot has a flexible and configurable importer."
msgstr "在处理 3D 资源时, Godot 有一个非常灵活且可配置的导入器。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:11
msgid ""
"Godot works with *scenes*. This means that the entire scene being worked on "
"in your favorite 3D DCC will be transferred as close as possible."
msgstr ""
"Godot 与 *场景* 一起工作。 这意味着用您最喜爱的3D软件制作的整个场景可以尽可能"
"完整地被导入。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:14
msgid "Godot supports the following 3D *scene file fomats*:"
msgstr "Godot支持以下3D *场景文件格式*:"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:16
msgid "DAE (COLLADA), which is currently the most mature workflow."
msgstr "DAE (Collada), 它是当前最成熟的工作流程。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:17
msgid ""
"GLTF 2.0. Both text and binary formats are supported. Godot has full support "
"for it, but the format is new and gaining traction."
msgstr ""
"GLTF 2.0。 支持文本格式和二进制格式。 Godot已经全力支持它，但格式是新的并且一"
"直受到引导。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:18
msgid ""
"OBJ (Wavefront) formats. It is also fully supported, but pretty limited (no "
"support for pivots, skeletons, etc)."
msgstr "OBJ (Wavefront) 格式。它也完全支持, 但相当有限 (不支持支点, 骨架等)。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:20
msgid ""
"Just copy the scene file together with the texture to the project "
"repository, and Godot will do a full import."
msgstr "只需将场景文件和纹理一起复制到项目存储库中，Godot 就可以完全导入。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:23
msgid "Why not FBX?"
msgstr "为什么不用 FBX？"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:25
msgid ""
"Most game engines use the FBX format for importing 3D scenes, which is "
"definitely one of the most standardized in the industry. However, this "
"format requires the use of a closed library from Autodesk, which is "
"distributed with more restrictive licensing terms than Godot."
msgstr ""
"大多数游戏引擎使用 FBX 格式导入 3D 场景，这绝对是业界最标准化的场景之一。 但"
"是，这种格式需要使用 Autodesk 的封闭库，这个封闭库分发的授权条款比 Godot 更具"
"有限制性。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:30
msgid ""
"The plan is, sometime in the future, to offer a binary plug-in using "
"GDNative."
msgstr "计划是，在未来的某个时候将使用GDNative提供二进制插件。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:33
msgid "Exporting DAE files from Maya and 3DS Max"
msgstr "从 maya 和 3DS Max 中输出 DAE 文件"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:35
msgid ""
"Autodesk added built-in COLLADA support to Maya and 3DS Max, but it's broken "
"by default and should not be used. The best way to export this format is by "
"using the `OpenCollada <https://github.com/KhronosGroup/OpenCOLLADA/wiki/"
"OpenCOLLADA-Tools>`__ plugins. They work well, although they are not always "
"up-to date with the latest version of the software."
msgstr ""
"Autodesk 为 Maya 和 3DS Max添加了内置的 collada 支持，但默认情况下已损坏，不"
"应使用。 导出这种格式的最好方法是使用`OpenCollada <https://github.com/"
"KhronosGroup/OpenCOLLADA/wiki/OpenCOLLADA-Tools>`__插件。 他们工作得很好，虽"
"然它们并不总是与最新版本的软件保持同步更新。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:43
msgid "Exporting DAE files from Blender"
msgstr "从 Blender 导出 DAE 文件"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:45
msgid ""
"Blender has built-in COLLADA support too, but it's also broken and should "
"not be used."
msgstr "Blender也有内置的COLLADA，但它也是损坏的，不应该使用。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:48
msgid ""
"Godot provides a `Python Plugin <https://github.com/godotengine/collada-"
"exporter>`__ that will do a much better job of exporting the scenes."
msgstr ""
"Godot 提供了一个 `Python插件 <https://github.com/godotengine/collada-"
"exporter>`__，可以更好地导出场景。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:53
msgid "Exporting ESCN files from Blender"
msgstr "从Blender导出ESCN文件"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:55
msgid ""
"The most powerful one, called `godot-blender-exporter <https://github.com/"
"godotengine/godot-blender-exporter>`__. It uses a .escn file, which is kind "
"of another name for a .tscn file (Godot scene file); it keeps as much "
"information as possible from a Blender scene."
msgstr ""
"最强大的一个，名为 `godot-blender-exporter <https://github.com/godotengine/"
"godot-blender-exporter>`__。 它使用.escn文件，它是.tscn文件(Godot场景文件)的"
"另一个名称，它从Blender场景中保留尽可能多的信息。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:60
msgid ""
"The ESCN exporter has a detailed `document <escn_exporter/index.html>`__ "
"describing its functionality and usage."
msgstr ""
"ESCN导出器有一个详细的 `document <escn_exporter / index.html>`__ ，描述了它的"
"功能和用法。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:64
msgid "Import workflows"
msgstr "导入工作流程"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:66
msgid ""
"Godot scene importer allows different workflows regarding how data is "
"imported. Depending on many options, it is possible to import a scene with:"
msgstr ""
"Godot 场景导入器支持对数据的导入方式进行不同的工作流程。 根据许多选项，可以通"
"过以下方式导入场景:"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:69
msgid ""
"External materials (default): Where each material is saved to a file "
"resource. Modifications to them are kept."
msgstr "外部材质(默认):每种材质保存到文件资源的位置。 可以对它们进行修改。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:70
msgid ""
"External meshes: Where each mesh is saved to a different file. Many users "
"prefer to deal with meshes directly."
msgstr "外部网格:每个网格被保存到不同的文件。 许多用户更喜欢直接处理网格。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:71
msgid ""
"External animations: Allowing saved animations to be modified and merged "
"when sources change."
msgstr "外部动画:允许修改已保存的动画并在源更改时进行合并。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:72
msgid ""
"External scenes: Save each of the root nodes of the imported scenes as a "
"separate scene."
msgstr "外部场景:将导入的场景的根节点分别保存为单独的场景。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:73
#, fuzzy
msgid "Single scene: A single scene file with everything built in."
msgstr "单场景:一个场景文件，内置所有内容。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:77
msgid ""
"As different developers have different needs, this import process is highly "
"customizable."
msgstr "由于不同的开发人员有不同的需求, 这个导入过程是高度可定制的。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:80
msgid "Import options"
msgstr "导入选项"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:82
msgid "The importer has several options, which will be discussed below:"
msgstr "导入器有几种选项，这将在下面讨论:"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:90
msgid "Root Type"
msgstr "根类型"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:92
msgid ""
"By default, the type of the root node in imported scenes is \"Spatial\", but "
"this can be modified."
msgstr "默认情况下，导入场景中根节点的类型为“Spatial”，但可以修改。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:95
msgid "Root Name"
msgstr "根名称"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:97
msgid "Allows setting a specific name to the generated root node."
msgstr "允许为生成的根节点设置特定的名称。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:100
msgid "Custom Script"
msgstr "自定义脚本"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:102
msgid ""
"A special script to process the whole scene after import can be provided. "
"This is great for post processing, changing materials, doing funny stuff "
"with the geometry etc."
msgstr ""
"可以提供导入后处理整个场景的特殊脚本。 这对于后期处理，更换材质，用几何体做些"
"有趣的事情等非常有用。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:106
msgid "Create a script like this:"
msgstr "创建如下的脚本:"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:117
msgid ""
"The ``post_import`` function takes the imported scene as argument (the "
"parameter is actually the root node of the scene). The scene that will "
"finally be used must be returned. It can be a different one."
msgstr ""
"导入后函数将导入的场景作为参数(参数实际上是场景的根节点)。 必须返回将最终使用"
"的场景。 它可以是不同的。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:122
#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:141
#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:196
#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:236
msgid "Storage"
msgstr "存储"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:124
msgid ""
"By default, Godot imports a single scene. This option allows specifying that "
"nodes below the root will each be a separate scene and instanced into the "
"imported one."
msgstr ""
"默认情况下，Godot导入一个单独的场景。 此选项允许指定根节点下方的节点将分别为"
"单独的场景并实例化为导入的节点。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:128
msgid ""
"Of course, instancing such imported scenes in other places manually works, "
"too."
msgstr "当然，在其他地方手动实例导入的场景也是可以的。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:135
msgid "Location"
msgstr "位置"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:137
msgid ""
"Godot supports materials in meshes or nodes. By default, materials will be "
"put on each node."
msgstr "Godot 支持网格或节点中的材质。 默认情况下，材质将放置在每个节点上。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:143
msgid ""
"Materials can be stored within the scene or in external files. By default, "
"they are stored in external files so editing them is possible. This is "
"because most 3D DCCs don't have the same material options as those present "
"in Godot."
msgstr ""
"材质可以存储在场景中或外部文件中。 默认情况下，它们存储在外部文件中，因此可以"
"进行编辑。 这是因为大多数 3D 数字创作软件没有与 Godot 中的材质相同的材质选"
"项。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:147
msgid ""
"When materials are built-in, they will be lost each time the source scene is "
"modified and re-imported."
msgstr "当材质内置时，每当源场景被修改并重新导入时，它们都会丢失。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:151
#, fuzzy
msgid "Keep On Reimport"
msgstr "保留重新导入"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:153
msgid ""
"Once materials are edited to use Godot features, the importer will keep the "
"edited ones and ignore the ones coming from the source scene. This option is "
"only present if materials are saved as files."
msgstr ""
"一旦材质被编辑为使用Godot功能，导入器将保留编辑过的材质并忽略来自源场景的材"
"质。 该选项仅在材质保存为文件时才存在。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:158
msgid "Meshes"
msgstr "网格"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:161
msgid "Compress"
msgstr "压缩"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:163
msgid ""
"Makes meshes use less precise numbers for multiple aspects of the mesh in "
"order to save space."
msgstr "使网格在网格的多个方面使用较少的精确数字以节省空间。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:176
msgid "These are:"
msgstr "这些是:"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:167
msgid ""
"Transform Matrix (Location, rotation, and scale)             : 32-bit float "
"to 16-bit signed integer."
msgstr "变换矩阵(位置，旋转和缩放):32位浮点数到16位有符号整数。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:168
msgid ""
"Vertices                                                     : 32-bit float "
"to 16-bit signed integer."
msgstr "顶点:32 位浮点数到16位有符号整数。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:169
msgid ""
"Normals                                                      : 32-bit float "
"to 32-bit unsigned integer."
msgstr "法线:32 位浮点数到32位无符号整数。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:170
msgid ""
"Tangents                                                     : 32-bit float "
"to 32-bit unsigned integer."
msgstr "切线:32 位浮点数到32位无符号整数。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:171
msgid ""
"Vertex Colors                                                : 32-bit float "
"to 32-bit unsigned integer."
msgstr "顶点色:32 位浮点数到32位无符号整数。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:172
msgid ""
"UV                                                           : 32-bit float "
"to 32-bit unsigned integer."
msgstr "UV:32 位浮点数到32位无符号整数。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:173
msgid ""
"UV2                                                          : 32-bit float "
"to 32-bit unsigned integer."
msgstr "UV2:32 位浮点数到32位无符号整数。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:174
msgid ""
"Vertex weights                                               : 32-bit float "
"to 16-bit unsigned integer."
msgstr "顶点权重:32 位浮点数到32位无符号整数。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:175
msgid ""
"Armature bones                                               : 32-bit float "
"to 16-bit unsigned integer."
msgstr "骨架骨骼:32 位浮点数到16位无符号整数。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:176
msgid ""
"Array index                                                  : 32-bit or 16-"
"bit unsigned integer based on how many elements there are."
msgstr "数组索引: 基于具体有多少元素的32位或16位无符号整数。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:180
msgid "Additional info:"
msgstr "附加信息:"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:179
msgid ""
"UV2 = The second UV channel for detail textures and baked lightmap textures."
msgstr "UV2 = 用于细节纹理和烘焙光照纹理的第二个 UV 通道。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:180
msgid ""
"Array index = An array of numbers that number each element of the arrays "
"above; i.e. they number the vertices and normals."
msgstr ""
"数组索引 = 一个数字数组, 它为上面数组的每个元素编号;即, 他们的顶点和法线的数"
"量。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:182
msgid ""
"In some cases, this might lead to loss of precision, so disabling this "
"option may be needed. For instance, if a mesh is very big or there are "
"multiple meshes being imported that cover a large area, compressing the "
"import of this mesh(es) may lead to gaps in geometry or vertices not being "
"exactly where they should be."
msgstr ""
"在某些情况下，这可能会导致精度损失，因此可能需要禁用此选项。 例如，如果网格非"
"常大或导入了多个覆盖大面积的网格，则压缩此网格的导入可能会导致几何图形或顶点"
"间的间隙不在他们应在的位置。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:188
msgid "Ensure Tangents"
msgstr "计算的切线"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:190
msgid ""
"If textures with normal mapping are to be used, meshes need to have tangent "
"arrays. This option ensures that these are generated if not present in the "
"source scene. Godot uses Mikktspace for this, but it's always better to have "
"them generated in the exporter."
msgstr ""
"如果要使用正常贴图的纹理，网格需要有切线阵列。 此选项可确保在源场景中不存在时"
"生成这些阵列。 Godot 使用 Mikktspace 来做这件事，但最好让它们在导出器中生成。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:198
msgid ""
"Meshes can be stored in separate files (resources) instead of built-in. This "
"does not have much practical use unless one wants to build objects with them "
"directly."
msgstr ""
"网格可以存储在单独的文件(资源)中，而不是内置的。 除非有人想直接用它们建立对"
"象，否则这没有多少实际用途。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:201
msgid ""
"This option is provided to help those who prefer working directly with "
"meshes instead of scenes."
msgstr "此选项用于帮助那些喜欢直接使用网格而不是场景的人。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:205
msgid "External Files"
msgstr "外部文件"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:207
msgid ""
"Generated meshes and materials can be optionally stored in a subdirectory "
"with the name of the scene."
msgstr "生成的网格和材质可以选择存储在具有场景名称的子目录中。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:211
#, fuzzy
msgid "Animation options"
msgstr "动画选项"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:213
msgid ""
"Godot provides many options regarding how animation data is dealt with. Some "
"exporters (such as Blender) can generate many animations in a single file. "
"Others, such as 3DS Max or Maya, need many animations put into the same "
"timeline or, at worst, put each animation in a separate file."
msgstr ""
"Godot提供了许多有关如何处理动画数据的选项。 一些导出器(如Blender)可以在一个文"
"件中生成许多动画。 其他的，如3DS Max 或 Maya，需要将许多动画放入同一时间线，"
"或者最糟糕的情况是将每个动画放在单独的文件中。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:220
msgid "Import of animations is enabled by default."
msgstr "默认情况下启用动画导入。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:223
msgid "FPS"
msgstr "帧数"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:225
msgid ""
"Most 3D export formats store animation timeline in seconds instead of "
"frames. To ensure animations are imported as faithfully as possible, please "
"specify the frames per second used to edit them. Failing to do this may "
"result in shaky animations."
msgstr ""
"大多数 3D 导出格式以秒为单位存储的动画时间线，而不是帧。 为了确保尽可能忠实地"
"导入动画，请指定用于编辑它们的每秒帧数。 未能这样做可能会导致极小的抖动。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:230
msgid "Filter Script"
msgstr "过滤器脚本"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:232
msgid ""
"It is possible to specify a filter script in a special syntax to decide "
"which tracks from which animations should be kept. (@TODO this needs "
"documentation)"
msgstr ""
"可以用特殊的语法指定过滤器脚本, 以决定哪些轨道应保留动画。(@TODO 这需要文档)"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:238
msgid ""
"By default, animations are saved as built-in. It is possible to save them to "
"a file instead. This allows adding custom tracks to the animations and "
"keeping them after a reimport."
msgstr ""
"默认情况下，动画保存为内置。 可以将它们保存到文件中。 这允许向动画添加自定义"
"轨道并在重新导入后保留它们。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:242
msgid "Optimizer"
msgstr "优化"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:244
msgid ""
"When animations are imported, an optimizer is run, which reduces the size of "
"the animation considerably. In general, this should always be turned on "
"unless you suspect that an animation might be broken due to it being enabled."
msgstr ""
"导入动画时，会运行优化程序，从而大大减少动画的大小。 一般情况下，除非您怀疑动"
"画可能因启用而被破坏，否则应始终启用此功能。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:248
msgid "Clips"
msgstr "片段"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:250
msgid ""
"It is possible to specify multiple animations from a single timeline as "
"clips. Specify from which frame to which frame each clip must be taken (and, "
"of course, don't forget to specify the FPS option above)."
msgstr ""
"可以将单个时间线中的多个动画指定为片段。只需指定从哪帧到哪帧(当然，不要忘记指"
"定上面的FPS选项)。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:254
msgid "Scene inheritance"
msgstr "场景继承"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:256
msgid ""
"In many cases, it may be desired to make modifications to the imported "
"scene. By default, this is not possible because if the source asset changes "
"(source .dae, .gltf, .obj file re-exported from 3D modelling app), Godot "
"will re-import the whole scene."
msgstr ""
"在许多情况下，可能希望对导入的场景进行修改。 默认情况下，这是不可能的，因为如"
"果源资源发生变化(从3D建模应用程序重新导出源.dae，.gltf，.obj文件)，Godot将重"
"新导入整个场景。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:259
msgid ""
"It is possible, however, to make local modifications by using *Scene "
"Inheritance*. Try to open the imported scene and the following dialog will "
"appear:"
msgstr ""
"但是，可以使用 *Scene Inheritance* 进行本地修改。 试着打开导入的场景，会出现"
"下面的对话框:"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:264
msgid "In inherited scenes, the only limitations for modifications are:"
msgstr "在继承场景中，修改的唯一限制是:"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:266
msgid "Nodes can't be removed (but can be added anywhere)."
msgstr "无法删除节点 (但可以在任何位置添加)。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:267
msgid ""
"Sub-Resources can't be edited (save them externally as described above for "
"this)"
msgstr "子资源无法编辑(如上所述它们将保存在外部)"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:269
msgid "Other than that, everything is allowed!"
msgstr "除了这些, 一切都是允许的!"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:272
msgid "Import hints"
msgstr "导入提示"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:274
msgid ""
"Many times, when editing a scene, there are common tasks that need to be "
"done after exporting:"
msgstr "很多时候, 在编辑场景时, 导出后需要完成一些常见的任务:"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:276
msgid "Adding collision detection to objects"
msgstr "向对象添加碰撞检测"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:277
msgid "Setting objects as navigation meshes"
msgstr "将对象设置为导航网格"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:278
msgid ""
"Deleting nodes that are not used in the game engine (like specific lights "
"used for modelling)"
msgstr "删除游戏引擎中未使用的节点 (如用于建模的特定光源)"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:280
msgid ""
"To simplify this workflow, Godot offers a few suffixes that can be added to "
"the names of the objects in your 3D modelling software. When imported, Godot "
"will detect them and perform actions automatically:"
msgstr ""
"为了简化这一工作流程，Godot 提供了一些后缀，可以添加到3D建模软件中的对象名称"
"中。 当输入时，Godot会自动检测它们并执行操作:"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:285
msgid "Remove nodes (-noimp)"
msgstr "删除节点 (-noimp)"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:287
msgid ""
"Node names that have this suffix will be removed at import time, no matter "
"what their type is. They will not appear in the imported scene."
msgstr ""
"具有此后缀的节点名称将在导入时被删除, 不管它们的类型是什么。它们不会出现在导"
"入的场景中。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:291
msgid "Create collisions (-col, -colonly, -convcolonly)"
msgstr "创建碰撞体 (-colonly,-convcolonly)"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:293
msgid ""
"Option \"-col\" will work only for Mesh nodes. If it is detected, a child "
"static collision node will be added, using the same geometry as the mesh."
msgstr ""
"选项“-col”只能用于 Mesh 节点。 如果检测到，则会添加子静态碰撞节点，使用与网格"
"相同的几何体。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:296
msgid ""
"However, it is often the case that the visual geometry is too complex or too "
"un-smooth for collisions, which ends up not working well."
msgstr ""
"然而，通常是可视几何体对于碰撞来说太复杂或太不平滑，这最终不能很好地工作。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:299
msgid ""
"To solve this, the \"-colonly\" modifier exists, which will remove the mesh "
"upon import and create a :ref:`class_staticbody` collision instead. This "
"helps the visual mesh and actual collision to be separated."
msgstr ""
"为了解决这个问题, \"-colonly\" 修饰符存在, 它将在导入时删除网格, 并创建一个 :"
"ref:\"class_staticbody\" 碰撞体。这有助于将可视的网格和实际碰撞体分开。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:303
msgid ""
"Option \"-convcolonly\" will create a :ref:`class_convexpolygonshape` "
"instead of a :ref:`class_concavepolygonshape`."
msgstr ""
"选项“-convcolonly”将创建 :ref:`class_convexpolygonshape`而不是 :ref:"
"`class_concavepolygonshape`。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:305
msgid ""
"Option \"-colonly\" can also be used with Blender's empty objects. On "
"import, it will create a :ref:`class_staticbody` with a collision node as a "
"child. The collision node will have one of a number of predefined shapes, "
"depending on Blender's empty draw type:"
msgstr ""
"选项“--colonly”也可以与Blender的空物件一起使用。 在导入时，它会创建一个带有碰"
"撞节点的 :ref:`class_staticbody`作为子节点。 Collision节点将有一个预定义的形"
"状，具体取决于Blender的空物体类型:"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:312
msgid "Single arrow will create a :ref:`class_rayshape`"
msgstr "单箭头将创建 :ref:`class_rayshape '"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:313
msgid "Cube will create a :ref:`class_boxshape`"
msgstr "方块将创建 :ref:`class_boxshape`"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:314
msgid "Image will create a :ref:`class_planeshape`"
msgstr "图像将创建 :ref:`class_planeshape '"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:315
msgid ""
"Sphere (and the others not listed) will create a :ref:`class_sphereshape`"
msgstr "球体 (和其他未列出的) 将创建 :ref:`class_sphereshape '"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:317
msgid ""
"For better visibility in Blender's editor, the user can set \"X-Ray\" option "
"on collision empties and set some distinct color for them in User "
"Preferences / Themes / 3D View / Empty."
msgstr ""
"为了提高Blender编辑器的可见性，用户可以在碰撞体上设置“X-Ray”选项，并在用户首"
"选项/主题/ 3D视图/空物体中为它们设置不同的颜色。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:321
msgid "Create navigation (-navmesh)"
msgstr "创建导航(-navmesh)"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:323
msgid ""
"A mesh node with this suffix will be converted to a navigation mesh. "
"Original Mesh node will be removed."
msgstr "具有此后缀的网格节点将被转换为导航网格。原始网格节点将被删除。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:327
msgid "Rigid Body (-rigid)"
msgstr "刚体 (-rigid)"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:329
msgid "Creates a rigid body from this mesh."
msgstr "从这个网格中创建一个刚体。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:332
msgid "Animation loop (-loop, -cycle)"
msgstr "动画循环"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:334
msgid ""
"Animation clips in the COLLADA document that start or end with the token "
"\"loop\" or \"cycle\" will be imported as a Godot Animation with the loop "
"flag set. This is case-sensitive and does not require a hyphen."
msgstr ""
"COLLADA文档中以令牌“循环”或“循环”开头或结尾的动画片段将作为Godot动画导入，并"
"设置循环标志。这是区分大小写的，不需要连字符。"

#: ../../docs/getting_started/workflow/assets/importing_scenes.rst:338
msgid ""
"In Blender, this requires using the NLA Editor and naming the Action with "
"the \"loop\" or \"cycle\" prefix or suffix."
msgstr ""
"在Blender中，这需要使用NLA编辑器并使用“loop”或“cycle”前缀或后缀命名Action。"

#: ../../docs/getting_started/workflow/export/index.rst:2
msgid "Export"
msgstr "导出"

#: ../../docs/getting_started/workflow/export/exporting_projects.rst:4
msgid "Exporting projects"
msgstr "导出项目"

#: ../../docs/getting_started/workflow/export/exporting_projects.rst:9
msgid "Why export?"
msgstr "为什么要导出？"

#: ../../docs/getting_started/workflow/export/exporting_projects.rst:11
msgid ""
"Originally, Godot did not have any means to export projects. The developers "
"would compile the proper binaries and build the packages for each platform "
"manually."
msgstr ""
"起初，Godot 没有任何导出项目的方法。 开发人员将编译适用的二进制文件并手动为每"
"个平台构建软件包。"

#: ../../docs/getting_started/workflow/export/exporting_projects.rst:15
msgid ""
"When more developers (and even non-programmers) started using it, and when "
"our company started taking more projects at the same time, it became evident "
"that this was a bottleneck."
msgstr ""
"当更多的开发人员(甚至非程序员)开始使用它，并且当我们公司开始同时进行更多项目"
"时，很明显这是一个瓶颈。"

#: ../../docs/getting_started/workflow/export/exporting_projects.rst:20
msgid "On PC"
msgstr "在 PC 上"

#: ../../docs/getting_started/workflow/export/exporting_projects.rst:22
msgid ""
"Distributing a game project on PC with Godot is rather easy. Drop the Godot "
"binary in the same directory as the ``project.godot`` file, then compress "
"the project directory and you are done."
msgstr ""
"用Godot在PC上分发游戏项目相当容易。 只需将 godot.exe(或godot)二进制文件放在"
"与 engine.cfg 文件相同的位置，然后将其压缩并完成。 这可以被利用来制作自定义安"
"装程序。"

#: ../../docs/getting_started/workflow/export/exporting_projects.rst:26
msgid ""
"It sounds simple, but there are probably a few reasons why the developer may "
"not want to do this. The first one is that it may not be desirable to "
"distribute loads of files. Some developers may not like curious users "
"peeking at how the game was made, others may find it inelegant, and so on. "
"Another reason is that the developer might prefer a specially-compiled "
"binary, which is smaller in size, more optimized and does not include tools "
"like the editor and debugger."
msgstr ""
"这听起来很简单，但开发人员可能不想这样做的原因可能有几个。 第一个原因是分发大"
"量文件可能不够理想。 一些开发人员可能不喜欢好奇的用户偷看游戏的制作方式，有些"
"开发人员可能会觉得它不够好看等等。"

#: ../../docs/getting_started/workflow/export/exporting_projects.rst:34
msgid ""
"Finally, Godot has a simple but efficient system for creating DLCs as extra "
"package files."
msgstr "最后，Godot 有一个简单而有效的系统来创建 DLC 作为额外的软件包文件。"

#: ../../docs/getting_started/workflow/export/exporting_projects.rst:38
msgid "On mobile"
msgstr "在移动端"

#: ../../docs/getting_started/workflow/export/exporting_projects.rst:40
msgid ""
"The same scenario on mobile platforms is a little worse. To distribute a "
"project on those devices, a binary for each of those platforms is built, "
"then added to a native project together with the game data."
msgstr ""
"移动设备中的相同情况会更糟糕。 要在这些设备中分发项目，将为每个平台构建一个二"
"进制文件，然后将其与游戏数据一起添加到本地项目中。"

#: ../../docs/getting_started/workflow/export/exporting_projects.rst:45
msgid ""
"This can be troublesome because it means that the developer must be "
"familiarized with the SDK of each platform before even being able to export. "
"While learning each SDK is always encouraged, it can be frustrating to be "
"forced to do it at an undesired time."
msgstr ""
"这可能很麻烦，因为这意味着开发人员在能够导出前必须熟悉每个平台的SDK。 尽管总"
"是鼓励学习每个SDK，但在不希望的时间被迫做到这一点令人沮丧。"

#: ../../docs/getting_started/workflow/export/exporting_projects.rst:50
msgid ""
"There is also another problem with this approach: different devices prefer "
"some data in different formats to run. The main example of this is texture "
"compression. All PC hardware uses S3TC (BC) compression and that has been "
"standardized for more than a decade, but mobile devices use different "
"formats for texture compression, such as PVRTC (iOS) or ETC (Android)."
msgstr ""
"这种方法还有另一个问题。 不同的设备偏好一些不同格式的数据来运行。 这个主要的"
"示例是纹理压缩。 所有PC硬件都使用 S3TC(BC)压缩，并且已经标准化了十多年，但移"
"动设备使用不同的格式进行纹理压缩，例如PVRCT(iOS)或ETC(Android)。"

#: ../../docs/getting_started/workflow/export/exporting_projects.rst:58
msgid "Export menu"
msgstr "导出菜单"

#: ../../docs/getting_started/workflow/export/exporting_projects.rst:60
msgid ""
"After many attempts at different export workflows, the current one has "
"proven to work the best. At the time of this writing, not all platforms are "
"supported yet, but the supported platforms continue to grow."
msgstr ""
"经过多次尝试不同的导出工作流程后，目前的工作流程已被证明是最好的。 在撰写本文"
"时，并不是所有平台都支持，但受支持的平台仍在继续增长。"

#: ../../docs/getting_started/workflow/export/exporting_projects.rst:64
msgid "To open the export menu, click the **Export** button:"
msgstr "要打开 \"导出\" 菜单, 只需单击 \"导出\" 按钮:"

#: ../../docs/getting_started/workflow/export/exporting_projects.rst:68
msgid ""
"The export menu will open. However, it will be completely empty. This is "
"because we need to add an export preset."
msgstr "导出菜单将打开，但它完全是空的。"

#: ../../docs/getting_started/workflow/export/exporting_projects.rst:73
msgid ""
"To create an export preset, click the **Add…** button at the top of the "
"export menu. This will open a drop-down list of platforms to choose from for "
"an export preset."
msgstr ""
"这是因为我们需要添加一个导出预设。 要做到这一点，请点击导出菜单顶部的“添"
"加...”按钮。 这将打开一个平台的下拉列表，以从导出预设中进行选择。"

#: ../../docs/getting_started/workflow/export/exporting_projects.rst:79
msgid ""
"The default options are often enough to export, so tweaking them is usually "
"not necessary. However, many platforms require additional tools (SDKs) to be "
"installed to be able to export. Additionally, Godot needs export templates "
"installed to create packages. The export menu will complain when something "
"is missing and will not allow the user to export for that platform until "
"they resolve it:"
msgstr ""
"默认选项通常足以导出，因此调整它们不是必需的，但可以提供额外的控制。 但是，许"
"多平台需要安装额外的工具(SDK)才能导出。 此外，Godot需要安装导出模板来创建"
"包。 导出菜单会在缺少某些内容时给出提示，并且不会允许用户在解决该问题之前导出"
"该平台:"

#: ../../docs/getting_started/workflow/export/exporting_projects.rst:88
msgid ""
"At that time, the user is expected to come back to the documentation and "
"follow instructions on how to properly set up that platform."
msgstr "那时，用户需要回到文档并按照说明如何正确设置该平台。"

#: ../../docs/getting_started/workflow/export/exporting_projects.rst:94
msgid ""
"Apart from setting up the platform, the export templates must be installed "
"to be able to export projects. They can be obtained as a TPZ file (which is "
"a renamed ZIP archive) from the `download page of the website <https://www."
"godotengine.org/download>`_."
msgstr ""
"除了设置平台之外，还必须安装导出模板才能导出项目。 它们可以从 `网站 <https://"
"www.godotengine.org/download>`_ 的下载页面以.tpz(更名为.zip)文件的形式获得。"

#: ../../docs/getting_started/workflow/export/exporting_projects.rst:99
msgid ""
"Once downloaded, they can be installed using the **Install Export "
"Templates** option in the editor:"
msgstr "下载后，可以使用编辑器中的“安装导出模板”选项进行安装:"

#: ../../docs/getting_started/workflow/export/exporting_projects.rst:105
msgid "Export mode"
msgstr "导出模式"

#: ../../docs/getting_started/workflow/export/exporting_projects.rst:107
msgid ""
"When exporting, Godot makes a list of all the files to export and then "
"creates the package. There are 3 different modes for exporting:"
msgstr "导出时，Godot会列出所有要导出的文件，然后创建包。 有3种不同的导出模式:"

#: ../../docs/getting_started/workflow/export/exporting_projects.rst:110
msgid "Export every single file in the project"
msgstr "导出项目中的每一个文件"

#: ../../docs/getting_started/workflow/export/exporting_projects.rst:111
msgid "Export only resources (+ custom filter), this is the default."
msgstr "仅导出资源 (+ 自定义过滤器), 这是默认值。"

#: ../../docs/getting_started/workflow/export/exporting_projects.rst:112
msgid "Export only selected resources (+ custom filter)"
msgstr "仅导出所选资源 (+ 自定义过滤器)"

#: ../../docs/getting_started/workflow/export/exporting_projects.rst:116
msgid ""
"**Export every single file** - This mode exports every single file in the "
"project. This is good to test if something is being forgotten, but "
"developers often have a lot of unrelated stuff around in the project "
"directory, which makes it a bad idea."
msgstr ""
"**导出每个单个文件** - 此模式导出项目中的每个单个文件。 这对于测试是否有什么"
"被遗忘很有用，但是开发人员在开发者目录中通常会有很多不相关的东西，这使得它不"
"是一个好主意。"

#: ../../docs/getting_started/workflow/export/exporting_projects.rst:121
msgid ""
"**Export only resources** - Only resources are exported. For most projects, "
"this is enough. However many developers like to use custom datafiles in "
"their games. To compensate for this, filters can be added for extra "
"extensions (for instance, ``*.txt,*.csv``)."
msgstr ""
"**仅导出资源** - 仅导出资源。 对于大多数项目来说，这就够了。 然而，许多开发人"
"员喜欢在他们的游戏中使用自定义数据文件。 为了弥补这一点，可以为额外的扩展名添"
"加过滤器(如* .txt，*。csv等)。"

#: ../../docs/getting_started/workflow/export/exporting_projects.rst:126
msgid ""
"**Export only selected resources** - Only select resources from a list are "
"exported. This is probably overkill for most projects, but in some cases it "
"is justified (usually huge projects). This mode offers total control of what "
"is exported. Individual resources can be selected and dependency detection "
"is performed to ensure that everything needed is added."
msgstr ""
"**仅导出选定资源** - 仅导出列表中的资源。 这对大多数项目来说可能是过度的，但"
"在某些情况下它是合理的(通常是巨大的项目)。 该模式提供对输出内容的完全控制。 "
"可以选择单个资源并执行依赖性检测以确保添加所需的所有内容。 此外，此模式允许"
"将“场景”和依赖关系“捆绑”到单个文件中，这对于发布到光碟上的游戏非常有用。"

#: ../../docs/getting_started/workflow/export/exporting_projects.rst:136
msgid "Exporting from the command line"
msgstr "从命令行导出"

#: ../../docs/getting_started/workflow/export/exporting_projects.rst:138
msgid ""
"In production, it is useful to automate builds, and Godot supports this with "
"the ``--export`` and ``--export-debug`` command line parameters. Exporting "
"from the command line still requires an export preset to define the export "
"parameters. A basic invocation of the command would be:"
msgstr ""
"在生产中，自动化构建很有用，Godot使用 ``--export`` 和 ``--export-debug`` 命令"
"行参数来支持它。 从命令行导出仍需要导出预设来定义导出参数。 该命令的基本调用"
"将是:"

#: ../../docs/getting_started/workflow/export/exporting_projects.rst:147
msgid ""
"This will export to ``some_name.exe``, assuming there is a preset called "
"\"Windows Desktop\" and the template can be found. The output path is "
"relative to the project path or absolute; it does not respect the directory "
"the command was invoked from."
msgstr ""
"假设有一个名为“Windows Desktop”的预设，并且可以找到该模板，它将导出"
"到“some_name.exe”。 输出路径相对于项目路径或绝对路径。 它不遵从命令被调用的目"
"录。"

#: ../../docs/getting_started/workflow/export/exporting_projects.rst:152
msgid ""
"You can also configure it to export only the PCK or ZIP file (allowing a "
"single export to be used with multiple Godot executables). This takes place "
"if:"
msgstr ""
"您也可以将其配置为仅导出.pck或.zip文件(允许将单个导出与多个 Godot 可执行文件"
"一起使用)。 这发生在以下情况下:"

#: ../../docs/getting_started/workflow/export/exporting_projects.rst:156
msgid "the export preset is not marked as runnable,"
msgstr "导出预设未标记为可执行的"

#: ../../docs/getting_started/workflow/export/exporting_projects.rst:157
msgid "the target name ends with ``.pck`` or ``.zip``."
msgstr "目标名称以 ``.pck`` 或 ``.zip``结尾。"

#: ../../docs/getting_started/workflow/export/exporting_projects.rst:159
msgid ""
"It is often useful to combine the ``--export`` flag with the ``--path`` "
"flag, and to create a dedicated export preset for automated export:"
msgstr ""
"将 ``--export`` 标志与 ``--path`` 标志组合起来通常很有用，并为自动导出创建专"
"用的导出预设:"

#: ../../docs/getting_started/workflow/export/exporting_pcks.rst:4
msgid "Exporting packs, patches, and mods"
msgstr "导出包，修补程序和mod"

#: ../../docs/getting_started/workflow/export/exporting_pcks.rst:7
msgid "Use cases"
msgstr "用例"

#: ../../docs/getting_started/workflow/export/exporting_pcks.rst:9
msgid ""
"Oftentimes one would like to add functionality to one's game after it has "
"been deployed."
msgstr "通常，人们希望在部署游戏后为其添加功能。"

#: ../../docs/getting_started/workflow/export/exporting_pcks.rst:12
msgid "Examples of this include..."
msgstr "这方面的示例包括......"

#: ../../docs/getting_started/workflow/export/exporting_pcks.rst:14
msgid ""
"Downloadable Content: the ability to add features and content to one's game."
msgstr "可下载内容:为一个游戏添加功能和内容的功能。"

#: ../../docs/getting_started/workflow/export/exporting_pcks.rst:15
msgid "Patches: the ability to fix a bug that is present in a shipped product."
msgstr "修补程序:修复已发布产品中存在的错误的功能。"

#: ../../docs/getting_started/workflow/export/exporting_pcks.rst:16
msgid "Mods: grant other people the ability to create content for one's game."
msgstr "Mods:授予其他人为一个人的游戏创建内容的能力。"

#: ../../docs/getting_started/workflow/export/exporting_pcks.rst:18
msgid ""
"These tools help developers to extend their development beyond the initial "
"release."
msgstr "这些工具可帮助开发人员将其开发扩展到初始版本之外。"

#: ../../docs/getting_started/workflow/export/exporting_pcks.rst:22
msgid "Overview of PCK files"
msgstr "调试工具概述"

#: ../../docs/getting_started/workflow/export/exporting_pcks.rst:24
msgid ""
"Godot enables this via a feature called **resource packs** (PCK files, with "
"extension ``.pck``)."
msgstr ""
"Godot通过名为 **资源包** (PCK文件，扩展名为`.pck``)的功能实现了这一点。"

#: ../../docs/getting_started/workflow/export/exporting_pcks.rst:27
msgid "**Advantages:**"
msgstr "**优势:**"

#: ../../docs/getting_started/workflow/export/exporting_pcks.rst:29
msgid "incremental updates/patches"
msgstr "增量更新/补丁"

#: ../../docs/getting_started/workflow/export/exporting_pcks.rst:30
msgid "offer DLCs"
msgstr "提供DLC"

#: ../../docs/getting_started/workflow/export/exporting_pcks.rst:31
msgid "offer mod support"
msgstr "提供mod支持"

#: ../../docs/getting_started/workflow/export/exporting_pcks.rst:32
msgid "no source code disclosure needed for mods"
msgstr "mods不需要公开源代码"

#: ../../docs/getting_started/workflow/export/exporting_pcks.rst:33
msgid "more modular project structure"
msgstr "更模块化的项目结构"

#: ../../docs/getting_started/workflow/export/exporting_pcks.rst:34
msgid "users don’t have to replace the entire game"
msgstr "用户无需替换整个游戏"

#: ../../docs/getting_started/workflow/export/exporting_pcks.rst:36
msgid ""
"The first part of using them involves exporting and delivering the project "
"to players. Then, when one wants to add functionality or content later on, "
"they just deliver the updates via PCK files to the users."
msgstr ""
"使用它们的第一部分涉及将项目导出并交付给游戏角色。然后，当想要稍后添加功能或"
"内容时，他们只是通过PCK文件将更新传递给用户。"

#: ../../docs/getting_started/workflow/export/exporting_pcks.rst:40
msgid "PCK files usually contain, but are not limited to:"
msgstr "PCK文件通常包含但不限于:"

#: ../../docs/getting_started/workflow/export/exporting_pcks.rst:42
msgid "scripts"
msgstr "脚本"

#: ../../docs/getting_started/workflow/export/exporting_pcks.rst:43
msgid "scenes"
msgstr "场景"

#: ../../docs/getting_started/workflow/export/exporting_pcks.rst:44
msgid "shaders"
msgstr "着色器"

#: ../../docs/getting_started/workflow/export/exporting_pcks.rst:45
msgid "models"
msgstr "模型"

#: ../../docs/getting_started/workflow/export/exporting_pcks.rst:46
msgid "textures"
msgstr "纹理"

#: ../../docs/getting_started/workflow/export/exporting_pcks.rst:47
msgid "sound effects"
msgstr "声效"

#: ../../docs/getting_started/workflow/export/exporting_pcks.rst:48
msgid "music"
msgstr "音乐"

#: ../../docs/getting_started/workflow/export/exporting_pcks.rst:49
msgid "any other asset suitable for import into the game"
msgstr "适合进口到游戏中的任何其他资源"

#: ../../docs/getting_started/workflow/export/exporting_pcks.rst:51
msgid ""
"The PCK files can even be an entirely different Godot project, which the "
"original game loads in at runtime."
msgstr "PCK文件甚至可以是一个完全不同的Godot项目，原始游戏在运行时加载。"

#: ../../docs/getting_started/workflow/export/exporting_pcks.rst:55
msgid "Generating PCK files"
msgstr "生成PCK文件"

#: ../../docs/getting_started/workflow/export/exporting_pcks.rst:57
msgid ""
"In order to pack all resources of a project into a PCK file open the project "
"and go to Project/Export and click on “Export PCK/Zip”. Also make sure to "
"have an export template selected while doing so."
msgstr ""
"为了将项目的所有资源打包到PCK文件中，打开项目并转到Project / Export并单"
"击“Export PCK / Zip”。还要确保在执行此操作时选择了导出模板。"

#: ../../docs/getting_started/workflow/export/exporting_pcks.rst:63
msgid ""
"Another method would be to :ref:`export from the command line "
"<doc_command_line_tutorial_exporting>`. If the output file ends with a PCK "
"or ZIP file extension, then the export process will build that type of file "
"for the chosen platform."
msgstr ""
"另一种方法是 :ref:`从命令行导出<doc_command_line_tutorial_exporting>`。如果输"
"出文件以PCK或ZIP文件扩展名结尾，则导出过程将为所选平台构建该类型的文件。"

#: ../../docs/getting_started/workflow/export/exporting_pcks.rst:69
msgid ""
"If one wishes to support mods for their game, they will need their users to "
"create similarly exported files. Assuming the original game expects a "
"certain structure for the PCK's resources and/or a certain interface for its "
"scripts, then either..."
msgstr ""
"如果有人希望为他们的游戏支持mod，他们将需要他们的用户创建类似的导出文件。假设"
"原始游戏需要PCK资源的某种结构和/或其脚本的某个界面，那么要么......"

#: ../../docs/getting_started/workflow/export/exporting_pcks.rst:74
msgid ""
"The developer must publicize documentation of these expected structures/ "
"interfaces, expect modders to install Godot Engine, and then also expect "
"those modders to conform to the documentation's defined API when building "
"mod content for the game (so that it will work). Users would then use "
"Godot's built in exporting tools to create a PCK file, as detailed above."
msgstr ""
"开发人员必须公开这些预期结构/接口的文档，期望modders安装Godot Engine，然后还"
"期望这些modder在为游戏构建mod内容时符合文档定义的API(以便它可以工作)。然后，"
"用户将使用Godot的内置导出工具来创建PCK文件，如上所述。"

#: ../../docs/getting_started/workflow/export/exporting_pcks.rst:80
#, fuzzy
msgid ""
"The developer uses Godot to build a GUI tool for adding their exact API "
"content to a project. This Godot tool must either run on a tools-enabled "
"build of the engine or have access to one (distributed alongside or perhaps "
"in the original game's files). The tool can then use the Godot executable to "
"export a PCK file from the command line with :ref:`OS.execute() "
"<class_OS_method_execute>`. It makes the most sense for the game to not use "
"a tool-build though (for security) and for the modding tools to *do* use a "
"tool-enabled engine build."
msgstr ""
"开发人员使用Godot构建GUI工具，将其确切的API内容添加到项目中。这个Godot工具必"
"须在启用工具的引擎构建上运行，或者可以访问一个(分布在原始游戏的文件旁边或者可"
"能在原始游戏的文件中)。然后，该工具可以使用Godot可执行文件从命令行导出PCK文"
"件 :ref:`OS.execute() <class_OS_method_execute>`。虽然(为了安全性)而不使用工"
"具构建，并且使用支持工具的引擎构建的模型工具，最有意义的是游戏。"

#: ../../docs/getting_started/workflow/export/exporting_pcks.rst:90
msgid "Opening PCK files at runtime"
msgstr "在运行时打开PCK文件"

#: ../../docs/getting_started/workflow/export/exporting_pcks.rst:92
msgid ""
"To import a PCK file, one uses a one-liner. Keep in mind, there is no error "
"or exception if the import fails. Instead, one might have to create some "
"validation code as a layer on top. The following example expects a “mod.pck” "
"file in the directory of the games executable. The PCK file contains a "
"“mod_scene.tscn” test scene in its root."
msgstr ""
"要导入PCK文件，可以使用单行程序。请记住，如果导入失败，则不会出现错误或异常。"
"相反，可能必须在顶部创建一些验证代码作为层。以下示例期望游戏可执行文件目录中"
"的“mod.pck”文件。 PCK文件的根目录中包含“mod_scene.tscn”测试场景。"

#: ../../docs/getting_started/workflow/export/exporting_pcks.rst:117
msgid ""
"If you import a file with the same file path/name as one you already have in "
"your project, the imported one will replace it. This is something to watch "
"out for when creating DLC or mods (solved easily with a tool isolating mods "
"to a specific mods subfolder). However, it is also a way of creating patches "
"for one's own game. A PCK file of this kind can fix the content of a "
"previously loaded PCK."
msgstr ""
"如果导入的文件具有与项目中已有的文件路径/名称相同的文件路径/名称，则导入的文"
"件将替换它。在创建DLC或mod时需要注意这一点(使用工具将mods隔离到特定mods子文件"
"夹时很容易解决)。但是，它也是一种为自己的游戏创建补丁的方法。这种PCK文件可以"
"修复先前加载的PCK的内容。"

#: ../../docs/getting_started/workflow/export/exporting_pcks.rst:126
msgid ""
"This tutorial should illustrate how easy adding mods, patches or DLC to a "
"game is. The most important thing is to identify how one plans to distribute "
"future content for their game and develop a workflow that is customized for "
"that purpose. Godot should make that process smooth regardless of which "
"route a developer pursues."
msgstr ""
"本教程应说明如何轻松地向游戏添加mod，补丁或DLC。最重要的是确定计划如何为他们"
"的游戏分发未来内容并开发为此目的定制的工作流程。无论开发人员追求哪条路线，"
"Godot都应该使这个过程顺利进行。"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:4
msgid "Feature tags"
msgstr "功能标签"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:9
msgid ""
"Godot has a special system to tag availability of features. Each *feature* "
"is represented as a string, which can refer to many of the following:"
msgstr ""
"Godot 有一个特殊的系统来标记功能的可用性。 每个 *特性* 表示为一个字符串，它可"
"以引用以下许多内容:"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:12
msgid "Platform name."
msgstr "平台名称。"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:13
msgid "Platform architecture (64-bit or 32-bit, x86 or ARM)."
msgstr "平台架构(64位或32位，x86或ARM)。"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:14
msgid "Platform type (desktop, mobile, Web)."
msgstr "平台类型 (台式机，手机，网页)。"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:15
msgid "Supported texture compression algorithms on the platform."
msgstr "支持平台的纹理压缩。"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:16
msgid ""
"Whether a build is ``debug`` or ``release`` (``debug`` includes the editor)."
msgstr "构建是 ``debug`` 还是 ``release`` ( ``debug`` 包括编辑器)。"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:17
msgid ""
"Whether the project is running from the editor or a \"standalone\" binary."
msgstr "项目是从编辑器运行还是“独立”二进制文件运行。"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:18
msgid "Many more things."
msgstr "更多的东西。"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:20
msgid "Features can be queried at run-time from the singleton API by calling:"
msgstr "通过调用以下功能可以在运行时查询单例API:"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:28
msgid "Default features"
msgstr "默认功能"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:30
msgid ""
"Here is a list of most feature tags in Godot. Keep in mind they are **case-"
"sensitive**:"
msgstr "以下是 Godot 中大多数功能标签的列表。 请记住它们 *区分大小写* :"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:33
msgid "**Feature tag**"
msgstr "** 功能标签 **"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:35
msgid "**Android**"
msgstr "**Android**"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:35
msgid "Running on Android"
msgstr "在Android上运行"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:37
msgid "**HTML5**"
msgstr "**HTML5**"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:37
msgid "Running on HTML5"
msgstr "在 HTML5 上运行"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:39
msgid "**JavaScript**"
msgstr "**JavaScript**"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:39
msgid ":ref:`JavaScript singleton <doc_javascript_eval>` is available"
msgstr ":ref:`JavaScript singleton <doc_javascript_eval>` 可用"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:42
msgid "**OSX**"
msgstr "**OSX**"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:42
msgid "Running on macOS"
msgstr "在 macOS 上运行"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:44
msgid "**iOS**"
msgstr "**iOS**"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:44
msgid "Running on iOS"
msgstr "在 iOS 上运行"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:46
msgid "**UWP**"
msgstr "**UWP**"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:46
msgid "Running on UWP"
msgstr "在 UWP 上运行"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:48
msgid "**Windows**"
msgstr "**Windows**"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:48
msgid "Running on Windows"
msgstr "在 Windows 上运行"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:50
msgid "**X11**"
msgstr "**X11**"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:50
msgid "Running on X11 (Linux/BSD desktop)"
msgstr "在X11上运行(Linux / BSD桌面)"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:52
msgid "**Server**"
msgstr "**服务器**"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:52
msgid "Running on the headless server platform"
msgstr "在无头服务器平台上运行"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:54
msgid "**debug**"
msgstr "**调试**"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:54
msgid "Running on a debug build (including the editor)"
msgstr "在调试版本(包括编辑器)上运行"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:56
msgid "**release**"
msgstr "**发布**"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:56
msgid "Running on a release build"
msgstr "以发布版本运行"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:58
msgid "**editor**"
msgstr "**编辑器**"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:58
msgid "Running on an editor build"
msgstr "在编辑器构建上运行"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:60
msgid "**standalone**"
msgstr "**独立平台**"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:60
msgid "Running on a non-editor build"
msgstr "在非编辑器构建上运行"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:62
msgid "**64**"
msgstr "**64**"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:62
msgid "Running on a 64-bit build (any architecture)"
msgstr "在64位版本(任何架构)上运行"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:64
msgid "**32**"
msgstr "**32**"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:64
msgid "Running on a 32-bit build (any architecture)"
msgstr "以32位运行"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:66
msgid "**x86_64**"
msgstr "**x86_64**"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:66
msgid "Running on a 64-bit x86 build"
msgstr "以64位运行"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:68
msgid "**x86**"
msgstr "**x86**"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:68
msgid "Running on a 32-bit x86 build"
msgstr "以32位 x86 运行"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:70
msgid "**arm64**"
msgstr "**arm64**"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:70
msgid "Running on a 64-bit ARM build"
msgstr "以64位 ARM 运行"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:72
msgid "**arm**"
msgstr "**arm**"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:72
msgid "Running on a 32-bit ARM build"
msgstr "以32位 ARM运行"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:74
msgid "**mobile**"
msgstr "**mobile**"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:74
msgid "Host OS is a mobile platform"
msgstr "宿主操作系统为移动平台"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:76
msgid "**pc**"
msgstr "**pc**"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:76
msgid "Host OS is a PC platform (desktop/laptop)"
msgstr "宿主操作系统是 PC 平台 (台式机/笔记本电脑)"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:78
msgid "**web**"
msgstr "**web**"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:78
msgid "Host OS is a Web browser"
msgstr "宿主操作系统是网页浏览器"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:80
msgid "**etc**"
msgstr "**etc**"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:80
msgid "Textures using ETC1 compression are supported"
msgstr "支持使用 ETC1 压缩的纹理"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:82
msgid "**etc2**"
msgstr "**etc2**"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:82
msgid "Textures using ETC2 compression are supported"
msgstr "支持使用 ETC2 压缩的纹理"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:84
msgid "**s3tc**"
msgstr "**s3tc**"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:84
msgid "Textures using S3TC (DXT/BC) compression are supported"
msgstr "支持使用 S3TC (DXT/BC) 压缩的纹理"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:86
msgid "**pvrtc**"
msgstr "**pvrtc**"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:86
msgid "Textures using PVRTC compression are supported"
msgstr "支持使用 PVRTC 压缩的纹理"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:90
msgid "Custom features"
msgstr "自定义功能"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:92
msgid ""
"It is possible to add custom features to a build; use the relevant field in "
"the *export preset* used to generate it:"
msgstr ""
"可以向构建添加自定义功能，使用用于生成它的 *export preset * 中的相关字段:"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:98
msgid "Overriding project settings"
msgstr "重载项目设置"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:100
msgid ""
"Features can be used to override specific configuration values in the "
"*Project Settings*. This allows you to better customize any configuration "
"when doing a build."
msgstr ""
"功能可用于重载 *Project Settings* 中的特定配置值。 这样可以在构建时更好地定制"
"任意配置。"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:103
msgid ""
"In the following example, a different icon is added for the demo build of "
"the game (which was customized in a special export preset, which, in turn, "
"includes only demo levels)."
msgstr ""
"在下面的示例中，为游戏的演示版本添加了一个不同的图标(在特定的导出预设中进行了"
"自定义，而该预设仅包含演示关卡)。"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:108
msgid "After overriding, a new field is added for this specific configuration:"
msgstr "重写后, 将为此特定配置添加一个新字段:"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:113
msgid "Default overrides"
msgstr "默认重载"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:115
msgid ""
"There are already a lot of settings that come with overrides by default; "
"they can be found in many sections of the project settings."
msgstr ""
"默认情况下，已有很多设置与其重载一起出现，它们可以在项目设置的许多地方中找"
"到。"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:121
#, fuzzy
msgid "Customizing the build"
msgstr "自定义生成"

#: ../../docs/getting_started/workflow/export/feature_tags.rst:123
msgid ""
"Feature tags can be used to customize a build process too, by writing a "
"custom **ExportPlugin**. They are also used to specify which shared library "
"is loaded and exported in **GDNative**."
msgstr ""
"通过编写自定义的 **ExportPlugin**，功能标签也可用于定制构建过程。 它们也被用"
"来指定在 **GDNative** 中加载和导出哪个共享库。"

#: ../../docs/getting_started/workflow/export/exporting_for_pc.rst:4
msgid "Exporting for PC"
msgstr "导出到PC"

#: ../../docs/getting_started/workflow/export/exporting_for_pc.rst:6
msgid ""
"The simplest way to distribute a game for PC is to copy the executables "
"(``godot.exe`` on Windows, ``godot`` on the rest), compress the folder and "
"send it to someone else. However, this is often not desired."
msgstr ""
"分发PC游戏的最简单方法是复制可执行文件(Windows上的 ``godot.exe`` ，其余的 "
"``godot`` )，压缩文件夹并将其发送给其他人。 然而，这通常是不希望的。"

#: ../../docs/getting_started/workflow/export/exporting_for_pc.rst:10
msgid ""
"Godot offers a more elegant approach for PC distribution when using the "
"export system. When exporting for PC (Linux, Windows, macOS), the exporter "
"takes all the project files and creates a ``data.pck`` file. This file is "
"bundled with a specially optimized binary that is smaller, faster and does "
"not contain the editor and debugger."
msgstr ""
"使用导出系统时，Godot为PC分发提供了更优雅的方法。 导出PC(Linux，Windows，"
"macOS)时，导出器会获取所有项目文件并创建一个 ``data.pck`` 文件。 此文件与特别"
"优化的二进制文件捆绑在一起，该二进制文件更小，更快，并且不包含编辑器和调试"
"器。"

#: ../../docs/getting_started/workflow/export/exporting_for_ios.rst:4
msgid "Exporting for iOS"
msgstr "导出到iOS"

#: ../../docs/getting_started/workflow/export/exporting_for_ios.rst:6
msgid ""
"These are the steps to load a Godot project in Xcode. This allows you to "
"build and deploy to an iOS device, build a release for the App Store, and do "
"everything else you can normally do with Xcode."
msgstr ""
"这些是在Xcode中加载Godot项目的步骤。 这允许您构建和部署到iOS设备，为App Store"
"构建版本，并执行您通常可以使用Xcode执行的所有其他操作。"

#: ../../docs/getting_started/workflow/export/exporting_for_ios.rst:11
#: ../../docs/development/compiling/compiling_for_windows.rst:9
#: ../../docs/development/compiling/compiling_for_x11.rst:9
#: ../../docs/development/compiling/compiling_for_osx.rst:9
#: ../../docs/development/compiling/compiling_for_android.rst:20
#: ../../docs/development/compiling/compiling_for_ios.rst:9
#: ../../docs/development/compiling/cross-compiling_for_ios_on_linux.rst:27
#: ../../docs/development/compiling/compiling_for_uwp.rst:9
#: ../../docs/development/compiling/compiling_for_web.rst:9
#: ../../docs/development/compiling/compiling_with_mono.rst:9
msgid "Requirements"
msgstr "需求"

#: ../../docs/getting_started/workflow/export/exporting_for_ios.rst:13
msgid ""
"You must export for iOS from a computer running macOS with Xcode installed."
msgstr "您必须从运行安装了Xcode的macOS的计算机导出iOS。"

#: ../../docs/getting_started/workflow/export/exporting_for_ios.rst:14
msgid ""
"Download the Godot export templates. Use the Godot menu: Editor > Manage "
"Export Templates"
msgstr "下载Godot导出模板。 使用Godot菜单:编辑器>管理导出模板"

#: ../../docs/getting_started/workflow/export/exporting_for_ios.rst:17
msgid "Export a Godot project to Xcode"
msgstr "将Godot项目导出到Xcode"

#: ../../docs/getting_started/workflow/export/exporting_for_ios.rst:19
msgid ""
"In the Godot editor, open the **Export** window from the **Project** menu. "
"When the Export window opens, click **Add..** and select **iOS**."
msgstr ""
"在Godot编辑器中，从 **Project** 菜单打开 **Export** 窗口。 导出窗口打开后，单"
"击 **添加..** 并选择 **iOS** 。"

#: ../../docs/getting_started/workflow/export/exporting_for_ios.rst:22
msgid ""
"The following export options are required. Leaving any blank will cause the "
"exporter to throw an error:"
msgstr "需要以下导出选项。 留下任何空白会导致导出器抛出错误:"

#: ../../docs/getting_started/workflow/export/exporting_for_ios.rst:25
msgid "In the **Application** category * **App Store Team ID**"
msgstr "在 **应用程序** 类别 * **App Store团队ID**"

#: ../../docs/getting_started/workflow/export/exporting_for_ios.rst:27
msgid "Everything in the **Required Icons** category"
msgstr "**必需图标** 类别中的所有内容"

#: ../../docs/getting_started/workflow/export/exporting_for_ios.rst:28
msgid "Everything in the **Landscape Launch Screens** category"
msgstr "**Landscape Launch Screens** 类别中的所有内容"

#: ../../docs/getting_started/workflow/export/exporting_for_ios.rst:29
msgid "Everything in the **Portrait Launch Screens** category"
msgstr "**Portrait Launch Screens** 类别中的所有内容"

#: ../../docs/getting_started/workflow/export/exporting_for_ios.rst:31
msgid ""
"After you click **Export Project**, there are still two important options "
"left:"
msgstr "单击 **导出项目** 后，仍有两个重要选项:"

#: ../../docs/getting_started/workflow/export/exporting_for_ios.rst:33
msgid ""
"**Path** is an empty folder that will contain the exported Xcode project "
"files."
msgstr "**Path** 是一个空文件夹，它将包含导出的Xcode项目文件。"

#: ../../docs/getting_started/workflow/export/exporting_for_ios.rst:34
msgid ""
"**File** will be the name of the Xcode project and several project specific "
"files and directories."
msgstr "**文件** 将是Xcode项目的名称和几个项目特定的文件和目录。"

#: ../../docs/getting_started/workflow/export/exporting_for_ios.rst:38
msgid ""
"This tutorial uses **exported_xcode_project_name**, but you will use your "
"project's name. When you see **exported_xcode_project_name** in the "
"following steps, replace it with the name you used instead."
msgstr ""
"本教程使用 **exported_xcode_project_name** ，但您将使用项目的名称。 当您在以"
"下步骤中看到 **exported_xcode_project_name** 时，请将其替换为您使用的名称。"

#: ../../docs/getting_started/workflow/export/exporting_for_ios.rst:42
msgid "When the export completes, the output folder should look like this:"
msgstr "导出完成后，输出文件夹应如下所示:"

#: ../../docs/getting_started/workflow/export/exporting_for_ios.rst:46
msgid ""
"Opening **exported_xcode_project_name.xcodeproj** lets you build and deploy "
"like any other iOS app."
msgstr ""
"打开 **exported_xcode_project_name.xcodeproj** 可让您像任何其他iOS应用程序一"
"样构建和部署。"

#: ../../docs/getting_started/workflow/export/exporting_for_ios.rst:50
msgid "Active development considerations"
msgstr "积极的发展考虑"

#: ../../docs/getting_started/workflow/export/exporting_for_ios.rst:52
msgid ""
"The above method creates an exported project that you can build for release, "
"but you have to re-export every time you make a change in Godot."
msgstr ""
"上面的方法创建了一个可以为发布而构建的导出项目，但每次在Godot中进行更改时都必"
"须重新导出。"

#: ../../docs/getting_started/workflow/export/exporting_for_ios.rst:55
msgid ""
"While developing, you can speed this process up by linking your Godot "
"project files directly into your app."
msgstr ""
"在开发过程中，您可以通过将Godot项目文件直接链接到您的应用程序来加快此过程。"

#: ../../docs/getting_started/workflow/export/exporting_for_ios.rst:58
msgid "In the following example:"
msgstr "在以下示例中:"

#: ../../docs/getting_started/workflow/export/exporting_for_ios.rst:60
msgid ""
"**exported_xcode_project_name** is the name of the exported iOS application "
"(as above)."
msgstr "**exported_xcode_project_name** 是导出的iOS应用程序的名称(如上所示)。"

#: ../../docs/getting_started/workflow/export/exporting_for_ios.rst:61
msgid "**godot_project_to_export** is the name of the Godot project."
msgstr "**godot_project_to_export** 是Godot项目的名称。"

#: ../../docs/getting_started/workflow/export/exporting_for_ios.rst:64
msgid "Steps to link a Godot project folder to Xcode"
msgstr "将Godot项目文件夹链接到Xcode的步骤"

#: ../../docs/getting_started/workflow/export/exporting_for_ios.rst:66
msgid "Start from an exported iOS project (follow the steps above)."
msgstr "从导出的iOS项目开始(按照上述步骤)。"

#: ../../docs/getting_started/workflow/export/exporting_for_ios.rst:67
msgid "In Finder, drag the Godot project folder into the Xcode file browser."
msgstr "在Finder中，将Godot项目文件夹拖到Xcode文件浏览器中。"

#: ../../docs/getting_started/workflow/export/exporting_for_ios.rst:71
msgid ""
"3. In the dialog, make sure **Create folder references** is selected. This "
"means you will be able to continue to edit your Godot project in its current "
"location."
msgstr ""
"3.在对话框中，确保选中 **创建文件夹引用** 。 这意味着您将能够继续在其当前位置"
"编辑您的Godot项目。"

#: ../../docs/getting_started/workflow/export/exporting_for_ios.rst:76
msgid "See the **godot_project_to_export** folder in the Xcode file browser."
msgstr "请参阅Xcode文件浏览器中的 **godot_project_to_export** 文件夹。"

#: ../../docs/getting_started/workflow/export/exporting_for_ios.rst:77
msgid "Delete **exported_xcode_project_name.pck** from the Xcode project."
msgstr "从Xcode项目中删除 **exported_xcode_project_name.pck**。"

#: ../../docs/getting_started/workflow/export/exporting_for_ios.rst:81
msgid ""
"6. Open **exported_xcode_project_name-Info.plist** and add a string property "
"named **godot_path** (this is the real key name) with a value "
"**godot_project_to_export** (this is the name of your project)"
msgstr ""
"6. 打开 **exported_xcode_project_name-Info.plist** 并添加一个名为 "
"**godot_path的字符串属性** (这是真正的密钥名称)，其值为 "
"**godot_project_to_export** (这是项目的名称)"

#: ../../docs/getting_started/workflow/export/exporting_for_ios.rst:87
msgid ""
"That's it! You can now edit your project in the Godot editor and build it in "
"Xcode when you want to run it on a device."
msgstr ""
"就这样！ 您现在可以在Godot编辑器中编辑项目，并在想要在设备上运行时在Xcode中构"
"建它。"

#: ../../docs/getting_started/workflow/export/exporting_for_ios.rst:91
#: ../../docs/tutorials/platform/services_for_ios.rst:4
msgid "Services for iOS"
msgstr "适用于iOS的服务"

#: ../../docs/getting_started/workflow/export/exporting_for_ios.rst:93
msgid ""
"Special iOS services can be used in Godot. Check out the :ref:"
"`doc_services_for_ios` page."
msgstr ""
"可以在Godot中使用特殊的iOS服务。 查看 :ref:`doc_services_for_ios` 页面。"

#: ../../docs/getting_started/workflow/export/exporting_for_uwp.rst:4
msgid "Exporting for Universal Windows Platform"
msgstr "导出到通用Windows平台"

#: ../../docs/getting_started/workflow/export/exporting_for_uwp.rst:6
msgid ""
"There's no extra requirement to export an ``.appx`` package that can be "
"installed as a Windows App or submitted to the Windows Store. Exporting UWP "
"packages also works from any platform, not only from Windows."
msgstr ""
"导出为 ``.appx`` 包没有额外的要求，它可以作为Windows应用程序被安装或提交到"
"Windows应用商店。 导出UWP软件包的功能也可以在任何平台上成功运行，而不仅仅是"
"Windows。"

#: ../../docs/getting_started/workflow/export/exporting_for_uwp.rst:10
msgid ""
"However, if you want to install and run the app, you need to sign it with a "
"trusted signature. Currently, Godot does not support signing of packages, so "
"you need to use external tools to do so."
msgstr ""
"但是，如果要安装并运行应用程序，则需要使用可信签名对其进行签名。 目前，Godot"
"不支持签名包，因此您需要使用外部工具来执行此操作。"

#: ../../docs/getting_started/workflow/export/exporting_for_uwp.rst:14
msgid ""
"Also, make sure the Publisher Name you set when exporting the package "
"matches the name used on the certificate."
msgstr "此外，请确保导出包时设置的发布者名称与证书上使用的名称相匹配。"

#: ../../docs/getting_started/workflow/export/exporting_for_uwp.rst:18
msgid "Limitations on Xbox One"
msgstr "Xbox One的限制"

#: ../../docs/getting_started/workflow/export/exporting_for_uwp.rst:20
msgid ""
"As described in the `UWP documentation <https://docs.microsoft.com/en-us/"
"windows/uwp/xbox-apps/system-resource-allocation>`__:"
msgstr ""
"如 `UWP文档 <https://docs.microsoft.com/en-us/windows/uwp/xbox-apps/system-"
"resource-allocation>`__ 中所述:"

#: ../../docs/getting_started/workflow/export/exporting_for_uwp.rst:25
msgid "Submitted as an \"App\""
msgstr "提交为“App”"

#: ../../docs/getting_started/workflow/export/exporting_for_uwp.rst:23
msgid "available memory is 1GB"
msgstr "可用内存为1GB"

#: ../../docs/getting_started/workflow/export/exporting_for_uwp.rst:24
msgid "share of 2-4 CPU cores"
msgstr "分享2-4个CPU核"

#: ../../docs/getting_started/workflow/export/exporting_for_uwp.rst:25
msgid "shared access of GPU power (45%)"
msgstr "共享GPU功率(45％)"

#: ../../docs/getting_started/workflow/export/exporting_for_uwp.rst:30
msgid ""
"Submitted as a \"Game\" (through `Xbox Live Creators Program <https://www."
"xbox.com/en-US/developers/creators-program>`__)"
msgstr ""
"提交为“游戏”(通过 `Xbox Live Creators Program <https://www.xbox.com/en-US/"
"developers/creators-program>`__)"

#: ../../docs/getting_started/workflow/export/exporting_for_uwp.rst:28
msgid "available memory is 5GB"
msgstr "可用内存为5GB"

#: ../../docs/getting_started/workflow/export/exporting_for_uwp.rst:29
msgid "4 exclusive CPU cores and 2 shared CPU cores"
msgstr "4个独有的CPU内核和2个共享CPU内核"

#: ../../docs/getting_started/workflow/export/exporting_for_uwp.rst:30
msgid "exclusive access to GPU power (100%)"
msgstr "独家访问GPU功率(100％)"

#: ../../docs/getting_started/workflow/export/exporting_for_uwp.rst:32
msgid ""
"Exceeding these memory limitations will cause allocation failures and the "
"application will crash."
msgstr "超出这些内存限制将导致分配失败，应用程序将崩溃。"

#: ../../docs/getting_started/workflow/export/exporting_for_uwp.rst:35
msgid "Creating a signing certificate"
msgstr "创建签名证书"

#: ../../docs/getting_started/workflow/export/exporting_for_uwp.rst:37
msgid ""
"This requires the ``MakeCert.exe`` and ``Pvk2Pfx.exe`` tools, which come "
"with the Windows SDK. If you use Visual Studio, you can open one of its "
"Developer Prompts, since it comes with these tools and they can be located "
"in the path."
msgstr ""
"这需要Windows SDK附带的 ``MakeCert.exe`` 和 ``Pvk2Pfx.exe`` 工具。 如果您使用"
"Visual Studio，则可以打开其中一个Developer Prompts，因为它附带了这些工具，并"
"且它们可以位于路径中。"

#: ../../docs/getting_started/workflow/export/exporting_for_uwp.rst:41
msgid ""
"You can get more detailed instructions from `Microsoft's documentation "
"<https://msdn.microsoft.com/en-us/library/windows/desktop/jj835832(v=vs.85)."
"aspx>`__."
msgstr ""
"您可以从 `Microsoft的文档 <https://msdn.microsoft.com/en-us/library/windows/"
"desktop/jj835832(v=vs.85).aspx>`__ 获得更详细的说明。"

#: ../../docs/getting_started/workflow/export/exporting_for_uwp.rst:44
msgid "First, run ``MakeCert`` to create a private key::"
msgstr "首先，运行 ``MakeCert`` 来创建私钥::"

#: ../../docs/getting_started/workflow/export/exporting_for_uwp.rst:48
msgid ""
"Where ``publisherName`` matches the Publisher Name of your package and "
"``expirationDate`` is in the ``mm/dd/yyyy`` format."
msgstr ""
"其中 ``publisherName`` 匹配包的发布者名称， ``expirationDate` `是 ``mm / "
"dd / yyyy`` 格式。"

#: ../../docs/getting_started/workflow/export/exporting_for_uwp.rst:51
msgid ""
"Next, create a Personal Information Exchange (.pfx) file using ``Pvk2Pfx."
"exe``::"
msgstr "接下来，使用 ``Pvk2Pfx.exe`` 创建个人信息交换(.pfx)文件::"

#: ../../docs/getting_started/workflow/export/exporting_for_uwp.rst:55
msgid ""
"If you don't specify a password with ``/po`` argument, the PFX will have the "
"same password as the private key."
msgstr "如果未使用 ``/ po`` 参数指定密码，则PFX将具有与私钥相同的密码。"

#: ../../docs/getting_started/workflow/export/exporting_for_uwp.rst:58
msgid ""
"You will also need to trust this certificate in order to be able to install "
"your app. Open the Command Prompt as Administrator and run the following "
"command::"
msgstr ""
"您还需要信任此证书才能安装您的应用。 以管理员身份打开命令提示符并运行以下命"
"令::"

#: ../../docs/getting_started/workflow/export/exporting_for_uwp.rst:64
msgid "Signing the package"
msgstr "签署包"

#: ../../docs/getting_started/workflow/export/exporting_for_uwp.rst:66
msgid "Finally, use ``SignTool.exe`` from the Windows SDK or Visual Studio::"
msgstr "最后，使用Windows SDK或Visual Studio中的 ``SignTool.exe`` ::"

#: ../../docs/getting_started/workflow/export/exporting_for_uwp.rst:71
msgid "Installing the package"
msgstr "安装包"

#: ../../docs/getting_started/workflow/export/exporting_for_uwp.rst:73
msgid ""
"As of the Windows 10 Anniversary Update, you are able to install packages "
"simply by double clicking the ``.appx`` file from Windows Explorer."
msgstr ""
"从Windows 10周年更新开始，只需双击Windows资源管理器中的 ``.appx`` 文件即可安"
"装软件包。"

#: ../../docs/getting_started/workflow/export/exporting_for_uwp.rst:76
msgid ""
"It's also possible to install by using the ``Add-AppxPackage`` PowerShell "
"cmdlet."
msgstr "也可以使用 ``Add-AppxPackage`` PowerShell cmdlet进行安装。"

#: ../../docs/getting_started/workflow/export/exporting_for_uwp.rst:78
msgid ""
"If you want to update your already installed app, you must update the "
"version number on the new package or first uninstall the previous package."
msgstr ""
"如果要更新已安装的应用程序，则必须更新新软件包上的版本号或首先卸载以前的软件"
"包。"

#: ../../docs/getting_started/workflow/export/exporting_for_android.rst:4
msgid "Exporting for Android"
msgstr "导出到Android"

#: ../../docs/getting_started/workflow/export/exporting_for_android.rst:6
msgid ""
"Exporting for Android has fewer requirements than compiling Godot for it. "
"The following steps detail what is needed to setup the SDK and the engine."
msgstr ""
"Android的导出比编译Godot的要求更少。 以下步骤详细说明了设置SDK和引擎所需的内"
"容。"

#: ../../docs/getting_started/workflow/export/exporting_for_android.rst:10
msgid "Download the Android SDK"
msgstr "下载Android SDK"

#: ../../docs/getting_started/workflow/export/exporting_for_android.rst:12
msgid ""
"Download and install the Android SDK from https://developer.android.com/"
"studio/"
msgstr "从 https://developer.android.com/studio/ 下载并安装Android SDK"

#: ../../docs/getting_started/workflow/export/exporting_for_android.rst:16
msgid "Install OpenJDK or Oracle JDK"
msgstr "安装OpenJDK或Oracle JDK"

#: ../../docs/getting_started/workflow/export/exporting_for_android.rst:18
msgid ""
"Download and install  `OpenJDK <https://github.com/ojdkbuild/ojdkbuild>`__ "
"or `Oracle JDK <http://www.oracle.com/technetwork/java/javase/downloads/"
"index.html>`__. Versions below JDK 8 may not work; some users have reported "
"issues with the jarsigner (used to sign the APKs) in JDK 7."
msgstr ""
"下载并安装 `OpenJDK <https://github.com/ojdkbuild/ojdkbuild>`__ 或 ` Oracle "
"JDK <http://www.oracle.com/technetwork/java/javase/downloads/index."
"html>`__ 。 JDK 8以下的版本可能无法正常工作，有些用户在JDK 7中报告了"
"jarsigner(用于签署APK)的问题。"

#: ../../docs/getting_started/workflow/export/exporting_for_android.rst:21
msgid "Create a debug.keystore"
msgstr "创建一个debug.keystore"

#: ../../docs/getting_started/workflow/export/exporting_for_android.rst:23
msgid ""
"Android needs a debug keystore file to install to devices and distribute non-"
"release APKs. If you have used the SDK before and have built projects, ant "
"or eclipse probably generated one for you (on Linux and macOS, you can find "
"it in the ``~/.android`` directory)."
msgstr ""
"Android需要调试密钥库文件才能安装到设备并分发非发布APK。 如果您以前使用过SDK"
"并且已经构建了项目，那么ant或eclipse可能会为您生成一个(在Linux和macOS上，您可"
"以在 ``〜/ .android`` 目录中找到它)。"

#: ../../docs/getting_started/workflow/export/exporting_for_android.rst:28
msgid ""
"If you can't find it or need to generate one, the keytool command from the "
"JDK can be used for this purpose:"
msgstr "如果找不到或需要生成一个，JDK的keytool命令可用于此目的:"

#: ../../docs/getting_started/workflow/export/exporting_for_android.rst:36
msgid "Make sure you have adb"
msgstr "确保您有adb"

#: ../../docs/getting_started/workflow/export/exporting_for_android.rst:38
msgid ""
"Android Debug Bridge (adb) is the command line tool used to communicate with "
"Android devices. It's installed with the SDK, but you may need to install "
"one (any) of the Android API levels for it to be installed in the SDK "
"directory."
msgstr ""
"Android Debug Bridge(adb)是用于与Android设备通信的命令行工具。 它随SDK一起安"
"装，但您可能需要安装一个(任何)Android API级别才能将其安装在SDK目录中。"

#: ../../docs/getting_started/workflow/export/exporting_for_android.rst:43
msgid "Setting it up in Godot"
msgstr "在Godot中设置它"

#: ../../docs/getting_started/workflow/export/exporting_for_android.rst:45
msgid ""
"Enter the Editor Settings screen. This screen contains the editor settings "
"for the user account in the computer (it's independent from the project)."
msgstr ""
"进入编辑器设置屏幕。 此屏幕包含计算机中用户帐户的编辑器设置(它独立于项目)。"

#: ../../docs/getting_started/workflow/export/exporting_for_android.rst:51
msgid "Scroll down to the section where the Android settings are located:"
msgstr "向下滚动到Android设置所在的部分:"

#: ../../docs/getting_started/workflow/export/exporting_for_android.rst:55
msgid "In that screen, the path to 3 files needs to be set:"
msgstr "在该屏幕中，需要设置3个文件的路径:"

#: ../../docs/getting_started/workflow/export/exporting_for_android.rst:57
msgid "The *adb* executable (adb.exe on Windows)"
msgstr "*adb* 可执行文件(Windows上的adb.exe)"

#: ../../docs/getting_started/workflow/export/exporting_for_android.rst:58
msgid "The *jarsigner* executable (from JDK 6 or 8)"
msgstr "*jarsigner* 可执行文件(来自JDK 6或8)"

#: ../../docs/getting_started/workflow/export/exporting_for_android.rst:59
msgid "The debug *keystore*"
msgstr "debug 的 *keystore*"

#: ../../docs/getting_started/workflow/export/exporting_for_android.rst:61
msgid "Once that is configured, everything is ready to export to Android!"
msgstr "配置完成后，导出到Android的一切都准备好了！"

#: ../../docs/getting_started/workflow/export/exporting_for_android.rst:64
msgid "Exporting for Google Play Store"
msgstr "导出到Google Play商店"

#: ../../docs/getting_started/workflow/export/exporting_for_android.rst:66
msgid ""
"Uploading an APK to Google's Play Store requires you to sign using a non-"
"debug keystore file; such file can be generated like this:"
msgstr ""
"将APK上传到Google的Play商店需要您使用非调试密钥库文件进行签名，这样的文件可以"
"像这样生成:"

#: ../../docs/getting_started/workflow/export/exporting_for_android.rst:73
#, fuzzy
msgid ""
"This keystore and key are used to verify your developer identity, remember "
"the password and keep it in a safe place! Use Google's Android Developer "
"guides to learn more about `APK signing <https://developer.android.com/"
"studio/publish/app-signing>`__."
msgstr ""
"此密钥用于验证您的开发人员身份，记住其密码并将其保存在安全的地方！ 使用Google"
"的Android开发人员指南了解有关 `APK签名 <https://developer.android.com/studio/"
"publish/app-signing>`__ 的更多信息。"

#: ../../docs/getting_started/workflow/export/exporting_for_android.rst:76
#, fuzzy
msgid "Now fill in the following forms in your Android Export Presets:"
msgstr "现在在Android导出预设中填写以下表格:"

#: ../../docs/getting_started/workflow/export/exporting_for_android.rst:80
msgid "Release: Enter the path to the keystore file you just generated."
msgstr "发布:输入刚刚生成的密钥库文件的路径。"

#: ../../docs/getting_started/workflow/export/exporting_for_android.rst:81
#, fuzzy
msgid "Release User: Replace with the key alias."
msgstr "发布用户:替换为您的密钥别名。"

#: ../../docs/getting_started/workflow/export/exporting_for_android.rst:82
#, fuzzy
msgid ""
"Release Password: Key password. Note that the keystore password and the key "
"password currently have to be the same."
msgstr ""
"Release Password（发布密码）: Key password（密码）. 请注意，当前的密钥库密码"
"（keystore password）与密钥密码（key password）必须时相同的。"

#: ../../docs/getting_started/workflow/export/exporting_for_android.rst:84
#, fuzzy
msgid ""
"**Now your export_presets.cfg file contains sensitive info;** if using a "
"Version Control System, it is a good idea to remove it from public "
"repositories."
msgstr ""
"现在您的export_presets.cfg文件包含敏感信息，如果使用版本控制系统，最好将其从"
"公共存储库中删除。"

#: ../../docs/getting_started/workflow/export/exporting_for_android.rst:86
msgid ""
"Don't forget to disable the ``Export With Debug`` button while choosing the "
"APK's name."
msgstr "选择APK的名称时，不要忘记禁用“使用调试导出”按钮。"

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:4
msgid "Exporting for the Web"
msgstr "导出到Web"

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:6
#, fuzzy
msgid ""
"HTML5 export allows publishing games made in Godot Engine to the browser. "
"This requires support for `WebAssembly <https://webassembly.org/>`__ and "
"`WebGL <https://www.khronos.org/webgl/>`__ in the user's browser."
msgstr ""
"HTML5导出允许将在Godot Engine中制作的游戏发布到浏览器。 这需要在用户的浏览器"
"中支持最近的技术 `WebAssembly <https://webassembly.org/>`__ 和 `WebGL 2.0 "
"<https://www.khronos.org/webgl/>`__ 。 ** Firefox ** 和 **Chromium** "
"(Chrome，Opera)是最受欢迎的支持浏览器， **Safari** 和 **Edge** 尚不起作用。 "
"在 **iOS** 上，所有浏览器必须基于WebKit(即Safari)，因此它们也不起作用。"

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:11
msgid ""
"Use the browser-integrated developer console, usually opened with :kbd:"
"`F12`, to view **debug information** like JavaScript, engine, and WebGL "
"errors."
msgstr ""
"使用浏览器集成的开发人员控制台 (通常使用： :kbd:`F12`打开) 来查看 **调试信息"
"**, 如 javascript、引擎和WebGL错误。"

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:15
msgid ""
"Many browsers, Chromium-based browsers specifically, will not load exported "
"projects when **opened locally** per ``file://`` protocol. To get around "
"this, use a local server."
msgstr ""
"许多浏览器，特别是基于Chromium的浏览器，在 **本地打开** 时不会加载导出的项目"
"的每个 ``file://`` 协议。 要解决此问题，请使用本地服务器。"

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:19
#, fuzzy
msgid ""
"Python offers an easy method to start a local server. Use ``python -m "
"SimpleHTTPServer`` with Python 2 or ``python -m http.server`` with Python 3 "
"to serve the current working directory at ``http://localhost:8000``."
msgstr ""
"Python提供了一个简单的方法，使用Python2中的 ``python -m SimpleHTTPServer`` 或"
"Python 3的 ``python -m http.server`` 将在 ``http://localhost:8000`` 上提供当"
"前的工作目录。"

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:25
msgid "WebGL 2"
msgstr "WebGL 2"

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:27
msgid ""
"Until the *OpenGL ES 3* renderer is removed from Godot in favor of *Vulkan*, "
"HTML5 export uses *WebGL 2* when the *GLES3* option selected."
msgstr ""
"在 *OpenGL ES 3* 呈现器从 Godot 删除以支持 *Vulkan* 之前, 当选择 *GLES3* 选项"
"时, HTML5导出使用 *WebGL 2* 。"

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:30
msgid ""
"Usage of WebGL 2 is not recommended due to its expected removal from Godot "
"without replacement."
msgstr "不建议使用 WebGL 2 ，因为它预期会在不更换的情况下从 Godot 中删除。"

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:33
#, fuzzy
msgid ""
"WebGL 2 is not supported in all browsers. **Firefox** and **Chromium** "
"(Chrome, Opera) are the most popular supported browsers, **Safari** and "
"**Edge** do not work. On **iOS**, all browsers are based on WebKit (i.e. "
"Safari), so they will also not work."
msgstr ""
"HTML5导出允许将在Godot Engine中制作的游戏发布到浏览器。 这需要在用户的浏览器"
"中支持最近的技术 `WebAssembly <https://webassembly.org/>`__ 和 `WebGL 2.0 "
"<https://www.khronos.org/webgl/>`__ 。 ** Firefox ** 和 **Chromium** "
"(Chrome，Opera)是最受欢迎的支持浏览器， **Safari** 和 **Edge** 尚不起作用。 "
"在 **iOS** 上，所有浏览器必须基于WebKit(即Safari)，因此它们也不起作用。"

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:38
msgid ""
"Godot's WebGL 2 renderer has issues with 3D and is no longer maintained."
msgstr "Godot 的 WebGL 2 渲染器与 3D 存在问题，不再维护。"

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:41
msgid "Limitations"
msgstr "限制"

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:43
msgid ""
"For security and privacy reasons, many features that work effortlessly on "
"native platforms are more complicated on the web platform. Following is a "
"list of limitations you should be aware of when porting a Godot game to the "
"web."
msgstr ""
"出于安全和隐私的原因，许多在本机平台上轻松工作的功能在Web平台上更加复杂。 以"
"下列出了将Godot游戏移植到网络时应注意的限制。"

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:48
msgid "Using cookies for data persistence"
msgstr "使用cookie进行数据持久化"

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:50
msgid ""
"Users must **allow cookies** (specifically IndexedDB) if persistence of the "
"``user://`` file system is desired. When playing a game presented in an "
"``iframe``, **third-party** cookies must also be enabled. Incognito/private "
"browsing mode also prevents persistence."
msgstr ""
"如果需要持久化 ``user://`` 文件系统，用户必须 **允许cookie ** (特别是"
"IndexedDB)。 当玩“iframe”中呈现的游戏时，还必须启用 **第三方** cookie。 隐身/"
"隐私浏览模式也可以防止持久性。"

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:55
msgid ""
"The method ``OS.is_userfs_persistent()`` can be used to check if the "
"``user://`` file system is persistent, but can give false positives in some "
"cases."
msgstr ""
"方法 ``OS.is_userfs_persistent()`` 可用于检查 ``user://`` 文件系统是否持久，"
"但在某些情况下会给出误报。"

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:60
msgid "Full screen and mouse capture"
msgstr "全屏和鼠标捕获"

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:62
#, fuzzy
msgid ""
"Browsers do not allow arbitrarily **entering full screen**. The same goes "
"for **capturing the cursor**. Instead, these actions have to occur as a "
"response to a JavaScript input event. In Godot, this means entering full "
"screen from within a pressed input event callback such as ``_input`` or "
"``_unhandled_input``. Querying the :ref:`class_Input` singleton is not "
"sufficient, the relevant input event must currently be active."
msgstr ""
"浏览器不允许任意 **随意进入全屏** 。 **捕获光标** 也是如此。 相反，这些操作必"
"须作为对JavaScript输入事件的响应而发生。 在Godot中，通过在输入回调中输入全"
"屏，例如 ``_input`` 或 ``_unhandled_input`` ，最容易做到这一点。"

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:69
msgid ""
"For the same reason, the full screen project setting doesn't work unless the "
"engine is started from within a valid input event handler. This requires :"
"ref:`customization of the HTML page <doc_customizing_html5_shell>`."
msgstr ""
"出于同样的原因，除非从有效的输入事件处理程序中启动引擎，否则全屏项目设置将不"
"起作用。这需要： :ref:`customization of the HTML page "
"<doc_customizing_html5_shell>`。"

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:74
msgid "Audio autoplay"
msgstr "音频自动播放"

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:76
msgid ""
"Chrome restricts how websites may play audio. It may be necessary for the "
"player to click or tap or press a key to enable audio."
msgstr ""
"Chrome 限制网站播放音频的方式。可能需要玩家单击或轻按或按住一个键来启用音频。"

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:79
msgid ""
"Google offers additional information about their `Web Audio autoplay "
"policies <https://sites.google.com/a/chromium.org/dev/audio-video/"
"autoplay>`__."
msgstr ""
"Google 提供了关于 `Web音频自动播放策略 <https://sites.google.com/a/chromium."
"org/dev/audio-video/autoplay>`__。"

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:83
msgid ":ref:`class_HTTPClient` and :ref:`class_HTTPRequest`"
msgstr ":ref:`class_HTTPClient` 和 :ref:`class_HTTPRequest`"

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:85
msgid "The HTTP classes have several restrictions on the HTML5 platform:"
msgstr "HTTP类在HTML5平台上有几个限制："

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:87
msgid "Accessing or changing the ``StreamPeer`` is not possible"
msgstr "无法访问或更改 ``StreamPeer``"

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:88
#, fuzzy
msgid "Threaded/Blocking mode is not available"
msgstr "阻止模式不可用"

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:89
msgid ""
"Cannot progress more than once per frame, so polling in a loop will freeze"
msgstr "每帧不能进行多次，因此循环中的轮询将冻结"

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:90
msgid "No chunked responses"
msgstr "没有重复的回应"

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:91
msgid "Host verification cannot be disabled"
msgstr "无法禁用主机验证"

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:92
#, fuzzy
msgid ""
"Subject to `same-origin policy <https://developer.mozilla.org/en-US/docs/Web/"
"Security/Same-origin_policy>`__"
msgstr ""
"遵循 `同源政策 <https://developer.mozilla.org/en-US/docs/Web/Security/Same-"
"origin_policy>`_"

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:95
msgid "Exported ``.html`` file must not be reused"
msgstr "导出的 ``.html`` 文件不得重复使用"

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:97
msgid ""
"On export, several text placeholders are replaced in the **generated HTML "
"file** specifically for the given export options. It must not be reused in "
"further exports."
msgstr ""
"在导出时，几个文本占位符将替换为 **生成的HTML文件** ，专门用于给定的导出选"
"项。 它不得在进一步的出口中重复使用。"

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:102
msgid "Boot splash is not displayed"
msgstr "不显示启动初始点"

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:104
msgid ""
"The default HTML page does not display the boot splash while loading. "
"However, the image is exported as a PNG file, so :ref:`custom HTML pages "
"<doc_customizing_html5_shell>` can display it."
msgstr ""

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:109
msgid "Unimplemented functionality"
msgstr "未实现的功能"

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:111
msgid ""
"The following functionality is currently unavailable on the HTML5 platform:"
msgstr "HTML5平台上目前无法使用以下功能:"

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:113
#: ../../docs/tutorials/threads/thread_safe_apis.rst:7
msgid "Threads"
msgstr "线程"

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:114
#: ../../docs/tutorials/plugins/gdnative/index.rst:2
msgid "GDNative"
msgstr "GDNative"

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:116
msgid "Clipboard synchronisation between engine and operating system"
msgstr "引擎和操作系统之间的剪贴板同步"

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:117
#, fuzzy
msgid ""
"Networking other than :ref:`class_HTTPClient` and :ref:"
"`class_WebSocketClient`"
msgstr "除了 ``HTTPClient`` 之外的网络"

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:119
#, fuzzy
msgid ""
"Check the `list of open HTML5 issues on Github <https://github.com/"
"godotengine/godot/issues?q=is:open+is:issue+label:platform:html5>`__ to see "
"if the functionality you're interested in has an issue yet. If not, open one "
"to communicate your interest."
msgstr ""
"检查 `Github上的HTML5问题列表 <https://github.com/godotengine/godot/issues?"
"q=is:open+is:issue+label:platform:html5>`_ 看看您是否有感兴趣的功能或则问"
"题。 如果没有，请打开一个来表达您的兴趣。"

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:125
msgid "Serving the files"
msgstr "提供文件"

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:127
msgid ""
"Exporting for the web generates several files to be served from a web "
"server, including a default HTML page for presentation. A custom HTML file "
"can be used, see :ref:`doc_customizing_html5_shell`."
msgstr ""
"导出为Web生成多个要从Web服务器提供的文件，包括用于演示的默认HTML页面。 可以使"
"用自定义HTML文件，请参阅 :ref:`doc_customizing_html5_shell` 。"

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:131
msgid ""
"The generated ``.html`` file can be used as ``DirectoryIndex`` in Apache "
"servers and can be renamed to e.g. ``index.html`` at any time, its name is "
"never depended on by default."
msgstr ""
"生成的 ``.html`` 文件可以在Apache服务器中用作 ``DirectoryIndex`` ，并且可以重"
"命名为例如 ``index.html`` 在任何时候，默认情况下它的名称永远不会依赖。"

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:135
#, fuzzy
msgid ""
"The HTML page draws the game at maximum size within the browser window. This "
"way it can be inserted into an ``<iframe>`` with the game's size, as is "
"common on most web game hosting sites."
msgstr ""
"HTML页面旨在完美地适应游戏，而不会在浏览器窗口缩放到游戏大小时切断画布的某些"
"部分。 通过这种方式，它可以插入到游戏大小的 ``<iframe>`` 中，这在大多数网页游"
"戏托管网站上都很常见。"

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:139
msgid ""
"The other exported files are served as they are, next to the ``.html`` file, "
"names unchanged. The ``.wasm`` file is a binary WebAssembly module "
"implementing the engine. The ``.pck`` file is the Godot main pack containing "
"your game. The ``.js`` file contains start-up code and is used by the ``."
"html`` file to access the engine. The ``.png`` file contains the boot splash "
"image. It is not used in the default HTML page, but is included for :ref:"
"`custom HTML pages <doc_customizing_html5_shell>`."
msgstr ""
"其他导出的文件按原样提供，在 ``.html`` 文件旁边，名称不变。 ``.wasm`` 文件是"
"实现引擎的二进制WebAssembly模块。 ``.pck`` 文件是包含您的游戏的Godot主包。 "
"``.js`` 文件包含启动代码， ``.html`` 文件使用它来访问引擎。 ``.png`` 文件包含"
"引导启动图像。 它不在默认的HTML页面中使用，但包括在 :ref:`custom HTML pages "
"<doc_customizing_html5_shell>`。"

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:147
#, fuzzy
msgid ""
"The ``.pck`` file is binary, usually delivered with the MIME-type :mimetype:"
"`application/octet-stream`. The ``.wasm`` file is delivered as :mimetype:"
"`application/wasm`."
msgstr ""
"``.pck`` 文件是二进制文件，通常与MIME类型 ``application / octet-stream`` 一起"
"提供。 ``.wasm`` 文件以 ``application / wasm`` 形式提供。"

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:151
msgid ""
"Delivering the WebAssembly module (``.wasm``) with a MIME-type other than :"
"mimetype:`application/wasm` can prevent some start-up optimizations."
msgstr ""

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:155
msgid ""
"Delivering the files with server-side compression is recommended especially "
"for the ``.pck`` and ``.wasm`` files, which are usually large in size. The "
"WebAssembly module compresses particularly well, down to around a quarter of "
"its original size with gzip compression."
msgstr ""
"建议使用服务器端压缩来提供文件，尤其是 ``.pck`` 和 ``.wasm`` 文件，这些文件通"
"常很大。 WebAssembly模块压缩特别好，通过gzip压缩缩小到原始大小的四分之一。"

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:161
msgid "Export options"
msgstr "导出选项"

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:163
msgid ""
"If a runnable web export template is available, a button appears between the "
"*Stop scene* and *Play edited Scene* buttons in the editor to quickly open "
"the game in the default browser for testing."
msgstr ""
"如果可以使用可运行的Web导出模板，则编辑器中的 *停止场景* 和 *播放编辑的场景* "
"按钮之间会出现一个按钮，可以在默认浏览器中快速打开游戏进行测试。"

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:167
msgid ""
"If a path to a **Custom HTML shell** file is given, it will be used instead "
"of the default HTML page. See :ref:`doc_customizing_html5_shell`."
msgstr ""
"如果给出了 **Custom HTML shell** 文件的路径，则将使用它来代替默认的HTML页"
"面。 请参阅 :ref:`doc_customizing_html5_shell`。"

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:170
msgid ""
"**Head Include** is appended into the ``<head>`` element of the generated "
"HTML page. This allows to, for example, load webfonts and third-party "
"JavaScript APIs, include CSS, or run JavaScript code."
msgstr ""
"**Head Include** 被附加到生成的HTML页面的 ``<head>`` 元素中。 例如，这允许加"
"载webfonts和第三方JavaScript API，包括CSS或运行JavaScript代码。"

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:177
msgid "Calling JavaScript from script"
msgstr "从脚本调用JavaScript"

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:179
#, fuzzy
msgid ""
"In web builds, the ``JavaScript`` singleton is implemented. It offers a "
"single method called ``eval`` that works similarly to the JavaScript "
"function of the same name. It takes a string as an argument and executes it "
"as JavaScript code. This allows interacting with the browser in ways not "
"possible with script languages integrated into Godot."
msgstr ""
"在Web构建中，实现了 ``JavaScript`` 单例。 如果提供一个名为 ``eval`` 的方法，"
"它的工作方式与同名的JavaScript函数类似。 它将字符串作为参数并将其作为"
"JavaScript代码执行。 这允许以与集成到Godot中的脚本语言不可能的方式与浏览器交"
"互。"

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:190
msgid ""
"The value of the last JavaScript statement is converted to a GDScript value "
"and returned by ``eval()`` under certain circumstances:"
msgstr ""
"最后一个JavaScript语句的值转换为GDScript值，并在某些情况下由 ``eval()`` 返回:"

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:193
msgid "JavaScript ``number`` is returned as GDScript :ref:`class_float`"
msgstr "JavaScript ``number`` 作为GDScript的 :ref:`class_float` 返回"

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:194
msgid "JavaScript ``boolean`` is returned as GDScript :ref:`class_bool`"
msgstr "JavaScript ``boolean`` 作为GDScript的 :ref:`class_bool` 返回"

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:195
msgid "JavaScript ``string`` is returned as GDScript :ref:`class_String`"
msgstr "JavaScript ``string`` 作为GDScript的 :ref:`class_String` 返回"

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:196
msgid ""
"JavaScript ``ArrayBuffer``, ``TypedArray`` and ``DataView`` are returned as "
"GDScript :ref:`class_PoolByteArray`"
msgstr ""
"JavaScript ``RellBuffer``， ``TypedArray`` 和 ``DataView`` 作为GDScript的 :"
"ref:`class_PoolByteArray` 返回"

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:205
msgid "Any other JavaScript value is returned as ``null``."
msgstr "任何其他JavaScript值都返回为 ``null`` 。"

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:207
msgid ""
"HTML5 export templates may be built without support for the singleton. With "
"such templates, and on platforms other than HTML5, calling ``JavaScript."
"eval`` will also return ``null``.  The availability of the singleton can be "
"checked with the ``JavaScript`` :ref:`feature tag <doc_feature_tags>`::"
msgstr ""
"可以在不支持单例的情况下构建HTML5导出模板。 使用这样的模板，在HTML5以外的平台"
"上，调用 ``JavaScript.eval`` 也会返回 ``null`` 。 可以使用 ``JavaScript`` 来"
"检查单例的可用性 :ref:`feature tag <doc_feature_tags>`::"

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:220
msgid ""
"GDScript's multi-line strings, surrounded by 3 quotes ``\"\"\"`` as in "
"``my_func3()`` above, are useful to keep JavaScript code readable."
msgstr ""
"GDScript中的多行字符串由三双引号 ``\"\"\"`` 包围，如同上文中的 "
"``my_func3()`` 那样，有助于保证JavaScript代码的可读性。"

#: ../../docs/getting_started/workflow/export/exporting_for_web.rst:223
msgid ""
"The ``eval`` method also accepts a second, optional Boolean argument, which "
"specifies whether to execute the code in the global execution context, "
"defaulting to ``false`` to prevent polluting the global namespace::"
msgstr ""
"``eval`` 方法也接受第二个可选的布尔参数，它指定是否在全局执行上下文中执行代"
"码，默认为 ``false`` 以防止污染全局命名空间::"

#: ../../docs/getting_started/workflow/export/one-click_deploy.rst:4
msgid "One-click deploy"
msgstr "一键部署"

#: ../../docs/getting_started/workflow/export/one-click_deploy.rst:7
msgid "Sounds good, what is it?"
msgstr "听起来不错，这是什么？"

#: ../../docs/getting_started/workflow/export/one-click_deploy.rst:9
msgid ""
"This feature will pop up automatically once a platform is properly "
"configured and a supported device is connected to the computer. Since things "
"can go wrong at many levels (platform may not be configured correctly, SDK "
"may be incorrectly installed, device may be improperly configured, kitty ate "
"the USB cable, etc.), it's good to let the user know that it exists."
msgstr ""
"正确配置平台并将支持的设备连接到计算机后，此功能将自动弹出。 由于在许多层面上"
"可能出现问题(平台可能未正确配置，SDK可能安装不正确，设备可能配置不当，小猫吃"
"了USB线等)，最好让用户知道它存在。"

#: ../../docs/getting_started/workflow/export/one-click_deploy.rst:16
msgid ""
"Some platforms (at the time of this writing, only Android and Blackberry 10) "
"can detect when a USB device is connected to the computer, and offer the "
"user to automatically export, install and run the project (in debug mode) on "
"the device. This feature is called, in industry buzz-words, \"One Click "
"Deploy\" (though, it's technically two clicks...)."
msgstr ""
"某些平台(在撰写本文时，只有Android和Blackberry 10)可以检测USB设备何时连接到计"
"算机，并为用户提供在设备上自动导出，安装和运行项目(在调试模式下)。 在行业热门"
"话题中，这个功能被称为“一键部署”(但是，从技术上讲，这是两次点击......)。"

#: ../../docs/getting_started/workflow/export/one-click_deploy.rst:23
msgid "Steps for one-click deploy"
msgstr "一键部署的步骤"

#: ../../docs/getting_started/workflow/export/one-click_deploy.rst:25
msgid "Configure target platform."
msgstr "配置目标平台。"

#: ../../docs/getting_started/workflow/export/one-click_deploy.rst:26
msgid ""
"Configure device (make sure it's in developer mode, likes the computer, usb "
"cable is plugged, usb is recognized, etc.)."
msgstr ""
"配置设备(确保它处于开发人员模式，就像计算机，usb被识别，usb电缆被插入等)。"

#: ../../docs/getting_started/workflow/export/one-click_deploy.rst:28
msgid "Connect the device.."
msgstr "连接设备.."

#: ../../docs/getting_started/workflow/export/one-click_deploy.rst:29
msgid "And voilà!"
msgstr "瞧！"

#: ../../docs/getting_started/workflow/export/one-click_deploy.rst:33
msgid "Click once.. and deploy!"
msgstr "点击一次..然后部署！"

#: ../../docs/getting_started/workflow/export/changing_application_icon_for_windows.rst:4
msgid "Changing application icon for Windows"
msgstr "更改Windows的应用程序图标"

#: ../../docs/getting_started/workflow/export/changing_application_icon_for_windows.rst:6
msgid ""
"By default, the exported project's icon will be the Godot icon. You will "
"most likely want to change that for your project. There are two types of "
"icons that can be changed on Windows: the file icon and the taskbar icon."
msgstr ""
"默认情况下，导出项目的图标将是Godot图标。 您很可能想要更改它。 在Windows上可"
"以更改两种类型的图标:文件图标和任务栏图标。"

#: ../../docs/getting_started/workflow/export/changing_application_icon_for_windows.rst:11
msgid "Changing the taskbar icon"
msgstr "更改任务栏图标"

#: ../../docs/getting_started/workflow/export/changing_application_icon_for_windows.rst:13
msgid ""
"The taskbar icon is the icon that shows up on the taskbar when your project "
"is running."
msgstr "任务栏图标是项目运行时显示在任务栏上的图标。"

#: ../../docs/getting_started/workflow/export/changing_application_icon_for_windows.rst:18
msgid ""
"To change the taskbar icon, go to **Project → Project Settings → Application "
"→ Config → Icon**. Click on the folder icon and select your desired icon."
msgstr ""
"要更改任务栏图标，请转到 **项目→项目设置→应用程序→配置→图标** 。 单击文件夹图"
"标，然后选择所需的图标。"

#: ../../docs/getting_started/workflow/export/changing_application_icon_for_windows.rst:22
msgid "This is also the icon that gets displayed in the Godot project list."
msgstr "这也是Godot项目列表中显示的图标。"

#: ../../docs/getting_started/workflow/export/changing_application_icon_for_windows.rst:27
msgid "Changing the file icon"
msgstr "更改文件图标"

#: ../../docs/getting_started/workflow/export/changing_application_icon_for_windows.rst:29
msgid ""
"The file icon is the icon of the executable that you click on to start the "
"project."
msgstr "文件图标是您单击以启动游戏的可执行文件的图标。"

#: ../../docs/getting_started/workflow/export/changing_application_icon_for_windows.rst:34
msgid ""
"Before selecting it in the export options, you will need to install an extra "
"tool called **rcedit**. You can download it `here <https://github.com/"
"electron/rcedit/releases>`_."
msgstr ""
"在导出选项中选择它之前，您需要安装一个名为 **rcedit** 的工具。 您可以在 `这"
"里 <https://github.com/electron/rcedit/releases>`_ 下载它。"

#: ../../docs/getting_started/workflow/export/changing_application_icon_for_windows.rst:38
msgid ""
"After downloading, you need to tell Godot the path to the rcedit executable "
"on your computer. Go to **Editor → Editor Settings → Export → Windows**. "
"Click on the folder icon for the **rcedit** entry. Navigate to and select "
"the rcedit executable."
msgstr ""
"下载后，您需要告诉Godot计算机上rcedit可执行文件的路径。 转到 **编辑器→编辑器"
"设置→导出→Windows** 。 单击 **rcedit** 条目的文件夹图标。 导航到并选择rcedit"
"可执行文件。"

#: ../../docs/getting_started/workflow/export/changing_application_icon_for_windows.rst:44
msgid ""
"Linux and macOS users will also need to install `WINE <https://www.winehq."
"org/>`_ to use rcedit."
msgstr ""
"Linux和macOS用户还需要安装 `WINE <https://www.winehq.org/>`_ 才能使用rcedit。"

#: ../../docs/getting_started/workflow/export/changing_application_icon_for_windows.rst:49
msgid ""
"You should now have everything in place to change the file icon. To do that, "
"you will need to specify the icon when exporting. Go to **Project → "
"Export**. Assuming you have already created a Windows Desktop preset, select "
"your icon in ICO format in the **Application → Icon** field."
msgstr ""
"您现在应该已准备好所有内容来更改文件图标。 为此，您需要在导出时指定图标。 转"
"到 **项目→导出** 。 假设您已经创建了Windows桌面预设，请在 **应用程序→图标** "
"字段中选择ICO格式的图标。"

#: ../../docs/getting_started/workflow/export/changing_application_icon_for_windows.rst:55
msgid ""
"You can use software such as GIMP to export an ICO image. For more "
"information, please refer to `this tutorial <http://skyboygames.com/easily-"
"create-a-windows-app-icon-with-gimp/>`_."
msgstr ""
"您可以使用GIMP等软件导出ICO图像。 有关更多信息，请参阅 `本教程 <http://"
"skyboygames.com/easily-create-a-windows-app-icon-with-gimp/>`_ 。"

#: ../../docs/getting_started/workflow/export/changing_application_icon_for_windows.rst:62
msgid "Testing the result"
msgstr "测试结果"

#: ../../docs/getting_started/workflow/export/changing_application_icon_for_windows.rst:64
msgid ""
"You can now export the project. If it worked correctly, you should see this:"
msgstr "您现在可以导出项目了。 如果它正常工作，您应该看到:"

#: ../../docs/getting_started/workflow/export/changing_application_icon_for_windows.rst:69
msgid "ICO file requirements"
msgstr "ICO文件要求"

#: ../../docs/getting_started/workflow/export/changing_application_icon_for_windows.rst:71
msgid ""
"Regardless of which program you use to create your `ICO file <https://en."
"wikipedia.org/wiki/ICO_(file_format)>`_, there are some requirements to "
"ensure the icon (and your executable) works on Windows."
msgstr ""
"无论您使用哪个程序创建 `ICO文件 <https://en.wikipedia.org/wiki/"
"ICO_(file_format)>`_ ，都有一些要求可以确保图标(和您的可执行文件)在Windows上"
"运行。"

#: ../../docs/getting_started/workflow/export/changing_application_icon_for_windows.rst:75
msgid ""
"This is a bit tricky, as can be seen in the following Stack Overflow "
"threads: `one <https://stackoverflow.com/q/3236115/>`_, `two <https://"
"stackoverflow.com/q/40749785/>`_."
msgstr ""
"这有点棘手，可以在下面的Stack Overflow线程中看到: `one <https://"
"stackoverflow.com/q/3236115/>`_ , `two <https://stackoverflow.com/q/40749785/"
">`_ 。"

#: ../../docs/getting_started/workflow/export/changing_application_icon_for_windows.rst:79
msgid ""
"Your ICO file should at least contain icons in the following resolutions: "
"16×16, 48×48 and 256×256."
msgstr "您的ICO文件至少应包含以下分辨率的图标:16×16,88×48和256×256。"

#: ../../docs/getting_started/workflow/export/changing_application_icon_for_windows.rst:82
msgid ""
"If you want to fully support high-DPI screens, this is the full list of "
"supported icon sizes on Windows 10: 16, 20, 24, 28, 30, 31, 32, 40, 42, 47, "
"48, 56, 60, 63, 84 and one larger than 255 pixels (such as 256, 512 or 1024)."
msgstr ""
"如果您想完全支持高DPI屏幕，这是Windows 10上支持的图标大小的完整列表:16, 20, "
"24, 28, 30, 31, 32, 40, 42, 47, 48, 56, 60, 63, 84 和一个大于255像素(例如"
"256,512或1024)。"

#: ../../docs/getting_started/workflow/export/changing_application_icon_for_windows.rst:87
msgid ""
"It is also possible to convert a PNG image to an hiDPI-friendly ICO file "
"using this `ImageMagick <https://www.imagemagick.org/>`_ command:"
msgstr ""
"也可以使用这个 `ImageMagick <https://www.imagemagick.org/>`_ 命令将PNG图像转"
"换为hiDPI友好的ICO文件:"

#: ../../docs/getting_started/workflow/best_practices/introduction_best_practices.rst:6
msgid ""
"This tutorial series aims to illustrate intended Godot workflows, i.e. the "
"\"best practices\" of defining one's game API. Godot allows for a great "
"amount of flexibility in how one designs a project's code and scene "
"structure. Each method will have its own advantages and disadvantages, so "
"outlining the best practices should help users feel less confused as they "
"further explore Godot's depth."
msgstr ""
"本教程系列旨在讲解Godot预期的工作流程，换言之，就是定义一个游戏API的“最佳实"
"践”。Godot允许我们设计项目代码和场景结构时注入大量的灵活性。每个方法都有其自"
"身的优势和缺点，因此概述最佳实践有助于用户在未来探索Godot的道路上消解困惑。"

#: ../../docs/getting_started/workflow/best_practices/introduction_best_practices.rst:13
msgid ""
"This series is also designed to help get users thinking about the best way "
"to reason about best practices. It would be impossible to give a "
"comprehensive overview of what one should do for any arbitrary design "
"decision. As such, each article breaks problems down into the fundamental "
"questions they pose, suggests the available solutions, analyzes the "
"advantages and disadvantages of each option, and then highlights the best "
"course of action depending on the circumstances."
msgstr ""
"本系列也意在帮助用户考虑如何以最好的方式去解读这种实践。我们无法给出一个人在"
"任意一种项目设计决策中的普适性概览，正因如此，每一篇文章会把问题分解成它们自"
"身提出的多个基本问题，并建议其可行的解决方案，分析各种选择的利弊，并之后依实"
"际情况强调采取最佳策略。"

#: ../../docs/getting_started/workflow/best_practices/introduction_best_practices.rst:21
msgid ""
"While the articles in this series are largely topic-directed, it is "
"recommended that users begin with the :ref:`doc_what_are_godot_classes` "
"article. It is from there that the \"best practices\" for the rest of the "
"engine become more clear, based on established OOP practices."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/what_are_godot_classes.rst:4
msgid "What are Godot classes really?"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/what_are_godot_classes.rst:6
msgid ""
"Godot offers two main means of creating types: scripts and scenes. Both of "
"these represent a \"class\" since Godot revolves around Object-Oriented "
"design. *How* they do this may not be clear to beginner or intermediate "
"users though."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/what_are_godot_classes.rst:11
msgid ""
"Godot Engine provides classes out-of-the-box (like :ref:`Node "
"<class_Node>`), but user-created types are not actually classes. Instead "
"they are resources that tell the engine a sequence of initializations to "
"perform on an engine class."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/what_are_godot_classes.rst:16
msgid ""
"Godot's internal classes have methods that register a class's data with a :"
"ref:`ClassDB <class_ClassDB>`. This database provides runtime access to "
"class information (also called \"reflection\"). Things stored in the ClassDB "
"include, among other things..."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/what_are_godot_classes.rst:21
#, fuzzy
msgid "properties"
msgstr "节点属性"

#: ../../docs/getting_started/workflow/best_practices/what_are_godot_classes.rst:23
#, fuzzy
msgid "methods"
msgstr "'method'"

#: ../../docs/getting_started/workflow/best_practices/what_are_godot_classes.rst:25
#, fuzzy
msgid "constants"
msgstr "常量"

#: ../../docs/getting_started/workflow/best_practices/what_are_godot_classes.rst:27
#, fuzzy
msgid "signals"
msgstr "signal"

#: ../../docs/getting_started/workflow/best_practices/what_are_godot_classes.rst:29
msgid ""
"Furthermore, this ClassDB is what Objects actually check against when "
"performing any operation. Access a property? Call a method? Emit a signal? "
"It will check the database's records (and the records of the Object's base "
"types) to see if the Object supports the operation. Every C++ Object defines "
"a static `_bind_methods()` function that describes what C++ content it "
"registers to the database and how."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/what_are_godot_classes.rst:36
msgid ""
"So, if the engine provides all of this data at startup, then how does a user "
"define their own data? It'd be nice if users could define a custom set of "
"data to be appended to an object's data. That way, users could inject their "
"own properties and methods into the engine's Object query requests."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/what_are_godot_classes.rst:41
msgid ""
"*This* is what a :ref:`Script <class_Script>` is. Objects check their "
"attached script before the database, so scripts can even override methods. "
"If a script defines a `_get_property_list()` method, that data is appended "
"to the list of properties the Object fetches from the ClassDB. The same "
"holds true for other declarative code."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/what_are_godot_classes.rst:47
msgid ""
"This can lead to some users' confusion when they see a script as being a "
"class unto itself. In reality, the engine just auto-instantiates the base "
"engine class and then adds the script to that object. This then allows the "
"Object to defer to the Script's content where the engine logic deems "
"appropriate."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/what_are_godot_classes.rst:53
msgid ""
"A problem does present itself though. As the size of Objects increases, the "
"scripts' necessary size to create them grows much, much larger. Creating "
"node hierarchies demonstrates this. Each individual Node's logic could be "
"several hundred lines of code in length."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/what_are_godot_classes.rst:58
msgid "let's see a simple example of creating a single Node as a child."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/what_are_godot_classes.rst:98
msgid ""
"Notice that only two pieces of declarative code are involved in the creation "
"of this child node: the variable declaration and the constructor "
"declaration. Everything else about the child must be setup using imperative "
"code. However, script code is much slower than engine C++ code. Each change "
"must make a separate call to the scripting API which means a lot of C++ "
"\"lookups\" within data structures to find the corresponding logic to "
"execute."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/what_are_godot_classes.rst:106
msgid ""
"To help offload the work, it would be convenient if one could batch up all "
"operations involved in creating and setting up node hierarchies. The engine "
"could then handle the construction using its fast C++ code, and the script "
"code would be free from the perils of imperative code."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/what_are_godot_classes.rst:111
msgid ""
"*This* is what a scene (:ref:`PackedScene <class_PackedScene>`) is: a "
"resource that provides an advanced \"constructor\" serialization which is "
"offloaded to the engine for batch processing."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/what_are_godot_classes.rst:115
msgid ""
"Now, why is any of this important to scene organization? Because one must "
"understand that scenes *are* objects. One often pairs a scene with a "
"scripted root node that makes use of the sub-nodes. This means that the "
"scene is often an extension of the script's declarative code."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/what_are_godot_classes.rst:120
msgid "It helps to define..."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/what_are_godot_classes.rst:122
#, fuzzy
msgid "what objects are available to the script?"
msgstr "脚本的作用"

#: ../../docs/getting_started/workflow/best_practices/what_are_godot_classes.rst:124
msgid "how are they organized?"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/what_are_godot_classes.rst:126
msgid "how are they initialized?"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/what_are_godot_classes.rst:128
msgid "what connections to each other do they have, if any?"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/what_are_godot_classes.rst:130
msgid ""
"As such, many Object-Oriented principles which apply to \"programming\", i."
"e. scripts, *also* apply to scenes. Some scripts are designed to only work "
"in one scene (which are often bundled into the scene itself). Other scripts "
"are meant to be re-used between scenes."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/what_are_godot_classes.rst:135
msgid ""
"**Regardless, the scene is always an extension of the root script, and can "
"therefore be interpreted as a part of the class.** Most of the points "
"covered in this series will build on this point, so keep it in mind."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:4
#, fuzzy
msgid "Scene organization"
msgstr "项目组织"

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:6
msgid ""
"This article covers topics related to the effective organization of scene "
"content. Which nodes should one use? Where should one place them? How should "
"they interact?"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:11
msgid "How to build relationships effectively"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:13
msgid ""
"When Godot users begin crafting their own scenes, they often run into the "
"following problem:"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:16
msgid ""
"They create their first scene and fill it with content before the creeping "
"sense that they need to split it up into re-usable pieces haunts them. They "
"save branches of their scene into their own scene. However, they then notice "
"that the hard references they were able to rely on before are no longer "
"possible. Re-using the scene in multiple places creates issues because the "
"node paths do not find their targets. Signal connections established in the "
"editor break."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:24
msgid ""
"To fix these problems, one must instantiate the sub-scenes without them "
"requiring details about their environment. One needs to be able to trust "
"that the sub-scene will create itself without being picky about how one uses "
"it."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:29
msgid ""
"One of the biggest things to consider in OOP is maintaining focused, "
"singular-purpose classes with `loose coupling <https://en.wikipedia.org/wiki/"
"Loose_coupling>`_ to other parts of the codebase. This keeps the size of "
"objects small (for maintainability) and improves their reusability so that "
"re-writing completed logic is unnecessary."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:36
msgid ""
"These OOP best practices have *several* ramifications for the best practices "
"in scene structure and script usage."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:39
msgid ""
"**If at all possible, one should design scenes to have no dependencies.** "
"That is, one should create scenes that keep everything they need within "
"themselves."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:43
msgid ""
"If a scene must interact with an external context, experienced developers "
"recommend the use of `Dependency Injection <https://en.wikipedia.org/wiki/"
"Dependency_injection>`_. This technique involves having a high-level API "
"provide the dependencies of the low-level API. Why do this? Because classes "
"which rely on their external environment can inadvertently trigger bugs and "
"unexpected behavior."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:50
msgid ""
"To do this, one must expose data and then rely on a parent context to "
"initialize it:"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:53
msgid ""
"Connect to a signal. Extremely safe, but should use only to \"respond\" to "
"behavior, not start it. Note that signal names are usually past-tense verbs "
"like \"entered\", \"skill_activated\", or \"item_collected\"."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:74
msgid "Call a method. Used to start behavior."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:93
msgid ""
"Initialize a :ref:`FuncRef <class_FuncRef>` property. Safer than a method as "
"ownership of the method is unnecessary. Used to start behavior."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:113
msgid "Initialize a Node or other Object reference."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:132
msgid "Initialize a NodePath."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:151
msgid ""
"These options hide the source of accesses from the child node. This in turn "
"keeps the child **loosely coupled** to its environment. One can re-use it in "
"another context without any extra changes to its API."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:157
msgid ""
"Although the examples above illustrate parent-child relationships, the same "
"principles apply towards all object relations. Nodes which are siblings "
"should only be aware of their hierarchies while an ancestor mediates their "
"communications and references."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:204
msgid ""
"The same principles also apply to non-Node objects that maintain "
"dependencies on other objects. Whichever object actually owns the objects "
"should manage the relationships between them."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:210
msgid ""
"One should favor keeping data in-house (internal to a scene) though as "
"placing a dependency on an external context, even a loosely coupled one, "
"still means that the node will expect something in its environment to be "
"true. The project's design philosophies should prevent this from happening. "
"If not, the code's inherent liabilities will force developers to use "
"documentation to keep track of object relations on a microscopic scale; this "
"is otherwise known as development hell. Writing code that relies on external "
"documentation for one to use it safely is error-prone by default."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:219
msgid ""
"To avoid creating and maintaining such documentation, one converts the "
"dependent node (\"child\" above) into a tool script that implements :ref:"
"`_get_configuration_warning() "
"<class_Node_method__get_configuration_warning>`. Returning a non-empty "
"string from it will make the Scene dock generate a warning icon with the "
"string as a tooltip by the node. This is the same icon that appears for "
"nodes such as the :ref:`Area2D <class_Area2D>` node when it has no child :"
"ref:`CollisionShape2D <class_CollisionShape2D>` nodes defined. The editor "
"then self-documents the scene through the script code. No content "
"duplication via documentation is necessary."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:230
msgid ""
"A GUI like this can better inform project users of critical information "
"about a Node. Does it have external dependencies? Have those dependencies "
"been satisfied? Other programmers, and especially designers and writers, "
"will need clear instructions in the messages telling them what to do to "
"configure it."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:235
msgid ""
"So, why do all this complex switcharoo work? Well, because scenes operate "
"best when they operate alone. If unable to work alone, then working with "
"others anonymously (with minimal hard dependencies, i.e. loose coupling). If "
"the inevitable changes made to a class cause it to interact with other "
"scenes in unforeseen ways, then things break down. A change to one class "
"could result in damaging effects to other classes."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:242
msgid ""
"Scripts and scenes, as extensions of engine classes should abide by *all* "
"OOP principles. Examples include..."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:245
#, fuzzy
msgid "`SOLID <https://en.wikipedia.org/wiki/SOLID>`_"
msgstr "`单例模式 <https://en.wikipedia.org/wiki/Singleton_pattern>`__"

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:246
#, fuzzy
msgid "`DRY <https://en.wikipedia.org/wiki/Don%27t_repeat_yourself>`_"
msgstr "`单例模式 <https://en.wikipedia.org/wiki/Singleton_pattern>`__"

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:247
#, fuzzy
msgid "`KISS <https://en.wikipedia.org/wiki/KISS_principle>`_"
msgstr "`单例模式 <https://en.wikipedia.org/wiki/Singleton_pattern>`__"

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:248
#, fuzzy
msgid "`YAGNI <https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it>`_"
msgstr "`单例模式 <https://en.wikipedia.org/wiki/Singleton_pattern>`__"

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:251
#, fuzzy
msgid "Choosing a node tree structure"
msgstr "节点结构"

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:253
msgid ""
"So, a developer starts work on a game only to stop at the vast possibilities "
"before them. They might know what they want to do, what systems they want to "
"have, but *where* to put them all? Well, how one goes about making their "
"game is always up to them. One can construct node trees in a myriad of ways. "
"But, for those who are unsure, this helpful guide can give them a sample of "
"a decent structure to start with."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:260
msgid ""
"A game should always have a sort of \"entry point\"; somewhere the developer "
"can definitively track where things begin so that they can follow the logic "
"as it continues elsewhere. This place also serves as a bird's eye view to "
"all of the other data and logic in the program. For traditional "
"applications, this would be the \"main\" function. In this case, it would be "
"a Main node."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:266
#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:277
msgid "Node \"Main\" (main.gd)"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:268
msgid ""
"The ``main.gd`` script would then serve as the primary controller of one's "
"game."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:271
msgid ""
"Then one has their actual in-game \"World\" (a 2D or 3D one). This can be a "
"child of Main. In addition, one will need a primary GUI for their game that "
"manages the various menus and widgets the project needs."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:276
msgid "Node2D/Spatial \"World\" (game_world.gd)"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:277
msgid "Control \"GUI\" (gui.gd)"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:279
msgid ""
"When changing levels, one can then swap out the children of the \"World\" "
"node. :ref:`Changing scenes manually <doc_change_scenes_manually>` gives "
"users full control over how their game world transitions."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:283
msgid ""
"The next step is to consider what gameplay systems one's project requires. "
"If one has a system that..."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:286
msgid "tracks all of its data internally"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:287
msgid "should be globally accessible"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:288
msgid "should exist in isolation"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:290
msgid ""
"... then one should create an :ref:`autoload 'singleton' node "
"<doc_singletons_autoload>`."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:294
msgid ""
"For smaller games, a simpler alternative with less control would be to have "
"a \"Game\" singleton that simply calls the :ref:`SceneTree.change_scene() "
"<class_SceneTree_method_change_scene>` method to swap out the main scene's "
"content. This structure more or less keeps the \"World\" as the main game "
"node."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:300
msgid ""
"Any GUI would need to also be a singleton, be transitory parts of the \"World"
"\", or be manually added as a direct child of the root. Otherwise, the GUI "
"nodes would also delete themselves during scene transitions."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:305
msgid ""
"If one has systems that modify other systems' data, one should define those "
"as their own scripts or scenes rather than autoloads. For more information "
"on the reasons, please see the :ref:`'Autoloads vs. Internal Nodes' "
"<doc_autoloads_versus_internal_nodes>` documentation."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:311
msgid ""
"Each subsystem within one's game should have its own section within the "
"SceneTree. One should use parent-child relationships only in cases where "
"nodes are effectively elements of their parents. Does removing the parent "
"reasonably mean that one should also remove the children? If not, then it "
"should have its own place in the hierarchy as a sibling or some other "
"relation."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:319
msgid ""
"In some cases, one needs these separated nodes to *also* position themselves "
"relative to each other. One can use the :ref:`RemoteTransform "
"<class_RemoteTransform>` / :ref:`RemoteTransform2D "
"<class_RemoteTransform2D>` nodes for this purpose. They will allow a target "
"node to conditionally inherit selected transform elements from the Remote\\* "
"node. To assign the ``target`` :ref:`NodePath <class_NodePath>`, use one of "
"the following:"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:327
msgid ""
"A reliable third party, likely a parent node, to mediate the assignment."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:328
msgid ""
"A group, to easily pull a reference to the desired node (assuming there will "
"only ever be one of the targets)."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:331
msgid ""
"When should one do this? Well, it's up to them to decide. The dilemma arises "
"when one must micro-manage when a node must move around the SceneTree to "
"preserve itself. For example..."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:335
msgid "Add a \"player\" node to a \"room\"."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:336
msgid "Need to change rooms, so one must delete the current room."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:337
msgid ""
"Before the room can be deleted, one must preserve and/or move the player."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:339
msgid "Is memory a concern?"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:341
msgid ""
"If not, one can just create the two rooms, move the player and delete the "
"old one. No problem."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:344
msgid "If so, one will need to..."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:346
msgid "Move the player somewhere else in the tree."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:347
#, fuzzy
msgid "Delete the room."
msgstr "删除轨道"

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:348
msgid "Instantiate and add the new room."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:349
#, fuzzy
msgid "Re-add the player."
msgstr "游戏角色"

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:351
msgid ""
"The issue is that the player here is a \"special case\", one where the "
"developers must *know* that they need to handle the player this way for the "
"project. As such, the only way to reliably share this information as a team "
"is to *document* it. Keeping implementation details in documentation however "
"is dangerous. It's a maintenance burden, strains code readability, and "
"bloats the intellectual content of a project unnecessarily."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:358
msgid ""
"In a more complex game with larger assets, it can be a better idea to simply "
"keep the player somewhere else in the SceneTree entirely. This involves..."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:361
msgid "More consistency."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:362
msgid "No \"special cases\" that must be documented and maintained somewhere."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:363
msgid ""
"No opportunity for errors to occur because these details are not accounted "
"for."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:366
msgid ""
"In contrast, if one ever needs to have a child node that does *not* inherit "
"the transform of their parent, one has the following options:"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:369
msgid ""
"The **declarative** solution: place a :ref:`Node <class_Node>` in between "
"them. As nodes with no transform, Nodes will not pass along such information "
"to their children."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:372
msgid ""
"The **imperative** solution: Use the ``set_as_toplevel`` setter for the :ref:"
"`CanvasItem <class_CanvasItem_method_set_as_toplevel>` or :ref:`Spatial "
"<class_Spatial_method_set_as_toplevel>` node. This will make the node ignore "
"its inherited transform."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:379
msgid ""
"If building a networked game, keep in mind which nodes and gameplay systems "
"are relevant to all players versus those just pertinent to the authoritative "
"server. For example, users do not all need to have a copy of every players' "
"\"PlayerController\" logic. Instead, they need only their own. As such, "
"keeping these in a separate branch from the \"world\" can help simplify the "
"management of game connections and the like."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:386
msgid ""
"The key to scene organization is to consider the SceneTree in relational "
"terms rather than spatial terms. Do the nodes need to be dependent on their "
"parent's existence? If not, then they can thrive all by themselves somewhere "
"else. If so, then it stands to reason they should be children of that parent "
"(and likely part of that parent's scene if they aren't already)."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scene_organization.rst:392
msgid ""
"Does this mean nodes themselves are components? Not at all. Godot's node "
"trees form an aggregation relationship, not one of composition. But while "
"one still has the flexibility to move nodes around, it is still best when "
"such moves are unnecessary by default."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:4
msgid "When to use scenes versus scripts"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:6
msgid ""
"We've already covered how scenes and scripts are different. Scripts define "
"an engine class extension with imperative code, scenes with declarative code."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:10
msgid ""
"Each system's capabilities are different as a result. Scenes can define how "
"an extended class initializes, but not what its behavior actually is. Scenes "
"are often used in conjunction with a script so that the scene acts as an "
"extension of the scripts declarative code."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:16
msgid "Anonymous types"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:18
msgid ""
"It *is* possible to completely define a scenes' contents using a script "
"alone. This is, in essence, what the Godot Editor does, only in the C++ "
"constructor of its objects."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:22
msgid ""
"But, choosing which one to use can be a dilemma. Creating script instances "
"is identical to creating in-engine classes whereas handling scenes requires "
"a change in API:"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:59
msgid ""
"Also, scripts will operate a little slower than scenes due to the speed "
"differences between engine and script code. The larger and more complex the "
"node, the more reason there is to build it as a scene."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:64
#, fuzzy
msgid "Named types"
msgstr "着色器类型"

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:66
msgid ""
"In some cases, a user can register a script as a new type within the editor "
"itself. This displays it as a new type in the node or resource creation "
"dialog with an optional icon. In these cases, the user's ability to use the "
"script is much more streamlined. Rather than having to..."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:71
msgid "Know the base type of the script they would like to use."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:73
#, fuzzy
msgid "Create an instance of that base type."
msgstr "创建自定义数据类型"

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:75
#, fuzzy
msgid "Add the script to the node."
msgstr "资源的文字描述。"

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:77
msgid "(Drag-n-drop method)"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:79
#, fuzzy
msgid "Find the script in the FileSystem dock."
msgstr "在编辑器中执行脚本。"

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:81
#, fuzzy
msgid "Drag and drop the script onto the node in the Scene dock."
msgstr "编写脚本，使其能访问场景中的其它节点。"

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:83
msgid "(Property method)"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:85
msgid ""
"Scroll down to the bottom of the Inspector to find the ``script`` property "
"and select it."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:87
#, fuzzy
msgid "Select \"Load\" from the dropdown."
msgstr "在顶部菜单中选择“loc”和“rot”。"

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:89
#, fuzzy
msgid "Select the script from the file dialog."
msgstr "在编辑器中执行脚本。"

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:91
msgid ""
"With a registered script, the scripted type instead becomes a creation "
"option like the other nodes and resources in the system. One need not do any "
"of the above work. The creation dialog even has a search bar to look up the "
"type by name."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:96
#, fuzzy
msgid "There are two systems for registering types..."
msgstr "有6中模式类型:"

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:98
#, fuzzy
msgid ":ref:`Custom Types <doc_making_plugins>`"
msgstr ":ref:`易于书写的着色器 <doc_shading_language>`"

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:100
msgid "Editor-only. Typenames are not accessible at runtime."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:102
msgid "Does not support inherited custom types."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:104
msgid "An initializer tool. Creates the node with the script. Nothing more."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:106
msgid ""
"Editor has no type-awareness of the script or its relationship to other "
"engine types or scripts."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:109
#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:127
msgid "Allows users to define an icon."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:111
msgid ""
"Works for all scripting languages because it deals with Script resources in "
"abstract."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:113
msgid ""
"Set up using :ref:`EditorPlugin.add_custom_type "
"<class_EditorPlugin_method_add_custom_type>`."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:115
msgid ":ref:`Script Classes <doc_scripting_continued_class_name>`"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:117
msgid "Editor and runtime accessible."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:119
#, fuzzy
msgid "Displays inheritance relationships in full."
msgstr "不允许多重继承。"

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:121
msgid ""
"Creates the node with the script, but can also change types or extend the "
"type from the editor."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:124
msgid ""
"Editor is aware of inheritance relationships between scripts, script "
"classes, and engine C++ classes."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:129
msgid ""
"Engine developers must add support for languages manually (both name "
"exposure and runtime accessibility)."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:132
#, fuzzy
msgid "Godot 3.1+ only."
msgstr "在Godot 3.1中:"

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:134
msgid ""
"The Editor scans project folders and registers any exposed names for all "
"scripting languages. Each scripting language must implement its own support "
"for exposing this information."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:138
msgid ""
"Both methodologies add names to the creation dialog, but script classes, in "
"particular, also allow for users to access the typename without loading the "
"script resource. Creating instances and accessing constants or static "
"methods is viable from anywhere."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:143
msgid ""
"With features like these, one may wish their type to be a script without a "
"scene due to the ease of use it grants users. Those developing plugins or "
"creating in-house tools for designers to use will find an easier time of "
"things this way."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:148
msgid ""
"On the downside, it also means having to use largely imperative programming."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:153
#, fuzzy
msgid "In the end, the best approach is to consider the following:"
msgstr "对于本文的其余部分，我们考虑以下场景:"

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:155
msgid ""
"If one wishes to create a basic tool that is going to be re-used in several "
"different projects and which people of all skill levels will likely use "
"(including those who don't label themselves as \"programmers\"), then "
"chances are that it should probably be a script, likely one with a custom "
"name/icon."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:160
msgid ""
"If one wishes to create a concept that is particular to their game, then it "
"should always be a scene. Scenes are easier to track/edit and provide more "
"security than scripts."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:164
msgid ""
"If one would like to give a name to a scene, then they can still sort of do "
"this in 3.1 by declaring a script class and giving it a scene as a constant. "
"The script becomes, in effect, a namespace:"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/autoloads_versus_internal_nodes.rst:4
msgid "Autoloads versus internal nodes"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/autoloads_versus_internal_nodes.rst:6
msgid ""
"Other engines might encourage the use of creating \"manager\" classes that "
"organize lots of functionality into a globally accessible entity. Godot "
"thrives by supporting ways to cut down the size of such objects. Instead it "
"shifts content into individual nodes as much as possible."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/autoloads_versus_internal_nodes.rst:11
msgid ""
"For example, what if a developer is building a platformer and they want to "
"collect coins that play a sound effect? Well, there's a node for that: the :"
"ref:`AudioStreamPlayer <class_AudioStreamPlayer>`. But they notice during "
"their testing that if they \"play\" an AudioStreamPlayer while it is already "
"playing the sound, then the new sound interrupts the first sound, "
"terminating it before it can play."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/autoloads_versus_internal_nodes.rst:18
msgid ""
"Users tend to think the best solution is to make the whole system smarter by "
"making a SoundManager autoload node. It generates a pool of "
"AudioStreamPlayers that cycle through as each new request for sound effects "
"comes in. They then make this SoundManager an autoload so that they can "
"access it from anywhere with `SFX.play(\"coin_pickup.ogg\")`. Little do they "
"know, they've invited a great many complications into their code."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/autoloads_versus_internal_nodes.rst:25
msgid ""
"**global state**: One object is now responsible for all objects' data. If "
"SFX has errors or doesn't have an AudioStreamPlayer available, everything "
"will break."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/autoloads_versus_internal_nodes.rst:29
msgid ""
"**global access**: Now that any object can call `SFX.play(sound_path)` from "
"anywhere, there's no longer an easy way to track where an SFX bug began."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/autoloads_versus_internal_nodes.rst:33
msgid ""
"**global resource allocation**: If all objects' data and processing is "
"centralized from the start, then one must either..."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/autoloads_versus_internal_nodes.rst:36
msgid "risk under-allocating resources which might lead to faulty behavior."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/autoloads_versus_internal_nodes.rst:38
msgid ""
"Ex: Have too few AudioStreamPlayers in the object pool. Sound doesn't play "
"or it interrupts another sound."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/autoloads_versus_internal_nodes.rst:41
msgid "over-allocate resources and use more memory/processing than it needs."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/autoloads_versus_internal_nodes.rst:43
msgid ""
"Ex: Have an arbitrarily large number of AudioStreamPlayers, with many of "
"them idling away and not doing anything."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/autoloads_versus_internal_nodes.rst:46
msgid ""
"have each object that needs an AudioStreamPlayer register exactly how many "
"it needs and for which sounds. This defeats the purpose of using a 3rd party "
"though; it is now coupled to each object, just as a child node would have "
"been. One has added an unnecessary middleman to the equation."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/autoloads_versus_internal_nodes.rst:52
msgid ""
"Contrast this with each scene keeping as many AudioStreamPlayer nodes as it "
"needs within itself and all these problems go away."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/autoloads_versus_internal_nodes.rst:55
msgid ""
"Each scene manages its own state information. If there is a problem with the "
"data, it will only cause issues in that one scene."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/autoloads_versus_internal_nodes.rst:58
msgid ""
"Each scene accesses only its own nodes. Now, if there is a bug, tracing "
"which node is responsible (probably the root node of the scene), and where "
"in the code it's making the problematic call (locate where the code "
"references the given node) is going to be much easier."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/autoloads_versus_internal_nodes.rst:63
msgid ""
"Each scene knows exactly how many resources it needs for the task it "
"performs. No waste of memory or processing due to a lack of information."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/autoloads_versus_internal_nodes.rst:66
msgid ""
"The typical justifications for the Autoload include, \"I have common Xs that "
"involve many nodes across many scenes, and I want each scene to have X.\""
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/autoloads_versus_internal_nodes.rst:69
msgid ""
"If X is a function, then the solution is to create a new type of :ref:`Node "
"<class_Node>` that deals with providing that feature for an individual scene "
"or node subtree."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/autoloads_versus_internal_nodes.rst:73
msgid ""
"If X is data, then the solution is either 1) to create a new type of :ref:"
"`Resource <class_Resource>` to share the data, or 2) to store the data in an "
"object to which each node has access (nodes within a scene can use "
"`get_owner()` to fetch the scene root for example)."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/autoloads_versus_internal_nodes.rst:78
msgid "So when *should* one use an autoload?"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/autoloads_versus_internal_nodes.rst:80
msgid ""
"**Static Data**: if you need static data, i.e. data that should be "
"associated with a class (so there is only ever one copy of the data), then "
"autoloads are good opportunities for that. Static data doesn't exist in "
"Godot's scripting API, so autoload singletons are the next best thing. If "
"one creates a class as an autoload, and never creates another copy of that "
"class within a scene, then it will function in place of a formal singleton "
"API."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/autoloads_versus_internal_nodes.rst:88
msgid ""
"**Convenience**: autoloaded nodes have a global variable for their name "
"generated in GDScript. This can be very convenient for defining objects that "
"should always exist, but which need object instance information. The "
"alternative is to create a namespace script: a script that's purpose is only "
"to load and create constants to access other Script or PackedScene "
"resources, resulting in something like ``MyAutoload.MyNode.new()``."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/autoloads_versus_internal_nodes.rst:95
msgid ""
"Note that the introduction of script classes in Godot 3.1 questions the "
"validity of this reason. With them, one can access scripts using an explicit "
"name from GDScript. Using an autoload to get to a namespace script becomes "
"unnecessary, e.g. ``MyScriptClass.MyPreloadedScript.new()``."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/autoloads_versus_internal_nodes.rst:100
msgid ""
"If the singleton is managing its own information and not invading the data "
"of other objects, then it's a great way to create a \"system\" class that "
"handles a broad-scoped task. For example a targeting system, quest system, "
"or dialogue system would be great use cases of singleton implementations."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/node_alternatives.rst:4
msgid "When and how to avoid using nodes for everything"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/node_alternatives.rst:7
msgid ""
"Nodes are cheap to produce, but even they have their limits. A project may "
"have tens of thousands of nodes all doing things. The more complex their "
"behavior though, the larger the strain each one adds to a project's "
"performance."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/node_alternatives.rst:12
msgid ""
"Godot provides more lightweight objects for creating APIs which nodes use. "
"Be sure to keep these in mind as options when designing how you wish to "
"build your project's features."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/node_alternatives.rst:16
msgid ""
":ref:`Object <class_Object>`: The ultimate lightweight object, the original "
"Object must use manual memory management. With that said, it isn't too "
"difficult to create one's own custom data structures, even node structures, "
"that are also lighter than the :ref:`Node <class_Node>` class."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/node_alternatives.rst:21
msgid ""
"**Example:** See the :ref:`Tree <class_Tree>` node. It supports a high level "
"of customization for a table of content with an arbitrary number of rows and "
"columns. The data that it uses to generate its visualization though is "
"actually a tree of :ref:`TreeItem <class_TreeItem>` Objects."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/node_alternatives.rst:26
msgid ""
"**Advantages:** Simplifying one's API to smaller scoped objects helps "
"improve its accessibility improve iteration time. Rather than working with "
"the entire Node library, one creates an abbreviated set of Objects from "
"which a node can generate and manage the appropriate sub-nodes."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/node_alternatives.rst:31
msgid ""
"One should be careful when handling them. One can store an Object into a "
"variable, but these references can become invalid without warning. For "
"example, if the object's creator decides to delete it out of nowhere, this "
"would trigger an error state when one next accesses it."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/node_alternatives.rst:36
msgid ""
":ref:`Reference <class_Reference>`: Only a little more complex than Object. "
"They track references to themselves, only deleting loaded memory when no "
"further references to themselves exist. These are useful in the majority of "
"cases where one needs data in a custom class."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/node_alternatives.rst:41
msgid ""
"**Example:** See the :ref:`File <class_File>` object. It functions just like "
"a regular Object except that one need not delete it themselves."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/node_alternatives.rst:44
#, fuzzy
msgid "**Advantages:** same as the Object."
msgstr "**优势:**"

#: ../../docs/getting_started/workflow/best_practices/node_alternatives.rst:46
msgid ""
":ref:`Resource <class_Resource>`: Only slightly more complex than Reference. "
"They have the innate ability to serialize/deserialize (i.e. save and load) "
"their object properties to/from Godot resource files."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/node_alternatives.rst:50
msgid ""
"**Example:** Scripts, PackedScene (for scene files), and other types like "
"each of the :ref:`AudioEffect <class_AudioEffect>` classes. Each of these "
"can be save and loaded, therefore they extend from Resource."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/node_alternatives.rst:54
msgid ""
"**Advantages:** Much has :ref:`already been said <doc_resources>` on :ref:"
"`Resource <class_Resource>`'s advantages over traditional data storage "
"methods. In the context of using Resources over Nodes though, their main "
"advantage is in Inspector-compatibility. While nearly as lightweight as "
"Object/Reference, they can still display and export properties in the "
"Inspector. This allows them to fulfill a purpose much like sub-Nodes on the "
"usability front, but also improve performance if one plans to have many such "
"Resources/Nodes in their scenes."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_interfaces.rst:4
#, fuzzy
msgid "Godot interfaces"
msgstr "调整界面"

#: ../../docs/getting_started/workflow/best_practices/godot_interfaces.rst:6
msgid ""
"Often one needs scripts that rely on other objects for features. There are 2 "
"parts to this process:"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_interfaces.rst:9
msgid "Acquiring a reference to the object that presumably has the features."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_interfaces.rst:11
msgid "Accessing the data or logic from the object."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_interfaces.rst:13
msgid "The rest of this tutorial outlines the various ways of doing all this."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_interfaces.rst:16
#, fuzzy
msgid "Acquiring object references"
msgstr "动画面板参考"

#: ../../docs/getting_started/workflow/best_practices/godot_interfaces.rst:18
msgid ""
"For all :ref:`Object <class_Object>`\\s, the most basic way of referencing "
"them is to get a reference to an existing object from another acquired "
"instance."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_interfaces.rst:32
msgid ""
"The same principle applies for :ref:`Reference <class_Reference>` objects. "
"While users often access :ref:`Node <class_Node>` and :ref:`Resource "
"<class_Resource>` this way, alternative measures are available."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_interfaces.rst:36
msgid ""
"Instead of property or method access, one can get Resources by load access."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_interfaces.rst:115
#, fuzzy
msgid "Note the following:"
msgstr "使用以下名称:"

#: ../../docs/getting_started/workflow/best_practices/godot_interfaces.rst:117
msgid "There are many ways in which a language can load such resources."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_interfaces.rst:119
msgid ""
"When designing how objects will access data, don't forget that one can pass "
"resources around as references as well."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_interfaces.rst:122
msgid ""
"Keep in mind that loading a resource fetches the cached resource instance "
"maintained by the engine. To get a new object, one must :ref:`duplicate "
"<class_Resource_method_duplicate>` an existing reference or instantiate one "
"from scratch with ``new()``."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_interfaces.rst:127
msgid "Nodes likewise have an alternative access point: the SceneTree."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_interfaces.rst:242
msgid "Accessing data or logic from an object"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_interfaces.rst:244
msgid ""
"Godot's scripting API is duck-typed. This means that if a script executes an "
"operation, Godot doesn't validate that it supports the operation by "
"**type**. It instead checks that the object **implements** the individual "
"method."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_interfaces.rst:248
msgid ""
"For example, the :ref:`CanvasItem <class_CanvasItem>` class has a "
"``visible`` property. All properties exposed to the scripting API are in "
"fact a setter and getter pair bound to a name. If one tried to access :ref:"
"`CanvasItem.visible <class_CanvasItem_property_visible>`, then Godot would "
"do the following checks, in order:"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_interfaces.rst:254
msgid ""
"If the object has a script attached, it will attempt to set the property "
"through the script. This leaves open the opportunity for scripts to override "
"a property defined on a base object by overriding the setter method for the "
"property."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_interfaces.rst:259
msgid ""
"If the script does not have the property, it performs a HashMap lookup in "
"the ClassDB for the \"visible\" property against the CanvasItem class and "
"all of its inherited types. If found, it will call the bound setter or "
"getter. For more information about HashMaps, see the :ref:`data preferences "
"<doc_data_preferences>` docs."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_interfaces.rst:265
msgid ""
"If not found, it does an explicit check to see if the user wants to access "
"the \"script\" or \"meta\" properties."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_interfaces.rst:268
msgid ""
"If not, it checks for a ``_set``/``_get`` implementation (depending on type "
"of access) in the CanvasItem and its inherited types. These methods can "
"execute logic that gives the impression that the Object has a property. This "
"is also the case with the ``_get_property_list`` method."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_interfaces.rst:273
msgid ""
"Note that this happens even for non-legal symbol names such as in the case "
"of :ref:`TileSet <class_TileSet>`'s \"1/tile_name\" property. This refers to "
"the name of the tile with ID 1, i.e. :ref:`TileSet.tile_get_name(1) "
"<class_TileSet_method_tile_get_name>`."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_interfaces.rst:278
msgid ""
"As a result, this duck-typed system can locate a property either in the "
"script, the object's class, or any class that object inherits, but only for "
"things which extend Object."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_interfaces.rst:282
msgid ""
"Godot provides a variety of options for performing runtime checks on these "
"accesses:"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_interfaces.rst:285
msgid ""
"A duck-typed property access. These will property check (as described "
"above). If the operation isn't supported by the object, execution will halt."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_interfaces.rst:313
msgid ""
"A method check. In the case of :ref:`CanvasItem.visible "
"<class_CanvasItem_property_visible>`, one can access the methods, "
"``set_visible`` and ``is_visible`` like any other method."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_interfaces.rst:445
msgid ""
"Outsource the access to a :ref:`FuncRef <class_FuncRef>`. These may be "
"useful in cases where one needs the max level of freedom from dependencies. "
"In this case, one relies on an external context to setup the method."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_interfaces.rst:504
msgid ""
"These strategies contribute to Godot's flexible design. Between them, users "
"have a breadth of tools to meet their specific needs."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:4
#, fuzzy
msgid "Godot notifications"
msgstr "推送通知"

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:6
msgid ""
"Every Object in Godot implements a :ref:`_notification "
"<class_Object_method__notification>` method. Its purpose is to allow the "
"Object to respond to a variety of engine-level callbacks that may relate to "
"it. For example, if the engine tells a :ref:`CanvasItem <class_CanvasItem>` "
"to \"draw\", it will call ``_notification(NOTIFICATION_DRAW)``."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:13
msgid ""
"Some of these notifications, like draw, are useful to override in scripts. "
"So much so that Godot exposes many of them with dedicated functions:"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:16
msgid "``_ready()`` : NOTIFICATION_READY"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:18
msgid "``_enter_tree()`` : NOTIFICATION_ENTER_TREE"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:20
msgid "``_exit_tree()`` : NOTIFICATION_EXIT_TREE"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:22
msgid "``_process(delta)`` : NOTIFICATION_PROCESS"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:24
msgid "``_physics_process(delta)`` : NOTIFICATION_PHYSICS_PROCESS"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:26
msgid "``_input()`` : NOTIFICATION_INPUT"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:28
msgid "``_unhandled_input()`` : NOTIFICATION_UNHANDLED_INPUT"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:30
msgid "``_draw()`` : NOTIFICATION_DRAW"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:32
msgid ""
"What users might *not* realize is that notifications exist for types other "
"than Node alone:"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:35
msgid ""
":ref:`Object::NOTIFICATION_POSTINITIALIZE "
"<class_Object_constant_NOTIFICATION_POSTINITIALIZE>`: a callback that "
"triggers during object initialization. Not accessible to scripts."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:38
msgid ""
":ref:`Object::NOTIFICATION_PREDELETE "
"<class_Object_constant_NOTIFICATION_PREDELETE>`: a callback that triggers "
"before the engine deletes an Object, i.e. a 'destructor'."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:42
msgid ""
":ref:`MainLoop::NOTIFICATION_WM_MOUSE_ENTER "
"<class_MainLoop_constant_NOTIFICATION_WM_MOUSE_ENTER>`: a callback that "
"triggers when the mouse enters the window in the operating system that "
"displays the game content."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:46
msgid ""
"And many of the callbacks that *do* exist in Nodes don't have any dedicated "
"methods, but are still quite useful."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:49
msgid ""
":ref:`Node::NOTIFICATION_PARENTED "
"<class_Node_constant_NOTIFICATION_PARENTED>`: a callback that triggers "
"anytime one adds a child node to another node."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:52
msgid ""
":ref:`Node::NOTIFICATION_UNPARENTED "
"<class_Node_constant_NOTIFICATION_UNPARENTED>`: a callback that triggers "
"anytime one removes a child node from another node."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:56
msgid ""
":ref:`Popup::NOTIFICATION_POST_POPUP "
"<class_Popup_constant_NOTIFICATION_POST_POPUP>`: a callback that triggers "
"after a Popup node completes any ``popup*`` method. Note the difference from "
"its ``about_to_show`` signal which triggers *before* its appearance."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:61
msgid ""
"One can access all these custom notifications from the universal "
"``_notification`` method."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:65
msgid ""
"Methods in the documentation labeled as \"virtual\" are also intended to be "
"overridden by scripts."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:68
msgid ""
"A classic example is the :ref:`_init <class_Object_method__init>` method in "
"Object. While it has no NOTIFICATION_* equivalent, the engine still calls "
"the method. Most languages (except C#) rely on it as a constructor."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:73
msgid ""
"So, in which situation should one use each of these notifications or virtual "
"functions?"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:77
msgid "_process vs. _physics_process vs. \\*_input"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:79
msgid ""
"Use ``_process`` when one needs a framerate-dependent deltatime between "
"frames. If code that updates object data needs to update as often as "
"possible, this is the right place. Recurring logic checks and data caching "
"often execute here, but it comes down to the frequency at which one needs "
"the evaluations to update. If they don't need to execute every frame, then "
"implementing a Timer-yield-timeout loop is another option."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:97
msgid ""
"Use ``_physics_process`` when one needs a framerate-independent deltatime "
"between frames. If code needs consistent updates over time, regardless of "
"how fast or slow time advances, this is the right place. Recurring kinematic "
"and object transform operations should execute here."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:102
msgid ""
"While it is possible, to achieve the best performance, one should avoid "
"making input checks during these callbacks. ``_process`` and "
"``_physics_process`` will trigger at every opportunity (they do not \"rest\" "
"by default). In contrast, ``*_input`` callbacks will trigger only on frames "
"in which the engine has actually detected the input."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:108
msgid ""
"One can check for input actions within the input callbacks just the same. If "
"one wants to use delta time, one can fetch it from the related deltatime "
"methods as needed."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:156
msgid "_init vs. initialization vs. export"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:158
msgid ""
"If the script initializes its own node subtree, without a scene, that code "
"should execute here. Other property or SceneTree-independent initializations "
"should also run here. This triggers before ``_ready`` or ``_enter_tree``, "
"but after a script creates and initializes its properties."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:163
msgid ""
"Scripts have three types of property assignments that can occur during "
"instantiation:"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:210
msgid ""
"When instantiating a scene, property values will set up according to the "
"following sequence:"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:213
msgid ""
"**Initial value assignment:** instantiation will assign either the "
"initialization value or the init assignment value. Init assignments take "
"priority over initialization values."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:217
msgid ""
"**Exported value assignment:** If instancing from a scene rather than a "
"script, Godot will assign the exported value to replace the initial value "
"defined in the script."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:221
msgid ""
"As a result, instantiating a script versus a scene will affect both the "
"initialization *and* the number of times the engine calls the setter."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:225
msgid "_ready vs. _enter_tree vs. NOTIFICATION_PARENTED"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:227
msgid ""
"When instantiating a scene connected to the first executed scene, Godot will "
"instantiate nodes down the tree (making ``_init`` calls) and build the tree "
"going downwards from the root. This causes ``_enter_tree`` calls to cascade "
"down the tree. Once the tree is complete, leaf nodes call ``_ready``. A node "
"will call this method once all child nodes have finished calling theirs. "
"This then causes a reverse cascade going up back to the tree's root."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:234
msgid ""
"When instantiating a script or a standalone scene, nodes are not added to "
"the SceneTree upon creation, so no ``_enter_tree`` callbacks trigger. "
"Instead, only the ``_init`` and later ``_ready`` calls occur."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:238
msgid ""
"If one needs to trigger behavior that occurs as nodes parent to another, "
"regardless of whether it occurs as part of the main/active scene or not, one "
"can use the :ref:`PARENTED <class_Node_constant_NOTIFICATION_PARENTED>` "
"notification. For example, here is a snippet that connects a node's method "
"to a custom signal on the parent node without failing. Useful on data-"
"centric nodes that one might create at runtime."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:4
#, fuzzy
msgid "Data preferences"
msgstr "参考"

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:6
msgid ""
"Ever wondered whether one should approach problem X with data structure Y or "
"Z? This article covers a variety of topics related to these dilemmas."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:11
msgid ""
"This article makes references to \"[something]-time\" operations. This "
"terminology comes from algorithm analysis' `Big O Notation <https://rob-bell."
"net/2009/06/a-beginners-guide-to-big-o-notation/>`_."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:15
msgid ""
"Long-story short, it describes the worst-case scenario of runtime length. In "
"laymen's terms:"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:18
msgid ""
"\"As the size of a problem domain increases, the runtime length of the "
"algorithm...\""
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:21
msgid "Constant-time, ``O(1)``: \"...does not increase.\""
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:22
msgid "Logarithmic-time, ``O(log n)``: \"...increases at a slow rate.\""
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:23
msgid "Linear-time, ``O(n)``: \"...increases at the same rate.\""
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:24
msgid "Etc."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:26
msgid ""
"Imagine if one had to process 3 million data points within a single frame. "
"It would be impossible to craft the feature with a linear-time algorithm "
"since the sheer size of the data would increase the runtime far beyond the "
"time allotted. In comparison, using a constant-time algorithm could handle "
"the operation without issue."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:32
msgid ""
"By and large, developers want to avoid engaging in linear-time operations as "
"much as possible. But, if one keeps the scale of a linear-time operation "
"small, and if one does not need to perform the operation often, then it may "
"be acceptable. Balancing these requirements and choosing the right "
"algorithm / data structure for the job is part of what makes programmers' "
"skills valuable."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:40
msgid "Array vs. Dictionary vs. Object"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:42
msgid ""
"Godot stores all variables in the scripting API in the `Variant <https://"
"docs.godotengine.org/en/latest/development/cpp/variant_class.html>`_ class. "
"Variants can store Variant-compatible data structures such as :ref:`Array "
"<class_Array>` and :ref:`Dictionary <class_Dictionary>` as well as :ref:"
"`Object <class_Object>` s."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:48
msgid ""
"Godot implements Array as a ``Vector<Variant>``. The engine stores the Array "
"contents in a contiguous section of memory, i.e. they are in a row adjacent "
"to each other."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:53
msgid ""
"For those unfamiliar with C++, a Vector is the name of the array object in "
"traditional C++ libraries. It is a \"templated\" type, meaning that its "
"records can only contain a particular type (denoted by angled brackets). So, "
"for example, a :ref:`PoolStringArray <class_PoolStringArray>` would be "
"something like a ``Vector<String>``."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:60
msgid "Contiguous memory stores imply the following operation performance:"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:62
msgid "**Iterate:** Fastest. Great for loops."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:64
msgid "Op: All it does is increment a counter to get to the next record."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:66
msgid "**Insert, Erase, Move:** Position-dependent. Generally slow."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:68
msgid ""
"Op: Adding/removing/moving content involves moving the adjacent records over "
"(to make room / fill space)."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:71
msgid "Fast add/remove *from the end*."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:73
msgid "Slow add/remove *from an arbitrary position*."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:75
msgid "Slowest add/remove *from the front*."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:77
msgid "If doing many inserts/removals *from the front*, then..."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:79
#, fuzzy
msgid "invert the array."
msgstr "int array"

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:81
msgid "do a loop which executes the Array changes *at the end*."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:83
#, fuzzy
msgid "re-invert the array."
msgstr "int array"

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:85
msgid ""
"This makes only 2 copies of the array (still constant time, but slow) versus "
"copying roughly 1/2 of the array, on average, N times (linear time)."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:88
msgid ""
"**Get, Set:** Fastest *by position*. Ex. can request 0th, 2nd, 10th record, "
"etc. but cannot specify which record you want."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:91
msgid "Op: 1 addition operation from array start position up to desired index."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:93
msgid "**Find:** Slowest. Identifies the index/position of a value."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:95
msgid ""
"Op: Must iterate through array and compare values until one finds a match."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:97
msgid ""
"Performance is also dependent on whether one needs an exhaustive search."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:100
msgid ""
"If kept ordered, custom search operations can bring it to logarithmic time "
"(relatively fast). Laymen users won't be comfortable with this though. Done "
"by re-sorting the Array after every edit and writing an ordered-aware search "
"algorithm."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:105
msgid ""
"Godot implements Dictionary as an ``OrderedHashMap<Variant, Variant>``. The "
"engine stores a giant array (initialized to 1000 records) of key-value "
"pairs. When one attempts to access a value, they provide it a key. It then "
"*hashes* the key, i.e. converts it into a number. The \"hash\" becomes the "
"index into the array, giving the OHM a quick lookup for the value within the "
"conceptual \"table\" of keys mapped to values."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:112
msgid ""
"Hashes are to reduce the chance of a key collision. If one occurs, the table "
"must recalculate another index for the value that takes the previous "
"position into account. In all, this results in constant-time access to all "
"records at the expense of memory and some minor operational efficiency."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:117
msgid "Hashing every key an arbitrary number of times."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:119
msgid ""
"Hash operations are constant-time, so even if an algorithm must do more than "
"one, as long as the number of hash calculations doesn't become too dependent "
"on the density of the table, things will stay fast. Which leads to..."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:124
msgid "Maintaining a huge size for the table."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:126
msgid ""
"The reason it starts with 1000 records, and the reason it forces large gaps "
"of unused memory interspersed in the table is to minimize hash collisions "
"and maintain the speed of the accesses."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:130
msgid ""
"As one might be able to tell, Dictionaries specialize in tasks that Arrays "
"aren't. An overview of their operational details is as follows:"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:133
msgid "**Iterate:** Fast."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:135
msgid ""
"Op: Iterate over the map's internal vector of hashes. Return each key. "
"Afterwards, users then use the key to jump to and return the desired value."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:139
msgid "**Insert, Erase, Move:** Fastest."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:141
msgid ""
"Op: Hash the given key. Do 1 addition operation to look up the appropriate "
"value (array start + offset). Move is two of these (one insert, one erase). "
"The map must do some maintenance to preserve its capabilities:"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:146
msgid "update ordered List of records."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:148
msgid "determine if table density mandates a need to expand table capacity."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:150
msgid ""
"The Dictionary remembers in what order users inserted its keys. This enables "
"it to execute reliable iterations."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:153
msgid "**Get, Set:** Fastest. Same as a lookup *by key*."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:155
msgid "Op: Same as insert/erase/move."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:157
msgid "**Find:** Slowest. Identifies the key of a value."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:159
msgid ""
"Op: Must iterate through records and compare the value until a match is "
"found."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:162
msgid ""
"Note that Godot does not provide this feature out-of-the-box (because they "
"aren't meant for this task)."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:165
msgid ""
"Godot implements Objects as stupid, but dynamic containers of data content. "
"Objects query data sources when posed questions. For example, to answer the "
"question, \"do you have a property called, 'position'?\", it might ask its :"
"ref:`script <class_Script>` or the :ref:`ClassDB <class_ClassDB>`. One can "
"find more information about what objects are and how they work in the :ref:"
"`doc_what_are_godot_classes` article."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:172
msgid ""
"The important detail here is the complexity of the Object's task. Every time "
"it performs one of these multi-source queries, it runs through *several* "
"iteration loops and HashMap lookups. What's more, the queries are linear-"
"time operations dependent on the Object's inheritance hierarchy size. If the "
"class the Object queries (it's current class) doesn't find anything, the "
"request defers to the next base class, all the way up until the original "
"Object class. While these are each fast operations in isolation, the fact "
"that it must make so many checks is what makes them slower than both of the "
"alternatives for looking up data."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:184
msgid ""
"When developers mention how slow the scripting API is, it is this chain of "
"queries they refer to. Compared to compiled C++ code where the application "
"knows exactly where to go to find anything, it is inevitable that scripting "
"API operations will take much longer. They must locate the source of any "
"relevant data before they can attempt to access it."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:190
msgid ""
"The reason GDScript is slow is because every operation it performs passes "
"through this system."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:193
msgid ""
"C# can process some content at higher speeds via more optimized bytecode. "
"But, if the C# script calls into an engine class' content or if the script "
"tries to access something external to it, it will go through this pipeline."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:198
msgid ""
"NativeScript C++ goes even further and keeps everything internal by default. "
"Calls into external structures will go through the scripting API. In "
"NativeScript C++, registering methods to expose them to the scripting API is "
"a manual task. It is at this point that external, non-C++ classes will use "
"the API to locate them."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:204
msgid ""
"So, assuming one extends from Reference to create a data structure, like an "
"Array or Dictionary, why choose an Object over the other two options?"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:207
msgid ""
"**Control:** With objects comes the ability to create more sophisticated "
"structures. One can layer abstractions over the data to ensure the external "
"API doesn't change in response to internal data structure changes. What's "
"more, Objects can have signals, allowing for reactive behavior."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:212
msgid ""
"**Clarity:** Objects are a reliable data source when it comes to the data "
"that scripts and engine classes define for them. Properties may not hold the "
"values one expects, but one doesn't need to worry about whether the property "
"exists in the first place."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:217
msgid ""
"**Convenience:** If one already has a similar data structure in mind, then "
"extending from an existing class makes the task of building the data "
"structure much easier. In comparison, Arrays and Dictionaries don't fulfill "
"all use cases one might have."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:222
msgid ""
"Objects also give users the opportunity to create even more specialized data "
"structures. With it, one can design their own List, Binary Search Tree, "
"Heap, Splay Tree, Graph, Disjoint Set, and any host of other options."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:226
msgid ""
"\"Why not use Node for tree structures?\" one might ask. Well, the Node "
"class contains things that won't be relevant to one's custom data structure. "
"As such, it can be helpful to construct one's own node type when building "
"tree structures."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:270
msgid ""
"From here, one can then create their own structures with specific features, "
"limited only by their imagination."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:274
msgid "Enumerations: int vs. string"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:276
msgid ""
"Most languages offer an enumeration type option. GDScript is no different, "
"but unlike most other languages, it allows one to use either integers or "
"strings for the enum values. The question then arises, \"which should one "
"use?\""
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:281
msgid ""
"The short answer is, \"whichever you are more comfortable with.\" This is a "
"feature specific to GDScript and not Godot scripting in general; The "
"languages prioritizes usability over performance."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:285
msgid ""
"On a technical level, integer comparisons (constant-time) will happen faster "
"than string comparisons (linear-time). If one wants to keep up other "
"languages' conventions though, then one should use integers."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:289
msgid ""
"The primary issue with using integers comes up when one wants to *print* an "
"enum value. As integers, attempting to print MY_ENUM will print ``5`` or "
"what-have-you, rather than something like ``\"MyEnum\"``. To print an "
"integer enum, one would have to write a Dictionary that maps the "
"corresponding string value for each enum."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:295
msgid ""
"If the primary purpose of using an enum is for printing values and one "
"wishes to group them together as related concepts, then it makes sense to "
"use them as strings. That way, a separate data structure to execute on the "
"printing is unnecessary."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:301
msgid ""
"AnimatedTexture vs. AnimatedSprite vs. AnimationPlayer vs. AnimationTree"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:303
msgid ""
"Under what circumstances should one use each of Godot's animation classes? "
"The answer may not be immediately clear to new Godot users."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:306
msgid ""
":ref:`AnimatedTexture <class_AnimatedTexture>` is a texture that the engine "
"draws as an animated loop rather than a static image. Users can manipulate..."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:310
msgid "the rate at which it moves across each section of the texture (fps)."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:312
msgid "the number of regions contained within the texture (frames)."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:314
msgid ""
"Godot's :ref:`VisualServer <class_VisualServer>` then draws the regions in "
"sequence at the prescribed rate. The good news is that this involves no "
"extra logic on the part of the engine. The bad news is that users have very "
"little control."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:319
msgid ""
"Also note that AnimatedTexture is a :ref:`Resource <class_Resource>` unlike "
"the other :ref:`Node <class_Node>` objects discussed here. One might create "
"a :ref:`Sprite <class_Sprite>` node that uses AnimatedTexture as its "
"texture. Or (something the others can't do) one could add AnimatedTextures "
"as tiles in a :ref:`TileSet <class_TileSet>` and integrate it with a :ref:"
"`TileMap <class_TileMap>` for many auto-animating backgrounds that all "
"render in a single batched draw call."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:327
msgid ""
"The AnimatedSprite node, in combination with the :ref:`SpriteFrames "
"<class_SpriteFrames>` resource, allows one to create a variety of animation "
"sequences through spritesheets, flip between animations, and control their "
"speed, regional offset, and orientation. This makes them well-suited to "
"controlling 2D frame-based animations."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:333
msgid ""
"If one needs trigger other effects in relation to animation changes (for "
"example, create particle effects, call functions, or manipulate other "
"peripheral elements besides the frame-based animation), then will need to "
"use an :ref:`AnimationPlayer <class_AnimationPlayer>` node in conjunction "
"with the AnimatedSprite."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:339
msgid ""
"AnimationPlayers are also the tool one will need to use if they wish to "
"design more complex 2D animation systems, such as..."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:342
msgid "**Cut-Out animations:** editing sprites' transforms at runtime."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:344
msgid ""
"**2D Mesh animations:** defining a region for the sprite's texture and "
"rigging a skeleton to it. Then one animates the bones which stretch and bend "
"the texture in proportion to the bones' relationships to each other."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:349
msgid "A mix of the above."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/data_preferences.rst:351
msgid ""
"While one needs an AnimationPlayer to design each of the individual "
"animation sequences for a game, it can also be useful to combine animations "
"for blending, i.e. enabling smooth transitions between these animations. "
"There may also be a hierarchical structure between animations that one plans "
"out for their object. These are the cases where the :ref:`AnimationTree "
"<class_AnimationTree>` shines. One can find an in-depth guide on using the "
"AnimationTree :ref:`here <doc_animation_tree>`."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/logic_preferences.rst:4
#, fuzzy
msgid "Logic preferences"
msgstr "参考"

#: ../../docs/getting_started/workflow/best_practices/logic_preferences.rst:6
msgid ""
"Ever wondered whether one should approach problem X with strategy Y or Z? "
"This article covers a variety of topics related to these dilemmas."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/logic_preferences.rst:10
#, fuzzy
msgid "Loading vs. preloading"
msgstr "加载场景"

#: ../../docs/getting_started/workflow/best_practices/logic_preferences.rst:12
msgid ""
"In GDScript, there exists the global :ref:`preload "
"<class_@GDScript_method_preload>` method. It loads resources as early as "
"possible to front-load the \"loading\" operations and avoid loading "
"resources while in the middle of performance-sensitive code."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/logic_preferences.rst:17
msgid ""
"Its counterpart, the :ref:`load <class_@GDScript_method_load>` method, loads "
"a resource only when it reaches the load statement. That is, it will load a "
"resource in-place which can cause slowdowns then it occurs in the middle of "
"sensitive processes. The ``load`` function is also an alias for :ref:"
"`ResourceLoader.load(path) <class_ResourceLoader_method_load>` which is "
"accessible to *all* scripting languages."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/logic_preferences.rst:24
msgid ""
"So, when exactly does preloading occur versus loading, and when should one "
"use either? Let's see an example:"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/logic_preferences.rst:88
msgid ""
"Preloading allows the script to handle all the loading the moment one loads "
"the script. Preloading is useful, but there are also times when one doesn't "
"wish for it. To distinguish these situations, there are a few things one can "
"consider:"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/logic_preferences.rst:93
msgid ""
"If one cannot determine when the script might load, then preloading a "
"resource, especially a scene or script, could result in further loads one "
"does not expect. This could lead to unintentional, variable-length load "
"times on top of the original script's load operations."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/logic_preferences.rst:98
msgid ""
"If something else could replace the value (like a scene's exported "
"initialization), then preloading the value has no meaning. This point isn't "
"a significant factor if one intends to always create the script on its own."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/logic_preferences.rst:102
msgid ""
"If one wishes only to 'import' another class resource (script or scene), "
"then using a preloaded constant is often the best course of action. However, "
"in exceptional cases, one my wish not to do this:"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/logic_preferences.rst:106
msgid ""
"If the 'imported' class is liable to change, then it should be a property "
"instead, initialized either using an ``export`` or a ``load`` (and perhaps "
"not even initialized until later)."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/logic_preferences.rst:110
msgid ""
"If the script requires a great many dependencies, and one does not wish to "
"consume so much memory, then one may wish to, load and unload various "
"dependencies at runtime as circumstances change. If one preloads resources "
"into constants, then the only way to unload these resources would be to "
"unload the entire script. If they are instead loaded properties, then one "
"can set them to ``null`` and remove all references to the resource entirely "
"(which, as a :ref:`Reference <class_Reference>`-extending type, will cause "
"the resources to delete themselves from memory)."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/logic_preferences.rst:121
msgid "Large levels: static vs. dynamic"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/logic_preferences.rst:123
msgid ""
"If one is creating a large level, which circumstances are most appropriate? "
"Should they create the level as one static space? Or should they load the "
"level in pieces and shift the world's content as needed?"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/logic_preferences.rst:127
msgid ""
"Well, the simple answer is , \"when the performance requires it.\" The "
"dilemma associated with the two options is one of the age-old programming "
"choices: does one optimize memory over speed, or vice versa?"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/logic_preferences.rst:131
msgid ""
"The naive answer is to use a static level that loads everything at once. "
"But, depending on the project, this could consume a large amount of memory. "
"Wasting users' RAM leads to programs running slow or outright crashing from "
"everything else the computer tries to do at the same time."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/logic_preferences.rst:136
msgid ""
"No matter what, one should break larger scenes into smaller ones (to aid in "
"reusability of assets). Developers can then design a node that manages the "
"creation/loading and deletion/unloading of resources and nodes in real-time. "
"Games with large and varied environments or procedurally generated elements "
"often implement these strategies to avoid wasting memory."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/logic_preferences.rst:142
msgid ""
"On the flip side, coding a dynamic system is more complex, i.e. uses more "
"programmed logic, which results in opportunities for errors and bugs. If one "
"isn't careful, they can develop a system that bloats the technical debt of "
"the application."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/logic_preferences.rst:147
msgid "As such, the best options would be..."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/logic_preferences.rst:149
msgid "To use a static level for smaller games."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/logic_preferences.rst:151
msgid ""
"If one has the time/resources on a medium/large game, create a library or "
"plugin that can code the management of nodes and resources. If refined over "
"time, so as to improve usability and stability, then it could evolve into a "
"reliable tool across projects."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/logic_preferences.rst:156
msgid ""
"Code the dynamic logic for a medium/large game because one has the coding "
"skills, but not the time or resources to refine the code (game's gotta get "
"done). Could potentially refactor later to outsource the code into a plugin."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/logic_preferences.rst:161
msgid ""
"For an example of the various ways one can swap scenes around at runtime, "
"please see the :ref:`\"Change scenes manually\" "
"<doc_change_scenes_manually>` documentation."
msgstr ""

#: ../../docs/tutorials/2d/canvas_layers.rst:4
msgid "Canvas layers"
msgstr "画布层"

#: ../../docs/tutorials/2d/canvas_layers.rst:7
msgid "Viewport and Canvas items"
msgstr "视区和画布项"

#: ../../docs/tutorials/2d/canvas_layers.rst:9
msgid ""
"Regular 2D nodes, such as :ref:`Node2D <class_Node2D>` or :ref:`Control "
"<class_Control>` both inherit from :ref:`CanvasItem <class_CanvasItem>`, "
"which is the base for all 2D nodes. CanvasItems can be arranged in trees and "
"they will inherit their transform. This means that when moving the parent, "
"the children will be moved too."
msgstr ""
"常规2D节点，如 :ref:`Node2D <class_Node2D>` 或 :ref:`Control "
"<class_Control>` 都继承自 :ref:`CanvasItem <class_CanvasItem>`，它是所有2D节"
"点的基础。画布项被放在树上，同时继承它们的变换。这意味着在移动父节点时，子节"
"点也会被移动。"

#: ../../docs/tutorials/2d/canvas_layers.rst:16
msgid ""
"These nodes are placed as direct or indirect children of a :ref:`Viewport "
"<class_Viewport>`, and will be displayed through it."
msgstr ""
"这些节点作为 :ref:`Viewport <class_Viewport>`的直接或间接子节点放置，并将通过"
"它显示。"

#: ../../docs/tutorials/2d/canvas_layers.rst:19
#, fuzzy
msgid ""
"Viewport has the property :ref:`Viewport.canvas_transform "
"<class_Viewport_property_canvas_transform>`, which allows to transform all "
"the CanvasItem hierarchy by a custom :ref:`Transform2D <class_Transform2D>` "
"transform. Nodes such as :ref:`Camera2D <class_Camera2D>` work by changing "
"that transform."
msgstr ""
"视区具有以下属性 :ref:`Viewport.canvas_transform "
"<class_Viewport_property_canvas_transform>` ，它允许使用一个自定义的 :ref:"
"`Transform2D <class_Transform2D>` 变换来改变画布项的层次结构。 节点如 :ref:"
"`Camera2D <class_Camera2D>`，主要靠改变变换来工作的。"

#: ../../docs/tutorials/2d/canvas_layers.rst:25
msgid ""
"Changing the canvas transform is useful because it is a lot more efficient "
"than moving the root canvas item (and hence the whole scene). Canvas "
"transform is a simple matrix that offsets the whole 2D drawing, so it's the "
"most efficient way to do scrolling."
msgstr ""
"改变画布变换很有用，因为它比移动根画布项(以及整个场景)更有效。 画布变换是一个"
"简单的矩阵，可以移动整个2D绘图，因此它可高效地实现背景滚动。"

#: ../../docs/tutorials/2d/canvas_layers.rst:31
msgid "Not enough..."
msgstr "仍然不够..."

#: ../../docs/tutorials/2d/canvas_layers.rst:33
msgid ""
"But this is not enough. There are often situations where the game or "
"application may not want *everything* transformed by the canvas transform. "
"Examples of this are:"
msgstr ""
"但这还不够。 通常情况下，游戏或应用程序可能不希望通过改变画布变换来改变 *所有"
"东西* 。 关于此的示例:"

#: ../../docs/tutorials/2d/canvas_layers.rst:37
msgid ""
"**Parallax Backgrounds**: Backgrounds that move slower than the rest of the "
"stage."
msgstr "**视差背景** :比舞台其他部分移动得慢的背景。"

#: ../../docs/tutorials/2d/canvas_layers.rst:39
msgid ""
"**HUD**: Heads-up display, or user interface. If the world moves, the life "
"counter, score, etc. must stay static."
msgstr ""
"**HUD** :页面头部的显示或用户界面。 如果世界在移动，生命条、分数等必须保持静"
"止。"

#: ../../docs/tutorials/2d/canvas_layers.rst:41
msgid ""
"**Transitions**: Effects used for transitions (fades, blends) may also want "
"it to remain at a fixed location."
msgstr "**转换** :用于转换的效果(淡入淡出，混合)也可能希望它保留在固定位置。"

#: ../../docs/tutorials/2d/canvas_layers.rst:44
msgid "How can these problems be solved in a single scene tree?"
msgstr "如何在单个场景树中解决这些问题？"

#: ../../docs/tutorials/2d/canvas_layers.rst:47
msgid "CanvasLayers"
msgstr "画布层"

#: ../../docs/tutorials/2d/canvas_layers.rst:49
msgid ""
"The answer is :ref:`CanvasLayer <class_CanvasLayer>`, which is a node that "
"adds a separate 2D rendering layer for all its children and grand-children. "
"Viewport children will draw by default at layer \"0\", while a CanvasLayer "
"will draw at any numeric layer. Layers with a greater number will be drawn "
"above those with a smaller number. CanvasLayers also have their own "
"transform and do not depend on the transform of other layers. This allows "
"the UI to be fixed in-place while the world moves."
msgstr ""
"答案是 :ref:`CanvasLayer <class_CanvasLayer>` ，这是一个为其所有子项和孙子项"
"添加单独的2D渲染层的节点。 视区的子项默认在图层“0”处绘制，而画布层将在任何数"
"字图层绘制。 数字较大的图层将被绘制在数字较小的图层之上。 画布层也有自己的位"
"置，它不依赖于其他层的位置。 这允许UI在世界移动时就地固定。"

#: ../../docs/tutorials/2d/canvas_layers.rst:58
msgid ""
"An example of this is creating a parallax background. This can be done with "
"a CanvasLayer at layer \"-1\". The screen with the points, life counter and "
"pause button can also be created at layer \"1\"."
msgstr ""
"一个示例是创建视差背景。 这可以通过层为“-1”的画布层完成。 带有点，寿命计数器"
"和暂停按钮的屏幕也可以创建在层“1”的画布层中。"

#: ../../docs/tutorials/2d/canvas_layers.rst:62
msgid "Here's a diagram of how it looks:"
msgstr "下面是它的外观图:"

#: ../../docs/tutorials/2d/canvas_layers.rst:66
msgid ""
"CanvasLayers are independent of tree order, and they only depend on their "
"layer number, so they can be instantiated when needed."
msgstr ""
"画布层独立于树顺序，它们仅依赖于它们的层数，因此可以只在需要时让它们实例化。"

#: ../../docs/tutorials/2d/canvas_layers.rst:72
#, fuzzy
msgid ""
"Even though there shouldn't be any performance limitation, it is not advised "
"to use excessive amount of layers to arrange drawing order of nodes. The "
"most optimal way will always be arranging them by tree order. 2d nodes also "
"have a property for controlling their drawing order (see :ref:`Node2D."
"z_index <class_Node2D_property_z_index>`)."
msgstr ""
"即使不存在任何性能限制，也不建议使用过多的层来排列节点的绘制顺序。 最佳方式始"
"终是按树顺序排列它们。 2d节点还具有控制其绘制顺序的属性(参见 :ref:`Node2D."
"z_index <class_Node2D_property_z_index>` )。"

#: ../../docs/tutorials/2d/2d_transforms.rst:4
msgid "Viewport and canvas transforms"
msgstr "视区和画布变换"

#: ../../docs/tutorials/2d/2d_transforms.rst:9
msgid ""
"This is an overview of the 2D transforms going on for nodes from the moment "
"they draw their content locally to the time they are drawn onto the screen. "
"This overview discusses very low level details of the engine."
msgstr ""
"本小节概述了， 节点从绘制本地内容开始到显示到屏幕上结束的过程中的2D变换。 本"
"概述从非常的低级别上，讨论了引擎的细节。"

#: ../../docs/tutorials/2d/2d_transforms.rst:14
msgid "Canvas transform"
msgstr "画布变换"

#: ../../docs/tutorials/2d/2d_transforms.rst:16
msgid ""
"As mentioned in the previous tutorial, :ref:`doc_canvas_layers`, every "
"CanvasItem node (remember that Node2D and Control based nodes use CanvasItem "
"as their common root) will reside in a *Canvas Layer*. Every canvas layer "
"has a transform (translation, rotation, scale, etc.) that can be accessed as "
"a :ref:`Transform2D <class_Transform2D>`."
msgstr ""
"正如前面教程中提到的那样 :ref:`doc_canvas_layers`，每个画布项节点(记住Node2D"
"和基于Control的节点使用画布项作为它们的公共根)将驻留在 *画布层* 中。 每个画布"
"层都有一个变换(平移，旋转，缩放等)，可以作为 :ref:`Transform2D "
"<class_Transform2D>` 进行访问。"

#: ../../docs/tutorials/2d/2d_transforms.rst:22
msgid ""
"Also covered in the previous tutorial, nodes are drawn by default in Layer "
"0, in the built-in canvas. To put nodes in a different layer, a :ref:"
"`CanvasLayer <class_CanvasLayer>` node can be used."
msgstr ""
"在上一个教程中也有介绍，默认情况下，在内置画布的第0层中绘制节点。 要将节点放"
"在不同的层中，可以使用 :ref:`CanvasLayer <class_CanvasLayer>` 节点。"

#: ../../docs/tutorials/2d/2d_transforms.rst:27
msgid "Global canvas transform"
msgstr "全局画布变换"

#: ../../docs/tutorials/2d/2d_transforms.rst:29
msgid ""
"Viewports also have a Global Canvas transform (also a :ref:`Transform2D "
"<class_Transform2D>`). This is the master transform and affects all "
"individual *Canvas Layer* transforms. Generally, this transform is not of "
"much use, but is used in the CanvasItem Editor in Godot's editor."
msgstr ""
"视区还具有全局画布变换(也是 :ref:`Transform2D <class_Transform2D>` )。 这是主"
"变换并影响所有单独的 *画布层* 变换。 通常这种变换用得不多，主要用在Godot的编"
"辑器中的画布项编辑器中。"

#: ../../docs/tutorials/2d/2d_transforms.rst:36
msgid "Stretch transform"
msgstr "拉伸变换"

#: ../../docs/tutorials/2d/2d_transforms.rst:38
msgid ""
"Finally, viewports have a *Stretch Transform*, which is used when resizing "
"or stretching the screen. This transform is used internally (as described "
"in :ref:`doc_multiple_resolutions`), but can also be manually set on each "
"viewport."
msgstr ""
"最后，视区有 *拉伸变换* ，用于调整大小或拉伸屏幕。 此变换在内部使用(见 :ref:"
"`doc_multiple_resolutions` )，但也可以在每个视区上手动设置。"

#: ../../docs/tutorials/2d/2d_transforms.rst:43
#, fuzzy
msgid ""
"Input events received in the :ref:`MainLoop._input_event() "
"<class_MainLoop_method__input_event>` callback are multiplied by this "
"transform but lack the ones above. To convert InputEvent coordinates to "
"local CanvasItem coordinates, the :ref:`CanvasItem.make_input_local() "
"<class_CanvasItem_method_make_input_local>` function was added for "
"convenience."
msgstr ""
"在 :ref:`MainLoop._input_event() <class_MainLoop_method__input_event>` 回调中"
"接收的输入事件乘以此变换，无法实现上述变换。 还需要将InputEvent坐标转换为本地"
"画布项坐标，为方便转换，引擎添加了 :ref:`CanvasItem.make_input_local() "
"<class_CanvasItem_method_make_input_local>` 函数。"

#: ../../docs/tutorials/2d/2d_transforms.rst:50
msgid "Transform order"
msgstr "变换顺序"

#: ../../docs/tutorials/2d/2d_transforms.rst:52
msgid ""
"For a coordinate in CanvasItem local properties to become an actual screen "
"coordinate, the following chain of transforms must be applied:"
msgstr "要使画布项的本地属性中的坐标成为实际屏幕坐标，必须应用以下一系列变换:"

#: ../../docs/tutorials/2d/2d_transforms.rst:58
msgid "Transform functions"
msgstr "变换函数"

#: ../../docs/tutorials/2d/2d_transforms.rst:60
msgid "Obtaining each transform can be achieved with the following functions:"
msgstr "通过以下函数可以实现每个转换:"

#: ../../docs/tutorials/2d/2d_transforms.rst:63
#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:21
#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:366
#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:92
#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:158
#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:218
#: ../../docs/tutorials/plugins/editor/import_plugins.rst:242
#: ../../docs/tutorials/misc/binary_serialization_api.rst:23
#: ../../docs/tutorials/misc/binary_serialization_api.rst:92
#: ../../docs/tutorials/misc/binary_serialization_api.rst:101
#: ../../docs/tutorials/misc/binary_serialization_api.rst:110
#: ../../docs/tutorials/misc/binary_serialization_api.rst:119
#: ../../docs/tutorials/misc/binary_serialization_api.rst:132
#: ../../docs/tutorials/misc/binary_serialization_api.rst:143
#: ../../docs/tutorials/misc/binary_serialization_api.rst:158
#: ../../docs/tutorials/misc/binary_serialization_api.rst:171
#: ../../docs/tutorials/misc/binary_serialization_api.rst:190
#: ../../docs/tutorials/misc/binary_serialization_api.rst:205
#: ../../docs/tutorials/misc/binary_serialization_api.rst:220
#: ../../docs/tutorials/misc/binary_serialization_api.rst:239
#: ../../docs/tutorials/misc/binary_serialization_api.rst:264
#: ../../docs/tutorials/misc/binary_serialization_api.rst:295
#: ../../docs/tutorials/misc/binary_serialization_api.rst:310
#: ../../docs/tutorials/misc/binary_serialization_api.rst:319
#: ../../docs/tutorials/misc/binary_serialization_api.rst:330
#: ../../docs/tutorials/misc/binary_serialization_api.rst:340
#: ../../docs/tutorials/misc/binary_serialization_api.rst:359
#: ../../docs/tutorials/misc/binary_serialization_api.rst:371
#: ../../docs/tutorials/misc/binary_serialization_api.rst:383
#: ../../docs/tutorials/misc/binary_serialization_api.rst:396
#: ../../docs/tutorials/misc/binary_serialization_api.rst:407
#: ../../docs/tutorials/misc/binary_serialization_api.rst:418
#: ../../docs/tutorials/misc/binary_serialization_api.rst:426
#: ../../docs/tutorials/misc/binary_serialization_api.rst:439
#: ../../docs/tutorials/misc/binary_serialization_api.rst:452
#: ../../docs/tutorials/misc/binary_serialization_api.rst:467
msgid "Type"
msgstr "类型"

#: ../../docs/tutorials/2d/2d_transforms.rst:63
#: ../../docs/tutorials/math/matrices_and_transforms.rst:342
#: ../../docs/tutorials/math/matrices_and_transforms.rst:703
msgid "Transform"
msgstr "变换"

#: ../../docs/tutorials/2d/2d_transforms.rst:65
msgid "CanvasItem"
msgstr "CanvasItem"

#: ../../docs/tutorials/2d/2d_transforms.rst:65
#, fuzzy
msgid ""
":ref:`CanvasItem.get_global_transform() "
"<class_CanvasItem_method_get_global_transform>`"
msgstr ""
":ref:`CanvasItem.get_global_transform() "
"<class_CanvasItem_method_get_global_transform>`"

#: ../../docs/tutorials/2d/2d_transforms.rst:67
msgid "CanvasLayer"
msgstr "CanvasLayer"

#: ../../docs/tutorials/2d/2d_transforms.rst:67
#, fuzzy
msgid ""
":ref:`CanvasItem.get_canvas_transform() "
"<class_CanvasItem_method_get_canvas_transform>`"
msgstr ""
":ref:`CanvasItem.get_canvas_transform() "
"<class_CanvasItem_method_get_canvas_transform>`"

#: ../../docs/tutorials/2d/2d_transforms.rst:69
msgid "CanvasLayer+GlobalCanvas+Stretch"
msgstr "CanvasLayer+GlobalCanvas+Stretch"

#: ../../docs/tutorials/2d/2d_transforms.rst:69
#, fuzzy
msgid ""
":ref:`CanvasItem.get_viewport_transform() "
"<class_CanvasItem_method_get_viewport_transform>`"
msgstr ""
":ref:`CanvasItem.get_viewport_transform() "
"<class_CanvasItem_method_get_viewport_transform>`"

#: ../../docs/tutorials/2d/2d_transforms.rst:72
msgid ""
"Finally, then, to convert a CanvasItem local coordinates to screen "
"coordinates, just multiply in the following order:"
msgstr "最后，然后，要将画布项的本地坐标转换为屏幕坐标，只需按以下顺序相乘:"

#: ../../docs/tutorials/2d/2d_transforms.rst:84
msgid ""
"Keep in mind, however, that it is generally not desired to work with screen "
"coordinates. The recommended approach is to simply work in Canvas "
"coordinates (``CanvasItem.get_global_transform()``), to allow automatic "
"screen resolution resizing to work properly."
msgstr ""
"但请记住，通常情况最好不要使用屏幕坐标。 推荐的方法是， 仅仅使用画布坐标"
"( ``CanvasItem.get_global_transform()`` )，以保证在调整屏幕大小后使其能正常工"
"作。"

#: ../../docs/tutorials/2d/2d_transforms.rst:90
msgid "Feeding custom input events"
msgstr "提供自定义输入事件"

#: ../../docs/tutorials/2d/2d_transforms.rst:92
msgid ""
"It is often desired to feed custom input events to the scene tree. With the "
"above knowledge, to correctly do this, it must be done the following way:"
msgstr ""
"通常需要将自定义输入事件提供给场景树。 有了上述知识，要正确地做到这一点，必须"
"通过以下方式完成:"

#: ../../docs/tutorials/2d/using_tilemaps.rst:4
msgid "Using tilemaps"
msgstr "使用瓦片地图"

#: ../../docs/tutorials/2d/using_tilemaps.rst:9
msgid ""
"Tilemaps are a simple and quick way to make 2D game levels. Basically, you "
"start with a bunch of reference tiles (or pieces) that can be put on a grid, "
"as many times each as desired - think of it like a map editor:"
msgstr ""
"瓦片地图是一种简单快捷的制作2D游戏关卡的方法。 基本上，您只需从一堆可多次使用"
"且放在网格上的瓦片(或碎片)开始就行了， - 想象它就像一个地图编辑器:"

#: ../../docs/tutorials/2d/using_tilemaps.rst:15
msgid ""
"Collisions can also be added to the tiles, allowing for both 2D side "
"scrolling and top down games."
msgstr "碰撞也可以添加到瓦片中，从而允许2D滚动和跳跃游戏。"

#: ../../docs/tutorials/2d/using_tilemaps.rst:19
msgid "Making a tileset"
msgstr "制作瓦片集"

#: ../../docs/tutorials/2d/using_tilemaps.rst:21
msgid ""
"To begin, a tileset needs to be made. Here are some tiles for it. They are "
"all in the same image for optimization reasons. There are so-called *texture "
"packers* that will generate these spritesheets out of your separate texture "
"files. Having them as separate images also works."
msgstr ""
"首先，需要制作一个瓦片集。 为创建它需要一些瓦片。 出于优化原因，它们都在相同"
"的图像中。 有一个所谓的 *纹理包装器* 将从您单独的纹理文件中生成这些精灵表。 "
"当然也可以使用多张单独的图像瓦片。"

#: ../../docs/tutorials/2d/using_tilemaps.rst:29
msgid ""
"Create a new project and move the above PNG image into the directory. Next, "
"go into the image's import settings and turn off ``Filter``, keeping it on "
"will cause issues later. ``Mipmaps`` should already be disabled; if not, "
"disable this too."
msgstr ""
"创建一个新项目并将上面的PNG图像移动到目录中。 接下来进入图像的导入设置并关"
"闭“过滤器”，保持打开将导致问题。 ``Mipmaps`` 应该已经被禁用，如果没有，也禁用"
"它。"

#: ../../docs/tutorials/2d/using_tilemaps.rst:33
msgid ""
"We will be creating a :ref:`TileSet <class_TileSet>` resource. While this "
"resource exports properties, it's pretty difficult to get complex data into "
"it and maintain it. Here is what it would look like to manually edit the "
"resource:"
msgstr ""
"我们将创建一个 :ref:`TileSet <class_TileSet>` 资源。 虽然此资源导出属性，但很"
"难将复杂数据导入其中并进行维护。 以下是手动编辑资源的样子:"

#: ../../docs/tutorials/2d/using_tilemaps.rst:40
msgid ""
"There are enough properties to get by. With some effort, editing this way "
"can work. But the easiest way to edit and maintain a tileset is exporting it "
"from a specially-crafted scene!"
msgstr ""
"有足够的属性可以获得。 通过一些努力，以这种方式编辑可以工作。 但编辑和维护"
"tileset的最简单方法是从特制场景中导出它！"

#: ../../docs/tutorials/2d/using_tilemaps.rst:45
msgid "TileSet scene"
msgstr "TileSet场景"

#: ../../docs/tutorials/2d/using_tilemaps.rst:47
#, fuzzy
msgid ""
"Create a new scene with a regular Node or Node2D as root. For each tile you "
"want to define, add a sprite node as a child. Since tiles here are 50x50, "
"you should turn on the grid (``View -> Show Grid`` or ``G`` key) and enable "
"snap (``Use Snap`` icon or ``Shift + S`` keys). Moving tiles with the mouse "
"might still be a bit inaccurate, so use your arrow keys as well."
msgstr ""
"使用常规节点或Node2D以root身份创建新场景。 对于要定义的每个tile，请将sprite节"
"点添加为子级。 由于这里的瓷砖是50x50，您应该打开网格( ``View -> Show Grid`` "
"或 ``G`` 键)并启用snap( ``使用Snap`` 图标或 ``S`` 键)。 使用鼠标移动切片可能"
"仍然不准确，因此也请使用箭头键。"

#: ../../docs/tutorials/2d/using_tilemaps.rst:53
msgid ""
"If more than one tile is present in the source image, make sure to use the "
"region property of the sprite to adjust which part of the texture is being "
"used."
msgstr ""
"如果源图像中存在多个瓦片，请确保使用精灵的region属性来调整正在使用纹理的哪个"
"部分。"

#: ../../docs/tutorials/2d/using_tilemaps.rst:57
msgid ""
"Finally, make sure to name your sprite node correctly. This will ensure "
"that, in subsequent edits to the tileset (for example, if you've added "
"collision, changed the region, etc), the tile will still be **identified "
"correctly and updated**. This name should be unique."
msgstr ""
"最后，确保正确命名您的精灵节点。 这将确保在对tileset的后续编辑中(例如，如果添"
"加了冲突，更改了区域等)，仍将 *正确识别并更新* 瓦片集。 这个名字应该是唯一"
"的。"

#: ../../docs/tutorials/2d/using_tilemaps.rst:62
msgid ""
"Sounds like quite a few requirements, so here's a screenshot that shows "
"where everything of relevance is:"
msgstr "听起来很多要求，所以这里有一个屏幕截图，显示相关的所有内容:"

#: ../../docs/tutorials/2d/using_tilemaps.rst:67
msgid ""
"Continue adding all the tiles, adjusting the offsets if needed (that is, if "
"you have multiple tiles in a single source image). Again, *remember that "
"their names must be unique*."
msgstr ""
"继续添加所有切片，根据需要调整偏移量(即，如果单个源图像中有多个切片)。 再"
"次， *记住他们的名字必须是唯一的* 。"

#: ../../docs/tutorials/2d/using_tilemaps.rst:74
msgid "Collision"
msgstr "碰撞"

#: ../../docs/tutorials/2d/using_tilemaps.rst:76
msgid ""
"To add collision to a tile, create a StaticBody2D child for each sprite. "
"This is a static collision node. Then create a CollisionShape2D or "
"CollisionPolygon as a child of the StaticBody2D. The CollisionPolygon is "
"recommended because it is easier to edit."
msgstr ""
"要向tile添加碰撞，请为每个sprite创建一个StaticBody2D子级。 这是一个静态碰撞节"
"点。 然后创建一个CollisionShape2D或CollisionPolygon作为StaticBody2D的子项。 "
"建议使用CollisionPolygon，因为它更容易编辑。"

#: ../../docs/tutorials/2d/using_tilemaps.rst:83
msgid ""
"Finally, edit the polygon; this will give the tile a collision and fix the "
"warning icon next to the CollisionPolygon node. **Remember to use snap!** "
"Using snap will make sure collision polygons are aligned properly, allowing "
"a character to walk seamlessly from tile to tile. Also **do not scale or "
"move** the collision and/or collision polygon nodes. Leave them at offset "
"0,0, with scale 1,1 and rotation 0 with respect to the parent sprite."
msgstr ""
"最后，编辑多边形，这将使图块发生碰撞并修复CollisionPolygon节点旁边的警告图"
"标。 **记得使用snap！** 使用snap会确保碰撞多边形正确对齐，允许角色从一个拼贴"
"到另一个拼贴无缝地行走。 另外 *不要缩放或移动* 碰撞和/或碰撞多边形节点。 将它"
"们保留在偏移0,0处，标度1,1和相对于父精灵的旋转0。"

#: ../../docs/tutorials/2d/using_tilemaps.rst:92
msgid ""
"Keep adding collisions to the tiles until we are done. Note that BG is just "
"a background, so it should not have a collision."
msgstr ""
"继续向瓷砖添加碰撞，直到完成为止。 请注意，BG只是一个背景，所以它不应该有碰"
"撞。"

#: ../../docs/tutorials/2d/using_tilemaps.rst:97
msgid ""
"OK! We're done! Remember to save this scene for future edit. Name it "
"\"tileset_edit.scn\" or something like that."
msgstr ""
"好！ 我们完成了！ 请记住保存此场景以供将来编辑。 将其命名为“tileset_edit."
"scn”或类似名称。"

#: ../../docs/tutorials/2d/using_tilemaps.rst:101
msgid "Exporting a TileSet"
msgstr "导出TileSet"

#: ../../docs/tutorials/2d/using_tilemaps.rst:103
msgid ""
"With the scene created and opened in the editor, the next step will be to "
"create a tileset. Use Scene > Convert To > Tile Set from the Scene Menu:"
msgstr ""
"在编辑器中创建并打开场景后，下一步将是创建一个tileset。 从场景菜单中使用场景>"
"转换为>平铺设置:"

#: ../../docs/tutorials/2d/using_tilemaps.rst:108
msgid ""
"Then choose a filename, like \"mytiles.tres\". Make sure the \"Merge With "
"Existing\" option is toggled on. This way, every time the tileset resource "
"file is overwritten, existing tiles are merged and updated (they are "
"referenced by their unique name, so again, **name your tiles properly**)."
msgstr ""
"然后选择一个文件名，例如“mytiles.tres”。 确保切换“与现有合并”选项。 这样，每"
"次覆盖tileset资源文件时，现有的tile都会被合并和更新(它们由它们的唯一名称引"
"用，所以再次**正确命名您的tile **)。"

#: ../../docs/tutorials/2d/using_tilemaps.rst:117
msgid "Using the TileSet in a TileMap"
msgstr "在TileMap中使用TileSet"

#: ../../docs/tutorials/2d/using_tilemaps.rst:119
msgid ""
"Create a new scene, using any node or node2d as root, and then create a :ref:"
"`TileMap <class_TileMap>` as a child."
msgstr ""
"使用任何节点或node2d作为root创建一个新场景，然后创建一个 :ref:`TileMap "
"<class_TileMap>` 作为子节点。"

#: ../../docs/tutorials/2d/using_tilemaps.rst:125
msgid ""
"Go to the TileSet property of this node and assign the one created in "
"previous steps:"
msgstr "转到此节点的TileSet属性并分配在先前步骤中创建的属性:"

#: ../../docs/tutorials/2d/using_tilemaps.rst:130
msgid ""
"Also set the cell size to '50', since that is the size used by the tiles. "
"Quadrant size is a tuning value, which means that the engine will draw and "
"cull the tilemap in blocks of 16x16 tiles. This value is usually fine and "
"does not need to be changed, but can be used to fine tune performance in "
"specific cases (if you know what you are doing)."
msgstr ""
"同时将单元格大小设置为“50”，因为这是图块使用的大小。 象限大小是一个调整值，这"
"意味着引擎将以16x16块的块来绘制和剔除tilemap。 此值通常很好，不需要更改，但可"
"以用于在特定情况下微调性能(如果您知道自己在做什么)。"

#: ../../docs/tutorials/2d/using_tilemaps.rst:137
msgid "Painting your world"
msgstr "画您的世界"

#: ../../docs/tutorials/2d/using_tilemaps.rst:139
msgid ""
"With all set, make sure the TileMap node is selected. A red grid will appear "
"on the screen, allowing you to paint on it with the selected tile on the "
"left palette."
msgstr ""
"使用all set，确保选中TileMap节点。 屏幕上将出现一个红色网格，允许使用左侧调色"
"板上的选定图块在其上绘画。"

#: ../../docs/tutorials/2d/using_tilemaps.rst:145
msgid ""
"To avoid accidentally moving and selecting the tilemap node (something "
"common, given it's a huge node), it is recommended that you lock it, using "
"the lock button:"
msgstr ""
"为了避免意外移动和选择tilemap节点(这是常见的，因为它是一个巨大的节点)，建议您"
"使用锁定按钮将其锁定:"

#: ../../docs/tutorials/2d/using_tilemaps.rst:151
msgid ""
"If you accidentally place a tile somewhere you don't want it to be, you can "
"delete it with ``RMB`` (the right mouse button) while in the tilemap editor."
msgstr ""
"如果您不小心将瓷砖放在某个您不想要的地方，您可以在瓷砖地图编辑器中用 ``RMB`` "
"删除它。"

#: ../../docs/tutorials/2d/using_tilemaps.rst:154
msgid ""
"You can also flip and rotate sprites in the TileMap editor (note: flipping "
"the sprite in the TileSet will have no effect). Icons at the top right of "
"the editor allow flipping and rotating of the currently selected sprite - "
"you can also use the A and S keys to flip the sprite horizontally and "
"vertically. With a brick pattern like this tutorial uses, flipping the "
"sprites would create unpleasant discontinuities unless you're flipping an "
"entire region of bricks. But for some kinds of tiles, flipping can be a "
"convenient and space-saving feature."
msgstr ""
"您还可以在TileMap编辑器中翻转和旋转精灵(注意:在TileSet中翻转精灵不起作用)。 "
"编辑器右上角的图标允许翻转和旋转当前选定的精灵 - 您还可以使用A和S键水平和垂直"
"翻转精灵。 使用像本教程所使用的砖图案，翻转精灵会产生令人不快的不连续性，除非"
"您翻转整个砖块区域。 但对于某些类型的瓷砖，翻转可以是一种方便且节省空间的功"
"能。"

#: ../../docs/tutorials/2d/using_tilemaps.rst:164
msgid "Offset and scaling artifacts"
msgstr "偏移和缩放工件"

#: ../../docs/tutorials/2d/using_tilemaps.rst:166
msgid ""
"When using a single texture for all the tiles, scaling the tileset (or even "
"moving to a non pixel-aligned location) will most likely result in filtering "
"artifacts like so:"
msgstr ""
"对所有切片使用单个纹理时，缩放切片集(甚至移动到非像素对齐的位置)很可能会导致"
"过滤伪像，如下所示:"

#: ../../docs/tutorials/2d/using_tilemaps.rst:172
msgid ""
"This is unavoidable, as it is the way the hardware bilinear filter works. To "
"avoid this situation, there are a few workarounds. Try the one that looks "
"better for you:"
msgstr ""
"这是不可避免的，因为它是硬件双线性滤波器的工作方式。 因此，为了避免这种情况，"
"有一些解决方法。 试试看起来更适合您的那个:"

#: ../../docs/tutorials/2d/using_tilemaps.rst:177
msgid ""
"Disable filtering and mipmaps for either the tileset texture or all tile "
"textures if using separate images (see the :ref:`doc_import_images` asset "
"pipeline tutorial)."
msgstr ""
"如果使用单独的图像，则禁用tileset纹理或所有tile纹理的过滤和mipmap(请参阅 :"
"ref:`doc_import_images`资源管道教程)。"

#: ../../docs/tutorials/2d/using_tilemaps.rst:178
msgid ""
"Enable pixel snap (Set ``Project > Project Settings > Rendering > Quality > "
"2d > Use Pixel Snap`` to true; you can also search for ``Pixel Snap``)."
msgstr ""
"启用像素捕捉(将“项目>项目设置>渲染>质量> 2d>使用像素捕捉”设置为true，您还可以"
"搜索“Pixel Snap”)。"

#: ../../docs/tutorials/2d/using_tilemaps.rst:180
msgid ""
"Viewport Scaling can often help with shrinking the map (see the :ref:"
"`doc_viewports` tutorial). Simply adding a camera, setting it to ``Current`` "
"and playing around with its ``Zoom`` may be a good starting point."
msgstr ""
"Viewport Scaling通常可以帮助缩小地图(参见 :ref:`doc_viewports`教程)。 只需添"
"加一个摄像头，将其设置为“当前”并使用其“缩放”进行游戏可能是一个很好的起点。"

#: ../../docs/tutorials/2d/using_tilemaps.rst:182
msgid ""
"You can use a single, separate image for each tile. This will remove all "
"artifacts, but can be more cumbersome to implement and is less optimized."
msgstr ""
"您可以为每个图块使用单个单独的图像。 这将删除所有工件，但实现起来可能更加麻"
"烦，并且不太优化。"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:4
msgid "Particle systems (2D)"
msgstr "粒子系统(2D)"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:9
msgid ""
"A simple (but flexible enough for most uses) particle system is provided. "
"Particle systems are used to simulate complex physical effects, such as "
"sparks, fire, magic particles, smoke, mist, etc."
msgstr ""
"Godot提供了一种简单(但对于大多数用途而言足够灵活)的粒子系统。 粒子系统用于模"
"拟复杂的物理效应，如火花，火焰，魔法粒子，烟雾，雾气，魔法等。"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:13
msgid ""
"The idea is that a \"particle\" is emitted at a fixed interval and with a "
"fixed lifetime. During its lifetime, every particle will have the same base "
"behavior. What makes each particle different from the rest and provides a "
"more organic look is the \"randomness\" associated with each parameter. In "
"essence, creating a particle system means setting base physics parameters "
"and then adding randomness to them."
msgstr ""
"这个想法是以固定的间隔发射具有固定的寿命的“粒子”。 在其生命周期中，每个粒子都"
"具有相同的基本行为。 每个参数相关的“随机性”是让每个粒子变得不同并呈现出具有组"
"织的外观。 实质上，创建粒子系统意味着设置基本物理参数，然后为它们添加随机性。"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:21
msgid "Particles2D"
msgstr "Particles2D"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:23
msgid ""
"Particle systems are added to the scene via the :ref:`Particles2D "
"<class_Particles2D>` node. However, after creating that node you will notice "
"that only a white dot was created, and that there is a warning icon next to "
"your Particles2D node in the inspector. This is because the node needs a "
"ParticlesMaterial to function."
msgstr ""
"粒子系统通过 :ref:`Particles2D <class_Particles2D>` 节点添加到场景中。 但是，"
"在创建该节点后，您会注意到只创建了一个白点，并且在Particles2D节点的属性面板旁"
"边有一个警告图标。 这是因为节点需要ParticlesMaterial才能运行。"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:30
msgid "ParticlesMaterial"
msgstr "ParticlesMaterial"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:32
msgid ""
"To add a process material to your particles node, go to ``Process Material`` "
"in your inspector panel. Click on the box next to ``Material``, and from the "
"dropdown menu select ``New ParticlesMaterial``."
msgstr ""
"要将过程材质添加到粒子节点，请转到“属性面板”面板中的“处理材质”。 单击材质旁边"
"的框，然后从下拉菜单中选择New Particles Material。"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:38
msgid "Your Particles2D node should now be emitting white points downward."
msgstr "您的Particles2D节点现在应该可以向下发射白点了。"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:44
msgid "Texture"
msgstr "纹理"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:46
msgid ""
"A particle system uses a single texture (in the future this might be "
"extended to animated textures via spritesheet). The texture is set via the "
"relevant texture property:"
msgstr ""
"粒子系统使用单个纹理(将来可能会通过spritesheet扩展到动画纹理)。 纹理通过相关"
"的纹理属性设置:"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:53
msgid "Time parameters"
msgstr "时间参数"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:56
msgid "Lifetime"
msgstr "寿命"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:58
msgid ""
"The time in seconds that every particle will stay alive. When lifetime ends, "
"a new particle is created to replace it."
msgstr ""
"每个粒子存活的时间(以秒为单位)。 生命周期结束时，会创建一个新粒子来替换它。"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:61
msgid "Lifetime: 0.5"
msgstr "寿命: 0.5"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:65
msgid "Lifetime: 4.0"
msgstr "寿命: 4.0"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:70
msgid "One Shot"
msgstr "一发"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:72
msgid ""
"When enabled, a Particles2D node will emit all of its particles once and "
"then never again."
msgstr "启用后，Particles2D节点将一次性发出所有粒子，然后再也不发射。"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:76
msgid "Preprocess"
msgstr "预处理"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:78
msgid ""
"Particle systems begin with zero particles emitted, then start emitting. "
"This can be an inconvenience when loading a scene and systems like a torch, "
"mist, etc. begin emitting the moment you enter. Preprocess is used to let "
"the system process a given number of seconds before it is actually drawn the "
"first time."
msgstr ""
"粒子系统从零粒子发射开始，然后开始发射。 当加载场景如火炬，雾等系统时可能会带"
"来不便，因为它会在您进入的那一刻开始发射。 预处理用于让系统在第一次实际绘制之"
"前处理给定的秒数。"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:85
msgid "Speed Scale"
msgstr "速度大小"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:87
msgid ""
"The speed scale has a default value of ``1`` and is used to adjust the speed "
"of a particle system. Lowering the value will make the particles slower "
"while increasing the value will make the particles much faster."
msgstr ""
"速度大小具有默认值 ``1`` ，用于调整粒子系统的速度。 降低值会使粒子变慢，而增"
"加值会使粒子更快。"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:92
msgid "Explosiveness"
msgstr "爆炸性"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:94
msgid ""
"If lifetime is ``1`` and there are 10 particles, it means a particle will be "
"emitted every 0.1 seconds. The explosiveness parameter changes this, and "
"forces particles to be emitted all together. Ranges are:"
msgstr ""
"如果有10个寿命为 ``1`` 的粒子，则意味着粒子将每0.1秒发射一次。 爆炸性参数改变"
"了这一点，并迫使粒子一起发射。 范围是:"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:98
msgid "0: Emit particles at regular intervals (default value)."
msgstr "0:定期发射粒子(默认值)。"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:99
msgid "1: Emit all particles simultaneously."
msgstr "1:同时发射所有粒子。"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:101
msgid ""
"Values in the middle are also allowed. This feature is useful for creating "
"explosions or sudden bursts of particles:"
msgstr "中间的值也是允许的。 此功能对于创建爆炸或突然爆发的粒子非常有用:"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:107
msgid "Randomness"
msgstr "随机性"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:109
msgid ""
"All physics parameters can be randomized. Random values range from ``0`` to "
"``1``. The formula to randomize a parameter is:"
msgstr "所有物理参数都可以随机化。随机值范围从“0”到“1”。随机化参数的公式为:"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:117
msgid "Fixed FPS"
msgstr "固定FPS"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:119
msgid ""
"This setting can be used to set the particle system to render at a fixed "
"FPS. For instance, changing the value to ``2`` will make the particles "
"render at 2 frames per second. Note this does not slow down the particle "
"system itself."
msgstr ""
"此设置可用于将粒子系统设置为以固定FPS渲染。 例如，将值更改为 ``2`` 将使粒子以"
"每秒2帧的速度渲染。 请注意，这不会减慢粒子系统本身的速度。"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:124
msgid "Fract Delta"
msgstr "分形间隔"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:126
msgid "This can be used to turn Fract Delta on or off."
msgstr "这可用于打开或关闭Fract Delta。"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:129
msgid "Drawing parameters"
msgstr "绘图参数"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:132
msgid "Visibility Rect"
msgstr "可见性矩形"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:135
msgid ""
"The visibility rectangle controls the visibility of the particles on screen. "
"If this rectangle is outside of the viewport, the engine will not render the "
"particles on screen."
msgstr ""
"可见性矩形控制粒子在屏幕上的可见性。 如果此矩形位于视区之外，则引擎将不会在屏"
"幕上渲染粒子。"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:137
msgid ""
"The rectangle's ``W`` and ``H`` properties respectively control its Width "
"and its Height. The ``X`` and ``Y`` properties control the position of the "
"upper-left corner of the rectangle, relative to the particle emitter."
msgstr ""
"矩形的 ``W`` 和 ``H`` 属性分别控制其宽度和高度。 ``X`` 和 ``Y`` 属性控制矩形"
"左上角相对于粒子发射器的位置。"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:141
msgid ""
"You can have Godot generate a Visibility Rect automatically using the "
"toolbar above the 2d view. To do so, select the Particles2D node and Click "
"``Particles > Generate Visibility Rect``. Godot will simulate the "
"Particles2D node emitting particles for a few seconds and set the rectangle "
"to fit the surface the particles take."
msgstr ""
"您可以使用2d视图上方的工具栏自动生成可见性矩形。 为此，请选择Particles2D节"
"点，然后单击 ``Particles > Generate Visibility Rect`` 。 Godot将模拟"
"Particles2D节点发射粒子几秒钟，并将矩形设置为适合粒子所采用的表面。"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:143
msgid ""
"You can control the emit duration with the ``Generation Time (sec)`` option. "
"The maximum value is 25 seconds. If you need more time for your particles to "
"move around, you can temporarily change the ``preprocess`` duration on the "
"Particles2D node."
msgstr ""
"您可以使用 ``Generation Time (sec)`` 选项控制发射持续时间。 最大值为25秒。 如"
"果您需要更多时间让粒子移动，您可以暂时更改Particles2D节点上的 ``preprocess`` "
"持续时间。"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:146
msgid "Local Coords"
msgstr "本地坐标"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:148
msgid ""
"By default this option is on, and it means that the space that particles are "
"emitted to is relative to the node. If the node is moved, all particles are "
"moved with it:"
msgstr ""
"默认情况下，此选项处于启用状态，这意味着粒子发射的空间是相对于节点。 如果移动"
"节点，则随之移动所有粒子:"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:154
msgid ""
"If disabled, particles will emit to global space, meaning that if the node "
"is moved, already emitted particles are not affected:"
msgstr ""
"如果禁用，粒子将发射到全局空间，这意味着如果移动节点，则已发射的粒子不会受到"
"影响:"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:160
msgid "Draw Order"
msgstr "绘图顺序"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:162
msgid ""
"This controls the order in which individual particles are drawn. ``Index`` "
"means particles are drawn according to their emission order (default). "
"``Lifetime`` means they are drawn in order of remaining lifetime."
msgstr ""
"这可以控制绘制单个粒子的顺序。 ``Index`` 表示粒子根据它们的发射顺序被绘制(默"
"认)。 ``Lifetime`` 表示它们按照剩余寿命的顺序被绘制。"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:167
msgid "ParticlesMaterial settings"
msgstr "ParticlesMaterial设置"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:186
msgid "Spread"
msgstr "传播"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:188
msgid ""
"This parameter is the angle in degrees which will be randomly added in "
"either direction to the base ``Direction``. A spread of ``180`` will emit in "
"all directions (+/- 180)."
msgstr ""
"此参数是以度为单位的角度，它将在任一方向上随机添加到基础 ``Direction`` 。 "
"``180`` 的传播将向所有方向发射(+/- 180)。"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:195
msgid "Gravity"
msgstr "重力"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:197
msgid "The gravity applied to every particle."
msgstr "重力应用于每个粒子。"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:202
msgid "Initial Velocity"
msgstr "初始速度"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:204
msgid ""
"Linear velocity is the speed at which particles will be emitted (in pixels/"
"sec). Speed might later be modified by gravity or other accelerations (as "
"described further below)."
msgstr ""
"线速度是粒子发射的速度(以像素/秒为单位)。 以后可以通过重力或其他加速度来修改"
"速度(下面将进一步描述)。"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:211
msgid "Angular Velocity"
msgstr "角速度"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:213
msgid "Angular velocity is the initial angular velocity applied to particles."
msgstr "角速度是应用于粒子的初始角速度。"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:216
msgid "Spin Velocity"
msgstr "旋转速度"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:218
msgid ""
"Spin velocity is the speed at which particles turn around their center (in "
"degrees/sec)."
msgstr "旋转速度是粒子围绕其中心转动的速度(以度/秒为单位)。"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:224
msgid "Orbit Velocity"
msgstr "轨道速度"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:226
msgid "Orbit velocity is used to make particles turn around their center."
msgstr "轨道速度用于使粒子绕它们的中心转动。"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:231
msgid "Linear Acceleration"
msgstr "线性加速度"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:233
msgid "The linear acceleration applied to each particle."
msgstr "应用于每个粒子的线性加速度。"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:236
msgid "Radial Acceleration"
msgstr "径向加速度"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:238
msgid ""
"If this acceleration is positive, particles are accelerated away from the "
"center. If negative, they are absorbed towards it."
msgstr "如果此加速度为正，则粒子会从发射中心加速。 如果是负的，他们会被吸收。"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:244
msgid "Tangential Acceleration"
msgstr "切向加速度"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:246
msgid ""
"This acceleration will use the tangent vector to the center. Combining with "
"radial acceleration can do nice effects."
msgstr "该加速度会使用到中心点的切向量，结合径向加速度可以做出很酷炫的效果。"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:252
msgid "Damping"
msgstr "衰减"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:254
msgid ""
"Damping applies friction to the particles, forcing them to stop. It is "
"especially useful for sparks or explosions, which usually begin with a high "
"linear velocity and then stop as they fade."
msgstr ""
"阻尼对颗粒施加摩擦力，迫使它们停止。 它特别适用于火花或爆炸，火花或爆炸通常以"
"高线速度开始，然后在褪色时停止。"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:261
msgid "Angle"
msgstr "角度"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:263
msgid ""
"Determines the initial angle of the particle (in degress). This parameter is "
"mostly useful randomized."
msgstr "确定粒子的初始角度(以度为单位)。 该参数主要用于随机化。"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:269
#: ../../docs/tutorials/3d/using_multi_mesh_instance.rst:87
#: ../../docs/tutorials/math/matrices_and_transforms.rst:309
msgid "Scale"
msgstr "规模"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:271
msgid "Determines the initial scale of the particles."
msgstr "确定粒子的初始大小。"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:276
msgid "Color"
msgstr "颜色"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:278
msgid "Used to change the color of the particles being emitted."
msgstr "用于改变发射中的粒子颜色。"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:281
msgid "Hue variation"
msgstr "色调变化"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:283
msgid ""
"The ``Variation`` value sets the initial hue variation applied to each "
"particle. The ``Variation Random`` value controls the hue variation "
"randomness ratio."
msgstr ""
"Variation值设置应用于每个粒子的初始色调变化。 Variation Rand值控制色调变化随"
"机性比率。"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:288
#, fuzzy
msgid "Emission Shapes"
msgstr "碰撞形状"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:290
msgid ""
"ParticlesMaterials allow you to set an Emission Mask, which dictates the "
"area and direction in which particles are emitted. These can be generated "
"from textures in your project."
msgstr ""

#: ../../docs/tutorials/2d/particle_systems_2d.rst:294
msgid ""
"Ensure that a ParticlesMaterial is set, and the Particles2D node is "
"selected. A \"Particles\" menu should appear in the Toolbar:"
msgstr ""

#: ../../docs/tutorials/2d/particle_systems_2d.rst:299
msgid "Open it and select \"Load Emission Mask\":"
msgstr ""

#: ../../docs/tutorials/2d/particle_systems_2d.rst:303
msgid "Then select which texture you want to use as your mask:"
msgstr ""

#: ../../docs/tutorials/2d/particle_systems_2d.rst:307
msgid "A dialog box with several settings will appear."
msgstr ""

#: ../../docs/tutorials/2d/particle_systems_2d.rst:310
#, fuzzy
msgid "Emission Mask"
msgstr "发射"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:312
msgid "Three types of emission masks can be generated from a texture:"
msgstr ""

#: ../../docs/tutorials/2d/particle_systems_2d.rst:314
msgid ""
"Solid Pixels: Particles will spawn from any area of the texture, excluding "
"transparent areas."
msgstr ""

#: ../../docs/tutorials/2d/particle_systems_2d.rst:319
msgid ""
"Border Pixels: Particles will spawn from the outer edges of the texture."
msgstr ""

#: ../../docs/tutorials/2d/particle_systems_2d.rst:323
msgid ""
"Directed Border Pixels: Similar to Border Pixels, but adds extra information "
"to the mask to give particles the ability to emit away from the borders. "
"Note that an ``Initial Velocity`` will need to be set in order to utilize "
"this."
msgstr ""

#: ../../docs/tutorials/2d/particle_systems_2d.rst:331
#, fuzzy
msgid "Emission Colors"
msgstr "发射"

#: ../../docs/tutorials/2d/particle_systems_2d.rst:333
msgid ""
"``Capture from Pixel`` will cause the particles to inherit the color of the "
"mask at their spawn points."
msgstr ""

#: ../../docs/tutorials/2d/particle_systems_2d.rst:335
msgid ""
"Once you click \"OK\", the mask will be generated and set to the "
"ParticlesMaterial, under the ``Emission Shape`` section:"
msgstr ""

#: ../../docs/tutorials/2d/particle_systems_2d.rst:339
msgid ""
"All of the values within this section have been automatically generated by "
"the \"Load Emission Mask\" menu, so they should generally be left alone."
msgstr ""

#: ../../docs/tutorials/2d/particle_systems_2d.rst:342
msgid ""
"An image should not be added to ``Point Texture`` or ``Color Texture`` "
"directly. The \"Load Emission Mask\" menu should always be used instead."
msgstr ""

#: ../../docs/tutorials/2d/2d_movement.rst:4
msgid "2D movement overview"
msgstr "2D运动概述"

#: ../../docs/tutorials/2d/2d_movement.rst:9
msgid ""
"Every beginner has been there: \"How do I move my character?\" Depending on "
"the style of game you're making, you may have special requirements, but in "
"general the movement in most 2D games is based on a small number of designs."
msgstr ""
"每个初学者都会说:“我如何移动我的游戏角色呢？” 根据您正在制作的游戏风格，您可"
"能有特殊要求，但一般来说，大多数2D游戏的运动都只需要少量的设计。"

#: ../../docs/tutorials/2d/2d_movement.rst:13
msgid ""
"We'll use :ref:`KinematicBody2D <class_KinematicBody2D>` for these examples, "
"but the principles will apply to other node types (Area2D, RigidBody2D) as "
"well."
msgstr ""
"对于这些示例，我们将使用 :ref:`KinematicBody2D <class_KinematicBody2D>` ，同"
"时这些原则也适用于其他节点类型(Area2D，RigidBody2D)。"

#: ../../docs/tutorials/2d/2d_movement.rst:17
#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:22
#: ../../docs/tutorials/animation/2d_skeletons.rst:25
#: ../../docs/development/compiling/introduction_to_the_buildsystem.rst:41
msgid "Setup"
msgstr "设置"

#: ../../docs/tutorials/2d/2d_movement.rst:19
msgid ""
"Each example below uses the same scene setup. Start with a "
"``KinematicBody2D`` with two children: ``Sprite`` and ``CollisionShape2D``. "
"You can use the Godot icon (\"icon.png\") for the Sprite's texture or use "
"any other 2D image you have."
msgstr ""
"以下每个示例都使用相同的场景设置。 从带有 ``Sprite`` 和 ``CollisionShape2D`` "
"两个子节点的 ``KinematicBody2D`` 开始。 您可以使用Godot图标(“icon.png”)作为精"
"灵的纹理或使用其他任何2D图像。"

#: ../../docs/tutorials/2d/2d_movement.rst:23
msgid ""
"Open ``Project -> Project Settings`` and select the \"Input Map\" tab. Add "
"the following input actions (see :ref:`InputEvent <doc_inputevent>` for "
"details):"
msgstr ""
"打开 ``Project -> Project Settings`` 并选择 “Input Map” 选项卡。 添加以下输入"
"操作(相关详细信息，请参阅 :ref:`InputEvent <doc_inputevent>` ):"

#: ../../docs/tutorials/2d/2d_movement.rst:29
msgid "8-way movement"
msgstr "8向移动"

#: ../../docs/tutorials/2d/2d_movement.rst:31
msgid ""
"In this scenario, you want the user to press the four directional keys (up/"
"left/down/right or W/A/S/D) and move in the selected direction. The name \"8-"
"way movement\" comes from the fact that the player can move diagonally by "
"pressing two keys at the same time."
msgstr ""
"在本情况下，您希望用户按下四个方向键(向上/向左/向下/向右或W / A / S / D)并沿"
"所选方向移动。 “8向移动”意味着游戏角色可以通过同时按下两个键实现对角移动。"

#: ../../docs/tutorials/2d/2d_movement.rst:37
msgid "Add a script to the kinematic body and add the following code:"
msgstr "将脚本添加到运动物体上，并添加以下代码:"

#: ../../docs/tutorials/2d/2d_movement.rst:101
msgid ""
"In the ``get_input()`` function we check for the four key events and sum "
"them up to get the velocity vector. This has the benefit of making two "
"opposite keys cancel each other out, but will also result in diagonal "
"movement being faster due to the two directions being added together."
msgstr ""
"在 ``get_input()`` 函数中，我们检查四个关键事件并将它们相加以获得速度向量。 "
"这具有使两个相对的键彼此抵消的优点，但是由于两个方向被加在一起，还将导致对角"
"线移动得更快。"

#: ../../docs/tutorials/2d/2d_movement.rst:106
msgid ""
"We can prevent that if we *normalize* the velocity, which means we set its "
"*length* to ``1``, and multiply by the desired speed."
msgstr ""
"我们可以防止这种情况，如果我们让速度 *归一化* ，这意味着我们将其 *长度* 设置"
"为 ``1`` ，并乘以所期望的值。"

#: ../../docs/tutorials/2d/2d_movement.rst:109
msgid ""
"If you've never used vector math before, or need a refresher, you can see an "
"explanation of vector usage in Godot at :ref:`doc_vector_math`."
msgstr ""
"如果您之前从未接触过向量数学，或者需要复习，您可以在Godot中看到向量用法的解"
"释 :ref:`doc_vector_math` 。"

#: ../../docs/tutorials/2d/2d_movement.rst:113
msgid "Rotation + movement"
msgstr "旋转+移动"

#: ../../docs/tutorials/2d/2d_movement.rst:115
msgid ""
"This type of movement is sometimes called \"Asteroids-style\" because it "
"resembles how that classic arcade game worked. Pressing left/right rotates "
"the character, while up/down moves it forward or backward in whatever "
"direction it's facing."
msgstr ""
"这种类型的运动有时被称为“小行星式运动”，因为它类似于经典街机游戏的工作方式。 "
"按左/右旋转角色，而按上/下使得角色向前或向后，往它面向的任何方向移动。"

#: ../../docs/tutorials/2d/2d_movement.rst:190
msgid ""
"Here we've added two new variables to track our rotation direction and "
"speed. Again, pressing both keys at once will cancel out and result in no "
"rotation. The rotation is applied directly to the body's ``rotation`` "
"property."
msgstr ""
"在这里，我们添加了两个新变量来跟踪旋转方向和速度。 同样，一次按下两个键将取消"
"并导致没有旋转。 旋转直接应用于物体的 ``rotation`` 属性。"

#: ../../docs/tutorials/2d/2d_movement.rst:194
msgid ""
"To set the velocity, we use the ``Vector2.rotated()`` method, so that it "
"points in the same direction as the body. ``rotated()`` is a useful vector "
"function that you can use in many circumstances where you would otherwise "
"need to apply trigonometric functions."
msgstr ""
"为了设置速度，我们使用 ``Vector2.rotated()`` 方法，使它的指向与物体方向相"
"同。 ``rotated()`` 是一个很有用的向量函数，您可以在许多情况下使用它，否则您就"
"需要用到三角函数。"

#: ../../docs/tutorials/2d/2d_movement.rst:200
msgid "Rotation + movement (mouse)"
msgstr "旋转+移动(鼠标)"

#: ../../docs/tutorials/2d/2d_movement.rst:202
msgid ""
"This style of movement is a variation of the previous one. This time, the "
"direction is set by the mouse position instead of the keyboard. The "
"character will always \"look at\" the mouse pointer. The forward/back inputs "
"remain the same, however."
msgstr ""
"这种运动方式是前一种运动方式的变体。 这次，方向由鼠标位置而不是键盘设置。 角"
"色将始终“看向”鼠标指针。 然而，前进/后退输入保持不变。"

#: ../../docs/tutorials/2d/2d_movement.rst:261
msgid ""
"Here we're using the :ref:`Node2D <class_Node2D>` ``look_at()`` method to "
"point the player towards a given position. Without this function, you could "
"get the same effect by setting the angle like this:"
msgstr ""
"这里我们用到 :ref:`Node2D <class_Node2D>` 中的 ``look_at()`` 方法，使游戏角色"
"朝向给定的位置。 如果没有此函数，为获得相同的效果，您可能需要像下面这样设置角"
"度:"

#: ../../docs/tutorials/2d/2d_movement.rst:276
msgid "Click-and-move"
msgstr "点击并移动"

#: ../../docs/tutorials/2d/2d_movement.rst:278
msgid ""
"This last example uses only the mouse to control the character. Clicking on "
"the screen will cause the player to move to the target location."
msgstr ""
"最后一个示例仅使用鼠标来控制角色。 单击屏幕将使游戏角色移动到目标位置。"

#: ../../docs/tutorials/2d/2d_movement.rst:335
msgid ""
"Note the ``length()`` check we make prior to movement. Without this test, "
"the body would \"jitter\" upon reaching the target position, as it moves "
"slightly past the position and tries to move back, only to move too far and "
"repeat."
msgstr ""
"注意我们在移动之前做的 ``length()`` 检查。 如果没有这个检查，物体在到达目标位"
"置时会“抖动”，因为它稍微移过该位置时就会试图向后移动，只是每次移动步长都会有"
"点远从而导致来回重复移动。"

#: ../../docs/tutorials/2d/2d_movement.rst:340
msgid ""
"Uncommenting the ``rotation`` line will also turn the body to point in its "
"direction of motion if you prefer."
msgstr "如果您取消注释的 ``rotation`` 代码，这将使物体转向其运动方向。"

#: ../../docs/tutorials/2d/2d_movement.rst:343
msgid ""
"This technique can also be used as the basis of a \"following\" character. "
"The ``target`` position can be that of any object you want to move to."
msgstr ""
"该技术也可以用到“跟随”游戏角色中。 ``目标`` 位置可以是移动中的任何对象的位"
"置。"

#: ../../docs/tutorials/2d/2d_movement.rst:349
msgid ""
"You may find these code samples useful as starting points for your own "
"projects. Feel free to use them and experiment with them to see what you can "
"make."
msgstr ""
"您可能会发现这些代码示例可用到您自己的项目中。 请随意使用它们并试验它们，看看"
"您能做些什么。"

#: ../../docs/tutorials/2d/2d_movement.rst:352
msgid ""
"You can download this sample project here: :download:`2D_movement_demo.zip "
"<files/2D_movement_demo.zip>`"
msgstr ""
"您可以在此处下载此示例项目 : :download:`2D_movement_demo.zip "
"<files/2D_movement_demo.zip>`"

#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:4
msgid "2D lights and shadows"
msgstr "2D 灯光和阴影"

#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:9
msgid ""
"This tutorial explains how the 2D lighting works in the `lights and shadows "
"<https://github.com/godotengine/godot-demo-projects/tree/master/2d/"
"lights_and_shadows>`_ demo project. It begins with a brief description of "
"the resources used in the final demo and then describes how to make a scene "
"like the demo step by step."
msgstr ""
"本教程以 `灯与影 <https://github.com/godotengine/godot-demo-projects/tree/"
"master/2d/lights_and_shadows>`_ 演示项目解释了2D灯光的工作原理。 本节首先简要"
"介绍了最终演示所使用的资源，然后介绍了如何逐步实现类似演示的场景。"

#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:16
msgid ""
"All the resources for this tutorial can be found in the `official demo "
"repository <https://github.com/godotengine/godot-demo-projects>`_ on github. "
"I suggest you download it before starting. Alternatively, it can be "
"downloaded from the Project Manager. Launch Godot and in the top bar select "
"\"Templates\" and search for \"2D Lights and Shadows Demo\"."
msgstr ""
"本教程的所有资源都可以在github上的 `官方演示存储库 <https://github.com/"
"godotengine/godot-demo-projects>`_ 中找到。 我建议您在开始之前下载它。 或者，"
"也可以在项目管理器中下载。 启动Godot并在顶部栏中选择 \"Templates\" 并搜索 "
"\"2D Lights and Shadows Demo\"。"

#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:24
msgid ""
"For this demo we use four textures: two for the lights, one for the shadow "
"casters, and one for the background. I've included links to them all here if "
"you want to download them separately from the demo."
msgstr ""
"对于这个演示，我们使用四种纹理:两种用于灯光，一种用于阴影脚轮，一种用于背"
"景。 如果您想从演示中单独下载它们，我在这里列出了所有链接。"

#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:28
msgid ""
"The first is the background image (`bg.png <https://raw.githubusercontent."
"com/godotengine/godot-demo-projects/master/2d/lights_and_shadows/bg.png>`_) "
"used in the demo. You do not necessarily need a background, but we use one "
"for the demo."
msgstr ""
"第一个是演示中使用的背景图像 (`bg.png <https://raw.githubusercontent.com/"
"godotengine/godot-demo-projects/master/2d/lights_and_shadows/bg.png>`_ ) 。 "
"您不一定需要背景，但我们还是在演示中用了一个。"

#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:31
msgid ""
"The second is a plain black image (`caster.png <https://raw."
"githubusercontent.com/godotengine/godot-demo-projects/master/2d/"
"lights_and_shadows/caster.png>`_) to use as our shadow caster object. For a "
"top down game this could be a wall or any other object that casts a shadow."
msgstr ""
"第二个是用作影子的纯黑色图片 (`caster.png <https://raw.githubusercontent.com/"
"godotengine/godot-demo-projects/master/2d/lights_and_shadows/caster."
"png>`_ ) 。 对跳跃游戏，它可能是墙或任何其他投射阴影的物体。"

#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:35
msgid ""
"Next is the light itself (`light.png <https://raw.githubusercontent.com/"
"godotengine/godot-demo-projects/master/2d/lights_and_shadows/light.png>`_). "
"If you click the link you will notice how large it is. The image you use for "
"a light should cover the area you want your light to cover. This image is "
"1024x1024 pixels, so you should use it to cover 1024x1024 pixels in your "
"game."
msgstr ""
"接下来是灯本身 (`light.png <https://raw.githubusercontent.com/godotengine/"
"godot-demo-projects/master/2d/lights_and_shadows/light.png>`_ ) 。 如果单击该"
"链接，您会注意到它有多大。 用于灯光的图像应覆盖您希望灯光覆盖的区域。 此图像"
"为1024x1024像素，因此您应该使用它来覆盖游戏中的1024x1024像素。"

#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:40
msgid ""
"Lastly, we have the spotlight image (`spot.png <https://raw."
"githubusercontent.com/godotengine/godot-demo-projects/master/2d/"
"lights_and_shadows/spot.png>`_). The demo uses a blob to show where the "
"light is and the larger light image to show the effect of the light upon the "
"rest of the scene."
msgstr ""
"最后，我们有聚光灯图像 (`spot.png <https://raw.githubusercontent.com/"
"godotengine/godot-demo-projects/master/2d/lights_and_shadows/spot."
"png>`_ ) 。 该演示使用灯泡来显示灯光的位置，使用较大的灯光图片来显示灯光对场"
"景其余部分的影响。"

#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:52
msgid "The demo uses four different nodes:"
msgstr "该演示使用了四个不同类型的节点:"

#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:49
msgid ":ref:`CanvasModulate <class_CanvasModulate>`"
msgstr ":ref:`CanvasModulate <class_CanvasModulate>`"

#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:50
msgid ":ref:`Sprite <class_Sprite>`"
msgstr ":ref:`Sprite <class_Sprite>`"

#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:51
msgid ":ref:`Light2D <class_Light2D>`"
msgstr ":ref:`Light2D <class_Light2D>`"

#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:52
msgid ":ref:`LightOccluder2D <class_LightOccluder2D>`"
msgstr ":ref:`LightOccluder2D <class_LightOccluder2D>`"

#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:54
msgid ""
":ref:`CanvasModulate<class_CanvasModulate>` is used to darken the scene."
msgstr ":ref:`CanvasModulate<class_CanvasModulate>` 用于使场景变暗。"

#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:56
msgid ""
":ref:`Sprites <class_Sprite>` are used to display the textures for the light "
"blobs, the background, and for the shadow casters."
msgstr ":ref:`Sprites <class_Sprite>` 用于显示灯泡，背景和阴影脚轮的纹理。"

#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:59
msgid ""
":ref:`Light2Ds <class_Light2D>` are used to light the scene. The way a light "
"typically works is by adding a selected texture over the rest of the scene "
"to simulate lighting. But it can be used in other ways, for example masking "
"out parts of the scene."
msgstr ""
":ref:`Light2Ds <class_Light2D>` 用于点亮场景。 光通常的工作方式是在场景的其余"
"部分添加选定的纹理以模拟光照。 但它可以以其他方式使用，例如屏蔽部分场景。"

#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:63
msgid ""
":ref:`LightOccluder2Ds <class_LightOccluder2D>` are used to tell the shader "
"which parts of the scene cast shadows. The shadows appear only on areas "
"covered by the :ref:`Light2D <class_Light2D>` and their direction is based "
"on the center of the :ref:`Light <class_Light2D>`."
msgstr ""
":ref:`LightOccluder2Ds <class_LightOccluder2D>` 用于告诉着色器场景的哪些部分"
"投射阴影。 阴影仅出现在 :ref:`Light2D <class_Light2D>` 所覆盖的区域，它们的方"
"向基于 :ref:`Light <class_Light2D>` 的中心。"

#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:70
msgid ""
":ref:`Lights <class_Light2D>` cover the entire extent of their respective "
"Texture. They use additive blending to add the color of their texture to the "
"scene."
msgstr ""
":ref:`Lights <class_Light2D>` 覆盖各自纹理的整个范围。 他们使用添加剂混合将其"
"纹理颜色添加到场景中。"

#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:75
msgid ""
":ref:`Lights <class_Light2D>` have four ``Modes``: ``Add``, ``Sub``, "
"``Mix``, and ``Mask``."
msgstr ""
":ref:`Lights <class_Light2D>` 有四个 ``模式``: ``add``, ``sub``, ``mix``, 和 "
"``mask`` 。"

#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:77
msgid ""
"``Add`` adds the color of the light texture to the scene. It brightens the "
"area under the light."
msgstr "``Add`` 将光纹理的颜色添加到场景中。 它照亮了灯光下的区域。"

#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:79
msgid ""
"``Sub`` subtracts the color of the light from the scene. It darkens the area "
"under the light."
msgstr "``Sub`` 从场景中减去光的颜色。 它使灯光下的区域变暗。"

#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:81
msgid ""
"``Mix`` mixes the color of the light with the underlying scene. The "
"resulting brightness is halfway between the color of the light and the color "
"underneath."
msgstr ""
"``Mix`` 混合了灯光的颜色和底层场景。 产生的亮度介于灯光颜色和下方颜色之间。"

#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:84
msgid ""
"``Mask`` is used to mask out areas that are covered by the light. Masked out "
"areas are hidden or revealed based on the color of the light."
msgstr "``Mask`` 用于掩盖灯光覆盖的区域。 根据光的颜色隐藏或显示蒙面区域。"

#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:87
msgid ""
"For the demo the lights have two components, the :ref:`Light "
"<class_Light2D>` itself (which is the effect of the light), and a :ref:"
"`Sprite <class_Sprite>` blob which is an image showing the location of the "
"light source. A child :ref:`Sprite <class_Sprite>` is not necessary to make "
"a :ref:`Light <class_Light2D>` work."
msgstr ""
"对于演示，灯光有两个组件， :ref:`Light <class_Light2D>` 本身(这是灯光的效"
"果)，和 :ref:`Sprite <class_Sprite>` 灯泡(一个显示光源位置的图片。 子节点 :"
"ref:`Sprite <class_Sprite>` 不是让 :ref:`Light <class_Light2D>` 工作的必要条"
"件。"

#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:95
msgid "Shadows"
msgstr "阴影"

#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:97
msgid ""
"Shadows are made by intersecting a :ref:`Light <class_Light2D>` with a :ref:"
"`LightOccluder2D <class_LightOccluder2D>`."
msgstr ""
"阴影是通过将 :ref:`Light <class_Light2D>` 与 :ref:`LightOccluder2D "
"<class_LightOccluder2D>` 搭配起来制作的。"

#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:99
msgid ""
"By default shadows are turned off. To turn them on click on the :ref:`Light "
"<class_Light2D>` and under the Shadows section check ``Enabled``."
msgstr ""
"默认情况下，阴影处于关闭状态。 要打开它们，请单击 :ref:`Light "
"<class_Light2D>` 并在Shadows部分下面选中 ``Enabled`` 。"

#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:102
msgid ""
"In the demo we are using a :ref:`Sprite <class_Sprite>` with a Texture on it "
"to make the \"Shadow Casters\", but in reality all you need is a couple of :"
"ref:`LightOccluder2Ds <class_LightOccluder2D>`. By itself the :ref:"
"`LightOccluder2D <class_LightOccluder2D>` looks like a dark spot and in this "
"demo the :ref:`Sprite <class_Sprite>` is just a black square."
msgstr ""
"在演示中我们使用带有纹理的 :ref:`Sprite <class_Sprite>` 来制作“影子投射器”，"
"但实际上您只需要几个 :ref:`LightOccluder2Ds <class_LightOccluder2D>` 。 本身"
"的 :ref:`LightOccluder2D <class_LightOccluder2D>` 看起来像一个黑点，在这个演"
"示中 :ref:`Sprite <class_Sprite>` 只是一个黑色方块。"

#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:110
msgid ""
"Now that we have covered the basics of the nodes being used, we can now walk "
"step by step through the process of making a scene like the one found in the "
"demo."
msgstr ""
"现在我们已经介绍了需用到的节点的基础知识，现在我们可以逐步实现演示中的场景。"

#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:113
msgid ""
"First add a :ref:`Sprite <class_Sprite>` and set its texture to the "
"`background image <https://raw.githubusercontent.com/godotengine/godot-demo-"
"projects/master/2d/lights_and_shadows/bg.png>`_. For your game this can be "
"any background you choose. For this style of shadow it is most likely to be "
"a floor texture."
msgstr ""
"首先添加一个 :ref:`Sprite <class_Sprite>` 并将其纹理设置为 `background image "
"<https://raw.githubusercontent.com/godotengine/godot-demo-projects/master/2d/"
"lights_and_shadows/bg.png>`_ 。 对于您的游戏，这可以是您选择的任何背景。 对这"
"种风格的阴影，它很可能是地板纹理。"

#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:118
msgid ""
"Next create three :ref:`Light2D's <class_Light2D>` and set their textures to "
"the `light image <https://raw.githubusercontent.com/godotengine/godot-demo-"
"projects/master/2d/lights_and_shadows/light.png>`_. You can alter their "
"color in the top section. By default shadows are turned off and the ``mode`` "
"is set to ``add``. This means that each light adds its own color to whatever "
"is underneath."
msgstr ""
"接下来创建三个 :ref:`Light2D's <class_Light2D>` 并将它们的纹理设置为 `light "
"image <https://raw.githubusercontent.com/godotengine/godot-demo-projects/"
"master/2d/lights_and_shadows/light.png>`_ 。 您可以在顶部更改颜色。 默认情况"
"下，阴影关闭并且 ``mode`` 设置为 ``add`` 。 这意味着每个灯光都会将自己的颜色"
"添加到下面的任何颜色中。"

#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:124
msgid ""
"Next add a child :ref:`Sprite <class_Sprite>` to each of the :ref:`Light "
"<class_Light2D>` nodes, and set the :ref:`Sprite's <class_Sprite>` texture "
"to the `blob image <https://raw.githubusercontent.com/godotengine/godot-demo-"
"projects/master/2d/lights_and_shadows/spot.png>`_. Each of these should stay "
"centered on the :ref:`Light <class_Light2D>` node. The blob is the image of "
"the light itself while the :ref:`Light <class_Light2D>` shows the effect "
"that the light has on the scene. The :ref:`LightOccluder2D's "
"<class_LightOccluder2D>` will treat the position of the light as the center "
"of the :ref:`Light <class_Light2D>` node, which is why we want the blob to "
"be centered on its parent :ref:`Light <class_Light2D>`."
msgstr ""
"接下来为每个 :ref:`Light <class_Light2D>` 节点添加一个 :ref:`Sprite "
"<class_Sprite>` 子节点，并将 :ref:`Sprite's <class_Sprite>` 纹理设置为 `blob "
"image <https://raw.githubusercontent.com/godotengine/godot-demo-projects/"
"master/2d/lights_and_shadows/spot.png>`_ 。 其中每个都应该集中在 :ref:`Light "
"<class_Light2D>` 节点。blob是灯本身的图像，而 :ref:`Light <class_Light2D>` 显"
"示灯光对场景的影响。 :ref:`LightOccluder2D's <class_LightOccluder2D>` 会将光"
"的位置视为 :ref:`Light <class_Light2D>` 节点的中心，这就是为什么我们希望blob"
"位于父节点 :ref:`Light <class_Light2D>` 的中心的原因。"

#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:133
msgid ""
"At the time of writing, 3.0 is the stable release version. The 3.1 "
"development branch contains many changes to the animation system, so the "
"animations in the demo will not be covered here. See :ref:"
"`doc_introduction_2d_animation` for more information."
msgstr ""
"在撰写本文时，3.0是稳定版本。 3.1开发版本已经对动画系统的做了许多更改，因此此"
"处不会介绍演示中的动画。 请参阅 :ref:Introduction to 2D Animation. "
"<doc_introduction_2d> 以了解更多信息。"

#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:137
msgid ""
"Right now the scene should look too bright. This is because all three lights "
"are adding color to the scene. This is why the demo uses a :ref:"
"`CanvasModulate <class_CanvasModulate>` in the scene. The :ref:"
"`CanvasModulate <class_CanvasModulate>` multiples the entire viewport by a "
"specific color."
msgstr ""
"现在场景看起来太亮了。 这是因为三个灯都在为场景添加颜色。 这就是演示场景使"
"用 :ref:`CanvasModulate <class_CanvasModulate>` 的原因。 :ref:"
"`CanvasModulate <class_CanvasModulate>` 将整个视区乘以特定颜色。"

#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:141
msgid ""
"Add a :ref:`CanvasModulate <class_CanvasModulate>` to the scene and set its "
"color to ``rgb(70, 70, 70)``. This will make the scene sufficiently dark to "
"see the effects of the lights distinctly."
msgstr ""
"在场景中添加 :ref:`CanvasModulate <class_CanvasModulate>` 并将其颜色设置为 "
"``rgb(70, 70, 70)`` 。 这将使场景足够暗，以清楚地看到灯光的效果。"

#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:146
msgid "Now we add the shadow casters."
msgstr "现在，我们添加阴影投射器。"

#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:148
msgid ""
"The demo uses a :ref:`Node <class_Node2D>` named \"casters\" to organize the "
"shadow casters. Add a :ref:`Node2D <class_Node2D>` to the scene. It will be "
"used to group all the shadow casters together. This way we can show and hide "
"them all at the same time."
msgstr ""
"该演示使用了一个名为“casters”的 :ref:`Node <class_Node2D>` 来组织阴影投射"
"器。 在场景中添加 :ref:`Node2D <class_Node2D>` 。 它将所有阴影投射器组合在一"
"起。 这样我们就可以同时显示和隐藏它们。"

#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:152
msgid ""
"Each shadow caster is made of a :ref:`Sprite <class_Sprite>`, with a :ref:"
"`LightOccluder2D <class_LightOccluder2D>` child. For the demo the :ref:"
"`Sprite <class_Sprite>` has a texture set to the `caster image <https://raw."
"githubusercontent.com/godotengine/godot-demo-projects/master/2d/"
"lights_and_shadows/caster.png>`_ and nothing else. The child :ref:"
"`LightOccluder2D <class_LightOccluder2D>` is where all the magic happens. In "
"a game the :ref:`Sprite <class_Sprite>` could be more than a black box; it "
"could be an image of whatever object is casting the shadow: a wall, a "
"magical chest, or anything else."
msgstr ""
"每个阴影投射器都由具有 :ref:`LightOccluder2D <class_LightOccluder2D>` 子节点"
"的 :ref:`Sprite <class_Sprite>` 组成。 在演示中， :ref:`Sprite "
"<class_Sprite>` 的纹理设置为 `caster image <https://raw.githubusercontent."
"com/godotengine/godot-demo-projects/master/2d/lights_and_shadows/caster."
"png>`_ 。 子节点 :ref:`LightOccluder2D <class_LightOccluder2D>` 是所有魔法发"
"生的地方。 在游戏中 :ref:`Sprite <class_Sprite>` 可能不仅仅是一个黑盒子; 它可"
"以是任何可以投射阴影的物体的图片:一面墙，一个宝箱或其他任何东西。"

#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:160
msgid ""
":ref:`LightOccluder2Ds <class_LightOccluder2D>` tell the game what shape the "
"occluder has. They hold an :ref:`OccluderPolygon2D "
"<class_OccluderPolygon2D>`, which is a container for a polygon and some "
"other information. For this demo, since our wall is a square, we set "
"``Polygon`` to a square. The other default settings are fine."
msgstr ""
":ref:`LightOccluder2Ds <class_LightOccluder2D>` 告诉游戏封堵器是什么形状。封"
"堵器是一个多边形的容器 :ref:`OccluderPolygon2D <class_OccluderPolygon2D>` 。 "
"对于这个演示，由于我们的墙是正方形，我们将 ``Polygon`` 设置为正方形。 其他设"
"置保持为默认。"

#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:165
msgid ""
"The first setting, ``Closed`` can be either ``on`` or ``off``. A closed "
"polygon occludes light coming from all directions. An open polygon only "
"occludes light from one direction"
msgstr ""
"对于第一个设置， ``Closed`` 可以是 ``on`` 或 ``off`` 。 闭合的多边形遮挡来自"
"所有方向的光线。 开放多边形仅遮挡来自一个方向的光线"

#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:168
msgid ""
"``Cull Mode`` lets you select which direction gets culled. The default is "
"``Disabled``, meaning the occluder will cast a shadow no matter which side "
"the light is on. The other two settings ``Clockwise`` and ``Counter-"
"Clockwise`` refer to the winding order of the vertices of the polygon. The "
"winding order is used to determine which side of the line is inside the "
"polygon. Only outward facing lines cast shadows."
msgstr ""
"``Cull Mode`` 让您选择剔除的方向。 默认值为“已禁用”，这意味着无论灯光在哪一"
"侧，遮挡物都会投射阴影。 另外两个设置 ``Clockwise`` 和 ``Counter-Clockwise`` "
"指的是多边形顶点的弯曲顺序。 弯曲顺序用于确定光线的哪一侧在多边形内。 只有朝"
"外的光线才投下阴影。"

#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:173
msgid ""
"To illustrate the difference, here is an image of a :ref:`LightOccluder2D "
"<class_LightOccluder2D>` with ``Closed`` set to ``off`` in the "
"corresponding :ref:`OccluderPolygon2D <class_OccluderPolygon2D>`, so that "
"the lines of the polygon can be seen:"
msgstr ""
"为了说明差异，这里是一个 :ref:`OccluderPolygon2D <class_OccluderPolygon2D>` "
"上的 ``Closed`` 设置为 ``off`` 的图片 :ref:`LightOccluder2D "
"<class_LightOccluder2D>` ，使得可以看到多边形的轮廓:"

#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:179
msgid "``Cull Mode`` is set to ``Disabled``. All three lines cast shadows."
msgstr "``Cull Mode`` 设置为 ``Disabled`` 。 全部三条线都投下阴影。"

#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:183
msgid ""
"``Cull Mode`` is set to ``Clockwise``. Only the top and right lines cast "
"shadows."
msgstr "``Cull Mode`` 设置为 ``Clockwise`` 。 只有顶部和右侧线条投射阴影。"

#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:187
msgid ""
"``Cull Mode`` is set to ``Counter-Clockwise``. Only the bottom line casts a "
"shadow. If ``Closed`` was set to ``on`` there would be an additional "
"vertical line on the left which would cast a shadow as well."
msgstr ""
"``Cull Mode`` 设置为 ``Counter-Clockwise`` 。 只有底线投下阴影。 如果 "
"``Closed`` 设置为 ``on`` ，左边会有一条额外的垂直线也会投射阴影。"

#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:191
msgid ""
"When you have added the :ref:`LightOccluder2Ds <class_LightOccluder2D>` the "
"shadows still won't appear. You need to go back into the :ref:`Light2Ds "
"<class_Light2D>` and under the Shadow section set ``Enable`` to ``on``. This "
"turns on shadows with hard edges like in the image below."
msgstr ""
"当您添加 :ref:`LightOccluder2Ds <class_LightOccluder2D>` 时，阴影仍不会出"
"现。 您需要回到 :ref:`Light2Ds <class_Light2D>` 并在Shadow部分下设置 "
"``Enable`` 为 ``on`` 。 这将打开带有硬边的阴影，如下图所示。"

#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:197
msgid ""
"To give the shadows that nice, soft edge look we set the variables "
"``filter``, ``filter smooth``, and ``gradient length``. Godot supports "
"`Percentage Closer Filtering <https://developer.nvidia.com/gpugems/GPUGems/"
"gpugems_ch11.html>`_ (PCF), which takes multiple samples of the shadow map "
"around a pixel and blurs them to create a smooth shadow effect. The higher "
"the number of samples the smoother the shadow will look, but the slower it "
"will run. That is why Godot provides 3-13 samples by default and allows you "
"to choose. The demo uses PCF7."
msgstr ""
"为了给出看起来更好的柔和边缘阴影，我们设置变量 ``filter`` ， ``filter "
"smooth`` 和 ``gradient length`` 。 Godot支持 `Percentage Closer Filtering "
"<https://developer.nvidia.com/gpugems/GPUGems/gpugems_ch11.html>`_ (PCF) ，它"
"在像素周围提取阴影贴图的多个样本，并模糊它们以创建平滑的阴影效果。 样本数越"
"多，阴影看起来越平滑但运行速度越慢。 这就是为什么Godot默认提供3-13个样本来让"
"您选择。 该演示使用PCF7。"

#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:206
msgid ""
"This is a shadow rendered with the demo's settings. ``gradient length`` is "
"set to ``1.3``, ``filter smooth`` is set to ``11.1``, and ``filter`` is set "
"to ``PCF7``."
msgstr ""
"这是使用演示中设置渲染的阴影。 ``gradient length`` 设置为 ``1.3`` ， "
"``filter smooth`` 设置为 ``11.1`` ， ``filter`` 设置为 ``PCF7`` 。"

#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:211
msgid ""
"``filter`` is set to ``PCF13``. Notice how the shadow becomes wider, this is "
"because the distance between samples is based on the variable ``filter "
"smooth``."
msgstr ""
"``filter`` 设置为 ``PCF13`` 。 注意到阴影变宽了，这是因为样本之间的距离是依赖"
"于变量 ``filter smooth`` 的。"

#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:214
msgid ""
"In order to make use of filtering you need to set the ``filter smooth`` "
"variable. This dictates how far apart the samples are. If you want the soft "
"area to extend quite far, you can increase the size of ``filter smooth``. "
"However, with few samples and a large filter smooth, you can see lines "
"forming between the samples."
msgstr ""
"为了使用过滤，您需要设置 ``filter smooth`` 变量。 这决定了样品之间的距离。 如"
"果您想让柔软区域延伸很远，您可以增加 ``filter smooth`` 的大小。 然而，在低样"
"品和大过滤平滑的，您会看到样本之间形成的线条。"

#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:221
#, fuzzy
msgid "``filter smooth`` is set to ``30``."
msgstr "``filter smooth`` 设置为 ``30`` 。"

#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:223
msgid ""
"The different :ref:`Light <class_Light2D>` nodes in the demo use different "
"values for filter smooth. Play around with it and see what you like."
msgstr ""
"演示中的不同 :ref:`Light <class_Light2D>` 节点使用不同的值来过滤平滑。 调试"
"它，看看您喜欢什么样的。"

#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:228
msgid "``filter smooth`` is set to ``0``."
msgstr "``filter smooth`` 设置为 ``0`` 。"

#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:230
msgid ""
"Lastly, there is the variable ``gradient length``. For some smooth shadows "
"it is preferable not to have the shadow start immediately on the object, as "
"this produces a hard edge. The gradient length variable creates a smooth "
"gradient to begin the shadow to reduce the effect of the hard edge."
msgstr ""
"最后谈谈变量 ``gradient length`` 。 对于一些平滑阴影，最好不要在对象上立即开"
"始阴影，因为这会产生硬边。 渐变长度变量创建阴影的平滑渐变，以减少硬边缘的影"
"响。"

#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:236
msgid "``gradient length`` is set to ``0``."
msgstr "``gradient length`` 设置为 ``0`` 。"

#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:240
msgid "``gradient length`` is set to ``10``."
msgstr "``gradient length`` 设置为 ``10`` 。"

#: ../../docs/tutorials/2d/2d_lights_and_shadows.rst:242
msgid ""
"You will need to play around with the options a bit to find settings that "
"suit your project. There is no right solution for everyone, which is why "
"Godot provides so much flexibility. Just keep in mind that the higher "
"``filter`` set the more expensive the shadows will be."
msgstr ""
"您需要稍微调整设置以找到适合您项目的设置。 每个人都没有正确的解决方案，这就是"
"Godot为什么提供如此多灵活性的原因。 请记住，较高的 ``filter`` 设置会导致阴影"
"的计算成本更高。"

#: ../../docs/tutorials/2d/2d_meshes.rst:4
#, fuzzy
msgid "2D meshes"
msgstr "网格"

#: ../../docs/tutorials/2d/2d_meshes.rst:9
#, fuzzy
msgid ""
"In 3D, meshes are used to display the world. In 2D, they are rare as images "
"are used more often. Godot's 2D engine is a pure two dimensional engine, so "
"it can't really display 3D meshes directly (although it can be done via "
"``Viewport`` and ``ViewportTexture``)."
msgstr ""
"在3D中，网格用于显示世界。在2D中，这么做却不常见，通过图片的使用方式更频繁。"
"Godot的2D部分是一个纯2D引擎，因此它不能直接显示3D网格(尽管它可以通过"
"``Viewport`` and ``ViewportTexture``完成)。"

#: ../../docs/tutorials/2d/2d_meshes.rst:13
msgid ""
"If you are interested in displaying 3D meshes on a 2D viewport, see the :ref:"
"`doc_viewport_as_texture` tutorial."
msgstr ""
"如果您对在二维视区上显示三维网格感兴趣，请参见：ref:`doc_viewport_as_texture`"
"教程。"

#: ../../docs/tutorials/2d/2d_meshes.rst:15
msgid ""
"2D meshes are meshes that contain two dimensional geometry (Z can be omitted "
"or ignored) instead of 3D. You can experiment creating them yourself using "
"``SurfaceTool`` from code and displaying them in a ``MeshInstance2D`` node."
msgstr ""

#: ../../docs/tutorials/2d/2d_meshes.rst:18
msgid ""
"Currently, the only way to generate a 2D mesh within the editor is by either "
"importing an OBJ file as a mesh, or converting it from a Sprite."
msgstr ""

#: ../../docs/tutorials/2d/2d_meshes.rst:21
#, fuzzy
msgid "Optimizing pixels drawn"
msgstr "优化大小的构建"

#: ../../docs/tutorials/2d/2d_meshes.rst:23
msgid ""
"This workflow is useful for optimizing 2D drawing in some situations. When "
"drawing large images with transparency, Godot will draw the whole quad to "
"the screen. The large transparent areas will still be drawn."
msgstr ""

#: ../../docs/tutorials/2d/2d_meshes.rst:25
msgid ""
"This can affect performance, especially on mobile devices, when drawing very "
"large images (generally screen sized), or layering multiple images on top of "
"each other with large transparent areas (for example, when using "
"``ParallaxBackground``)."
msgstr ""

#: ../../docs/tutorials/2d/2d_meshes.rst:28
msgid ""
"Converting to a mesh will ensure that only the opaque parts will be drawn "
"and the rest will be ignored."
msgstr ""

#: ../../docs/tutorials/2d/2d_meshes.rst:31
#, fuzzy
msgid "Converting Sprites to 2D meshes"
msgstr "将键转换为文本"

#: ../../docs/tutorials/2d/2d_meshes.rst:33
msgid ""
"You can take advantage of this optimization by converting a ``Sprite`` to a "
"``MeshInstance2D``. Start with an image that contains large amounts of "
"transparency on the edges, like this tree:"
msgstr ""

#: ../../docs/tutorials/2d/2d_meshes.rst:38
msgid "Put it in a ``Sprite`` and select \"Convert to 2D Mesh\" from the menu:"
msgstr ""

#: ../../docs/tutorials/2d/2d_meshes.rst:42
msgid ""
"A dialog will appear, showing a preview of how the 2D mesh will be created:"
msgstr ""

#: ../../docs/tutorials/2d/2d_meshes.rst:46
msgid ""
"The default values are good enough for many cases, but you can change growth "
"and simplification according to your needs:"
msgstr ""

#: ../../docs/tutorials/2d/2d_meshes.rst:50
msgid ""
"Finally, push the ``Convert 2D Mesh`` button and your Sprite will be "
"replaced:"
msgstr ""

#: ../../docs/tutorials/2d/custom_drawing_in_2d.rst:4
msgid "Custom drawing in 2D"
msgstr "2D中自定义绘图"

#: ../../docs/tutorials/2d/custom_drawing_in_2d.rst:7
#: ../../docs/tutorials/io/encrypting_save_games.rst:7
msgid "Why?"
msgstr "为什么？"

#: ../../docs/tutorials/2d/custom_drawing_in_2d.rst:9
msgid ""
"Godot has nodes to draw sprites, polygons, particles, and all sorts of "
"stuff. For most cases, this is enough; but not always. Before crying in "
"fear, angst, and rage because a node to draw that specific *something* does "
"not exist... it would be good to know that it is possible to easily make any "
"2D node (be it :ref:`Control <class_Control>` or :ref:`Node2D "
"<class_Node2D>` based) draw custom commands. It is *really* easy to do it, "
"too."
msgstr ""
"Godot有绘制精灵、多边形、粒子和各种东西的节点。 在大多数情况下，这已足够但并"
"不总是 。在因为不存在绘制特定 *东西* 的节点，而恐惧、焦虑和愤怒之前...有必要"
"知道引擎有轻松绘制任何2D节点(不管它是继承自 :ref:`Control <class_Control>` "
"或 :ref:`Node2D <class_Node2D>` )的自定义命令。 绘制 *真的* 很容易。"

#: ../../docs/tutorials/2d/custom_drawing_in_2d.rst:17
msgid "But..."
msgstr "但是..."

#: ../../docs/tutorials/2d/custom_drawing_in_2d.rst:19
msgid ""
"Custom drawing manually in a node is *really* useful. Here are some examples "
"why:"
msgstr "在节点中手动自定义绘图 *真的* 非常有用。 以下是一些示例:"

#: ../../docs/tutorials/2d/custom_drawing_in_2d.rst:22
msgid ""
"Drawing shapes or logic that is not handled by nodes (example: making a node "
"that draws a circle, an image with trails, a special kind of animated "
"polygon, etc)."
msgstr ""
"绘制未由节点处理的形状或逻辑(例如:制作一个可以绘制圆的节点，带有轨迹的图像，"
"特殊类型的动画多边形等)。"

#: ../../docs/tutorials/2d/custom_drawing_in_2d.rst:25
msgid ""
"Visualizations that are not that compatible with nodes: (example: a tetris "
"board). The tetris example uses a custom draw function to draw the blocks."
msgstr ""
"与节点不兼容的可视化:(例如:俄罗斯方块板)。 俄罗斯方块示例使用自定义绘制功能来"
"绘制块。"

#: ../../docs/tutorials/2d/custom_drawing_in_2d.rst:28
msgid ""
"Drawing a large number of simple objects. Custom drawing avoids the overhead "
"of using nodes which makes it less memory intensive and potentially faster."
msgstr ""

#: ../../docs/tutorials/2d/custom_drawing_in_2d.rst:31
msgid ""
"Making a custom UI control. There are plenty of controls available, but it's "
"easy to run into the need to make a new, custom one."
msgstr ""
"制作自定义UI控件。 尽管有很多可用的控件，但很容易遇到需要制作新自定义控件的情"
"况。"

#: ../../docs/tutorials/2d/custom_drawing_in_2d.rst:35
msgid "OK, how?"
msgstr "好吧，怎么办？"

#: ../../docs/tutorials/2d/custom_drawing_in_2d.rst:37
#, fuzzy
msgid ""
"Add a script to any :ref:`CanvasItem <class_CanvasItem>` derived node, like :"
"ref:`Control <class_Control>` or :ref:`Node2D <class_Node2D>`. Then override "
"the ``_draw()`` function."
msgstr ""
"将脚本添加到任何 :ref:`CanvasItem <class_CanvasItem>` 派生节点，如 :ref:"
"`Control <class_Control>` 或 :ref:`Node2D <class_Node2D>`。 然后覆盖_draw()函"
"数。"

#: ../../docs/tutorials/2d/custom_drawing_in_2d.rst:57
msgid ""
"Draw commands are described in the :ref:`CanvasItem <class_CanvasItem>` "
"class reference. There are plenty of them."
msgstr ""
"Draw命令在 :ref:`CanvasItem <class_CanvasItem>` 类型参考中描述。 有很多。"

#: ../../docs/tutorials/2d/custom_drawing_in_2d.rst:61
msgid "Updating"
msgstr "升级"

#: ../../docs/tutorials/2d/custom_drawing_in_2d.rst:63
#, fuzzy
msgid ""
"The ``_draw()`` function is only called once, and then the draw commands are "
"cached and remembered, so further calls are unnecessary."
msgstr "_draw() 函数只调用一次，然后缓存并记住绘制命令，因此不需要进一步调用。"

#: ../../docs/tutorials/2d/custom_drawing_in_2d.rst:66
#, fuzzy
msgid ""
"If re-drawing is required because a state or something else changed, simply "
"call :ref:`CanvasItem.update() <class_CanvasItem_method_update>` in that "
"same node and a new ``_draw()`` call will happen."
msgstr ""
"如果由于状态或其他更改而需要重新绘制，只需在同一节点中调用 :ref:`CanvasItem."
"update()<class_CanvasItem_method_update>` 并且将发生新的_draw()调用。"

#: ../../docs/tutorials/2d/custom_drawing_in_2d.rst:70
msgid ""
"Here is a little more complex example, a texture variable that will be "
"redrawn if modified:"
msgstr "这是一个更复杂的示例。 如果改变，将重绘的纹理变量:"

#: ../../docs/tutorials/2d/custom_drawing_in_2d.rst:114
#, fuzzy
msgid ""
"In some cases, it may be desired to draw every frame. For this, just call "
"``update()`` from the ``_process()`` callback, like this:"
msgstr ""
"在某些情况下，可能需要绘制每一帧。 为此，只需从_process()回调调用update()，如"
"下所示:"

#: ../../docs/tutorials/2d/custom_drawing_in_2d.rst:146
msgid "An example: drawing circular arcs"
msgstr "一个示例:绘制圆弧"

#: ../../docs/tutorials/2d/custom_drawing_in_2d.rst:148
#, fuzzy
msgid ""
"We will now use the custom drawing functionality of the Godot Engine to draw "
"something that Godot doesn't provide functions for. As an example, Godot "
"provides a ``draw_circle()`` function that draws a whole circle. However, "
"what about drawing a portion of a circle? You will have to code a function "
"to perform this and draw it yourself."
msgstr ""
"我们现在将使用Godot Engine的自定义绘图功能来绘制Godot不提供功能的内容。 作为"
"一个示例，Godot提供了draw_circle()函数，它绘制了一个完整的圆。 但是，画一个圆"
"的一部分怎么样？ 您必须编写一个函数来执行此操作并自己绘制它。"

#: ../../docs/tutorials/2d/custom_drawing_in_2d.rst:154
msgid "Arc function"
msgstr "弧函数"

#: ../../docs/tutorials/2d/custom_drawing_in_2d.rst:156
msgid ""
"An arc is defined by its support circle parameters, that is, the center "
"position and the radius. The arc itself is then defined by the angle it "
"starts from and the angle at which it stops. These are the 4 arguments that "
"we have to provide to our drawing function. We'll also provide the color "
"value, so we can draw the arc in different colors if we wish."
msgstr ""
"弧由其支撑圆参数定义。 即:中心位置和半径。 然后通过它开始的角度和停止的角度来"
"定义弧本身。 这些是我们必须为绘图提供的4个参数。 我们还将提供颜色值，因此我们"
"可以根据需要绘制不同颜色的圆弧。"

#: ../../docs/tutorials/2d/custom_drawing_in_2d.rst:161
msgid ""
"Basically, drawing a shape on the screen requires it to be decomposed into a "
"certain number of points linked from one to the next. As you can imagine, "
"the more points your shape is made of, the smoother it will appear, but the "
"heavier it will also be in terms of processing cost. In general, if your "
"shape is huge (or in 3D, close to the camera), it will require more points "
"to be drawn without it being angular-looking. On the contrary, if your shape "
"is small (or in 3D, far from the camera), you may decrease its number of "
"points to save processing costs; this is known as *Level of Detail (LoD)*. "
"In our example, we will simply use a fixed number of points, no matter the "
"radius."
msgstr ""
"基本上，在屏幕上绘制形状需要将其分解为从一个到下一个链接的特定数量的点。 您可"
"以想象，您的形状越多，它就越平滑，但在加工成本方面也越重。 一般来说，如果您的"
"形状很大(或者在3D中，靠近相机)，则需要绘制更多的点，而不会看起来像是有角度"
"的。 相反，如果您的形状很小(或3D，远离相机)，您可以减少其点数以节省处理成"
"本。 这称为 *细节级别(LoD)* 。 在我们的示例中，无论半径如何，我们都只使用固定"
"数量的点。"

#: ../../docs/tutorials/2d/custom_drawing_in_2d.rst:201
#, fuzzy
msgid ""
"Remember the number of points our shape has to be decomposed into? We fixed "
"this number in the ``nb_points`` variable to a value of ``32``. Then, we "
"initialize an empty ``PoolVector2Array``, which is simply an array of "
"``Vector2``\\ s."
msgstr ""
"还记得我们的形状必须分解成的点数吗？ 我们将nb_points变量中的这个数字修改为32."
"然后，我们初始化一个空的PoolVector2Array，它只是一个Vector2数组。"

#: ../../docs/tutorials/2d/custom_drawing_in_2d.rst:205
msgid ""
"The next step consists of computing the actual positions of these 32 points "
"that compose an arc. This is done in the first for-loop: we iterate over the "
"number of points for which we want to compute the positions, plus one to "
"include the last point. We first determine the angle of each point, between "
"the starting and ending angles."
msgstr ""
"下一步包括计算构成弧的这32个点的实际位置。 这是在第一个for循环中完成的:我们迭"
"代我们想要计算位置的点数，加上一个包括最后一个点。 我们首先确定起点和终点之间"
"每个点的角度。"

#: ../../docs/tutorials/2d/custom_drawing_in_2d.rst:210
#, fuzzy
msgid ""
"The reason why each angle is decreased by 90° is that we will compute 2D "
"positions out of each angle using trigonometry (you know, cosine and sine "
"stuff...). However, to be simple, ``cos()`` and ``sin()`` use radians, not "
"degrees. The angle of 0° (0 radian) starts at 3 o'clock, although we want to "
"start counting at 12 o'clock. So we decrease each angle by 90° in order to "
"start counting from 12 o'clock."
msgstr ""
"每个角度减小90°的原因是我们将使用三角学计算每个角度的2D位置(您知道，余弦和正"
"弦的东西......)。 但是，简单来说，cos()和sin()使用弧度，而不是度数。 虽然我们"
"想在12点钟开始计数，但0°(0弧度)的角度从3点钟开始。 因此我们将每个角度减小"
"90°，以便从12点开始计数。"

#: ../../docs/tutorials/2d/custom_drawing_in_2d.rst:216
#, fuzzy
msgid ""
"The actual position of a point located on a circle at angle ``angle`` (in "
"radians) is given by ``Vector2(cos(angle), sin(angle))``. Since ``cos()`` "
"and ``sin()`` return values between -1 and 1, the position is located on a "
"circle of radius 1. To have this position on our support circle, which has a "
"radius of ``radius``, we simply need to multiply the position by ``radius``. "
"Finally, we need to position our support circle at the ``center`` position, "
"which is performed by adding it to our ``Vector2`` value. Finally, we insert "
"the point in the ``PoolVector2Array`` which was previously defined."
msgstr ""
"以角度'角度'(以弧度表示)位于圆上的点的实际位置由Vector2(cos(角度)，sin(角度))"
"给出。 由于cos()和sin()返回介于-1和1之间的值，因此位置位于半径为1的圆上。要将"
"此位置放在我们的半径为“半径”的支撑圆上，我们只需要乘以 “半径”的位置。 最后，"
"我们需要将我们的支持圈定位在“中心”位置，这是通过将其添加到我们的Vector2值来执"
"行的。 最后，我们在之前定义的PoolVector2Array中插入点。"

#: ../../docs/tutorials/2d/custom_drawing_in_2d.rst:224
msgid ""
"Now, we need to actually draw our points. As you can imagine, we will not "
"simply draw our 32 points: we need to draw everything that is between each "
"of them. We could have computed every point ourselves using the previous "
"method, and drew it one by one. But this is too complicated and inefficient "
"(except if explicitly needed), so we simply draw lines between each pair of "
"points. Unless the radius of our support circle is big, the length of each "
"line between a pair of points will never be long enough to see them. If that "
"were to happen, we would simply need to increase the number of points."
msgstr ""
"现在，我们需要实际绘制我们的观点。 您可以想象，我们不会简单地画出我们的32点:"
"我们需要绘制每一点之间的所有内容。 我们可以使用前面的方法自己计算每个点，然后"
"逐个绘制。 但这太复杂和低效(除非明确需要)。 因此，我们只需在每对点之间绘制线"
"条。 除非我们的支撑圆的半径很大，否则一对点之间每条线的长度永远不会长到足以看"
"到它们。 如果发生这种情况，我们只需要增加点数。"

#: ../../docs/tutorials/2d/custom_drawing_in_2d.rst:234
msgid "Draw the arc on the screen"
msgstr "在屏幕上绘制弧形"

#: ../../docs/tutorials/2d/custom_drawing_in_2d.rst:236
#, fuzzy
msgid ""
"We now have a function that draws stuff on the screen; it is time to call it "
"inside the ``_draw()`` function:"
msgstr "我们现在有一个在屏幕上绘制内容的函数:是时候调用_draw()函数了:"

#: ../../docs/tutorials/2d/custom_drawing_in_2d.rst:263
msgid "Result:"
msgstr "结果:"

#: ../../docs/tutorials/2d/custom_drawing_in_2d.rst:268
msgid "Arc polygon function"
msgstr "弧多边形功能"

#: ../../docs/tutorials/2d/custom_drawing_in_2d.rst:270
msgid ""
"We can take this a step further and not only write a function that draws the "
"plain portion of the disc defined by the arc, but also its shape. The method "
"is exactly the same as before, except that we draw a polygon instead of "
"lines:"
msgstr ""
"我们可以更进一步，不仅可以编写一个函数来绘制由弧定义的光盘的平面部分，还可以"
"绘制其形状。 该方法与以前完全相同，只是我们绘制多边形而不是线条:"

#: ../../docs/tutorials/2d/custom_drawing_in_2d.rst:310
msgid "Dynamic custom drawing"
msgstr "动态自定义绘图"

#: ../../docs/tutorials/2d/custom_drawing_in_2d.rst:312
msgid ""
"All right, we are now able to draw custom stuff on the screen. However, it "
"is static; let's make this shape turn around the center. The solution to do "
"this is simply to change the angle_from and angle_to values over time. For "
"our example, we will simply increment them by 50. This increment value has "
"to remain constant or else the rotation speed will change accordingly."
msgstr ""
"好吧，我们现在能够在屏幕上绘制自定义内容。 然而，它是静态的:让我们围绕中心转"
"动这个形状。 这样做的解决方案就是随着时间的推移改变angle_from和angle_to值。 "
"对于我们的示例，我们将简单地将它们递增50.此增量值必须保持不变，否则旋转速度将"
"相应地改变。"

#: ../../docs/tutorials/2d/custom_drawing_in_2d.rst:318
#, fuzzy
msgid ""
"First, we have to make both angle_from and angle_to variables global at the "
"top of our script. Also note that you can store them in other nodes and "
"access them using ``get_node()``."
msgstr ""
"首先，我们必须在我们的脚本顶部使angle_from和angle_to变量全局化。 另请注意，您"
"可以将它们存储在其他节点中并使用get_node()访问它们。"

#: ../../docs/tutorials/2d/custom_drawing_in_2d.rst:340
msgid "We make these values change in the _process(delta) function."
msgstr "我们在_process(delta)函数中更改这些值。"

#: ../../docs/tutorials/2d/custom_drawing_in_2d.rst:342
#, fuzzy
msgid ""
"We also increment our angle_from and angle_to values here. However, we must "
"not forget to ``wrap()`` the resulting values between 0 and 360°! That is, "
"if the angle is 361°, then it is actually 1°. If you don't wrap these "
"values, the script will work correctly, but the angle values will grow "
"bigger and bigger over time until they reach the maximum integer value Godot "
"can manage (``2^31 - 1``). When this happens, Godot may crash or produce "
"unexpected behavior."
msgstr ""
"我们还在这里增加angle_from和angle_to值。 但是，我们不能忘记将结果值包装()在0"
"到360°之间！ 也就是说，如果角度是361°，那么它实际上是1°。 如果您不包装这些"
"值，脚本将正常工作，但角度值将随着时间的推移变得越来越大，直到它们达到Godot可"
"以管理的最大整数值(2 ^ 31-1)。 当发生这种情况时，Godot可能会崩溃或产生意外行"
"为。 由于Godot不提供wrap()函数，我们将在这里创建它，因为它相对简单。"

#: ../../docs/tutorials/2d/custom_drawing_in_2d.rst:349
#, fuzzy
msgid ""
"Finally, we must not forget to call the ``update()`` function, which "
"automatically calls ``_draw()``. This way, you can control when you want to "
"refresh the frame."
msgstr ""
"最后，我们不要忘记调用update()函数，它自动调用_draw()。 这样，您可以控制何时"
"刷新帧。"

#: ../../docs/tutorials/2d/custom_drawing_in_2d.rst:389
#, fuzzy
msgid ""
"Also, don't forget to modify the ``_draw()`` function to make use of these "
"variables:"
msgstr "另外，不要忘记修改_draw()函数以使用这些变量:"

#: ../../docs/tutorials/2d/custom_drawing_in_2d.rst:413
msgid ""
"Let's run! It works, but the arc is rotating insanely fast! What's wrong?"
msgstr "我们运行吧！ 它工作正常，但弧线快速旋转！ 怎么了？"

#: ../../docs/tutorials/2d/custom_drawing_in_2d.rst:416
#, fuzzy
msgid ""
"The reason is that your GPU is actually displaying the frames as fast as it "
"can. We need to \"normalize\" the drawing by this speed; to achieve that, we "
"have to make use of the ``delta`` parameter of the ``_process()`` function. "
"``delta`` contains the time elapsed between the two last rendered frames. It "
"is generally small (about 0.0003 seconds, but this depends on your "
"hardware), so using ``delta`` to control your drawing ensures that your "
"program runs at the same speed on everybody's hardware."
msgstr ""
"原因是您的GPU实际上正在尽可能快地显示帧。 我们需要以此速度“标准化”绘图。 为了"
"实现，我们必须使用_process()函数的'delta'参数。 'delta'包含最后两个渲染帧之间"
"经过的时间。 它通常很小(约0.0003秒，但这取决于您的硬件)。 因此，使用“delta”来"
"控制绘图可确保程序在每个人的硬件上以相同的速度运行。"

#: ../../docs/tutorials/2d/custom_drawing_in_2d.rst:424
#, fuzzy
msgid ""
"In our case, we simply need to multiply our ``rotation_angle`` variable by "
"``delta`` in the ``_process()`` function. This way, our 2 angles will be "
"increased by a much smaller value, which directly depends on the rendering "
"speed."
msgstr ""
"在我们的示例中，我们只需要在_process()函数中将'rotation_angle'变量乘"
"以'delta'。 这样，我们的2个角度将增加一个更小的值，这直接取决于渲染速度。"

#: ../../docs/tutorials/2d/custom_drawing_in_2d.rst:458
msgid "Let's run again! This time, the rotation displays fine!"
msgstr "让我们再运行一次！ 这次，旋转显示正常！"

#: ../../docs/tutorials/2d/custom_drawing_in_2d.rst:461
#: ../../docs/development/compiling/introduction_to_the_buildsystem.rst:133
msgid "Tools"
msgstr "工具"

#: ../../docs/tutorials/2d/custom_drawing_in_2d.rst:463
msgid ""
"Drawing your own nodes might also be desired while running them in the "
"editor to use as a preview or visualization of some feature or behavior."
msgstr ""
"在编辑器中运行它们时，可能还需要绘制自己的节点，以用作某些功能或行为的预览或"
"可视化。"

#: ../../docs/tutorials/2d/custom_drawing_in_2d.rst:467
msgid ""
"Remember to use the \"tool\" keyword at the top of the script (check the :"
"ref:`doc_gdscript` reference if you forgot what this does)."
msgstr ""
"请记住在脚本顶部使用“tool”关键字(如果您忘记了这一点，请查看 :ref:"
"`doc_gdscript`参考)。"

#: ../../docs/tutorials/3d/introduction_to_3d.rst:4
msgid "Introduction to 3D"
msgstr "3D简介"

#: ../../docs/tutorials/3d/introduction_to_3d.rst:6
msgid ""
"Creating a 3D game can be challenging. That extra Z coordinate makes many of "
"the common techniques that helped to make 2D games simple no longer work. To "
"aid in this transition, it is worth mentioning that Godot uses similar APIs "
"for 2D and 3D. Most nodes are the same and are present in both 2D and 3D "
"versions. In fact, it is worth checking the 3D platformer tutorial, or the "
"3D kinematic character tutorials, which are almost identical to their 2D "
"counterparts."
msgstr ""
"创造一个3D游戏很有挑战性。 多余的Z坐标使许多有助于使2D游戏变得简单的常用技术"
"不再起作用。 为了帮助实现这一转变，值得一提的是，Godot在2D和3D上使用了类似的"
"API。 大多数节点是相同的，并且以2D和3D版本存在。 事实上，看看3D平台游戏教程或"
"3D运动学角色教程是值得的，这些教程大部分与2D游戏相同。"

#: ../../docs/tutorials/3d/introduction_to_3d.rst:14
msgid ""
"In 3D, math is a little more complex than in 2D, so also checking the :ref:"
"`doc_vector_math` entry in the wiki (which was especially created for game "
"developers, not mathematicians or engineers) will help pave the way for you "
"to develop 3D games efficiently."
msgstr ""
"在3D中，数学比2D更复杂一些，所以看看wiki :ref:`doc_vector_math` (特别是为游戏"
"开发者，而不是数学家或项目师创建的)将有助于为有效开发3D游戏铺平道路。"

#: ../../docs/tutorials/3d/introduction_to_3d.rst:20
msgid "Spatial node"
msgstr "空间节点"

#: ../../docs/tutorials/3d/introduction_to_3d.rst:22
msgid ""
":ref:`Node2D <class_Node2D>` is the base node for 2D. :ref:`Control "
"<class_Control>` is the base node for everything GUI. Following this "
"reasoning, the 3D engine uses the :ref:`Spatial <class_Spatial>` node for "
"everything 3D."
msgstr ""
":ref:`Node2D <class_Node2D>` 是2D的基本节点。 :ref:`Control <class_Control>` "
"是所有GUI的基本节点。 按照这个推理，3D引擎中的所有3D物体使用 :ref:`Spatial "
"<class_Spatial>` 节点。"

#: ../../docs/tutorials/3d/introduction_to_3d.rst:29
msgid ""
"Spatial nodes have a local transform, which is relative to the parent node "
"(as long as the parent node is also of **or inherits** from the type "
"Spatial). This transform can be accessed as a 4x3 :ref:`Transform "
"<class_Transform>`, or as 3 :ref:`Vector3 <class_Vector3>` members "
"representing location, Euler rotation (x,y and z angles) and scale."
msgstr ""
"空间节点有一个局部变换，它与父节点相关(只要父节点也是 **或者继承** Spatial类"
"型)。 这个变换可以作为4x3 :ref:`Transform <class_Transform>` 或3个 :ref:"
"`Vector3 <class_Vector3>` 成员来表示位置，欧拉旋转(x，y和z角度)和比例。"

#: ../../docs/tutorials/3d/introduction_to_3d.rst:39
msgid "3D content"
msgstr "3D内容"

#: ../../docs/tutorials/3d/introduction_to_3d.rst:41
msgid ""
"Unlike 2D, where loading image content and drawing is straightforward, 3D is "
"a little more difficult. The content needs to be created with special 3D "
"tools (usually referred to as DCCs) and exported to an exchange file format "
"in order to be imported in Godot (3D formats are not as standardized as "
"images)."
msgstr ""
"与2D不同，2D加载图像内容和绘图非常简单，但3D更难一些。 内容需要使用特殊的3D工"
"具(通常称为DCC)创造，并导出为交换文件格式以导入Godot(3D格式不像图像那样标准"
"化)。"

#: ../../docs/tutorials/3d/introduction_to_3d.rst:48
msgid "DCC-created models"
msgstr "DCC 创建的模型"

#: ../../docs/tutorials/3d/introduction_to_3d.rst:53
#, fuzzy
msgid ""
"There are two pipelines to import 3D models in Godot. The first and most "
"common one is by :ref:`doc_importing_3d_scenes`, which allows you to import "
"entire scenes (just as they look in the DCC), including animation, skeletal "
"rigs, blend shapes, etc."
msgstr ""
"有两条管线可以导入3D模型到Godot中。 第一个也是最常见的一个，是通过 :ref:"
"`doc_importing_3d_scenes` 导入器，它允许导入整个场景(就像它们在DCC中看起来一"
"样)，包括动画，骨架绑定，混合形状等。"

#: ../../docs/tutorials/3d/introduction_to_3d.rst:58
#, fuzzy
msgid ""
"The second pipeline is by importing simple .OBJ files as mesh resources, "
"which can be then put inside a :ref:`MeshInstance <class_MeshInstance>` node "
"for display."
msgstr ""
"第二条管线是:通过 :ref:`doc_importing_3d_meshes` 导入器。 第二种方法允许导入"
"简单的.OBJ文件作为网格资源，然后将其放入 :ref:`MeshInstance "
"<class_MeshInstance>` 节点中显示。"

#: ../../docs/tutorials/3d/introduction_to_3d.rst:63
msgid "Generated geometry"
msgstr "生成的几何体"

#: ../../docs/tutorials/3d/introduction_to_3d.rst:65
#, fuzzy
msgid ""
"It is possible to create custom geometry by using the :ref:`ArrayMesh "
"<class_ArrayMesh>` resource directly. Simply create your arrays and use the :"
"ref:`ArrayMesh.add_surface_from_arrays() "
"<class_ArrayMesh_method_add_surface_from_arrays>` function. A helper class "
"is also available, :ref:`SurfaceTool <class_SurfaceTool>`, which provides a "
"more straightforward API and helpers for indexing, generating normals, "
"tangents, etc."
msgstr ""
"通过直接使用 :ref:`Mesh <class_Mesh>` 资源可以创建自定义几何，只需创建数组并"
"使用 :ref:`Mesh.add_surface() <class_Mesh_method_add_surface>` 函数即可。 辅"
"助类也可用 :ref:`SurfaceTool <class_SurfaceTool>` ，它提供了一个更直接的API和"
"帮助器，用于索引，生成法线，切线等。"

#: ../../docs/tutorials/3d/introduction_to_3d.rst:72
msgid ""
"In any case, this method is meant for generating static geometry (models "
"that will not be updated often), as creating vertex arrays and submitting "
"them to the 3D API has a significant performance cost."
msgstr ""
"在任何情况下，这种方法都是为了用于生成静态几何体(不会经常更新的模型)，因为创"
"建顶点数组并将它们提交给3D API具有显著的性能开销。"

#: ../../docs/tutorials/3d/introduction_to_3d.rst:77
msgid "Immediate geometry"
msgstr "立即几何体"

#: ../../docs/tutorials/3d/introduction_to_3d.rst:79
msgid ""
"If, instead, there is a requirement to generate simple geometry that will be "
"updated often, Godot provides a special node, :ref:`ImmediateGeometry "
"<class_ImmediateGeometry>`, which provides an OpenGL 1.x style immediate-"
"mode API to create points, lines, triangles, etc."
msgstr ""
"相反，如果需要生成会经常更新的简单几何体，Godot会提供一个特殊节点 :ref:"
"`ImmediateGeometry <class_ImmediateGeometry>` ，它会提供OpenGL 1.x风格的即时"
"模式API来创建点，线 ，三角形等。"

#: ../../docs/tutorials/3d/introduction_to_3d.rst:86
msgid "2D in 3D"
msgstr "3D环境下的2D"

#: ../../docs/tutorials/3d/introduction_to_3d.rst:88
msgid ""
"While Godot packs a powerful 2D engine, many types of games use 2D in a 3D "
"environment. By using a fixed camera (either orthogonal or perspective) that "
"does not rotate, nodes such as :ref:`Sprite3D <class_Sprite3D>` and :ref:"
"`AnimatedSprite3D <class_AnimatedSprite3D>` can be used to create 2D games "
"that take advantage of mixing with 3D backgrounds, more realistic parallax, "
"lighting/shadow effects, etc."
msgstr ""
"虽然Godot包装了强大的2D引擎，但许多类型的游戏会使用在3D环境中的2D效果。 通过"
"使用不旋转的固定相机(正交或透视)，可以使用诸如 :ref:`Sprite3D "
"<class_Sprite3D>` 和 :ref:`AnimatedSprite3D <class_AnimatedSprite3D>` 等节点"
"来创建混合了具有3D背景，更逼真的视差，灯光/阴影效果等的2D游戏。"

#: ../../docs/tutorials/3d/introduction_to_3d.rst:96
msgid ""
"The disadvantage is, of course, that added complexity and reduced "
"performance in comparison to plain 2D, as well as the lack of reference of "
"working in pixels."
msgstr ""
"当然，缺点在于与普通2D相比增加了复杂性并降低了与普通2D 相比的性能，以及缺乏使"
"用像素作业的参考。"

#: ../../docs/tutorials/3d/introduction_to_3d.rst:101
#: ../../docs/tutorials/3d/environment_and_post_processing.rst:10
msgid "Environment"
msgstr "环境"

#: ../../docs/tutorials/3d/introduction_to_3d.rst:103
msgid ""
"Besides editing a scene, it is often common to edit the environment. Godot "
"provides a :ref:`WorldEnvironment <class_WorldEnvironment>` node that allows "
"changing the background color, mode (as in, put a skybox), and applying "
"several types of built-in post-processing effects. Environments can also be "
"overridden in the Camera."
msgstr ""
"除了编辑场景之外，编辑环境通常也很常见。 Godot提供了一个 :ref:"
"`WorldEnvironment <class_WorldEnvironment>` 节点，该节点允许更改背景颜色，模"
"式(例如放置天空盒)以及应用多种内置后处理效果。 相机中也可以覆盖环境。"

#: ../../docs/tutorials/3d/introduction_to_3d.rst:110
msgid "3D viewport"
msgstr "3D 视区"

#: ../../docs/tutorials/3d/introduction_to_3d.rst:112
msgid ""
"Editing 3D scenes is done in the 3D tab. This tab can be selected manually, "
"but it will be automatically enabled when a Spatial node is selected."
msgstr ""
"编辑3D场景可以在3D选项卡中完成。 该选项卡可以手动选择，但在选择Spatial节点时"
"将自动启用。"

#: ../../docs/tutorials/3d/introduction_to_3d.rst:118
msgid ""
"Default 3D scene navigation controls are similar to Blender (aiming to have "
"some sort of consistency in the free software pipeline..), but options are "
"included to customize mouse buttons and behavior to be similar to other "
"tools in the Editor Settings:"
msgstr ""
"默认的3D场景导航控件类似于Blender(旨在在自由软件管线中具有某种一致性)，但含有"
"用于自定义鼠标按钮和行为的选项，它也与编辑器设置中的其他工具类似:"

#: ../../docs/tutorials/3d/introduction_to_3d.rst:126
msgid "Coordinate system"
msgstr "坐标系统"

#: ../../docs/tutorials/3d/introduction_to_3d.rst:128
msgid ""
"Godot uses the `metric <https://en.wikipedia.org/wiki/Metric_system>`__ "
"system for everything. 3D Physics and other areas are tuned for this, so "
"attempting to use a different scale is usually a bad idea (unless you know "
"what you are doing)."
msgstr ""
"Godot使用`metric <http://en.wikipedia.org/wiki/Metric_system>`__系统来处理所"
"有事情。 3D物理和其他领域都在为此而调整，所以试图使用不同的缩放比例通常是一个"
"坏主意(除非您知道您在做什么)。"

#: ../../docs/tutorials/3d/introduction_to_3d.rst:133
msgid ""
"When working with 3D assets, it's always best to work in the correct scale "
"(set your DCC to metric). Godot allows scaling post-import and, while this "
"works in most cases, in rare situations it may introduce floating point "
"precision issues (and thus, glitches or artifacts) in delicate areas, such "
"as rendering or physics, so make sure your artists always work in the right "
"scale!"
msgstr ""
"在使用3D资源时，最好以正确的比例工作(将您的DCC设置为度量标准)。 Godot允许缩放"
"后导入，尽管这在大多数情况下都适用，但在极少数情况下，它可能会在诸如渲染或物"
"理等敏感区域引入浮点精度问题(并因此引入毛刺或失真)。 所以，确保您的艺术家总是"
"在正确的缩放比例下工作！"

#: ../../docs/tutorials/3d/introduction_to_3d.rst:140
msgid ""
"The Y coordinate is used for \"up\", though for most objects that need "
"alignment (like lights, cameras, capsule collider, vehicle, etc.), the Z "
"axis is used as a \"pointing towards\" direction. This convention roughly "
"means that:"
msgstr ""
"Y坐标用于“向上”，但对于大多数需要对齐的物体(如灯光，摄像机，胶囊碰撞体，载具"
"等)，Z轴用作“指向”方向。 这个约定大致意味着:"

#: ../../docs/tutorials/3d/introduction_to_3d.rst:145
msgid "**X** is sides"
msgstr "** X **是两边"

#: ../../docs/tutorials/3d/introduction_to_3d.rst:146
msgid "**Y** is up/down"
msgstr "** Y **是上/下"

#: ../../docs/tutorials/3d/introduction_to_3d.rst:147
msgid "**Z** is front/back"
msgstr "** Z **是前/后"

#: ../../docs/tutorials/3d/introduction_to_3d.rst:150
msgid "Space and manipulation gizmos"
msgstr "空间和可操纵的小控件"

#: ../../docs/tutorials/3d/introduction_to_3d.rst:152
msgid ""
"Moving objects in the 3D view is done through the manipulator gizmos. Each "
"axis is represented by a color: Red, Green, Blue represent X,Y,Z "
"respectively. This convention applies to the grid and other gizmos too (and "
"also to the shader language, ordering of components for Vector3,Color,etc.)."
msgstr ""
"在3D视图中移动对象是通过操纵器小控件完成的。 每个轴用颜色表示:红色，绿色，蓝"
"色分别代表X，Y，Z。 这个约定也适用于格子和其他小控件(也涉及着色器语言，"
"Vector3，Color等组件的排序)。"

#: ../../docs/tutorials/3d/introduction_to_3d.rst:160
msgid "Some useful keybindings:"
msgstr "一些有用的键盘绑定:"

#: ../../docs/tutorials/3d/introduction_to_3d.rst:162
msgid ""
"To snap placement or rotation, press the \"s\" key while moving, scaling or "
"rotating."
msgstr "要快速移动或旋转，请在移动，缩放或旋转时按下“s”键。"

#: ../../docs/tutorials/3d/introduction_to_3d.rst:164
msgid "To center the view on the selected object, press the \"f\" key."
msgstr "要将视图居中在所选对象上，请按“f”键。"

#: ../../docs/tutorials/3d/introduction_to_3d.rst:167
msgid "View menu"
msgstr "视图菜单"

#: ../../docs/tutorials/3d/introduction_to_3d.rst:169
msgid ""
"The view options are controlled by the \"View\" menu in the viewport's "
"toolbar."
msgstr "视图选项由视区工具栏中的“视图”菜单控制。"

#: ../../docs/tutorials/3d/introduction_to_3d.rst:173
msgid "You can hide the gizmos in the 3D view of the editor through this menu:"
msgstr "您可以通过以下菜单在编辑器的3D视图中隐藏小玩意:"

#: ../../docs/tutorials/3d/introduction_to_3d.rst:177
msgid ""
"To hide a specific type of gizmos, you can toggle them off in the \"View\" "
"menu."
msgstr "要隐藏特定类型的小玩意，您可以在“视图”菜单中将其关闭。"

#: ../../docs/tutorials/3d/introduction_to_3d.rst:182
#: ../../docs/tutorials/3d/environment_and_post_processing.rst:40
msgid "Default environment"
msgstr "默认环境"

#: ../../docs/tutorials/3d/introduction_to_3d.rst:184
msgid ""
"When created from the Project Manager, the 3D environment has a default sky."
msgstr "从项目管理器中创建时，3D环境具有默认的天空。"

#: ../../docs/tutorials/3d/introduction_to_3d.rst:188
msgid ""
"Given how physically based rendering works, it is advised to always try to "
"work with a default environment in order to provide indirect and reflected "
"light to your objects."
msgstr ""
"鉴于基于物理的渲染工作流程，建议始终使用默认环境，以便为对象提供间接和反射"
"光。"

#: ../../docs/tutorials/3d/introduction_to_3d.rst:193
msgid "Cameras"
msgstr "相机"

#: ../../docs/tutorials/3d/introduction_to_3d.rst:195
msgid ""
"No matter how many objects are placed in the 3D space, nothing will be "
"displayed unless a :ref:`Camera <class_Camera>` is also added to the scene. "
"Cameras can work in either orthogonal or perspective projections:"
msgstr ""
"无论在3D空间中放置多少物体，除非在场景中添加了 :ref:`相机 <class_Camera>` ，"
"否则不会显示任何内容。 相机可以在正交或透视投影中工作:"

#: ../../docs/tutorials/3d/introduction_to_3d.rst:202
msgid ""
"Cameras are associated with (and only display to) a parent or grandparent "
"viewport. Since the root of the scene tree is a viewport, cameras will "
"display on it by default, but if sub-viewports (either as render target or "
"picture-in-picture) are desired, they need their own children cameras to "
"display."
msgstr ""
"摄像机与父视图或祖父母视区相关联，仅显示。 由于场景树的根是一个视区，默认情况"
"下会在其上显示摄像机，但如果需要子视区(渲染目标或画中画)，则需要自己的子摄像"
"头才能显示。"

#: ../../docs/tutorials/3d/introduction_to_3d.rst:210
msgid ""
"When dealing with multiple cameras, the following rules are enforced for "
"each viewport:"
msgstr "处理多台摄像机时，每个视区都遵循以下规则:"

#: ../../docs/tutorials/3d/introduction_to_3d.rst:213
msgid ""
"If no cameras are present in the scene tree, the first one that enters it "
"will become the active camera. Further cameras entering the scene will be "
"ignored (unless they are set as *current*)."
msgstr ""
"如果场景树中没有摄像机，则第一个摄像机将成为活动摄像机。 进入场景的其他摄像机"
"将被忽略(除非它们被设置为 *当前* )。"

#: ../../docs/tutorials/3d/introduction_to_3d.rst:216
msgid ""
"If a camera has the \"*current*\" property set, it will be used regardless "
"of any other camera in the scene. If the property is set, it will become "
"active, replacing the previous camera."
msgstr ""
"如果相机具有“ *当前* ”属性设置，则无论场景中是否有其他相机，都会使用它。 如果"
"该属性已设置，它将变为活动状态，取代之前的摄像头。"

#: ../../docs/tutorials/3d/introduction_to_3d.rst:219
msgid ""
"If an active camera leaves the scene tree, the first camera in tree-order "
"will take its place."
msgstr "如果活动摄像机离开场景树，则按树形顺序排列的第一台摄像机将取代它。"

#: ../../docs/tutorials/3d/introduction_to_3d.rst:225
msgid ""
"There is no limitation on the number of lights, nor of types of lights, in "
"Godot. As many as desired can be added (as long as performance allows)."
msgstr "Godot的灯光数量和灯光类型没有限制。 想加多少都可以(只要性能允许)。"

#: ../../docs/tutorials/3d/using_transforms.rst:4
msgid "Using 3D transforms"
msgstr "使用3D变换"

#: ../../docs/tutorials/3d/using_transforms.rst:9
msgid ""
"If you have never made 3D games before, working with rotations in three "
"dimensions can be confusing at first. Coming from 2D, the natural way of "
"thinking is along the lines of *\"Oh, it's just like rotating in 2D, except "
"now rotations happen in X, Y and Z\"*."
msgstr ""
"如果您以前从未制作过3D游戏，那么首先在三维环境中进行旋转可能会让人感到困惑。 "
"从2D开始，自然的思维方式就是沿着“噢，它就像2D旋转一样，而现在旋转发生在X，Y和"
"Z轴上”*。"

#: ../../docs/tutorials/3d/using_transforms.rst:12
msgid ""
"At first this seems easy and for simple games, this way of thinking may even "
"be enough. Unfortunately, it's often incorrect."
msgstr ""
"起初这似乎很简单，对于简单的游戏，这种思维方式甚至可能足够了。 不幸的是，这往"
"往是不正确的。"

#: ../../docs/tutorials/3d/using_transforms.rst:14
msgid ""
"Angles in three dimensions are most commonly referred to as \"Euler Angles\"."
msgstr "三维角度通常被称为“欧拉角”。"

#: ../../docs/tutorials/3d/using_transforms.rst:18
msgid ""
"Euler angles were introduced by mathematician Leonhard Euler in the early "
"1700s."
msgstr "欧拉角是由数学家莱昂哈德·欧拉在1700年代初引入的。"

#: ../../docs/tutorials/3d/using_transforms.rst:22
msgid ""
"This way of representing 3D rotations was groundbreaking at the time, but it "
"has several shortcomings when used in game development (which is to be "
"expected from a guy with a funny hat). The idea of this document is to "
"explain why, as well as outlining best practices for dealing with transforms "
"when programming 3D games."
msgstr ""
"这种代表三维旋转的方式在当时是开创性的，但在游戏开发中使用时有一些缺点(这可以"
"从一个戴着滑稽帽子的家伙那里得到)。 本文的主旨是解释其原因，并概述在编写3D游"
"戏时处理变换的最佳做法。"

#: ../../docs/tutorials/3d/using_transforms.rst:28
msgid "Problems of Euler angles"
msgstr "欧拉角问题"

#: ../../docs/tutorials/3d/using_transforms.rst:30
msgid ""
"While it may seem intuitive that each axis has a rotation, the truth is that "
"it's just not practical."
msgstr "虽然看起来很直观，每个轴都有一个旋转，但事实是它并不实用。"

#: ../../docs/tutorials/3d/using_transforms.rst:33
msgid "Axis order"
msgstr "轴顺序"

#: ../../docs/tutorials/3d/using_transforms.rst:35
msgid ""
"The main reason for this is that there isn't a *unique* way to construct an "
"orientation from the angles. There isn't a standard mathematical function "
"that takes all the angles together and produces an actual 3D rotation. The "
"only way an orientation can be produced from angles is to rotate the object "
"angle by angle, in an *arbitrary order*."
msgstr ""
"这样做的主要原因是没有一种独特的方法可以从角度构建方向。 没有一个标准的数学函"
"数可以将所有角度放在一起并产生实际的3D旋转。 从角度产生方向的唯一方法是以 *任"
"意顺序* 按角度旋转物体角度。"

#: ../../docs/tutorials/3d/using_transforms.rst:39
msgid ""
"This could be done by first rotating in *X*, then *Y* and then in *Z*. "
"Alternatively, you could first rotate in *Y*, then in *Z* and finally in "
"*X*. Anything works, but depending on the order, the final orientation of "
"the object will *not necessarily be the same*. Indeed, this means that there "
"are several ways to construct an orientation from 3 different angles, "
"depending on *the order of the rotations*."
msgstr ""
"这可以通过先旋转* X *，然后* Y *然后旋转* Z *来完成。 或者，您可以先以* Y *旋"
"转，然后以* Z *旋转，最后以* X *旋转。 怎样都行，但根据顺序，对象的最终方向 *"
"不一定是相同的* 。 事实上，这意味着有多种方法可以从3个不同的角度构建方向，具"
"体取决于 *旋转的顺序* 。"

#: ../../docs/tutorials/3d/using_transforms.rst:43
msgid ""
"Following is a visualization of rotation axes (in X,Y,Z order) in a gimbal "
"(from Wikipedia). As you can see, the orientation of each axis depends on "
"the rotation of the previous one:"
msgstr ""
"以下(来自维基百科)是万向节旋转轴(X，Y，Z顺序)的可视化。 如您所见，每个轴的方"
"向取决于前一个轴的旋转方向:"

#: ../../docs/tutorials/3d/using_transforms.rst:47
msgid ""
"You may be wondering how this affects you. Let's look at a practical example:"
msgstr "您可能想知道这是如何影响您的。 我们来看一个实际的示例:"

#: ../../docs/tutorials/3d/using_transforms.rst:49
msgid ""
"Imagine you are working on a first-person controller (e.g. an FPS game). "
"Moving the mouse left and right controls your view angle parallel to the "
"ground, while moving it up and down moves the player's view up and down."
msgstr ""
"想象一下，您正在研究第一人称控制器(FPS游戏)。 向左和向右移动鼠标可以控制与地"
"面平行的视角，同时上下移动可以调整游戏角色上下的视野。"

#: ../../docs/tutorials/3d/using_transforms.rst:51
msgid ""
"In this case to achieve the desired effect, rotation must be applied first "
"in the *Y* axis (\"up\" in this case, since Godot uses a \"Y-Up\" "
"orientation), followed by rotation in the *X* axis."
msgstr ""
"在这种情况下，为了达到所需的效果，必须首先在* Y *轴上应用旋转(在这种情况下"
"为“上”，因为Godot使用“Y-Up”方向)，然后在* X *轴上旋转。"

#: ../../docs/tutorials/3d/using_transforms.rst:55
msgid ""
"If we were to apply rotation in the *X* axis first, and then in *Y*, the "
"effect would be undesired:"
msgstr ""
"如果我们首先在* X *轴上应用旋转，然后再在* Y *中应用旋转，则效果会不理想:"

#: ../../docs/tutorials/3d/using_transforms.rst:59
msgid ""
"Depending on the type of game or effect desired, the order in which you want "
"axis rotations to be applied may differ. Therefore, applying rotations in X, "
"Y, and Z is not enough: you also need a *rotation order*."
msgstr ""
"根据所需的游戏类型或效果，您想要应用轴旋转的顺序可能会有所不同。 因此，在X，Y"
"和Z中应用旋转是不够的:您还需要 *旋转顺序* 。"

#: ../../docs/tutorials/3d/using_transforms.rst:62
msgid "Interpolation"
msgstr "插值"

#: ../../docs/tutorials/3d/using_transforms.rst:64
msgid ""
"Another problem with using Euler angles is interpolation. Imagine you want "
"to transition between two different camera or enemy positions (including "
"rotations). One logical way to approach this is to interpolate the angles "
"from one position to the next. One would expect it to look like this:"
msgstr ""
"使用欧拉角的另一个问题是插值。 设想您想在两个不同的相机或敌人位置(包括旋转)之"
"间转换。 解决这个问题的一个合乎逻辑的方法是从一个位置插入到下一个位置。 人们"
"会期望它看起来像这样:"

#: ../../docs/tutorials/3d/using_transforms.rst:68
msgid "But this does not always have the expected effect when using angles:"
msgstr "但是，在使用角度时，这并不总是有预期的效果:"

#: ../../docs/tutorials/3d/using_transforms.rst:72
msgid "The camera actually rotated the opposite direction!"
msgstr "相机实际上旋转了相反的方向！"

#: ../../docs/tutorials/3d/using_transforms.rst:74
msgid "There are a few reasons this may happen:"
msgstr "这可能有几个原因:"

#: ../../docs/tutorials/3d/using_transforms.rst:76
msgid ""
"Rotations don't map linearly to orientation, so interpolating them does not "
"always result in the shortest path (i.e., to go from ``270`` to ``0`` "
"degrees is not the same as going from ``270`` to ``360``, even though the "
"angles are equivalent)."
msgstr ""
"旋转不会线性映射到方向，因此插入它们并不总是会形成最短路径(即从“270”到“0”的度"
"数与从“270”开始到“360”的度数不同，即使角度是相同的)。"

#: ../../docs/tutorials/3d/using_transforms.rst:77
msgid ""
"Gimbal lock is at play (first and last rotated axis align, so a degree of "
"freedom is lost). See `Wikipedia's page on Gimbal Lock <https://en.wikipedia."
"org/wiki/Gimbal_lock>`_ for a detailed explanation of this problem."
msgstr ""
"万向节锁正在发挥作用(第一个和最后一个旋转的轴对齐，因此失去了一定的自由度)。 "
"请参阅 `维基百科关于Gimbal Lock的页面 <https://en.wikipedia.org/wiki/"
"Gimbal_lock>`_ 以了解这个问题的详细解释。"

#: ../../docs/tutorials/3d/using_transforms.rst:80
msgid "Say no to Euler angles"
msgstr "对欧拉角说不"

#: ../../docs/tutorials/3d/using_transforms.rst:82
msgid ""
"The result of all this is that you should **not use** the ``rotation`` "
"property of :ref:`class_Spatial` nodes in Godot for games. It's there to be "
"used mainly in the editor, for coherence with the 2D engine, and for simple "
"rotations (generally just one axis, or even two in limited cases). As much "
"as you may be tempted, don't use it."
msgstr ""
"所有这些的结论是，您不应该在游戏中使用Godot的 ``rotation`` 属性 :ref:"
"`class_Spatial` 节点。 它主要用在编辑器中，为了与2D引擎一致，并且用于简单的旋"
"转(通常只有一个轴，或者在有限的情况下使用两个)。 您可能会受到诱惑, 但不要使用"
"它。"

#: ../../docs/tutorials/3d/using_transforms.rst:84
msgid "Instead, there is a better way to solve your rotation problems."
msgstr "相反，有一个更好的方法来解决您的旋转问题。"

#: ../../docs/tutorials/3d/using_transforms.rst:87
msgid "Introducing transforms"
msgstr "变换的介绍"

#: ../../docs/tutorials/3d/using_transforms.rst:89
msgid ""
"Godot uses the :ref:`class_Transform` datatype for orientations. Each :ref:"
"`class_Spatial` node contains a ``transform`` property which is relative to "
"the parent's transform, if the parent is a Spatial-derived type."
msgstr ""
"Godot对方向使用 :ref:`class_Transform` 数据类型。 每一个 :ref:"
"`class_Spatial` 节点都包含一个 ``transform`` 属性，如果该父类是一个空间派生类"
"型，则该属性相对依赖于父类变换。"

#: ../../docs/tutorials/3d/using_transforms.rst:91
msgid ""
"It is also possible to access the world coordinate transform via the "
"``global_transform`` property."
msgstr "也可以通过 ``global_transform`` 属性访问世界坐标变换。"

#: ../../docs/tutorials/3d/using_transforms.rst:93
msgid ""
"A transform has a :ref:`class_Basis` (transform.basis sub-property), which "
"consists of three :ref:`class_Vector3` vectors. These are accessed via the "
"``transform.basis`` property and can be accessed directly by ``transform."
"basis.x``, ``transform.basis.y``, and ``transform.basis.z``. Each vector "
"points in the direction its axis has been rotated, so they effectively "
"describe the node's total rotation. The scale (as long as it's uniform) can "
"also be inferred from the length of the axes. A *basis* can also be "
"interpreted as a 3x3 matrix and used as ``transform.basis[x][y]``."
msgstr ""
"一个变换有一个 :ref:`class_Basis` (transform.basis子属性)，它由三个 :ref:"
"`class_Vector3` 向量组成。 这些向量可以通过 ``transform.basis`` 属性访问，并"
"可以通过 ``transform.basis.x`` ， ``transform.basis.y`` 和 ``transform.basis."
"z`` 直接访问。 每个向量指向它的轴被旋转的方向，因此它们可以有效地描述节点的总"
"旋转。 比例(只要它是一致的)也可以从轴的长度推断出来。 一个 *basis* 也可以被解"
"释为一个3x3矩阵并被用作 ``transform.basis [x] [y]``。"

#: ../../docs/tutorials/3d/using_transforms.rst:95
msgid "A default basis (unmodified) is akin to:"
msgstr "默认的basis(未修改)类似于:"

#: ../../docs/tutorials/3d/using_transforms.rst:123
msgid "This is also an analog of a 3x3 identity matrix."
msgstr "这也是一个3x3单位矩阵的类似物。"

#: ../../docs/tutorials/3d/using_transforms.rst:125
msgid ""
"Following the OpenGL convention, ``X`` is the *Right* axis, ``Y`` is the "
"*Up* axis and ``Z`` is the *Forward* axis."
msgstr "遵循OpenGL惯例，“X”是* 右 *轴，“Y”是* 上 *轴，“Z”是* 前 *轴。"

#: ../../docs/tutorials/3d/using_transforms.rst:127
msgid ""
"Together with the *basis*, a transform also has an *origin*. This is a "
"*Vector3* specifying how far away from the actual origin ``(0, 0, 0)`` this "
"transform is. Combining the *basis* with the *origin*, a *transform* "
"efficiently represents a unique translation, rotation, and scale in space."
msgstr ""
"与 *基* 一起，变换也有 *原点* 。 这是一个* 3维向量 *，用于指定该变换距离实际"
"原点“(0，0，0)”多远。 *基*与*原点*相结合，一个 *变换*有效地表示了一个空间中特"
"定的平移，旋转和缩放。"

#: ../../docs/tutorials/3d/using_transforms.rst:132
msgid ""
"One way to visualize a transform is to look at an object's 3D gizmo while in "
"\"local space\" mode."
msgstr "一种查看一个变换的方法是在“本地空间”模式下查看该对象的3D Gizmo。"

#: ../../docs/tutorials/3d/using_transforms.rst:136
msgid ""
"The gizmo's arrows show the ``X``, ``Y``, and ``Z`` axes (in red, green, and "
"blue respectively) of the basis, while the gizmo's center is at the object's "
"origin."
msgstr ""
"Gizmo的箭头显示基准的“X”，“Y”和“Z”轴(分别为红色，绿色和蓝色)，而Gizmo的中心位"
"于对象的原点。"

#: ../../docs/tutorials/3d/using_transforms.rst:140
msgid ""
"For more information on the mathematics of vectors and transforms, please "
"read the :ref:`doc_vector_math` tutorials."
msgstr ""
"有关向量和变换在数学方面的更多信息，请阅读 :ref:`doc_vector_math`教程。"

#: ../../docs/tutorials/3d/using_transforms.rst:143
msgid "Manipulating transforms"
msgstr "操作变换"

#: ../../docs/tutorials/3d/using_transforms.rst:145
msgid ""
"Of course, transforms are not as straightforward to manipulate as angles and "
"have problems of their own."
msgstr "当然，变换并不像角度那样有那么简单的操作，并且有它自己的问题。"

#: ../../docs/tutorials/3d/using_transforms.rst:147
msgid ""
"It is possible to rotate a transform, either by multiplying its basis by "
"another (this is called accumulation), or by using the rotation methods."
msgstr "可以通过将其的基乘以另一个(这称为堆积)或使用旋转方法来旋转变换。"

#: ../../docs/tutorials/3d/using_transforms.rst:164
msgid "A method in Spatial simplifies this:"
msgstr "Spatial中的一种方法简化了这一点:"

#: ../../docs/tutorials/3d/using_transforms.rst:181
msgid "This rotates the node relative to the parent node."
msgstr "这会相对于父节点来旋转节点。"

#: ../../docs/tutorials/3d/using_transforms.rst:183
msgid ""
"To rotate relative to object space (the node's own transform), use the "
"following:"
msgstr "要相对于对象空间旋转(节点自己的变换)，请使用以下内容:"

#: ../../docs/tutorials/3d/using_transforms.rst:197
msgid "Precision errors"
msgstr "精度误差"

#: ../../docs/tutorials/3d/using_transforms.rst:199
msgid ""
"Doing successive operations on transforms will result in a loss of precision "
"due to floating-point error. This means the scale of each axis may no longer "
"be exactly ``1.0``, and they may not be exactly ``90`` degrees from each "
"other."
msgstr ""
"对变换执行连续的操作将导致由于浮点错误导致的精度损失。 这意味着每个轴的比例可"
"能不再精确地为“1.0”，并且它们可能不完全相互为“90”度。"

#: ../../docs/tutorials/3d/using_transforms.rst:201
msgid ""
"If a transform is rotated every frame, it will eventually start deforming "
"over time. This is unavoidable."
msgstr ""
"如果一个变换每帧旋转一次，它最终会随着时间的推移开始变形。 这是不可避免的。"

#: ../../docs/tutorials/3d/using_transforms.rst:203
msgid ""
"There are two different ways to handle this. The first is to "
"*orthonormalize* the transform after some time (maybe once per frame if you "
"modify it every frame):"
msgstr ""
"有两种不同的方法来处理这个问题。 首先是在一段时间后对变换进行正交归一化处理"
"(如果每帧修改一次，则可能每帧一次):"

#: ../../docs/tutorials/3d/using_transforms.rst:214
msgid ""
"This will make all axes have ``1.0`` length again and be ``90`` degrees from "
"each other. However, any scale applied to the transform will be lost."
msgstr ""
"这将使所有的轴再次拥有有“1.0”的长度并且彼此成90度角。 但是，应用于变换的任何"
"缩放都将丢失。"

#: ../../docs/tutorials/3d/using_transforms.rst:216
msgid ""
"It is recommended you not scale nodes that are going to be manipulated; "
"scale their children nodes instead (such as MeshInstance). If you absolutely "
"must scale the node, then re-apply it at the end:"
msgstr ""
"建议您不要缩放要操纵的节点，而是缩放其子节点(如MeshInstance)。 如果您必须缩放"
"节点，则在最后重新应用它:"

#: ../../docs/tutorials/3d/using_transforms.rst:230
msgid "Obtaining information"
msgstr "获取信息"

#: ../../docs/tutorials/3d/using_transforms.rst:232
msgid ""
"You might be thinking at this point: **\"Ok, but how do I get angles from a "
"transform?\"**. The answer again is: you don't. You must do your best to "
"stop thinking in angles."
msgstr ""
"您可能在这一点上想:** “好吧，但是我怎么从变换中获得角度？”**。 答案又一次是:"
"您没有必要。 您必须尽最大努力停止在角度方向的思考。"

#: ../../docs/tutorials/3d/using_transforms.rst:234
msgid ""
"Imagine you need to shoot a bullet in the direction your player is facing. "
"Just use the forward axis (commonly ``Z`` or ``-Z``)."
msgstr ""
"想象一下，您需要朝您的游戏角色面对的方向射击子弹。 只需使用前进轴(通常为 "
"``Z`` 或 ``-Z`` )。"

#: ../../docs/tutorials/3d/using_transforms.rst:247
msgid ""
"Is the enemy looking at the player? Use the dot product for this (see the :"
"ref:`doc_vector_math` tutorial for an explanation of the dot product):"
msgstr ""
"敌人在看着游戏角色吗？ 为此判断您可以使用点积(请参阅 :ref:`doc_vector_math` "
"教程以获取对点积的解释):"

#: ../../docs/tutorials/3d/using_transforms.rst:266
msgid "Strafe left:"
msgstr "向左平移:"

#: ../../docs/tutorials/3d/using_transforms.rst:283
msgid "Jump:"
msgstr "跳跃:"

#: ../../docs/tutorials/3d/using_transforms.rst:302
msgid "All common behaviors and logic can be done with just vectors."
msgstr "所有常见的行为和逻辑都可以用向量来完成。"

#: ../../docs/tutorials/3d/using_transforms.rst:305
msgid "Setting information"
msgstr "设置信息"

#: ../../docs/tutorials/3d/using_transforms.rst:307
msgid ""
"There are, of course, cases where you want to set information to a "
"transform. Imagine a first person controller or orbiting camera. Those are "
"definitely done using angles, because you *do want* the transforms to happen "
"in a specific order."
msgstr ""
"当然，有些情况下您想要将一些信息赋予到变换上。 想象一下第一人称控制器或轨道摄"
"像机。 那些肯定是用角度来完成的，因为您希望变换以特定的顺序进行。"

#: ../../docs/tutorials/3d/using_transforms.rst:309
msgid ""
"For such cases, keep the angles and rotations *outside* the transform and "
"set them every frame. Don't try to retrieve and re-use them because the "
"transform is not meant to be used this way."
msgstr ""
"对于这种情况，请保持变换 *外* 的角度和旋转，并将其设置为每帧。 不要尝试恢复并"
"重新使用它们，因为变换没有以这种方式使用的意思。"

#: ../../docs/tutorials/3d/using_transforms.rst:311
msgid "Example of looking around, FPS style:"
msgstr "环顾四周，FPS风格的示例:"

#: ../../docs/tutorials/3d/using_transforms.rst:353
msgid ""
"As you can see, in such cases it's even simpler to keep the rotation "
"outside, then use the transform as the *final* orientation."
msgstr ""
"如您所见，在这种情况下，保持外部旋转更为简单，然后使用变换作为* 最后的 *方"
"向。"

#: ../../docs/tutorials/3d/using_transforms.rst:356
msgid "Interpolating with quaternions"
msgstr "四元数插值"

#: ../../docs/tutorials/3d/using_transforms.rst:358
msgid ""
"Interpolating between two transforms can efficiently be done with "
"quaternions. More information about how quaternions work can be found in "
"other places around the Internet. For practical use, it's enough to "
"understand that pretty much their main use is doing a closest path "
"interpolation. As in, if you have two rotations, a quaternion will smoothly "
"allow interpolation between them using the closest axis."
msgstr ""
"用四元数能有效地完成两个变换之间的插值。 有关四元数如何工作的更多信息可以在互"
"联网上的其他地方找到。 在实际应用中，了解它们的主要用途是做最近的路径插值就足"
"够了。 同样，如果您有两次旋转，四元数将平滑地使用最近的轴在它们之间进行插值。"

#: ../../docs/tutorials/3d/using_transforms.rst:360
msgid "Converting a rotation to quaternion is straightforward."
msgstr "将旋转转换为四元数很简单。"

#: ../../docs/tutorials/3d/using_transforms.rst:383
msgid ""
"The :ref:`class_Quat` type reference has more information on the datatype "
"(it can also do transform accumulation, transform points, etc., though this "
"is used less often). If you interpolate or apply operations to quaternions "
"many times, keep in mind they need to be eventually normalized or they also "
"may suffer from numerical precision errors."
msgstr ""
":ref:`class_Quat` 类型的引用有更多关于数据类型的信息(它也可以做变换累加，变换"
"点等等，虽然这个用法较少)。 如果多次对四元数进行插值或应用运算，请记住它们需"
"要最终归一化，否则它们可能会产生数值精度错误。"

#: ../../docs/tutorials/3d/using_transforms.rst:385
msgid ""
"Quaternions are useful when doing camera/path/etc. interpolations, as the "
"result will always be correct and smooth."
msgstr "四元数在做相机/路径/等东西时很有用。 插值的结果总会是正确且平滑的。"

#: ../../docs/tutorials/3d/using_transforms.rst:388
msgid "Transforms are your friend"
msgstr "变换是您的朋友"

#: ../../docs/tutorials/3d/using_transforms.rst:390
msgid ""
"For most beginners, getting used to working with transforms can take some "
"time. However, once you get used to them, you will appreciate their "
"simplicity and power."
msgstr ""
"对于大多数初学者来说，习惯于使用变换可能需要一些时间。 但是，一旦您习惯了它"
"们，您会欣赏他们的简单而有力。"

#: ../../docs/tutorials/3d/using_transforms.rst:392
msgid ""
"Don't hesitate to ask for help on this topic in any of Godot's `online "
"communities <https://godotengine.org/community>`_ and, once you become "
"confident enough, please help others!"
msgstr ""
"不要犹豫，在Godot的任何“在线社区”网站上寻求帮助，一旦您变得足够自信，请帮助其"
"他人！"

#: ../../docs/tutorials/3d/3d_performance_and_limitations.rst:4
msgid "3D performance and limitations"
msgstr "3D性能和局限性"

#: ../../docs/tutorials/3d/3d_performance_and_limitations.rst:9
msgid ""
"Godot follows a balanced performance philosophy. In the performance world, "
"there are always trade-offs, which consist of trading speed for usability "
"and flexibility. Some practical examples of this are:"
msgstr ""
"Godot遵循平衡的表现理念。 在绩效世界中，总是需要权衡交易的可用性和灵活性。 一"
"些实际的示例是:"

#: ../../docs/tutorials/3d/3d_performance_and_limitations.rst:13
msgid ""
"Rendering objects efficiently in high amounts is easy, but when a large "
"scene must be rendered, it can become inefficient. To solve this, visibility "
"computation must be added to the rendering, which makes rendering less "
"efficient, but, at the same time, fewer objects are rendered, so efficiency "
"overall improves."
msgstr ""
"高效地渲染对象很容易，但是当必须渲染大型场景时，它会变得效率低下。 要解决这个"
"问题，必须将可见性计算添加到渲染中，这会使渲染效率降低，但同时渲染的对象也会"
"减少，因此整体效率会提高。"

#: ../../docs/tutorials/3d/3d_performance_and_limitations.rst:18
msgid ""
"Configuring the properties of every material for every object that needs to "
"be rendered is also slow. To solve this, objects are sorted by material to "
"reduce the costs, but at the same time sorting has a cost."
msgstr ""
"为每个需要渲染的对象配置每种材质的属性也很慢。 为了解决这个问题，对象按材质分"
"类以降低成本，但同时排序会产生成本。"

#: ../../docs/tutorials/3d/3d_performance_and_limitations.rst:22
msgid ""
"In 3D physics a similar situation happens. The best algorithms to handle "
"large amounts of physics objects (such as SAP) are slow at insertion/removal "
"of objects and ray-casting. Algorithms that allow faster insertion and "
"removal, as well as ray-casting, will not be able to handle as many active "
"objects."
msgstr ""
"在3D物理学中，会发生类似的情况。 处理大量物理对象(例如SAP)的最佳算法在插入/移"
"除对象和光线投射时很慢。 允许更快插入和移除以及光线投射的算法将无法处理尽可能"
"多的活动对象。"

#: ../../docs/tutorials/3d/3d_performance_and_limitations.rst:28
msgid ""
"And there are many more examples of this! Game engines strive to be general "
"purpose in nature, so balanced algorithms are always favored over algorithms "
"that might be fast in some situations and slow in others.. or algorithms "
"that are fast but make usability more difficult."
msgstr ""
"还有更多的示例！ 游戏引擎本质上是通用的，因此平衡算法总是比在某些情况下可能快"
"速且在其他情况下速度慢的算法更受青睐。或者算法速度快但使可用性更难。"

#: ../../docs/tutorials/3d/3d_performance_and_limitations.rst:33
msgid ""
"Godot is not an exception and, while it is designed to have backends "
"swappable for different algorithms, the default ones (or more like, the only "
"ones that are there for now) prioritize balance and flexibility over "
"performance."
msgstr ""
"Godot不是一个例外，虽然它被设计为可以为不同的算法交换后端，但默认的(或者更像"
"是现在唯一的那些)优先考虑平衡和灵活性而不是性能。"

#: ../../docs/tutorials/3d/3d_performance_and_limitations.rst:38
msgid ""
"With this clear, the aim of this tutorial is to explain how to get the "
"maximum performance out of Godot."
msgstr "有了这个清楚，本教程的目的是解释如何从Godot中获得最大的性能。"

#: ../../docs/tutorials/3d/3d_performance_and_limitations.rst:42
#: ../../docs/tutorials/viewports/viewports.rst:174
msgid "Rendering"
msgstr "渲染"

#: ../../docs/tutorials/3d/3d_performance_and_limitations.rst:44
msgid ""
"3D rendering is one of the most difficult areas to get performance from, so "
"this section will have a list of tips."
msgstr "3D渲染是获得性能最困难的领域之一，因此本节将提供一系列提示。"

#: ../../docs/tutorials/3d/3d_performance_and_limitations.rst:48
msgid "Reuse shaders and materials"
msgstr "重复使用着色器和材质"

#: ../../docs/tutorials/3d/3d_performance_and_limitations.rst:50
msgid ""
"The Godot renderer is a little different to what is out there. It's designed "
"to minimize GPU state changes as much as possible. :ref:"
"`class_SpatialMaterial` does a good job at reusing materials that need "
"similar shaders but, if custom shaders are used, make sure to reuse them as "
"much as possible. Godot's priorities will be like this:"
msgstr ""
"Godot渲染器与那里的渲染器略有不同。 它旨在尽可能减少GPU状态的变化。 :ref:"
"`class_SpatialMaterial` 在重用需要类似着色器的材质方面做得很好但是，如果使用"
"自定义着色器，请确保尽可能多地重用它们。 Godot的优先事项如下:"

#: ../../docs/tutorials/3d/3d_performance_and_limitations.rst:57
msgid ""
"**Reusing Materials**: The fewer different materials in the scene, the "
"faster the rendering will be. If a scene has a huge amount of objects (in "
"the hundreds or thousands) try reusing the materials or in the worst case "
"use atlases."
msgstr ""
"**重复使用材质**:场景中不同的材质越少，渲染速度就越快。 如果一个场景有大量的"
"物体(数百或数千)，请尝试重复使用这些材质，或者在最坏的情况下使用地图集。"

#: ../../docs/tutorials/3d/3d_performance_and_limitations.rst:61
msgid ""
"**Reusing Shaders**: If materials can't be reused, at least try to re-use "
"shaders (or SpatialMaterials with different parameters but the same "
"configuration)."
msgstr ""
"**重用着色器**: 如果材质无法重复使用，至少尝试重新使用着色器(或具有不同参数但"
"配置相同的SpatialMaterials)。"

#: ../../docs/tutorials/3d/3d_performance_and_limitations.rst:65
msgid ""
"If a scene has, for example, 20.000 objects with 20.000 different materials "
"each, rendering will be slow. If the same scene has 20.000 objects, but only "
"uses 100 materials, rendering will be blazingly fast."
msgstr ""
"例如，如果一个场景有20.000个对象，每个对象有20.000个不同的材质，那么渲染将会"
"很慢。如果同一场景有20.000个对象，但只使用100个素材，渲染将非常迅速。"

#: ../../docs/tutorials/3d/3d_performance_and_limitations.rst:71
msgid "Pixel cost vs vertex cost"
msgstr "像素成本vs顶点成本"

#: ../../docs/tutorials/3d/3d_performance_and_limitations.rst:73
msgid ""
"It is a common thought that the lower the number of polygons in a model, the "
"faster it will be rendered. This is *really* relative and depends on many "
"factors."
msgstr ""
"人们普遍认为，模型中多边形的数量越少，渲染的速度就越快。这确实是相对的，取决"
"于很多因素。"

#: ../../docs/tutorials/3d/3d_performance_and_limitations.rst:77
msgid ""
"On a modern PC and console, vertex cost is low. GPUs originally only "
"rendered triangles, so all the vertices:"
msgstr ""
"在现代PC和控制台上，顶点成本很低。 GPU最初只渲染三角形，所以所有顶点都是:"

#: ../../docs/tutorials/3d/3d_performance_and_limitations.rst:80
msgid "Had to be transformed by the CPU (including clipping)."
msgstr "不得不被CPU改造(包括剪裁)。"

#: ../../docs/tutorials/3d/3d_performance_and_limitations.rst:82
msgid "Had to be sent to the GPU memory from the main RAM."
msgstr "不得不从主RAM发送到GPU内存。"

#: ../../docs/tutorials/3d/3d_performance_and_limitations.rst:84
msgid ""
"Nowadays, all this is handled inside the GPU, so the performance is "
"extremely high. 3D artists usually have the wrong feeling about polycount "
"performance because 3D DCCs (such as Blender, Max, etc.) need to keep "
"geometry in CPU memory in order for it to be edited, reducing actual "
"performance. Truth is, a model rendered by a 3D engine is much more optimal "
"than how 3D DCCs display them."
msgstr ""
"如今，所有这些都是在GPU内部处理的，因此性能非常高。 3D艺术家通常对多计数性能"
"有错误的感觉，因为3D DCC(例如Blender，Max等)需要将几何保留在CPU内存中以便进行"
"编辑，从而降低实际性能。 事实上，3D引擎渲染的模型比3D DCC显示模型更加优化。"

#: ../../docs/tutorials/3d/3d_performance_and_limitations.rst:91
msgid ""
"On mobile devices, the story is different. PC and Console GPUs are brute-"
"force monsters that can pull as much electricity as they need from the power "
"grid. Mobile GPUs are limited to a tiny battery, so they need to be a lot "
"more power efficient."
msgstr ""
"在移动设备上，故事是不同的。 PC和控制台GPU是蛮力的怪物，可以从电网中获取所需"
"的电量。 移动GPU仅限于小型电池，因此它们需要更高的功率效率。"

#: ../../docs/tutorials/3d/3d_performance_and_limitations.rst:96
msgid ""
"To be more efficient, mobile GPUs attempt to avoid *overdraw*. This means, "
"the same pixel on the screen being rendered (as in, with lighting "
"calculation, etc.) more than once. Imagine a town with several buildings, "
"GPUs don't know what is visible and what is hidden until they draw it. A "
"house might be drawn and then another house in front of it (rendering "
"happened twice for the same pixel!). PC GPUs normally don't care much about "
"this and just throw more pixel processors to the hardware to increase "
"performance (but this also increases power consumption)."
msgstr ""
"为了提高效率，移动GPU试图避免 *透支* 。 这意味着，屏幕上的相同像素被渲染(如，"
"通过照明计算等)不止一次。 想象一个有几座建筑的小镇，GPU不知道什么是可见的，什"
"么是隐藏的，直到它们绘制它。 可能会绘制一个房子，然后在它前面的另一个房子(对"
"于同一个像素渲染两次！)。 PC GPU通常不关心这一点，只是将更多像素处理器投入硬"
"件以提高性能(但这也增加了功耗)。"

#: ../../docs/tutorials/3d/3d_performance_and_limitations.rst:106
msgid ""
"On mobile, pulling more power is not an option, so a technique called \"Tile "
"Based Rendering\" is used (almost every mobile hardware uses a variant of "
"it), which divides the screen into a grid. Each cell keeps the list of "
"triangles drawn to it and sorts them by depth to minimize *overdraw*. This "
"technique improves performance and reduces power consumption, but takes a "
"toll on vertex performance. As a result, fewer vertices and triangles can be "
"processed for drawing."
msgstr ""
"在移动设备上，提供更多功率不是一种选择，因此使用了一种称为“基于平铺的渲染”的"
"技术(几乎每个移动硬件都使用它的一种变体)，它将屏幕划分为网格。 每个单元格保留"
"绘制到它的三角形列表，并按深度对它们进行排序，以最小化 *重绘* 。 这种技术可以"
"提高性能并降低功耗，但会降低顶点性能。 因此，可以处理更少的顶点和三角形以进行"
"绘制。"

#: ../../docs/tutorials/3d/3d_performance_and_limitations.rst:114
msgid ""
"Generally, this is not so bad, but there is a corner case on mobile that "
"must be avoided, which is to have small objects with a lot of geometry "
"within a small portion of the screen. This forces mobile GPUs to put a lot "
"of strain on a single screen cell, considerably decreasing performance (as "
"all the other cells must wait for it to complete in order to display the "
"frame)."
msgstr ""
"一般来说，这并不是那么糟糕，但在移动设备上有一个必须避免的角落情况，即在屏幕"
"的一小部分内具有大量几何形状的小物体。 这迫使移动GPU在单个屏幕单元上施加了很"
"大的压力，大大降低了性能(因为所有其他单元必须等待它完成才能显示帧)。"

#: ../../docs/tutorials/3d/3d_performance_and_limitations.rst:121
msgid ""
"To make it short, do not worry about vertex count so much on mobile, but "
"avoid concentration of vertices in small parts of the screen. If, for "
"example, a character, NPC, vehicle, etc. is far away (so it looks tiny), use "
"a smaller level of detail (LOD) model instead."
msgstr ""
"为了简化它，不要担心移动设备上的顶点数量如此之多，但要避免在屏幕的小部分中集"
"中顶点。 例如，如果角色，NPC，车辆等距离较远(因此看起来很小)，请使用较小的细"
"节(LOD)模型。"

#: ../../docs/tutorials/3d/3d_performance_and_limitations.rst:126
msgid ""
"An extra situation where vertex cost must be considered is objects that have "
"extra processing per vertex, such as:"
msgstr "必须考虑顶点成本的额外情况是每个顶点具有额外处理的对象，例如:"

#: ../../docs/tutorials/3d/3d_performance_and_limitations.rst:129
msgid "Skinning (skeletal animation)"
msgstr "剥皮(骨骼动画)"

#: ../../docs/tutorials/3d/3d_performance_and_limitations.rst:130
msgid "Morphs (shape keys)"
msgstr "变形(形状键)"

#: ../../docs/tutorials/3d/3d_performance_and_limitations.rst:131
msgid "Vertex Lit Objects (common on mobile)"
msgstr "顶点对象(在移动设备上常见)"

#: ../../docs/tutorials/3d/3d_performance_and_limitations.rst:134
#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:108
msgid "Texture compression"
msgstr "纹理压缩"

#: ../../docs/tutorials/3d/3d_performance_and_limitations.rst:136
msgid ""
"Godot offers to compress textures of 3D models when imported (VRAM "
"compression). Video RAM compression is not as efficient in size as PNG or "
"JPG when stored, but increases performance enormously when drawing."
msgstr ""
"Godot提供在导入时压缩3D模型的纹理(VRAM压缩)。 视频RAM压缩在存储时的大小不如"
"PNG或JPG，但在绘制时极大地提高了性能。"

#: ../../docs/tutorials/3d/3d_performance_and_limitations.rst:140
msgid ""
"This is because the main goal of texture compression is bandwidth reduction "
"between memory and the GPU."
msgstr "这是因为纹理压缩的主要目标是在内存和GPU之间减少带宽。"

#: ../../docs/tutorials/3d/3d_performance_and_limitations.rst:143
#, fuzzy
msgid ""
"In 3D, the shapes of objects depend more on the geometry than the texture, "
"so compression is generally not noticeable. In 2D, compression depends more "
"on shapes inside the textures, so the artifacts resulting from 2D "
"compression are more noticeable."
msgstr ""
"在3D中，对象的形状更多地取决于几何形状而不是纹理，因此压缩通常不明显。 在2D"
"中，压缩更多地取决于纹理内部的形状，因此压缩产生的伪像更加明显。"

#: ../../docs/tutorials/3d/3d_performance_and_limitations.rst:148
msgid ""
"As a warning, most Android devices do not support texture compression of "
"textures with transparency (only opaque), so keep this in mind."
msgstr ""
"作为警告，大多数Android设备不支持具有透明度的纹理的纹理压缩(仅不透明)，因此请"
"记住这一点。"

#: ../../docs/tutorials/3d/3d_performance_and_limitations.rst:152
msgid "Transparent objects"
msgstr "透明物体"

#: ../../docs/tutorials/3d/3d_performance_and_limitations.rst:154
msgid ""
"As mentioned before, Godot sorts objects by material and shader to improve "
"performance. This, however, can not be done on transparent objects. "
"Transparent objects are rendered from back to front to make blending with "
"what is behind work. As a result, please try to keep transparent objects to "
"a minimum! If an object has a small section with transparency, try to make "
"that section a separate material."
msgstr ""
"如前所述，Godot通过材质和着色器对对象进行排序以提高性能。 但是，这不能在透明"
"对象上完成。 透明对象从后向前呈现，以便与工作背后的内容进行混合。 因此，请尽"
"量将透明物体保持在最低限度！ 如果对象具有透明度较小的部分，请尝试将该部分作为"
"单独的材质。"

#: ../../docs/tutorials/3d/3d_performance_and_limitations.rst:162
msgid "Level of detail (LOD)"
msgstr "细节程度(LOD)"

#: ../../docs/tutorials/3d/3d_performance_and_limitations.rst:164
msgid ""
"As also mentioned before, using objects with fewer vertices can improve "
"performance in some cases. Godot has a simple system to change level of "
"detail, :ref:`GeometryInstance <class_GeometryInstance>` based objects have "
"a visibility range that can be defined. Having several GeometryInstance "
"objects in different ranges works as LOD."
msgstr ""
"如前所述，在某些情况下，使用具有较少顶点的对象可以提高性能。 Godot有一个简单"
"的系统来改变细节层次 :ref:`GeometryInstance <class_GeometryInstance>` 基于对"
"象的可见范围可以定义。 在不同范围内具有多个GeometryInstance对象可用作LOD。"

#: ../../docs/tutorials/3d/3d_performance_and_limitations.rst:172
msgid "Use instancing (MultiMesh)"
msgstr "使用实例化(MultiMesh)"

#: ../../docs/tutorials/3d/3d_performance_and_limitations.rst:174
msgid ""
"If several identical objects have to be drawn in the same place or nearby, "
"try using :ref:`MultiMesh <class_MultiMesh>` instead. MultiMesh allows the "
"drawing of dozens of thousands of objects at very little performance cost, "
"making it ideal for flocks, grass, particles, etc."
msgstr ""
"如果必须在同一个地方或附近绘制几个相同的对象，请尝试使用 :ref:`MultiMesh "
"<class_MultiMesh>` 。 MultiMesh允许以极低的性能成本绘制数十万个物体，使其成为"
"鸡群，草，颗粒等的理想选择。"

#: ../../docs/tutorials/3d/3d_performance_and_limitations.rst:181
msgid "Bake lighting"
msgstr "烘焙照明"

#: ../../docs/tutorials/3d/3d_performance_and_limitations.rst:183
msgid ""
"Small lights are usually not a performance issue. Shadows a little more. In "
"general, if several lights need to affect a scene, it's ideal to bake it (:"
"ref:`doc_baked_lightmaps`). Baking can also improve the scene quality by "
"adding indirect light bounces."
msgstr ""
"小灯通常不是性能问题。 阴影多一点。 一般来说，如果几个灯需要影响一个场景，理"
"想的是烘焙它( :ref:`doc_baked_lightmaps` )。 烘焙还可以通过添加间接光反弹来改"
"善场景质量。"

#: ../../docs/tutorials/3d/3d_performance_and_limitations.rst:188
msgid ""
"If working on mobile, baking to texture is recommended, since this method is "
"even faster."
msgstr "如果在移动设备上工作，建议烘焙到纹理，因为这种方法更快。"

#: ../../docs/tutorials/3d/spatial_material.rst:4
msgid "Spatial Material"
msgstr "空间材质"

#: ../../docs/tutorials/3d/spatial_material.rst:9
msgid ""
"``SpatialMaterial`` is a default 3D material that aims to provide most of "
"the features artists look for in a material, without the need for writing "
"shader code. However, it can be converted to shader code if additional "
"functionality is needed."
msgstr ""
"``SpatialMaterial``是一种默认的3D材质，旨在提供艺术家在材质中寻找的大部分功"
"能，而无需编写着色器代码。 但是，如果需要其他功能，可以将其转换为着色器代码。"

#: ../../docs/tutorials/3d/spatial_material.rst:13
msgid "This tutorial explains most parameters present in ``SpatialMaterial``."
msgstr "本教程解释了 ``SpatialMaterial`` 中出现的大多数参数。"

#: ../../docs/tutorials/3d/spatial_material.rst:15
msgid ""
"You can add a ``SpatialMaterial`` to an object by choosing \"New "
"SpatialMaterial\" in the *Material* property of the Inspector."
msgstr ""
"您可以通过在Inspector的* Material *属性中选择“New SpatialMaterial”来向对象添"
"加“SpatialMaterial”。"

#: ../../docs/tutorials/3d/spatial_material.rst:21
msgid ""
"Spatial materials have many flags determining the general usage of a "
"material."
msgstr "空间材质有许多标志，用于确定材质的一般用法。"

#: ../../docs/tutorials/3d/spatial_material.rst:26
msgid "Transparent"
msgstr "透明"

#: ../../docs/tutorials/3d/spatial_material.rst:28
msgid ""
"In Godot, materials are not transparent unless specifically configured to "
"be. The main reason behind this is that transparent materials are rendered "
"using a different technique (sorted from back to front and rendered in "
"order)."
msgstr ""
"在Godot中，除非特别配置，否则材质不透明。 这背后的主要原因是透明材质使用不同"
"的技术渲染(从后到前排序并按顺序渲染)。"

#: ../../docs/tutorials/3d/spatial_material.rst:32
msgid ""
"This technique is less efficient (many state changes happen) and makes the "
"materials unusable with many mid- and post-processing effects (such as SSAO, "
"SSR, etc.) that require perfectly opaque geometry."
msgstr ""
"这种技术效率较低(发生许多状态变化)，并且使得材质无法用于许多需要完全不透明几"
"何形状的中间和后处理效果(例如SSAO，SSR等)。"

#: ../../docs/tutorials/3d/spatial_material.rst:36
msgid ""
"For this reason, materials in Godot are assumed opaque unless specified "
"otherwise. The main settings that enable transparency are:"
msgstr ""
"因此，除非另有说明，否则Godot中的材质是不透明的。 启用透明度的主要设置是:"

#: ../../docs/tutorials/3d/spatial_material.rst:39
msgid "Transparent flag (this one)"
msgstr "透明旗帜(这一个)"

#: ../../docs/tutorials/3d/spatial_material.rst:40
msgid "Blend mode set to other than \"Mix\""
msgstr "混合模式设置为“混合”以外的模式"

#: ../../docs/tutorials/3d/spatial_material.rst:41
msgid "Enabling distance or proximity fade"
msgstr "启用距离或接近淡入淡出"

#: ../../docs/tutorials/3d/spatial_material.rst:44
msgid "Unshaded"
msgstr "无阴影"

#: ../../docs/tutorials/3d/spatial_material.rst:46
msgid ""
"In most cases it is common for materials to be affected by lighting (shaded)."
msgstr "在大多数情况下，材质通常受到照明(阴影)的影响。"

#: ../../docs/tutorials/3d/spatial_material.rst:48
msgid ""
"However, in some cases you might want to show just the albedo (color) and "
"ignore the rest. Toggling this flag on will remove all shading and display "
"pure, unlit color."
msgstr ""
"但是，在某些情况下，您可能只想显示反照率(颜色)而忽略其余部分。 切换此标志将删"
"除所有阴影并显示纯净，不亮的颜色。"

#: ../../docs/tutorials/3d/spatial_material.rst:55
msgid "Vertex Lighting"
msgstr "顶点照明"

#: ../../docs/tutorials/3d/spatial_material.rst:57
msgid ""
"Godot has a more or less uniform cost per pixel thanks to depth pre-pass. "
"All lighting calculations are made by running the lighting shader on every "
"pixel."
msgstr ""
"由于深度预通过，Godot的每像素成本或多或少均匀。 所有照明计算都是通过在每个像"
"素上运行照明着色器来完成的。"

#: ../../docs/tutorials/3d/spatial_material.rst:60
msgid ""
"As these calculations are costly, performance can be brought down "
"considerably in some corner cases such as drawing several layers of "
"transparency (which is common in particle systems). Switching to per-vertex "
"lighting may help in these cases."
msgstr ""
"由于这些计算成本很高，因此在某些极端情况下可以大大降低性能，例如绘制几层透明"
"度(这在粒子系统中很常见)。 在这些情况下，切换到每顶点照明可能会有所帮助。"

#: ../../docs/tutorials/3d/spatial_material.rst:65
msgid ""
"Additionally, on low-end or mobile devices, switching to vertex lighting can "
"considerably increase rendering performance."
msgstr "此外，在低端或移动设备上，切换到顶点照明可以显着提高渲染性能。"

#: ../../docs/tutorials/3d/spatial_material.rst:70
msgid ""
"Keep in mind that when vertex lighting is enabled, only directional lighting "
"can produce shadows (for performance reasons)."
msgstr "请记住，启用顶点照明时，只有定向照明会产生阴影(出于性能原因)。"

#: ../../docs/tutorials/3d/spatial_material.rst:74
msgid "No Depth Test"
msgstr "没有深度测试"

#: ../../docs/tutorials/3d/spatial_material.rst:76
msgid ""
"In order for close objects to appear over far away objects, depth testing is "
"performed. Disabling it has the result of objects appearing over (or under) "
"everything else."
msgstr ""
"为了使近距离物体出现在远处的物体上，进行深度测试。 禁用它会导致对象出现在其他"
"所有内容之上(或之下)。"

#: ../../docs/tutorials/3d/spatial_material.rst:80
msgid ""
"Disabling this makes the most sense for drawing indicators in world space, "
"and works very well with the *Render Priority* property of Material (see the "
"bottom of this page)."
msgstr ""
"禁用此选项对于在世界空间中绘制指标最有意义，并且与Material的* Render "
"Priority *属性非常相似(请参阅本页底部)。"

#: ../../docs/tutorials/3d/spatial_material.rst:87
msgid "Use Point Size"
msgstr "使用磅值"

#: ../../docs/tutorials/3d/spatial_material.rst:89
msgid ""
"This option is only effective when the geometry rendered is made of points "
"(generally it's made of triangles when imported from 3D DCCs). If so, then "
"those points can be resized (see below)."
msgstr ""
"此选项仅在渲染的几何体由点组成时有效(通常从3D DCC导入时由三角形组成)。 如果是"
"这样，那么这些点可以调整大小(见下文)。"

#: ../../docs/tutorials/3d/spatial_material.rst:94
msgid "World Triplanar"
msgstr "世界三平面"

#: ../../docs/tutorials/3d/spatial_material.rst:96
msgid ""
"When using triplanar mapping (see below, in the UV1 and UV2 settings), "
"triplanar is computed in object local space. This option makes triplanar "
"work in world space."
msgstr ""
"使用三平面映射时(见下文，在UV1和UV2设置中)，在对象局部空间中计算三平面。 此选"
"项使triplanar在世界空间中工作。"

#: ../../docs/tutorials/3d/spatial_material.rst:101
msgid "Fixed Size"
msgstr "固定大小"

#: ../../docs/tutorials/3d/spatial_material.rst:103
msgid ""
"This causes the object to be rendered at the same size no matter the "
"distance. This is useful mostly for indicators (no depth test and high "
"render priority) and some types of billboards."
msgstr ""
"这使得无论距离如何，对象都以相同的大小呈现。 这主要用于指标(无深度测试和高渲"
"染优先级)和某些类型的广告牌。"

#: ../../docs/tutorials/3d/spatial_material.rst:108
msgid "Do Not Receive Shadows"
msgstr "不接受阴影"

#: ../../docs/tutorials/3d/spatial_material.rst:110
msgid ""
"Makes the object not receive any kind of shadow that would otherwise be cast "
"onto it."
msgstr "使对象不会接收任何可能会被投射到其上的阴影。"

#: ../../docs/tutorials/3d/spatial_material.rst:114
msgid "Disable Ambient Light"
msgstr "禁用环境光"

#: ../../docs/tutorials/3d/spatial_material.rst:116
msgid ""
"Makes the object not receive any kind of ambient lighting that would "
"otherwise light it."
msgstr "使物体不会接收任何会照亮它的环境照明。"

#: ../../docs/tutorials/3d/spatial_material.rst:120
msgid "Vertex Color"
msgstr "顶点颜色"

#: ../../docs/tutorials/3d/spatial_material.rst:122
msgid ""
"This setting allows choosing what is done by default to vertex colors that "
"come from your 3D modelling application. By default they are ignored."
msgstr ""
"此设置允许选择默认情况下对来自3D建模应用程序的顶点颜色执行的操作。 默认情况"
"下，它们会被忽略。"

#: ../../docs/tutorials/3d/spatial_material.rst:128
msgid "Use as Albedo"
msgstr "用作反照率"

#: ../../docs/tutorials/3d/spatial_material.rst:130
msgid "Choosing this option means vertex color is used as albedo color."
msgstr "选择此选项意味着顶点颜色用作反照率颜色。"

#: ../../docs/tutorials/3d/spatial_material.rst:133
msgid "Is sRGB"
msgstr "是sRGB"

#: ../../docs/tutorials/3d/spatial_material.rst:135
msgid ""
"Most 3D DCCs will likely export vertex colors as sRGB, so toggling this "
"option on will help them look correct."
msgstr ""
"大多数3D DCC可能会将顶点颜色导出为sRGB，因此切换此选项将有助于它们看起来正"
"确。"

#: ../../docs/tutorials/3d/spatial_material.rst:139
#: ../../docs/tutorials/platform/services_for_ios.rst:87
#: ../../docs/tutorials/platform/services_for_ios.rst:127
#: ../../docs/tutorials/platform/services_for_ios.rst:196
#: ../../docs/tutorials/platform/services_for_ios.rst:240
#: ../../docs/tutorials/platform/services_for_ios.rst:385
msgid "Parameters"
msgstr "参数"

#: ../../docs/tutorials/3d/spatial_material.rst:141
msgid ""
"``SpatialMaterial`` also has several configurable parameters to tweak many "
"aspects of the rendering:"
msgstr "``SpatialMaterial``还有几个可配置的参数来调整渲染的许多方面:"

#: ../../docs/tutorials/3d/spatial_material.rst:147
msgid "Diffuse Mode"
msgstr "漫反射模式"

#: ../../docs/tutorials/3d/spatial_material.rst:149
msgid ""
"Specifies the algorithm used by diffuse scattering of light when hitting the "
"object. The default is *Burley*. Other modes are also available:"
msgstr ""
"指定击中对象时漫反射光散射所使用的算法。 默认为* Burley *。 其他模式也可用:"

#: ../../docs/tutorials/3d/spatial_material.rst:152
msgid ""
"**Burley:** Default mode, the original Disney Principled PBS diffuse "
"algorithm."
msgstr "** Burley:** 默认模式，原始的Disney Principled PBS漫反射算法。"

#: ../../docs/tutorials/3d/spatial_material.rst:153
msgid "**Lambert:** Is not affected by roughness."
msgstr "**兰伯特:** 不受粗糙度的影响。"

#: ../../docs/tutorials/3d/spatial_material.rst:154
msgid ""
"**Lambert Wrap:** Extends Lambert to cover more than 90 degrees when "
"roughness increases. Works great for hair and simulating cheap subsurface "
"scattering. This implementation is energy conserving."
msgstr ""
"** Lambert Wrap:** 当粗糙度增加时，将Lambert延伸至覆盖90度以上。 适用于头发和"
"模拟廉价的次表面散射。 这种实施是节能的。"

#: ../../docs/tutorials/3d/spatial_material.rst:157
msgid ""
"**Oren Nayar:** This implementation aims to take microsurfacing into account "
"(via roughness). Works well for clay-like materials and some types of cloth."
msgstr ""
"** Oren Nayar:** 此实现旨在将微表面考虑在内(通过粗糙度)。 适用于粘土类材质和"
"某些类型的布料。"

#: ../../docs/tutorials/3d/spatial_material.rst:159
msgid ""
"**Toon:** Provides a hard cut for lighting, with smoothing affected by "
"roughness. It is recommended you disable sky contribution from your "
"environment's ambient light settings or disable ambient light in the spatial "
"material to achieve a better effect."
msgstr ""
"**香椿:** 为照明提供硬切，光滑度受粗糙度的影响。 建议您从环境的环境光设置中禁"
"用天空贡献，或禁用空间材质中的环境光以获得更好的效果。"

#: ../../docs/tutorials/3d/spatial_material.rst:167
msgid "Specular Mode"
msgstr "镜面反射模式"

#: ../../docs/tutorials/3d/spatial_material.rst:169
msgid ""
"Specifies how the specular blob will be rendered. The specular blob "
"represents the shape of a light source reflected in the object."
msgstr "指定镜面blob的呈现方式。 镜面斑点表示在对象中反射的光源的形状。"

#: ../../docs/tutorials/3d/spatial_material.rst:172
msgid "**ShlickGGX:** The most common blob used by PBR 3D engines nowadays."
msgstr "** ShlickGGX:** 现在PBR 3D引擎使用的最常见的blob。"

#: ../../docs/tutorials/3d/spatial_material.rst:173
msgid ""
"**Blinn:** Common in previous-generation engines. Not worth using nowadays, "
"but left here for the sake of compatibility."
msgstr ""
"** Blinn:** 在上一代发动机中很常见。 现在不值得使用，但为了兼容性而留在这里。"

#: ../../docs/tutorials/3d/spatial_material.rst:175
msgid "**Phong:** Same as above."
msgstr "** Phong:** 同上。"

#: ../../docs/tutorials/3d/spatial_material.rst:176
msgid ""
"**Toon:** Creates a toon blob, which changes size depending on roughness."
msgstr "**香椿:** 创建一个香椿斑点，根据粗糙度改变大小。"

#: ../../docs/tutorials/3d/spatial_material.rst:177
msgid "**Disabled:** Sometimes the blob gets in the way. Begone!"
msgstr "**禁用:** 有时候blob阻碍了。走开！"

#: ../../docs/tutorials/3d/spatial_material.rst:182
msgid "Blend Mode"
msgstr "混合模式"

#: ../../docs/tutorials/3d/spatial_material.rst:184
msgid ""
"Controls the blend mode for the material. Keep in mind that any mode other "
"than *Mix* forces the object to go through the transparent pipeline."
msgstr ""
"控制材质的混合模式。 请记住，* Mix *以外的任何模式都会强制对象通过透明管道。"

#: ../../docs/tutorials/3d/spatial_material.rst:187
msgid ""
"**Mix:** Default blend mode, alpha controls how much the object is visible."
msgstr "**混合:** 默认混合模式，alpha控制对象可见的程度。"

#: ../../docs/tutorials/3d/spatial_material.rst:188
msgid ""
"**Add:** Object is blended additively, nice for flares or some fire-like "
"effects."
msgstr "**添加:** 物体混合添加，非常适合耀斑或类似火焰的效果。"

#: ../../docs/tutorials/3d/spatial_material.rst:190
msgid "**Sub:** Object is subtracted."
msgstr "** Sub:** 减去对象。"

#: ../../docs/tutorials/3d/spatial_material.rst:191
msgid "**Mul:** Object is multiplied."
msgstr "** Mul:** 物体成倍增加。"

#: ../../docs/tutorials/3d/spatial_material.rst:196
msgid "Cull Mode"
msgstr "剔除模式"

#: ../../docs/tutorials/3d/spatial_material.rst:198
msgid ""
"Determines which side of the object is not drawn when backfaces are rendered:"
msgstr "确定渲染背面时未绘制对象的哪一侧:"

#: ../../docs/tutorials/3d/spatial_material.rst:200
msgid "**Back:** The back of the object is culled when not visible (default)."
msgstr "**后退:** 当不可见时，对象的背面被剔除(默认)。"

#: ../../docs/tutorials/3d/spatial_material.rst:201
msgid "**Front:** The front of the object is culled when not visible."
msgstr "**正面:** 当不可见时，物体的正面被剔除。"

#: ../../docs/tutorials/3d/spatial_material.rst:202
msgid ""
"**Disabled:** Used for objects that are double-sided (no culling is "
"performed)."
msgstr "**禁用:** 用于双面对象(不进行剔除)。"

#: ../../docs/tutorials/3d/spatial_material.rst:205
msgid "Depth Draw Mode"
msgstr "深度绘制模式"

#: ../../docs/tutorials/3d/spatial_material.rst:207
msgid "Specifies when depth rendering must take place."
msgstr "指定何时必须进行深度渲染。"

#: ../../docs/tutorials/3d/spatial_material.rst:209
msgid "**Opaque Only (default):** Depth is only drawn for opaque objects."
msgstr "**仅限不透明(默认):** 仅为不透明对象绘制深度。"

#: ../../docs/tutorials/3d/spatial_material.rst:210
msgid ""
"**Always:** Depth draw is drawn for both opaque and transparent objects."
msgstr "**始终:** 为不透明和透明对象绘制深度绘制。"

#: ../../docs/tutorials/3d/spatial_material.rst:211
msgid ""
"**Never:** No depth draw takes place (do not confuse this with the No Depth "
"Test option above)."
msgstr "**从不:** 不进行深度抽取(不要将其与上面的无深度测试选项混淆)。"

#: ../../docs/tutorials/3d/spatial_material.rst:213
msgid ""
"**Depth Pre-Pass:** For transparent objects, an opaque pass is made first "
"with the opaque parts, then transparency is drawn above. Use this option "
"with transparent grass or tree foliage."
msgstr ""
"**深度预通过:** 对于透明物体，首先使用不透明部分进行不透明的通过，然后在上方"
"绘制透明度。 将此选项与透明草或树叶一起使用。"

#: ../../docs/tutorials/3d/spatial_material.rst:220
msgid "Line Width"
msgstr "行宽"

#: ../../docs/tutorials/3d/spatial_material.rst:222
msgid ""
"When drawing lines, specify the width of the lines being drawn. This option "
"is not available on most modern hardware."
msgstr "绘制线条时，指定要绘制的线条的宽度。 大多数现代硬件都不提供此选项。"

#: ../../docs/tutorials/3d/spatial_material.rst:226
msgid "Point Size"
msgstr "点大小"

#: ../../docs/tutorials/3d/spatial_material.rst:228
msgid "When drawing points, specify the point size in pixels."
msgstr "绘制点时，指定点大小(以像素为单位)。"

#: ../../docs/tutorials/3d/spatial_material.rst:231
msgid "Billboard Mode"
msgstr "广告牌模式"

#: ../../docs/tutorials/3d/spatial_material.rst:233
msgid ""
"Enables billboard mode for drawing materials. This controls how the object "
"faces the camera:"
msgstr "为绘图材质启用广告牌模式。 这可以控制对象面向摄像头的方式:"

#: ../../docs/tutorials/3d/spatial_material.rst:236
msgid "**Disabled:** Billboard mode is disabled."
msgstr "**已禁用:** 禁用广告牌模式。"

#: ../../docs/tutorials/3d/spatial_material.rst:237
msgid ""
"**Enabled:** Billboard mode is enabled, the object's -Z axis will always "
"face the camera."
msgstr "**启用:** 启用广告牌模式，对象的-Z轴将始终面向摄像机。"

#: ../../docs/tutorials/3d/spatial_material.rst:239
msgid ""
"**Y-Billboard:** The object's X axis will always be aligned with the camera."
msgstr "** Y-Billboard:** 物体的X轴始终与相机对齐。"

#: ../../docs/tutorials/3d/spatial_material.rst:240
msgid ""
"**Particles:** Most suited for particle systems, because it allows "
"specifying animation options."
msgstr "**粒子:** 最适合粒子系统，因为它允许指定动画选项。"

#: ../../docs/tutorials/3d/spatial_material.rst:245
msgid "The above options are only enabled for Particle Billboard."
msgstr "以上选项仅适用于Particle Billboard。"

#: ../../docs/tutorials/3d/spatial_material.rst:248
msgid "Grow"
msgstr "增长"

#: ../../docs/tutorials/3d/spatial_material.rst:250
msgid "Grows the object vertices in the direction pointed by their normals:"
msgstr "沿法线指向的方向生成对象顶点:"

#: ../../docs/tutorials/3d/spatial_material.rst:254
msgid ""
"This is commonly used to create cheap outlines. Add a second material pass, "
"make it black and unshaded, reverse culling (Cull Front), and add some grow:"
msgstr ""
"这通常用于创建廉价的轮廓。 添加第二个材质传递，使其变为黑色和无阴影，反向剔除"
"(剔除前面)，并添加一些增长:"

#: ../../docs/tutorials/3d/spatial_material.rst:261
msgid "Use Alpha Scissor"
msgstr "使用Alpha Scissor"

#: ../../docs/tutorials/3d/spatial_material.rst:263
msgid ""
"When transparency other than ``0`` or ``1`` is not needed, it's possible to "
"set a threshold to prevent the object from rendering semi-transparent pixels."
msgstr "当不需要“0”或“1”以外的透明度时，可以设置阈值以防止对象呈现半透明像素。"

#: ../../docs/tutorials/3d/spatial_material.rst:268
msgid ""
"This renders the object via the opaque pipeline, which is faster and allows "
"it to use mid- and post-process effects such as SSAO, SSR, etc."
msgstr ""
"这通过不透明管道渲染对象，这更快，并允许它使用中间和后期处理效果，如SSAO，SSR"
"等。"

#: ../../docs/tutorials/3d/spatial_material.rst:272
msgid "Material colors, maps and channels"
msgstr "材质颜色，地图和渠道"

#: ../../docs/tutorials/3d/spatial_material.rst:274
msgid ""
"Besides the parameters, what defines materials themselves are the colors, "
"textures, and channels. Godot supports an extensive list of them. They are "
"described in detail below:"
msgstr ""
"除了参数之外，定义材质本身的是颜色，纹理和通道。 Godot支持广泛的列表。 它们在"
"下面详细描述:"

#: ../../docs/tutorials/3d/spatial_material.rst:279
msgid "Albedo"
msgstr "反照率"

#: ../../docs/tutorials/3d/spatial_material.rst:281
msgid ""
"*Albedo* is the base color for the material, on which all the other settings "
"operate. When set to *Unshaded*, this is the only color that is visible. In "
"previous versions of Godot, this channel was named *Diffuse*. The change of "
"name mainly happened because, in PBR (Physically Based Rendering), this "
"color affects many more calculations than just the diffuse lighting path."
msgstr ""
"*Albedo* 是材质的基色，所有其他设置都在其上运行。 设置为 *Unshaded* 时，这是"
"唯一可见的颜色。 在以前版本的Godot中，这个频道被命名为 *Diffuse* 。 名称的改"
"变主要是因为在PBR渲染中，这种颜色影响的计算量远远超过漫射光照路径。"

#: ../../docs/tutorials/3d/spatial_material.rst:287
msgid "Albedo color and texture can be used together as they are multiplied."
msgstr "反射颜色和纹理可以一起使用，因为它们相乘。"

#: ../../docs/tutorials/3d/spatial_material.rst:289
msgid ""
"*Alpha channel* in albedo color and texture is also used for the object "
"transparency. If you use a color or texture with *alpha channel*, make sure "
"to either enable transparency or *alpha scissoring* for it to work."
msgstr ""
"*反照率颜色和纹理的Alpha通道*也用于对象透明度。 如果您使用带* alpha通道*的颜"
"色或纹理，请确保启用透明度或* alpha剪裁*以使其正常工作。"

#: ../../docs/tutorials/3d/spatial_material.rst:294
msgid "Metallic"
msgstr "金属的"

#: ../../docs/tutorials/3d/spatial_material.rst:296
msgid ""
"Godot uses a metallic model over competing models due to its simplicity. "
"This parameter defines how reflective the material is. The more reflective, "
"the less diffuse/ambient light affects the material and the more light is "
"reflected. This model is called \"energy-conserving\"."
msgstr ""
"由于其简单性，Godot使用金属模型而不是竞争模型。 此参数定义材质的反射程度。 反"
"射越多，漫射/环境光的影响越小，反射的光越多。 这种模式被称为“节能”。"

#: ../../docs/tutorials/3d/spatial_material.rst:301
msgid ""
"The *Specular* parameter is a general amount for the reflectivity (unlike "
"*Metallic*, this is not energy-conserving, so leave it at ``0.5`` and don't "
"touch it unless you need to)."
msgstr ""
"* Specular *参数是反射率的一般数量(与* Metallic *不同，这不是节能的，因此请将"
"其保留为“0.5”并且除非您需要，否则不要触摸它)。"

#: ../../docs/tutorials/3d/spatial_material.rst:305
msgid ""
"The minimum internal reflectivity is ``0.04``, so it's impossible to make a "
"material completely unreflective, just like in real life."
msgstr ""
"最小的内部反射率是“0.04”，因此不可能使材质完全不反射，就像在现实生活中一样。"

#: ../../docs/tutorials/3d/spatial_material.rst:311
msgid "Roughness"
msgstr "粗糙度"

#: ../../docs/tutorials/3d/spatial_material.rst:313
msgid ""
"*Roughness* affects the way reflection happens. A value of ``0`` makes it a "
"perfect mirror while a value of ``1`` completely blurs the reflection "
"(simulating natural microsurfacing). Most common types of materials can be "
"achieved with the right combination of *Metallic* and *Roughness*."
msgstr ""
"*粗糙度*会影响反射的发生方式。 值“0”使其成为完美的镜子，而“1”的值完全模糊了反"
"射(模拟自然微表面)。 最常见的材质类型可以通过* Metallic *和* Roughness *的正"
"确组合来实现。"

#: ../../docs/tutorials/3d/spatial_material.rst:321
msgid "Emission"
msgstr "发射"

#: ../../docs/tutorials/3d/spatial_material.rst:323
msgid ""
"*Emission* specifies how much light is emitted by the material (keep in mind "
"this does not include light surrounding geometry unless :ref:`doc_gi_probes` "
"are used). This value is added to the resulting final image and is not "
"affected by other lighting in the scene."
msgstr ""
"*发射* 指定材质发出的光量(请记住，这不包括周围的几何光，除非使用 :ref:"
"`doc_gi_probes` )。 此值将添加到生成的最终图像中，并且不受场景中其他光照的影"
"响。"

#: ../../docs/tutorials/3d/spatial_material.rst:331
msgid "Normalmap"
msgstr "法线"

#: ../../docs/tutorials/3d/spatial_material.rst:333
msgid ""
"Normal mapping allows you to set a texture that represents finer shape "
"detail. This does not modify geometry, only the incident angle for light. In "
"Godot, only the red and green channels of normal maps are used for wider "
"compatibility."
msgstr ""
"法线贴图允许您设置表示更精细形状细节的纹理。 这不会修改几何体，只会修改光的入"
"射角。 在Godot中，只使用法线贴图的红色和绿色通道来实现更广泛的兼容性。"

#: ../../docs/tutorials/3d/spatial_material.rst:340
msgid "Rim"
msgstr "轮缘"

#: ../../docs/tutorials/3d/spatial_material.rst:342
msgid ""
"Some fabrics have small micro-fur that causes light to scatter around it. "
"Godot emulates this with the *Rim* parameter. Unlike other rim lighting "
"implementations, which just use the emission channel, this one actually "
"takes light into account (no light means no rim). This makes the effect "
"considerably more believable."
msgstr ""
"一些织物具有小的微毛，导致光在其周围散射。 Godot使用* Rim *参数模拟它。 与仅"
"使用发射通道的其他边缘照明实施方式不同，这实际上考虑了光(没有光意味着没有边"
"缘)。 这使得效果更加可信。"

#: ../../docs/tutorials/3d/spatial_material.rst:349
msgid ""
"Rim size depends on roughness, and there is a special parameter to specify "
"how it must be colored. If *Tint* is ``0``, the color of the light is used "
"for the rim. If *Tint* is ``1``, then the albedo of the material is used. "
"Using intermediate values generally works best."
msgstr ""
"轮辋大小取决于粗糙度，并且有一个特殊参数来指定它必须如何着色。 如果* Tint *"
"为“0”，则灯的颜色用于轮辋。 如果* Tint *是“1”，则使用材质的反照率。 使用中间"
"值通常效果最佳。"

#: ../../docs/tutorials/3d/spatial_material.rst:355
#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:61
msgid "Clearcoat"
msgstr "清漆"

#: ../../docs/tutorials/3d/spatial_material.rst:357
msgid ""
"The *Clearcoat* parameter is used to add a secondary pass of transparent "
"coat to the material. This is common in car paint and toys. In practice, "
"it's a smaller specular blob added on top of the existing material."
msgstr ""
"* Clearcoat *参数用于为材质添加透明涂层的二次通过。 这在汽车油漆和玩具中很常"
"见。 在实践中，它是在现有材质之上添加的较小的镜面斑点。"

#: ../../docs/tutorials/3d/spatial_material.rst:362
#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:60
msgid "Anisotropy"
msgstr "各向异性"

#: ../../docs/tutorials/3d/spatial_material.rst:364
msgid ""
"This changes the shape of the specular blob and aligns it to tangent space. "
"Anisotropy is commonly used with hair, or to make materials such as brushed "
"aluminum more realistic. It works especially well when combined with "
"flowmaps."
msgstr ""
"这会更改镜面斑点的形状并将其与切线空间对齐。 各向异性通常与头发一起使用，或使"
"诸如拉丝铝之类的材质更加逼真。 与流程图结合使用时效果特别好。"

#: ../../docs/tutorials/3d/spatial_material.rst:371
msgid "Ambient Occlusion"
msgstr "环境光遮蔽"

#: ../../docs/tutorials/3d/spatial_material.rst:373
msgid ""
"It is possible to specify a baked ambient occlusion map. This map affects "
"how much ambient light reaches each surface of the object (it does not "
"affect direct light by default). While it is possible to use Screen-Space "
"Ambient Occlusion (SSAO) to generate ambient occlusion, nothing beats the "
"quality of a well-baked AO map. It is recommended to bake ambient occlusion "
"whenever possible."
msgstr ""
"可以指定烘焙的环境遮挡贴图。 此贴图会影响环境光到达对象每个表面的程度(默认情"
"况下它不会影响直接光)。 虽然可以使用屏幕空间环境遮挡(SSAO)来生成环境遮挡，但"
"没有什么能比良好烘焙的AO贴图的质量更好。 建议尽可能烘焙环境遮挡。"

#: ../../docs/tutorials/3d/spatial_material.rst:382
msgid "Depth"
msgstr "深度"

#: ../../docs/tutorials/3d/spatial_material.rst:384
msgid ""
"Setting a depth map on a material produces a ray-marched search to emulate "
"the proper displacement of cavities along the view direction. This is not "
"real added geometry, but an illusion of depth. It may not work for complex "
"objects, but it produces a realistic depth effect for textures. For best "
"results, *Depth* should be used together with normal mapping."
msgstr ""
"在材质上设置深度贴图会产生光线行进搜索，以模拟沿视图方向的腔体的正确位移。 这"
"不是真正增加的几何，而是一种深度的幻觉。 它可能不适用于复杂的对象，但它会为纹"
"理产生逼真的深度效果。 为获得最佳效果，* Depth *应与法线贴图一起使用。"

#: ../../docs/tutorials/3d/spatial_material.rst:393
msgid "Subsurface Scattering"
msgstr "次表面散射"

#: ../../docs/tutorials/3d/spatial_material.rst:395
msgid ""
"This effect emulates light that penetrates an object's surface, is "
"scattered, and then comes out. It is useful to create realistic skin, "
"marble, colored liquids, etc."
msgstr ""
"此效果模拟穿透物体表面，散射然后散出的光。 创造逼真的皮肤，大理石，有色液体等"
"是有用的。"

#: ../../docs/tutorials/3d/spatial_material.rst:402
msgid "Transmission"
msgstr "传输"

#: ../../docs/tutorials/3d/spatial_material.rst:404
msgid ""
"This controls how much light from the lit side (visible to light) is "
"transferred to the dark side (opposite from the light). This works well for "
"thin objects such as plant leaves, grass, human ears, etc."
msgstr ""
"这可以控制从被点亮的一侧(可见光到光线)传输到暗侧(与灯光相反)的光线。 这适用于"
"植物叶子，草，人耳等薄物体。"

#: ../../docs/tutorials/3d/spatial_material.rst:411
#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:58
msgid "Refraction"
msgstr "折射"

#: ../../docs/tutorials/3d/spatial_material.rst:413
msgid ""
"When refraction is enabled, it supersedes alpha blending, and Godot attempts "
"to fetch information from behind the object being rendered instead. This "
"allows distorting the transparency in a way similar to refraction in real "
"life."
msgstr ""
"当启用折射时，它会取代alpha混合，而Godot会尝试从正在渲染的对象后面获取信息。 "
"这允许以类似于现实生活中的折射的方式扭曲透明度。"

#: ../../docs/tutorials/3d/spatial_material.rst:420
msgid "Detail"
msgstr "详情"

#: ../../docs/tutorials/3d/spatial_material.rst:422
msgid ""
"Godot allows using secondary albedo and normal maps to generate a detail "
"texture, which can be blended in many ways. By combining this with secondary "
"UV or triplanar modes, many interesting textures can be achieved."
msgstr ""
"Godot允许使用二级反照率和法线贴图生成细节纹理，可以通过多种方式进行混合。 通"
"过将其与二级UV或三平面模式相结合，可以实现许多有趣的纹理。"

#: ../../docs/tutorials/3d/spatial_material.rst:429
msgid "UV1 and UV2"
msgstr "UV1和UV2"

#: ../../docs/tutorials/3d/spatial_material.rst:431
msgid ""
"Godot supports two UV channels per material. Secondary UV is often useful "
"for ambient occlusion or emission (baked light). UVs can be scaled and "
"offset, which is useful when using repeating textures."
msgstr ""
"Godot每种材质支持两个UV通道。 二次紫外线通常可用于环境遮挡或发射(烘焙光)。 UV"
"可以缩放和偏移，这在使用重复纹理时很有用。"

#: ../../docs/tutorials/3d/spatial_material.rst:436
msgid "Triplanar Mapping"
msgstr "Triplanar映射"

#: ../../docs/tutorials/3d/spatial_material.rst:438
msgid ""
"Triplanar mapping is supported for both UV1 and UV2. This is an alternative "
"way to obtain texture coordinates, sometimes called \"Autotexture\". "
"Textures are sampled in X, Y and Z and blended by the normal. Triplanar "
"mapping can be performed in either world space or object space."
msgstr ""
"UV1和UV2都支持Triplanar映射。 这是获得纹理坐标的另一种方法，有时称为“自动纹"
"理”。 纹理在X，Y和Z中采样，并由法线混合。 可以在世界空间或对象空间中执行三平"
"面映射。"

#: ../../docs/tutorials/3d/spatial_material.rst:443
msgid ""
"In the image below, you can see how all primitives share the same material "
"with world triplanar, so the brick texture continues smoothly between them."
msgstr ""
"在下图中，您可以看到所有基元如何与世界三平面共享相同的材质，因此砖纹理在它们"
"之间继续平滑。"

#: ../../docs/tutorials/3d/spatial_material.rst:449
msgid "Proximity and distance fade"
msgstr "接近和距离褪色"

#: ../../docs/tutorials/3d/spatial_material.rst:451
msgid ""
"Godot allows materials to fade by proximity to each other as well as "
"depending on the distance from the viewer. Proximity fade is useful for "
"effects such as soft particles or a mass of water with a smooth blending to "
"the shores. Distance fade is useful for light shafts or indicators that are "
"only present after a given distance."
msgstr ""
"Godot允许材质通过彼此接近以及取决于与观察者的距离而褪色。 接近褪色对于诸如软"
"颗粒或大量水的效果是有用的，并且平滑地混合到海岸。 距离淡化对于仅在给定距离之"
"后存在的光轴或指示器是有用的。"

#: ../../docs/tutorials/3d/spatial_material.rst:457
msgid ""
"Keep in mind enabling these enables alpha blending, so abusing them for an "
"entire scene is usually not a good idea."
msgstr ""
"请记住，启用这些功能可以实现Alpha混合，因此将它们用于整个场景通常不是一个好主"
"意。"

#: ../../docs/tutorials/3d/spatial_material.rst:463
msgid "Render priority"
msgstr "渲染优先级"

#: ../../docs/tutorials/3d/spatial_material.rst:465
msgid ""
"The rendering order of objects can be changed, although this is mostly "
"useful for transparent objects (or opaque objects that perform depth draw "
"but no color draw, such as cracks on the floor)."
msgstr ""
"可以更改对象的渲染顺序，尽管这对于透明对象(或执行深度绘制但没有颜色绘制的不透"
"明对象，例如地板上的裂缝)非常有用。"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:4
msgid "Lights and shadows"
msgstr "灯光和阴影"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:9
#, fuzzy
msgid ""
"Light sources emit light that mixes with the materials and produces a "
"visible result. Light can come from several types of sources in a scene:"
msgstr "灯发出的光与材质混合并产生可见的结果。 光可以来自场景中的几种类型的源:"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:12
msgid ""
"From the Material itself in the form of the emission color (though it does "
"not affect nearby objects unless baked)."
msgstr "从材质本身以发光颜色的形式(虽然它不会影响附近的物体，除非烘焙)。"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:14
msgid "Light Nodes: Directional, Omni and Spot."
msgstr "光节点:Directional，Omni和Spot。"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:15
msgid "Ambient Light in the :ref:`Environment <class_Environment>`."
msgstr "环境光 :ref:`Environment <class_Environment>`。"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:17
msgid "Baked Light (read :ref:`doc_baked_lightmaps`)."
msgstr "烤光(读 :ref:`doc_baked_lightmaps`)。"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:19
msgid ""
"The emission color is a material property. You can read more about it in "
"the :ref:`doc_spatial_material` tutorial."
msgstr ""
"发光颜色是材质特性。 您可以在 :ref:`doc_spatial_material` 教程中阅读更多相关"
"内容。"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:23
msgid "Light nodes"
msgstr "轻节点"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:25
#, fuzzy
msgid ""
"There are three types of light nodes: `Directional light`_, `Omni light`_ "
"and `Spot light`_. Let's take a look at the common parameters for lights:"
msgstr ""
"如前所述，有三种类型的光节点:Directional，Omni和Spot。 每种都有不同的用途，下"
"面将详细介绍，但首先让我们来看看灯光的常用参数:"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:31
msgid "Each one has a specific function:"
msgstr "每个人都有一个特定的功能:"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:33
msgid "**Color**: Base color for emitted light."
msgstr "**颜色**:发光的基色。"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:34
msgid ""
"**Energy**: Energy multiplier. This is useful for saturating lights or "
"working with :ref:`doc_high_dynamic_range`."
msgstr ""
"**能量**:能量倍增器。 这对于使灯光饱和或使用以下内容非常有用 :ref:"
"`doc_high_dynamic_range`。"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:35
msgid ""
"**Indirect Energy**: Secondary multiplier used with indirect light (light "
"bounces). This works in baked light or GIProbe."
msgstr ""
"**间接能量**:与间接光(光反弹)一起使用的次级倍增器。 这适用于烘焙灯或GIProbe。"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:36
msgid ""
"**Negative**: Light becomes subtractive instead of additive. It's sometimes "
"useful to manually compensate some dark corners."
msgstr "**负**:光变为减色而不是添加。 手动补偿一些黑暗角落有时很有用。"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:37
msgid ""
"**Specular**: Affects the intensity of the specular blob in objects affected "
"by this light. At zero, this light becomes a pure diffuse light."
msgstr ""
"**高光**:影响受此光影响的物体中镜面斑点的强度。 在零时，该光变为纯漫射光。"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:38
msgid ""
"**Cull Mask**: Objects that are in the selected layers below will be "
"affected by this light."
msgstr "**剔掩码**:下面所选图层中的物体会受到此灯光的影响。"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:41
msgid "Shadow mapping"
msgstr "阴影贴图"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:43
msgid ""
"Lights can optionally cast shadows. This gives them greater realism (light "
"does not reach occluded areas), but it can incur a bigger performance cost. "
"There is a list of generic shadow parameters, each also has a specific "
"function:"
msgstr ""
"灯光可以选择投射阴影。 这使它们具有更大的真实感(光线不会到达遮挡区域)，但它会"
"带来更大的性能成本。 有一个通用阴影参数列表，每个参数也有一个特定的功能:"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:47
msgid "**Enabled**: Check to enable shadow mapping in this light."
msgstr "**启用**:检查以启用阴影贴图。"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:48
msgid ""
"**Color**: Areas occluded are multiplied by this color. It is black by "
"default, but it can be changed to tint shadows."
msgstr "**颜色**:遮挡的区域乘以此颜色。 默认为黑色，但可以更改为浅色阴影。"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:49
msgid ""
"**Bias**: When this parameter is too small, self shadowing occurs. When too "
"large, shadows separate from the casters. Tweak to what works best for you."
msgstr ""
"**偏置**:当此参数太小时，会发生自阴影。 当太大时，阴影与脚轮分开。 调整最适合"
"您的方法。"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:50
msgid ""
"**Contact**: Performs a short screen-space raycast to reduce the gap "
"generated by the bias."
msgstr "**联系人**:执行短屏幕空间光线投射，以减少偏差产生的间隙。"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:51
msgid ""
"**Reverse Cull Faces**: Some scenes work better when shadow mapping is "
"rendered with face-culling inverted."
msgstr "**反向剔除面部**:当使用面部剔除反转渲染阴影贴图时，某些场景效果更好。"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:53
#, fuzzy
msgid ""
"Below is an image of what tweaking bias looks like. Default values work for "
"most cases, but in general it depends on the size and complexity of geometry."
msgstr ""
"下面是调整偏差的样子。 默认值适用于大多数情况，但通常取决于几何的大小和复杂程"
"度。"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:58
msgid "Finally, if gaps can't be solved, the **Contact** option can help:"
msgstr "最后，如果无法解决差距，** Contact **选项可以帮助:"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:62
msgid ""
"Any sort of bias issues can always be fixed by increasing the shadow map "
"resolution, although that may lead to decreased performance on low-end "
"hardware."
msgstr ""
"任何类型的偏差问题都可以通过增加阴影贴图分辨率来解决，尽管这可能会导致低端硬"
"件性能下降。"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:66
msgid "Directional light"
msgstr "定向光"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:68
msgid ""
"This is the most common type of light and represents a light source very far "
"away (such as the sun). It is also the cheapest light to compute and should "
"be used whenever possible (although it's not the cheapest shadow-map to "
"compute, but more on that later)."
msgstr ""
"这是最常见的光线类型，代表了很远的光源(如太阳)。 它也是计算中最便宜的灯，应该"
"尽可能使用(虽然它不是最便宜的阴影图来计算，但稍后会更多)。"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:72
msgid ""
"Directional light models an infinite number of parallel light rays covering "
"the whole scene. The directional light node is represented by a big arrow "
"which indicates the direction of the light rays. However, the position of "
"the node does not affect the lighting at all and can be anywhere."
msgstr ""
"定向光模拟覆盖整个场景的无限数量的平行光线。 定向光节点由指示光线方向的大箭头"
"表示。 但是，节点的位置根本不会影响照明，可以在任何地方。"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:79
#, fuzzy
msgid ""
"Every face whose front-side is hit by the light rays is lit, while the "
"others stay dark. Most light types have specific parameters, but directional "
"lights are pretty simple in nature, so they don't."
msgstr ""
"每个脸的正面被光线照射，而其他脸部则保持黑暗。 大多数灯光类型都有特定的参数，"
"但定向灯本质上非常简单，所以它们没有。"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:83
msgid "Directional shadow mapping"
msgstr "定向阴影映射"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:85
msgid ""
"To compute shadow maps, the scene is rendered (only depth) from an "
"orthogonal point of view that covers the whole scene (or up to the max "
"distance). There is, however, a problem with this approach because objects "
"closer to the camera receive blocky shadows."
msgstr ""
"为了计算阴影贴图，从覆盖整个场景(或直到最大距离)的正交视点渲染场景(仅深度)。 "
"但是，这种方法存在问题，因为靠近相机的物体会接收到块状阴影。"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:91
msgid ""
"To fix this, a technique named \"Parallel Split Shadow Maps\" (or PSSM) is "
"used. This splits the view frustum in 2 or 4 areas. Each area gets its own "
"shadow map. This allows small areas close to the viewer to have the same "
"shadow resolution as a huge, far-away area."
msgstr ""
"为了解决这个问题，使用了名为“Parallel Split Shadow Maps”(或PSSM)的技术。 这将"
"视锥体分成2或4个区域。 每个区域都有自己的阴影贴图。 这允许靠近观察者的小区域"
"具有与巨大的遥远区域相同的阴影分辨率。"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:96
msgid "With this, shadows become more detailed:"
msgstr "有了它，阴影变得更加详细:"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:100
msgid "To control PSSM, a number of parameters are exposed:"
msgstr "为了控制PSSM，暴露了许多参数:"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:104
msgid ""
"Each split distance is controlled relative to the camera far (or shadow "
"**Max Distance** if greater than zero), so *0.0* is the eye position and "
"*1.0* is where the shadow ends at a distance. Splits are in-between. Default "
"values generally work well, but tweaking the first split a bit is common to "
"give more detail to close objects (like a character in a third person game)."
msgstr ""
"每个分割距离相对于相机远处控制(或阴影 **最大距离** ，如果大于零)，因此* 0.0 *"
"是眼睛位置，* 1.0 *是阴影在一定距离处结束的位置。 分裂介于两者之间。 默认值通"
"常效果很好，但调整第一个分割是很常见的，可以为关闭对象提供更多细节(比如第三人"
"称游戏中的角色)。"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:110
msgid ""
"Always make sure to set a shadow *Max Distance* according to what the scene "
"needs. A lower maximum distance will result in better-looking shadows."
msgstr "始终确保根据场景需要设置阴影 *最大距离* 。 距离越近，阴影的质量越高。"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:113
#, fuzzy
msgid ""
"Sometimes, the transition between a split and the next can look bad. To fix "
"this, the **\"Blend Splits\"** option can be turned on, which sacrifices "
"detail in exchange for smoother transitions:"
msgstr ""
"有时，分裂与下一个之间的过渡看起来很糟糕。 要解决此问题，可以打开**“Blend "
"Splits”**选项，牺牲细节以换取更平滑的过渡:"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:119
msgid ""
"The **\"Normal Bias\"** parameter can be used to fix special cases of self "
"shadowing when objects are perpendicular to the light. The only downside is "
"that it makes the shadow a bit thinner."
msgstr ""
"当“物体垂直于光线”时，**“Normal Bias”**参数可用于修复自阴影的特殊情况。 唯一"
"的缺点是它使阴影更薄。"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:125
msgid ""
"The **\"Bias Split Scale\"** parameter can control extra bias for the splits "
"that are far away. If self shadowing occurs only on the splits far away, "
"this value can fix them."
msgstr ""
"**“偏差分割比例”**参数可以控制远处分裂的额外偏差。 如果仅在远处的分割上发生自"
"阴影，则此值可以修复它们。"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:128
msgid "Finally, the **\"Depth Range\"** has two settings:"
msgstr "最后， **“深度范围”** 有两个设置:"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:130
msgid ""
"**Stable**: Keeps the shadow stable while the camera moves, and the blocks "
"that appear in the outline when close to the shadow edges remain in-place. "
"This is the default and generally desired, but it reduces the effective "
"shadow resolution."
msgstr ""
"**稳定**:在相机移动时保持阴影稳定，并且当靠近阴影边缘时出现在轮廓中的块保持原"
"位。 这是默认设置，通常需要，但会降低有效的阴影分辨率。"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:131
msgid ""
"**Optimized**: Tries to achieve the maximum resolution available at any "
"given time. This may result in a \"moving saw\" effect on shadow edges, but "
"at the same time the shadow looks more detailed (so this effect may be "
"subtle enough to be forgiven)."
msgstr ""
"**优化**:尝试在任何给定时间达到最大可用分辨率。 这可能会导致阴影边缘出现“移动"
"锯”效果，但同时阴影看起来更加细致(因此这种效果可能非常微妙，可以被原谅)。"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:133
msgid "Just experiment which setting works better for your scene."
msgstr "只是尝试哪种设置更适合您的场景。"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:135
msgid ""
"Shadowmap size for directional lights can be changed in Project Settings -> "
"Rendering -> Quality:"
msgstr "可以在项目设置 ->渲染 ->质量中更改方向灯的阴影贴图大小:"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:139
#, fuzzy
msgid ""
"Increasing it can solve bias problems, but decrease performance. Shadow "
"mapping is an art of tweaking."
msgstr "增加它可以解决偏差问题，但会降低性能。 阴影贴图是一种调整艺术。"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:142
msgid "Omni light"
msgstr "全方位的光"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:144
msgid ""
"Omni light is a point source that emits light spherically in all directions "
"up to a given radius."
msgstr "全光是一种点光源，可在所有方向上发射光，直至给定半径。"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:149
#, fuzzy
msgid ""
"In real life, light attenuation is an inverse function, which means omni "
"lights don't have a radius. This is a problem because it means computing "
"several omni lights would become demanding."
msgstr ""
"在现实生活中，光衰减是反函数，这意味着全向光没有半径。 这是一个问题，因为这意"
"味着计算几个全向灯会变得很苛刻。"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:152
msgid ""
"To solve this, a *Range* is introduced together with an attenuation function."
msgstr "为了解决这个问题，引入了* Range *和衰减功能。"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:156
msgid ""
"These two parameters allow tweaking how this works visually in order to find "
"aesthetically pleasing results."
msgstr "这两个参数允许在视觉上调整其工作方式，以便找到美学上令人愉悦的结果。"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:162
msgid "Omni shadow mapping"
msgstr "全方位阴影贴图"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:164
msgid ""
"Omni light shadow mapping is relatively straightforward. The main issue that "
"needs to be considered is the algorithm used to render it."
msgstr "全方位光影映射相对简单。 需要考虑的主要问题是用于渲染它的算法。"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:167
#, fuzzy
msgid ""
"Omni Shadows can be rendered as either **\"Dual Paraboloid\" or \"Cube Mapped"
"\"**. The former renders quickly, but can cause deformations, while the "
"later is more correct, but costlier."
msgstr ""
"Omni Shadows可以渲染为**“Dual Paraboloid”或“Cube Mapped”**。 前者渲染速度很快"
"但会导致变形，而后者更正确但成本更高。"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:173
msgid ""
"If the objects being rendered are mostly irregular, Dual Paraboloid is "
"usually enough. In any case, as these shadows are cached in a shadow atlas "
"(more on that at the end), it may not make a difference in performance for "
"most scenes."
msgstr ""
"如果渲染的对象大部分是不规则的，那么双抛物面通常就足够了。 在任何情况下，由于"
"这些阴影被缓存在阴影图集中(更多的是在结尾处)，因此对于大多数场景而言，它可能"
"不会对性能产生影响。"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:178
msgid "Spot light"
msgstr "聚光灯"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:180
msgid ""
"Spot lights are similar to omni lights, except they emit light only into a "
"cone (or \"cutoff\"). They are useful to simulate flashlights, car lights, "
"reflectors, spots, etc. This type of light is also attenuated towards the "
"opposite direction it points to."
msgstr ""
"聚光灯类似于全向灯，除了它们只发光到锥形(或“截止”)。 它们可用于模拟手电筒，汽"
"车灯，反射器，光点等。这种类型的光也会向其指向的相反方向衰减。"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:187
msgid ""
"Spot lights share the same **Range** and **Attenuation** as **OmniLight**, "
"and add two extra parameters:"
msgstr "聚光灯共用 **范围** 和 **衰减** 为** OmniLight **，并添加两个额外参数:"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:189
msgid "**Angle**: The aperture angle of the light"
msgstr "**角度**:光线的光圈角度"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:190
msgid ""
"**Angle Attenuation**: The cone attenuation, which helps soften the cone "
"borders."
msgstr "**角度衰减**:锥形衰减，有助于软化锥形边界。"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:193
msgid "Spot shadow mapping"
msgstr "现场阴影贴图"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:195
msgid ""
"Spots don't need any parameters for shadow mapping. Keep in mind that, at "
"more than 89 degrees of aperture, shadows stop functioning for spots, and "
"you should consider using an Omni light instead."
msgstr ""
"斑点不需要任何阴影映射参数。 请记住，在超过89度的光圈下，阴影会停止对斑点起作"
"用，您应该考虑使用Omni灯。"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:199
msgid "Shadow atlas"
msgstr "影子地图集"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:201
#, fuzzy
msgid ""
"Unlike Directional lights, which have their own shadow texture, Omni and "
"Spot lights are assigned to slots of a shadow atlas. This atlas can be "
"configured in Project Settings -> Rendering -> Quality -> Shadow Atlas."
msgstr ""
"与具有自己的阴影纹理的定向灯不同，Omni和Spot灯被分配到阴影图集的插槽。 可以在"
"项目设置 ->渲染 ->质量 ->阴影图集中配置此地图集。"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:206
#, fuzzy
msgid ""
"The resolution applies to the whole Shadow Atlas. This atlas is divided into "
"four quadrants:"
msgstr "该决议适用于整个影子地图集。 该地图集分为四个象限:"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:210
#, fuzzy
msgid ""
"Each quadrant can be subdivided to allocate any number of shadow maps; the "
"following is the default subdivision:"
msgstr "每个象限可以细分为分配任意数量的阴影贴图。 以下是默认细分:"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:214
msgid ""
"The allocation logic is simple. The biggest shadow map size (when no "
"subdivision is used) represents a light the size of the screen (or bigger). "
"Subdivisions (smaller maps) represent shadows for lights that are further "
"away from view and proportionally smaller."
msgstr ""
"分配逻辑很简单。 最大的阴影贴图大小(当不使用细分时)表示屏幕大小(或更大)的亮"
"度。 细分(较小的地图)表示远离视图并且比例较小的光的阴影。"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:219
#, fuzzy
msgid "Every frame, the following procedure is performed for all lights:"
msgstr "每一帧，所有灯光都完成以下逻辑:"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:221
msgid ""
"Check if the light is on a slot of the right size. If not, re-render it and "
"move it to a larger/smaller slot."
msgstr ""
"检查灯是否在正确大小的插槽上。 如果没有，重新渲染它并将其移动到更大/更小的插"
"槽。"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:222
msgid ""
"Check if any object affecting the shadow map has changed. If it did, re-"
"render the light."
msgstr "检查影响阴影贴图的任何对象是否已更改。 如果是的话，重新渲染光线。"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:223
msgid ""
"If neither of the above has happened, nothing is done, and the shadow is "
"left untouched."
msgstr "如果上述情况均未发生，则不执行任何操作，阴影保持不变。"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:225
#, fuzzy
msgid ""
"If the slots in a quadrant are full, lights are pushed back to smaller "
"slots, depending on size and distance."
msgstr "如果上述情况均未发生，则不执行任何操作，阴影保持不变。"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:227
#, fuzzy
msgid ""
"This allocation strategy works for most games, but you may want to use a "
"separate one in some cases (for example, a top-down game where all lights "
"are around the same size and quadrants may all have the same subdivision)."
msgstr ""
"此分配策略适用于大多数游戏，但在某些情况下您可能会使用单独的游戏(例如，自上而"
"下的游戏，其中所有灯光大小相同，四边形可能具有相同的细分)。"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:231
msgid "Shadow filter quality"
msgstr "阴影滤镜质量"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:233
msgid ""
"The filter quality of shadows can be tweaked. This can be found in Project "
"Settings -> Rendering -> Quality -> Shadows. Godot supports no filter, PCF5 "
"and PCF13."
msgstr ""
"可以调整阴影的滤镜质量。 这可以在项目设置 ->渲染 ->质量 ->阴影中找到。 Godot"
"不支持过滤器，PCF5和PCF13。"

#: ../../docs/tutorials/3d/lights_and_shadows.rst:239
msgid "It affects the blockyness of the shadow outline:"
msgstr "它会影响阴影轮廓的块状:"

#: ../../docs/tutorials/3d/reflection_probes.rst:4
msgid "Reflection probes"
msgstr "反射探针"

#: ../../docs/tutorials/3d/reflection_probes.rst:9
msgid ""
"As stated in the :ref:`doc_spatial_material`, objects can show reflected or "
"diffuse light. Reflection probes are used as a source of reflected and "
"ambient light for objects inside their area of influence."
msgstr ""
"如下所示 :ref:`doc_spatial_material` ，对象可以显示反射光或漫反射光。 反射探"
"头用作其影响区域内物体的反射光和环境光源。"

#: ../../docs/tutorials/3d/reflection_probes.rst:12
msgid ""
"A probe of this type captures the surroundings (as a sort of 360 degrees "
"image), and stores versions of it with increasing levels of *blur*. This is "
"used to simulate roughness in materials, as well as ambient lighting."
msgstr ""
"这种类型的探测器捕获周围环境(作为一种360度图像)，并以不断增加的* blur *水平存"
"储它的版本。 这用于模拟材质的粗糙度以及环境照明。"

#: ../../docs/tutorials/3d/reflection_probes.rst:15
#, fuzzy
msgid ""
"While these probes are an efficient way of storing reflections, they have a "
"few shortcomings:"
msgstr "虽然这些探针是存储反射的有效方法，但它们有一些缺点:"

#: ../../docs/tutorials/3d/reflection_probes.rst:17
#, fuzzy
msgid ""
"They are efficient to render, but expensive to compute. This leads to a "
"default behavior where they only capture on scene load."
msgstr ""
"它们渲染效率高，但计算成本高。 这会导致默认行为，它们仅在场景加载时捕获。"

#: ../../docs/tutorials/3d/reflection_probes.rst:18
msgid ""
"They work best for rectangular shaped rooms or places, otherwise the "
"reflections shown are not as faithful (especially when roughness is 0)."
msgstr "它们最适合矩形房间或地方，否则显示的反射不忠实(特别是当粗糙度为0时)。"

#: ../../docs/tutorials/3d/reflection_probes.rst:23
msgid ""
"Create a ReflectionProbe node and wrap it around the area where you want to "
"have reflections:"
msgstr "创建一个ReflectionProbe节点并将其包在您想要反射的区域周围:"

#: ../../docs/tutorials/3d/reflection_probes.rst:27
msgid ""
"This should result in immediate local reflections. If you are using a Sky "
"texture, reflections are by default blended with it."
msgstr ""
"这应该导致立即的局部反射。 如果您使用的是Sky纹理，则默认情况下会将反射与其混"
"合。"

#: ../../docs/tutorials/3d/reflection_probes.rst:30
#, fuzzy
msgid ""
"By default, on interiors, reflections may appear not to have much "
"consistence. In this scenario, make sure to tick the *\"Box Correct\"* "
"property."
msgstr ""
"默认情况下，在内部，反射似乎没有太多的一致性。 在这种情况下，请务必勾选*“Box "
"Correct”*属性。"

#: ../../docs/tutorials/3d/reflection_probes.rst:36
msgid ""
"This setting changes the reflection from an infinite skybox to reflecting a "
"box the size of the probe:"
msgstr "此设置将反射从无限天空盒更改为反映探测器大小的框:"

#: ../../docs/tutorials/3d/reflection_probes.rst:41
#, fuzzy
msgid ""
"Adjusting the box walls may help improve the reflection a bit, but it will "
"always look best in box shaped rooms."
msgstr "调整盒子的墙壁可能有助于改善反射，但它总是在箱形房间看起来最好。"

#: ../../docs/tutorials/3d/reflection_probes.rst:44
msgid ""
"The probe captures the surrounding from the center of the gizmo. If, for "
"some reason, the room shape or contents occlude the center, it can be "
"displaced to an empty place by moving the handles in the center:"
msgstr ""
"探头从Gizmo的中心捕获周围环境。 如果由于某种原因，房间的形状或内容遮挡了中"
"心，可以通过移动中心的把手将其移到空的地方:"

#: ../../docs/tutorials/3d/reflection_probes.rst:50
msgid ""
"By default, shadow mapping is disabled when rendering probes (only in the "
"rendered image inside the probe, not the actual scene). This is a simple way "
"to save on performance and memory. If you want shadows in the probe, they "
"can be toggled on/off with the *Enable Shadow* setting:"
msgstr ""
"默认情况下，渲染探针时仅禁用阴影贴图(仅在探针内的渲染图像中，而不是实际场景"
"中)。 这是节省性能和内存的简单方法。 如果您想在探头中使用阴影，可以使用* "
"Enable Shadow *设置打开/关闭它们:"

#: ../../docs/tutorials/3d/reflection_probes.rst:57
msgid ""
"Finally, keep in mind that you may not want the Reflection Probe to render "
"some objects. A typical scenario is an enemy inside the room which will move "
"around. To keep objects from being rendered in the reflections, use the "
"*Cull Mask* setting:"
msgstr ""
"最后，请记住，您可能不希望Reflection Probe渲染某些对象。 一个典型的场景是房间"
"内的敌人会四处移动。 要防止对象在反射中渲染，请使用 *Cull Mask* 设置:"

#: ../../docs/tutorials/3d/reflection_probes.rst:65
#: ../../docs/tutorials/3d/gi_probes.rst:84
msgid "Interior vs exterior"
msgstr "内部与外部"

#: ../../docs/tutorials/3d/reflection_probes.rst:67
#, fuzzy
msgid ""
"If you are using reflection probes in an interior setting, it is recommended "
"that the **Interior** property be enabled. This stops the probe from "
"rendering the sky and also allows custom ambient lighting settings."
msgstr ""
"如果在室内设置中使用反射探头，建议启用** Interior **属性。 这会使探针停止渲染"
"天空，并允许自定义环境光照设置。"

#: ../../docs/tutorials/3d/reflection_probes.rst:73
msgid ""
"When probes are set to **Interior**, custom constant ambient lighting can be "
"specified per probe. Just choose a color and an energy."
msgstr ""
"当探头设置为** Interior **时，可以为每个探头指定自定义恒定环境光。 只需选择颜"
"色和能量。"

#: ../../docs/tutorials/3d/reflection_probes.rst:76
#, fuzzy
msgid ""
"Optionally, you can blend this ambient light with the probe diffuse capture "
"by tweaking the **Ambient Contribution** property (0.0 means pure ambient "
"color, while 1.0 means pure diffuse capture)."
msgstr ""
"或者，您可以通过调整** Ambient Contribution **属性(0.0表示纯环境颜色，而1.0表"
"示纯漫反射捕获)将此环境光与探测器漫反射捕获混合。"

#: ../../docs/tutorials/3d/reflection_probes.rst:81
msgid "Blending"
msgstr "混纺"

#: ../../docs/tutorials/3d/reflection_probes.rst:83
msgid ""
"Multiple reflection probes can be used, and Godot will blend them where they "
"overlap using a smart algorithm:"
msgstr "可以使用多个反射探针，Godot会使用智能算法将它们混合在一起:"

#: ../../docs/tutorials/3d/reflection_probes.rst:87
#, fuzzy
msgid ""
"As you can see, this blending is never perfect (after all, these are box "
"reflections, not real reflections), but these artifacts are only visible "
"when using perfectly mirrored reflections. Normally, scenes have normal "
"mapping and varying levels of roughness, which can hide this."
msgstr ""
"正如您所看到的，这种混合从来都不是完美的(毕竟，这些是盒子反射，而不是真实的反"
"射)，但这些伪像只有在使用完美镜像反射时才可见。 通常情况下，场景具有正常的映"
"射和不同程度的粗糙度，这可以隐藏它。"

#: ../../docs/tutorials/3d/reflection_probes.rst:93
#, fuzzy
msgid ""
"Alternatively, Reflection Probes work well blended together with Screen "
"Space Reflections to solve these problems. Combining them makes local "
"reflections appear more faithful, while probes are only used as a fallback "
"when no screen-space information is found:"
msgstr ""
"另外，Reflection Probes与Screen Space Reflections很好地融合在一起，可以解决这"
"些问题。 将它们组合使得局部反射看起来更忠实，而探测器仅在没有找到屏幕空间信息"
"时用作后备:"

#: ../../docs/tutorials/3d/reflection_probes.rst:99
msgid ""
"Finally, blending interior and exterior probes is the recommended approach "
"when making levels that combine both interiors and exteriors. Near the door, "
"a probe can be marked as *exterior* (so it will get sky reflections) while "
"on the inside, it can be interior."
msgstr ""
"最后，在制作内部和外部结合的水平时，建议混合使用内部和外部探头。 在门附近，探"
"头可以标记为 *外部* (因此它将获得天空反射)，而在内部，它可以是内部。"

#: ../../docs/tutorials/3d/reflection_probes.rst:104
msgid "Reflection atlas"
msgstr "反思地图集"

#: ../../docs/tutorials/3d/reflection_probes.rst:106
msgid ""
"In the current renderer implementation, all probes are the same size and are "
"fit into a Reflection Atlas. The size and amount of probes can be customized "
"in Project Settings -> Quality -> Reflections"
msgstr ""
"在当前的渲染器实现中，所有探测器都具有相同的大小并且适合反射图集。 可以在项目"
"设置 ->质量 ->反射中自定义探针的大小和数量"

#: ../../docs/tutorials/3d/gi_probes.rst:4
msgid "GI Probes"
msgstr "GI探针"

#: ../../docs/tutorials/3d/gi_probes.rst:9
msgid ""
"Just like with :ref:`doc_reflection_probes`, and as stated in the :ref:"
"`doc_spatial_material`, objects can show reflected or diffuse light. GI "
"Probes are similar to Reflection Probes, but they use a different and more "
"complex technique to produce indirect light and reflections."
msgstr ""
"就像 :ref:`doc_reflection_probes`，并且如 :ref:`doc_spatial_material` 中所"
"述，对象可以显示反射光或漫反射光。 GI探针类似于反射探针，但它们使用不同且更复"
"杂的技术来产生间接光和反射。"

#: ../../docs/tutorials/3d/gi_probes.rst:14
msgid ""
"The strength of GI Probes is real-time, high quality, indirect light. While "
"the scene needs a quick pre-bake for the static objects that will be used, "
"lights can be added, changed or removed, and this will be updated in real-"
"time. Dynamic objects that move within one of these probes will also receive "
"indirect lighting from the scene automatically."
msgstr ""
"GI探针的强度是实时，高质量，间接光。 虽然场景需要对将要使用的静态对象进行快速"
"预烘焙，但可以添加，更改或删除灯光，并且这将实时更新。 在其中一个探针内移动的"
"动态对象也将自动从场景接收间接光照。"

#: ../../docs/tutorials/3d/gi_probes.rst:20
#, fuzzy
msgid ""
"Just like with ``ReflectionProbe``, ``GIProbe`` can be blended (in a bit "
"more limited way), so it is possible to provide full real-time lighting for "
"a stage without having to resort to lightmaps."
msgstr ""
"就像ReflectionProbe一样，GIProbe可以混合(以更有限的方式)，因此可以为舞台提供"
"完整的实时照明，而无需借助光照贴图。"

#: ../../docs/tutorials/3d/gi_probes.rst:24
#, fuzzy
msgid "The main downsides of ``GIProbe`` are:"
msgstr "GIProbe的主要缺点是:"

#: ../../docs/tutorials/3d/gi_probes.rst:26
msgid ""
"A small amount of light leaking can occur if the level is not carefully "
"designed. This must be artist-tweaked."
msgstr "如果没有仔细设计水平，可能会发生少量漏光。 这必须是艺术家调整的。"

#: ../../docs/tutorials/3d/gi_probes.rst:27
msgid ""
"Performance requirements are higher than for lightmaps, so it may not run "
"properly in low-end integrated GPUs (may need to reduce resolution)."
msgstr ""
"性能要求高于光照贴图，因此在低端集成GPU中可能无法正常运行(可能需要降低分辨"
"率)。"

#: ../../docs/tutorials/3d/gi_probes.rst:28
#, fuzzy
msgid ""
"Reflections are voxelized, so they don't look as sharp as with "
"``ReflectionProbe``. However, in exchange they are volumetric, so any room "
"size or shape works for them. Mixing them with Screen Space Reflection also "
"works well."
msgstr ""
"反射是体素化的，因此它们看起来不像ReflectionProbe那样清晰。 但是，作为交换，"
"它们是体积的，因此任何房间大小或形状都适用于它们。 将它们与屏幕空间反射混合也"
"很有效。"

#: ../../docs/tutorials/3d/gi_probes.rst:29
#, fuzzy
msgid ""
"They consume considerably more video memory than Reflection Probes, so they "
"must be used with care in the right subdivision sizes."
msgstr "它们比Reflection Probes消耗的视频内存要多得多，因此必须小心使用它们。"

#: ../../docs/tutorials/3d/gi_probes.rst:34
#, fuzzy
msgid ""
"Just like a ``ReflectionProbe``, simply set up the ``GIProbe`` by wrapping "
"it around the geometry that will be affected."
msgstr "就像ReflectionProbe一样，只需将GIProbe包在受影响的几何体周围即可。"

#: ../../docs/tutorials/3d/gi_probes.rst:39
#, fuzzy
msgid ""
"Afterwards, make sure to enable the geometry will be baked. This is "
"important in order for ``GIProbe`` to recognize objects, otherwise they will "
"be ignored:"
msgstr ""
"然后，确保启用几何体将被烘焙。 这对于GIPRobe识别对象很重要，否则它们将被忽略:"

#: ../../docs/tutorials/3d/gi_probes.rst:44
#, fuzzy
msgid ""
"Once the geometry is set up, push the Bake button that appears on the 3D "
"editor toolbar to begin the pre-baking process:"
msgstr "设置几何体后，按下3D编辑器工具栏上显示的“烘焙”按钮开始预烘焙过程:"

#: ../../docs/tutorials/3d/gi_probes.rst:50
msgid "Adding lights"
msgstr "添加灯光"

#: ../../docs/tutorials/3d/gi_probes.rst:52
#, fuzzy
msgid ""
"Unless there are materials with emission, ``GIProbe`` does nothing by "
"default. Lights need to be added to the scene to have an effect."
msgstr ""
"除非存在具有发射的材质，否则GIProbe默认不执行任何操作。 需要将灯光添加到场景"
"才能生效。"

#: ../../docs/tutorials/3d/gi_probes.rst:55
msgid ""
"The effect of indirect light can be viewed quickly (it is recommended you "
"turn off all ambient/sky lighting to tweak this, though, as shown below):"
msgstr ""
"可以快速查看间接光的效果(建议您关闭所有环境/天空照明以调整它，但如下所示):"

#: ../../docs/tutorials/3d/gi_probes.rst:60
msgid ""
"In some situations, though, indirect light may be too weak. Lights have an "
"indirect multiplier to tweak this:"
msgstr "但在某些情况下，间接光线可能太弱。 灯具有间接乘数来调整:"

#: ../../docs/tutorials/3d/gi_probes.rst:65
#, fuzzy
msgid ""
"And, as ``GIProbe`` lighting updates in real-time, this effect is immediate:"
msgstr "而且，随着GIPRobe照明实时更新，这种效果立竿见影:"

#: ../../docs/tutorials/3d/gi_probes.rst:70
msgid "Reflections"
msgstr "反射"

#: ../../docs/tutorials/3d/gi_probes.rst:72
#, fuzzy
msgid ""
"For very metallic materials with low roughness, it's possible to appreciate "
"voxel reflections. Keep in mind that these have far less detail than "
"Reflection Probes or Screen Space Reflections, but fully reflect "
"volumetrically."
msgstr ""
"对于具有高金属度和低粗糙度的材质，可以欣赏体素反射。 请记住，它们的细节远远少"
"于反射探测器或屏幕空间反射，但完全反映了体积。"

#: ../../docs/tutorials/3d/gi_probes.rst:78
#, fuzzy
msgid ""
"``GIProbe``\\ s can be easily mixed with Reflection Probes and Screen Space "
"Reflections, as a full 3-stage fallback-chain. This allows to have precise "
"reflections where needed:"
msgstr ""
"GIProbes可以轻松地与Reflection Probes和Screen Space Reflections混合使用，作为"
"一个完整的3阶段后备链。 这允许在需要时进行精确反射:"

#: ../../docs/tutorials/3d/gi_probes.rst:86
msgid ""
"GI Probes normally allow mixing with lighting from the sky. This can be "
"disabled when turning on the *Interior* setting."
msgstr ""
"GI探头通常允许与来自天空的照明混合。 打开* Interior *设置时可以禁用此功能。"

#: ../../docs/tutorials/3d/gi_probes.rst:91
msgid ""
"The difference becomes clear in the image below, where light from the sky "
"goes from spreading inside to being ignored."
msgstr "在下面的图像中，差异变得清晰，来自天空的光从内部传播到被忽略。"

#: ../../docs/tutorials/3d/gi_probes.rst:96
msgid ""
"As complex buildings may mix interiors with exteriors, combining GIProbes "
"for both parts works well."
msgstr ""
"由于复杂的建筑物可能将室内和室外混合在一起，因此将两个部件的GIProbes结合起来"
"非常有效。"

#: ../../docs/tutorials/3d/gi_probes.rst:100
msgid "Tweaking"
msgstr "扭捏"

#: ../../docs/tutorials/3d/gi_probes.rst:102
msgid "GI Probes support a few parameters for tweaking:"
msgstr "GI探针支持一些调整参数:"

#: ../../docs/tutorials/3d/gi_probes.rst:106
#, fuzzy
msgid ""
"**Subdiv** Subdivision used for the probe. The default (128) is generally "
"good for small- to medium-sized areas. Bigger subdivisions use more memory."
msgstr ""
"** Subdiv **用于探测的细分。 默认值(128)通常适用于中小大小区域。 较大的细分使"
"用更多的内存。"

#: ../../docs/tutorials/3d/gi_probes.rst:107
msgid "**Extents** Size of the probe. Can be tweaked from the gizmo."
msgstr "**范围**探头大小。 可以从Gizmo调整。"

#: ../../docs/tutorials/3d/gi_probes.rst:108
msgid ""
"**Dynamic Range** Maximum light energy the probe can absorb. Higher values "
"allow brighter light, but with less color detail."
msgstr ""
"**动态范围**探头可以吸收的最大光能。 值越高，光线越亮，但颜色细节越少。"

#: ../../docs/tutorials/3d/gi_probes.rst:109
msgid ""
"**Energy** Multiplier for all the probe. Can be used to make the indirect "
"light brighter (although it's better to tweak this from the light itself)."
msgstr ""
"**能量**所有探头的倍增器。 可用于使间接光更亮(尽管最好从灯本身调整它)。"

#: ../../docs/tutorials/3d/gi_probes.rst:110
msgid "**Propagation** How much light propagates through the probe internally."
msgstr "**传播**内部有多少光通过探头传播。"

#: ../../docs/tutorials/3d/gi_probes.rst:111
msgid ""
"**Bias** Value used to avoid self-occlusion when doing voxel cone tracing, "
"should generally be above 1.0 (1==voxel size)."
msgstr ""
"**偏差**用于避免在进行体素锥体追踪时自我遮挡的值，通常应高于1.0(1 ==体素大"
"小)。"

#: ../../docs/tutorials/3d/gi_probes.rst:112
msgid ""
"**Normal Bias** Alternative type of bias useful for some scenes. Experiment "
"with this one if regular bias does not work."
msgstr ""
"**普通偏差**对某些场景有用的替代偏见类型。 如果常规偏差不起作用，请尝试使用此"
"方法。"

#: ../../docs/tutorials/3d/gi_probes.rst:115
msgid "Quality"
msgstr "质量"

#: ../../docs/tutorials/3d/gi_probes.rst:117
#, fuzzy
msgid ""
"``GIProbe``\\ s are quite demanding. It is possible to use lower quality "
"voxel cone tracing in exchange for more performance."
msgstr "GIProbes相当苛刻。 可以使用较低质量的体素锥跟踪来交换更多性能。"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:4
msgid "Baked lightmaps"
msgstr "烘焙光照贴图"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:9
#, fuzzy
msgid ""
"Baked lightmaps are an alternative workflow for adding indirect (or baked) "
"lighting to a scene. Unlike the :ref:`doc_gi_probes` approach, baked "
"lightmaps work fine on low-end PCs and mobile devices, as they consume "
"almost no resources at run-time."
msgstr ""
"烘焙光照贴图是用于向场景添加间接(或烘焙)光照的替代工作流程。 与 :ref:"
"`doc_gi_probes` 方法不同，烘焙光照贴图在低端PC和移动设备上运行良好，因为它们"
"在运行时几乎不消耗任何资源。"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:14
#, fuzzy
msgid ""
"Unlike ``GIProbe``\\ s, Baked Lightmaps are completely static. Once baked, "
"they can't be modified at all. They also don't provide the scene with "
"reflections, so using :ref:`doc_reflection_probes` together with it on "
"interiors (or using a Sky on exteriors) is a requirement to get good quality."
msgstr ""
"与GIProbes不同，Baked Lightmaps是完全静态的。 一旦烘焙，它们根本无法修改。 他"
"们也没有为场景提供反射，因此在内部使用 :ref:`doc_reflection_probes` (或在外部"
"使用Sky)是获得高质量的要求。"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:19
#, fuzzy
msgid ""
"As they are baked, they have fewer problems than ``GIProbe`` regarding light "
"bleeding, and indirect light can look better if using Raytrace mode on high "
"quality setting (but baking can take a while)."
msgstr ""
"当它们被烘焙时，它们对于光出血的问题比GIProbe少，并且如果在高质量设置上使用光"
"线跟踪模式，间接光看起来会更好(但烘焙可能需要一段时间)。"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:23
#, fuzzy
msgid ""
"In the end, deciding which indirect lighting approach is better depends on "
"your use case. In general, GIProbe looks better and is much easier to set "
"up. For mobile or low-end compatibility, though, Baked Lightmaps are your "
"only choice."
msgstr ""
"最后，决定哪种间接照明方法更好取决于您的使用案例。 一般来说，GIProbe看起来更"
"好，更容易设置。 但是，对于低端兼容性或移动设备，Baked Lightmaps是您唯一的选"
"择。"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:29
msgid "Visual comparison"
msgstr "视觉比较"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:31
#, fuzzy
msgid ""
"Here are some comparisons of how Baked Lightmaps vs. GIProbe look. Notice "
"that lightmaps are more accurate, but also suffer from the fact that "
"lighting is on an unwrapped texture, so transitions and resolution may not "
"be that good. GIProbe looks less accurate (as it's an approximation), but "
"smoother overall."
msgstr ""
"以下是Baked Lightmaps与GIProbe外观的比较。 请注意，光照贴图更准确，但也受到照"
"明在未打开的纹理上的影响，因此过渡和分辨率可能不那么好。 GIProbe看起来不太准"
"确(因为它是近似值)，但总体上更加平滑。"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:42
msgid ""
"First of all, before the lightmapper can do anything, the objects to be "
"baked need an UV2 layer and a texture size. An UV2 layer is a set of "
"secondary texture coordinates that ensures any face in the object has its "
"own place in the UV map. Faces must not share pixels in the texture."
msgstr ""
"首先，在光照贴图可以执行任何操作之前，要烘焙的对象需要UV2图层和纹理大小。 UV2"
"图层是一组辅助纹理坐标，可确保对象中的任何面在UV贴图中都有自己的位置。 面不得"
"共享纹理中的像素。"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:47
#, fuzzy
msgid ""
"There are a few ways to ensure your object has a unique UV2 layer and "
"texture size:"
msgstr "有几种方法可以确保您的对象具有唯一的UV2图层和纹理大小"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:50
msgid "Unwrap from your 3D DCC"
msgstr "从3D DCC展开"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:52
msgid ""
"One option is to do it from your favorite 3D app. This approach is generally "
"not recommended, but it's explained first so that you know it exists. The "
"main advantage is that, on complex objects that you may want to re-import a "
"lot, the texture generation process can be quite costly within Godot, so "
"having it unwrapped before import can be faster."
msgstr ""
"一种选择是从您最喜欢的3D应用程序中进行。 通常不推荐这种方法，但首先要解释它，"
"以便您知道它存在。 主要的优点是，在您可能想要重新导入很多的复杂对象上，纹理生"
"成过程在Godot中可能非常昂贵，因此在导入之前将其解包可以更快。"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:58
msgid "Simply do an unwrap on the second UV2 layer."
msgstr "只需在第二个UV2层上打开包装即可。"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:62
msgid ""
"And import normally. Remember you will need to set the texture size on the "
"mesh after import."
msgstr "并正常导入。 请记住，导入后需要在网格上设置纹理大小。"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:67
#, fuzzy
msgid ""
"If you use external meshes on import, the size will be kept. Be wary that "
"most unwrappers in 3D DCCs are not quality oriented, as they are meant to "
"work quickly. You will mostly need to use seams or other techniques to "
"create better unwrapping."
msgstr ""
"如果在导入时使用外部网格，则将保留大小。 请注意，3D DCC中的大多数解包器都不是"
"面向质量的，因为它们可以快速工作。 您通常需要使用接缝或其他技术来创建更好的展"
"开。"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:73
msgid "Unwrap from within Godot"
msgstr "从Godot内部解开"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:75
msgid ""
"Godot has an option to unwrap meshes and visualize the UV channels. It can "
"be found in the Mesh menu:"
msgstr "Godot可以选择打开网格并可视化UV通道。 它可以在Mesh菜单中找到:"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:80
msgid ""
"This will generate a second set of UV2 coordinates which can be used for "
"baking, and it will also set the texture size automatically."
msgstr "这将生成第二组UV2坐标，可用于烘焙，并且还将自动设置纹理大小。"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:84
msgid "Unwrap on scene import"
msgstr "解开场景导入"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:86
#, fuzzy
msgid ""
"This is probably the best approach overall. The only downside is that, on "
"large models, unwrapping can take a while on import. Just select the "
"imported scene in the filesystem dock, then go to the Import tab. There, the "
"following option can be modified:"
msgstr ""
"这可能是整体上最好的方法。 唯一的缺点是，在大型模型上，解包可能需要一段时间才"
"能导入。 只需在文件系统面板中选择导入的场景，然后转到“导入”选项卡。 在那里，"
"可以修改以下选项:"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:93
msgid ""
"The **Light Baking** mode needs to be set to **\"Gen Lightmaps\"**. A texel "
"size in world units must also be provided, as this will determine the final "
"size of the lightmap texture (and, in consequence, the UV padding in the "
"map)."
msgstr ""
"** Light Baking **模式需要设置为**“Gen Lightmaps”**。 还必须提供世界单位的纹"
"素大小，因为这将确定光照贴图纹理的最终大小(并因此确定地图中的UV填充)。"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:97
msgid ""
"The effect of setting this option is that all meshes within the scene will "
"have their UV2 maps properly generated."
msgstr "设置此选项的效果是场景中的所有网格都将正确生成其UV2贴图。"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:100
msgid ""
"As a word of warning: When reusing a mesh within a scene, keep in mind that "
"UVs will be generated for the first instance found. If the mesh is re-used "
"with different scales (and the scales are wildly different, more than half "
"or twice), this will result in inefficient lightmaps. Just don't reuse a "
"source mesh at different scales if you are planning to use lightmapping."
msgstr ""
"作为警告:当重用场景中的网格时，请记住将为找到的第一个实例生成UV。 如果网格重"
"复使用不同的比例(并且比例大不相同，超过一半或两次)，这将导致低效的光照贴图。 "
"如果您计划使用光照贴图，请不要在不同比例下重复使用源网格。"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:107
msgid "Checking UV2"
msgstr "检查UV2"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:109
msgid ""
"In the mesh menu mentioned before, the UV2 texture coordinates can be "
"visualized. Make sure, if something is failing, to check that the meshes "
"have these UV2 coordinates:"
msgstr ""
"在前面提到的网格菜单中，可以显示UV2纹理坐标。 如果出现问题，请确保检查网格是"
"否具有以下UV2坐标:"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:115
msgid "Setting up the scene"
msgstr "设置场景"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:117
#, fuzzy
msgid ""
"Before anything is done, a **BakedLightmap** Node needs to be added to a "
"scene. This will enable light baking on all nodes (and sub-nodes) in that "
"scene, even on instanced scenes."
msgstr ""
"在做任何事情之前，需要将** BakedLight **节点添加到场景中。 这将在该场景中的所"
"有节点(和子节点)上进行灯光烘焙，即使在实例化场景中也是如此。"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:123
msgid ""
"A sub-scene can be instanced several times, as this is supported by the "
"baker, and each will be assigned a lightmap of its own (just make sure to "
"respect the rule about scaling mentioned before):"
msgstr ""
"子场景可以多次实例化，因为这是由面包师支持的，并且每个子场景都将被分配一个自"
"己的光照贴图(只需确保遵守前面提到的缩放规则):"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:128
msgid "Configure bounds"
msgstr "配置边界"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:130
#, fuzzy
msgid ""
"Lightmap needs an approximate volume of the area affected because it uses it "
"to transfer light to dynamic objects inside it (more on that later). Just "
"cover the scene with the volume as you do with ``GIProbe``:"
msgstr ""
"光照贴图需要受影响区域的近似体积，因为它使用它将光线传输到内部的动态对象(稍后"
"会详细介绍)。 只需像使用GIProbe一样用音量覆盖场景:"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:137
msgid "Setting up meshes"
msgstr "设置网格"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:139
msgid ""
"For a **MeshInstance** node to take part in the baking process, it needs to "
"have the \"Use in Baked Light\" property enabled."
msgstr "要使** MeshInstance **节点参与烘焙过程，需要启用“在烘焙灯中使用”属性。"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:144
msgid ""
"When auto-generating lightmaps on scene import, this is enabled "
"automatically."
msgstr "在场景导入时自动生成光照贴图时，会自动启用此功能。"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:147
msgid "Setting up lights"
msgstr "设置灯"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:149
msgid ""
"Lights are baked with indirect light by default. This means that "
"shadowmapping and lighting are still dynamic and affect moving objects, but "
"light bounces from that light will be baked."
msgstr ""
"默认情况下，灯光采用间接灯光烘焙。 这意味着阴影贴图和光照仍然是动态的并影响移"
"动的物体，但是光线反射的光将被烘焙。"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:153
msgid ""
"Lights can be disabled (no bake) or be fully baked (direct and indirect). "
"This can be controlled from the **Bake Mode** menu in lights:"
msgstr ""
"灯可以禁用(不烘焙)或完全烘焙(直接和间接)。 这可以通过灯光中的 **烘焙模式** 菜"
"单进行控制:"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:158
msgid "The modes are:"
msgstr "模式是:"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:160
msgid ""
"**Disabled:** Light is ignored in baking. Keep in mind hiding a light will "
"have no effect for baking, so this must be used instead."
msgstr ""
"**禁用:** 烘焙时忽略灯光。 请记住隐藏灯光对烘焙没有影响，因此必须使用此灯泡。"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:161
msgid ""
"**Indirect:** This is the default mode. Only indirect lighting will be baked."
msgstr "**间接:** 这是默认模式。 只会间接照明。"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:162
msgid ""
"**All:** Both indirect and direct lighting will be baked. If you don't want "
"the light to appear twice (dynamically and statically), simply hide it."
msgstr ""
"**全部:** 间接和直接照明都将被烘焙。 如果您不希望灯光出现两次(动态和静态)，只"
"需将其隐藏即可。"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:165
msgid "Baking quality"
msgstr "烘焙质量"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:167
#, fuzzy
msgid ""
"``BakedLightmap`` uses, for simplicity, a voxelized version of the scene to "
"compute lighting. Voxel size can be adjusted with the **Bake Subdiv** "
"parameter. More subdivision results in more detail, but also takes more time "
"to bake."
msgstr ""
"为简单起见，BakedLightmap使用场景的体素化版本来计算光照。 可以使用** Bake "
"Subdiv **参数调整体素大小。 更多细分会产生更多细节，但也需要更多时间来烘焙。"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:171
#, fuzzy
msgid ""
"In general, the defaults are good enough. There is also a **Capture "
"Subdivision** (that must always be equal to or less than the main "
"subdivision), which is used for capturing light in dynamic objects (more on "
"that later). Its default value is also good enough for most cases."
msgstr ""
"通常，默认值足够好。 还有一个** Capture Subdivision **(必须始终等于或小于主细"
"分)，用于捕捉动态对象中的光(稍后会详细介绍)。 对于更多情况，它的默认值也足够"
"好。"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:178
msgid ""
"Besides the capture size, quality can be modified by setting the **Bake "
"Mode**. Two modes of capturing indirect are provided:"
msgstr ""
"除捕获大小外，还可以通过设置 **烘焙模式** 来修改质量。 提供了两种间接捕获模"
"式:"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:183
#, fuzzy
msgid ""
"**Voxel Cone**: Trace: Is the default one; it's less precise, but faster. "
"Looks similar to (but slightly better than) ``GIProbe``."
msgstr ""
"** Voxel Cone**: 跟踪:是默认值，它不太精确但速度更快。 看起来与GIProbe相似(但"
"稍微好一点)。"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:184
#, fuzzy
msgid ""
"**Ray Tracing**: This method is more precise, but can take considerably "
"longer to bake. If used in low or medium quality, some scenes may produce "
"grain."
msgstr ""
"**光线追踪**:这种方法更精确，但烘焙时间可能要长得多。 如果以低质量或中等质量"
"使用，某些场景可能会产生谷物。"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:187
msgid "Baking"
msgstr "烘焙"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:189
#, fuzzy
msgid ""
"To begin the bake process, just push the big **Bake Lightmaps** button on "
"top when selecting the ``BakedLightmap`` node:"
msgstr ""
"要开始烘焙过程，只需在选择BakedLightmap节点时按下顶部的大** Bake Lightmaps **"
"按钮:"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:194
msgid ""
"This can take from seconds to minutes (or hours) depending on scene size, "
"bake method and quality selected."
msgstr ""
"这可能需要几秒到几分钟(或几小时)，具体取决于场景大小，烘焙方法和所选质量。"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:198
msgid "Configuring bake"
msgstr "配置烘焙"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:200
msgid "Several more options are present for baking:"
msgstr "烘焙还有几种选择:"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:202
#, fuzzy
msgid ""
"**Bake Subdiv**: The Godot lightmapper uses a grid to transfer light "
"information around; the default value is fine and should work for most "
"cases. Increase it in case you want better lighting on small details or your "
"scene is large."
msgstr ""
"** Bake Subdiv**: Godot lightmapper使用网格传输光信息。 默认值很好，适用于大"
"多数情况。 增加它，以防您希望更好地照亮小细节或您的场景很大。"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:203
msgid ""
"**Capture Subdiv**: This is the grid used for real-time capture information "
"(lighting dynamic objects). Default value is generally OK, it's usually "
"smaller than Bake Subdiv and can't be larger than it."
msgstr ""
"** Capture Subdiv**: 这是用于实时捕获信息的网格(照明动态对象)。 默认值通常是"
"OK，它通常小于Bake Subdiv并且不能大于它。"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:204
msgid ""
"**Bake Quality**: Three bake quality modes are provided, Low, Medium and "
"High. Higher quality takes more time."
msgstr ""
"**烘焙质量**:提供三种烘焙质量模式，低，中和高。 更高的质量需要更多的时间。"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:205
#, fuzzy
msgid ""
"**Bake Mode**: The baker can use two different techniques: *Voxel Cone "
"Tracing* (fast, but approximate), or *RayTracing* (slow, but accurate)."
msgstr ""
"**烘焙模式**:面包师可以使用两种不同的技术:* Voxel Cone Tracing *(快速但近"
"似)，或* RayTracing *(慢但准确)。"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:206
#, fuzzy
msgid ""
"**Propagation**: Used for the *Voxel Cone Trace* mode. Works just like in "
"``GIProbe``."
msgstr "**传播**:用于* Voxel Cone Trace *模式。 就像在GIProbe中一样工作。"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:207
#, fuzzy
msgid ""
"**HDR**: If disabled, lightmaps are smaller, but can't capture any light "
"over white (1.0)."
msgstr "** HDR**: 如果禁用，则光照贴图较小但无法捕捉白光(1.0)。"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:208
msgid ""
"**Image Path**: Where lightmaps will be saved. By default, on the same "
"directory as the scene (\".\"), but can be tweaked."
msgstr ""
"**图像路径**:将保存光照贴图的位置。 默认情况下，在与场景相同的目录(“。”)上，"
"但可以进行调整。"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:209
msgid "**Extents**: Size of the area affected (can be edited visually)"
msgstr "**范围**:受影响区域的大小(可以直观地编辑)"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:210
#, fuzzy
msgid ""
"**Light Data**: Contains the light baked data after baking. Textures are "
"saved to disk, but this also contains the capture data for dynamic objects, "
"which can be a bit heavy. If you are using .tscn formats (instead of .scn), "
"you can save it to disk."
msgstr ""
"**光数据**:烘焙后包含光烘焙数据。 纹理保存到磁盘，但这也包含动态对象的捕获数"
"据，这些数据可能有点重。 如果您使用.tscn格式(而不是.scn)，则可以将其保存到磁"
"盘。"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:213
msgid "Dynamic objects"
msgstr "动态对象"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:215
msgid ""
"In other engines or lightmapper implementations, you are required to "
"manually place small objects called \"lightprobes\" all around the level to "
"generate *capture* data. This is used to, then, transfer the light to "
"dynamic objects that move around the scene."
msgstr ""
"在其他引擎或lightmapper实现中，您需要手动在该级别周围放置称为“lightprobes”的"
"小对象以生成* capture *数据。 然后，这用于将光传输到在场景中移动的动态对象。"

#: ../../docs/tutorials/3d/baked_lightmaps.rst:220
msgid ""
"However, this implementation of lightmapping uses a different method. The "
"process is automatic, so you don't have to do anything. Just move your "
"objects around, and they will be lit accordingly. Of course, you have to "
"make sure you set up your scene bounds accordingly or it won't work."
msgstr ""
"但是，这种光照贴图的实现使用了不同的方法。 这个过程是自动的，所以您不必做任何"
"事情。 只需移动物体，它们就会相应点亮。 当然，您必须确保相应地设置场景边界，"
"否则它将无法工作。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:4
msgid "Environment and post-processing"
msgstr "环境和后处理"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:6
msgid ""
"Godot 3 provides a redesigned Environment resource, as well as a brand new "
"post-processing system with many available effects right out of the box."
msgstr ""
"Godot 3提供了重新设计的环境资源，以及一个全新的后期处理系统，其开箱即用，具有"
"许多可用的效果。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:12
msgid ""
"The Environment resource stores all the information required for controlling "
"rendering environment. This includes sky, ambient lighting, tone mapping, "
"effects, and adjustments. By itself it does nothing, but it becomes enabled "
"once used in one of the following locations in order of priority:"
msgstr ""
"Environment资源存储控制渲染环境所需的所有信息。 这包括天空，环境照明，色调映"
"射，效果和调整。 它本身什么都不做，但是一旦在以下位置之一中按优先级顺序使用它"
"就会启用:"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:18
msgid "Camera node"
msgstr "摄像机节点"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:20
msgid ""
"An Environment can be set to a camera. It will have priority over any other "
"setting."
msgstr "环境可以设置为相机。 它将优先于任何其他设置。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:24
msgid ""
"This is mostly useful when wanting to override an existing environment, but "
"in general it's a better idea to use the option below."
msgstr "这在想要覆盖现有环境时非常有用，但通常使用下面的选项更好。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:28
msgid "WorldEnvironment node"
msgstr "世界环境节点"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:30
msgid ""
"The WorldEnvironment node can be added to any scene, but only one can exist "
"per active scene tree. Adding more than one will result in a warning."
msgstr ""
"WorldEnvironment节点可以添加到任何场景，但每个活动场景树只能存在一个。 添加多"
"个将导致警告。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:35
msgid ""
"Any Environment added has higher priority than the default Environment "
"(explained below). This means it can be overridden on a per-scene basis, "
"which makes it quite useful."
msgstr ""
"添加的任何环境都具有比默认环境更高的优先级(如下所述)。 这意味着它可以在每个场"
"景的基础上被覆盖，这使它非常有用。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:42
msgid ""
"A default environment can be set, which acts as a fallback when no "
"Environment was set to a Camera or WorldEnvironment. Just head to Project "
"Settings -> Rendering -> Environment:"
msgstr ""
"可以设置默认环境，当没有将环境设置为Camera或WorldEnvironment时，该环境可用作"
"后备环境。 只需前往项目设置 ->渲染 ->环境:"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:48
msgid ""
"New projects created from the Project Manager come with a default "
"environment (``default_env.tres``). If one needs to be created, save it to "
"disk before referencing it here."
msgstr ""
"从项目管理器创建的新项目带有默认环境(``default_env.tres``)。 如果需要创建一"
"个，请将其保存到磁盘，然后再在此处引用它。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:53
msgid "Environment options"
msgstr "环境可选项"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:55
msgid ""
"Following is a detailed description of all environment options and how they "
"are intended to be used."
msgstr "以下是所有环境选项的详细说明以及如何使用它们。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:61
#, fuzzy
msgid ""
"The Background section contains settings on how to fill the background "
"(parts of the screen where objects were not drawn). In Godot 3.0, the "
"background not only serves the purpose of displaying an image or color, it "
"can also change how objects are affected by ambient and reflected light."
msgstr ""
"“背景”部分包含有关如何填充背景的设置(屏幕中未绘制对象的部分)。 在Godot 3.0"
"中，背景不仅用于显示图像或颜色，还可以改变物体受环境光和反射光影响的方式。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:68
msgid "There are many ways to set the background:"
msgstr "设置背景的方法有很多种:"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:70
msgid ""
"**Clear Color** uses the default clear color defined by the project. The "
"background will be a constant color."
msgstr "** Clear Color **使用项目定义的默认清晰颜色。 背景将是恒定的颜色。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:71
#, fuzzy
msgid "**Custom Color** is like Clear Color, but with a custom color value."
msgstr "**自定义颜色**与“清除颜色”类似，但具有自定义颜色值。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:72
msgid ""
"**Sky** lets you define a panorama sky (a 360 degree sphere texture) or a "
"procedural sky (a simple sky featuring a gradient and an optional sun). "
"Objects will reflect it and absorb ambient light from it."
msgstr ""
"** Sky **可让您定义全景天空(360度球体纹理)或程序天空(具有渐变和可选太阳的简单"
"天空)。 物体将反射它并从中吸收环境光。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:73
#, fuzzy
msgid ""
"**Color+Sky** lets you define a sky (as above), but uses a constant color "
"value for drawing the background. The sky will only be used for reflection "
"and ambient light."
msgstr ""
"** Color + Sky **可让您定义天空(如上所示)，但使用恒定颜色值绘制背景。 天空仅"
"用于反射和环境光。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:76
msgid "Ambient Light"
msgstr "环境光"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:78
msgid ""
"Ambient (as defined here) is a type of light that affects every piece of "
"geometry with the same intensity. It is global and independent of lights "
"that might be added to the scene."
msgstr ""
"环境(如此处定义)是一种光，它影响具有相同强度的每个几何体。 它是全局的，独立于"
"可能添加到场景中的灯光。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:82
msgid ""
"There are two types of ambient light: the *Ambient Color* (which is a "
"constant color multiplied by the material albedo) and then one obtained from "
"the *Sky* (as described before, but a sky needs to be set as background for "
"this to be enabled)."
msgstr ""
"有两种类型的环境光: *环境色* (恒定颜色乘以材质反照率)，然后从 *天空* 获得一个"
"(如前所述，但天空需要设置为背景) 启用)。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:89
#, fuzzy
msgid ""
"When a *Sky* is set as background, it's possible to blend between ambient "
"color and sky using the **Sky Contribution** setting (this value is 1.0 by "
"default for convenience, so only the sky affects objects)."
msgstr ""
"当* Sky *设置为背景时，可以使用** Sky Contribution **设置在环境颜色和天空之间"
"进行混合(为方便起见，此值默认为1.0，因此只有天空会影响对象)。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:93
msgid "Here is a comparison of how different ambient light affects a scene:"
msgstr "以下是不同环境光对场景的影响比较:"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:97
#, fuzzy
msgid ""
"Finally there is an **Energy** setting, which is a multiplier, useful when "
"working with HDR."
msgstr "最后有一个** Energy **设置，这是一个乘数，在使用HDR时非常有用。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:99
#, fuzzy
msgid ""
"In general, ambient light should only be used for simple scenes, large "
"exteriors, or for performance reasons (ambient light is cheap), as it does "
"not provide the best lighting quality. It's better to generate ambient light "
"from ReflectionProbe or GIProbe, which will more faithfully simulate how "
"indirect light propagates. Below is a comparison, in terms of quality, "
"between using a flat ambient color and a GIProbe:"
msgstr ""
"通常，环境光应该仅用于简单的场景，大的外部或出于性能原因(环境光很便宜)，因为"
"它不能提供最佳的照明质量。 最好从ReflectionProbe或GIProbe生成环境光，这将更加"
"忠实地模拟间接光传播的方式。 以下是使用平坦环境色和GIProbe之间的质量比较:"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:108
msgid ""
"Using one of the methods described above, objects get constant ambient "
"lighting replaced by ambient light from the probes."
msgstr "使用上述方法之一，物体获得恒定的环境照明，由来自探头的环境光代替。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:112
#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:87
msgid "Fog"
msgstr "雾"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:114
msgid ""
"Fog, as in real life, makes distant objects fade away into an uniform color. "
"The physical effect is actually pretty complex, but Godot provides a good "
"approximation. There are two kinds of fog in Godot:"
msgstr ""
"雾，就像在现实生活中一样，使远处的物体逐渐消失成均匀的颜色。 物理效果实际上非"
"常复杂，但Godot提供了一个很好的近似。 Godot有两种雾:"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:118
msgid ""
"**Depth Fog:** This one is applied based on the distance from the camera."
msgstr "**深度雾:** 这个基于距相机的距离来应用。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:119
msgid ""
"**Height Fog:** This one is applied to any objects below (or above) a "
"certain height, regardless of the distance from the camera."
msgstr ""
"**高度雾:** 此高度应用于任何低于(或高于)某个高度的物体，无论距离相机的距离如"
"何。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:123
msgid ""
"Both of these fog types can have their curve tweaked, making their "
"transition more or less sharp."
msgstr "这两种雾类型都可以调整它们的曲线，使它们的过渡或多或少变得清晰。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:125
msgid "Two properties can be tweaked to make the fog effect more interesting:"
msgstr "可以调整两个属性以使雾效果更有趣:"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:127
msgid ""
"The first is **Sun Amount**, which makes use of the Sun Color property of "
"the fog. When looking towards a directional light (usually a sun), the color "
"of the fog will be changed, simulating the sunlight passing through the fog."
msgstr ""
"第一个是 **太阳量** ，它利用雾的太阳颜色属性。 当朝向定向光(通常是太阳)时，雾"
"的颜色将会改变，模拟穿过雾的阳光。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:131
msgid ""
"The second is **Transmit Enabled** which simulates more realistic light "
"transmittance. In practice, it makes light stand out more across the fog."
msgstr ""
"第二个是** Transmit Enabled **，模拟更逼真的透光率。 在实践中，它使光线在雾中"
"更加突出。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:137
msgid "Tonemap"
msgstr "品质图"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:139
msgid ""
"Selects the tone-mapping curve that will be applied to the scene, from a "
"short list of standard curves used in the film and game industry. Tone "
"mapping can make light and dark areas more homogeneous, even though the "
"result is not that strong. Tone mapping options are:"
msgstr ""
"从电影和游戏行业中使用的标准曲线的简短列表中选择将应用于场景的色调映射曲线。 "
"色调映射可以使亮区和暗区更均匀，即使结果不那么强。 色调映射选项包括:"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:144
msgid ""
"**Mode:** Tone mapping mode, which can be Linear, Reindhart, Filmic, or Aces."
msgstr "**模式:** 色调映射模式，可以是线性，Reindhart，Filmic或Aces。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:145
msgid ""
"**Exposure:** Tone mapping exposure which simulates amount of light received "
"over time."
msgstr "**曝光:** 色调映射曝光，模拟随时间接收的光量。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:146
#, fuzzy
msgid ""
"**White:** Tone mapping white, which simulates where in the scale white is "
"located (by default 1.0)."
msgstr "**白色:** 色调映射白色，模拟刻度中白色所在的位置(默认为1.0)。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:149
msgid "Auto Exposure (HDR)"
msgstr "自动曝光(HDR)"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:151
msgid ""
"Even though, in most cases, lighting and texturing are heavily artist "
"controlled, Godot supports a simple high dynamic range implementation with "
"the auto exposure mechanism. This is generally used for the sake of realism "
"when combining interior areas with low light and outdoors. Auto exposure "
"simulates the camera (or eye) in an effort to adapt between light and dark "
"locations and their different amounts of light."
msgstr ""
"尽管在大多数情况下，照明和纹理都受到艺术家的严格控制，但Godot通过自动曝光机制"
"支持简单的高动态范围实现。 当将内部区域与低光和户外相结合时，这通常用于真实"
"性。 自动曝光模拟相机(或眼睛)，以适应明暗位置和不同光量。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:160
#, fuzzy
msgid ""
"The simplest way to use auto exposure is to make sure outdoor lights (or "
"other strong lights) have energy beyond 1.0. This is done by tweaking their "
"**Energy** multiplier (on the Light itself). To make it consistent, the "
"**Sky** usually needs to use the energy multiplier too, to match with the "
"directional light. Normally, values between 3.0 and 6.0 are enough to "
"simulate indoor-outdoor conditions."
msgstr ""
"使用自动曝光的最简单方法是确保室外灯(或其他强光)的能量超过1.0。 这是通过调整"
"他们的 **能量** 乘数(在光本身上)来完成的。 为了保持一致，** Sky **通常也需要"
"使用能量倍增器，以匹配定向光。 通常，3.0到6.0之间的值足以模拟室内 - 室外条"
"件。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:166
msgid ""
"By combining Auto Exposure with *Glow* post processing (more on that below), "
"pixels that go over the tonemap **White** will bleed to the glow buffer, "
"creating the typical bloom effect in photography."
msgstr ""
"通过将自动曝光与* Glow *后期处理相结合(更多内容如下)，超过色调图** **的像素将"
"会流向发光缓冲区，从而在摄影中创造典型的绽放效果。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:172
#, fuzzy
msgid ""
"The user-controllable values in the Auto Exposure section come with sensible "
"defaults, but you can still tweak them:"
msgstr "“自动曝光”部分中的用户可控值具有合理的默认值，但您仍然可以调整:"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:177
msgid ""
"**Scale:** Value to scale the lighting. Brighter values produce brighter "
"images, smaller ones produce darker ones."
msgstr ""
"**比例:** 用于缩放照明的值。 较亮的值会产生较亮的图像，较小的值会产生较暗的图"
"像。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:178
msgid ""
"**Min Luma:** Minimum luminance that auto exposure will aim to adjust for. "
"Luminance is the average of the light in all the pixels of the screen."
msgstr ""
"** Min Luma:** 自动曝光旨在调整的最小亮度。 亮度是屏幕所有像素中光线的平均"
"值。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:179
msgid ""
"**Max Luma:** Maximum luminance that auto exposure will aim to adjust for."
msgstr "** Max Luma:** 自动曝光旨在调整的最大亮度。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:180
msgid ""
"**Speed:** Speed at which luminance corrects itself. The higher the value, "
"the faster correction happens."
msgstr "**速度:** 亮度校正的速度。 值越高，发生的校正越快。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:183
#, fuzzy
msgid "Mid- and post-processing effects"
msgstr "中后期处理效果"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:185
#, fuzzy
msgid ""
"A large amount of widely-used mid- and post-processing effects are supported "
"in the Environment."
msgstr "环境支持大量广泛使用的中间和后处理效果。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:189
msgid "Screen-Space Reflections (SSR)"
msgstr "屏幕空间反射(SSR)"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:191
msgid ""
"While Godot supports three sources of reflection data (Sky, ReflectionProbe, "
"and GIProbe), they may not provide enough detail for all situations. "
"Scenarios where Screen Space Reflections make the most sense are when "
"objects are in contact with each other (object over floor, over a table, "
"floating on water, etc)."
msgstr ""
"虽然Godot支持三种反射数据源(Sky，ReflectionProbe和GIProbe)，但它们可能无法为"
"所有情况提供足够的细节。 屏幕空间反射最有意义的场景是物体彼此接触(地板上的物"
"体，桌子上的物体，漂浮在水面上等)。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:198
#, fuzzy
msgid ""
"The other advantage (even if only enabled to a minimum), is that it works in "
"real-time (while the other types of reflections are pre-computed). This can "
"be used to make characters, cars, etc. reflect on surrounding surfaces when "
"moving around."
msgstr ""
"另一个优点(即使只启用最小)，它是实时工作(而其他类型的反射是预先计算的)。 这很"
"好，可以让人物，汽车等在行走时反映出来。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:202
msgid ""
"A few user-controlled parameters are available to better tweak the technique:"
msgstr "一些用户控制的参数可用于更好地调整技术:"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:204
msgid ""
"**Max Steps** determines the length of the reflection. The bigger this "
"number, the more costly it is to compute."
msgstr "**最大步数**确定反射的长度。 这个数字越大，计算成本就越高。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:205
msgid ""
"**Fade In** allows adjusting the fade-in curve, which is useful to make the "
"contact area softer."
msgstr "**淡入**允许调整淡入曲线，这有助于使接触区域更柔和。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:206
msgid ""
"**Fade Out** allows adjusting the fade-out curve, so the step limit fades "
"out softly."
msgstr "**淡出**允许调整淡出曲线，因此步长限制会轻微淡出。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:207
msgid ""
"**Depth Tolerance** can be used for screen-space-ray hit tolerance to gaps. "
"The bigger the value, the more gaps will be ignored."
msgstr ""
"** Depth Tolerance **可用于屏幕空间射线对间隙的容差。 值越大，忽略的差距就越"
"大。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:208
msgid ""
"**Roughness** will apply a screen-space blur to approximate roughness in "
"objects with this material characteristic."
msgstr "**粗糙度**将应用屏幕空间模糊来近似具有此材质特征的对象的粗糙度。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:210
msgid ""
"Keep in mind that screen-space-reflections only work for reflecting opaque "
"geometry. Transparent objects can't be reflected."
msgstr "请记住，屏幕空间反射仅适用于反射不透明几何体。 透明对象无法反映。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:213
msgid "Screen-Space Ambient Occlusion (SSAO)"
msgstr "屏幕空间环境遮挡(SSAO)"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:215
#, fuzzy
msgid ""
"As mentioned in the **Ambient** section, areas where light from light nodes "
"does not reach (either because it's outside the radius or shadowed) are lit "
"with ambient light. Godot can simulate this using GIProbe, ReflectionProbe, "
"the Sky, or a constant ambient color. The problem, however, is that all the "
"methods proposed previously act more on a larger scale (large regions) than "
"at the smaller geometry level."
msgstr ""
"如 **环境** 部分所述，来自光节点的光线未到达的区域(因为它在半径之外或被遮蔽)"
"会被环境光照亮。 Godot可以使用GIProbe，ReflectionProbe，Sky或恒定的环境颜色来"
"模拟这个。 然而，问题在于之前提出的所有方法在更大规模(大区域)上的作用比在较小"
"几何级别上更大。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:222
#, fuzzy
msgid ""
"Constant ambient color and Sky are the same everywhere, while GI and "
"Reflection probes have more local detail, but not enough to simulate "
"situations where light is not able to fill inside hollow or concave features."
msgstr ""
"恒定的环境颜色和Sky是均匀的，并且在任何地方都是相同的，而GI和反射探头具有更多"
"的局部细节，但不足以模拟光线无法填充空心或凹陷特征的情况。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:226
#, fuzzy
msgid ""
"This can be simulated with Screen Space Ambient Occlusion. As you can see in "
"the image below, its purpose is to make sure concave areas are darker, "
"simulating a narrower path for the light to enter:"
msgstr ""
"这可以使用Screen Space Ambient Occlusion进行模拟。 正如您在下图中所看到的，它"
"的目标是确保凹面区域更暗，模拟光线进入的较窄路径:"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:232
msgid ""
"It is a common mistake to enable this effect, turn on a light, and not be "
"able to appreciate it. This is because SSAO only acts on *ambient* light, "
"not direct light."
msgstr ""
"启用此效果，打开灯光并且无法欣赏它是一个常见的错误。 这是因为SSAO仅作用于* "
"ambient * light，而不是直接光。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:235
#, fuzzy
msgid ""
"This is why, in the image above, the effect is less noticeable under the "
"direct light (on the left). If you want to force SSAO to work with direct "
"light too, use the **Light Affect** parameter (even though this is not "
"correct, some artists like how it looks)."
msgstr ""
"这就是为什么在上图中，在直射光下(左侧)效果不太明显。 如果您想强制SSAO也使用直"
"接光源，请使用** Light Affect **参数(尽管这不正确，有些艺术家喜欢它的样子)。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:239
msgid ""
"SSAO looks best when combined with a real source of indirect light, like "
"GIProbe:"
msgstr "当与真正的间接光源结合时，SSAO看起来最好，比如GIProbe:"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:243
msgid "Tweaking SSAO is possible with several parameters:"
msgstr "可以使用以下几个参数调整SSAO:"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:247
msgid ""
"**Radius/Intensity:** To control the radius or intensity of the occlusion, "
"these two parameters are available. Radius is in world (Metric) units."
msgstr ""
"**半径/强度:** 要控制遮挡的半径或强度，可以使用这两个参数。 半径是世界(公制)"
"单位。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:248
msgid ""
"**Radius2/Intensity2:** A Secondary radius/intensity can be used. Combining "
"a large and a small radius AO generally works well."
msgstr ""
"** Radius2 / Intensity2:** 可以使用辅助半径/强度。 结合大半径和小半径AO通常效"
"果很好。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:249
msgid ""
"**Bias:** This can be tweaked to solve self occlusion, though the default "
"generally works well enough."
msgstr "**偏差:** 这可以通过调整来解决自我遮挡问题，但默认情况下通常效果不错。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:250
#, fuzzy
msgid ""
"**Light Affect:** SSAO only affects ambient light, but increasing this "
"slider can make it also affect direct light. Some artists prefer this effect."
msgstr ""
"**光线影响:** SSAO仅影响环境光线，但增加此滑块可能会影响直射光线。 有些艺术家"
"喜欢这种效果。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:251
#, fuzzy
msgid ""
"**Quality:** Depending on quality, SSAO will take more samples over a sphere "
"for every pixel. High quality only works well on modern GPUs."
msgstr ""
"**质量:** 根据质量，SSAO将针对每个像素对球体进行更多采样。 高品质仅适用于现代"
"GPU。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:252
#, fuzzy
msgid ""
"**Blur:** Type of blur kernel used. The 1x1 kernel is a simple blur that "
"preserves local detail better, but is not as efficient (generally works "
"better with the high quality setting above), while 3x3 will soften the image "
"better (with a bit of dithering-like effect), but does not preserve local "
"detail as well."
msgstr ""
"**模糊:** 使用的模糊内核类型。 1x1内核是一个简单的模糊，可以更好地保留局部细"
"节，但效率不高(通常在上面的高质量设置下效果更好)，而3x3会更好地柔化图像(有一"
"点像抖动效果)但不保留局部 细节也是如此。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:253
msgid ""
"**Edge Sharpness**: This can be used to preserve the sharpness of edges "
"(avoids areas without AO on creases)."
msgstr "**边缘清晰度**:这可用于保持边缘的清晰度(避免折痕处没有AO的区域)。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:256
msgid "Depth of Field / Far Blur"
msgstr "景深/远模糊"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:258
msgid ""
"This effect simulates focal distance on high end cameras. It blurs objects "
"behind a given range. It has an initial **Distance** with a **Transition** "
"region (in world units):"
msgstr ""
"此效果可模拟高端相机的焦距。 它模糊了给定范围后面的物体。 它有一个** **距离"
"**， **过渡** 区域(世界单位):"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:264
#: ../../docs/tutorials/3d/environment_and_post_processing.rst:276
msgid ""
"The **Amount** parameter controls the amount of blur. For larger blurs, "
"tweaking the **Quality** may be needed in order to avoid artifacts."
msgstr ""
"** Amount **参数控制模糊量。 对于较大的模糊，可能需要调整 **质量** 以避免伪"
"影。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:268
msgid "Depth of Field / Near Blur"
msgstr "景深/近模糊"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:270
msgid ""
"This effect simulates focal distance on high end cameras. It blurs objects "
"close to the camera (acts in the opposite direction as far blur). It has an "
"initial **Distance** with a **Transition** region (in world units):"
msgstr ""
"此效果可模拟高端相机的焦距。 它使靠近相机的物体模糊(在远处模糊的相反方向上作"
"用)。 它有一个** **距离**， **过渡** 区域(世界单位):"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:279
msgid ""
"It is common to use both blurs together to focus the viewer's attention on a "
"given object:"
msgstr "通常使用两种模糊将观众的注意力集中在给定对象上:"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:285
msgid "Glow"
msgstr "辉光"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:287
msgid ""
"In photography and film, when light amount exceeds the maximum supported by "
"the media (be it analog or digital), it generally bleeds outwards to darker "
"regions of the image. This is simulated in Godot with the **Glow** effect."
msgstr ""
"在摄影和胶片中，当光量超过介质支持的最大值(无论是模拟还是数字)时，它通常会向"
"外渗出到图像的较暗区域。 这是在Godot中用** Glow **效果模拟的。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:293
msgid ""
"By default, even if the effect is enabled, it will be weak or invisible. One "
"of two conditions need to happen for it to actually show:"
msgstr ""
"默认情况下，即使启用了效果，它也会变弱或不可见。 实际显示它需要发生的两个条件"
"之一:"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:296
#, fuzzy
msgid ""
"The light in a pixel surpasses the **HDR Threshold** (where 0 is all light "
"surpasses it, and 1.0 is light over the tonemapper **White** value). "
"Normally, this value is expected to be at 1.0, but it can be lowered to "
"allow more light to bleed. There is also an extra parameter, **HDR Scale**, "
"that allows scaling (making brighter or darker) the light surpassing the "
"threshold."
msgstr ""
"像素中的光线超过了** HDR阈值**(其中0表示所有光线都超过它，而1.0表示光线照片上"
"的亮度为 **白色** 值)。 通常这个值预计为1.0，但可以降低，以允许更多的光线流"
"血。 还有一个额外的参数，** HDR Scale **，允许超出阈值的光线缩放(使亮度更高或"
"更暗)。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:300
msgid ""
"The Bloom effect has a value set greater than 0. As it increases, it sends "
"the whole screen to the glow processor at higher amounts."
msgstr ""
"Bloom效果的值设置大于0.随着它的增加，它会以更高的数量将整个屏幕发送到辉光处理"
"器。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:304
msgid "Both will cause the light to start bleeding out of the brighter areas."
msgstr "两者都会导致光从较亮的区域开始流血。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:306
msgid "Once glow is visible, it can be controlled with a few extra parameters:"
msgstr "一旦看到发光，就可以通过一些额外的参数来控制它:"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:308
msgid ""
"**Intensity** is an overall scale for the effect, it can be made stronger or "
"weaker (0.0 removes it)."
msgstr "**强度**是效果的整体比例，可以更强或更弱(0.0将其移除)。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:309
#, fuzzy
msgid ""
"**Strength** is how strong the gaussian filter kernel is processed. Greater "
"values make the filter saturate and expand outwards. In general, changing "
"this is not needed, as the size can be more efficiently adjusted with the "
"**Levels**."
msgstr ""
"**强度**是高斯滤波器内核处理的强度。 更大的值使滤波器饱和并向外扩展。 一般情"
"况下，不需要更改它，因为可以使用 **级别** 更有效地调整大小。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:311
msgid "The **Blend Mode** of the effect can also be changed:"
msgstr "效果的 **混合模式** 也可以改变:"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:313
#, fuzzy
msgid ""
"**Additive** is the strongest one, as it just adds the glow effect over the "
"image with no blending involved. In general, it's too strong to be used, but "
"can look good with low intensity Bloom (produces a dream-like effect)."
msgstr ""
"**添加剂**是最强的，因为它只是在图像上添加了发光效果而不涉及混合。 一般来说，"
"它太强大而无法使用，但在低强度Bloom下可以看起来很好(产生梦幻般的效果)。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:314
msgid ""
"**Screen** is the default one. It ensures glow never brights more than "
"itself and works great as an all around."
msgstr ""
"**屏幕**是默认值。 它确保发光永远不会比自身更亮，并且可以很好地作为一个整体。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:315
msgid ""
"**Softlight** is the weakest one, producing only a subtle color disturbance "
"around the objects. This mode works best on dark scenes."
msgstr ""
"** Softlight **是最弱的一种，只会在物体周围产生微妙的色彩干扰。 此模式在黑暗"
"场景中效果最佳。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:316
msgid ""
"**Replace** can be used to blur the whole screen or debug the effect. It "
"just shows the glow effect without the image below."
msgstr "**替换**可用于模糊整个屏幕或调试效果。 它只显示没有下图的发光效果。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:318
#, fuzzy
msgid ""
"To change the glow effect size and shape, Godot provides **Levels**. Smaller "
"levels are strong glows that appear around objects, while large levels are "
"hazy glows covering the whole screen:"
msgstr ""
"为了改变发光效果的大小和形状，Godot提供 **级别** 。 较小的水平是在物体周围出"
"现的强烈发光，而大的水平是覆盖整个屏幕的朦胧发光:"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:324
msgid ""
"The real strength of this system, though, is to combine levels to create "
"more interesting glow patterns:"
msgstr "然而，这个系统的真正优势在于结合水平来创造更有趣的发光模式:"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:329
msgid ""
"Finally, as the highest layers are created by stretching small blurred "
"images, it is possible that some blockiness may be visible. Enabling "
"**Bicubic Upscaling** gets rids of it, at a minimal performance cost."
msgstr ""
"最后，由于通过拉伸小的模糊图像来创建最高层，因此可能会看到一些块状。 启用** "
"Bicubic Upscaling **会以最低的性能成本获取它。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:336
msgid "Adjustments"
msgstr "调整"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:338
msgid ""
"At the end of processing, Godot offers the possibility to do some standard "
"image adjustments."
msgstr "在处理结束时，Godot提供了进行一些标准图像调整的可能性。"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:343
msgid ""
"The first one is being able to change the typical Brightness, Contrast, and "
"Saturation:"
msgstr "第一个是能够改变典型的亮度，对比度和饱和度:"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:348
msgid ""
"The second is by supplying a color correction gradient. A regular black to "
"white gradient like the following one will produce no effect:"
msgstr "第二种是通过提供颜色校正梯度。 如下所示的常规黑色到白色渐变将不起作用:"

#: ../../docs/tutorials/3d/environment_and_post_processing.rst:353
msgid ""
"But creating custom ones will allow to map each channel to a different color:"
msgstr "但是创建自定义的会允许将每个通道映射到不同的颜色:"

#: ../../docs/tutorials/3d/high_dynamic_range.rst:4
msgid "High dynamic range"
msgstr "高动态范围"

#: ../../docs/tutorials/3d/high_dynamic_range.rst:9
msgid ""
"Normally, an artist does all the 3D modelling, then all the texturing, looks "
"at their awesome looking model in the 3D DCC and says \"looks fantastic, "
"ready for integration!\" then goes into the game, lighting is setup and the "
"game runs."
msgstr ""
"通常情况下，艺术家会进行所有3D建模，然后进行所有纹理处理，在3D DCC中查看他们"
"令人敬畏的模型并说“看起来很棒，可以进行整合！” 然后进入游戏，设置灯光并运行游"
"戏。"

#: ../../docs/tutorials/3d/high_dynamic_range.rst:14
#, fuzzy
msgid ""
"So at what point does all this HDR business come into play? The idea is that "
"instead of dealing with colors that go from black to white (0 to 1), we use "
"colors whiter than white (for example, 0 to 8 times white)."
msgstr ""
"那么所有这些HDR东西的来源是从哪里来的？ 我们的想法是，不使用从黑色到白色(0到"
"1)的颜色，而是使用比白色更白的颜色(例如，白色的0到8倍)。"

#: ../../docs/tutorials/3d/high_dynamic_range.rst:18
msgid ""
"To be more practical, imagine that in a regular scene, the intensity of a "
"light (generally 1.0) is set to 5.0. The whole scene will turn very bright "
"(towards white) and look horrible."
msgstr ""
"更实际的是，想象一下在常规场景中，光的强度(通常为1.0)设置为5.0。 整个场景将变"
"得非常明亮(朝向白色)并且看起来很可怕。"

#: ../../docs/tutorials/3d/high_dynamic_range.rst:22
#, fuzzy
msgid ""
"After this, the luminance of the scene is computed by averaging the "
"luminance of every pixel of it, and this value is used to bring the scene "
"back to normal ranges. This last operation is called tone-mapping. Finally, "
"we are at a similar place from where we started:"
msgstr ""
"在此之后，通过平均场景的每个像素的亮度来计算场景的亮度，并且该值用于使场景回"
"到正常范围。 最后一个操作称为色调映射。 最后，我们在与我们开始的地方类似的地"
"方:"

#: ../../docs/tutorials/3d/high_dynamic_range.rst:30
msgid ""
"Except the scene is more contrasted because there is a higher light range at "
"play. What is this all useful for? The idea is that the scene luminance will "
"change while you move through the world, allowing situations like this to "
"happen:"
msgstr ""
"除了场景更加对比，因为在比赛中有更高的光线范围。 这有什么用呢？ 我们的想法"
"是，当您在世界各地移动时，场景亮度会发生变化，从而允许这样的情况发生:"

#: ../../docs/tutorials/3d/high_dynamic_range.rst:37
msgid ""
"Additionally, it is possible to set a threshold value to send to the glow "
"buffer depending on the pixel luminance. This allows for more realistic "
"light bleeding effects in the scene."
msgstr ""
"另外，可以根据像素亮度设置阈值以发送到辉光缓冲器。 这允许场景中更逼真的光线流"
"失效果。"

#: ../../docs/tutorials/3d/high_dynamic_range.rst:42
msgid "Linear color space"
msgstr "线性色彩空间"

#: ../../docs/tutorials/3d/high_dynamic_range.rst:44
msgid ""
"The problem with this technique is that computer monitors apply a gamma "
"curve to adapt better to the way the human eye sees. Artists create their "
"art on the screen too, so their art has an implicit gamma curve applied to "
"it."
msgstr ""
"该技术的问题在于计算机监视器应用伽马曲线以更好地适应人眼看到的方式。 艺术家也"
"在屏幕上创作他们的艺术，因此他们的艺术有一个隐含的伽玛曲线应用于它。"

#: ../../docs/tutorials/3d/high_dynamic_range.rst:49
#, fuzzy
msgid ""
"The color space where images created on computer monitors exist is called "
"\"sRGB\". All visual content that people have on their computers or download "
"from the internet (such as pictures, movies, etc.) is in this colorspace."
msgstr ""
"存在于计算机监视器中的图像的颜色空间称为“sRGB”。 人们在他们的计算机上或从互联"
"网上下载的所有视觉内容(例如图片，电影等)都在这个颜色空间中。"

#: ../../docs/tutorials/3d/high_dynamic_range.rst:56
#, fuzzy
msgid ""
"The mathematics of HDR require that we multiply the scene by different "
"values to adjust the luminance and exposure to different light ranges, and "
"this curve gets in the way, as we need colors in linear space for this."
msgstr ""
"HDR的数学要求我们将场景乘以不同的值来调整亮度和曝光到不同的光范围，这条曲线会"
"妨碍我们在线性空间中需要颜色。"

#: ../../docs/tutorials/3d/high_dynamic_range.rst:62
msgid "Linear color space & asset pipeline"
msgstr "线性色彩空间和资源管道"

#: ../../docs/tutorials/3d/high_dynamic_range.rst:64
msgid ""
"Working in HDR is not just pressing a switch. First, imported image assets "
"must be converted to linear space on import. There are two ways to do this:"
msgstr ""
"在HDR中工作不仅仅是按下开关。 首先，导入的图像资源必须在导入时转换为线性空"
"间。 有两种方法可以做到这一点:"

#: ../../docs/tutorials/3d/high_dynamic_range.rst:69
#, fuzzy
msgid "sRGB -> linear conversion on image import"
msgstr "SRGB ->图像导入的线性转换"

#: ../../docs/tutorials/3d/high_dynamic_range.rst:71
#, fuzzy
msgid ""
"This is the most compatible way of using linear-space assets, and it will "
"work everywhere, including all mobile devices. The main issue with this is "
"loss of quality, as sRGB exists to avoid this same problem. Using 8 bits per "
"channel to represent linear colors is inefficient from the point of view of "
"the human eye. These textures might later be compressed too, which makes the "
"problem worse."
msgstr ""
"这是使用线性空间资源最兼容的方式，它可以在包括所有移动设备在内的任何地方使"
"用。 这个问题的主要问题是质量下降，因为存在sRGB以避免同样的问题。 从人眼的角"
"度来看，每个通道使用8位来表示线性颜色是低效的。 这些纹理可能会在以后被压缩，"
"这会使问题变得更糟。"

#: ../../docs/tutorials/3d/high_dynamic_range.rst:78
#, fuzzy
msgid "In any case, though, this is the easy solution that works everywhere."
msgstr "无论如何，这是一个随处可用的简单解决方案。"

#: ../../docs/tutorials/3d/high_dynamic_range.rst:81
msgid "Hardware sRGB -> linear conversion"
msgstr "硬件sRGB ->线性转换"

#: ../../docs/tutorials/3d/high_dynamic_range.rst:83
msgid ""
"This is the most correct way to use assets in linear-space, as the texture "
"sampler on the GPU will do the conversion after reading the texel using "
"floating point. This works fine on PC and consoles, but most mobile devices "
"do no support it, or do not support it on compressed texture format (iOS for "
"example)."
msgstr ""
"这是在线性空间中使用资源的最正确方法，因为GPU上的纹理采样器将在使用浮点读取纹"
"素后执行转换。 这在PC和控制台上运行良好，但大多数移动设备不支持它，或者不支持"
"压缩纹理格式(例如iOS)。"

#: ../../docs/tutorials/3d/high_dynamic_range.rst:90
msgid "Linear -> sRGB at the end"
msgstr "线性 -> sRGB结尾"

#: ../../docs/tutorials/3d/high_dynamic_range.rst:92
msgid ""
"After all the rendering is done, the linear-space rendered image must be "
"converted back to sRGB. To do this, simply enable sRGB conversion in the "
"current :ref:`Environment <class_Environment>` (more on that below)."
msgstr ""
"完成所有渲染后，必须将线性空间渲染图像转换回sRGB。 要做到这一点，只需在当前启"
"用sRGB转换 :ref:`Environment <class_Environment>` (更多内容见下文)。"

#: ../../docs/tutorials/3d/high_dynamic_range.rst:96
msgid ""
"Keep in mind that sRGB -> Linear and Linear -> sRGB conversions must always "
"be **both** enabled. Failing to enable one of them will result in horrible "
"visuals suitable only for avant-garde experimental indie games."
msgstr ""
"请记住，sRGB ->线性和线性 -> sRGB转换必须始终 **都** 启用。 未能启用其中一个"
"将导致可怕的视觉效果仅适用于前卫的实验性独立游戏。"

#: ../../docs/tutorials/3d/high_dynamic_range.rst:102
msgid "Parameters of HDR"
msgstr "HDR的参数"

#: ../../docs/tutorials/3d/high_dynamic_range.rst:104
msgid ""
"HDR is found in the :ref:`Environment <class_Environment>` resource. These "
"are found most of the time inside a :ref:`WorldEnvironment "
"<class_WorldEnvironment>` node or set in a camera. There are many parameters "
"for HDR:"
msgstr ""
"HDR可以在 :ref:`Environment <class_Environment>` 资源中找到。 这些在大多数情"
"况下都可以在 :ref:`WorldEnvironment <class_WorldEnvironment>` 节点中找到或在"
"相机中设置。 HDR有许多参数:"

#: ../../docs/tutorials/3d/high_dynamic_range.rst:112
msgid "ToneMapper"
msgstr "色调映射器"

#: ../../docs/tutorials/3d/high_dynamic_range.rst:114
msgid ""
"The ToneMapper is the heart of the algorithm. Many options for tonemappers "
"are provided:"
msgstr "ToneMapper是算法的核心。 提供了许多色调映射器的选项:"

#: ../../docs/tutorials/3d/high_dynamic_range.rst:117
msgid ""
"**Linear:** Simplest tonemapper. It does its job for adjusting scene "
"brightness, but if the differences in light are too big, it will cause "
"colors to be too saturated."
msgstr ""
"**线性:** 最简单的色调映射器。 它的作用是调整场景亮度，但是如果光线的差异太"
"大，会导致颜色过饱和。"

#: ../../docs/tutorials/3d/high_dynamic_range.rst:120
msgid "**Log:** Similar to linear but not as extreme."
msgstr "**日志:** 类似于线性而非极端。"

#: ../../docs/tutorials/3d/high_dynamic_range.rst:121
#, fuzzy
msgid ""
"**Reinhardt:** Classical tonemapper (modified, so it will not desaturate as "
"much)"
msgstr "** Reinhardt:** 经典的色调映射器(经过修改，因此不会降低饱和度)"

#: ../../docs/tutorials/3d/high_dynamic_range.rst:123
#, fuzzy
msgid ""
"**ReinhardtAutoWhite:** Same as above, but uses the max scene luminance to "
"adjust the white value."
msgstr "** ReinhardtAutoWhite:** 与上述相同，但使用最大场景亮度来调整白色值。"

#: ../../docs/tutorials/3d/high_dynamic_range.rst:127
msgid "Exposure"
msgstr "曝光"

#: ../../docs/tutorials/3d/high_dynamic_range.rst:129
msgid ""
"The same exposure parameter as in real cameras. Controls how much light "
"enters the camera. Higher values will result in a brighter scene, and lower "
"values will result in a darker scene."
msgstr ""
"与真实相机相同的曝光参数。 控制进入相机的光线量。 较高的值将导致更亮的场景，"
"较低的值将导致较暗的场景。"

#: ../../docs/tutorials/3d/high_dynamic_range.rst:134
msgid "White"
msgstr "白色"

#: ../../docs/tutorials/3d/high_dynamic_range.rst:136
msgid "Maximum value of white."
msgstr "白色的最大值。"

#: ../../docs/tutorials/3d/high_dynamic_range.rst:139
msgid "Glow threshold"
msgstr "发光阈值"

#: ../../docs/tutorials/3d/high_dynamic_range.rst:141
#, fuzzy
msgid ""
"Determines above which value (from 0 to 1 after the scene is tonemapped) "
"light will start bleeding."
msgstr "确定上面的哪个值(场景在色调映射后从0到1)，灯光将开始流血。"

#: ../../docs/tutorials/3d/high_dynamic_range.rst:145
msgid "Glow scale"
msgstr "发光量表"

#: ../../docs/tutorials/3d/high_dynamic_range.rst:147
#, fuzzy
msgid "Determines how much light will bleed."
msgstr "确定会有多少光线流出。"

#: ../../docs/tutorials/3d/high_dynamic_range.rst:150
msgid "Min luminance"
msgstr "最低亮度"

#: ../../docs/tutorials/3d/high_dynamic_range.rst:152
msgid ""
"Lower bound value of light for the scene at which the tonemapper stops "
"working. This allows dark scenes to remain dark."
msgstr "色调映射器停止工作的场景的光的下限值。 这允许黑暗场景保持黑暗。"

#: ../../docs/tutorials/3d/high_dynamic_range.rst:156
msgid "Max luminance"
msgstr "最大亮度"

#: ../../docs/tutorials/3d/high_dynamic_range.rst:158
msgid ""
"Upper bound value of light for the scene at which the tonemapper stops "
"working. This allows bright scenes to remain saturated."
msgstr "色调映射器停止工作的场景的光的上限值。 这允许明亮的场景保持饱和。"

#: ../../docs/tutorials/3d/high_dynamic_range.rst:162
msgid "Exposure adjustment speed"
msgstr "曝光调整速度"

#: ../../docs/tutorials/3d/high_dynamic_range.rst:164
#, fuzzy
msgid ""
"Auto-exposure will change slowly and will take a while to adjust (like in "
"real cameras). Bigger values mean faster adjustment."
msgstr ""
"自动曝光会缓慢变化，需要一段时间才能调整(就像在真实相机中一样)。 值越大意味着"
"调整越快。"

#: ../../docs/tutorials/3d/using_gridmaps.rst:4
msgid "Using gridmaps"
msgstr "使用网格地图"

#: ../../docs/tutorials/3d/using_gridmaps.rst:9
msgid ""
":ref:`Gridmaps <class_GridMap>` are a tool for creating 3D game levels, "
"similar to the way :ref:`TileMap <doc_using_tilemaps>` works in 2D. You "
"start with a predefined collection of 3D meshes (a :ref:`class_MeshLibrary`) "
"that can be placed on a grid, as if you were building a level with an "
"unlimited amount of Lego blocks."
msgstr ""
":ref:`Gridmaps <class_GridMap>` 是一种用于创建3D游戏关卡的工具，方式类似于2D"
"中使用 :ref:`TileMap <doc_using_tilemaps>` 。使用一个定义好的可以放在一个网格"
"中的 3D mesh (a :ref:`class_MeshLibrary`) (译注，grid和mesh都译作网格，这里为"
"了清晰，mesh直接使用英文，grid则译作网格)对象集合搭建关卡，就像您使用无限多数"
"量的乐高积木搭建世界一样。"

#: ../../docs/tutorials/3d/using_gridmaps.rst:15
msgid ""
"Collisions and navigation can also be added to the meshes, just like you "
"would do with the tiles of a tilemap."
msgstr "就像使用tilemap的tile一样，碰撞和导航也可以添加到网格中。"

#: ../../docs/tutorials/3d/using_gridmaps.rst:19
msgid "Example project"
msgstr "示例项目"

#: ../../docs/tutorials/3d/using_gridmaps.rst:21
msgid ""
"To learn how GridMaps work, start by downloading the sample project: :"
"download:`gridmap_demo.zip <files/gridmap_demo.zip>`."
msgstr ""
"要学习GridMaps是怎么样工作的，请先下载示例项目: :download:`gridmap_demo.zip "
"<files/gridmap_demo.zip>`。"

#: ../../docs/tutorials/3d/using_gridmaps.rst:24
msgid ""
"Unzip this project and add it to the Project Manager using the \"Import\" "
"button."
msgstr "解压缩此项目并使用“导入”按钮将其添加到项目管理器。"

#: ../../docs/tutorials/3d/using_gridmaps.rst:28
msgid "Creating a MeshLibrary"
msgstr "创建Mesh库"

#: ../../docs/tutorials/3d/using_gridmaps.rst:30
msgid ""
"To begin, you need a :ref:`class_MeshLibrary`, which is a collection of "
"individual meshes that can be used in the gridmap. Open the "
"\"MeshLibrary_Source.tscn\" scene to see an example of how to set up the "
"mesh library."
msgstr ""
"首先，您需要一个 :ref:`class_MeshLibrary`，它是可以在gridmap中使用的Mesh的集"
"合。 打开“MeshLibrary_Source.tscn”场景以查看如何设置网格库的示例。"

#: ../../docs/tutorials/3d/using_gridmaps.rst:36
msgid ""
"As you can see, this scene has a :ref:`class_Spatial` node as its root, and "
"a number of :ref:`class_MeshInstance` node children."
msgstr ""
"可以看到，这个场景有一个 :ref:`class_Spatial` 节点作为它的根，以及一些 :ref:"
"`class_MeshInstance` 子节点。"

#: ../../docs/tutorials/3d/using_gridmaps.rst:39
msgid ""
"If you don't need any physics in your scene, then you're done. However, in "
"most cases you'll want to assign collision bodies to the meshes."
msgstr ""
"如果您的场景中不需要任何物理，那么到这里就完成了。 但是，在大多数情况下，您还"
"需要给网格指定碰撞体。"

#: ../../docs/tutorials/3d/using_gridmaps.rst:43
msgid "Collisions"
msgstr "碰撞"

#: ../../docs/tutorials/3d/using_gridmaps.rst:45
msgid ""
"You can manually assign a :ref:`class_StaticBody` and :ref:"
"`class_CollisionShape` to each mesh. Alternatively, you can use the \"Mesh\" "
"menu to automatically create the collision body based on the mesh data."
msgstr ""
"您可以手动为每个Mesh指定 :ref:`class_StaticBody` 和 :ref:"
"`class_CollisionShape`。或者，您可以使用“网格(Mesh)”菜单根据Mesh数据自动创建"
"碰撞体。"

#: ../../docs/tutorials/3d/using_gridmaps.rst:51
msgid ""
"Note that a \"Convex\" collision body will work better for simple meshes. "
"For more complex shapes, select \"Create Trimesh Static Body\". Once each "
"mesh has a physics body and collision shape assigned, your mesh library is "
"ready to be used."
msgstr ""
"请注意，“凸(Convex)”碰撞体对于简单Mesh效果更好。 对于更复杂的形状，请选择“创"
"建Trimesh静态体”。 一旦每个网格都分配了物理主体和碰撞形状，就可以使用Mesh库"
"了。"

#: ../../docs/tutorials/3d/using_gridmaps.rst:62
msgid ""
"Only the materials from within the meshes are used when generating the mesh "
"library. Materials set on the node will be ignored."
msgstr ""

#: ../../docs/tutorials/3d/using_gridmaps.rst:66
msgid "Exporting the MeshLibrary"
msgstr "导出Mesh库"

#: ../../docs/tutorials/3d/using_gridmaps.rst:68
msgid ""
"To export the library, click on Scene -> Convert To.. -> MeshLibrary.., and "
"save it as a resource."
msgstr ""
"要导出库，请单击“场景” ->“转换为...” ->“MeshLibrary(网格库)...”，并将其另存为"
"资源。"

#: ../../docs/tutorials/3d/using_gridmaps.rst:73
msgid ""
"You can find an already exported MeshLibrary in the project named "
"\"MeshLibrary.tres\"."
msgstr "可以在项目中找到已导出的名为“MeshLibrary.tres”的Mesh库。"

#: ../../docs/tutorials/3d/using_gridmaps.rst:76
msgid "Using GridMap"
msgstr "使用网格图(GridMap)"

#: ../../docs/tutorials/3d/using_gridmaps.rst:78
msgid ""
"Create a new scene and add a GridMap node. Add the mesh library by dragging "
"the resource file from the FileSystem dock and dropping it in the \"Theme\" "
"property in the Inspector."
msgstr ""
"创建一个新场景并添加一个GridMap节点。 通过从“文件系统(FileSystem)”扩展面板拖"
"动资源文件并将其放入Inspector中的“Theme(主题)”属性中来添加Mesh库。"

#: ../../docs/tutorials/3d/using_gridmaps.rst:84
msgid ""
"The \"Cell/Size\" property should be set to the size of your meshes. You can "
"leave it at the default value for the demo. Set the \"Center Y\" property to "
"\"Off\"."
msgstr ""
"“单元格/大小(Cell/Size)”属性应设置为Mesh的大小。 在本示例中您可以使用默认"
"值。 将“Center Y”属性设置为“Off”。"

#: ../../docs/tutorials/3d/using_gridmaps.rst:87
msgid ""
"Now you can start designing the level by choosing a tile from the palette "
"and placing it with Left-Click in the editor window. To remove a tile, use "
"Shift+Right-click."
msgstr ""
"现在，您可以通过从调色板中选择一个图块并使用左键单击在编辑器窗口中放置来开始"
"设计关卡。 要删除图块，请使用Shift + 右键单击。"

#: ../../docs/tutorials/3d/using_gridmaps.rst:91
msgid ""
"Click on the \"GridMap\" menu to see options and shortcuts. For example, "
"pressing \"S\" rotates a tile around the y-axis."
msgstr "单击“GridMap”菜单可以查看选项和快捷键。 例如，按下“S”围绕y轴旋转图块。"

#: ../../docs/tutorials/3d/using_gridmaps.rst:96
msgid ""
"Holding <Shift> and dragging with the left mouse button will draw a "
"selection box. You can duplicate or clear the selected area using the "
"respective menu options."
msgstr ""
"按住<Shift>并使用鼠标左键拖动将绘制一个选择框。 您可以使用相应的菜单选项复制"
"或清除所选区域。"

#: ../../docs/tutorials/3d/using_gridmaps.rst:102
#, fuzzy
msgid ""
"In the menu, you can also change the axis you're drawing on, as well as "
"shift the drawing plane higher or lower on its axis."
msgstr ""
"在菜单中，您还可以更改正在绘制的轴，并将绘图平面在其轴上移动得更高或更低。"

#: ../../docs/tutorials/3d/using_gridmaps.rst:108
msgid "Using GridMap in code"
msgstr "在代码中使用GridMap"

#: ../../docs/tutorials/3d/using_gridmaps.rst:110
msgid ""
"See :ref:`class_GridMap` for details on the node's methods and member "
"variables."
msgstr "有关节点方法和成员变量的详细信息，请参阅 :ref:`class_GridMap`。"

#: ../../docs/tutorials/3d/using_multi_mesh_instance.rst:4
msgid "Using MultiMeshInstance"
msgstr "使用多网格实例"

#: ../../docs/tutorials/3d/using_multi_mesh_instance.rst:9
#, fuzzy
msgid ""
"In a normal scenario, you would use a :ref:`MeshInstance "
"<class_MeshInstance>` node to display a 3D mesh like a human model for the "
"main character, but in some cases, you would like to create multiple "
"instances of the same mesh in a scene. You *could* duplicate the same node "
"multiple times and adjust the transforms manually. This may be a tedious "
"process and the result may look mechanical. Also, this method is not "
"conducive to rapid iterations. :ref:`MultiMeshInstance "
"<class_MultiMeshInstance>` is one of the possible solutions to this problem."
msgstr ""
"在正常情况下，您将使用 :ref:`MeshInstance <class_MeshInstance>` 节点显示类似"
"于主角的人体模型的3D网格，但在某些情况下，您希望创建同一网格的多个实例 一个场"
"景。 您 *可以* 多次复制同一节点并手动调整转换。 这可能是一个繁琐的过程，结果"
"看起来很机械。 而且，该方法不利于快速迭代。 :ref:`MultiMeshInstance "
"<class_MultiMeshInstance>` 是这个问题的可能解决方案之一。"

#: ../../docs/tutorials/3d/using_multi_mesh_instance.rst:18
msgid ""
"MultiMeshInstance, as the name suggests, creates multiple copies of a "
"MeshInstance over a surface of a specific mesh. An example would be having a "
"tree mesh populate a landscape mesh with trees of random scales and "
"orientations."
msgstr ""
"MultiMeshInstance，顾名思义，在特定网格的表面上创建MeshInstance的多个副本。 "
"一个示例是树形网格用随机比例和方向的树填充景观网格。"

#: ../../docs/tutorials/3d/using_multi_mesh_instance.rst:23
msgid "Setting up the nodes"
msgstr "设置节点"

#: ../../docs/tutorials/3d/using_multi_mesh_instance.rst:25
msgid ""
"The basic setup requires three nodes: the MultiMeshInstance node and two "
"MeshInstance nodes."
msgstr "基本设置需要三个节点:MultiMeshInstance节点和两个MeshInstance节点。"

#: ../../docs/tutorials/3d/using_multi_mesh_instance.rst:28
msgid ""
"One node is used as the target, the mesh that you want to place multiple "
"meshes on. In the tree example, this would be the landscape."
msgstr "一个节点用作目标，即要放置多个网格的网格。 在树的示例中，这将是景观。"

#: ../../docs/tutorials/3d/using_multi_mesh_instance.rst:31
#, fuzzy
msgid ""
"The other node is used as the source, the mesh that you want to have "
"duplicated. In the tree case, this would be the tree itself."
msgstr "另一个节点用作源，即要复制的网格。 在树的情况下，这将是树。"

#: ../../docs/tutorials/3d/using_multi_mesh_instance.rst:34
msgid ""
"In our example, we would use a :ref:`Node <class_Node>` as the root node of "
"the scene. Your scene tree would look like this:"
msgstr ""
"在我们的示例中，我们将使用 :ref:`Node <class_Node>` 作为场景的根节点。 您的场"
"景树看起来像这样:"

#: ../../docs/tutorials/3d/using_multi_mesh_instance.rst:39
#, fuzzy
msgid "For simplicity's sake, this tutorial uses built-in primitives."
msgstr "出于简化目的，本教程使用内置基元。"

#: ../../docs/tutorials/3d/using_multi_mesh_instance.rst:41
msgid ""
"Now you have everything ready. Select the MultiMeshInstance node and look at "
"the toolbar, you should see an extra button called ``MultiMesh`` next to "
"``View``. Click it and select *Populate surface* in the dropdown menu. A new "
"window titled *Populate MultiMesh* will pop up."
msgstr ""
"现在您准备好了一切。 选择MultiMeshInstance节点并查看工具栏，您应该在 "
"``View`` 旁边看到一个名为 ``MultiMesh`` 的额外按钮。 单击它并在下拉菜单中选"
"择 *填充曲面* 。 将弹出一个名为* Populate MultiMesh *的新窗口。"

#: ../../docs/tutorials/3d/using_multi_mesh_instance.rst:51
msgid "MultiMesh settings"
msgstr "MultiMesh设置"

#: ../../docs/tutorials/3d/using_multi_mesh_instance.rst:53
msgid "Below are descriptions of the options."
msgstr "以下是选项说明。"

#: ../../docs/tutorials/3d/using_multi_mesh_instance.rst:56
msgid "Target Surface"
msgstr "目标表面"

#: ../../docs/tutorials/3d/using_multi_mesh_instance.rst:58
#, fuzzy
msgid ""
"The mesh used as the target surface on which to place copies of your source "
"mesh."
msgstr "您将用作目标曲面的网格，用于放置源网格的副本。"

#: ../../docs/tutorials/3d/using_multi_mesh_instance.rst:62
msgid "Source Mesh"
msgstr "源网格"

#: ../../docs/tutorials/3d/using_multi_mesh_instance.rst:64
msgid "The mesh you want duplicated on the target surface."
msgstr "要在目标曲面上复制的网格。"

#: ../../docs/tutorials/3d/using_multi_mesh_instance.rst:67
msgid "Mesh Up Axis"
msgstr "网格向上轴"

#: ../../docs/tutorials/3d/using_multi_mesh_instance.rst:69
msgid "The axis used as the up axis of the source mesh."
msgstr "轴用作源网格的上轴。"

#: ../../docs/tutorials/3d/using_multi_mesh_instance.rst:72
msgid "Random Rotation"
msgstr "随机旋转"

#: ../../docs/tutorials/3d/using_multi_mesh_instance.rst:74
#, fuzzy
msgid "Randomizing the rotation around the up axis of the source mesh."
msgstr "随机围绕源网格的网格向上轴旋转。"

#: ../../docs/tutorials/3d/using_multi_mesh_instance.rst:77
msgid "Random Tilt"
msgstr "随机砖块"

#: ../../docs/tutorials/3d/using_multi_mesh_instance.rst:79
msgid "Randomizing the overall rotation of the source mesh."
msgstr "随机化源网格的整体旋转。"

#: ../../docs/tutorials/3d/using_multi_mesh_instance.rst:82
msgid "Random Scale"
msgstr "随机缩放"

#: ../../docs/tutorials/3d/using_multi_mesh_instance.rst:84
msgid "Randomizing the scale of the source mesh."
msgstr "随机化源网格的比例。"

#: ../../docs/tutorials/3d/using_multi_mesh_instance.rst:89
msgid ""
"The scale of the source mesh that will be placed over the target surface."
msgstr "将放置在目标曲面上的源网格的比例。"

#: ../../docs/tutorials/3d/using_multi_mesh_instance.rst:92
msgid "Amount"
msgstr "量"

#: ../../docs/tutorials/3d/using_multi_mesh_instance.rst:94
msgid "The amount of mesh instances placed over the target surface."
msgstr "放置在目标曲面上的网格实例数量。"

#: ../../docs/tutorials/3d/using_multi_mesh_instance.rst:96
msgid ""
"Select the target surface. In the tree case, this should be the landscape "
"node. The source mesh should be the tree node. Adjust the other parameters "
"according to your preference. Press ``Populate`` and multiple copies of the "
"source mesh will be placed over the target mesh. If you are satisfied with "
"the result, you can delete the mesh instance used as the source mesh."
msgstr ""
"选择目标曲面。 在树情况下，这应该是横向节点。 源网格应该是树节点。 根据您的喜"
"好调整其他参数。 按 ``Populate`` ，源网格的多个副本将放在目标网格上。 如果对"
"结果满意，可以删除用作源网格的网格实例。"

#: ../../docs/tutorials/3d/using_multi_mesh_instance.rst:102
msgid "The end result should look like this:"
msgstr "最终结果应如下所示:"

#: ../../docs/tutorials/3d/using_multi_mesh_instance.rst:106
#, fuzzy
msgid ""
"To change the result, repeat the previous steps with different parameters."
msgstr "要更改结果，请使用不同的参数重复相同的步骤。"

#: ../../docs/tutorials/3d/csg_tools.rst:4
msgid "CSG"
msgstr "CSG"

#: ../../docs/tutorials/3d/csg_tools.rst:6
#, fuzzy
msgid ""
"CSG stands for **Constructive Solid Geometry**, and is a tool to combine "
"basic shapes or custom meshes to create more complex shapes. In 3D modelling "
"software, CSG is mostly known as \"Boolean Operators\"."
msgstr ""
"CSG代表“构造实体几何”，是一种组合基本形状或自定义网格以创建更复杂形状的工"
"具。 在3D建模软件中，CSG主要称为“布尔运算符”。"

#: ../../docs/tutorials/3d/csg_tools.rst:10
#, fuzzy
msgid ""
"Level prototyping is one of the main uses of CSG in Godot. This technique "
"allows users to create simple versions of most common shapes by combining "
"primitives. Interior environments can be created by using inverted "
"primitives."
msgstr ""
"CSG在Godot中的目的是将其用于水平原型设计。 该技术允许用户通过组合基元来创建最"
"常见形状的简单版本。 可以使用反转基元创建室内环境。"

#: ../../docs/tutorials/3d/csg_tools.rst:17
msgid "Introduction to CSG nodes"
msgstr "CSG节点简介"

#: ../../docs/tutorials/3d/csg_tools.rst:19
#, fuzzy
msgid ""
"Like other features of Godot, CSG is supported in the form of nodes. These "
"are the CSG nodes:"
msgstr "与Godot的其他功能一样，CSG以节点的形式支持，这些是CSG节点:"

#: ../../docs/tutorials/3d/csg_tools.rst:22
msgid ":ref:`CSGBox <class_CSGBox>`"
msgstr ":ref:`CSGBox <class_CSGBox>`"

#: ../../docs/tutorials/3d/csg_tools.rst:23
#, fuzzy
msgid ":ref:`CSGCylinder <class_CSGCylinder>` (also supports cone)"
msgstr ":ref:`CSGCylinder <class_CSGCylinder>` (也支持锥形)"

#: ../../docs/tutorials/3d/csg_tools.rst:24
msgid ":ref:`CSGSphere <class_CSGSphere>`"
msgstr ":ref:`CSGSphere <class_CSGSphere>`"

#: ../../docs/tutorials/3d/csg_tools.rst:25
msgid ":ref:`CSGTorus <class_CSGTorus>`"
msgstr ":ref:`CSGTorus <class_CSGTorus>`"

#: ../../docs/tutorials/3d/csg_tools.rst:26
msgid ":ref:`CSGPolygon <class_CSGPolygon>`"
msgstr ":ref:`CSGPolygon <class_CSGPolygon>`"

#: ../../docs/tutorials/3d/csg_tools.rst:27
msgid ":ref:`CSGMesh <class_CSGMesh>`"
msgstr ":ref:`CSGMesh <class_CSGMesh>`"

#: ../../docs/tutorials/3d/csg_tools.rst:28
msgid ":ref:`CSGCombiner <class_CSGcombiner>`"
msgstr ":ref:`CSGCombiner <class_CSGcombiner>'"

#: ../../docs/tutorials/3d/csg_tools.rst:35
msgid "CSG tools features"
msgstr "CSG工具功能"

#: ../../docs/tutorials/3d/csg_tools.rst:37
msgid "Every CSG node supports 3 kinds of boolean operations:"
msgstr "每个CSG节点都支持3种布尔运算:"

#: ../../docs/tutorials/3d/csg_tools.rst:39
#, fuzzy
msgid ""
"**Union:** Geometry of both primitives is merged, intersecting geometry is "
"removed."
msgstr "联合:合并两个基元的几何，删除交叉几何。"

#: ../../docs/tutorials/3d/csg_tools.rst:41
#, fuzzy
msgid ""
"**Intersection:** Only intersecting geometry remains, the rest is removed."
msgstr "交点:仅保留相交的几何图形，其余部分将被删除。"

#: ../../docs/tutorials/3d/csg_tools.rst:42
#, fuzzy
msgid ""
"**Subtraction:** The second shape is subtracted from the first, leaving a "
"dent with its shape."
msgstr "减法:从第一个形状中减去第二个形状，留下形状的凹痕。"

#: ../../docs/tutorials/3d/csg_tools.rst:50
msgid "CSGPolygon"
msgstr "CSGPolygon"

#: ../../docs/tutorials/3d/csg_tools.rst:52
msgid ""
"The :ref:`CSGPolygon <class_CSGPolygon>` node extrude along a Polygon drawn "
"in 2D (in X,Y coordinates) in the following ways:"
msgstr ""
":ref:`CSGPolygon <class_CSGPolygon>` 节点沿着以2D(X，Y坐标)绘制的多边形以下列"
"方式拉伸:"

#: ../../docs/tutorials/3d/csg_tools.rst:55
#, fuzzy
msgid "**Depth:** Extruded back a given amount."
msgstr "深度:挤出一定量。"

#: ../../docs/tutorials/3d/csg_tools.rst:56
#, fuzzy
msgid "**Spin:** Extruded while spinning around its origin."
msgstr "旋转:在旋转它的原点时挤压。"

#: ../../docs/tutorials/3d/csg_tools.rst:57
#, fuzzy
msgid ""
"**Path:** Extruded along a Path node. This operation is commonly called "
"lofting."
msgstr "路径:沿路径节点挤出。 此操作通常称为放样。"

#: ../../docs/tutorials/3d/csg_tools.rst:64
#, fuzzy
msgid ""
"The **Path** mode must be provided with a :ref:`Path <class_Path>` node to "
"work. In the Path node, draw the path and the polygon in CSGPolygon will "
"extrude along the given path."
msgstr ""
"``Path`` 模式需要一个 ``Path`` :ref:`Path <class_Path>` 节点来运行。 在 "
"``Path`` 中，绘制路径，``CSGPolygon`` 中的多边形将沿路径挤出。"

#: ../../docs/tutorials/3d/csg_tools.rst:70
msgid "Custom meshes"
msgstr "自定义网格"

#: ../../docs/tutorials/3d/csg_tools.rst:72
#, fuzzy
msgid ""
"Any mesh can be used for :ref:`CSGMesh <class_CSGMesh>`; the mesh can be "
"modelled in other software and imported into Godot. Multiple materials are "
"supported. There are some restrictions for geometry:"
msgstr ""
"任何网格都可以用于 :ref:`CSGMesh <class_CSGMesh>`，网格可以在其他软件中建模并"
"导入Godot。 支持多种材质。 几何有一些限制:"

#: ../../docs/tutorials/3d/csg_tools.rst:76
#, fuzzy
msgid "it must be closed,"
msgstr "它必须关闭"

#: ../../docs/tutorials/3d/csg_tools.rst:77
#, fuzzy
msgid "it must not self-intersect,"
msgstr "它不能自相交"

#: ../../docs/tutorials/3d/csg_tools.rst:78
#, fuzzy
msgid "it must not contain internal faces,"
msgstr "它不得包含内部面"

#: ../../docs/tutorials/3d/csg_tools.rst:79
#, fuzzy
msgid "every edge must connect to only two other faces."
msgstr "每条边都必须连接到另外两个面"

#: ../../docs/tutorials/3d/csg_tools.rst:84
msgid "CSGCombiner"
msgstr "CSGCombiner"

#: ../../docs/tutorials/3d/csg_tools.rst:86
msgid ""
"The :ref:`CSGCombiner <class_CSGCombiner>` node is an empty shape used for "
"organization. It will only combine children nodes."
msgstr ""
":ref:`CSGCombiner <class_CSGCombiner>` 节点是用于组织的空形状。 它只会组合子"
"节点。"

#: ../../docs/tutorials/3d/csg_tools.rst:90
#, fuzzy
msgid "Processing order"
msgstr "处理顺序"

#: ../../docs/tutorials/3d/csg_tools.rst:92
#, fuzzy
msgid ""
"Every CSG node will first process its children nodes and their operations: "
"union, intersection or subtraction, in tree order, and apply them to itself "
"one after the other."
msgstr ""
"每个CSG节点将首先按树顺序处理其子节点及其操作:并集，交集或减法，并将它们一个"
"接一个地应用于自身。"

#: ../../docs/tutorials/3d/csg_tools.rst:96
#, fuzzy
msgid ""
"In the interest of performance, make sure CSG geometry remains relatively "
"simple, as complex meshes can take a while to process. If adding objects "
"together (such as table and room objects), create them as separate CSG "
"trees. Forcing too many objects in a single tree will eventually start "
"affecting performance. Only use binary operations where you actually need "
"them."
msgstr ""
"关于性能的注意事项:确保CSG几何图形保持相对简单，因为复杂网格可能需要一段时间"
"才能处理。 如果将对象添加到一起(例如表和房间对象)，请将它们创建为单独的CSG"
"树。 在单个树中强制过多的对象最终会开始影响性能。 仅在实际需要的地方使用二进"
"制操作。"

#: ../../docs/tutorials/3d/csg_tools.rst:104
msgid "Prototyping a level"
msgstr "原型设计"

#: ../../docs/tutorials/3d/csg_tools.rst:106
msgid "We will prototype a room to practice the use of CSG tools."
msgstr "我们将对房间进行原型设计以练习使用CSG工具。"

#: ../../docs/tutorials/3d/csg_tools.rst:108
#, fuzzy
msgid ""
"Working in **Orthogonal** projection gives a better view when combining the "
"CSG shapes."
msgstr "在组合CSG形状时，在“Orthogonal”视图中工作可以提供更好的视图。"

#: ../../docs/tutorials/3d/csg_tools.rst:111
msgid "Our level will contain these objects:"
msgstr ""

#: ../../docs/tutorials/3d/csg_tools.rst:113
msgid "a room,"
msgstr ""

#: ../../docs/tutorials/3d/csg_tools.rst:114
msgid "a bed,"
msgstr ""

#: ../../docs/tutorials/3d/csg_tools.rst:115
msgid "a lamp,"
msgstr ""

#: ../../docs/tutorials/3d/csg_tools.rst:116
msgid "a desk,"
msgstr ""

#: ../../docs/tutorials/3d/csg_tools.rst:117
msgid "a bookshelf."
msgstr ""

#: ../../docs/tutorials/3d/csg_tools.rst:119
msgid "Create a scene with a Spatial node as root node."
msgstr "使用Spatial节点作为根节点创建场景。"

#: ../../docs/tutorials/3d/csg_tools.rst:121
#, fuzzy
msgid ""
"The default lighting of the environment doesn't provide clear shading at "
"some angles. Change the display mode using **Display Overdraw** in the 3D "
"viewport menu, or add a DirectionalLight node to help you see clearly."
msgstr ""
"环境的默认光照不能在某个角度提供清晰的阴影，以“过度绘制”模式显示或添加方向光"
"以帮助您清楚地看到。"

#: ../../docs/tutorials/3d/csg_tools.rst:128
#, fuzzy
msgid ""
"Create a CSGBox and name it ``room``, enable **Invert Faces** and change the "
"dimensions of your room."
msgstr "然后，创建一个CSGBox并将其命名为room，选择反转面并更改房间的大小。"

#: ../../docs/tutorials/3d/csg_tools.rst:135
msgid "Next, create a CSGCombiner and name it ``desk``."
msgstr "接下来，创建一个CSGCombiner并将其命名为 ``desk`` 。"

#: ../../docs/tutorials/3d/csg_tools.rst:137
#, fuzzy
msgid "A desk has one surface and 4 legs:"
msgstr "桌子有一个表面和四条腿。"

#: ../../docs/tutorials/3d/csg_tools.rst:139
#, fuzzy
msgid ""
"Create 1 CSGBox children node in **Union** mode for the surface and adjust "
"the dimensions."
msgstr "在表面的`union``模式下创建1``CSGBox``子节点并调整大小。"

#: ../../docs/tutorials/3d/csg_tools.rst:141
#, fuzzy
msgid ""
"Create 4 CSGBox children nodes in **Union** mode for the legs and adjust the "
"dimensions."
msgstr "在“联合”模式下为腿创建4个 ``CSGBox`` 子节点并调整大小。"

#: ../../docs/tutorials/3d/csg_tools.rst:144
#, fuzzy
msgid "Adjust their placement to resemble a desk."
msgstr "调整位置以形成桌子。"

#: ../../docs/tutorials/3d/csg_tools.rst:148
#, fuzzy
msgid ""
"CSG nodes inside a CSGCombiner will only process their operation within the "
"combiner. Therefore, CSGCombiners are used to organize CSG nodes."
msgstr ""
"“CSGCombiner”中的CSG节点只会在组合器中处理它们的操作，因此，“CSGCombiners”用"
"于组织CSG节点。"

#: ../../docs/tutorials/3d/csg_tools.rst:152
#, fuzzy
msgid "Create a CSGCombiner and name it ``bed``."
msgstr "创建一个 ``CSGCombiner`` 并将其命名为 ``bed`` 。"

#: ../../docs/tutorials/3d/csg_tools.rst:154
#, fuzzy
msgid ""
"Our bed consists of 3 parts: the bed, the mattress and a pillow. Create a "
"CSGBox and adjust its dimension for the bed. Create another CSGBox and "
"adjust its dimension for the mattress."
msgstr ""
"创建一个 ``CSGBox`` 并调整其床的大小。 创建另一个 ``CSGBox`` 并调整床垫的大"
"小。"

#: ../../docs/tutorials/3d/csg_tools.rst:160
#, fuzzy
msgid ""
"We will create another CSGCombiner named ``pillow`` as the child of  "
"``bed``. The scene tree should look like this:"
msgstr ""
"我们将创建另一个 ``CSGCombiner`` 并将其命名为 ``pillow`` 作为 ``bed`` 的子节"
"点。 场景树应如下所示:"

#: ../../docs/tutorials/3d/csg_tools.rst:165
#, fuzzy
msgid ""
"We will combine 3 CSGSphere nodes in **Union** mode to form a pillow. Scale "
"the Y axis of the spheres and enable **Smooth Faces**."
msgstr ""
"我们将在 ``union`` 模式中组合3 ``CSGshpere`` 来形成一个枕头。 缩放球体的y轴并"
"启用“光滑面”。"

#: ../../docs/tutorials/3d/csg_tools.rst:170
#, fuzzy
msgid ""
"Select the ``pillow`` node and switch the mode to **Subtraction**; the "
"combined spheres will cut a hole into the mattress."
msgstr "选择`枕头'节点并将模式切换为“减法”，合并的球体将在床垫上切一个洞。"

#: ../../docs/tutorials/3d/csg_tools.rst:175
#, fuzzy
msgid ""
"Try to re-parent the ``pillow`` node to the root ``Spatial`` node; the hole "
"will disappear."
msgstr "尝试将 ``pillow`` 节点重新设置为根 ``Spatial`` 节点，该孔将消失。"

#: ../../docs/tutorials/3d/csg_tools.rst:178
#, fuzzy
msgid ""
"This is to illustrate the effect of CSG processing order. Since the root "
"node is not a CSG node, the CSGCombiner nodes are the end of the operations; "
"this shows the use of CSGCombiner to organize the CSG scene."
msgstr ""
"这是为了说明CSG流程订单的效果。 由于根节点不是CSG节点，因此 ``CSGCombiner`` "
"节点是操作的结束，这表示使用 ``CSGCombiner`` 来组织CSG场景。"

#: ../../docs/tutorials/3d/csg_tools.rst:183
#, fuzzy
msgid ""
"Undo the re-parent after observing the effect. The bed you've built should "
"look like this:"
msgstr "观察效果后撤消重新父母。"

#: ../../docs/tutorials/3d/csg_tools.rst:188
#, fuzzy
msgid "Create a CSGCombiner and name it ``lamp``."
msgstr "创建一个 ``CSGCombiner`` 并将其命名为 ``lamp`` 。"

#: ../../docs/tutorials/3d/csg_tools.rst:190
#, fuzzy
msgid ""
"A lamp consists of 3 parts: the stand, the pole and the lampshade. Create a "
"CSGCylinder, enable the **Cone** option and make it the stand. Create "
"another CSGCylinder and adjust the dimensions to use it as a pole."
msgstr ""
"创建一个 ``CSGCylinder`` 启用选项 ``cone`` 并使其成为支架。 创建另一个 "
"``CSGCylinder`` 并调整大小以将其用作极点。"

#: ../../docs/tutorials/3d/csg_tools.rst:196
#, fuzzy
msgid ""
"We will use a CSGPolygon for the lampshade. Use the **Spin** mode for the "
"CSGPolygon and draw a `trapezoid <https://en.wikipedia.org/wiki/Trapezoid>`_ "
"while in **Front View** (numeric keypad 1); this shape will extrude around "
"the origin and form the lampshade."
msgstr ""
"我们将使用 ``CSGPolygon`` 作为灯罩。 使用 ``Spin`` 模式作为 ``CSGPolygon`` 并"
"在前视图中绘制一个梯形，这个形状将在原点周围挤出并形成灯罩。"

#: ../../docs/tutorials/3d/csg_tools.rst:207
#, fuzzy
msgid "Adjust the placement of the 3 parts to make it look like a lamp."
msgstr "调整3个部分的位置，使其成为“灯”。"

#: ../../docs/tutorials/3d/csg_tools.rst:211
#, fuzzy
msgid "Create a CSGCombiner and name it ``bookshelf``."
msgstr "创建一个 ``CSGCombiner`` 并将其命名为 ``bookshelf`` 。"

#: ../../docs/tutorials/3d/csg_tools.rst:213
#, fuzzy
msgid ""
"We will use 3 CSGBox nodes for the bookshelf. Create a CSGBox and adjust its "
"dimensions; this will be the size of the bookshelf."
msgstr ""
"我们将使用3 ``CSGBox`` 作为书架。 创建一个 ``CSGBox`` 并调整其大小，这将是书"
"架的大小。"

#: ../../docs/tutorials/3d/csg_tools.rst:218
#, fuzzy
msgid ""
"Duplicate the CSGBox and shorten the dimensions of each axis and change the "
"mode to **Subtraction**."
msgstr "复制 ``CSGBox`` 并缩短每个轴的大小并将模式更改为 ``Subtraction`` 。"

#: ../../docs/tutorials/3d/csg_tools.rst:225
#, fuzzy
msgid ""
"You've almost built a shelf. Create one more CSGBox for dividing the shelf "
"into two levels."
msgstr ""
"您几乎建立了一个架子。 再创建一个 ``CSGBox`` ，用于将货架划分为两个级别。"

#: ../../docs/tutorials/3d/csg_tools.rst:230
msgid ""
"Position your furniture in your room as you like and your scene should look "
"this:"
msgstr "根据您的喜好将您的家具放在房间里，您的场景应该是这样的:"

#: ../../docs/tutorials/3d/csg_tools.rst:235
#, fuzzy
msgid ""
"You've successfully prototyped a room level with the CSG tools in Godot. CSG "
"tools can be used for designing all kinds of levels, such as a maze or a "
"city; explore its limitations when designing your game."
msgstr ""
"您使用Godot中的csg工具成功构建了一个房间级别的原型。 CSG工具可用于设计各种级"
"别，如迷宫或城市，在设计游戏时探索它的局限性。"

#: ../../docs/tutorials/3d/fps_tutorial/index.rst:2
msgid "FPS tutorial"
msgstr "FPS教程"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:4
msgid "Part 1"
msgstr "第1部分"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:7
msgid "Tutorial introduction"
msgstr "教程介绍"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:11
msgid ""
"This tutorial series will show you how to make a single player FPS game."
msgstr "本教程系列将向您展示如何制作单人FPS游戏。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:13
msgid "Throughout the course of this tutorial series, we will cover how:"
msgstr "在本系列教程的整个过程中，我们将介绍如何:"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:15
msgid "To make a first person character that can move, sprint, and jump."
msgstr "制作可以移动，冲刺和跳跃的第一人称角色。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:16
msgid ""
"To make a simple animation state machine for handling animation transitions."
msgstr "制作一个简单的动画状态机来处理动画过渡。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:17
msgid ""
"To add three weapons to the first person character, each using a different "
"way to handle bullet collisions:"
msgstr "要向第一个人物角色添加三个武器，每个武器使用不同的方式来处理子弹碰撞:"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:18
msgid "A knife (using an :ref:`Area <class_Area>`)"
msgstr "一把刀(使用 :ref:`Area <class_Area>` )"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:19
msgid "A pistol (Bullet scenes)"
msgstr "手枪(子弹场景)"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:20
msgid "A rifle (using a :ref:`Raycast <class_Raycast>`)"
msgstr "步枪(使用 :ref:`Raycast <class_Raycast>` )"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:21
msgid "To add two different types of grenades to the first person character:"
msgstr "要为第一个人角色添加两种不同类型的手榴弹:"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:22
msgid "A normal grenade"
msgstr "正常的手榴弹"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:23
msgid "A sticky grenade"
msgstr "粘手榴弹"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:24
msgid ""
"To add the ability to grab and throw :ref:`RigidBody <class_RigidBody>` nodes"
msgstr "添加抓取和抛出的能力 :ref:`RigidBody <class_RigidBody>` 节点"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:25
msgid "To add joypad input for the player"
msgstr "为游戏角色添加游戏手柄输入"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:26
msgid "To add ammo and reloading for all weapons that consume ammo."
msgstr "为所有消耗弹药的武器添加弹药和重装。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:27
msgid "To add ammo and health pick ups"
msgstr "添加弹药和健康拾取"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:28
msgid "In two sizes: big and small"
msgstr "有两种大小:大小"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:29
msgid "To add an automatic turret"
msgstr "添加自动炮塔"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:30
msgid "That can fire using bullet objects or a :ref:`Raycast <class_Raycast>`"
msgstr "这可以使用bullet对象或 :ref:`Raycast <class_Raycast>` 来触发"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:31
msgid "To add targets that break when they've taken enough damage"
msgstr "添加在受到足够伤害时破坏的目标"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:32
msgid "To add sounds that play when the guns fire."
msgstr "添加枪支发射时发出的声音。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:33
msgid "To add a simple main menu:"
msgstr "要添加简单的主菜单:"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:34
msgid "With an options menu for changing how the game runs"
msgstr "使用选项菜单更改游戏的运行方式"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:35
msgid "With a level select screen"
msgstr "使用级别选择屏幕"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:36
msgid "To add a universal pause menu we can access anywhere"
msgstr "要添加通用暂停菜单，我们可以随时随地访问"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:38
msgid ""
"While this tutorial can be completed by beginners, it is highly advised to "
"complete :ref:`doc_your_first_game`, if you are new to Godot and/or game "
"development **before** going through this tutorial series."
msgstr ""
"虽然这个教程可以由初学者完成，但强烈建议完成 :ref:`doc_your_first_game` ，如"
"果您是新手Godot和/或游戏开发 **之前** 通过本教程系列。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:43
#, fuzzy
msgid ""
"Remember: Making 3D games is much harder than making 2D games. If you do not "
"know how to make 2D games, you will likely struggle making 3D games."
msgstr ""
"请记住:制作3D游戏要比制作2D游戏困难得多。 如果您不知道如何制作2D游戏，您可能"
"会很难制作3D游戏。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:46
#, fuzzy
msgid ""
"This tutorial assumes you have experience working with the Godot editor, "
"basic programming experience in GDScript, and basic experience in game "
"development."
msgstr ""
"本教程假设您具有使用Godot编辑器的经验，具有GDScript的基本编程经验，并且具有游"
"戏开发的基本经验。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:49
msgid ""
"You can find the start assets for this tutorial here: :download:"
"`Godot_FPS_Starter.zip <files/Godot_FPS_Starter.zip>`"
msgstr ""
"您可以在这里找到本教程的起始资源: :download:`Godot_FPS_Starter.zip <files / "
"Godot_FPS_Starter.zip>`"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:51
msgid ""
"The provided starter assets contain an animated 3D model, a bunch of 3D "
"models for making levels, and a few scenes already configured for this "
"tutorial."
msgstr ""
"提供的初始化资源包含动画3D模型，一组用于制作关卡的3D模型，以及已为本教程配置"
"的一些场景。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:54
msgid ""
"All assets provided (unless otherwise noted) were originally created by "
"TwistedTwigleg, with changes/additions by the Godot community. All original "
"assets provided for this tutorial are released under the ``MIT`` license."
msgstr ""
"提供的所有资源(除非另有说明)最初由TwistedTwigleg创建，由Godot社区进行更改/添"
"加。 本教程提供的所有原始资源都在“MIT”许可下发布。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:57
#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:1027
#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:44
msgid ""
"Feel free to use these assets however you want! All original assets belong "
"to the Godot community, with the other assets belonging to those listed "
"below:"
msgstr ""
"您可以随意使用这些资源！ 所有原始资源均属于Godot社区，其他资源属于以下列出的"
"资源:"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:59
msgid ""
"The skybox is created by **StumpyStrust** on OpenGameArt. The skybox used is "
"licensed under ``CC0``."
msgstr ""
"天空盒由OpenGameArt上的** StumpyStrust **创建。 使用的天空盒在“CC0”下获得许"
"可。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:62
#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:1032
msgid ""
"The font used is **Titillium-Regular**, and is licensed under the ``SIL Open "
"Font License, Version 1.1``."
msgstr ""
"使用的字体是** Titillium-Regular **，并根据``SIL Open Font License，Version "
"1.1`许可。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:64
msgid ""
"You can find the finished project for each part at the bottom of each part's "
"page"
msgstr "您可以在每个零件页面底部找到每个零件的完成项目"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:67
#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:7
#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:7
#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:7
#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:7
#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:7
#, fuzzy
msgid "Part overview"
msgstr "零件概述"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:69
msgid ""
"In this part we will be making a first person player that can move around "
"the environment."
msgstr "在这一部分，我们将制作一个可以在环境中移动的第一人称游戏角色。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:74
#, fuzzy
msgid ""
"By the end of this part, you will have a working first-person character who "
"can move around the game environment, sprint, look around with a mouse based "
"first person camera, jump into the air, and turn a flash light on and off."
msgstr ""
"在这部分结束时，您将拥有一个可以在游戏环境中移动的第一人称角色，用基于鼠标的"
"第一人称相机环顾四周，可以跳到空中，打开和关闭闪光灯，以及冲刺。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:78
#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:60
msgid "Getting everything ready"
msgstr "准备好一切"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:80
#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:62
msgid "Launch Godot and open up the project included in the starter assets."
msgstr "启动Godot并打开启动资源中包含的项目。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:82
#, fuzzy
msgid ""
"While these assets are not necessarily required to use the scripts provided "
"in this tutorial, they will make the tutorial much easier to follow, as "
"there are several pre-setup scenes we will be using throughout the tutorial "
"series."
msgstr ""
"虽然这些资源不一定需要使用本教程中提供的脚本，但它们将使教程更容易理解，因为"
"我们将在整个教程系列中使用几个预设置场景。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:86
#, fuzzy
msgid ""
"First, open the project settings and go to the \"Input Map\" tab. You'll "
"find several actions have already been defined. We will be using these "
"actions for our player. Feel free to change the keys bound to these actions "
"if you want."
msgstr ""
"首先，打开项目设置并转到“输入映射”选项卡。 您会发现已经定义了几个动作。 我们"
"将为我们的游戏角色使用这些操作。 如果需要，可以随意更改绑定到这些操作的键。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:92
msgid "Let's take a second to see what we have in the starter assets."
msgstr "让我们花点时间看看我们在初始资源中的含义。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:94
msgid ""
"Included in the starter assets are several scenes. For example, in ``res://"
"`` we have 14 scenes, most of which we will be visiting as we go through "
"this tutorial series."
msgstr ""
"初始化资源中包含几个场景。 例如，在``res://``中我们有14个场景，我们将在本教程"
"系列中访问其中的大多数场景。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:97
msgid "For now let's open up ``Player.tscn``."
msgstr "现在让我们打开 ``Player.tscn`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:99
#, fuzzy
msgid ""
"There are a bunch of scenes and a few textures in the ``Assets`` folder. You "
"can look at these if you want, but we will not be exploring through "
"``Assets`` in this tutorial series. ``Assets`` contains all the models used "
"for each of the levels, as well as some textures and materials."
msgstr ""
"在 ``Assets`` 文件夹中有一堆场景和一些纹理。 如果您愿意，可以查看这些内容，但"
"我们不会通过本系列教程中的“资源”来探索。 ``Assets``包含用于每个级别的所有模"
"型，以及一些纹理和材质。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:104
msgid "Making the FPS movement logic"
msgstr "制作FPS运动逻辑"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:106
msgid ""
"Once you have ``Player.tscn`` open, let's take a quick look at how it is set "
"up"
msgstr "打开“Player.tscn”后，让我们快速了解它是如何设置的"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:110
msgid ""
"First, notice how the player's collision shapes are set up. Using a vertical "
"pointing capsule as the collision shape for the player is fairly common in "
"most first person games."
msgstr ""
"首先，注意如何设置游戏角色的碰撞形状。 在大多数第一人称游戏中，使用垂直指向胶"
"囊作为游戏角色的碰撞形状是相当普遍的。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:113
msgid ""
"We are adding a small square to the 'feet' of the player so the player does "
"not feel like they are balancing on a single point."
msgstr ""
"我们在游戏角色的“脚”上添加一个小方块，这样游戏角色就不会觉得他们在单点上保持"
"平衡。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:116
msgid ""
"We do want the 'feet' slightly higher than the bottom of the capsule so we "
"can roll over slight edges. Where to place the 'feet' is dependent on your "
"levels and how you want your player to feel."
msgstr ""
"我们确实希望“脚”略高于胶囊的底部，因此我们可以翻过轻微的边缘。 放置“脚”的位置"
"取决于您的水平以及您希望游戏角色的感受。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:119
#, fuzzy
msgid ""
"Many times the player will notice the collision shape being circular when "
"they walk to an edge and slide off. We are adding the small square at the "
"bottom of the capsule to reduce sliding on, and around, edges."
msgstr ""
"很多时候，游戏角色会注意到碰撞形状在走到边缘并滑落时是如何形成圆形的。 我们在"
"胶囊底部添加了一个小方块，以减少边缘和周围的滑动。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:123
#, fuzzy
msgid ""
"Another thing to notice is how many nodes are children of "
"``Rotation_Helper``. This is because ``Rotation_Helper`` contains all the "
"nodes we want to rotate on the ``X`` axis (up and down). The reason behind "
"this is so we can rotate ``Player`` on the ``Y`` axis, and "
"``Rotation_helper`` on the ``X`` axis."
msgstr ""
"需要注意的另一件事是有多少节点是 ``Rotation_Helper`` 的子节点。 这是因为 "
"``Rotation_Helper`` 包含我们想要在 ``X`` 轴上旋转的所有节点(向上和向下)。 这"
"背后的原因是我们可以在 ``Y`` 轴上旋转 ``Player`` ，在 ``X`` 轴上旋转 "
"``Rotation_helper`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:128
#, fuzzy
msgid ""
"Had we not used ``Rotation_helper``, we would've likely had cases of "
"rotating on both the ``X`` and ``Y`` axes simultaneously, potentially "
"further degenerating into a state of rotation on all three axes in some "
"cases."
msgstr ""
"如果我们不使用 ``Rotation_helper`` 那么我们可能会遇到同时旋转 ``X`` 和 ``Y`` "
"轴的情况。 这会导致不良结果，因为在某些情况下我们可以在所有三个轴上旋转。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:132
msgid "See :ref:`using transforms <doc_using_transforms>` for more information"
msgstr "有关更多信息，请参阅 :ref:`使用转换<doc_using_transforms>`"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:136
msgid "Attach a new script to the ``Player`` node and call it ``Player.gd``."
msgstr "将一个新脚本附加到 ``Player`` 节点并将其命名为 ``Player.gd`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:138
msgid ""
"Let's program our player by adding the ability to move around, look around "
"with the mouse, and jump. Add the following code to ``Player.gd``:"
msgstr ""
"让我们通过添加移动能力，用鼠标环顾四周并跳跃来编程我们的游戏角色。 将以下代码"
"添加到``Player.gd``:"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:243
msgid "This is a lot of code, so let's break it down function by function:"
msgstr "这是很多代码，所以让我们按功能分解它:"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:245
msgid ""
"While copy and pasting code is ill advised, as you can learn a lot from "
"manually typing the code in, you can copy and paste the code from this page "
"directly into the script editor."
msgstr ""
"虽然不建议复制和粘贴代码，因为您可以通过手动输入代码来学习很多东西，但您可以"
"将此页面中的代码直接复制并粘贴到脚本编辑器中。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:248
msgid ""
"If you do this, all of the code copied will be using spaces instead of tabs."
msgstr "如果这样做，所有复制的代码将使用空格而不是制表符。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:250
#, fuzzy
msgid ""
"To convert the spaces to tabs in the script editor, click the \"edit\" menu "
"and select \"Convert Indent To Tabs\". This will convert all the spaces into "
"tabs. You can select \"Convert Indent To Spaces\" to convert tabs back into "
"spaces."
msgstr ""
"要在脚本编辑器中将空格转换为选项卡，请单击“编辑”菜单并选择“将缩进转换为选项"
"卡”。 这会将所有空格转换为制表符。 您可以选择“将缩进转换为空格”以将t转换回空"
"格。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:255
msgid ""
"First, we define some class variables to dictate how our player will move "
"about the world."
msgstr "首先，我们定义一些类变量来决定我们的游戏角色将如何在世界范围内移动。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:257
msgid ""
"Throughout this tutorial, **variables defined outside functions will be "
"referred to as \"class variables\"**. This is because we can access any of "
"these variables from any place in the script."
msgstr ""
"在本教程中， **函数外部定义的变量将被称为“类变量”** 。 这是因为我们可以从脚本"
"中的任何位置访问这些变量中的任何一个。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:261
msgid "Let's go through each of the class variables:"
msgstr "让我们来看看每个类变量:"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:263
msgid "``GRAVITY``: How strong gravity pulls us down."
msgstr "``GRAVITY``:强大的重力让我们失望。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:264
msgid "``vel``: Our :ref:`KinematicBody <class_KinematicBody>`'s velocity."
msgstr "``vel``:我们的 :ref:`KinematicBody <class_KinematicBody>` 的速度。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:265
msgid ""
"``MAX_SPEED``: The fastest speed we can reach. Once we hit this speed, we "
"will not go any faster."
msgstr ""
"``MAX_SPEED``:我们可以达到的最快速度。 一旦我们达到这个速度，我们就不会更快。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:266
msgid "``JUMP_SPEED``: How high we can jump."
msgstr "``JUMP_SPEED``:我们能跳得多高。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:267
#, fuzzy
msgid ""
"``ACCEL``: How quickly we accelerate. The higher the value, the sooner we "
"get to max speed."
msgstr ""
"``ACCEL``:我们加速的速度有多快。 值越高，我们达到最大速度的速度就越快。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:268
#, fuzzy
msgid ""
"``DEACCEL``: How quickly we are going to decelerate. The higher the value, "
"the sooner we will come to a complete stop."
msgstr "``DEACCEL``:我们减速的速度有多快。 价值越高，我们就越快完全停止。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:269
msgid ""
"``MAX_SLOPE_ANGLE``: The steepest angle our :ref:`KinematicBody "
"<class_KinematicBody>` will consider as a 'floor'."
msgstr ""
"``MAX_SLOPE_ANGLE``:我们最陡的角度 :ref:`KinematicBody "
"<class_KinematicBody>` 将被视为'floor'。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:270
msgid "``camera``: The :ref:`Camera <class_Camera>` node."
msgstr "``camera``: :ref:`Camera <class_Camera>` 节点。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:271
msgid ""
"``rotation_helper``: A :ref:`Spatial <class_Spatial>` node holding "
"everything we want to rotate on the X axis (up and down)."
msgstr ""
"``rotation_helper``:一个 :ref:`Spatial <class_Spatial>` 节点，包含我们想要在X"
"轴上旋转的所有内容(向上和向下)。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:272
msgid ""
"``MOUSE_SENSITIVITY``: How sensitive the mouse is. I find a value of "
"``0.05`` works well for my mouse, but you may need to change it based on how "
"sensitive your mouse is."
msgstr ""
"``MOUSE_SENSITIVITY``:鼠标的敏感程度。 我发现“0.05”的值适用于我的鼠标，但您可"
"能需要根据鼠标的敏感程度进行更改。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:274
msgid ""
"You can tweak many of these variables to get different results. For example, "
"by lowering ``GRAVITY`` and/or increasing ``JUMP_SPEED`` you can get a more "
"'floaty' feeling character. Feel free to experiment!"
msgstr ""
"您可以调整其中的许多变量以获得不同的结果。 例如，通过降低 ``GRAVITY`` 和/或增"
"加 ``JUMP_SPEED`` ，您可以获得一个更“浮动”的感觉角色。 随意尝试！"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:278
msgid ""
"You may have noticed that ``MOUSE_SENSITIVITY`` is written in all caps like "
"the other constants, but ``MOUSE_SENSITIVITY`` is not a constant."
msgstr ""
"您可能已经注意到 ``MOUSE_SENSITIVITY`` 写在所有大写字母中，就像其他常量一样，"
"但 ``MOUSE_SENSITIVITY`` 不是常量。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:280
msgid ""
"The reason behind this is we want to treat it like a constant variable (a "
"variable that cannot change) throughout our script, but we want to be able "
"to change the value later when we add customizable settings. So, in an "
"effort to remind ourselves to treat it like a constant, it's named in all "
"caps."
msgstr ""
"这背后的原因是我们希望在整个脚本中将其视为一个常量变量(一个无法更改的变量)，"
"但我们希望能够在以后添加可自定义设置时更改该值。 因此，为了提醒自己将其视为一"
"个常量，它以全部大写命名。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:285
msgid "Now let's look at the ``_ready`` function:"
msgstr "现在让我们看一下 ``_ready`` 函数:"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:287
msgid ""
"First we get the ``camera`` and ``rotation_helper`` nodes and store them "
"into their variables."
msgstr ""
"首先，我们获得“camera”和“rotation_helper”节点，并将它们存储到它们的变量中。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:289
#, fuzzy
msgid ""
"Then we need to set the mouse mode to captured, so the mouse cannot leave "
"the game window."
msgstr "然后我们需要将鼠标模式设置为capture，这样鼠标就不能离开游戏窗口。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:291
#, fuzzy
msgid ""
"This will hide the mouse and keep it at the center of the screen. We do this "
"for two reasons: The first reason being we do not want the player to see "
"their mouse cursor as they play."
msgstr ""
"这将隐藏鼠标并将其保持在屏幕的中心。 我们这样做有两个原因:第一个原因是我们不"
"希望游戏角色在玩游戏时看到他们的鼠标光标。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:294
#, fuzzy
msgid ""
"The second reason is because we do not want the cursor to leave the game "
"window. If the cursor leaves the game window there could be instances where "
"the player clicks outside the window, and then the game would lose focus. To "
"assure neither of these issues happens, we capture the mouse cursor."
msgstr ""
"第二个原因是因为我们不希望光标离开游戏窗口。 如果光标离开游戏窗口，则可能存在"
"游戏角色在窗口外点击的情况，然后游戏将失去焦点。 为了确保这些问题都不会发生，"
"我们捕获鼠标光标。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:298
msgid ""
"see :ref:`Input documentation <class_Input>` for the various mouse modes. We "
"will only be using ``MOUSE_MODE_CAPTURED`` and ``MOUSE_MODE_VISIBLE`` in "
"this tutorial series."
msgstr ""
"请参阅 :ref:`输入文档<class_Input>` 用于各种鼠标模式。 我们将只在本教程系列中"
"使用 ``MOUSE_MODE_CAPTURED`` 和 ``MOUSE_MODE_VISIBLE`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:303
msgid "Next let's take a look at ``_physics_process``:"
msgstr "接下来让我们来看看``_physics_process``:"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:305
msgid ""
"All we're doing in ``_physics_process`` is calling two functions: "
"``process_input`` and ``process_movement``."
msgstr ""
"我们在 ``_physics_process`` 中所做的就是调用两个函数: ``process_input`` 和 "
"``process_movement`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:307
#, fuzzy
msgid ""
"``process_input`` will be where we store all the code relating to player "
"input. We want to call it first, before anything else, so we have fresh "
"player input to work with."
msgstr ""
"``process_input``将存储与游戏角色输入相关的所有代码。 我们希望在其他任何事情"
"之前先调用它，以便我们有新的游戏角色输入。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:310
#, fuzzy
msgid ""
"``process_movement`` is where we'll send all the data necessary to the :ref:"
"`KinematicBody <class_KinematicBody>` so it can move through the game world."
msgstr ""
"``process_movement`` 是我们将所有必要的数据发送到 :ref:`KinematicBody "
"<class_KinematicBody>` 所以它可以在游戏世界中移动。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:315
msgid "Let's look at ``process_input`` next:"
msgstr "让我们看看下面的``process_input``:"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:317
msgid "First we set ``dir`` to an empty :ref:`Vector3 <class_Vector3>`."
msgstr "首先我们将 ``dir`` 设置为空 :ref:`Vector3 <class_Vector3>`。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:319
msgid ""
"``dir`` will be used for storing the direction the player intends to move "
"towards. Because we do not want the player's previous input to effect the "
"player beyond a single ``process_movement`` call, we reset ``dir``."
msgstr ""
"``dir``将用于存储游戏角色打算移动的方向。 因为我们不希望游戏角色以前的输入影"
"响游戏角色超过单个 ``process_movement`` 调用，所以我们重置 ``dir`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:322
msgid ""
"Next we get the camera's global transform and store it as well, into the "
"``cam_xform`` variable."
msgstr "接下来，我们获取相机的全局变换并将其存储到 ``cam_xform`` 变量中。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:324
msgid ""
"The reason we need the camera's global transform is so we can use its "
"directional vectors. Many have found directional vectors confusing, so let's "
"take a second to explain how they work:"
msgstr ""
"我们需要相机的全局变换的原因是我们可以使用它的方向向量。 许多人发现方向向量令"
"人困惑，所以让我们花一点时间来解释它们是如何工作的:"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:329
msgid ""
"World space can be defined as: The space in which all objects are placed in, "
"relative to a constant origin point. Every object, no matter if it is 2D or "
"3D, has a position in world space."
msgstr ""
"世界空间可以定义为:相对于恒定原点，放置所有对象的空间。 每个物体，无论是2D还"
"是3D，都在世界空间中占有一席之地。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:332
msgid ""
"To put it another way: world space is the space in a universe where every "
"object's position, rotation, and scale can be measured by a single, known, "
"fixed point called the origin."
msgstr ""
"换句话说:世界空间是宇宙中的空间，每个物体的位置，旋转和比例都可以通过称为原点"
"的单个已知固定点来测量。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:335
msgid ""
"In Godot, the origin is at position ``(0, 0, 0)`` with a rotation of ``(0, "
"0, 0)`` and a scale of ``(1, 1, 1)``."
msgstr "在Godot中，原点位于``(0,0,0)``，旋转为``(0,0,0)``，标度为``(1,1,1)``。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:337
msgid ""
"When you open up the Godot editor and select a :ref:`Spatial "
"<class_Spatial>` based node, a gizmo pops up. Each of the arrows points "
"using world space directions by default."
msgstr ""
"当您打开Godot编辑器并选择一个 :ref:`Spatial <class_Spatial>` 基于节点时，会弹"
"出一个Gizmo。 默认情况下，每个箭头都使用世界空间方向指向。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:340
msgid ""
"If you want to move using the world space directional vectors, you'd do "
"something like this:"
msgstr "如果您想使用世界空间方向向量移动，您会做这样的事情:"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:353
msgid ""
"Notice how we do not need to do any calculations to get world space "
"directional vectors. We can define a few :ref:`Vector3 <class_Vector3>` "
"variables and input the values pointing in each direction."
msgstr ""
"请注意我们如何不需要进行任何计算来获得世界空间方向向量。 我们可以定义一些 :"
"ref:`Vector3 <class_Vector3>` 变量并输入指向每个方向的值。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:356
msgid "Here is what world space looks like in 2D:"
msgstr "以下是2D中的世界空间:"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:358
msgid ""
"The following images are just examples. Each arrow/rectangle represents a "
"directional vector"
msgstr "以下图片仅为示例。 每个箭头/矩形表示方向向量"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:362
#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:405
msgid "And here is what it looks like for 3D:"
msgstr "这就是3D的样子:"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:366
msgid ""
"Notice how in both examples, the rotation of the node does not change the "
"directional arrows. This is because world space is a constant. No matter how "
"you translate, rotate, or scale an object, world space will *always point in "
"the same direction*."
msgstr ""
"请注意，在两个示例中，节点的旋转不会更改方向箭头。 这是因为世界空间是一个常"
"数。 无论您如何平移，旋转或缩放对象，世界空间都将*始终指向相同的方向*。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:370
msgid ""
"Local space is different, because it takes the rotation of the object into "
"account."
msgstr "局部空间不同，因为它考虑了对象的旋转。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:372
#, fuzzy
msgid ""
"Local space can be defined as follows: The space in which an object's "
"position is the origin of the universe. Because the position of the origin "
"can be at ``N`` many locations, the values derived from local space change "
"with the position of the origin."
msgstr ""
"局部空间可以定义如下:对象位置是宇宙起源的空间。 因为原点的位置可以在“N”多个位"
"置，所以从局部空间导出的值随着原点的位置而变化。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:377
msgid ""
"This stack overflow question has a much better explanation of world space "
"and local space."
msgstr "这个堆栈溢出问题对世界空间和局部空间有更好的解释。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:379
msgid ""
"https://gamedev.stackexchange.com/questions/65783/what-are-world-space-and-"
"eye-space-in-game-development (Local space and eye space are essentially the "
"same thing in this context)"
msgstr ""
"https://gamedev.stackexchange.com/questions/65783/what-are-world-space-and-"
"eye-space-in-game-development(在这种情况下，局部空间和眼睛空间基本相同)"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:382
msgid ""
"To get a :ref:`Spatial <class_Spatial>` node's local space, we need to get "
"its :ref:`Transform <class_Transform>`, so then we can get the :ref:`Basis "
"<class_Basis>` from the :ref:`Transform <class_Transform>`."
msgstr ""
"要获得 :ref:`Spatial <class_Spatial>` 节点的局部空间，我们需要得到它 :ref:"
"`Transform <class_Transform>` ，这样我们就可以从 :ref:`Transform "
"<class_Transform>` 得到 :ref:`Basis <class_Basis>` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:385
msgid ""
"Each :ref:`Basis <class_Basis>` has three vectors: ``X``, ``Y``, and ``Z``. "
"Each of those vectors point towards each of the local space vectors coming "
"from that object."
msgstr ""
"每个 :ref:`Basis <class_Basis>` 有三个向量: ``X`` ， ``Y`` 和 ``Z``。 这些向"
"量中的每一个指向来自该对象的每个局部空间向量。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:388
msgid ""
"To use the :ref:`Spatial <class_Spatial>` node's local directional vectors, "
"we use this code:"
msgstr ""
"要使用 :ref:`Spatial <class_Spatial>` 节点的本地方向向量，我们使用以下代码:"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:401
msgid "Here is what local space looks like in 2D:"
msgstr "以下是2D中的局部空间:"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:409
msgid ""
"Here is what the :ref:`Spatial <class_Spatial>` gizmo shows when you are "
"using local space mode. Notice how the arrows follow the rotation of the "
"object on the left, which looks exactly the same as the 3D example for local "
"space."
msgstr ""
"以下是 :ref:`Spatial <class_Spatial>` 装置在您使用本地空间模式时显示。 注意箭"
"头如何跟随左侧对象的旋转，这看起来与局部空间的3D示例完全相同。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:413
#, fuzzy
msgid ""
"You can change between local and world space modes by pressing T or the "
"little cube button when you have a :ref:`Spatial <class_Spatial>` based node "
"selected."
msgstr ""
"当您选择了 :ref:`Spatial <class_Spatial>` 基于节点时，可以通过按小立方体按钮"
"在本地和世界空间模式之间切换。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:418
#, fuzzy
msgid ""
"Local vectors are confusing even for more experienced game developers, so do "
"not worry if this all doesn't make a lot of sense. The key thing to remember "
"about local vectors is that we are using local coordinates to get direction "
"from the object's point of view, as opposed to using world vectors, which "
"give direction from the world's point of view."
msgstr ""
"即使对于经验丰富的游戏开发者来说，本地向量也会让人感到困惑，所以不要担心这一"
"切都没有多大意义。 关于局部向量要记住的关键是我们使用局部坐标从对象的角度获取"
"方向，而不是使用从世界的角度给出方向的世界向量。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:424
msgid "Okay, back to ``process_input``:"
msgstr "好的，回到``process_input``:"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:426
#, fuzzy
msgid ""
"Next we make a new variable called ``input_movement_vector`` and assign it "
"to an empty :ref:`Vector2 <class_Vector2>`. We will use this to make a "
"virtual axis of sorts, to map the player's input to movement."
msgstr ""
"接下来，我们创建一个名为 ``input_movement_vector`` 的新变量，并将其赋值为空 :"
"ref:`Vector2 <class_Vector2>`。 我们将使用它来制作各种虚拟轴，以便将游戏角色"
"的输入映射到移动。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:429
msgid ""
"This may seem overkill for just the keyboard, but this will make sense later "
"when we add joypad input."
msgstr "这对于键盘来说似乎有些过分，但是当我们添加游戏手柄输入时，这将有意义。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:431
#, fuzzy
msgid ""
"Based on which directional movement action is pressed, we add to or subtract "
"from ``input_movement_vector``."
msgstr ""
"根据按下的方向移动动作，我们在 ``input_movement_vector`` 中添加或删除。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:433
msgid ""
"After we've checked each of the directional movement actions, we normalize "
"``input_movement_vector``. This makes it where ``input_movement_vector``'s "
"values are within a ``1`` radius unit circle."
msgstr ""
"在我们检查了每个定向运动动作之后，我们将 ``input_movement_vector`` 标准化。 "
"这使得 ``input_movement_vector`` 的值在“1”半径单位圆内。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:436
msgid ""
"Next we add the camera's local ``Z`` vector times ``input_movement_vector."
"y`` to ``dir``. This is so when the player presses forward or backwards, we "
"add the camera's local ``Z`` axis so the player moves forward or backwards "
"in relation to the camera."
msgstr ""
"接下来，我们将摄像机的本地 ``Z`` 向量时间 ``input_movement_vector.y`` 添加到 "
"``dir`` 。 这是当游戏角色向前或向后按下时，我们添加相机的本地“Z”轴，以便游戏"
"角色相对于相机向前或向后移动。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:439
msgid ""
"Because the camera is rotated by ``-180`` degrees, we have to flip the ``Z`` "
"directional vector. Normally forward would be the positive Z axis, so using "
"``basis.z.normalized()`` would work, but we are using ``-basis.z."
"normalized()`` because our camera's Z axis faces backwards in relation to "
"the rest of the player."
msgstr ""
"因为相机旋转了“-180”度，我们必须翻转“Z`”方向向量。 通常向前是正Z轴，所以使用 "
"``basis.z.normalized()`` 会起作用，但是我们使用 ``-basis.z.normalized()`` 因"
"为我们的相机的Z轴面向后方 对其余的游戏角色。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:444
msgid ""
"We do the same thing for the camera's local ``X`` vector, and instead of "
"using ``input_movement_vector.y`` we instead use ``input_movement_vector."
"x``. This makes it where the player moves left/right in relation to the "
"camera when the player presses left/right."
msgstr ""
"我们对相机的本地 ``X`` 向量做同样的事情，而不是使用 ``input_movement_vector."
"y`` 我们改为使用 ``input_movement_vector.x`` 。 当游戏角色向左/向右按下时，这"
"使得游戏角色相对于相机向左/向右移动。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:447
msgid ""
"Next we check if the player is on the floor using :ref:`KinematicBody "
"<class_KinematicBody>`'s ``is_on_floor`` function. If it is, then we check "
"to see if the \"movement_jump\" action has just been pressed. If it has, "
"then we set the player's ``Y`` velocity to ``JUMP_SPEED``."
msgstr ""
"接下来我们使用 :ref:`KinematicBody <class_KinematicBody>` 的 ``is_on_floor`` "
"函数检查游戏角色是否在场上。 如果是，那么我们检查是否刚刚按下"
"了“movement_jump”动作。 如果有，那么我们将游戏角色的“Y”速度设置"
"为“JUMP_SPEED”。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:451
msgid ""
"Because we're setting the Y velocity, the player will jump into the air."
msgstr "因为我们正在设置Y速度，所以游戏角色将跳到空中。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:453
msgid ""
"Then we check for the ``ui_cancel`` action. This is so we can free/capture "
"the mouse cursor when the ``escape`` button is pressed. We do this because "
"otherwise we'd have no way to free the cursor, meaning it would be stuck "
"until you terminate the runtime."
msgstr ""
"然后我们检查 ``ui_cancel`` 动作。 这样我们就可以在按下 ``escape`` 按钮时释放/"
"捕获鼠标光标。 我们这样做是因为否则我们无法释放光标，这意味着它会在您终止运行"
"时停止。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:457
#, fuzzy
msgid ""
"To free/capture the cursor, we check to see if the mouse is visible (freed) "
"or not. If it is, we capture it, and if it's not, we make it visible (free "
"it)."
msgstr ""
"要释放/捕获光标，我们检查鼠标是否可见(释放)。 如果是，我们捕获它，如果它不是"
"我们让它可见(释放它)。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:459
msgid ""
"That's all we're doing right now for ``process_input``. We'll come back "
"several times to this function as we add more complexities to our player."
msgstr ""
"这就是我们现在为 ``process_input`` 所做的一切。 我们会多次回到此功能，因为我"
"们会为游戏角色增加更多复杂性。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:463
msgid "Now let's look at ``process_movement``:"
msgstr "现在让我们看一下``process_movement``:"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:465
#, fuzzy
msgid ""
"First we ensure that ``dir`` does not have any movement on the ``Y`` axis by "
"setting it's ``Y`` value to zero."
msgstr ""
"首先，我们通过将 ``Y`` 值设置为零来确保 ``dir`` 在 ``Y`` 轴上没有任何运动。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:467
#, fuzzy
msgid ""
"Next we normalize ``dir`` to ensure we're within a ``1`` radius unit circle. "
"This makes it where we're moving at a constant speed regardless of whether "
"the player is moving straight or diagonally. If we did not normalize, the "
"player would move faster on the diagonal than when going straight."
msgstr ""
"接下来我们规范化 ``dir`` 以确保我们处于一个“1”半径单位圆内。 无论游戏角色是直"
"线移动还是对角线移动，这都是我们以恒定速度移动的地方。 如果我们没有标准化，那"
"么游戏角色在对角线上移动的速度要比直线移动时快。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:470
msgid ""
"Next we add gravity to the player by adding ``GRAVITY * delta`` to the "
"player's ``Y`` velocity."
msgstr ""
"接下来，我们通过将“GRAVITY * delta”添加到游戏角色的“Y”速度来为游戏角色增加重"
"力。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:472
msgid ""
"After that we assign the player's velocity to a new variable (called "
"``hvel``) and remove any movement on the ``Y`` axis."
msgstr ""
"之后我们将游戏角色的速度分配给一个新的变量(称为“hvel”)，并移除“Y”轴上的任何移"
"动。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:474
msgid ""
"Next we set a new variable (``target``) to the player's direction vector. "
"Then we multiply that by the player's max speed so we know how far the "
"player will move in the direction provided by ``dir``."
msgstr ""
"接下来，我们为游戏角色的方向向量设置一个新变量(``target``)。 然后我们将其乘以"
"游戏角色的最大速度，以便我们知道游戏角色将在“dir”提供的方向上移动多远。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:477
msgid "After that we make a new variable for acceleration, named ``accel``."
msgstr "之后我们为加速创建一个新变量，名为 ``accel`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:479
msgid ""
"We then take the dot product of ``hvel`` to see if the player is moving "
"according to ``hvel``. Remember, ``hvel`` does not have any ``Y`` velocity, "
"meaning we are only checking if the player is moving forwards, backwards, "
"left, or right."
msgstr ""
"然后我们采用 ``hvel`` 的点积来看看游戏角色是否按照 ``hvel`` 移动。 记住， "
"``hvel`` 没有任何“Y”速度，这意味着我们只检查游戏角色是向前，向后，向左还是向"
"右移动。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:483
#, fuzzy
msgid ""
"If the player is moving according to ``hvel``, then we set ``accel`` to the "
"``ACCEL`` constant so the player will accelerate, otherwise we set ``accel`` "
"to our ``DEACCEL`` constant so the player will decelerate."
msgstr ""
"如果游戏角色按照 ``hvel`` 移动，那么我们将 ``accel`` 设置为 ``ACCEL`` 常量，"
"这样游戏角色就会加速，否则我们将``accel`设置为 ``DEACCEL`` 常数 所以游戏角色"
"会减速。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:486
msgid ""
"Then we interpolate the horizontal velocity, set the player's ``X`` and "
"``Z`` velocity to the interpolated horizontal velocity, and call "
"``move_and_slide`` to let the :ref:`KinematicBody <class_KinematicBody>` "
"handle moving the player through the physics world."
msgstr ""
"然后我们插入水平速度，将游戏角色的“X”和“Z”速度设置为插值水平速度，并调"
"用“move_and_slide”以让 :ref:`KinematicBody <class_KinematicBody>` 处理移动 游"
"戏角色通过物理世界。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:489
msgid ""
"All of the code in ``process_movement`` is exactly the same as the movement "
"code from the Kinematic Character demo!"
msgstr "``process_movement``中的所有代码都与运动角色演示中的移动代码完全相同！"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:493
msgid ""
"The final function we have is the ``_input`` function, and thankfully it's "
"fairly short:"
msgstr "我们的最后一个函数是 ``_input`` 函数，谢天谢地它很简短:"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:495
#, fuzzy
msgid ""
"First we make sure that the event we are dealing with is an :ref:"
"`InputEventMouseMotion <class_InputEventMouseMotion>` event. We also want to "
"check if the cursor is captured, as we do not want to rotate if it is not."
msgstr ""
"首先，我们确保我们正在处理的事件是 :ref:`InputEventMouseMotion "
"<class_InputEventMouseMotion>` event。 我们还想检查光标是否被捕获，因为如果不"
"是，我们不想旋转。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:498
msgid ""
"See :ref:`Mouse and input coordinates <doc_mouse_and_input_coordinates>` for "
"a list of possible input events."
msgstr ""
"请参阅 :ref:`鼠标和输入坐标<doc_mouse_and_input_coordinates>` 以获取可能的输"
"入事件列表。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:501
msgid ""
"If the event is indeed a mouse motion event and the cursor is captured, we "
"rotate based on the relative mouse motion provided by :ref:"
"`InputEventMouseMotion <class_InputEventMouseMotion>`."
msgstr ""
"如果事件确实是鼠标移动事件并且捕获了光标，我们将根据以下提供的相对鼠标移动进"
"行旋转 :ref:`InputEventMouseMotion <class_InputEventMouseMotion>`。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:504
msgid ""
"First we rotate the ``rotation_helper`` node on the ``X`` axis, using the "
"relative mouse motion's ``Y`` value, provided by :ref:`InputEventMouseMotion "
"<class_InputEventMouseMotion>`."
msgstr ""
"首先，我们使用相对鼠标运动的 ``Y`` 值旋转 ``X`` 轴上的``rotation_helper`` 节"
"点，提供者 :ref:`InputEventMouseMotion <class_InputEventMouseMotion>`。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:507
msgid ""
"Then we rotate the entire :ref:`KinematicBody <class_KinematicBody>` on the "
"``Y`` axis by the relative mouse motion's ``X`` value."
msgstr ""
"然后我们通过相对鼠标运动的“X”值旋转整个 :ref:`KinematicBody "
"<class_KinematicBody>` 在 ``Y`` 轴上。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:509
msgid ""
"Godot converts relative mouse motion into a :ref:`Vector2 <class_Vector2>` "
"where mouse movement going up and down is ``1`` and ``-1`` respectively. "
"Right and Left movement is ``1`` and ``-1`` respectively."
msgstr ""
"Godot将相对鼠标运动转换为 :ref:`Vector2 <class_Vector2>` 其中鼠标上下移动分别"
"为“1”和“-1”。 左右移动分别是“1”和“-1”。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:513
msgid ""
"Because of how we are rotating the player, we multiply the relative mouse "
"motion's ``X`` value by ``-1`` so mouse motion going left and right rotates "
"the player left and right in the same direction."
msgstr ""
"由于我们如何旋转游戏角色，我们将相对鼠标移动的“X”值乘以“-1”，因此鼠标左右移动"
"会使游戏角色左右向同一方向旋转。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:517
msgid ""
"Finally, we clamp the ``rotation_helper``'s ``X`` rotation to be between "
"``-70`` and ``70`` degrees so the player cannot rotate themselves upside "
"down."
msgstr ""
"最后，我们将 ``rotation_helper`` 的 ``X`` 旋转夹在 ``-70`` 和 ``70`` 度之间，"
"这样游戏角色就不能自己颠倒了。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:520
#, fuzzy
msgid ""
"See :ref:`using transforms <doc_using_transforms>` for more information on "
"rotating transforms."
msgstr ""
"请参阅 :ref:`使用变换<doc_using_transforms>` 获取有关旋转变换的更多信息。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:524
#, fuzzy
msgid ""
"To test the code, open up the scene named ``Testing_Area.tscn``, if it's not "
"already opened up. We will be using this scene as we go through the next few "
"tutorial parts, so be sure to keep it open in one of your scene tabs."
msgstr ""
"为了测试代码，打开名为 ``Testing_Area.tscn`` 的场景，如果它尚未打开。 我们将"
"在接下来的几个教程部分中使用此场景，因此请务必在其中一个场景选项卡中保持打开"
"状态。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:527
#, fuzzy
msgid ""
"Go ahead and test your code either by pressing ``F6`` with ``Testing_Area."
"tscn`` as the open tab, by pressing the play button in the top right corner, "
"or by pressing ``F5``. You should now be able to walk around, jump in the "
"air, and look around using the mouse."
msgstr ""
"继续测试代码，方法是按 ``F4`` ，将 ``Testing_Area.tscn`` 作为打开标签，按右上"
"角的播放按钮，或按“F6”。 您现在应该能够四处走动，跳到空中，用鼠标环顾四周。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:533
msgid "Giving the player a flash light and the option to sprint"
msgstr "为游戏角色提供闪光灯和冲刺选项"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:535
#, fuzzy
msgid ""
"Before we get to making the weapons work, there are a couple more things we "
"should add."
msgstr "在我们开始制造武器之前，还有一些我们应该添加的东西。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:537
msgid ""
"Many FPS games have an option to sprint and a flashlight. We can easily add "
"these to our player, so let's do that!"
msgstr ""
"许多FPS游戏都可以选择冲刺和手电筒。 我们可以轻松地将这些添加到我们的游戏角色"
"中，所以让我们这样做！"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:540
msgid "First we need a few more class variables in our player script:"
msgstr "首先，我们需要在游戏角色脚本中添加更多类变量:"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:550
#, fuzzy
msgid ""
"All the sprinting variables work exactly the same as the non sprinting "
"variables with similar names."
msgstr "所有冲刺变量与具有相似名称的非冲刺变量完全相同。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:553
msgid ""
"``is_sprinting`` is a boolean to track whether the player is currently "
"sprinting, and ``flashlight`` is a variable we will be using to hold the "
"player's flash light node."
msgstr ""
"``is_sprinting``是一个布尔值来跟踪游戏角色当前是否正在冲刺，而'`flashlight``"
"是我们用来保持游戏角色闪光灯节点的变量。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:556
msgid ""
"Now we need to add a few lines of code, starting in ``_ready``. Add the "
"following to ``_ready``:"
msgstr ""
"现在我们需要添加几行代码，从 ``_ready`` 开始。 将以下内容添加到``_ready``:"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:562
#, fuzzy
msgid ""
"This gets the ``Flashlight`` node and assigns it to the ``flashlight`` "
"variable."
msgstr "这将获得闪光灯节点并将其分配给 ``flashlight`` 变量。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:566
msgid ""
"Now we need to change some of the code in ``process_input``. Add the "
"following somewhere in ``process_input``:"
msgstr ""
"现在我们需要更改 ``process_input`` 中的一些代码。 在 ``process_input`` 中添加"
"以下内容:"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:587
msgid "Let's go over the additions:"
msgstr "让我们回顾一下:"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:589
msgid ""
"We set ``is_sprinting`` to true when the player is holding down the "
"``movement_sprint`` action, and false when the ``movement_sprint`` action is "
"released. In ``process_movement`` we'll add the code that makes the player "
"faster when they sprint. Here in ``process_input`` we are just going to "
"change the ``is_sprinting`` variable."
msgstr ""
"当游戏角色按住 ``movement_sprint`` 动作时，我们将 ``is_sprinting`` 设置为"
"true，当释放 ``movement_sprint`` 动作时设置为false。 在 ``process_movement`` "
"中，我们将添加代码，使其在冲刺时更快。 在 ``process_input`` 中，我们将改变 "
"``is_sprinting`` 变量。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:593
#, fuzzy
msgid ""
"We do something similar to freeing/capturing the cursor for handling the "
"flashlight. We first check to see if the ``flashlight`` action was just "
"pressed. If it was, we then check to see if ``flashlight`` is visible in the "
"scene tree. If it is, then we hide it, and if it's not, we show it."
msgstr ""
"我们做类似于释放/捕捉光标以处理手电筒。 我们首先检查是否按下了 "
"``flashlight`` 动作。 如果是，我们检查是否在场景树中看到 ``flashlight`` 。 如"
"果是，那么我们隐藏它，如果它不是我们显示它。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:598
msgid ""
"Now we need to change a couple things in ``process_movement``. First, "
"replace ``target *= MAX_SPEED`` with the following:"
msgstr ""
"现在我们需要在 ``process_movement`` 中改变一些东西。 首先，用以下代码替换"
"``target * = MAX_SPEED``:"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:607
msgid ""
"Now instead of always multiplying ``target`` by ``MAX_SPEED``, we first "
"check to see if the player is sprinting or not. If the player is sprinting, "
"we instead multiply ``target`` by ``MAX_SPRINT_SPEED``."
msgstr ""
"现在我们首先检查游戏角色是否在冲刺，而不是总是将 ``target`` 乘以 "
"``MAX_SPEED`` 。 如果游戏角色正在冲刺，我们将 ``target`` 乘以 "
"``MAX_SPRINT_SPEED`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:610
#, fuzzy
msgid ""
"Now all that's left is to change the acceleration when sprinting. Change "
"``accel = ACCEL`` to the following:"
msgstr "现在剩下的就是在短跑时改变加速度。 将``accel = ACCEL``更改为以下内容:"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:620
#, fuzzy
msgid ""
"Now, when the player is sprinting, we'll use ``SPRINT_ACCEL`` instead of "
"``ACCEL``, which will accelerate the player faster."
msgstr ""
"现在当游戏角色冲刺时，我们将使用 ``SPRINT_ACCEL`` 而不是 ``ACCEL`` ，这将加快"
"游戏角色的速度。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:624
msgid ""
"You should now be able to sprint if you press the ``shift`` button, and can "
"toggle the flash light on and off by pressing the ``F`` button!"
msgstr ""
"如果您按下“shift”按钮，您现在应该能够冲刺，并且可以通过按下“F”按钮来打开和关"
"闭闪光灯！"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:626
#, fuzzy
msgid ""
"Go try it out! You can change the sprint-related class variables to make the "
"player faster or slower when sprinting!"
msgstr ""
"去试试吧！ 您可以更改与sprint相关的类变量，以便在短跑时让游戏角色更快或更慢！"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:629
#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:1246
#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:666
#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:778
#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:951
#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:994
#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1412
msgid "Final notes"
msgstr "最后的笔记"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:633
#, fuzzy
msgid ""
"Whew! That was a lot of work. Now you have a fully working first person "
"character!"
msgstr "唷！ 这是很多工作。 现在您有一个完全工作的第一人称角色！"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:635
msgid ""
"In :ref:`doc_fps_tutorial_part_two` we will add some guns to our player "
"character."
msgstr ""
"在 :ref:`doc_fps_tutorial_part_two` 我们将为我们的游戏角色角色添加一些枪支。"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:637
msgid ""
"At this point we've recreated the Kinematic character demo from first person "
"perspective with sprinting and a flash light!"
msgstr "在这一点上，我们通过短跑和闪光灯从第一人称角度重新创建了运动角色演示！"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:639
msgid ""
"Currently the player script would be at an ideal state for making all sorts "
"of first person games. For example: Horror games, platformer games, "
"adventure games, and more!"
msgstr ""
"目前，游戏角色脚本将处于制作各种第一人称游戏的理想状态。 例如:恐怖游戏，平台"
"游戏，冒险游戏等等！"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:642
#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:1257
#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:681
#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:787
#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:960
#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:1002
#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1418
msgid "If you ever get lost, be sure to read over the code again!"
msgstr "如果您迷路了，请务必再次阅读代码！"

#: ../../docs/tutorials/3d/fps_tutorial/part_one.rst:644
msgid ""
"You can download the finished project for this part here: :download:"
"`Godot_FPS_Part_1.zip <files/Godot_FPS_Part_1.zip>`"
msgstr ""
"您可以在这里下载这个部分的完成项目: :download:`Godot_FPS_Part_1.zip <files / "
"Godot_FPS_Part_1.zip>`"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:4
msgid "Part 2"
msgstr "第2部分"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:9
msgid "In this part we will be giving our player weapons to play with."
msgstr "在这部分中，我们将为游戏角色提供武器。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:13
msgid ""
"By the end of this part, you will have a player that can fire a pistol, "
"rifle, and attack using a knife. The player will also now have animations "
"with transitions, and the weapons will interact with objects in the "
"environment."
msgstr ""
"到这部分结束时，您将拥有一个可以使用小刀发射手枪，步枪和攻击的游戏角色。 游戏"
"角色现在还将拥有过渡动画，并且武器将与环境中的对象进行交互。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:17
msgid ""
"You are assumed to have finished :ref:`doc_fps_tutorial_part_one` before "
"moving on to this part of the tutorial. The finished project from :ref:"
"`doc_fps_tutorial_part_one` will be the starting project for part 2"
msgstr ""
"在继续本教程的这一部分之前，我们假设您已经完成了 :ref:"
"`doc_fps_tutorial_part_one`。 完成的项目来自 :ref:`doc_fps_tutorial_part_one`"
"将成为第2部分的起始项目"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:20
#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:18
#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:16
#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:16
#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:19
msgid "Let's get started!"
msgstr "让我们开始吧！"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:23
msgid "Making a system to handle animations"
msgstr "制作系统来处理动画"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:25
msgid ""
"First we need a way to handle changing animations. Open up ``Player.tscn`` "
"and select the :ref:`AnimationPlayer <class_AnimationPlayer>` Node "
"(``Player`` -> ``Rotation_Helper`` -> ``Model`` -> ``Animation_Player``)."
msgstr ""
"首先，我们需要一种方法来处理不断变化的动画。 打开 ``Player.tscn`` 并选择 :"
"ref:`AnimationPlayer <class_AnimationPlayer>` Node(``Player`` ->` "
"`Rotation_Helper`` ->` `Model`` ->` `Animation_Player``)。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:28
msgid ""
"Create a new script called ``AnimationPlayer_Manager.gd`` and attach that to "
"the :ref:`AnimationPlayer <class_AnimationPlayer>`."
msgstr ""
"创建一个名为 ``AnimationPlayer_Manager.gd`` 的新脚本，并将其附加到 :ref:"
"`AnimationPlayer <class_AnimationPlayer>`。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:30
msgid "Add the following code to ``AnimationPlayer_Manager.gd``:"
msgstr "将以下代码添加到``AnimationPlayer_Manager.gd``:"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:152
msgid "Lets go over what this script is doing:"
msgstr "让我们来看看这个脚本正在做什么:"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:156
msgid "Lets start with this script's class variables:"
msgstr "让我们从这个脚本的类变量开始:"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:158
msgid ""
"``states``: A dictionary for holding our animation states. (Further "
"explanation below)"
msgstr "``states``:用于保存动画状态的字典。 (以下进一步说明)"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:159
#, fuzzy
msgid ""
"``animation_speeds``: A dictionary for holding all the speeds at which we "
"want to play our animations."
msgstr "``animation_speeds``:一个字典，用于保存我们想要播放动画的所有速度。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:160
msgid ""
"``current_state``: A variable for holding the name of the animation state we "
"are currently in."
msgstr "``current_state``:一个变量，用于保存我们当前所处的动画状态的名称。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:161
msgid ""
"``callback_function``: A variable for holding the callback function. "
"(Further explanation below)"
msgstr "``callback_function``:用于保存回调函数的变量。 (以下进一步说明)"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:163
msgid ""
"If you are familiar with state machines, then you may have noticed that "
"``states`` is structured like a basic state machine. Here is roughly how "
"``states`` is set up:"
msgstr ""
"如果您熟悉状态机，那么您可能已经注意到 ``states`` 的结构类似于基本状态机。 这"
"里大致是如何设置``states``:"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:166
#, fuzzy
msgid ""
"``states`` is a dictionary with the key being the name of the current state, "
"and the value being an array holding all the animations (states) we can "
"transition to. For example, if we are currently in the ``Idle_unarmed`` "
"state, we can only transition to ``Knife_equip``, ``Pistol_equip``, "
"``Rifle_equip``, and ``Idle_unarmed``."
msgstr ""
"``states``是一个字典，键是当前状态的名称，值是一个包含我们可以转换到的所有动"
"画(状态)的数组。 例如，如果我们当前处于 ``Idle_unarmed`` 状态，我们只能转换"
"为 ``Knife_equip`` ， ``Pistol_equip`` ， ``Rifle_equip`` 和 "
"``Idle_unarmed`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:171
msgid ""
"If we try to transition to a state that is not included in the possible "
"transitions states for the state we are in, then we get a warning message "
"and the animation does not change. We can also automatically transition from "
"some states into others, as will be explained further below in "
"``animation_ended``"
msgstr ""
"如果我们尝试转换到未包含在我们所处状态的可能转换状态中的状态，那么我们会收到"
"警告消息并且动画不会更改。 我们也可以自动从一些状态转换到其他状态，这将在下面"
"的“animation_ended”中进一步解释"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:175
#, fuzzy
msgid ""
"For the sake of keeping this tutorial simple, we are not using a 'proper' "
"state machine. If you are interested to know more about state machines, see "
"the following articles:"
msgstr ""
"为了保持本教程的简单，我们没有使用“正确的”状态机。 如果您有兴趣了解有关状态机"
"的更多信息，请参阅以下文章:"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:179
msgid ""
"(Python example) https://dev.to/karn/building-a-simple-state-machine-in-"
"python"
msgstr ""
"(Python示例)https://dev.to/karn/building-a-simple-state-machine-in-python"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:180
msgid ""
"(C# example) https://www.codeproject.com/Articles/489136/"
"UnderstandingplusandplusImplementingplusStateplusP"
msgstr ""
"(C#示例)https://www.codeproject.com/Articles/489136/"
"UnderstandingplusandplusImplementingplusStateplusP"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:181
msgid "(Wiki article) https://en.wikipedia.org/wiki/Finite-state_machine"
msgstr "(维基文章)https://en.wikipedia.org/wiki/Finite-state_machine"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:183
msgid ""
"``animation_speeds`` is how fast each animation will play. Some of the "
"animations are a little slow and in an effort to make everything look "
"smooth, we need to play them at faster speeds."
msgstr ""
"``animation_speeds``是每个动画播放的速度。 有些动画有点慢，为了让一切看起来都"
"很流畅，我们需要以更快的速度播放它们。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:186
msgid ""
"Notice that all of the firing animations are faster than their normal speed. "
"Remember this for later!"
msgstr "请注意，所有触发动画都比正常速度快。 请记住以后再说！"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:188
msgid ""
"``current_state`` will hold the name of the animation state we are currently "
"in."
msgstr "``current_state``将保存我们当前所处的动画状态的名称。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:190
msgid ""
"Finally, ``callback_function`` will be a :ref:`FuncRef <class_FuncRef>` "
"passed in by the player for spawning bullets at the proper frame of "
"animation. A :ref:`FuncRef <class_FuncRef>` allows us to pass in a function "
"as an argument, effectively allowing us to call a function from another "
"script, which is how we will use it later."
msgstr ""
"最后， ``callback_function`` 将是一个 :ref:`FuncRef <class_FuncRef>` 由游戏角"
"色传入，用于在适当的动画帧中生成子弹。 答 :ref:`FuncRef <class_FuncRef>` 允许"
"我们传递一个函数作为参数，有效地允许我们从另一个脚本调用一个函数，这是我们以"
"后使用它的方式。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:196
#, fuzzy
msgid "Now let's look at ``_ready``."
msgstr "现在让我们来看看 ``_ready`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:198
msgid ""
"First we are setting our animation to ``Idle_unarmed`` using the "
"``set_animation`` function, so we for sure start in that animation."
msgstr ""
"首先，我们使用 ``set_animation`` 函数将动画设置为 ``Idle_unarmed`` ，所以我们"
"肯定会从那个动画开始。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:201
msgid ""
"Next we connect the ``animation_finished`` signal to this script and assign "
"it to call ``animation_ended``. This means whenever an animation is "
"finished, ``animation_ended`` will be called."
msgstr ""
"接下来，我们将 ``animation_finished`` 信号连接到此脚本并将其指定为调用 "
"``animation_ended`` 。 这意味着每当动画完成时，都会调用 "
"``animation_ended`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:206
msgid "Lets look at ``set_animation`` next."
msgstr "让我们看看下面的 ``set_animation`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:208
msgid ""
"``set_animation`` changes the animation to the animation named "
"``animation_name`` *if* we can transition to it. In other words, if the "
"animation state we are currently in has the passed in animation state name "
"in ``states``, then we will change to that animation."
msgstr ""
"``set_animation``将动画更改为名为``animation_name`` *的动画*如果*我们可以转换"
"到它。 换句话说，如果我们当前所处的动画状态在“states”中有传递的动画状态名称，"
"那么我们将更改为该动画。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:212
#, fuzzy
msgid ""
"Firstly, we check if the passed in animation name is the same name as the "
"animation currently playing. If they are the same, then we write a warning "
"to the console and return ``true``."
msgstr ""
"首先，我们检查传入的动画名称是否与当前播放的动画名称相同。 如果它们是相同的，"
"那么我们向控制台写一个警告并返回 ``true`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:215
#, fuzzy
msgid ""
"Secondly, we see if :ref:`AnimationPlayer <class_AnimationPlayer>` has the "
"animation with the name ``animation_name`` using ``has_animation``. If it "
"does not, we return ``false``."
msgstr ""
"接下来我们看看 :ref:`AnimationPlayer <class_AnimationPlayer>` 使用 "
"``has_animation`` 创建名为 ``animation_name`` 的动画。 如果没有，我们返回 "
"``false`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:218
#, fuzzy
msgid ""
"Thirdly, we check whether ``current_state`` is set. If ``current_state`` is "
"*not* currently set, then we set ``current_state`` to the passed in "
"animation name and tell :ref:`AnimationPlayer <class_AnimationPlayer>` to "
"start playing the animation with a blend time of ``-1`` at the speed set in "
"``animation_speeds`` and then we return ``true``."
msgstr ""
"然后我们检查是否设置了 ``current_state`` 。 如果 ``current_state`` 是* not *"
"当前设置，我们将 ``current_state`` 设置为传入的动画名称并告诉 :ref:"
"`AnimationPlayer <class_AnimationPlayer>` 开始播放动画，混合时间为`` - 1``以"
"``animation_speeds``中设置的速度然后我们返回``true``。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:222
msgid "Blend time is how long to blend/mix the two animations together."
msgstr "混合时间是将两个动画混合/混合多长时间。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:224
msgid ""
"By putting in a value of ``-1``, the new animation instantly plays, "
"overriding whatever animation is already playing."
msgstr "通过输入值“-1”，新动画立即播放，覆盖已播放的任何动画。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:226
msgid ""
"If you put in a value of ``1``, for one second the new animation will play "
"with increasing strength, blending the two animations together for one "
"second before playing only the new animation. This leads to a smooth "
"transition between animations, which looks great when you are changing from "
"a walking animation to a running animation."
msgstr ""
"如果您输入一个“1”的值，一秒钟后新动画将以增加的力量播放，将两个动画混合在一起"
"一秒钟，然后再播放新动画。 这导致动画之间的平滑过渡，当您从步行动画更改为正在"
"运行的动画时，这看起来很棒。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:230
msgid ""
"We set the blend time to ``-1`` because we want to instantly change "
"animations."
msgstr "我们将混合时间设置为“-1”，因为我们想立即更改动画。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:232
#, fuzzy
msgid ""
"If we have a state in ``current_state``, then we get all the possible states "
"we can transition to."
msgstr ""
"如果我们在 ``current_state`` 中有一个状态，那么我们就可以获得所有可以转换到的"
"状态。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:234
msgid ""
"If the animation name is in the list of possible transitions, we set "
"``current_state`` to the passed in animation (``animation_name``), tell :ref:"
"`AnimationPlayer <class_AnimationPlayer>` to play the animation with a blend "
"time of ``-1`` at the speed set in ``animation_speeds`` and return ``true``."
msgstr ""
"如果动画名称在可能的转换列表中，我们将 ``current_state`` 设置为传入的动画"
"(``animation_name``)，告诉 :ref:`AnimationPlayer <class_AnimationPlayer>` 以"
"混合时间播放动画 在 ``animation_speeds`` 中设置的速度为`-1 -1`并返回 "
"``true`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:240
msgid "Now lets look at ``animation_ended``."
msgstr "现在让我们来看看 ``animation_ended`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:242
msgid ""
"``animation_ended`` is the function that will be called by :ref:"
"`AnimationPlayer <class_AnimationPlayer>` when it's done playing an "
"animation."
msgstr ""
"``animation_ended``是一个函数，它将被调用 :ref:`AnimationPlayer "
"<class_AnimationPlayer>` 当它完成播放动画时。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:245
#, fuzzy
msgid ""
"For certain animation states, we may need to transition into another state "
"when it's finished. To handle this, we check for every possible animation "
"state. If we need to, we will transition into another state."
msgstr ""
"对于某些动画状态，我们可能需要在完成后转换到另一个状态。 为了解决这个问题，我"
"们检查每个可能的动画状态。 如果我们需要，我们将过渡到另一个州。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:248
msgid ""
"If you are using your own animated models, make sure that none of the "
"animations are set to loop. Looping animations do not send the "
"``animation_finished`` signal when they reach the end of the animation and "
"are about to loop again."
msgstr ""
"如果您使用自己的动画模型，请确保没有动画设置为循环。 循环动画在到达动画结束时"
"不会发送 ``animation_finished`` 信号，并且即将再循环。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:252
#, fuzzy
msgid ""
"The transitions in ``animation_ended`` would ideally be part of the data in "
"``states``, but in an effort to make the tutorial easier to understand, "
"we'll hard code each state transition in ``animation_ended``."
msgstr ""
"理想情况下， ``animation_ended`` 中的转换将成为 ``states`` 中数据的一部分，但"
"为了使教程更容易理解，我们将在 ``animation_ended`` 中对每个状态转换进行硬编"
"码。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:258
#, fuzzy
msgid ""
"Finally, there is ``animation_callback``. This function will be called by a "
"function track in our animations. If we have a :ref:`FuncRef "
"<class_FuncRef>` assigned to ``callback_function``, then we call that passed "
"in function. If we do not have a :ref:`FuncRef <class_FuncRef>` assigned to "
"``callback_function``, we print out a warning to the console."
msgstr ""
"最后我们有 ``animation_callback`` 。 此功能将由我们的动画中的功能轨道调用。 "
"如果我们有一个 :ref:`FuncRef <class_FuncRef>` 分配给 ``callback_function`` ，"
"那么我们调用传入函数。 如果我们没有 :ref:`FuncRef <class_FuncRef>` 分配给 "
"``callback_function`` ，我们会向控制台打印一个警告。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:262
msgid ""
"Try running ``Testing_Area.tscn`` to make sure there are no runtime issues. "
"If the game runs but nothing seems to have changed, then everything is "
"working correctly."
msgstr ""
"尝试运行 ``Testing_Area.tscn`` 以确保没有运行时问题。 如果游戏运行但似乎没有"
"任何改变，那么一切都正常。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:266
msgid "Getting the animations ready"
msgstr "准备好动画"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:268
#, fuzzy
msgid ""
"Now that we have a working animation manager, we need to call it from our "
"player script. Before that, though, we need to set some animation callback "
"tracks in our firing animations."
msgstr ""
"现在我们有了一个有效的动画管理器，我们需要从我们的游戏角色脚本中调用它。 在此"
"之前，我们需要在我们的射击动画中设置一些动画回调轨道。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:271
msgid ""
"Open up ``Player.tscn`` if you don't have it open and navigate to the :ref:"
"`AnimationPlayer <class_AnimationPlayer>` node (``Player`` -> "
"``Rotation_Helper`` -> ``Model`` -> ``Animation_Player``)."
msgstr ""
"打开 ``Player.tscn`` 如果您没有打开并导航到 :ref:`AnimationPlayer "
"<class_AnimationPlayer>` node(``Player`` ->` `Rotation_Helper`` ->` `Model` "
"` ->` `Animation_Player``)。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:274
msgid ""
"We need to attach a function track to three of our animations: The firing "
"animation for the pistol, rifle, and knife. Let's start with the pistol. "
"Click the animation drop down list and select \"Pistol_fire\"."
msgstr ""
"我们需要将功能轨道附加到我们的三个动画中:手枪，步枪和刀的射击动画。 让我们从"
"手枪开始吧。 单击动画下拉列表，然后选择“Pistol_fire”。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:277
msgid ""
"Now scroll down to the bottom of the list of animation tracks. The final "
"item in the list should read ``Armature/Skeleton:Left_UpperPointer``. Now at "
"the bottom of the list, click the plus icon on the bottom bar of animation "
"window, right next to the loop button and the up arrow."
msgstr ""
"现在向下滚动到动画轨道列表的底部。 列表中的最后一项应为“Armature / Skeleton:"
"Left_UpperPointer”。 现在位于列表底部，单击动画窗口底部栏上的加号图标，紧邻循"
"环按钮和向上箭头。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:283
#, fuzzy
msgid ""
"This will bring up a window with three choices. We want to add a function "
"callback track, so click the option that reads \"Add Call Func Track\". This "
"will open a window showing the entire node tree. Navigate to the :ref:"
"`AnimationPlayer <class_AnimationPlayer>` node, select it, and press OK."
msgstr ""
"这将打开一个有三个选择的窗口。 我们想要添加一个函数回调轨道，所以单击“Add "
"Call Func Track”选项。 这将打开一个显示整个节点树的窗口。 导航到 :ref:"
"`AnimationPlayer <class_AnimationPlayer>` 节点，选择它，然后按OK。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:289
msgid ""
"Now at the bottom of list of animation tracks you will have a green track "
"that reads \"AnimationPlayer\". Now we need to add the point where we want "
"to call our callback function. Scrub the timeline until you reach the point "
"where the muzzle starts to flash."
msgstr ""
"现在位于动画轨道列表的底部，您将看到一个绿色轨道，其中显"
"示“AnimationPlayer”。 现在我们需要添加我们想要调用回调函数的点。 擦洗时间线，"
"直到到达枪口开始闪烁的点。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:293
#, fuzzy
msgid ""
"The timeline is the window where all the points in our animation are stored. "
"Each of the little points represents a point of animation data."
msgstr "时间轴是存储动画中所有点的窗口。 每个小点代表一个动画数据点。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:296
msgid ""
"Scrubbing the timeline means moving ourselves through the animation. So when "
"we say \"scrub the timeline until you reach a point\", what we mean is move "
"through the animation window until you reach the point on the timeline."
msgstr ""
"擦洗时间轴意味着让我们自己完成动画。 因此，当我们说“擦洗时间线直到达到某个"
"点”时，我们的意思是在动画窗口中移动，直到到达时间轴上的点。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:300
msgid ""
"Also, the muzzle of a gun is the end point where the bullet comes out. The "
"muzzle flash is the flash of light that escapes the muzzle when a bullet is "
"fired. The muzzle is also sometimes referred to as the barrel of the gun."
msgstr ""
"而且，枪口是枪弹出来的终点。 枪口闪光是当子弹射击时逃离枪口的闪光。 枪口有时"
"也被称为枪管。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:304
msgid ""
"For finer control when scrubbing the timeline, press ``control`` and scroll "
"forward with the mouse wheel to zoom in. Scrolling backwards will zoom out."
msgstr ""
"要在删除时间线时进行更精细的控制，请按“控制”并使用鼠标滚轮向前滚动以放大。向"
"后滚动将缩小。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:307
msgid ""
"You can also change how the timeline scrubbing snaps by changing the value "
"in ``Step (s)`` to a lower/higher value."
msgstr ""
"您还可以通过将“Step(s)`”中的值更改为更低/更高的值来更改时间线清理捕捉的方式。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:309
msgid ""
"Once you get to a point you like, press the little green plus symbol on the "
"far right side of the ``AnimationPlayer`` track. This will place a little "
"green point at the position you are currently at in the animation on your "
"``AnimationPlayer`` track."
msgstr ""
"一旦您达到您喜欢的点，按下 ``AnimationPlayer`` 轨道最右侧的小绿色加号。 这将"
"在您的 ``AnimationPlayer`` 轨道上的动画中放置一个绿点。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:315
msgid ""
"Now we have one more step before we are done with the pistol. Select the "
"\"enable editing of individual keys\" button on the far right corner of the "
"animation window. It looks like a pencil with a little point beside it."
msgstr ""
"在我们完成手枪之前，我们还有一步。 选择动画窗口最右侧的“启用单个键的编辑”按"
"钮。 它看起来像一支铅笔，旁边有一点点。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:320
msgid ""
"Once you've clicked that, a new window will open on the right side. Now "
"click the green point on the ``AnimationPlayer`` track. This will bring up "
"the information associated with that point in the timeline. In the empty "
"name field, enter ``animation_callback`` and press ``enter``."
msgstr ""
"点击后，右侧会打开一个新窗口。 现在单击 ``AnimationPlayer`` 轨道上的绿点。 这"
"将显示与时间线中该点相关的信息。 在空名称字段中，输入 ``animation_callback`` "
"并按 ``enter`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:324
msgid ""
"Now when we are playing this animation the callback function will be "
"triggered at that specific point of the animation."
msgstr "现在，当我们播放此动画时，将在动画的特定点触发回调函数。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:326
msgid ""
"Be sure to press the \"enable editing of individual keys\" button again to "
"turn off the ability to edit individual keys so you cannot change one of the "
"transform tracks by accident!"
msgstr ""
"请务必再次按下“启用单个按键编辑”按钮以关闭编辑单个按键的功能，这样您就无法意"
"外更改其中一个变换轨道！"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:331
msgid "Let's repeat the process for the rifle and knife firing animations!"
msgstr "让我们重复步枪和刀射击动画的过程！"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:333
msgid ""
"Because the process is exactly the same as the pistol, the process is going "
"to explained in a little less depth. Follow the steps from above if you get "
"lost! It is exactly the same, just on a different animation."
msgstr ""
"因为这个过程与手枪完全相同，所以这个过程的解释会稍微深入一点。 如果您迷路，请"
"按照上面的步骤！ 它完全相同，只是在不同的动画上。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:336
msgid ""
"Go to the \"Rifle_fire\" animation from the animation drop down. Add the "
"function callback track once you reach the bottom of the animation track "
"list by clicking the little plus icon at the bottom of the screen. Find the "
"point where the muzzle starts to flash and click the little green plus "
"symbol to add a function callback point at that position on the track."
msgstr ""
"从动画下拉菜单转到“Rifle_fire”动画。 通过单击屏幕底部的小加号图标，一旦到达动"
"画轨道列表的底部，添加功能回调轨道。 找到枪口开始闪烁的点，然后单击小绿色加号"
"以在轨道上的该位置添加功能回调点。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:340
msgid ""
"Next, click the \"enable editing of individual keys\" button. Select the "
"newly created function callback point, put \"animation_callback\" into the "
"name field and press ``enter``. Click the \"enable editing of individual keys"
"\" button again to turn off individual key editing. so we cannot change one "
"of the transform tracks by accident."
msgstr ""
"接下来，单击“启用单个键的编辑”按钮。 选择新创建的函数回调点，"
"将“animation_callback”放入name字段并按“enter”。 单击“再次启用单个键的编辑”按"
"钮以关闭单个键编辑。 所以我们不能意外地改变其中一个变换轨道。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:345
msgid ""
"Now we need to apply the callback function track to the knife animation. "
"Select the \"Knife_fire\" animation and scroll to the bottom of the "
"animation tracks. Click the plus symbol at the bottom of the animation "
"window and add a function callback track. Next find a point around the first "
"third of the animation to place the animation callback function point at."
msgstr ""
"现在我们需要将回调函数轨道应用于刀动画。 选择“Knife_fire”动画并滚动到动画轨道"
"的底部。 单击动画窗口底部的加号，然后添加函数回调轨道。 接下来，在动画的前三"
"分之一处找到一个点，将动画回调函数指向。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:349
msgid ""
"We will not actually be firing the knife, and the animation is a stabbing "
"animation rather than a firing one. For this tutorial we are reusing the gun "
"firing logic for our knife, so the animation has been named in a style that "
"is consistent with the other animations."
msgstr ""
"我们实际上不会开枪，动画是一个刺伤动画而不是射击动画。 在本教程中，我们重复使"
"用枪械射击逻辑，因此动画的命名风格与其他动画一致。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:353
msgid ""
"From there click the little green plus to add a function callback point at "
"the current position. Then click the \"enable editing of individual keys\" "
"button, the button with a plus at the bottom right side of the animation "
"window. Select the newly created function callback point, put "
"\"animation_callback\" into the name field and press ``enter``. Click the "
"\"enable editing of individual keys\" button again to turn off individual "
"key editing, so we cannot change one of the transform tracks by accident."
msgstr ""
"从那里单击小绿色加号以在当前位置添加函数回调点。 然后单击“启用单个键的编辑”按"
"钮，在动画窗口右下角加一个加号按钮。 选择新创建的函数回调点，"
"将“animation_callback”放入name字段并按“enter”。 单击“启用单个键的编辑”按钮可"
"以关闭单个键编辑，因此我们无法意外更改其中一个变换轨道。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:359
msgid "Be sure to save your work!"
msgstr "一定要保存您的工作！"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:361
#, fuzzy
msgid ""
"With that done, we are almost ready to start adding the ability to fire to "
"our player script! We need to set up one last scene: The scene for our "
"bullet object."
msgstr ""
"完成后，我们几乎准备开始添加触发我们的游戏角色脚本的功能！ 我们需要设置最后一"
"个场景:我们的子弹对象的场景。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:365
msgid "Creating the bullet scene"
msgstr "创建子弹场景"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:367
msgid ""
"There are several ways to handle a gun's bullets in video games. In this "
"tutorial series, we will be exploring two of the more common ways: Objects, "
"and raycasts."
msgstr ""
"有几种方法可以处理电子游戏中枪支的子弹。 在本系列教程中，我们将探讨两种更常见"
"的方法:对象和光线投射。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:372
msgid ""
"One of the two ways is using a bullet object. This will be an object that "
"travels through the world and handles its own collision code. In this method "
"we create/spawn a bullet object in the direction our gun is facing, and then "
"it travels forward."
msgstr ""
"两种方法之一是使用子弹对象。 这将是一个穿越世界并处理自己的碰撞代码的对象。 "
"在这种方法中，我们在枪的方向上创建/生成一个子弹对象，然后向前行进。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:376
msgid ""
"There are several advantages to this method. The first being we do not have "
"to store the bullets in our player. We can simply create the bullet and then "
"move on, and the bullet itself with handle checking for collisions, sending "
"the proper signal(s) to the object it collides with, and destroying itself."
msgstr ""
"这种方法有几个优点。 首先，我们不必将子弹存储在我们的游戏角色中。 我们可以简"
"单地创建子弹然后继续前进，子弹本身用手柄检查碰撞，将正确的信号发送到它碰撞的"
"对象，并自行销毁。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:379
#, fuzzy
msgid ""
"Another advantage is we can have more complex bullet movement. If we want to "
"make the bullet fall ever so slightly as time goes on, we can make the "
"bullet controlling script slowly push the bullet towards the ground. Using "
"an object also makes the bullet take time to reach its target, it doesn't "
"instantly hit whatever it's pointed at. This feels more realistic because "
"nothing in real life moves instantly from one point to another."
msgstr ""
"另一个优点是我们可以拥有更复杂的子弹运动。 如果我们想让子弹随着时间的推移而下"
"降，我们可以让子弹控制脚本慢慢将子弹推向地面。 使用一个物体也会使子弹花费时间"
"到达目标，它不会立即击中它所指向的任何物体。 这种感觉更加真实，因为现实生活中"
"的任何事物都不会立即从一个点移动到另一个。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:383
msgid ""
"One of the huge disadvantages is performance. While having each bullet "
"calculate their own paths and handle their own collision allows for a lot of "
"flexibility, it comes at the cost of performance. With this method we are "
"calculating every bullet's movement every step, and while this may not be a "
"problem for a few dozen bullets, it can become a huge problem when you "
"potentially have several hundred bullets."
msgstr ""
"性能的一个巨大缺点。 虽然让每个子弹计算他们自己的路径并处理他们自己的碰撞可以"
"提供很大的灵活性，但这需要以性能为代价。 通过这种方法，我们每一步计算每个子弹"
"的运动，虽然这可能不是几十个子弹的问题，但当您可能有几百个子弹时，它可能会成"
"为一个巨大的问题。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:387
msgid ""
"Despite the performance hit, many first person shooters include some form of "
"object bullets. Rocket launchers are a prime example because in many first "
"person shooters, rockets do not just instantly explode at their target "
"position. You can also find bullets as objects many times with grenades "
"because they generally bounce around the world before exploding."
msgstr ""
"尽管性能受到了影响，但许多第一人称射击游戏包括某种形式的物体子弹。 火箭发射器"
"是一个很好的示例，因为在许多第一人称射击游戏中，火箭不会立即在目标位置爆炸。 "
"您也可以用手榴弹多次发现子弹作为物体，因为它们通常会在爆炸前在世界各地反弹。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:391
msgid ""
"While I cannot say for sure this is the case, these games *probably* use "
"bullet objects in some form or another: (These are entirely from my "
"observations. **They may be entirely wrong**. I have never worked on **any** "
"of the following games)"
msgstr ""
"虽然我不能肯定地说是这种情况，但这些游戏 *可能* 以某种形式使用子弹物体:(这些"
"完全来自我的观察。 **它们可能完全错误** 。我从未参与** 任何**以下游戏)"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:394
#, fuzzy
msgid ""
"Halo (Rocket launchers, fragmentation grenades, sniper rifles, brute shot, "
"and more)"
msgstr "光环(火箭发射器，碎片手榴弹，狙击步枪，蛮力射击等)"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:395
msgid ""
"Destiny (Rocket launchers, grenades, fusion rifles, sniper rifles, super "
"moves, and more)"
msgstr "命运(火箭发射器，手榴弹，聚变步枪，狙击步枪，超级动作等)"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:396
msgid ""
"Call of Duty (Rocket launchers, grenades, ballistic knives, crossbows, and "
"more)"
msgstr "使命召唤(火箭发射器，手榴弹，弹道刀，弩等)"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:397
msgid "Battlefield (Rocket launchers, grenades, claymores, mortars, and more)"
msgstr "战场(火箭发射器，手榴弹，claymores，迫击炮等)"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:399
msgid ""
"Another disadvantage with bullet objects is networking. Bullet objects have "
"to sync the positions (at least) with all the clients that are connected to "
"the server."
msgstr ""
"子弹对象的另一个缺点是网络。 Bullet对象必须(至少)与连接到服务器的所有客户端同"
"步位置。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:402
msgid ""
"While we are not implementing any form of networking (as that would be in "
"its own entire tutorial series), it is a consideration to keep in mind when "
"creating your first person shooter, especially if you plan on adding some "
"form of networking in the future."
msgstr ""
"虽然我们没有实现任何形式的网络(因为它将在其自己的整个教程系列中)，但在创建第"
"一人称射击游戏时要牢记这一点，特别是如果您计划在未来添加某种形式的网络。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:407
#, fuzzy
msgid ""
"The other way of handling bullet collisions we will be looking at is "
"raycasting."
msgstr "我们将关注的另一种处理子弹碰撞的方法是光线投射。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:409
msgid ""
"This method is extremely common in guns that have fast moving bullets that "
"rarely change trajectory over time."
msgstr ""
"这种方法在具有快速移动的子弹的枪支中非常常见，这些子弹很少随时间改变轨道。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:411
msgid ""
"Instead of creating a bullet object and sending it through space, we instead "
"send a ray starting from the barrel/muzzle of the gun forwards. We set the "
"raycast's origin to the starting position of the bullet, and based on the "
"length we can adjust how far the bullet 'travels' through space."
msgstr ""
"我们不是创建一个子弹对象并通过空间发送它，而是从枪的枪管/枪口向前发送一条射"
"线。 我们将光线投射的原点设置为子弹的起始位置，并根据长度调整子弹在空间中“行"
"进”的距离。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:414
msgid ""
"While I cannot say for sure this is the case, these games *probably* use "
"raycasts in some form or another: (These are entirely from my observations. "
"**They may be entirely wrong**. I have never worked on **any** of the "
"following games)"
msgstr ""
"虽然我不能肯定地说是这种情况，但这些游戏*可能会以某种形式使用光线投射:(这些完"
"全来自我的观察。 **它们可能完全错误** 。我从来没有工作**任何 **以下游戏)"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:417
msgid ""
"Halo (Assault rifles, DMRs, battle rifles, covenant carbine, spartan laser, "
"and more)"
msgstr "Halo(突击步枪，DMR，战斗步枪，契约卡宾枪，斯巴达激光等)"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:418
msgid ""
"Destiny (Auto rifles, pulse rifles, scout rifles, hand cannons, machine "
"guns, and more)"
msgstr "命运(自动步枪，脉冲步枪，侦察步枪，手枪，机关枪等)"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:419
msgid ""
"Call of Duty (Assault rifles, light machine guns, sub machine guns, pistols, "
"and more)"
msgstr "使命召唤(突击步枪，轻型机枪，子机枪，手枪等)"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:420
msgid "Battlefield (Assault rifles, SMGs, carbines, pistols, and more)"
msgstr "战场(突击步枪，SMG，卡宾枪，手枪等)"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:422
#, fuzzy
msgid ""
"One huge advantage of this method is that it's light on performance. Sending "
"a couple hundred rays through space is *much* easier for the computer to "
"calculate than sending a couple hundred bullet objects."
msgstr ""
"这种方法的一个巨大优势是它的性能很好。 通过空间发送几百条光线对于计算机来说比"
"发送几百个子弹对象更简单。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:426
msgid ""
"Another advantage is we can instantly know if we've hit something or not "
"exactly when we call for it. For networking this is important because we do "
"not need to sync the bullet movements over the Internet, we only need to "
"send whether or not the raycast hit."
msgstr ""
"另一个优点是我们可以立即知道我们是否在确实遇到了什么，或者当我们要求它时。 对"
"于网络而言，这很重要，因为我们不需要通过互联网同步子弹移动，我们只需要发送光"
"线投射。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:429
#, fuzzy
msgid ""
"Raycasting does have some disadvantages, though. One major disadvantage is "
"we cannot easily cast a ray in anything but a linear line. This means we can "
"only fire in a straight line for however long our ray length is. You can "
"create the illusion of bullet movement by casting multiple rays at different "
"positions, but not only is this hard to implement in code, it is also "
"heavier on performance."
msgstr ""
"然而，Raycasting确实有一些缺点。 一个主要的缺点是我们不能轻易地将光线投射到除"
"线性线之外的任何物体上。 这意味着我们只能用直线射击，不管我们的射线长度是多"
"长。 您可以通过在不同位置投射多条光线来创建子弹运动的幻觉，但这不仅难以在代码"
"中实现，而且在性能上也更重。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:433
msgid ""
"Another disadvantage is we cannot see the bullet. With bullet objects we can "
"actually see the bullet travel through space if we attach a mesh to it, but "
"because raycasts happen instantly, we do not have a decent way of showing "
"the bullets. You could draw a line from the origin of the raycast to the "
"point where the raycast collided, and that is one popular way of showing "
"raycasts. Another way is simply not drawing the raycast at all, because "
"theoretically the bullets move so fast our eyes could not see it anyway."
msgstr ""
"另一个缺点是我们看不到子弹。 对于子弹物体，我们实际上可以看到子弹穿过空间，如"
"果我们将一个网格附加到它上面，但由于光线投射立即发生，我们没有一个体面的方式"
"来显示子弹。 您可以从光线投射的原点到光线投射相撞的点绘制一条线，这是显示光线"
"投影的一种流行方式。 另一种方法是根本不绘制光线投射，因为从理论上讲，子弹移动"
"得如此之快，我们的眼睛无论如何都看不到它。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:440
#, fuzzy
msgid ""
"Let's get the bullet object set up. This is what our pistol will create when "
"the \"Pistol_fire\" animation callback function is called."
msgstr ""
"让我们设置子弹对象。 这就是我们的手枪在调用“Pistol_fire”动画回调函数时会创建"
"的内容。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:443
msgid ""
"Open up ``Bullet_Scene.tscn``. The scene contains :ref:`Spatial "
"<class_Spatial>` node called bullet, with a :ref:`MeshInstance "
"<class_MeshInstance>` and an :ref:`Area <class_Area>` with a :ref:"
"`CollisionShape <class_CollisionShape>` children to it."
msgstr ""
"打开 ``Bullet_Scene.tscn`` 。 场景包含 :ref:`Spatial <class_Spatial>` 节点名"
"为bullet，带有 :ref:`MeshInstance <class_MeshInstance>` 和 :ref:`Area "
"<class_Area>` 带有 :ref:`CollisionShape <class_CollisionShape>` children 它。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:447
msgid ""
"Create a new script called ``Bullet_script.gd`` and attach it to the "
"``Bullet`` :ref:`Spatial <class_Spatial>`."
msgstr ""
"创建一个名为 ``Bullet_script.gd`` 的新脚本并将其附加到``Bullet`` :ref:"
"`Spatial <class_Spatial>`。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:449
msgid ""
"We are going to move the entire bullet object at the root (``Bullet``). We "
"will be using the :ref:`Area <class_Area>` to check whether or not we've "
"collided with something"
msgstr ""
"我们将在根部移动整个子弹对象(``Bullet``)。 我们将使用 :ref:`Area "
"<class_Area>` 来检查我们是否与某些东西相撞"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:451
#, fuzzy
msgid ""
"Why are we using an :ref:`Area <class_Area>` and not a :ref:`RigidBody "
"<class_RigidBody>`? The main reason we're not using a :ref:`RigidBody "
"<class_RigidBody>` is because we do not want the bullet to interact with "
"other :ref:`RigidBody <class_RigidBody>` nodes. By using an :ref:`Area "
"<class_Area>` we are ensuring that none of the other :ref:`RigidBody "
"<class_RigidBody>` nodes, including other bullets, will be effected."
msgstr ""
"为什么我们使用 :ref:`Area <class_Area>` 而不是 :ref:`RigidBody "
"<class_RigidBody>`？ 我们没有使用的主要原因是 :ref:`RigidBody "
"<class_RigidBody>` 是因为我们不希望子弹与其他人交互 :ref:`RigidBody "
"<class_RigidBody>` 节点。 通过使用 :ref:`Area <class_Area>` 我们确保其他任何"
"一个 :ref:`RigidBody <class_RigidBody>` 节点，包括其他子弹，将受到影响。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:455
msgid ""
"Another reason is simply because it is easier to detect collisions with an :"
"ref:`Area <class_Area>`!"
msgstr ""
"另一个原因很简单，因为用以下方法检测碰撞更容易 :ref:`Area <class_Area>`！"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:457
msgid "Here's the script that will control our bullet:"
msgstr "这是控制我们子弹的脚本:"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:493
#, fuzzy
msgid "Let's go through the script:"
msgstr "这是控制我们子弹的脚本:"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:497
msgid "First we define a few class variables:"
msgstr "首先我们定义一些类变量:"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:499
#, fuzzy
msgid "``BULLET_SPEED``: The speed at which the bullet travels."
msgstr "``BULLET_SPEED``:子弹行进的速度。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:500
#, fuzzy
msgid ""
"``BULLET_DAMAGE``: The damage the bullet will cause to anything with which "
"it collides."
msgstr "``BULLET_DAMAGE``:子弹对它碰撞的任何伤害。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:501
msgid "``KILL_TIMER``: How long the bullet can last without hitting anything."
msgstr "``KILL_TIMER``:子弹可以持续多久而不击中任何东西。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:502
msgid "``timer``: A float for tracking how long the bullet has been alive."
msgstr "``timer``:一个用于跟踪子弹活着多久的浮子。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:503
msgid ""
"``hit_something``: A boolean for tracking whether or not we've hit something."
msgstr "``hit_something``:一个布尔值，用于跟踪我们是否击中了某些东西。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:505
msgid ""
"With the exception of ``timer`` and ``hit_something``, all of these "
"variables change how the bullet interacts with the world."
msgstr ""
"除了 ``timer`` 和 ``hit_something`` 之外，所有这些变量都会改变子弹与世界的交"
"互方式。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:508
#, fuzzy
msgid ""
"The reason we are using a kill timer is so we do not have a case where we "
"get a bullet travelling forever. By using a kill timer, we can ensure that "
"no bullets will travel forever and consume resources."
msgstr ""
"我们使用杀戮计时器的原因是因为我们没有永久性地发射子弹的情况。 通过使用kill计"
"时器，我们可以确保没有子弹将永远传播并消耗资源。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:512
msgid ""
"As in :ref:`doc_fps_tutorial_part_one`, we have a couple all uppercase class "
"variables. The reason behind this is the same as the reason given in :ref:"
"`doc_fps_tutorial_part_one`: We want to treat these variables like "
"constants, but we want to be able to change them. In this case we will later "
"need to change the damage and speed of these bullets, so we need them to be "
"variables and not constants."
msgstr ""
"如 :ref:`doc_fps_tutorial_part_one`，我们有几个全部大写的类变量。 这背后的原"
"因与下面给出的原因相同 :ref:`doc_fps_tutorial_part_one`:我们希望将这些变量视"
"为常量，但我们希望能够更改它们。 在这种情况下，我们稍后需要更改这些子弹的损坏"
"和速度，因此我们需要它们是变量而不是常量。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:519
msgid ""
"In ``_ready`` we set the area's ``body_entered`` signal to ourself so that "
"it calls the ``collided`` function when a body enters the area."
msgstr ""
"在 ``_ready`` 中，我们将区域的 ``body_entered`` 信号设置为我们自己，以便在物"
"体进入该区域时调用 ``collided`` 函数。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:524
#, fuzzy
msgid ""
"``_physics_process`` gets the bullet's local ``Z`` axis. If you look at the "
"scene in local mode, you will find that the bullet faces the positive local "
"``Z`` axis."
msgstr ""
"``_physics_process``获得子弹的本地``Z``轴。 如果您以局部模式观察场景，您会发"
"现子弹面向正的本地“Z”轴。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:527
msgid ""
"Next we translate the entire bullet by that forward direction, multiplying "
"in our speed and delta time."
msgstr "接下来，我们按照前进方向翻译整个项目符号，乘以我们的速度和增量时间。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:529
#, fuzzy
msgid ""
"After that we add delta time to our timer and check whether the timer has "
"reached a value as big or greater than our ``KILL_TIME`` constant. If it "
"has, we use ``queue_free`` to free the bullet."
msgstr ""
"之后我们将增量时间添加到我们的计时器，并检查计时器是否长于或长于我们的 "
"``KILL_TIME`` 常量。 如果有，我们使用 ``queue_free`` 释放子弹。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:534
#, fuzzy
msgid "In ``collided`` we check whether we've hit something yet."
msgstr "在 ``collided`` 中，我们检查我们是否已经击中了某些东西。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:536
msgid ""
"Remember that ``collided`` is only called when a body has entered the :ref:"
"`Area <class_Area>` node. If the bullet has not already collided with "
"something, we then proceed to check if the body the bullet has collided with "
"has a function/method called ``bullet_hit``. If it does, we call it and pass "
"in the bullet's damage and the bullet's global transform so we can get the "
"bullet's rotation and position."
msgstr ""
"请记住，只有当一个实体进入 :ref:`Area <class_Area>` 节点时才会调用 "
"``collided`` 。 如果子弹尚未与某些东西发生碰撞，我们将继续检查子弹发生碰撞的"
"物体是否具有名为“bullet_hit”的功能/方法。 如果是这样，我们称之为并传递子弹的"
"伤害和子弹的全局变换，这样我们就可以获得子弹的旋转和位置。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:541
msgid ""
"in ``collided``, the passed in body can be a :ref:`StaticBody "
"<class_StaticBody>`, :ref:`RigidBody <class_RigidBody>`, or :ref:"
"`KinematicBody <class_KinematicBody>`"
msgstr ""
"在 ``collided`` 中，传入的物体可以是 :ref:`StaticBody <class_StaticBody>`， :"
"ref:`RigidBody <class_RigidBody>`，或者 :ref:`KinematicBody "
"<class_KinematicBody>`"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:544
msgid ""
"We set the Bullet's ``hit_something`` variable to ``true`` because "
"regardless of whether or not the body that the bullet collided with has the "
"``bullet_hit`` function/method, it has hit something and so we need to make "
"sure the bullet does not hit anything else."
msgstr ""
"我们将子弹的 ``hit_something`` 变量设置为 ``true`` ，因为无论子弹碰撞的物体是"
"否具有 ``bullet_hit`` 函数/方法，它都会击中某些东西，所以我们需要制作 确定子"
"弹没有击中任何其他东西。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:547
msgid "Then we free the bullet using ``queue_free``."
msgstr "然后我们使用 ``queue_free`` 释放子弹。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:549
msgid ""
"You may be wondering why we even have a ``hit_something`` variable if we "
"free the bullet using ``queue_free`` as soon as it hits something."
msgstr ""
"您可能想知道为什么我们甚至有一个 ``hit_something`` 变量，如果我们在命中某事时"
"立即使用 ``queue_free`` 释放子弹。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:552
#, fuzzy
msgid ""
"The reason we need to track whether we've hit something or not is because "
"``queue_free`` does not immediately free the node, so the bullet could "
"collide with another body before Godot has a chance to free it. By tracking "
"whether the bullet has hit something, we can make sure that the bullet will "
"only hit one object."
msgstr ""
"我们需要跟踪我们是否击中某个东西的原因是因为 ``queue_free`` 没有立即释放节"
"点，所以子弹可能会在Godot有机会释放它之前与另一个物体发生碰撞。 通过跟踪子弹"
"是否击中了什么，我们可以确保子弹只击中一个物体。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:560
msgid ""
"Before we start programming the player again, let's take a quick look at "
"``Player.tscn``. Open up ``Player.tscn`` again."
msgstr ""
"在我们再次开始编程游戏角色之前，让我们快速看一下 ``Player.tscn`` 。 再次打开 "
"``Player.tscn`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:563
msgid ""
"Expand ``Rotation_Helper`` and notice how it has two nodes: "
"``Gun_Fire_Points`` and ``Gun_Aim_Point``."
msgstr ""
"展开 ``Rotation_Helper`` 并注意它有两个节点: ``Gun_Fire_Points`` 和 "
"``Gun_Aim_Point`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:566
msgid ""
"``Gun_aim_point`` is the point that the bullets will be aiming at. Notice "
"how it is lined up with the center of the screen and pulled a distance "
"forward on the Z axis. ``Gun_aim_point`` will serve as the point where the "
"bullets will for sure collide with as it goes along."
msgstr ""
"``Gun_aim_point``是子弹瞄准的点。 注意它是如何与屏幕中心对齐并在Z轴上向前拉一"
"段距离。 ``Gun_aim_point``将作为子弹在进行时肯定会碰撞的点。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:571
#, fuzzy
msgid ""
"There is a invisible mesh instance for debugging purposes. The mesh is a "
"small sphere that visually shows at which target the bullets will be aiming."
msgstr ""
"有一个不可见的网格实例用于调试目的。 网格是一个小球体，可以直观地显示子弹将瞄"
"准的位置。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:574
msgid ""
"Open up ``Gun_Fire_Points`` and you'll find three more :ref:`Spatial "
"<class_Spatial>` nodes, one for each weapon."
msgstr ""
"打开 ``Gun_Fire_Points`` ，您会发现另外三个 :ref:`Spatial <class_Spatial>` 节"
"点，每个武器一个。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:577
msgid ""
"Open up ``Rifle_Point`` and you'll find a :ref:`Raycast <class_Raycast>` "
"node. This is where we will be sending the raycasts for our rifle's bullets. "
"The length of the raycast will dictate how far our bullets will travel."
msgstr ""
"打开 ``Rifle_Point`` 您会找到一个 :ref:`Raycast <class_Raycast>` 节点。 这是"
"我们将为我们的步枪的子弹发送光线投射的地方。 光线投射的长度将决定我们的子弹将"
"走多远。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:581
msgid ""
"We are using a :ref:`Raycast <class_Raycast>` node to handle the rifle's "
"bullet because we want to fire lots of bullets quickly. If we use bullet "
"objects, it is quite possible we could run into performance issues on older "
"machines."
msgstr ""
"我们使用 :ref:`Raycast <class_Raycast>` 节点来处理步枪的子弹，因为我们想要快"
"速发射大量子弹。 如果我们使用bullet对象，很可能会在旧机器上遇到性能问题。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:585
#, fuzzy
msgid ""
"If you are wondering from where the positions of the points came, they are "
"the rough positions of the ends of each weapon. You can see this by going to "
"``AnimationPlayer``, selecting one of the firing animations and scrubbing "
"through the timeline. The point for each weapon should mostly line up with "
"the end of each weapon."
msgstr ""
"如果您想知道点的位置来自哪里，它们就是每个武器末端的粗略位置。 您可以通过转"
"到 ``AnimationPlayer`` ，选择其中一个触发动画并在时间轴上擦洗来看到这一点。 "
"每种武器的重点应该主要与每种武器的结束对齐。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:591
#, fuzzy
msgid ""
"Open up ``Knife_Point`` and you'll find an :ref:`Area <class_Area>` node. We "
"are using an :ref:`Area <class_Area>` for the knife because we only care for "
"all the bodies close to us, and because our knife does not fire into space. "
"If we were making a throwing knife, we would likely spawn a bullet object "
"that looks like a knife."
msgstr ""
"打开 ``Knife_Point`` 您会找到一个 :ref:`Area <class_Area>` 节点。 我们正在使"
"用 :ref:`Area <class_Area>` 因为我们只关心靠近我们的所有尸体，因为我们的刀不"
"会射入太空。 如果我们正在制作一把投掷刀，我们可能会生成一个看起来像刀子的子弹"
"物体。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:596
msgid ""
"Finally, we have ``Pistol_Point``. This is the point where we will be "
"creating/instancing our bullet objects. We do not need any additional nodes "
"here, as the bullet handles all of its own collision detection."
msgstr ""
"最后，我们有了 ``Pistol_Point`` 。 这是我们将创建/实例化子弹对象的点。 我们这"
"里不需要任何额外的节点，因为子弹处理它自己的所有碰撞检测。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:600
msgid ""
"Now that we've seen how we will handle our other weapons, and where we will "
"spawn the bullets, let's start working on making them work."
msgstr ""
"现在我们已经看到了我们将如何处理我们的其他武器，以及我们将在哪里产生子弹，让"
"我们开始努力让它们发挥作用。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:603
msgid ""
"You can also look at the HUD nodes if you want. There is nothing fancy there "
"and other than using a single :ref:`Label <class_Label>`, we will not be "
"touching any of those nodes. Check :ref:"
"`doc_design_interfaces_with_the_control_nodes` for a tutorial on using GUI "
"nodes."
msgstr ""
"如果需要，您还可以查看HUD节点。 除了使用单个参考之外没有任何花哨的东西 :ref:"
"`Label <class_Label>`，我们不会触及任何这些节点。 检查 :ref:"
"`doc_design_interfaces_with_the_control_nodes`获取有关使用GUI节点的教程。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:609
msgid "Creating the first weapon"
msgstr "创造第一个武器"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:611
msgid "Lets write the code for each of our weapons, starting with the pistol."
msgstr "让我们为每个武器编写代码，从手枪开始。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:613
msgid ""
"Select ``Pistol_Point`` (``Player`` -> ``Rotation_Helper`` -> "
"``Gun_Fire_Points`` -> ``Pistol_Point``) and create a new script called "
"``Weapon_Pistol.gd``."
msgstr ""
"选择 ``Pistol_Point`` (``Player`` ->` `Rotation_Helper`` ->` "
"`Gun_Fire_Points`` ->` `Pistol_Point``)并创建一个名为``Weapon_Pistol.gd``的新"
"脚本。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:615
msgid "Add the following code to ``Weapon_Pistol.gd``:"
msgstr "将以下代码添加到``Weapon_Pistol.gd``:"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:666
msgid "Let's go over how the script works."
msgstr "让我们回顾一下脚本的工作原理。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:670
msgid "First we define some class variables we'll need in the script:"
msgstr "首先，我们在脚本中定义一些我们需要的类变量:"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:672
msgid "``DAMAGE``: The amount of damage a single bullet does."
msgstr "``DAMAGE``:单个子弹造成的伤害量。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:673
msgid "``IDLE_ANIM_NAME``: The name of the pistol's idle animation."
msgstr "``IDLE_ANIM_NAME``:手枪空闲动画的名称。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:674
msgid "``FIRE_ANIM_NAME``: The name of the pistol's fire animation."
msgstr "``FIRE_ANIM_NAME``:手枪的火焰动画的名称。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:675
msgid ""
"``is_weapon_enabled``: A variable for checking whether this weapon is in use/"
"enabled."
msgstr "``is_weapon_enabled``:用于检查此武器是否正在使用/启用的变量。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:676
msgid "``bullet_scene``: The bullet scene we worked on earlier."
msgstr "``bullet_scene``:我们之前处理的子弹场景。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:677
msgid "``player_node``: A variable to hold ``Player.gd``."
msgstr "``player_node``:一个容纳 ``Player.gd`` 的变量。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:679
msgid ""
"The reason we define most of these variables is so we can use them in "
"``Player.gd``."
msgstr "我们定义大多数这些变量的原因是我们可以在 ``Player.gd`` 中使用它们。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:681
#, fuzzy
msgid ""
"Each of the weapons we'll make will have all these variables (minus "
"``bullet_scene``) so we have a consistent interface to interact with in "
"``Player.gd``. By using the same variables/functions in each weapon, we can "
"interact with them without having to know which weapon we are using, which "
"makes our code much more modular because we can add weapons without having "
"to change much of the code in ``Player.gd`` and it will just work."
msgstr ""
"我们所做的所有武器都将拥有所有这些变量(减去 ``bullet_scene`` )，因此我们在 "
"``Player.gd`` 中有一个一致的界面来与之交互。 通过在每个武器中使用相同的变量/"
"函数，我们可以与它们进行交互而无需知道我们正在使用哪种武器，这使得我们的代码"
"更加模块化，因为我们可以添加武器而无需更改“游戏角色”中的大部分代码 .gd``它会"
"起作用。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:686
#, fuzzy
msgid ""
"We could write all the code in ``Player.gd``, but then ``Player.gd`` will "
"get increasingly harder to manage as we add weapons. By using a modular "
"design with a consistent interface, we can keep ``Player.gd`` nice and neat, "
"while also making it easier to add/remove/modify weapons."
msgstr ""
"我们可以在 ``Player.gd`` 中编写所有代码，但随着我们添加武器， ``Player.gd`` "
"将变得越来越难以管理。 通过使用具有一致界面的模块化设计，我们可以保持“Player."
"gd”的美观和整洁，同时还可以更容易地添加/删除/修改武器。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:691
msgid "In ``_ready`` we simply pass over it."
msgstr "在 ``_ready`` 中我们简单地将它传递过来。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:693
msgid ""
"There is one thing of note though, an assumption that we'll fill in ``Player."
"gd`` at some point."
msgstr "但有一点值得注意，我们假设我们会在某些时候填写“Player.gd”。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:695
msgid ""
"We are going to assume that ``Player.gd`` will pass themselves in before "
"calling any of the functions in ``Weapon_Pistol.gd``."
msgstr ""
"我们假设 ``Player.gd`` 会在调用 ``Weapon_Pistol.gd`` 中的任何函数之前自行传"
"递。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:697
msgid ""
"While this can lead to situations where the player does not pass themselves "
"in (because we forget), we would have to have a long string of "
"``get_parent`` calls to traverse up the scene tree to retrieve the player. "
"This does not look pretty (``get_parent().get_parent().get_parent()`` and so "
"on) and it is relatively safe to assume we will remember to pass ourselves "
"to each weapon in ``Player.gd``."
msgstr ""
"虽然这可能导致游戏角色没有进入自己的情况(因为我们忘记)，但我们必须有一长串 "
"``get_parent`` 调用来遍历场景树以检索游戏角色。 这看起来不太漂亮"
"(``get_parent()。get_parent()。get_parent()``依此类推)假设我们会记得将自己传"
"递给``Player.gd``中的每个武器，这是相对安全的。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:703
msgid "Next let's look at ``fire_weapon``:"
msgstr "接下来让我们看看``fire_weapon``:"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:705
msgid "The first thing we do is instance the bullet scene we made earlier."
msgstr "我们做的第一件事就是我们之前制作的子弹场景。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:707
#, fuzzy
msgid ""
"By instancing the scene, we are creating a new node holding all the node(s) "
"in the scene we instanced, effectively cloning that scene."
msgstr ""
"通过实例化场景，我们创建了一个新节点，其中包含我们实例化的场景中的所有节点，"
"有效地克隆了该场景。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:709
#, fuzzy
msgid ""
"Then we add a ``clone`` to the first child node of the root of the scene we "
"are currently in. By doing this, we're making it a child of the root node of "
"the currently loaded scene."
msgstr ""
"然后我们将“克隆”添加到我们当前所在场景的根的第一个子节点。通过这样做，我们将"
"它作为当前加载场景的根节点的子节点。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:711
msgid ""
"In other words, we are adding a ``clone`` as a child of the first node "
"(whatever is at the top of the scene tree) in the currently loaded/opened "
"scene. If the currently loaded/open scene is ``Testing_Area.tscn``, we'd be "
"adding our ``clone`` as a child of ``Testing_Area``, the root node in that "
"scene."
msgstr ""
"换句话说，我们在当前加载/打开的场景中添加一个 ``clone`` 作为第一个节点的子节"
"点(无论在场景树的顶部)。 如果当前加载/打开的场景是 ``Testing_Area.tscn`` ，我"
"们将把 ``clone`` 添加为 ``Testing_Area`` 的子项，这是该场景中的根节点。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:714
#, fuzzy
msgid ""
"As mentioned later below in the section on adding sounds, this method makes "
"an assumption. This will be explained later in the section on adding sounds "
"in :ref:`doc_fps_tutorial_part_three`"
msgstr ""
"正如下文关于添加声音的部分所述，此方法做出了假设。 这将在后面的关于添加声音的"
"部分中解释 :ref:`doc_fps_tutorial_part_three`"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:717
msgid ""
"Next we set the global transform of the clone to the ``Pistol_Aim_Point``'s "
"global transform. The reason we do this is so the bullet is spawned at the "
"end of the pistol."
msgstr ""
"接下来，我们将克隆的全局变换设置为“Pistol_Aim_Point”的全局变换。 我们这样做的"
"原因是手枪末端会产生子弹。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:719
#, fuzzy
msgid ""
"You can see that ``Pistol_Aim_Point`` is positioned right at the end of the "
"pistol by clicking the :ref:`AnimationPlayer <class_AnimationPlayer>` and "
"scrolling through ``Pistol_fire``. You'll find the position is more or less "
"at the end of the pistol when it fires."
msgstr ""
"您可以通过单击 :ref:`AnimationPlayer <class_AnimationPlayer>并滚动浏览 "
"``Pistol_fire`` 来看到 ``Pistol_Aim_Point`` 位于手枪的末端。 您会发现这个位置"
"或多或少位于手枪发射结束时。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:722
msgid ""
"Next we scale it up by a factor of ``4`` because the bullet scene is a "
"little too small by default."
msgstr "接下来我们将它扩大一倍因为“4”，因为子弹场景默认情况下有点太小了。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:724
#, fuzzy
msgid ""
"Then we set the bullet's damage (``BULLET_DAMAGE``) to the amount of damage "
"a single pistol bullet does (``DAMAGE``)."
msgstr ""
"然后我们将子弹的伤害(“BULLET_DAMAGE”)设置为单个手枪子弹造成的伤害量(“损坏”)"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:728
msgid "Now let's look at ``equip_weapon``:"
msgstr "现在让我们来看看`equip_weapon``:"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:730
#, fuzzy
msgid ""
"The first thing we do is check to see whether the animation manager is in "
"the pistol's idle animation. If we are in the pistol's idle animation, we "
"set ``is_weapon_enabled`` to ``true`` and return ``true`` because the pistol "
"has successfully been equipped."
msgstr ""
"我们要做的第一件事是检查动画管理器是否在手枪的空闲动画中。 如果我们在手枪的闲"
"置动画中，我们将 ``is_weapon_enabled`` 设置为 ``true`` 并返回 ``true`` 因为手"
"枪已成功装备。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:734
msgid ""
"Because we know our pistol's ``equip`` animation automatically transitions "
"to the pistol's idle animation, if we are in the pistol's idle animation the "
"pistol must have finished playing the equip animation."
msgstr ""
"因为我们知道我们的手枪的“装备”动画会自动转换为手枪的空闲动画，如果我们在手枪"
"的空闲动画中，手枪必须完成播放装备动画。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:737
msgid ""
"We know these animations will transition because we wrote the code to make "
"them transition in ``Animation_Manager.gd``"
msgstr ""
"我们知道这些动画将会转换，因为我们编写了代码以使它们在 ``Animation_Manager."
"gd`` 中转换"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:739
msgid ""
"Next we check to see if the player is in the ``Idle_unarmed`` animation "
"state. Because all unequipping animations go to this state, and because any "
"weapon can be equipped from this state, we change animations to "
"``Pistol_equip`` if the player is in the ``Idle_unarmed`` state."
msgstr ""
"接下来我们检查游戏角色是否处于“Idle_unarmed”动画状态。 因为所有非装备动画都会"
"进入这种状态，并且因为任何武器都可以从这种状态装备，所以如果游戏角色处"
"于“Idle_unarmed”状态，我们会将动画更改为“Pistol_equip”。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:742
msgid ""
"Since we know ``Pistol_equip`` will transition to ``Pistol_idle``, we do not "
"need to do any more additional processing for equipping weapons, but since "
"we were not able to equip the pistol yet, we return ``false``."
msgstr ""
"既然我们知道 ``Pistol_equip`` 将转换为 ``Pistol_idle`` ，我们不需要再为武器配"
"备额外的处理，但由于我们还没能装备手枪，我们返回 ``false``。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:747
msgid "Finally, let's look at ``unequip_weapon``:"
msgstr "最后，让我们看看 ``unequip_weapon``:"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:749
msgid ""
"``unequip_weapon`` is similar to ``equip_weapon``, but instead we're "
"checking things in reverse."
msgstr "``unequip_weapon``类似于``equip_weapon``，但我们却反过来检查。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:751
#, fuzzy
msgid ""
"First we check to see whether the player is in the idle animation state. "
"Then we check to make sure the player is not in the ``Pistol_unequip`` "
"animation. If the player is not in the ``Pistol_unequip`` animation, we want "
"to play the ``pistol_unequip`` animation."
msgstr ""
"首先，我们检查游戏角色是否处于空闲动画状态。 然后我们检查以确保游戏角色不"
"在“Pistol_unequip”动画中。 如果游戏角色不在“Pistol_unequip”动画中，我们想播"
"放 ``pistol_unequip`` 动画。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:754
#, fuzzy
msgid ""
"You may be wondering why we are checking to see whether the player is in the "
"pistol's idle animation, and then making sure the player is not unequipping "
"right after. The reason behind the additional check is because we could (in "
"rare cases) call ``unequip_weapon`` twice before we've had a chance to "
"process ``set_animation``, so we add this additional check to make sure the "
"unequip animation plays."
msgstr ""
"您可能想知道为什么我们要检查游戏角色是否在手枪的空闲动画中，然后确保游戏角色"
"不会立即取消。 额外检查背后的原因是因为我们可以(在极少数情况下)在我们有机会处"
"理 ``set_animation`` 之前两次调用 ``unequip_weapon`` ，所以我们添加这个额外的"
"检查以确保取消设置动画播放。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:758
#, fuzzy
msgid ""
"Next we check to see whether the player is in ``Idle_unarmed``, which is the "
"animation state we will transition into from ``Pistol_unequip``. If the "
"player is in ``Idle_unarmed``, then we set ``is_weapon_enabled`` to "
"``false`` since we are no longer using this weapon, and return ``true`` "
"because we have successfully unequipped the pistol."
msgstr ""
"接下来我们检查游戏角色是否在“Idle_unarmed”中，这是我们将从“Pistol_unequip”转"
"换成的动画状态。 如果游戏角色在 ``Idle_unarmed`` ，那么我们将 "
"``is_weapon_enabled`` 设置为 ``false`` ，因为我们不再使用这种武器，并返回 "
"``true`` 因为我们已经成功地装备了手枪。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:761
msgid ""
"If the player is not in ``Idle_unarmed``, we return ``false`` because we "
"have not yet successfully unequipped the pistol."
msgstr ""
"如果游戏角色不在“Idle_unarmed”中，我们会返回“false”，因为我们尚未成功装备手"
"枪。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:764
msgid "Creating the other two weapons"
msgstr "制造另外两种武器"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:766
#, fuzzy
msgid ""
"Now that we have all the code we'll need for the pistol, let's add the code "
"for the rifle and knife next."
msgstr ""
"现在我们已经掌握了手枪所需的所有代码，接下来我们将为步枪和刀具添加代码。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:768
msgid ""
"Select ``Rifle_Point`` (``Player`` -> ``Rotation_Helper`` -> "
"``Gun_Fire_Points`` -> ``Rifle_Point``) and create a new script called "
"``Weapon_Rifle.gd``, then add the following:"
msgstr ""
"选择 ``Rifle_Point`` (``Player`` ->` `Rotation_Helper`` ->` "
"`Gun_Fire_Points`` ->` `Rifle_Point``)并创建一个名为``Weapon_Rifle.gd``的新脚"
"本，然后添加 下列:"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:821
msgid ""
"Most of this is exactly the same as ``Weapon_Pistol.gd``, so we're only "
"going to look at what's changed: ``fire_weapon``."
msgstr ""
"其中大部分与 ``Weapon_Pistol.gd`` 完全相同，所以我们只会看看改变了什么: "
"``fire_weapon`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:823
msgid ""
"The first thing we do is get the :ref:`Raycast <class_Raycast>` node, which "
"is a child of ``Rifle_Point``."
msgstr ""
"我们要做的第一件事是获取 :ref:`Raycast <class_Raycast>` 节点，它是 "
"``Rifle_Point`` 的子节点。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:825
msgid ""
"Next we force the :ref:`Raycast <class_Raycast>` to update using "
"``force_raycast_update``. This will force the :ref:`Raycast <class_Raycast>` "
"to detect collisions when we call it, meaning we get a frame perfect "
"collision check with the 3D physics world."
msgstr ""
"接下来我们使用 ``force_raycast_update`` 强制执行 :ref:`Raycast "
"<class_Raycast>` 更新。 这将迫使 :ref:`Raycast <class_Raycast>` 在我们调用它"
"时检测碰撞，这意味着我们可以与3D物理世界进行帧完美碰撞检查。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:828
msgid ""
"Then we check to see if the :ref:`Raycast <class_Raycast>` collided with "
"something."
msgstr "然后我们检查 :ref:`Raycast <class_Raycast>` 是否与某些东西相撞。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:830
msgid ""
"If the :ref:`Raycast <class_Raycast>` has collided with something, we first "
"get the collision body it collided with. This can be a :ref:`StaticBody "
"<class_StaticBody>`, :ref:`RigidBody <class_RigidBody>`, or a :ref:"
"`KinematicBody <class_KinematicBody>`."
msgstr ""
"如果 :ref:`Raycast <class_Raycast>` 与某些东西相撞，我们首先得到它碰撞的碰撞"
"体。 这可以是 :ref:`StaticBody <class_StaticBody>`， :ref:`RigidBody "
"<class_RigidBody>`，或者a :ref:`KinematicBody <class_KinematicBody>`。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:833
msgid ""
"Next we want to make sure the body we've collided with is not the player, "
"since we (probably) do not want to give the player the ability to shoot "
"themselves in the foot."
msgstr ""
"接下来我们要确保我们碰到的物体不是游戏角色，因为我们(可能)不想让游戏角色有能"
"力在脚下射击。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:835
#, fuzzy
msgid ""
"If the body is not the player, we then check to see if it has a function/"
"method called ``bullet_hit``. If it does, we call it and pass in the amount "
"of damage this bullet does (``DAMAGE``), and the global transform of the :"
"ref:`Raycast <class_Raycast>` so we can tell from which direction the bullet "
"came."
msgstr ""
"如果物体不是游戏角色，我们检查他们是否有一个名为 ``bullet_hit`` 的函数/方"
"法。 如果他们这样做，我们称之为并传递这个子弹所造成的伤害量(``DAMAGE``)，以"
"及 :ref:`Raycast <class_Raycast>` 的全局变换，这样我们可以知道子弹来自哪个方"
"向。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:840
msgid "Now all we need to do is write the code for the knife."
msgstr "现在我们需要做的就是为刀编写代码。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:842
msgid ""
"Select ``Knife_Point`` (``Player`` -> ``Rotation_Helper`` -> "
"``Gun_Fire_Points`` -> ``Knife_Point``) and create a new script called "
"``Weapon_Knife.gd``, then add the following:"
msgstr ""
"选择 ``Knife_Point`` (``Player`` ->` `Rotation_Helper`` ->` "
"`Gun_Fire_Points`` ->` `Knife_Point``)并创建一个名为``Weapon_Knife.gd``的新脚"
"本，然后添加 下列:"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:893
msgid ""
"As with ``Weapon_Rifle.gd``, the only differences are in ``fire_weapon``, so "
"let's look at that:"
msgstr ""
"与 ``Weapon_Rifle.gd`` 一样，唯一的区别在于 ``fire_weapon`` ，所以让我们看一"
"下:"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:895
msgid ""
"The first thing we do is get the :ref:`Area <class_Area>` child node of "
"``Knife_Point``."
msgstr ""
"我们要做的第一件事就是得到 ``Knife_Point`` 的 :ref:`Area <class_Area>` 子节"
"点。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:897
#, fuzzy
msgid ""
"Next we want to get all the collision bodies inside the :ref:`Area "
"<class_Area>` using ``get_overlapping_bodies``. This will return a list of "
"every body that touches the :ref:`Area <class_Area>`."
msgstr ""
"接下来我们想要使用 ``get_overlapping_bodies`` 获取所有的碰撞体 :ref:`Area "
"<class_Area>`。 这将返回触及的每个实体的列表 :ref:`Area <class_Area>`。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:900
msgid "We next want to go through each of those bodies."
msgstr "我们接下来想要浏览每一个机构。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:902
msgid ""
"First we check to make sure the body is not the player, because we do not "
"want to let the player be able to stab themselves. If the body is the "
"player, we use ``continue`` so we jump and look at the next body in "
"``bodies``."
msgstr ""
"首先我们检查以确保物体不是游戏角色，因为我们不想让游戏角色能够刺伤自己。 如果"
"物体是游戏角色，我们使用 ``continue`` ，所以我们跳过并看着 ``bodies`` 中的下"
"一个物体。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:905
msgid ""
"If we have not jumped to the next body, we then check to see if the body has "
"the ``bullet_hit`` function/method. If it does, we call it, passing in the "
"amount of damage a single knife swipe does (``DAMAGE``) and the global "
"transform of the :ref:`Area <class_Area>`."
msgstr ""
"如果我们没有跳到下一个物体，我们检查物体是否有 ``bullet_hit`` 函数/方法。 如"
"果确实如此，我们称之为，传递单刀划动所造成的伤害量(``DAMAGE``)和全局变换 :"
"ref:`Area <class_Area>`。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:908
msgid ""
"While we could attempt to calculate a rough location for where the knife hit "
"exactly, we are not going to because using the :ref:`Area <class_Area>`'s "
"position works well enough and the extra time needed to calculate a rough "
"position for each body is not worth the effort."
msgstr ""
"虽然我们可以尝试计算刀准确击中的粗略位置，但我们不会这样做，因为使用 :ref:"
"`Area <class_Area>` 的位置运行良好，并且计算粗略位置所需的额外时间 每个人都不"
"值得努力。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:913
msgid "Making the weapons work"
msgstr "制造武器"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:915
#, fuzzy
msgid "Let's start making the weapons work in ``Player.gd``."
msgstr "让我们开始在 ``Player.gd`` 中制作武器。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:917
#, fuzzy
msgid ""
"First let's start by adding some class variables we'll need for the weapons:"
msgstr "首先让我们首先添加一些我们需要的武器类变量:"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:935
#, fuzzy
msgid "Let's go over what these new variables will do:"
msgstr "让我们回顾一下这些新变量的作用:"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:937
msgid ""
"``animation_manager``: This will hold the :ref:`AnimationPlayer "
"<class_AnimationPlayer>` node and its script, which we wrote previously."
msgstr ""
"``animation_manager``:这将保存 :ref:`AnimationPlayer "
"<class_AnimationPlayer>` 节点及其脚本，我们之前写过。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:938
msgid ""
"``current_weapon_name``: The name of the weapon we are currently using. It "
"has four possible values: ``UNARMED``, ``KNIFE``, ``PISTOL``, and ``RIFLE``."
msgstr ""
"``current_weapon_name``:我们当前使用的武器的名称。 它有四个可能的值: "
"``UNARMED`` ， ``KNIFE`` ， ``PISTOL`` 和 ``RIFLE`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:939
#, fuzzy
msgid "``weapons``: A dictionary that will hold all the weapon nodes."
msgstr "``weapon``:一个包含所有武器节点的字典。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:940
msgid ""
"``WEAPON_NUMBER_TO_NAME``: A dictionary allowing us to convert from a "
"weapon's number to its name. We'll use this for changing weapons."
msgstr ""
"``WEAPON_NUMBER_TO_NAME``:允许我们从武器编号转换为其名称的字典。 我们将用它来"
"换武器。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:941
msgid ""
"``WEAPON_NAME_TO_NUMBER``: A dictionary allowing us to convert from a "
"weapon's name to its number. We'll use this for changing weapons."
msgstr ""
"``WEAPON_NAME_TO_NUMBER``:一个字典，允许我们从武器的名称转换为它的号码。 我们"
"将用它来换武器。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:942
msgid ""
"``changing_weapon``: A boolean to track whether or not we are changing guns/"
"weapons."
msgstr "``changing_weapon``:一个布尔值，用于跟踪我们是否正在改变枪支/武器。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:943
msgid "``changing_weapon_name``: The name of the weapon we want to change to."
msgstr "``changing_weapon_name``:我们想要改变的武器的名称。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:944
msgid ""
"``health``: How much health our player has. In this part of the tutorial we "
"will not be using it."
msgstr ""
"``health``:我们的球员有多少健康。 在本教程的这一部分中，我们将不会使用它。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:945
#, fuzzy
msgid ""
"``UI_status_label``: A label to show how much health we have, and how much "
"ammo we have both in our gun and in reserve."
msgstr ""
"``UI_status_label``:一个标签，显示我们有多少健康，以及我们在枪支和储备中有多"
"少弹药。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:949
msgid ""
"Next we need to add a few things in ``_ready``. Here's the new ``_ready`` "
"function:"
msgstr "接下来我们需要在 ``_ready`` 中添加一些东西。 这是新的 ``_ready`` 函数:"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:981
msgid "Let's go over what's changed."
msgstr "让我们回顾一下改变了什么。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:983
msgid ""
"First we get the :ref:`AnimationPlayer <class_AnimationPlayer>` node and "
"assign it to the ``animation_manager`` variable. Then we set the callback "
"function to a :ref:`FuncRef <class_FuncRef>` that will call the player's "
"``fire_bullet`` function. Right now we haven't written the ``fire_bullet`` "
"function, but we'll get there soon."
msgstr ""
"首先我们得到 :ref:`AnimationPlayer <class_AnimationPlayer>` 节点并将其分配给 "
"``animation_manager`` 变量。 然后我们将回调函数设置为 :ref:`FuncRef "
"<class_FuncRef>` ，它将调用游戏角色的 ``fire_bullet`` 函数。 现在我们还没有编"
"写 ``fire_bullet`` 函数，但我们很快就会到达那里。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:987
#, fuzzy
msgid ""
"Next we get all the weapon nodes and assign them to ``weapons``. This will "
"allow us to access the weapon nodes only with their name (``KNIFE``, "
"``PISTOL``, or ``RIFLE``)."
msgstr ""
"接下来我们获取所有武器节点并将它们分配给 ``weapon`` 。 这将允许我们只使用他们"
"的名字(``KNIFE``， ``PISTOL`` 或 ``RIFLE`` )来访问武器节点。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:990
msgid ""
"We then get ``Gun_Aim_Point``'s global position so we can rotate the "
"player's weapons to aim at it."
msgstr ""
"然后我们得到 ``Gun_Aim_Point`` 的全球位置，这样我们就可以旋转游戏角色的武器来"
"瞄准它。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:992
msgid "Then we go through each weapon in ``weapons``."
msgstr "然后我们通过“武器”中的每一件武器。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:994
msgid ""
"We first get the weapon node. If the weapon node is not ``null``, we then "
"set its ``player_node`` variable to this script (``Player.gd``). Then we "
"have it look at ``gun_aim_point_pos`` using the ``look_at`` function, and "
"then rotate it by ``180`` degrees on the ``Y`` axis."
msgstr ""
"我们首先得到武器节点。 如果武器节点不是“null”，那么我们将它的 "
"``player_node`` 变量设置为这个脚本(``Player.gd``)。 然后我们使用 ``look_at`` "
"函数查看 ``gun_aim_point_pos`` ，然后在 ``Y`` 轴上旋转 ``180`` 度。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:997
msgid ""
"We rotate all of those weapon points by ``180`` degrees on their ``Y`` axis "
"because our camera is pointing backwards. If we did not rotate all of these "
"weapon points by ``180`` degrees, all of the weapons would fire backwards."
msgstr ""
"我们将所有这些武器点在它们的“Y”轴上旋转“180”度，因为我们的相机指向后方。 如果"
"我们没有将所有这些武器点旋转“180”度，那么所有武器都会向后射击。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:1000
msgid ""
"Then we set ``current_weapon_name`` and ``changing_weapon_name`` to "
"``UNARMED``."
msgstr ""
"然后我们将 ``current_weapon_name`` 和 ``changing_weapon_name`` 设置为 "
"``UNARMED`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:1002
msgid "Finally, we get the UI :ref:`Label <class_Label>` from our HUD."
msgstr "最后，我们从我们的HUD获取UI :ref:`Label <class_Label>` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:1006
#, fuzzy
msgid ""
"Let's add a new function call to ``_physics_process`` so we can change "
"weapons. Here's the new code:"
msgstr ""
"让我们为 ``_physics_process`` 添加一个新的函数调用，这样我们就可以改变武器"
"了。 这是新代码:"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:1016
msgid "Now we will call ``process_changing_weapons``."
msgstr "现在我们将调用 ``process_changing_weapons`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:1020
#, fuzzy
msgid ""
"Now let's add all the player input code for the weapons in "
"``process_input``. Add the following code:"
msgstr ""
"现在让我们在 ``process_input`` 中添加武器的所有游戏角色输入代码。 添加以下代"
"码:"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:1060
#, fuzzy
msgid "Let's go over the additions, starting with how we're changing weapons."
msgstr "让我们回顾一下，从我们如何改变武器开始。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:1062
msgid ""
"First we get the current weapon's number and assign it to "
"``weapon_change_number``."
msgstr "首先，我们得到当前武器的数字并将其分配给 ``weapon_change_number`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:1064
msgid ""
"Then we check to see if any of the number keys (keys 1-4) are pressed. If "
"they are, we set ``weapon_change_number`` to the value mapped at that key."
msgstr ""
"然后我们检查是否按下了任何数字键(键1-4)。 如果是，我们将 "
"``weapon_change_number`` 设置为该键映射的值。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:1067
msgid ""
"The reason key 1 is mapped to ``0`` is because the first element in a list "
"is mapped to zero, not one. Most list/array accessors in most programming "
"languages start at ``0`` instead of ``1``. See https://en.wikipedia.org/wiki/"
"Zero-based_numbering for more information."
msgstr ""
"键1被映射到“0”的原因是因为列表中的第一个元素被映射到零而不是一个。 大多数编程"
"语言中的大多数列表/数组访问器都以 ``0`` 而不是 ``1`` 开头。 有关详细信息，请"
"参阅https://en.wikipedia.org/wiki/Zero-based_numbering。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:1070
#, fuzzy
msgid ""
"Next we check to see if ``shift_weapon_positive`` or "
"``shift_weapon_negative`` is pressed. If one of them is, we add/subtract "
"``1`` from ``weapon_change_number``."
msgstr ""
"接下来我们检查是否按下了``shift weapon positive``或``shift weapon "
"negative``。 如果其中之一，我们从 ``weapon_change_number`` 添加/减去 ``1`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:1073
msgid ""
"Because the player may have shifted ``weapon_change_number`` outside of the "
"number of weapons the player has, we clamp it so it cannot exceed the "
"maximum number of weapons the player has and it ensures "
"``weapon_change_number`` is ``0`` or more."
msgstr ""
"因为游戏角色可能已经在游戏角色拥有的武器数量之外移动了 "
"``weapon_change_number`` ，我们将其钳制，使其不能超过游戏角色拥有的最大武器数"
"量，并确保 ``weapon_change_number`` 为“0”。 或者更多。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:1076
msgid ""
"Then we check to make sure the player is not already changing weapons. If "
"the player is not, we then check to see if the weapon the player wants to "
"change to is a new weapon and not the weapon the player is currently using. "
"If the weapon the player is wanting to change to is a new weapon, we then "
"set ``changing_weapon_name`` to the weapon at ``weapon_change_number`` and "
"set ``changing_weapon`` to true."
msgstr ""
"然后我们检查以确保游戏角色还没有更换武器。 如果游戏角色不是，我们会检查游戏角"
"色想要改变的武器是否是新武器，而不是游戏角色当前使用的武器。 如果游戏角色想要"
"改变的武器是一种新武器，那么我们将 ``changing_weapon_name`` 设置为 "
"``weapon_change_number`` 中的武器并将 ``changing_weapon`` 设置为true。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:1080
msgid ""
"For firing the weapon we first check to see if the ``fire`` action is "
"pressed. Then we check to make sure the player is not changing weapons. Next "
"we get the weapon node for the current weapon."
msgstr ""
"为了发射武器，我们首先检查是否按下了 ``fire`` 动作。 然后我们检查确保游戏角色"
"没有更换武器。 接下来，我们获得当前武器的武器节点。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:1084
msgid ""
"If the current weapon node does not equal null, and the player is in its "
"``IDLE_ANIM_NAME`` state, we set the player's animation to the current "
"weapon's ``FIRE_ANIM_NAME``."
msgstr ""
"如果当前武器节点不等于null，并且游戏角色处于“IDLE_ANIM_NAME”状态，我们将游戏"
"角色的动画设置为当前武器的“FIRE_ANIM_NAME”。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:1089
#, fuzzy
msgid "Let's add ``process_changing_weapons`` next."
msgstr "让我们接下来添加 ``process_changing_weapons`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:1127
#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:533
#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:290
msgid "Let's go over what's happening here:"
msgstr "让我们回顾一下这里发生的事情:"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:1129
msgid ""
"The first thing we do is make sure we've received input to change weapons. "
"We do this by making sure ``changing_weapons`` is ``true``."
msgstr ""
"我们要做的第一件事就是确保我们收到改变武器的投入。 我们通过确保 "
"``changing_weapons`` 是 ``true`` 来做到这一点。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:1131
msgid ""
"Next we define a variable (``weapon_unequipped``) so we can check whether "
"the current weapon has been successfully unequipped or not."
msgstr ""
"接下来我们定义一个变量(``weapon_unequipped``)，这样我们就可以检查当前的武器是"
"否已成功装备。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:1133
msgid "Then we get the current weapon from ``weapons``."
msgstr "然后我们从“武器”中获取当前的武器。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:1135
#, fuzzy
msgid ""
"If the current weapon is not ``null``, then we need to check whether the "
"weapon is enabled. If the weapon is enabled, we call its ``unequip_weapon`` "
"function so it will start the unequip animation. If the weapon is not "
"enabled, we set ``weapon_unequipped`` to ``true`` because the weapon has "
"successfully been unequipped."
msgstr ""
"如果当前武器不是“null”，那么我们需要检查武器是否启用。 如果武器已启用，我们将"
"其称为 ``unequip_weapon`` 函数，以便启动非全景动画。 如果没有启用武器，我们"
"将 ``weapon_unequipped`` 设置为 ``true`` ，因为武器已成功装备。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:1138
msgid ""
"If the current weapon is ``null``, then we can simply set "
"``weapon_unequipped`` to ``true``. The reason we do this check is because "
"there is no weapon script/node for ``UNARMED``, but there is also no "
"animations for ``UNARMED``, so we can just start equipping the weapon the "
"player wants to change to."
msgstr ""
"如果当前武器是“null”，那么我们可以简单地将 ``weapon_unequipped`` 设置为 "
"``true`` 。 我们做这个检查的原因是因为 ``UNARMED`` 没有武器脚本/节点，但是 "
"``UNARMED`` 也没有动画，所以我们可以开始装备游戏角色想要改变的武器。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:1141
msgid ""
"If the player has successfully unequipped the current weapon "
"(``weapon_unequipped == true``), we need to equip the new weapon."
msgstr ""
"如果游戏角色已成功装备当前武器(``weapon_unequipped == true``)，我们需要装备新"
"武器。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:1143
msgid ""
"First we define a new variable (``weapon_equipped``) for tracking whether "
"the player has successfully equipped the new weapon or not."
msgstr ""
"首先，我们定义一个新变量(``weapon_equipped``)，用于跟踪游戏角色是否成功装备了"
"新武器。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:1145
msgid ""
"Then we get the weapon the player wants to change to. If the weapon the "
"player wants to change to is not ``null``, we then check to see whether it's "
"enabled or not. If it is not enabled, we call its ``equip_weapon`` function "
"so it starts to equip the weapon. If the weapon is enabled, we set "
"``weapon_equipped`` to ``true``."
msgstr ""
"然后我们得到游戏角色想要改变的武器。 如果游戏角色想要改变的武器不是“空”，那么"
"我们检查它是否被启用。 如果它没有启用，我们称其为 ``equip_weapon`` 函数，因此"
"它开始装备武器。 如果武器已启用，我们将 ``weapon_equipped`` 设置为 "
"``true`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:1148
msgid ""
"If the weapon the player wants to change to is ``null``, we simply set "
"``weapon_equipped`` to ``true`` because we do not have any node/script for "
"``UNARMED``, nor do we have any animations."
msgstr ""
"如果游戏角色想要改变的武器是“null”，我们只需将 ``weapon_equipped`` 设置为 "
"``true`` ，因为我们没有“UNARMED”的任何节点/脚本，我们也没有 任何动画。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:1151
#, fuzzy
msgid ""
"Finally, we check to see whether the player has successfully equipped the "
"new weapon. If (s)he has done so, we set ``changing_weapon`` to ``false`` "
"because the player is no longer changing weapons. We also set "
"``current_weapon_name`` to ``changing_weapon_name`` since the current weapon "
"has changed, and then we set ``changing_weapon_name`` to an empty string."
msgstr ""
"最后，我们检查游戏角色是否已成功装备新武器。 如果游戏角色有，我们将 "
"``changing_weapon`` 设置为 ``false`` ，因为游戏角色不再更换武器。 我们还将 "
"``current_weapon_name`` 设置为 ``changing_weapon_name`` ，因为当前武器已经改"
"变，然后我们将 ``changing_weapon_name`` 设置为空字符串。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:1157
msgid ""
"Now, we need to add one more function to the player, and then the player is "
"ready to start firing the weapons!"
msgstr "现在，我们需要为游戏角色增加一个功能，然后游戏角色就可以开始射击武器！"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:1159
msgid ""
"We need to add ``fire_bullet``, which will be called by the :ref:"
"`AnimationPlayer <class_AnimationPlayer>` at those points we set earlier in "
"the :ref:`AnimationPlayer <class_AnimationPlayer>` function track:"
msgstr ""
"我们需要添加 ``fire_bullet`` ，它将由 :ref:`AnimationPlayer "
"<class_AnimationPlayer>` 调用，我们在前面设置的那些点 :ref:`AnimationPlayer "
"<class_AnimationPlayer>` 函数轨道:"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:1171
#, fuzzy
msgid "Let's go over what this function does:"
msgstr "让我们回顾一下这个功能的作用。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:1173
#, fuzzy
msgid ""
"First we check to see whether the player is changing weapons. If the player "
"is changing weapons, we do not want shoot, so we ``return``."
msgstr ""
"首先，我们检查游戏角色是否正在更换武器。 如果游戏角色正在更换武器，我们不想拍"
"摄，所以我们“返回”。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:1175
msgid ""
"Calling ``return`` stops the rest of the function from being called. In this "
"case, we are not returning a variable because we are only interested in not "
"running the rest of the code, and because we are not looking for a returned "
"variable either when we call this function."
msgstr ""
"调用 ``return`` 会停止调用函数的其余部分。 在这种情况下，我们不返回变量，因为"
"我们只对不运行其余代码感兴趣，并且因为我们在调用此函数时不会查找返回的变量。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:1179
msgid ""
"Then we tell the current weapon the player is using to fire by calling its "
"``fire_weapon`` function."
msgstr ""
"然后我们通过调用它的 ``fire_weapon`` 函数来告诉游戏角色正在使用的当前武器。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:1181
msgid ""
"Remember how we mentioned the speed of the animations for firing was faster "
"than the other animations? By changing the firing animation speeds, you can "
"change how fast the weapon fires bullets!"
msgstr ""
"还记得我们如何提到射击动画的速度比其他动画更快吗？ 通过改变射击动画速度，您可"
"以改变武器射击子弹的速度！"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:1187
msgid ""
"Before we are ready to test our new weapons, we still have a little bit of "
"work to do."
msgstr "在我们准备测试新武器之前，我们还有一些工作要做。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:1190
msgid "Creating some test subjects"
msgstr "创建一些测试科目"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:1192
msgid ""
"Create a new script by going to the scripting window, clicking \"file\", and "
"selecting new. Name this script ``RigidBody_hit_test`` and make sure it "
"extends :ref:`RigidBody <class_RigidBody>`."
msgstr ""
"通过转到脚本窗口，单击“文件”，然后选择新脚本来创建新脚本。 将此脚本命名为 "
"``RigidBody_hit_test`` 并确保它扩展 :ref:`RigidBody <class_RigidBody>`。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:1195
msgid "Now we need to add this code:"
msgstr "现在我们需要添加以下代码:"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:1212
#, fuzzy
msgid "Let's go over how ``bullet_hit`` works:"
msgstr "让我们回顾一下 ``bullet_hit`` 的工作原理:"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:1215
msgid ""
"First we get the bullet's forward directional vector. This is so we can tell "
"from which direction the bullet will hit the :ref:`RigidBody "
"<class_RigidBody>`. We will use this to push the :ref:`RigidBody "
"<class_RigidBody>` in the same direction as the bullet."
msgstr ""
"首先，我们得到子弹的前向方向向量。 这样我们可以知道子弹将从哪个方向击中 :ref:"
"`RigidBody <class_RigidBody>`。 我们将使用它来推送 :ref:`RigidBody "
"<class_RigidBody>` 与子弹的方向相同。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:1218
msgid ""
"We need to boost the directional vector by ``BASE_BULLET_BOOST`` so the "
"bullets pack a bit more of a punch and move the :ref:`RigidBody "
"<class_RigidBody>` nodes in a visible way. You can just set "
"``BASE_BULLET_BOOST`` to lower or higher values if you want less or more of "
"a reaction when the bullets collide with the :ref:`RigidBody "
"<class_RigidBody>`."
msgstr ""
"我们需要通过 ``BASE_BULLET_BOOST`` 来增加方向向量，这样子弹可以打包更多，并以"
"可见的方式移动 :ref:`RigidBody <class_RigidBody>` 节点。 如果在子弹与 :ref:"
"`RigidBody <class_RigidBody>` 发生冲突时想要更少或更多的反应，您可以将 "
"``BASE_BULLET_BOOST`` 设置为更低或更高的值。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:1222
msgid "Then we apply an impulse using ``apply_impulse``."
msgstr "然后我们使用 ``apply_impulse`` 来施加冲动。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:1224
msgid ""
"First, we need to calculate the position for the impulse. Because "
"``apply_impulse`` takes a vector relative to the :ref:`RigidBody "
"<class_RigidBody>`, we need to calculate the distance from the :ref:"
"`RigidBody <class_RigidBody>` to the bullet. We do this by subtracting the :"
"ref:`RigidBody <class_RigidBody>`'s global origin/position from the bullet's "
"global origin/position. This gets us the distance from the :ref:`RigidBody "
"<class_RigidBody>` to the bullet. We normalize this vector so the size of "
"the collider does not effect how much the bullets move the :ref:`RigidBody "
"<class_RigidBody>`."
msgstr ""
"首先，我们需要计算冲动的位置。 因为 ``apply_impulse`` 采用相对于 :ref:"
"`RigidBody <class_RigidBody>的向量，我们需要计算从 :ref:`RigidBody "
"<class_RigidBody>` 到子弹的距离。 我们通过从子弹的全局原点/位置减去 :ref:"
"`RigidBody <class_RigidBody>的全局原点/位置来做到这一点。 这使我们与 :ref:"
"`RigidBody <class_RigidBody>` 到子弹的距离。 我们规范化这个向量，这样对撞机的"
"大小不会影响子弹移动的程度 :ref:`RigidBody <class_RigidBody>`。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:1230
#, fuzzy
msgid ""
"Finally, we need to calculate the force for the impulse. For this, we use "
"the direction the bullet is facing and multiply it by the bullet's damage. "
"This gives a nice result and for stronger bullets, we get a stronger result."
msgstr ""
"最后，我们需要计算冲动力。 为此，我们使用子弹面向的方向并将其乘以子弹的伤"
"害。 这给出了一个很好的结果，对于更强的子弹，我们得到了更强的结果。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:1235
#, fuzzy
msgid ""
"Now we need to attach this script to all of the :ref:`RigidBody "
"<class_RigidBody>` nodes we want to affect."
msgstr ""
"现在我们需要将这个脚本附加到我们想要生效的所有 :ref:`RigidBody "
"<class_RigidBody>` 节点。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:1237
#, fuzzy
msgid ""
"Open up ``Testing_Area.tscn`` and select all the cubes parented to the "
"``Cubes`` node."
msgstr "打开 ``Testing_Area.tscn`` 并选择所有以'`Cubes``节点为父级的立方体。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:1239
#, fuzzy
msgid ""
"If you select the top cube, and then hold down ``shift`` and select the last "
"cube, Godot will select all the cubes in-between!"
msgstr ""
"如果选择顶部立方体，然后按住“shift”并选择最后一个立方体，Godot将选择其间的所"
"有立方体！"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:1242
#, fuzzy
msgid ""
"Once you have all the cubes selected, scroll down in the inspector until you "
"get to the \"scripts\" section. Click the drop down and select \"Load\". "
"Open your newly created ``RigidBody_hit_test.gd`` script."
msgstr ""
"选择所有多维数据集后，在属性面板中向下滚动，直到进入“脚本”部分。 单击下拉列表"
"并选择“加载”。 打开新创建的 ``RigidBody_hit_test.gd`` 脚本。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:1250
#, fuzzy
msgid ""
"That was a lot of code! But now, with all that done, you can go and give "
"your weapons a test!"
msgstr "那是很多代码！ 但是现在完成所有这些，您可以去测试您的武器了！"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:1252
#, fuzzy
msgid ""
"You should now be able to fire as many bullets as you want at the cubes and "
"they will move in response to the bullets colliding with them."
msgstr "您现在应该可以在立方体上发射任意数量的子弹，它们会随着子弹碰撞而移动。"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:1255
msgid ""
"In :ref:`doc_fps_tutorial_part_three`, we will add ammo to the weapons, as "
"well as some sounds!"
msgstr ""
"在 :ref:`doc_fps_tutorial_part_three`中，我们将为武器添加弹药以及一些声音！"

#: ../../docs/tutorials/3d/fps_tutorial/part_two.rst:1259
msgid ""
"You can download the finished project for this part here: :download:"
"`Godot_FPS_Part_2.zip <files/Godot_FPS_Part_2.zip>`"
msgstr ""
"您可以在这里下载这个部分的完成项目: :download:`Godot_FPS_Part_2.zip <files / "
"Godot_FPS_Part_2.zip>`"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:4
msgid "Part 3"
msgstr "第3部分"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:9
#, fuzzy
msgid ""
"In this part, we will be limiting the player's weapons by giving them ammo. "
"We will also be giving the player the ability to reload, and we will be "
"adding sounds when the weapons fire."
msgstr ""
"在这部分中，我们将通过给予弹药来限制游戏角色的武器。 我们还将为游戏角色提供重"
"新加载的能力，并且当武器射击时我们将添加声音。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:15
msgid ""
"You are assumed to have finished :ref:`doc_fps_tutorial_part_two` before "
"moving on to this part of the tutorial. The finished project from :ref:"
"`doc_fps_tutorial_part_two` will be the starting project for part 3"
msgstr ""
"在继续本教程的这一部分之前，我们假设您已经完成了 :ref:"
"`doc_fps_tutorial_part_two`。 完成的项目来自 :ref:`doc_fps_tutorial_part_two`"
"将成为第3部分的起始项目"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:22
msgid "Changing levels"
msgstr "改变水平"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:24
#, fuzzy
msgid ""
"Now that we have a fully working FPS, let's move to a more FPS-like level."
msgstr "现在我们已经有了一个完全正常工作的FPS，让我们转向更高级别的FPS。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:26
msgid ""
"Open up ``Space_Level.tscn`` (``assets/Space_Level_Objects/Space_Level."
"tscn``) and/or ``Ruins_Level.tscn`` (``assets/Ruin_Level_Objects/Ruins_Level."
"tscn``)."
msgstr ""
"打开 ``Space_Level.tscn`` (``assets / Space_Level_Objects / Space_Level."
"tscn``)和/或 ``Ruins_Level.tscn`` (``assets / Ruin_Level_Objects / "
"Ruins_Level.tscn``)。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:28
#, fuzzy
msgid ""
"``Space_Level.tscn`` and ``Ruins_Level.tscn`` are complete custom FPS levels "
"created for the purpose of this tutorial. Press ``F6`` to play the open "
"scene, or press the ``play current scene button``, and give each a try."
msgstr ""
"``Space_Level.tscn``和``Ruins_Level.tscn``是为本教程的目的而创建的完整自定义"
"FPS级别。 按“F6`”播放打开的场景，或按“播放当前场景按钮”，然后给它们旋转一下。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:31
msgid ""
"``Space_Level.tscn`` is more graphically demanding of the GPU than "
"``Ruins_Level.tscn``. If your computer is struggling to render ``Space_Level."
"tscn``, try using ``Ruins_Level.tscn`` instead."
msgstr ""
"``Space_Level.tscn``对于GPU的图形要求比``Ruins_Level.tscn``更高。 如果您的计"
"算机正在努力渲染 ``Space_Level.tscn`` ，请尝试使用 ``Ruins_Level.tscn`` 代"
"替。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:34
msgid ""
"You might have noticed there are several :ref:`RigidBody <class_RigidBody>` "
"nodes placed throughout the level. We can place ``RigidBody_hit_test.gd`` on "
"them and then they will react to being hit with bullets, so let's do that!"
msgstr ""
"您可能已经注意到有几个 :ref:`RigidBody <class_RigidBody>` 节点放在整个关卡"
"中。 我们可以在它们上面放置 ``RigidBody_hit_test.gd`` 然后它们会对被子弹击中"
"做出反应，所以让我们这样做吧！"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:37
msgid ""
"Follow the instructions below for either (or both) of the scenes you want to "
"use"
msgstr "按照以下说明选择您要使用的场景中的任何一个(或两个)"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:73
#, fuzzy
msgid ""
"Now you can fire at all the rigid bodies in either level and they will react "
"to bullets hitting them!"
msgstr "现在您可以射击任何级别的所有刚体，它们会对撞击它们的子弹作出反应！"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:76
msgid "Adding ammo"
msgstr "添加弹药"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:78
msgid ""
"Now that the player has working guns, let's give them a limited amount of "
"ammo."
msgstr "现在游戏角色有枪，让我们给他们一些有限的弹药。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:80
#, fuzzy
msgid ""
"Firstly, we need to define a few variables in each of our weapon scripts."
msgstr "首先，我们需要在每个武器脚本中定义一些变量。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:82
#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:191
msgid "Open up ``Weapon_Pistol.gd`` and add the following class variables:"
msgstr "打开 ``Weapon_Pistol.gd`` 并添加以下类变量:"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:90
msgid "``ammo_in_weapon``: The amount of ammo currently in the pistol"
msgstr "``ammo_in_weapon``:手枪中弹药的数量"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:91
msgid ""
"``spare_ammo``: The amount of ammo we have left in reserve for the pistol"
msgstr "``spare_ammo``:我们为手枪留下的弹药量"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:92
#, fuzzy
msgid "``AMMO_IN_MAG``: The amount of ammo in a fully reloaded weapon/magazine"
msgstr "``AMMO_IN_MAG``:完全重装武器/杂志中的弹药数量"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:94
msgid "Now all we need to do is add a single line of code to ``fire_weapon``."
msgstr "现在我们需要做的就是在 ``fire_weapon`` 中添加一行代码。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:96
msgid ""
"Add the following right under ``Clone.BULLET_DAMAGE = DAMAGE``: "
"``ammo_in_weapon -= 1``"
msgstr ""
"在``Clone.BULLET_DAMAGE = DAMAGE``下添加以下内容:``ammo_in_weapon - = 1``"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:98
#, fuzzy
msgid ""
"This will remove one from ``ammo_in_weapon`` every time the player fires. "
"Notice we're not checking to see if the player has enough ammo or not in "
"``fire_weapon``. Instead, we're going to check to see if the player has "
"enough ammo in ``Player.gd``."
msgstr ""
"每次游戏角色开火时，这将从“ammo_in_weapon”中删除一个。 请注意，我们没有检查游"
"戏角色是否在“fire_weapon”中有足够的弹药。 相反，我们将检查游戏角色是否"
"在“Player.gd”中有足够的弹药。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:103
msgid "Now we need to add ammo for both the rifle and the knife."
msgstr "现在我们需要为步枪和刀子添加弹药。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:105
#, fuzzy
msgid ""
"You may be wondering why we are adding ammo for the knife given it does not "
"consume any ammunition. The reason we want to add ammo to the knife is so we "
"have a consistent interface for all our weapons."
msgstr ""
"您可能想知道为什么我们为刀子添加弹药，因为它不消耗任何弹药。 我们想要给刀子添"
"加弹药的原因是我们为所有武器提供了一致的界面。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:108
#, fuzzy
msgid ""
"If we did not add ammo variables for the knife, we would have to add checks "
"for the knife. By adding the ammo variables to the knife, we don't need to "
"worry about whether or not all our weapons have the same variables."
msgstr ""
"如果我们没有为刀子添加弹药变量，我们将不得不添加刀具检查。 通过将弹药变量添加"
"到刀具中，我们无需担心我们的武器是否具有相同的变量。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:111
msgid "Add the following class variables to ``Weapon_Rifle.gd``:"
msgstr "将以下类变量添加到``Weapon_Rifle.gd``:"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:119
msgid ""
"And then add the following to ``fire_weapon``: ``ammo_in_weapon -= 1``. Make "
"sure that ``ammo_in_weapon -= 1`` is outside of the ``if ray."
"is_colliding()`` check so the player loses ammo regardless of whether the "
"player hit something or not."
msgstr ""
"然后将以下内容添加到``fire_weapon``:``ammo_in_weapon - = 1``。 确保"
"``ammo_in_weapon - = 1``在``if ray.is_colliding()``之后检查，这样无论游戏角色"
"是否击中某个东西，游戏角色都会失去弹药。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:122
msgid ""
"Now all that's left is the knife. Add the following to ``Weapon_Knife.gd``:"
msgstr "现在剩下的就是刀。 将以下内容添加到``Weapon_Knife.gd``:"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:130
#, fuzzy
msgid "Because the knife does not consume ammo, that is all we need to add."
msgstr "因为刀不消耗弹药，所以我们需要添加。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:134
#, fuzzy
msgid "Now we need to change one thing in ``Player.gd``, that is to say,"
msgstr "现在我们需要做的就是改变 ``Player.gd`` 中的一件事。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:136
#, fuzzy
msgid ""
"how we're firing the weapons in ``process_input``. Change the code for "
"firing weapons to the following:"
msgstr ""
"我们需要改变我们在 ``process_input`` 中发射武器的方式。 将发射武器的代码更改"
"为以下内容:"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:151
msgid ""
"Now the weapons have a limited amount of ammo, and will stop firing when the "
"player runs out."
msgstr "现在武器的弹药数量有限，并且当游戏角色用尽时将停止射击。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:155
#, fuzzy
msgid ""
"Ideally, we'd like to let the player be able to see how much ammo is left. "
"Let's make a new function called ``process_UI``."
msgstr ""
"理想情况下，我们想让游戏角色能够看到剩下多少弹药。 让我们创建一个名为 "
"``process_UI`` 的新函数。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:157
msgid "First, add ``process_UI(delta)`` to ``_physics_process``."
msgstr "首先，将 ``process_UI(delta)`` 添加到 ``_physics_process``。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:159
msgid "Now add the following to ``Player.gd``:"
msgstr "现在将以下内容添加到 ``Player.gd``:"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:171
#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:233
#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:216
msgid "Let's go over what's happening:"
msgstr "让我们回顾一下发生的事情:"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:173
#, fuzzy
msgid ""
"Firstly, we check to see if the current weapon is either ``UNARMED`` or "
"``KNIFE``. If it is, we change the ``UI_status_label``'s text to only show "
"the player's health since ``UNARMED`` and ``KNIFE`` do not consume ammo."
msgstr ""
"首先，我们检查当前武器是“UNARMED”还是“KNIFE”。 如果是，我们改变 "
"``UI_status_label`` 的文本只显示游戏角色的健康状况，因为 ``UNARMED`` 和 "
"``KNIFE`` 不消耗弹药。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:176
msgid ""
"If the player is using a weapon that consumes ammo, we first get the weapon "
"node."
msgstr "如果游戏角色正在使用消耗弹药的武器，我们首先获得武器节点。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:178
#, fuzzy
msgid ""
"Then we change ``UI_status_label``'s text to show the player's health, along "
"with how much ammo the player has in the weapon and how much spare ammo the "
"player has for that weapon."
msgstr ""
"然后改变 ``UI_status_label`` 的文字，以显示游戏角色的健康状况，游戏角色在武器"
"中的弹药量以及游戏角色对该武器的弹药量。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:182
msgid "Now we can see how much ammo the player has through the HUD."
msgstr "现在我们可以看到游戏角色通过HUD获得了多少弹药。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:185
msgid "Adding reloading to the weapons"
msgstr "添加重装到武器"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:187
msgid ""
"Now that the player can run out of ammo, we need a way to let the player "
"fill them back up. Let's add reloading next!"
msgstr ""
"现在游戏角色可以用尽弹药，我们需要一种方法让游戏角色填补它们。 我们接下来再添"
"加重装！"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:189
#, fuzzy
msgid ""
"For reloading, we need to add a few more variables and a function to every "
"weapon."
msgstr "对于重新加载，我们需要为每个武器添加一些变量和一个函数。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:200
msgid ""
"``CAN_RELOAD``: A boolean to track whether this weapon has the ability to "
"reload"
msgstr "``CAN_RELOAD``:一个布尔值，用于跟踪此武器是否具有重新加载的能力"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:201
msgid ""
"``CAN_REFILL``: A boolean to track whether we can refill this weapon's spare "
"ammo. We will not be using ``CAN_REFILL`` in this part, but we will in the "
"next part!"
msgstr ""
"``CAN_REFILL``:一个布尔值，用于跟踪我们是否可以重新填充此武器的备用弹药。 我"
"们不会在这部分使用 ``CAN_REFILL`` ，但我们将在下一部分中使用！"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:202
msgid ""
"``RELOADING_ANIM_NAME``: The name of the reloading animation for this weapon."
msgstr "``RELOADING_ANIM_NAME``:此武器的重新加载动画的名称。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:204
msgid ""
"Now we need to add a function for handling reloading. Add the following "
"function to ``Weapon_Pistol.gd``:"
msgstr ""
"现在我们需要添加一个处理重载的函数。 将以下函数添加到``Weapon_Pistol.gd``:"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:235
msgid ""
"First we define a variable to see whether or not this weapon can reload."
msgstr "首先，我们定义一个变量，以查看此武器是否可以重新加载。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:237
msgid ""
"Then we check to see if the player is in this weapon's idle animation state "
"because we only want to be able to reload when the player is not firing, "
"equipping, or unequipping."
msgstr ""
"然后我们检查游戏角色是否处于这个武器的空闲动画状态，因为我们只希望能够在游戏"
"角色没有开火，装备或无装备时重新加载。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:240
#, fuzzy
msgid ""
"Next we check to see if the player has spare ammo, and if the ammo already "
"in the weapon is equal to a fully reloaded weapon. This way we can ensure "
"the player cannot reload when the player has no ammo or when the weapon is "
"already full of ammo."
msgstr ""
"接下来我们检查游戏角色是否有备用弹药，以及武器中已有的弹药是否等于完全重装的"
"武器。 这样我们可以确保当游戏角色没有弹药或者武器已经装满弹药时游戏角色无法重"
"新加载。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:243
#, fuzzy
msgid ""
"If we can still reload, then we calculate the amount of ammo needed to "
"reload the weapon."
msgstr "如果我们仍然可以重新加载，那么我们计算重装武器所需的弹药量。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:245
msgid ""
"If the player has enough ammo to fill the weapon, we remove the ammo needed "
"from ``spare_ammo`` and then set ``ammo_in_weapon`` to a full weapon/"
"magazine."
msgstr ""
"如果游戏角色有足够的弹药来填充武器，我们从 ``spare_ammo`` 中移除所需的弹药，"
"然后将'ammo_in_weapon``设置为完整的武器/杂志。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:247
#, fuzzy
msgid ""
"If the player does not have enough ammo, we add all the ammo left in "
"``spare_ammo``, and then set ``spare_ammo`` to ``0``."
msgstr ""
"如果游戏角色没有足够的弹药，我们在 ``spare_ammo`` 中添加所有弹药，然后将 "
"``spare_ammo`` 设置为 ``0`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:249
msgid ""
"Next we play the reloading animation for this weapon, and then return "
"``true``."
msgstr "接下来我们播放这个武器的重新加载动画，然后返回 ``true`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:251
msgid "If the player could not reload, we return ``false``."
msgstr "如果游戏角色无法重新加载，我们会返回“false”。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:255
msgid ""
"Now we need to add reloading to the rifle. Open up ``Weapon_Rifle.gd`` and "
"add the following class variables:"
msgstr ""
"现在我们需要为步枪添加重装。 打开 ``Weapon_Rifle.gd`` 并添加以下类变量:"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:264
msgid ""
"These variables are exactly the same as the pistol, just with "
"``RELOADING_ANIM_NAME`` changed to the rifle's reloading animation."
msgstr ""
"这些变量与手枪完全相同，只是将“RELOADING_ANIM_NAME”改为步枪的重装动画。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:266
msgid "Now we need to add ``reload_weapon`` to ``Weapon_Rifle.gd``:"
msgstr "现在我们需要将 ``reload_weapon`` 添加到``Weapon_Rifle.gd``:"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:295
#, fuzzy
msgid "This code is exactly the same as the one for the pistol."
msgstr "此代码与手枪完全相同。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:299
msgid ""
"The last bit we need to do for the weapons is add 'reloading' to the knife. "
"Add the following class variables to ``Weapon_Knife.gd``:"
msgstr ""
"我们需要为武器做的最后一点是向刀子添加“重装”。 将以下类变量添加到"
"``Weapon_Knife.gd``:"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:308
msgid ""
"Since we both cannot reload or refill a knife, we set both constants to "
"``false``. We also define ``RELOADING_ANIM_NAME`` as an empty string, since "
"the knife has no reloading animation."
msgstr ""
"由于我们都无法重新加载或重新填充刀，我们将两个常量都设置为“false”。 我们还将 "
"``RELOADING_ANIM_NAME`` 定义为空字符串，因为该刀没有重新加载动画。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:311
msgid "Now we need to add ``reloading_weapon``:"
msgstr "现在我们需要添加``reloading_weapon``:"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:318
msgid "Since we cannot reload a knife, we always return ``false``."
msgstr "由于我们无法重装刀，我们总是返回 ``false`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:321
msgid "Adding reloading to the player"
msgstr "添加重新加载到游戏角色"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:323
msgid ""
"Now we need to add a few things to ``Player.gd``. First we need to define a "
"new class variable:"
msgstr ""
"现在我们需要在 ``Player.gd`` 中添加一些内容。 首先，我们需要定义一个新的类变"
"量:"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:329
msgid ""
"``reloading_weapon``: A variable to track whether or not the player is "
"currently trying to reload."
msgstr ""
"``reloading_weapon``:一个变量，用于跟踪游戏角色当前是否正在尝试重新加载。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:332
msgid "Next we need to add another function call to ``_physics_process``."
msgstr "接下来我们需要为 ``_physics_process`` 添加另一个函数调用。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:334
msgid ""
"Add ``process_reloading(delta)`` to ``_physics_process``. Now "
"``_physics_process`` should look something like this:"
msgstr ""
"将 ``process_reloading(delta)`` 添加到 ``_physics_process`` 。 现在 "
"``_physics_process`` 应该是这样的:"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:345
msgid ""
"Now we need to add ``process_reloading``. Add the following function to "
"``Player.gd``:"
msgstr ""
"现在我们需要添加 ``process_reloading`` 。 将以下函数添加到``Player.gd``:"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:356
#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:407
#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:362
#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:424
msgid "Let's go over what's happening here."
msgstr "让我们回顾一下这里发生的事情。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:358
#, fuzzy
msgid "Firstly, we check to make sure the player is trying to reload."
msgstr "首先，我们检查以确保游戏角色正在尝试重新加载。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:360
msgid ""
"If the player is trying to reload, we then get the current weapon. If the "
"current weapon does not equal ``null``, we call its ``reload_weapon`` "
"function."
msgstr ""
"如果游戏角色正在尝试重新加载，我们将获得当前的武器。 如果当前武器不等于 "
"``null`` ，我们称之为 ``reload_weapon`` 函数。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:362
msgid ""
"If the current weapon is equal to ``null``, then the current weapon is "
"``UNARMED``."
msgstr "如果当前武器等于“null”，则当前武器为“UNARMED”。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:364
#, fuzzy
msgid ""
"Finally, we set ``reloading_weapon`` to ``false`` because, regardless of "
"whether the player successfully reloaded, we've tried reloading and no "
"longer need to keep trying."
msgstr ""
"最后，我们将 ``reloading_weapon`` 设置为 ``false`` ，因为不管游戏角色是否成功"
"重载，我们都尝试重新加载，不再需要继续尝试。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:369
msgid ""
"Before we can let the player reload, we need to change a few things in "
"``process_input``."
msgstr ""
"在我们让游戏角色重新加载之前，我们需要在 ``process_input`` 中更改一些内容。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:371
#, fuzzy
msgid ""
"The first thing we need to change is in the code for changing weapons. We "
"need to add an additional check (``if reloading_weapon == false:``) to see "
"if the player is reloading:"
msgstr ""
"我们需要改变的第一件事是改变武器的代码。 我们需要添加一个额外的检查(``if "
"reloading_weapon == false:``)以查看游戏角色是否正在重新加载:"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:382
msgid ""
"This makes it so the player cannot change weapons if the player is reloading."
msgstr "这使得如果游戏角色重新加载，游戏角色无法改变武器。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:384
msgid ""
"Now we need to add the code to trigger a reload when the player pushes the "
"``reload`` action. Add the following code to ``process_input``:"
msgstr ""
"现在我们需要添加代码以在游戏角色按下“reload”动作时触发重新加载。 将以下代码添"
"加到``process_input``:"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:409
msgid ""
"First we make sure the player is not reloading already, nor is the player "
"trying to change weapons."
msgstr "首先，我们确保游戏角色没有重新加载，游戏角色也不会尝试更换武器。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:411
msgid "Then we check to see if the ``reload`` action has been pressed."
msgstr "然后我们检查是否按下了 ``reload`` 动作。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:413
#, fuzzy
msgid ""
"If the player has pressed ``reload``, we then get the current weapon and "
"check to make sure it is not ``null``. Then we check to see whether the "
"weapon can reload or not using its ``CAN_RELOAD`` constant."
msgstr ""
"如果游戏角色按下了“reload”，我们就会得到当前的武器并检查以确保它不是“null”。 "
"然后我们检查武器是否可以使用其 ``CAN_RELOAD`` 常量重新加载。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:416
msgid ""
"If the weapon can reload, we then get the current animation state, and make "
"a variable for tracking whether the player is already reloading or not."
msgstr ""
"如果武器可以重新加载，我们将获得当前动画状态，并创建一个变量来跟踪游戏角色是"
"否已经重新加载。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:418
msgid ""
"We then go through every weapon to make sure the player is not already "
"playing that weapon's reloading animation."
msgstr "然后我们通过每一件武器来确保游戏角色还没有玩过那个武器的重装动画。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:420
#, fuzzy
msgid ""
"If the player is not reloading any weapon, we set ``reloading_weapon`` to "
"``true``."
msgstr ""
"如果游戏角色没有使用任何武器重装，我们将 ``reloading_weapon`` 设置为 "
"``true`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:424
msgid ""
"One thing I like to add is where the weapon will reload itself if you try to "
"fire it and it's out of ammo."
msgstr ""
"我想补充的一件事是，如果您试图发射武器并且没有弹药，那么武器会自动重装。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:426
#, fuzzy
msgid ""
"We also need to add an additional if check (``is_reloading_weapon == false:"
"``) so the player cannot fire the current weapon while reloading."
msgstr ""
"我们还需要添加一个额外的if check(``is_reloading_weapon == false:``)，以便游戏"
"角色在重新加载时无法触发当前武器。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:429
msgid ""
"Let's change our firing code in ``process_input`` so it reloads when trying "
"to fire an empty weapon:"
msgstr ""
"让我们在 ``process_input`` 中更改我们的触发代码，以便在尝试触发空武器时重新加"
"载:"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:447
#, fuzzy
msgid ""
"Now we check to make sure the player is not reloading before we fire the "
"weapon, and when we have ``0`` or less ammo in the current weapon, we set "
"``reloading_weapon`` to ``true`` if the player tries to fire."
msgstr ""
"现在我们检查以确保在我们开火之前游戏角色没有重新加载，当我们在当前武器中使"
"用“0”或更少的弹药时，如果游戏角色尝试，我们将 ``reloading_weapon`` 设置为"
"``true`` 开火。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:450
#, fuzzy
msgid ""
"This will make it so the player will try to reload when attempting to fire "
"an empty weapon."
msgstr "当游戏角色试图发射空武器时，这将使游戏角色尝试重新加载。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:454
#, fuzzy
msgid ""
"With that done, the player can now reload! Give it a try! Now you can fire "
"all the spare ammo for each weapon."
msgstr ""
"完成后，游戏角色现在可以重新加载！ 试试看！ 现在您可以为每个武器发射所有备用"
"弹药。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:457
msgid "Adding sounds"
msgstr "添加声音"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:459
#, fuzzy
msgid ""
"Finally, let's add some sounds that accompany the player firing, reloading "
"and changing weapons."
msgstr ""
"最后，让我们添加一些在游戏角色重装，更换武器以及游戏角色开火时播放的声音。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:461
msgid ""
"There are no game sounds provided in this tutorial (for legal reasons). "
"https://gamesounds.xyz/ is a collection of **\"royalty free or public domain "
"music and sounds suitable for games\"**. I used Gamemaster's Gun Sound Pack, "
"which can be found in the Sonniss.com GDC 2017 Game Audio Bundle."
msgstr ""
"本教程中没有提供游戏声音(出于法律原因)。 https://gamesounds.xyz/是 **“免版税"
"或公共领域音乐和适合游戏的声音”的集合** 。 我使用了Gamemaster的Gun Sound "
"Pack，可以在Sonniss.com GDC 2017 Game Audio Bundle中找到。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:465
#, fuzzy
msgid ""
"Open up ``Simple_Audio_Player.tscn``. It is simply a :ref:`Spatial "
"<class_Spatial>` with an :ref:`AudioStreamPlayer <class_AudioStreamPlayer>` "
"as its child."
msgstr ""
"打开 ``Simple_Audio_Player.tscn`` 。 它只是一个 :ref:`Spatial "
"<class_Spatial>` ，其中 :ref:`AudioStreamPlayer <class_AudioStreamPlayer>` 作"
"为它的子节点。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:467
msgid ""
"The reason this is called a 'simple' audio player is because we are not "
"taking performance into account and because the code is designed to provide "
"sound in the simplest way possible."
msgstr ""
"这被称为“简单”音频播放器的原因是因为我们没有考虑性能，因为代码旨在以最简单的"
"方式提供声音。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:470
msgid ""
"If you want to use 3D audio, so it sounds like it's coming from a location "
"in 3D space, right click the :ref:`AudioStreamPlayer "
"<class_AudioStreamPlayer>` and select \"Change type\"."
msgstr ""
"如果您想使用3D音频，所以它听起来像是来自3D空间中的一个位置，右键单击 :ref:"
"`AudioStreamPlayer <class_AudioStreamPlayer>` 并选择“更改类型”。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:473
msgid ""
"This will open the node browser. Navigate to :ref:`AudioStreamPlayer3D "
"<class_AudioStreamPlayer3D>` and select \"change\". In the source for this "
"tutorial, we will be using :ref:`AudioStreamPlayer "
"<class_AudioStreamPlayer>`, but you can optionally use :ref:"
"`AudioStreamPlayer3D <class_AudioStreamPlayer3D>` if you desire, and the "
"code provided below will work regardless of which one you chose."
msgstr ""
"这将打开节点浏览器。 导航到 :ref:`AudioStreamPlayer3D "
"<class_AudioStreamPlayer3D>` 并选择“更改”。 在本教程的源代码中，我们将使用 :"
"ref:`AudioStreamPlayer <class_AudioStreamPlayer>`，但如果需要，您可以选择使"
"用 :ref:`AudioStreamPlayer3D <class_AudioStreamPlayer3D>`，无论哪一个，下面提"
"供的代码都可以使用 您选择了。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:478
msgid ""
"Create a new script and call it ``Simple_Audio_Player.gd``. Attach it to "
"the :ref:`Spatial <class_Spatial>` in ``Simple_Audio_Player.tscn`` and "
"insert the following code:"
msgstr ""
"创建一个新脚本并将其命名为 ``Simple_Audio_Player.gd`` 。 将它附加到 "
"``Simple_Audio_Player.tscn`` 中的 :ref:`Spatial <class_Spatial>` 并插入以下代"
"码:"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:530
#, fuzzy
msgid ""
"By setting ``position`` to ``null`` by default in ``play_sound``, we are "
"making it an optional argument, meaning ``position`` doesn't necessarily "
"have to be passed in to call ``play_sound``."
msgstr ""
"通过在 ``play_sound`` 中默认设置 ``position`` 为 ``null`` ，我们将它作为一个"
"可选参数，这意味着 ``position`` 不一定要被传入来调用 ``play_sound`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:537
#, fuzzy
msgid ""
"In ``_ready``, we get the :ref:`AudioStreamPlayer <class_AudioStreamPlayer>` "
"and connect its ``finished`` signal to the ``destroy_self`` function. It "
"doesn't matter if it's an :ref:`AudioStreamPlayer <class_AudioStreamPlayer>` "
"or :ref:`AudioStreamPlayer3D <class_AudioStreamPlayer3D>` node, as they both "
"have the finished signal. To make sure it is not playing any sounds, we call "
"``stop`` on the :ref:`AudioStreamPlayer <class_AudioStreamPlayer>`."
msgstr ""
"在 ``_ready`` 中我们得到 :ref:`AudioStreamPlayer <class_AudioStreamPlayer>` "
"并将其 ``finished`` 信号连接到 ``destroy_self`` 函数。 无论是否为 :ref:"
"`AudioStreamPlayer <class_AudioStreamPlayer>` 或 :ref:`AudioStreamPlayer3D "
"<class_AudioStreamPlayer3D>` 节点，因为它们都有完成的信号。 为了确保它没有播"
"放任何声音，我们在 :ref:`AudioStreamPlayer <class_AudioStreamPlayer>` 上调用 "
"``stop`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:541
#, fuzzy
msgid ""
"Make sure your sound files are **not** set to loop! If it is set to loop, "
"the sounds will continue to play infinitely and the script will not work!"
msgstr ""
"确保您的声音文件不是**设置为循环！ 如果设置为循环，声音将继续无限播放，脚本将"
"无法正常工作！"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:544
msgid ""
"The ``play_sound`` function is what we will be calling from ``Player.gd``. "
"We check if the sound is one of the three possible sounds, and if it is one "
"of the three sounds we set the audio stream in :ref:`AudioStreamPlayer "
"<class_AudioStreamPlayer>` to the correct sound."
msgstr ""
"``play_sound``函数是我们将从``Player.gd``调用的函数。 我们检查声音是否是三种"
"可能的声音之一，如果它是三种声音之一，我们将音频流设置为 :ref:"
"`AudioStreamPlayer <class_AudioStreamPlayer>` 到正确的声音。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:548
msgid ""
"If it is an unknown sound, we print an error message to the console and free "
"the audio player."
msgstr "如果是未知声音，我们会向控制台输出错误消息并释放音频播放器。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:550
#, fuzzy
msgid ""
"If you are using an :ref:`AudioStreamPlayer3D <class_AudioStreamPlayer3D>`, "
"remove the ``#`` to set the position of the audio player node so it plays at "
"the correct position."
msgstr ""
"如果您使用的是 :ref:`AudioStreamPlayer3D <class_AudioStreamPlayer3D>`，请删"
"除 ``#`` 以设置音频播放器节点的位置，使其在正确的位置播放。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:553
msgid ""
"Finally, we tell the :ref:`AudioStreamPlayer <class_AudioStreamPlayer>` to "
"play."
msgstr ""
"最后，我们告诉 :ref:`AudioStreamPlayer <class_AudioStreamPlayer>` 来玩。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:555
msgid ""
"When the :ref:`AudioStreamPlayer <class_AudioStreamPlayer>` is finished "
"playing the sound, it will call ``destroy_self`` because we connected the "
"``finished`` signal in ``_ready``. We stop the :ref:`AudioStreamPlayer "
"<class_AudioStreamPlayer>` and free the audio player to save on resources."
msgstr ""
"当 :ref:`AudioStreamPlayer <class_AudioStreamPlayer>` 播放声音时，它将调用 "
"``destroy_self`` ，因为我们连接了 ``_ready`` 中的 ``finished`` 信号。 我们停"
"止 :ref:`AudioStreamPlayer <class_AudioStreamPlayer>` 并释放音频播放器以节省"
"资源。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:559
msgid "This system is extremely simple and has some major flaws:"
msgstr "这个系统非常简单，有一些重大缺陷:"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:561
#, fuzzy
msgid ""
"One flaw is we have to pass in a string value to play a sound. While it is "
"relatively simple to remember the names of the three sounds, it can be "
"increasingly complex when you have more sounds. Ideally, we'd place these "
"sounds in some sort of container with exposed variables so we do not have to "
"remember the name(s) of each sound effect we want to play."
msgstr ""
"一个缺陷是我们必须传入一个字符串值来播放声音。 虽然记住三种声音的名称相对简"
"单，但是当您有更多的声音时它会变得越来越复杂。 理想情况下，我们会将这些声音放"
"在某种具有暴露变量的容器中，这样我们就不必记住我们想要播放的每种声音效果的名"
"称。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:566
msgid ""
"Another flaw is we cannot play looping sounds effects, nor background music, "
"easily with this system. Because we cannot play looping sounds, certain "
"effects, like footstep sounds, are harder to accomplish because we then have "
"to keep track of whether or not there is a sound effect and whether or not "
"we need to continue playing it."
msgstr ""
"另一个缺陷是我们无法使用此系统轻松播放循环音效，也无法播放背景音乐。 因为我们"
"无法播放循环声音，某些效果(如脚步声)难以实现，因为我们必须跟踪是否存在声音效"
"果以及是否需要继续播放它。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:571
msgid ""
"One of the biggest flaws with this system is we can only play sounds from "
"``Player.gd``. Ideally we'd like to be able to play sounds from any script "
"at any time."
msgstr ""
"这个系统最大的缺点之一是我们只能播放“Player.gd”中的声音。 理想情况下，我们希"
"望能够随时播放任何脚本中的声音。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:576
#, fuzzy
msgid ""
"With that done, let's open up ``Player.gd`` again. First we need to load the "
"``Simple_Audio_Player.tscn``. Place the following code in the class "
"variables section of the script:"
msgstr ""
"完成后，让我们再次打开 ``Player.gd`` 。 首先，我们需要加载 "
"``Simple_Audio_Player.tscn`` 。 将以下代码放在类变量中:"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:583
msgid ""
"Now we need to instance the simple audio player when we need it, and then "
"call its ``play_sound`` function and pass the name of the sound we want to "
"play. To make the process simpler, let's create a ``create_sound`` function "
"in ``Player.gd``:"
msgstr ""
"现在我们需要在需要时实例化简单的音频播放器，然后调用它的 ``play_sound`` 函数"
"并传递我们想要播放的声音的名称。 为了简化这个过程，让我们在 ``Player.gd`` 中"
"创建一个 ``create_sound`` 函数:"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:595
#, fuzzy
msgid "Let's walk through what this function does:"
msgstr "让我们来看看这个函数的作用:"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:599
#, fuzzy
msgid ""
"The first line instances the ``Simple_Audio_Player.tscn`` scene and assigns "
"it to a variable named ``audio_clone``."
msgstr ""
"第一行实例化 ``Simple_Audio_Player.tscn`` 场景并将其分配给名为 "
"``audio_clone`` 的变量。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:602
msgid ""
"The second line gets the scene root, and this has a large (though safe) "
"assumption."
msgstr "第二行获取场景根，这有一个很大(虽然安全)的假设。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:604
msgid ""
"We first get this node's :ref:`SceneTree <class_SceneTree>`, and then access "
"the root node, which in this case is the :ref:`Viewport <class_Viewport>` "
"this entire game is running under. Then we get the first child of the :ref:"
"`Viewport <class_Viewport>`, which in our case happens to be the root node "
"in ``Test_Area.tscn`` or any of the other provided levels. **We are making a "
"huge assumption that the first child of the root node is the root scene that "
"the player is under, which may not always be the case**."
msgstr ""
"我们首先得到这个节点 :ref:`SceneTree <class_SceneTree>`，然后访问根节点，在这"
"种情况下是 :ref:`Viewport <class_Viewport>` 这整个游戏正在运行。 然后我们得到"
"了第一个子节点 :ref:`Viewport <class_Viewport>`，在我们的示例中恰好是 "
"``Test_Area.tscn`` 中的根节点或任何其他提供的级别。 **我们正在做出一个巨大的"
"假设，即根节点的第一个子节点是游戏角色所处的根场景，这可能并非总是如此**。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:610
#, fuzzy
msgid ""
"If this doesn't make sense to you, don't worry too much about it. The second "
"line of code only does not work reliably if you have multiple scenes loaded "
"as children of the root node at a time, which will rarely happen for most "
"projects and will not be happening in this tutorial series. This is only "
"potentially a issue depending on how you handle scene loading."
msgstr ""
"如果这对您没有意义，不要过于担心。 如果您一次将多个场景作为子节点加载到根节"
"点，则第二行代码无法可靠地工作，这对于大多数项目很少发生，并且在本教程系列中"
"不会发生。 这可能只是一个问题，具体取决于您处理场景加载的方式。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:614
msgid ""
"The third line adds our newly created ``Simple_Audio_Player`` scene to be a "
"child of the scene root. This works exactly the same as when we are spawning "
"bullets."
msgstr ""
"第三行将我们新创建的 ``Simple_Audio_Player`` 场景添加为场景根的子节点。 这与"
"我们产生子弹时的工作方式完全相同。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:617
msgid ""
"Finally, we call the ``play_sound`` function and pass in the arguments "
"passed in to ``create_sound``. This will call ``Simple_Audio_Player.gd``'s "
"``play_sound`` function with the passed in arguments."
msgstr ""
"最后，我们调用 ``play_sound`` 函数并将传入的参数传递给 ``create_sound`` 。 这"
"将使用传入的参数调用 ``Simple_Audio_Player.gd`` 的 ``play_sound`` 函数。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:622
msgid ""
"Now all that is left is playing the sounds when we want to. Let's add sound "
"to the pistol first!"
msgstr "现在剩下的就是在我们想要的时候播放声音。 让我们首先为手枪添加声音！"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:624
msgid "Open up ``Weapon_Pistol.gd``."
msgstr "打开 ``Weapon_Pistol.gd`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:626
msgid ""
"Now, we want to make a noise when the player fires the pistol, so add the "
"following to the end of the ``fire_weapon`` function:"
msgstr ""
"现在，我们想在游戏角色发射手枪时发出噪音，所以将以下内容添加到 "
"``fire_weapon`` 函数的末尾:"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:632
msgid ""
"Now when the player fires the pistol, we'll play the ``Pistol_shot`` sound."
msgstr "现在，当游戏角色发射手枪时，我们将发出“手枪射击”的声音。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:634
#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:656
msgid ""
"To make a sound when the player reloads, we need to add the following right "
"under ``player_node.animation_manager.set_animation(RELOADING_ANIM_NAME)`` "
"in the ``reload_weapon`` function:"
msgstr ""
"要在游戏角色重新加载时发出声音，我们需要在 ``reload_weapon`` 函数中的 "
"``player_node.animation_manager.set_animation(RELOADING_ANIM_NAME)`` 下添加以"
"下内容:"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:641
#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:663
msgid "Now when the player reloads, we'll play the ``Gun_cock`` sound."
msgstr "现在当游戏角色重新加载时，我们将播放 ``Gun_cock`` 声音。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:645
msgid "Now let's add sounds to the rifle. Open up ``Weapon_Rifle.gd``."
msgstr "现在让我们为步枪添加声音。 打开 ``Weapon_Rifle.gd`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:648
msgid ""
"To play sounds when the rifle is fired, add the following to the end of the "
"``fire_weapon`` function:"
msgstr ""
"要在步枪被射击时发出声音，请将以下内容添加到 ``fire_weapon`` 函数的末尾:"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:654
msgid ""
"Now when the player fires the rifle, we'll play the ``Rifle_shot`` sound."
msgstr "现在，当游戏角色发射步枪时，我们将发出“Rifle_shot”声音。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:670
msgid ""
"Now you have weapons with limited ammo that play sounds when you fire them!"
msgstr "现在您拥有有限弹药的武器，当您开火时它们会播放声音！"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:672
#, fuzzy
msgid ""
"At this point, we have all the basics of an FPS game working. There are "
"still a few things that would be nice to add, and we're going to add them in "
"the next three parts!"
msgstr ""
"在这一点上，我们拥有FPS游戏的所有基础知识。 还有一些很好的东西可以添加，我们"
"将在接下来的三个部分中添加它们！"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:675
msgid ""
"For example, right now we have no way to add ammo to our spares, so we'll "
"eventually run out. Also, we don't have anything to shoot at outside of the :"
"ref:`RigidBody <class_RigidBody>` nodes."
msgstr ""
"例如，现在我们无法为我们的备件添加弹药，所以我们最终会耗尽。 另外，我们没有任"
"何东西可以射击 :ref:`RigidBody <class_RigidBody>` 节点。"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:678
msgid ""
"In :ref:`doc_fps_tutorial_part_four` we'll add some targets to shoot at, "
"along with some health and ammo pick ups! We're also going to add joypad "
"support, so we can play with wired Xbox 360 controllers!"
msgstr ""
"在:参考:`doc_fps_tutorial_part_four`我们将添加一些射击目标，以及一些健康和弹"
"药拾取！ 我们还将添加joypad支持，因此我们可以使用有线Xbox 360控制器！"

#: ../../docs/tutorials/3d/fps_tutorial/part_three.rst:683
msgid ""
"You can download the finished project for this part here: :download:"
"`Godot_FPS_Part_3.zip <files/Godot_FPS_Part_3.zip>`"
msgstr ""
"您可以在这里下载这个部分的完成项目: :download:`Godot_FPS_Part_3.zip <files / "
"Godot_FPS_Part_3.zip>`"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:4
msgid "Part 4"
msgstr "第4部分"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:9
#, fuzzy
msgid ""
"In this part, we will be adding health pickups, ammo pickups, targets the "
"player can destroy, support for joypads, and add the ability to change "
"weapons with the scroll wheel."
msgstr ""
"在这部分中，我们将添加健康拾取，弹药拾取，游戏角色可以摧毁的目标，支持游戏手"
"柄，并添加使用滚轮更改武器的能力。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:13
msgid ""
"You are assumed to have finished :ref:`doc_fps_tutorial_part_three` before "
"moving on to this part of the tutorial. The finished project from :ref:"
"`doc_fps_tutorial_part_three` will be the starting project for part 4"
msgstr ""
"在继续本教程的这一部分之前，假设您已完成 :ref:"
"`doc_fps_tutorial_part_three`。 完成的项目来自 :ref:"
"`doc_fps_tutorial_part_three`将成为第4部分的起始项目"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:19
msgid "Adding joypad input"
msgstr "添加游戏手柄输入"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:21
#, fuzzy
msgid ""
"In Godot, any game controller is referred to as a joypad. This includes: "
"Console controllers, Joysticks (like for flight simulators), Wheels (like "
"for driving simulators), VR Controllers, and more!"
msgstr ""
"在Godot中，任何游戏控制器都被称为游戏手柄。 这包括:控制台控制器，操纵杆(如飞"
"行模拟器)，车轮(如用于驾驶模拟器)，VR控制器等等！"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:24
#, fuzzy
msgid ""
"Firstly, we need to change a few things in our project's input map. Open up "
"the project settings and select the ``Input Map`` tab."
msgstr ""
"首先，我们需要在项目的输入映射中更改一些内容。 打开项目设置并选择“输入映射”选"
"项卡。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:26
msgid ""
"Now we need to add some joypad buttons to our various actions. Click the "
"plus icon and select ``Joy Button``."
msgstr ""
"现在我们需要为我们的各种动作添加一些游戏手柄按钮。 单击加号图标，然后选择“欢"
"乐按钮”。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:30
msgid ""
"Feel free to use whatever button layout you want. Make sure that the device "
"selected is set to ``0``. In the finished project, we will be using the "
"following:"
msgstr ""
"随意使用您想要的任何按钮布局。 确保所选设备设置为“0”。 在完成的项目中，我们将"
"使用以下内容:"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:32
msgid "movement_sprint: ``Device 0, Button 4 (L, L1)``"
msgstr "movement_sprint:``设备0，按钮4(L，L1)``"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:33
msgid "fire: ``Device 0, Button 0 (PS Cross, XBox A, Nintendo B)``"
msgstr "fire:``设备0，按钮0(PS Cross，XBox A，Nintendo B)``"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:34
msgid "reload: ``Device 0, Button 0 (PS Square, XBox X, Nintendo Y)``"
msgstr "重新加载:``设备0，按钮0(PS Square，XBox X，Nintendo Y)``"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:35
msgid "flashlight: ``Device 0, Button 12 (D-Pad Up)``"
msgstr "手电筒:``设备0，按钮12(D-Pad Up)``"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:36
msgid "shift_weapon_positive: ``Device 0, Button 15 (D-Pad Right)``"
msgstr "shift_weapon_positive:``设备0，按钮15(D-Pad右)``"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:37
msgid "shift_weapon_negative: ``Device 0, Button 14 (D-Pad Left)``"
msgstr "shift_weapon_negative:``设备0，按钮14(D-Pad Left)``"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:38
msgid "fire_grenade: ``Device 0, Button 1 (PS Circle, XBox B, Nintendo A).``"
msgstr "fire_grenade:``设备0，按钮1(PS圈，XBox B，任天堂A).``"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:40
msgid "These are already set up for you if you downloaded the starter assets"
msgstr "如果您下载了启动资源，则已为您设置了这些内容"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:42
msgid "Once you are happy with the input, close the project settings and save."
msgstr "对输入感到满意后，关闭项目设置并保存。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:46
msgid "Now let's open up ``Player.gd`` and add joypad input."
msgstr "现在让我们打开 ``Player.gd`` 并添加joypad输入。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:48
msgid ""
"First, we need to define a few new class variables. Add the following class "
"variables to ``Player.gd``:"
msgstr "首先，我们需要定义一些新的类变量。 将以下类变量添加到``Player.gd``:"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:56
#, fuzzy
msgid "Let's go over what each of these does:"
msgstr "让我们回顾一下这些做法:"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:58
msgid ""
"``JOYPAD_SENSITIVITY``: This is how fast the joypad's joysticks will move "
"the camera."
msgstr "``JOYPAD SENSITIVITY``:这是游戏手柄操纵杆移动相机的速度。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:59
msgid ""
"``JOYPAD_DEADZONE``: The dead zone for the joypad. You may need to adjust "
"depending on your joypad."
msgstr ""
"``JOYPAD DEADZONE``:游戏手柄的死区。 您可能需要根据您的游戏手柄进行调整。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:61
#, fuzzy
msgid ""
"Many joypads jitter around a certain point. To counter this, we ignore any "
"movement within a radius of JOYPAD_DEADZONE. If we did not ignore said "
"movement, the camera would jitter."
msgstr ""
"许多游戏手柄在某一点上抖动。 为了解决这个问题，我们忽略半径为JOYPAD_DEADZONE"
"的a中的任何移动。 如果我们不忽略所说的动作，相机就会抖动。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:64
msgid ""
"Also, we are defining ``JOYPAD_SENSITIVITY`` as a variable instead of a "
"constant because we'll later be changing it."
msgstr ""
"此外，我们将 ``JOYPAD_SENSITIVITY`` 定义为变量而不是常量，因为我们稍后会更改"
"它。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:66
msgid "Now we are ready to start handling joypad input!"
msgstr "现在我们准备开始处理游戏手柄输入了！"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:70
#, fuzzy
msgid ""
"In ``process_input``, add the following code just before "
"``input_movement_vector = input_movement_vector.normalized()``:"
msgstr ""
"在 ``process_input`` 中添加以下代码，就在``input_movement_vector = "
"input_movement_vector.normalized()``之前:"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:113
msgid "Let's go over what we're doing."
msgstr "让我们回顾一下我们正在做的事情。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:115
#, fuzzy
msgid "Firstly, we check to see if there is a connected joypad."
msgstr "首先，我们检查是否有连接的游戏手柄。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:117
msgid ""
"If there is a joypad connected, we then get its left stick axes for right/"
"left and up/down. Because a wired Xbox 360 controller has different joystick "
"axis mapping based on OS, we will use different axes based on the OS."
msgstr ""
"如果连接了一个游戏手柄，我们就可以获得左/右和左/上的左摇杆轴。 由于有线Xbox "
"360控制器具有基于OS的不同操纵杆轴映射，因此我们将基于OS使用不同的轴。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:121
msgid ""
"This tutorial assumes you are using a XBox 360 or a Playstation wired "
"controller. Also, I do not (currently) have access to a Mac computer, so the "
"joystick axes may need changing. If they do, please open a GitHub issue on "
"the Godot documentation repository! Thanks!"
msgstr ""
"本教程假设您使用的是XBox 360或Playstation有线控制器。 此外，我(目前)没有访问"
"Mac计算机，因此操纵杆轴可能需要更改。 如果有，请在Godot文档存储库中打开GitHub"
"问题！ 谢谢！"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:125
#, fuzzy
msgid ""
"Next, we check to see if the joypad vector length is within the "
"``JOYPAD_DEADZONE`` radius. If it is, we set ``joypad_vec`` to an empty "
"Vector2. If it is not, we use a scaled Radial Dead zone for precise dead "
"zone calculation."
msgstr ""
"接下来我们检查一下joypad向量长度是否在 ``JOYPAD_DEADZONE`` 范围内。 如果是，"
"我们将 ``joypad_vec`` 设置为空Vector2。 如果不是，我们使用缩放的径向死区来进"
"行精确的死区计算。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:128
msgid ""
"You can find a great article explaining all about how to handle joypad/"
"controller dead zones here: http://www.third-helix.com/2013/04/12/doing-"
"thumbstick-dead-zones-right.html"
msgstr ""
"您可以在这里找到一篇很棒的文章解释如何处理游戏手柄/控制器死区:http://www."
"third-helix.com/2013/04/12/doing-thumbstick-dead-zones-right.html"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:131
msgid ""
"We're using a translated version of the scaled radial dead zone code "
"provided in that article. The article is a great read, and I highly suggest "
"giving it a look!"
msgstr ""
"我们正在使用该文章中提供的缩放径向死区代码的翻译版本。 这篇文章很精彩，我强烈"
"建议您看看！"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:134
msgid "Finally, we add ``joypad_vec`` to ``input_movement_vector``."
msgstr "最后，我们将 ``joypad_vec`` 添加到 ``input_movement_vector`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:136
#, fuzzy
msgid ""
"Remember how we normalize ``input_movement_vector``? This is why! If we did "
"not normalize ``input_movement_vector``, the player could move faster if "
"they pushed in the same direction with both the keyboard and the joypad!"
msgstr ""
"还记得我们如何规范化 ``input_movement_vector`` ？ 这就是为什么！ 如果我们没有"
"规范化 ``input_movement_vector`` ，如果游戏角色用键盘和游戏手柄向同一个方向推"
"进，游戏角色可以移动得更快！"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:141
msgid ""
"Make a new function called ``process_view_input`` and add the following:"
msgstr "创建一个名为 ``process_view_input`` 的新函数并添加以下内容:"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:218
#, fuzzy
msgid ""
"Firstly, we check the mouse mode. If the mouse mode is not "
"``MOUSE_MODE_CAPTURED``, we want to return, which will skip the code below."
msgstr ""
"首先我们检查鼠标模式。 如果鼠标模式不是“MOUSE_MODE_CAPTURED”，我们想要返回，"
"这将跳过下面的代码。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:220
#, fuzzy
msgid ""
"Next, we define a new :ref:`Vector2 <class_Vector2>` called ``joypad_vec``. "
"This will hold the right joystick position. Based on the OS, we set its "
"values so it is mapped to the proper axes for the right joystick."
msgstr ""
"接下来我们定义一个新的 :ref:`Vector2 <class_Vector2>` ` ``joypad_vec`` 。 这"
"将保持正确的操纵杆位置。 基于操作系统，我们设置其值，使其映射到右侧操纵杆的正"
"确轴。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:223
#, fuzzy
msgid ""
"As stated above, I do not (currently) have access to a Mac computer, so the "
"joystick axes may need changing. If they do, please open a GitHub issue on "
"the Godot documentation repository! Thanks!"
msgstr ""
"如上所述，我(目前)没有访问Mac计算机，因此操纵杆轴可能需要更改。 如果有，请在"
"Godot文档存储库中打开GitHub问题！ 谢谢！"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:226
msgid ""
"We then account for the joypad's dead zone, exactly like in "
"``process_input``."
msgstr "然后我们考虑了joypad的死区，就像在 ``process_input`` 中一样。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:228
#, fuzzy
msgid ""
"Then, we rotate ``rotation_helper`` and the player's :ref:`KinematicBody "
"<class_KinematicBody>` using ``joypad_vec``."
msgstr ""
"然后我们使用 ``joypad_vec`` 旋转 ``rotation_helper`` 和游戏角色的 :ref:"
"`KinematicBody <class_KinematicBody>` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:230
msgid ""
"Notice how the code that handles rotating the player and ``rotation_helper`` "
"is exactly the same as the code in ``_input``. All we've done is change the "
"values to use ``joypad_vec`` and ``JOYPAD_SENSITIVITY``."
msgstr ""
"注意处理旋转游戏角色和 ``rotation_helper`` 的代码与 ``_input`` 中的代码完全相"
"同。 我们所做的就是更改值以使用 ``joypad_vec`` 和 ``JOYPAD_SENSITIVITY`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:233
#, fuzzy
msgid ""
"Due to a few mouse-related bugs on Windows, we cannot put mouse rotation in "
"``process_view`` as well. Once these bugs are fixed, this will likely be "
"updated to place the mouse rotation here in ``process_view_input`` as well."
msgstr ""
"由于Windows上几乎没有鼠标相关的错误，我们也不能将鼠标旋转放在 "
"``process_view`` 中。 一旦修复了这些错误，这可能会更新，以便将鼠标旋转放在 "
"``process_view_input`` 中。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:236
msgid ""
"Finally, we clamp the camera's rotation so the player cannot look upside "
"down."
msgstr "最后，我们夹住相机的旋转，这样游戏角色就不会颠倒过来。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:240
msgid ""
"The last thing we need to do is add ``process_view_input`` to "
"``_physics_process``."
msgstr ""
"我们需要做的最后一件事是将 ``process_view_input`` 添加到 "
"``_physics_process`` 中。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:242
msgid ""
"Once ``process_view_input`` is added to ``_physics_process``, you should be "
"able to play using a joypad!"
msgstr ""
"一旦 ``process_view_input`` 被添加到 ``_physics_process`` ，您应该能够使用游"
"戏手柄玩！"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:244
msgid ""
"I decided not to use the joypad triggers for firing because we'd then have "
"to do some more axis managing, and because I prefer to use a shoulder "
"buttons to fire."
msgstr ""
"我决定不使用游戏手柄来触发，因为我们必须做更多的轴管理，因为我更喜欢使用肩部"
"按钮来开火。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:246
msgid ""
"If you want to use the triggers for firing, you will need to change how "
"firing works in ``process_input``. You need to get the axis values for the "
"triggers, and check if it's over a certain value, say ``0.8`` for example. "
"If it is, you add the same code as when the ``fire`` action was pressed."
msgstr ""
"如果您想使用触发器进行触发，您需要在 ``process_input`` 中改变触发的工作方"
"式。 您需要获取触发器的轴值，并检查它是否超过某个值，例如“0.8”。 如果是，则添"
"加与按下 ``fire`` 动作时相同的代码。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:250
msgid "Adding mouse scroll wheel input"
msgstr "添加鼠标滚轮输入"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:252
#, fuzzy
msgid ""
"Let's add one more input related feature before we start working on the "
"pickups and the target. Let's add the ability to change weapons using the "
"scroll wheel on the mouse."
msgstr ""
"在我们开始处理拾取器和目标之前，让我们再添加一个与输入相关的功能。 让我们添加"
"使用鼠标滚轮更改武器的功能。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:254
#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:457
#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:526
msgid "Open up ``Player.gd`` and add the following class variables:"
msgstr "打开 ``Player.gd`` 并添加以下类变量:"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:261
msgid "Let's go over what each of these new variables will be doing:"
msgstr "让我们回顾一下这些新变量将要做的事情:"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:263
msgid "``mouse_scroll_value``: The value of the mouse scroll wheel."
msgstr "``mouse_scroll_value``:鼠标滚轮的值。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:264
msgid ""
"``MOUSE_SENSITIVITY_SCROLL_WHEEL``: How much a single scroll action "
"increases mouse_scroll_value"
msgstr ""
"``MOUSE_SENSITIVITY_SCROLL_WHEEL``:单个滚动操作增加了多少mouse_scroll_value"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:268
msgid "Now let's add the following to ``_input``:"
msgstr "现在让我们将以下内容添加到 ``_input`` 中:"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:292
#, fuzzy
msgid ""
"Firstly, we check if the event is an ``InputEventMouseButton`` event and "
"that the mouse mode is ``MOUSE_MODE_CAPTURED``. Then, we check to see if the "
"button index is either a ``BUTTON_WHEEL_UP`` or ``BUTTON_WHEEL_DOWN`` index."
msgstr ""
"首先，我们检查事件是否是一个 ``InputEventMouseButton`` 事件，并且鼠标模式是 "
"``MOUSE_MODE_CAPTURED`` 。 然后我们检查按钮索引是否是 ``BUTTON_WHEEL_UP`` 或 "
"``BUTTON_WHEEL_DOWN`` 索引。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:295
#, fuzzy
msgid ""
"If the event's index is indeed a button wheel index, we then check to see if "
"it is a ``BUTTON_WHEEL_UP`` or ``BUTTON_WHEEL_DOWN`` index. Based on whether "
"it is up or down, we add or subtract ``MOUSE_SENSITIVITY_SCROLL_WHEEL`` to/"
"from ``mouse_scroll_value``."
msgstr ""
"如果事件的索引确实是一个按钮轮索引，那么我们检查它是否是一个 "
"``BUTTON_WHEEL_UP`` 或 ``BUTTON_WHEEL_DOWN`` 索引。 根据它是向上还是向下，我"
"们在 ``mouse_scroll_value`` 中添加或删除 "
"``MOUSE_SENSITIVITY_SCROLL_WHEEL`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:298
#, fuzzy
msgid ""
"Next, we clamp mouse scroll value to ensure it is inside the range of "
"selectable weapons."
msgstr "接下来我们将鼠标滚动值限制为确保它在可选武器范围内。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:300
msgid ""
"We then check to see if the player is changing weapons or reloading. If the "
"player is doing neither, we round ``mouse_scroll_value`` and cast it to an "
"``int``."
msgstr ""
"然后我们检查游戏角色是在换武器还是重装。 如果游戏角色两者都没做，我们将 "
"``mouse_scroll_value`` 舍入并将其转换为 ``int`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:302
#, fuzzy
msgid ""
"We are casting ``mouse_scroll_value`` to an ``int`` so we can use it as a "
"key in our dictionary. If we left it as a float, we would get an error when "
"we tried to run the project."
msgstr ""
"我们将 ``mouse_scroll_value`` 转换为 ``int``，这样我们就可以将它用作字典中的"
"键。 如果我们将它保留为浮点数，当我们尝试运行项目时会出现错误。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:305
#, fuzzy
msgid ""
"Next, we check to see if the weapon name at ``round_mouse_scroll_value`` is "
"not equal to the current weapon name using ``WEAPON_NUMBER_TO_NAME``. If the "
"weapon is different than the player's current weapon, we assign "
"``changing_weapon_name``, set ``changing_weapon`` to ``true`` so the player "
"will change weapons in ``process_changing_weapon``, and set "
"``mouse_scroll_value`` to ``round_mouse_scroll_value``."
msgstr ""
"接下来，我们使用 ``weapon_number_to_name`` 检查 ``round_mouse_scroll_value`` "
"中的武器名称是否不等于当前武器名称。 如果武器与游戏角色的当前武器不同，我们分"
"配 ``changing_weapon_name`` ，将 ``changing_weapon`` 设置为 ``true`` ，这样游"
"戏角色将在 ``process_changing_weapon`` 中更改武器，并设置"
"``mouse_scroll_value` `到 ``round_mouse_scroll_value`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:309
#, fuzzy
msgid ""
"The reason we are setting ``mouse_scroll_value`` to the rounded scroll value "
"is because we do not want the player to keep their mouse scroll wheel just "
"in between values, giving them the ability to switch almost extremely fast. "
"By assigning ``mouse_scroll_value`` to ``round_mouse_scroll_value``, we "
"ensure that each weapon takes exactly the same amount of scrolling to change."
msgstr ""
"我们将 ``mouse_scroll_value`` 设置为舍入滚动值的原因是因为我们不希望游戏角色"
"将鼠标滚轮保持在两个值之间，从而使它们能够快速切换。 通过将 "
"``mouse_scroll_value`` 分配给 ``round_mouse_scroll_value`` ，我们可以确保每个"
"武器的滚动量完全相同。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:315
msgid ""
"One more thing we need to change is in ``process_input``. In the code for "
"changing weapons, add the following right after the line ``changing_weapon = "
"true``:"
msgstr ""
"我们需要改变的另一件事是 ``process_input`` 。 在更改武器的代码中，"
"在“changing_weapon = true”行之后添加以下内容:"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:321
#, fuzzy
msgid ""
"Now the scroll value will be changed with the keyboard input. If we did not "
"change this, the scroll value would be out of sync. If the scroll wheel were "
"out of sync, scrolling forwards or backwards would not transition to the "
"next/last weapon, but rather the next/last weapon the scroll wheel changed "
"to."
msgstr ""
"现在，滚动值将随键盘输入而改变。 如果我们没有更改它，滚动值将不同步。 如果滚"
"轮不同步，向前或向后滚动将不会转换到下一个/最后一个武器，而是滚轮改为的下一"
"个/最后一个武器。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:326
msgid "Now you can change weapons using the scroll wheel! Go give it a whirl!"
msgstr "现在您可以使用滚轮更换武器了！ 去试试吧！"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:329
#, fuzzy
msgid "Adding the health pickups"
msgstr "添加健康提取"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:331
msgid ""
"Now that the player has health and ammo, we ideally need a way to replenish "
"those resources."
msgstr "既然游戏角色拥有健康和弹药，我们理想情况下需要一种补充这些资源的方法。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:333
msgid "Open up ``Health_Pickup.tscn``."
msgstr "打开 ``Health_Pickup.tscn`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:335
msgid ""
"Expand ``Holder`` if it's not already expanded. Notice how we have two "
"Spatial nodes, one called ``Health_Kit`` and another called "
"``Health_Kit_Small``."
msgstr ""
"如果尚未展开，请展开 ``Holder`` 。 注意我们如何有两个Spatial节点，一个叫做 "
"``Health_Kit`` ，另一个称为 ``Health_Kit_Small`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:337
#, fuzzy
msgid ""
"This is because we're actually going to be making two sizes of health "
"pickups, one small and one large/normal. ``Health_Kit`` and "
"``Health_Kit_Small`` only have a single :ref:`MeshInstance "
"<class_MeshInstance>` as their children."
msgstr ""
"这是因为我们实际上将制作两种大小的健康拾取器，一种小型和一种大型/正常型。 "
"``Health_Kit``和``Health_Kit_Small``只有一个 :ref:`MeshInstance "
"<class_MeshInstance>` 作为他们的子节点。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:340
#, fuzzy
msgid ""
"Next expand ``Health_Pickup_Trigger``. This is an :ref:`Area <class_Area>` "
"node we're going to use to check if the player has walked close enough to "
"pick up the health kit. If you expand it, you'll find two collision shapes, "
"one for each size. We will be using a different collision shape size based "
"on the size of the health pickup, so the smaller health pickup has a trigger "
"collision shape closer to its size."
msgstr ""
"接下来展开 ``Health_Pickup_Trigger`` 。 这是一个 :ref:`Area <class_Area>` 节"
"点我们将用来检查游戏角色是否走得足够接近健康套件。 如果您展开它，您会发现两个"
"碰撞形状，每个大小一个。 我们将根据健康拾取的大小使用不同的碰撞形状大小，因此"
"较小的健康拾取具有接近其大小的触发碰撞形状。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:344
#, fuzzy
msgid ""
"The last thing to note is how we have an :ref:`AnimationPlayer "
"<class_AnimationPlayer>` node so the health kit bobs and spins around slowly."
msgstr ""
"最后要注意的是我们如何拥有 :ref:`AnimationPlayer <class_AnimationPlayer>` 节"
"点，因此健康工具包缓慢旋转并上下摆动。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:346
msgid ""
"Select ``Health_Pickup`` and add a new script called ``Health_Pickup.gd``. "
"Add the following:"
msgstr ""
"选择 ``Health_Pickup`` 并添加一个名为 ``Health_Pickup.gd`` 的新脚本。 添加以"
"下内容:"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:405
msgid ""
"Let's go over what this script is doing, starting with its class variables:"
msgstr "让我们回顾一下这个脚本正在做什么，从它的类变量开始:"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:407
#, fuzzy
msgid ""
"``kit_size``: The size of the health pickup. Notice how we're using a "
"``setget`` function to tell if it's changed."
msgstr ""
"``kit_size``:健康的大小。 请注意我们如何使用 ``setget`` 函数来判断它是否已更"
"改。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:408
#, fuzzy
msgid ""
"``HEALTH_AMMOUNTS``: The amount of health each pickup in each size contains."
msgstr "``HEALTH_AMMOUNTS``:每种大小的健康量包含。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:409
#, fuzzy
msgid ""
"``RESPAWN_TIME``: The amount of time, in seconds, it takes for the health "
"pickup to respawn"
msgstr "``RESPAWN_TIME``:健康选择重生所需的时间(以秒为单位)"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:410
#, fuzzy
msgid ""
"``respawn_timer``: A variable used to track how long the health pickup has "
"been waiting to respawn."
msgstr "``respawn_timer``:一个变量，用于跟踪健康提取等待重生的时间。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:411
msgid ""
"``is_ready``: A variable to track whether the ``_ready`` function has been "
"called or not."
msgstr "``is_ready``:一个变量，用于跟踪是否已调用 ``_ready`` 函数。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:413
#, fuzzy
msgid ""
"We're using ``is_ready`` because ``setget`` functions are called before "
"``_ready``; we need to ignore the first kit_size_change call, because we "
"cannot access child nodes until ``_ready`` is called. If we did not ignore "
"the first ``setget`` call, we would get several errors in the debugger."
msgstr ""
"我们使用 ``is_ready`` 是因为在 ``_ready`` 之前调用 ``setget`` 函数，我们需要"
"忽略第一个kit_size_change调用，因为在调用 ``_ready`` 之前我们无法访问子节"
"点。 如果我们没有忽略第一个 ``setget`` 调用，我们会在调试器中得到几个错误。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:417
#, fuzzy
msgid ""
"Also, notice how we are using an exported variable. This is so we can change "
"the size of the health pickups in the editor. This makes it so we do not "
"have to make two scenes for the two sizes, since we can easily change sizes "
"in the editor using the exported variable."
msgstr ""
"另外，请注意我们如何使用导出的变量。 这样我们就可以在编辑器中更改健康拾取的大"
"小。 这使得我们不必为两种大小制作两个场景，因为我们可以使用导出的变量轻松地在"
"编辑器中更改大小。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:420
msgid ""
"See :ref:`doc_GDScript` and scroll down to the Exports section for a list of "
"export hints you can use."
msgstr ""
"请参阅 :ref:`doc_GDScript`并向下滚动到Exports部分，以获取可以使用的导出提示列"
"表。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:424
msgid "Let's look at ``_ready``:"
msgstr "让我们来看看``_ready``:"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:426
#, fuzzy
msgid ""
"Firstly, we connect the ``body_entered`` signal from the "
"``Health_Pickup_Trigger`` to the ``trigger_body_entered`` function. This "
"makes it so any body that enters the :ref:`Area <class_Area>` triggers the "
"``trigger_body_entered`` function."
msgstr ""
"首先，我们将 ``body_entered`` 信号从 ``Health_Pickup_Trigger`` 连接到 "
"``trigger_body_entered`` 函数。 这使得任何进入 :ref:`Area <class_Area>` 的主"
"体触发 ``trigger_body_entered`` 函数。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:429
#, fuzzy
msgid ""
"Next, we set ``is_ready`` to ``true`` so we can use the ``setget`` function."
msgstr ""
"接下来我们将 ``is_ready`` 设置为 ``true`` ，这样我们就可以使用 ``setget`` 函"
"数了。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:431
#, fuzzy
msgid ""
"Then we hide all the possible kits and their collision shapes using "
"``kit_size_change_values``. The first argument is the size of the kit, while "
"the second argument is whether to enable or disable the collision shape and "
"mesh at that size."
msgstr ""
"然后我们使用 ``kit_size_change_values`` 隐藏所有可能的套件及其碰撞形状。 第一"
"个参数是套件的大小，而第二个参数是是否启用或禁用该大小的碰撞形状和网格。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:434
msgid ""
"Then we make only the kit size we selected visible, calling "
"``kit_size_change_values`` and passing in ``kit_size`` and ``true``, so the "
"size at ``kit_size`` is enabled."
msgstr ""
"然后我们只选择我们选择的工具包大小，调用 ``kit_size_change_values`` 并传入 "
"``kit_size`` 和 ``true`` ，这样就可以启用 ``kit_size`` 的大小。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:438
msgid "Next let's look at ``kit_size_change``."
msgstr "接下来让我们看一下 ``kit_size_change`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:440
msgid "The first thing we do is check to see if ``is_ready`` is ``true``."
msgstr "我们要做的第一件事就是检查 ``is_ready`` 是否为 ``true`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:442
msgid ""
"If ``is_ready`` is ``true``, we then make whatever kit already assigned to "
"``kit_size`` disabled using ``kit_size_change_values``, passing in "
"``kit_size`` and ``false``."
msgstr ""
"如果 ``is_ready`` 是 ``true`` ，那么我们使用 ``kit_size_change_values`` 制作"
"已经分配给 ``kit_size`` 的任何工具包，传入 ``kit_size`` 和 ``false`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:444
msgid ""
"Then we assign ``kit_size`` to the new value passed in, ``value``. Then we "
"call ``kit_size_change_values`` passing in ``kit_size`` again, but this time "
"with the second argument as ``true`` so we enable it. Because we changed "
"``kit_size`` to the passed in value, this will make whatever kit size was "
"passed in visible."
msgstr ""
"然后我们将 ``kit_size`` 分配给传入的新值 ``value`` 。 然后我们再次调用 "
"``kit_size_change_values`` 传递 ``kit_size`` ，但这次使用第二个参数作为 "
"``true`` ，所以我们启用它。 因为我们将 ``kit_size`` 更改为传入的值，这将使得"
"任何工具包大小都可见。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:447
msgid ""
"If ``is_ready`` is not ``true``, we simply assign ``kit_size`` to the passed "
"in ``value``."
msgstr ""
"如果 ``is_ready`` 不是 ``true`` ，我们只需将 ``kit_size`` 分配给传入的 "
"``value`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:451
msgid "Now let's look at ``kit_size_change_values``."
msgstr "现在让我们来看看 ``kit_size_change_values`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:453
#, fuzzy
msgid ""
"The first thing we do is check to see which size was passed in. Based on "
"which size we want to enable/disable, we want to get different nodes."
msgstr ""
"我们要做的第一件事是检查传入的大小。根据我们想要启用/禁用的大小，我们希望得到"
"不同的节点。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:455
msgid ""
"We get the collision shape for the node corresponding to ``size`` and "
"disable it based on the ``enabled`` passed in argument/variable."
msgstr ""
"我们得到对应于 ``size`` 的节点的碰撞形状，并根据参数/变量中传递的 "
"``enabled`` 禁用它。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:457
msgid ""
"Why are we using ``!enable`` instead of ``enable``? This is so when we say "
"we want to enable the node, we can pass in ``true``, but since :ref:"
"`CollisionShape <class_CollisionShape>` uses disabled instead of enabled, we "
"need to flip it. By flipping it, we can enable the collision shape and make "
"the mesh visible when ``true`` is passed in."
msgstr ""
"为什么我们使用 ``！enable`` 而不是 ``enable`` ？ 当我们说要启用节点时，我们可"
"以传入 ``true`` ，但是因为 :ref:`CollisionShape <class_CollisionShape>` 使用"
"禁用而不是启用，我们需要翻转它。 通过翻转它，我们可以启用碰撞形状，并在传"
"入“true”时使网格可见。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:461
msgid ""
"We then get the correct :ref:`Spatial <class_Spatial>` node holding the mesh "
"and set its visibility to ``enable``."
msgstr ""
"然后我们得到正确的 :ref:`Spatial <class_Spatial>` 节点保存网格并将其可见性设"
"置为 ``enable`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:463
#, fuzzy
msgid ""
"This function may be a little confusing; try to think of it like this: We're "
"enabling/disabling the proper nodes for ``size`` using ``enabled``. This is "
"so we cannot pick up health for a size that is not visible, and so only the "
"mesh for the proper size will be visible."
msgstr ""
"这个函数可能有点混乱，试着这样想:我们使用 ``enabled`` 启用/禁用 ``size`` 的正"
"确节点。 这样我们就无法获得不可见的大小的健康状况，因此只能看到适当大小的网"
"格。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:468
msgid "Finally, let's look at ``trigger_body_entered``."
msgstr "最后，让我们看一下 ``trigger_body_entered`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:470
#, fuzzy
msgid ""
"The first thing we do is check whether or not the body that has just entered "
"has a method/function called ``add_health``. If it does, we then call "
"``add_health`` and pass in the health provided by the current kit size."
msgstr ""
"我们要做的第一件事就是看看刚进入的主体是否有一个名为 ``add_health`` 的方法/函"
"数。 如果是，我们再调用 ``add_health`` 并传递当前套件大小提供的健康状况。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:473
msgid ""
"Then we set ``respawn_timer`` to ``RESPAWN_TIME`` so the player has to wait "
"before the player can get health again. Finally, call "
"``kit_size_change_values``, passing in ``kit_size`` and ``false`` so the kit "
"at ``kit_size`` is invisible until it has waited long enough to respawn."
msgstr ""
"然后我们将 ``respawn_timer`` 设置为 ``RESPAWN_TIME`` ，这样游戏角色必须等待游"
"戏角色再次恢复健康状态。 最后，调用 ``kit_size_change_values`` ，传入 "
"``kit_size`` 和 ``false`` ，这样 ``kit_size`` 的工具包是不可见的，直到它等待"
"足够长的时间重新生成。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:478
#, fuzzy
msgid ""
"The last thing we need to do before the player can use this health pickup is "
"add a few things to ``Player.gd``."
msgstr ""
"在游戏角色使用此健康状态之前我们需要做的最后一件事是向“Player.gd”添加一些内"
"容。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:480
msgid "Open up ``Player.gd`` and add the following class variable:"
msgstr "打开 ``Player.gd`` 并添加以下类变量:"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:486
msgid "``MAX_HEALTH``: The maximum amount of health a player can have."
msgstr "``MAX_HEALTH``:游戏角色可以拥有的最大健康状态。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:488
msgid ""
"Now we need to add the ``add_health`` function to the player. Add the "
"following to ``Player.gd``:"
msgstr ""
"现在我们需要将“add_health”函数添加到游戏角色中。 将以下内容添加到``Player."
"gd``:"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:496
msgid "Let's quickly go over what this does."
msgstr "让我们快点回顾一下这个问题。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:498
#, fuzzy
msgid ""
"We first add ``additional_health`` to the player's current health. We then "
"clamp the health so that it cannot take on a value higher than "
"``MAX_HEALTH``, nor a value lower than ``0``."
msgstr ""
"我们首先将“additional_health”添加到游戏角色当前的健康状态。 然后我们将健康状"
"态钳制到不超过“MAX_HEALTH”的值，也不能低于“0”的值。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:503
#, fuzzy
msgid ""
"With that done, the player can now collect health! Go place a few "
"``Health_Pickup`` scenes around and give it a try. You can change the size "
"of the health pickup in the editor when a ``Health_Pickup`` instanced scene "
"is selected, from a convenient drop down."
msgstr ""
"完成后，游戏角色现在可以收集健康！ 去看几个 ``Health_Pickup`` 场景并尝试一"
"下。 从方便的下拉菜单中选择 ``Health_Pickup`` 实例化场景后，您可以在编辑器中"
"更改运行状况拾取的大小。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:507
#, fuzzy
msgid "Adding the ammo pickups"
msgstr "添加弹药拾音器"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:509
#, fuzzy
msgid ""
"While adding health is good and all, we can't reap the rewards from adding "
"it since nothing can (currently) damage us. Let's add some ammo pickups next!"
msgstr ""
"虽然添加健康是好的，但我们无法从添加中获得回报，因为没有任何东西可以(当前)损"
"害我们。 让我们接下来添加一些弹药拾音器！"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:512
#, fuzzy
msgid ""
"Open up ``Ammo_Pickup.tscn``. Notice how it's structured exactly the same as "
"``Health_Pickup.tscn``, but with the meshes and trigger collision shapes "
"changed slightly to account for the difference in mesh sizes."
msgstr ""
"打开 ``Ammo_Pickup.tscn`` 。 注意它的结构与 ``Health_Pickup.tscn`` 完全相同，"
"但是网格和触发器的碰撞形状稍有变化，以适应网格大小的差异。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:515
msgid ""
"Select ``Ammo_Pickup`` and add a new script called ``Ammo_Pickup.gd``. Add "
"the following:"
msgstr ""
"选择 ``Ammo_Pickup`` 并添加一个名为 ``Ammo_Pickup.gd`` 的新脚本。 添加以下内"
"容:"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:576
#, fuzzy
msgid ""
"You may have noticed this code looks almost exactly the same as the health "
"pickup. That's because it largely is the same! Only a few things have been "
"changed, and that's what we're going to go over."
msgstr ""
"您可能已经注意到此代码看起来与健康提取几乎完全相同。 那是因为它基本上是一样"
"的！ 只有少数事情发生了变化，这就是我们要做的事情。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:579
#, fuzzy
msgid ""
"Firstly, notice the change to ``AMMO_AMOUNTS`` from ``HEALTH_AMMOUNTS``. "
"``AMMO_AMOUNTS`` will be how many ammo clips/magazines the pickup adds to "
"the current weapon. (Unlike in the case of ``HEALTH_AMMOUNTS``, which has "
"stood for how many health points would be awarded, we add an entire clip to "
"the current weapon instead of the raw ammo amount)"
msgstr ""
"首先，请注意如何“AMMO_AMOUNTS”而不是“HEALTH_AMMOUNTS”。 ``AMMO_AMOUNTS``将是"
"当前武器中拾取的弹药片/杂志的数量。 (与 ``HEALTH_AMMOUNTS`` 不同，这是多少生"
"命值，我们改为为当前武器添加整个剪辑，而不是原始弹药数量)"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:582
#, fuzzy
msgid ""
"The only other thing to notice is in ``trigger_body_entered``. We're "
"checking for the existence of and calling a function called ``add_ammo`` "
"instead of ``add_health``."
msgstr ""
"唯一需要注意的是 ``trigger_body_entered`` 。 我们正在检查并调用一个名为 "
"``add_ammo`` 的函数而不是 ``add_health`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:584
#, fuzzy
msgid ""
"Other than those two small changes, everything else is the same as the "
"health pickup!"
msgstr "除了这两个小变化之外，其他一切都与健康状况完全相同！"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:588
#, fuzzy
msgid ""
"All we need to do to make the ammo pickups work is add a new function to the "
"player. Open ``Player.gd`` and add the following function:"
msgstr ""
"我们需要做的就是让弹药拾音器工作就是为游戏角色增加一个新功能。 打开 ``Player."
"gd`` 并添加以下功能:"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:597
#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:759
#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:941
msgid "Let's go over what this function does."
msgstr "让我们回顾一下这个功能的作用。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:599
#, fuzzy
msgid ""
"The first thing we check is whether the player is ``UNARMED``. Because "
"``UNARMED`` does not have a node/script, we want to make sure the player is "
"not ``UNARMED`` before trying to get the node/script attached to "
"``current_weapon_name``."
msgstr ""
"我们检查的第一件事是看看游戏角色是否正在使用 ``UNARMED`` 。 因为 ``UNARMED`` "
"没有节点/脚本，所以我们要确保游戏角色在尝试将节点/脚本附加到 "
"``current_weapon_name`` 之前没有使用 ``UNARMED`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:602
#, fuzzy
msgid ""
"Next, we check to see if the current weapon can be refilled. If the current "
"weapon can, we add a full clip/magazine worth of ammo to the weapon by "
"multiplying the current weapon's ``AMMO_IN_MAG`` value by however many ammo "
"clips we're adding (``additional_ammo``)."
msgstr ""
"接下来我们检查当前的武器是否可以重新填充。 如果当前的武器可以，我们通过将当前"
"武器的“AMMO_IN_MAG”变量乘以我们正在添加的大量弹药片段(``additional_ammo``)来"
"为武器添加一个完整的弹片/杂志。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:607
#, fuzzy
msgid ""
"With that done, you should now be able to get additional ammo! Go place some "
"ammo pickups in one/both/all of the scenes and give it a try!"
msgstr ""
"完成后，您现在应该能够获得额外的弹药！ 在一个/两个/所有场景中进行一些弹药拾取"
"并尝试一下！"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:609
#, fuzzy
msgid ""
"Notice how we're not limiting the amount of ammo you can carry. To limit the "
"amount of ammo each weapon can carry, you need to add an additional variable "
"to each weapon's script, and then clamp the weapon's ``spare_ammo`` variable "
"after adding ammo in ``add_ammo``."
msgstr ""
"请注意我们如何限制您可携带的弹药数量。 为了限制每个武器可以携带的弹药数量，您"
"需要为每个武器的脚本添加一个额外的变量，然后在“add_ammo”中添加弹药后夹住武器"
"的 ``spare_ammo`` 变量。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:613
msgid "Adding breakable targets"
msgstr "添加易碎目标"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:615
msgid "Before we end this part, let's add some targets."
msgstr "在我们结束这一部分之前，让我们添加一些目标。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:617
msgid ""
"Open up ``Target.tscn`` and take a look at the scenes in the scene tree."
msgstr "打开 ``Target.tscn`` 并查看场景树中的场景。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:619
#, fuzzy
msgid ""
"Firstly, notice how we're not using a :ref:`RigidBody <class_RigidBody>` "
"node, but a :ref:`StaticBody <class_StaticBody>` one. The reason behind this "
"is our non-broken targets will not be moving anywhere; using a :ref:"
"`RigidBody <class_RigidBody>` would be more hassle than it's worth since all "
"it has to do is stay still."
msgstr ""
"首先，请注意我们如何不使用 :ref:`RigidBody <class_RigidBody>` 节点，而是使"
"用 :ref:`StaticBody <class_StaticBody>` 节点。 这背后的原因是我们的非破坏目标"
"不会移动到任何地方，使用 :ref:`RigidBody <class_RigidBody>` 比它的价值更麻"
"烦，因为所有它必须做的就是保持静止。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:623
#, fuzzy
msgid ""
"We also save a tiny bit of performance using a :ref:`StaticBody "
"<class_StaticBody>` over a :ref:`RigidBody <class_RigidBody>`."
msgstr ""
"我们还使用 :ref:`StaticBody <class_StaticBody>` 来节省一点点性能 :ref:"
"`RigidBody <class_RigidBody>`"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:625
msgid ""
"The other thing to note is we have a node called ``Broken_Target_Holder``. "
"This node is going to hold a spawned/instanced scene called ``Broken_Target."
"tscn``. Open up ``Broken_Target.tscn``."
msgstr ""
"另外需要注意的是我们有一个名为 ``Broken_Target_Holder`` 的节点。 该节点将保存"
"一个名为 ``Broken_Target.tscn`` 的衍生/实例化场景。 打开 ``Broken_Target."
"tscn`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:628
#, fuzzy
msgid ""
"Notice how the target is broken up into five pieces, each a :ref:`RigidBody "
"<class_RigidBody>` node. We're going to spawn/instance this scene when the "
"target takes too much damage and needs to be destroyed. Then, we're going to "
"hide the non-broken target, so it looks like the target shattered rather "
"than a shattered target was spawned/instanced."
msgstr ""
"注意目标如何分解为五个部分，每个部分a :ref:`RigidBody <class_RigidBody>` 节"
"点。 当目标受到太多伤害并需要被摧毁时，我们将生成/实例化这个场景。 然后我们将"
"隐藏未破坏的目标，因此它看起来像目标破碎而不是产生/实例化的破碎目标。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:632
#, fuzzy
msgid ""
"While you still have ``Broken_Target.tscn`` open, attach "
"``RigidBody_hit_test.gd`` to all of the :ref:`RigidBody <class_RigidBody>` "
"nodes. This will make it so the player can shoot at the broken pieces and "
"they will react to the bullets."
msgstr ""
"当您仍然打开 ``Broken_Target.tscn`` 然后将 ``RigidBody_hit_test.gd`` 附加到所"
"有的 :ref:`RigidBody <class_RigidBody>` 节点。 这将使游戏角色能够在破碎的棋子"
"上射击并且他们将对子弹作出反应。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:635
msgid ""
"Alright, now switch back to ``Target.tscn``, select the ``Target`` :ref:"
"`StaticBody <class_StaticBody>` node and create a new script called ``Target."
"gd``."
msgstr ""
"好吧，现在切换回 ``Target.tscn`` ，选择``Target`` :ref:`StaticBody "
"<class_StaticBody>` 节点并创建一个名为 ``Target.gd`` 的新脚本。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:637
msgid "Add the following code to ``Target.gd``:"
msgstr "将以下代码添加到``Target.gd``:"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:695
#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:901
msgid "Let's go over what this script does, starting with the class variables:"
msgstr "让我们回顾一下这个脚本的作用，从类变量开始:"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:697
msgid ""
"``TARGET_HEALTH``: The amount of damage needed to break a fully healed "
"target."
msgstr "``TARGET_HEALTH``:打破完全治疗目标所需的伤害量。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:698
msgid "``current_health``: The amount of health this target currently has."
msgstr "``current_health``:此目标目前的健康状况。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:699
msgid ""
"``broken_target_holder``: A variable to hold the ``Broken_Target_Holder`` "
"node so we can use it easily."
msgstr ""
"``broken_target_holder``:一个变量，用于保存 ``Broken_Target_Holder`` 节点，以"
"便我们可以轻松使用它。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:700
msgid ""
"``target_collision_shape``: A variable to hold the :ref:`CollisionShape "
"<class_CollisionShape>` for the non-broken target."
msgstr ""
"``target_collision_shape``:一个变量，用于保存 :ref:`CollisionShape "
"<class_CollisionShape>` 用于未破坏的目标。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:701
msgid ""
"``TARGET_RESPAWN_TIME``: The length of time, in seconds, it takes for a "
"target to respawn."
msgstr "``TARGET_RESPAWN_TIME``:目标重生的时间长度(以秒为单位)。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:702
msgid ""
"``target_respawn_timer``: A variable to track how long a target has been "
"broken."
msgstr "``target_respawn_timer``:一个跟踪目标被破坏时间的变量。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:703
msgid ""
"``destroyed_target``: A :ref:`PackedScene <class_PackedScene>` to hold the "
"broken target scene."
msgstr ""
"``destroyed_target``:A :ref:`PackedScene <class_PackedScene>` 来保存破碎的目"
"标场景。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:705
#, fuzzy
msgid ""
"Notice how we're using an exported variable (a :ref:`PackedScene "
"<class_PackedScene>`) to get the broken target scene instead of using "
"``preload``. By using an exported variable, we can choose the scene from the "
"editor, and if we need to use a different scene, it's as easy as selecting a "
"different scene in the editor; we don't need to go to the code to change the "
"scene we're using."
msgstr ""
"注意我们如何使用导出的变量(a :ref:`PackedScene <class_PackedScene>`)来获取破"
"坏的目标场景而不是使用 ``preload`` 。 通过使用导出的变量，我们可以从编辑器中"
"选择场景，如果我们需要使用不同的场景，就像在编辑器中选择不同的场景一样简单，"
"我们不需要转到代码来更改 我们正在使用的场景。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:711
msgid "Let's look at ``_ready``."
msgstr "让我们看看`_ready``。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:713
#, fuzzy
msgid ""
"The first thing we do is get the broken target holder and assign it to "
"``broken_target_holder``. Notice how we're using ``get_parent().get_node()`` "
"here, instead of ``$``. If you wanted to use ``$``, then you'd need to "
"change ``get_parent().get_node()`` to ``$\"../Broken_Target_Holder\"``."
msgstr ""
"我们要做的第一件事是获取破碎的目标持有者并将其分配给 "
"``broken_target_holder`` 。 注意我们如何在这里使用 ``get_parent()."
"get_node()`` ，而不是 ``$`` 。 如果您想使用 ``$`` ，那么您需要将 "
"``get_parent().get_node()`` 改为``$“../ Broken_Target_Holder”``。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:716
msgid ""
"At the time of when this was written, I did not realize you can use ``$\"../"
"NodeName\"`` to get the parent nodes using ``$``, which is why "
"``get_parent().get_node()`` is used instead."
msgstr ""
"在写这篇文章时，我没有意识到您可以使用``$“../ NodeName”``来使用``$``来获取父"
"节点，这就是为什么``get_parent()。get_node( )``用来代替。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:719
#, fuzzy
msgid ""
"Next, we get the collision shape and assign it to "
"``target_collision_shape``. The reason we need the collision shape is "
"because even when the mesh is invisible, the collision shape will still "
"exist in the physics world. This makes it so the player could interact with "
"a non-broken target even though it's invisible, which is not what we want. "
"To get around this, we will disable/enable the collision shape as we make "
"the mesh visible/invisible."
msgstr ""
"接下来我们得到碰撞形状并将其分配给 ``target_collision_shape`` 。 我们需要碰撞"
"形状的原因是因为即使网格不可见，碰撞形状仍然存在于物理世界中。 这使得游戏角色"
"可以与未破坏的目标交互，即使它是不可见的，这不是我们想要的。 为了解决这个问"
"题，我们将禁用/启用碰撞形状，因为我们使网格可见/不可见。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:725
msgid "Next let's look at ``_physics_process``."
msgstr "接下来让我们看一下 ``_physics_process`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:727
#, fuzzy
msgid ""
"We're only going to be using ``_physics_process`` for respawning, and so the "
"first thing we do is check to see if ``target_respawn_timer`` is greater "
"than ``0``."
msgstr ""
"我们只会使用 ``_physics_process`` 进行重生，所以我们要做的第一件事是检查 "
"``target_respawn_timer`` 是否超过 ``0`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:729
#, fuzzy
msgid "If it is, we then subtract ``delta`` from it."
msgstr "如果是，我们从中删除 ``delta`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:731
#, fuzzy
msgid ""
"Then we check to see if ``target_respawn_timer`` is ``0`` or less. The "
"reason behind this is since we just removed ``delta`` from "
"``target_respawn_timer``, if it's ``0`` or less, then the target just got "
"here, effectively allowing us to do whatever we need to do when the timer is "
"finished."
msgstr ""
"然后我们检查 ``target_respawn_timer`` 是否为“0”或更少。 这背后的原因是因为我"
"们刚从 ``target_respawn_timer`` 中删除了 ``delta`` ，如果它是'0``或更少，那么"
"目标刚到这里，有效地允许我们做任何我们需要做的事情当计时器 完了。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:734
msgid "In this case, we want to respawn the target."
msgstr "在这种情况下，我们想重新生成目标。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:736
msgid ""
"The first thing we do is remove all children in the broken target holder. We "
"do this by iterating over all of the children in ``broken_target_holder`` "
"and free them using ``queue_free``."
msgstr ""
"我们要做的第一件事是移除破碎的目标持有者中的所有儿童。 我们通过遍历 "
"``broken_target_holder`` 中的所有子节点并使用 ``queue_free`` 释放它们来完成此"
"操作。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:738
#, fuzzy
msgid ""
"Next, we enable the collision shape by setting its ``disabled`` boolean to "
"``false``."
msgstr ""
"接下来，我们通过将 ``disabled`` 布尔值设置为 ``false`` 来启用碰撞形状。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:740
msgid "Then we make the target, and all of its children nodes, visible again."
msgstr "然后我们再次使目标及其所有子节点可见。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:742
msgid ""
"Finally, we reset the target's health (``current_health``) to "
"``TARGET_HEALTH``."
msgstr ""
"最后，我们将目标的健康状况(``current_health``)重置为``TARGET_HEALTH``。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:746
#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:903
msgid "Finally, let's look at ``bullet_hit``."
msgstr "最后，让我们看一下 ``bullet_hit`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:748
#, fuzzy
msgid ""
"The first thing we do is subtract however much damage the bullet does from "
"the target's health."
msgstr "我们要做的第一件事就是去除子弹对目标健康造成的伤害。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:750
msgid ""
"Next we check to see if the target is at ``0`` health or lower. If it is, "
"the target has just died and we need to spawn a broken target."
msgstr ""
"接下来我们检查目标是否处于“0”健康状态或更低。 如果是，目标刚刚死亡，我们需要"
"产生一个破碎的目标。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:752
msgid ""
"We first instance a new destroyed target scene, and assign it to a new "
"variable, a ``clone``."
msgstr ""
"我们首先实例化一个新的被破坏的目标场景，并将其分配给一个新变量，即 "
"``clone`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:754
msgid "Next we add the ``clone`` as a child of the broken target holder."
msgstr "接下来，我们将 ``clone`` 添加为已损坏目标持有者的子项。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:756
#, fuzzy
msgid ""
"For bonus effect, we want to make all the target pieces explode outwards. To "
"do this, we iterate over all the children in ``clone``."
msgstr ""
"对于奖励效果，我们希望使所有目标碎片向外爆炸。 为此，我们遍历 ``clone`` 中的"
"所有子节点。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:758
msgid ""
"For each child, we first check to see if it's a :ref:`RigidBody "
"<class_RigidBody>` node. If it is, we then calculate the center position of "
"the target relative to the child node. Then we figure out which direction "
"the child node is relative to the center. Using those calculated variables, "
"we push the child from the calculated center, in the direction away from the "
"center, using the damage of the bullet as the force."
msgstr ""
"对于每个子节点，我们首先检查它是否是 :ref:`RigidBody <class_RigidBody>` 节"
"点。 如果是，我们然后计算目标相对于子节点的中心位置。 然后我们计算出子节点相"
"对于中心的方向。 使用这些计算出的变量，我们将子弹从计算中心推向远离中心的方"
"向，使用子弹的损伤作为力。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:762
#, fuzzy
msgid ""
"We multiply the damage by ``12`` so it has a more dramatic effect. You can "
"change this to a higher or lower value depending on how explosively you want "
"your targets to shatter."
msgstr ""
"我们将伤害乘以“12”以使其具有更显着的效果。 您可以将此值更改为更高或更低的值，"
"具体取决于您希望目标破碎的爆炸程度。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:765
#, fuzzy
msgid ""
"Next, we set the target's respawn timer. We set the timer to "
"``TARGET_RESPAWN_TIME``, so it takes ``TARGET_RESPAWN_TIME`` in seconds "
"until it is respawned."
msgstr ""
"接下来我们设置目标的重生计时器。 我们将计时器设置为 "
"``TARGET_RESPAWN_TIME`` ，因此它在几秒钟内需要 ``TARGET_RESPAWN_TIME`` ，直到"
"重生为止。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:767
msgid ""
"Then we disable the non-broken target's collision shape, and set the "
"target's visibility to ``false``."
msgstr "然后我们禁用非破坏目标的碰撞形状，并将目标的可见性设置为“假”。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:771
msgid ""
"Make sure to set the exported ``destroyed_target`` value for ``Target.tscn`` "
"in the editor! Otherwise the targets will not be destroyed and you will get "
"an error!"
msgstr ""
"确保在编辑器中为 ``Target.tscn`` 设置导出的 ``destroyed_target`` 值！ 否则目"
"标将不会被销毁，您将收到错误！"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:774
msgid ""
"With that done, go place some ``Target.tscn`` instances around in one/both/"
"all of the levels. You should find they explode into five pieces after "
"they've taken enough damage. After a little while, they'll respawn into a "
"whole target again."
msgstr ""
"完成后，在一个/两个/所有级别中放置一些 ``Target.tscn`` 实例。 您会发现他们在"
"受到足够的伤害后会爆炸成五件。 过了一会儿，他们会再次重生成一个整体目标。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:782
msgid ""
"Now you can use a joypad, change weapons with the mouse's scroll wheel, "
"replenish your health and ammo, and break targets with your weapons."
msgstr ""
"现在您可以使用游戏手柄，用鼠标的滚轮更换武器，补充您的健康和弹药，并用您的武"
"器打破目标。"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:784
msgid ""
"In the next part, :ref:`doc_fps_tutorial_part_five`, we're going to add "
"grenades to our player, give our player the ability to grab and throw "
"objects, and add turrets!"
msgstr ""
"在下一部分中， :ref:`doc_fps_tutorial_part_five`，我们将为我们的游戏角色添加"
"手榴弹，让我们的游戏角色能够抓住并投掷物体，并添加炮塔！"

#: ../../docs/tutorials/3d/fps_tutorial/part_four.rst:789
msgid ""
"You can download the finished project for this part here: :download:"
"`Godot_FPS_Part_4.zip <files/Godot_FPS_Part_4.zip>`"
msgstr ""
"您可以在这里下载这个部分的完成项目: :download:`Godot_FPS_Part_4.zip <files / "
"Godot_FPS_Part_4.zip>`"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:4
msgid "Part 5"
msgstr "第5部分"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:9
#, fuzzy
msgid ""
"In this part, we're going to add grenades to the player, give the player the "
"ability to grab and throw objects, and add turrets!"
msgstr ""
"在这部分中，我们将向游戏角色添加手榴弹，让游戏角色能够抓住并投掷物体，并添加"
"炮塔！"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:13
msgid ""
"You are assumed to have finished :ref:`doc_fps_tutorial_part_four` before "
"moving on to this part of the tutorial. The finished project from :ref:"
"`doc_fps_tutorial_part_four` will be the starting project for part 5"
msgstr ""
"在继续本教程的这一部分之前，我们假设您已经完成了 :ref:"
"`doc_fps_tutorial_part_four`。 完成的项目来自 :ref:"
"`doc_fps_tutorial_part_four`将成为第5部分的起始项目"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:19
msgid "Adding grenades"
msgstr "添加手榴弹"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:21
#, fuzzy
msgid ""
"Firstly, let's give the player some grenades to play with. Open up ``Grenade."
"tscn``."
msgstr "首先，让我们给游戏角色一些手榴弹。 打开 ``Grenade.tscn``。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:23
#, fuzzy
msgid ""
"There are a few things to note here, the first and foremost being that the "
"grenades are going to use :ref:`RigidBody <class_RigidBody>` nodes. We're "
"going to use :ref:`RigidBody <class_RigidBody>` nodes for our grenades so "
"they bounce around the world in a (somewhat) realistic manner."
msgstr ""
"这里有一些注意事项，首先是手榴弹将要使用 :ref:`RigidBody <class_RigidBody>` "
"节点。 我们将使用 :ref:`RigidBody <class_RigidBody>` 我们手榴弹的节点，所以它"
"们以某种(某种)现实的方式在世界各地反弹。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:26
msgid ""
"The second thing to note is ``Blast_Area``. This is an :ref:`Area "
"<class_Area>` node that will represent the blast radius of the grenade."
msgstr ""
"第二点需要注意的是 ``Blast_Area``。 这是一个 :ref:`Area <class_Area>` 节点，"
"它代表手榴弹的爆炸半径。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:28
#, fuzzy
msgid ""
"Finally, the last thing to note is ``Explosion``. This is the :ref:"
"`Particles <class_Particles>` node that will emit an explosion effect when "
"the grenade explodes. One thing to note here is that we have ``One shot`` "
"enabled. This is so we emit all the particles at once. The particles are "
"also emitted using world coordinates instead of local coordinates, so we "
"have ``Local Coords`` unchecked as well."
msgstr ""
"最后，最后要注意的是“爆炸”。 这是 :ref:`Particles <class_Particles>` 节点，当"
"手榴弹爆炸时会发出爆炸效果。 这里要注意的一点是我们启用了“一次性”。 这样我们"
"一次发射所有粒子。 粒子也是使用世界坐标而不是局部坐标发射的，所以我们也没有选"
"中“局部坐标”。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:32
msgid ""
"If you want, you can see how the particles are set up by looking through the "
"particle's ``Process Material`` and ``Draw Passes``."
msgstr ""
"如果需要，您可以通过查看粒子的“过程材质”和“绘制过程”来查看粒子是如何设置的。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:34
msgid ""
"Let's write the code needed for the grenade. Select ``Grenade`` and make a "
"new script called ``Grenade.gd``. Add the following:"
msgstr ""
"让我们编写手榴弹所需的代码。 选择 ``Grenade`` 并制作一个名为 ``Grenade.gd`` "
"的新脚本。 添加以下内容:"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:90
msgid "Let's go over what's happening, starting with the class variables:"
msgstr "让我们回顾一下正在发生的事情，从类变量开始:"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:92
msgid ""
"``GRENADE_DAMAGE``: The amount of damage the grenade causes when it explodes."
msgstr "``GRENADE DAMAGE``:手榴弹爆炸时造成的伤害量。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:93
msgid ""
"``GRENADE_TIME``: The amount of time the grenade takes (in seconds) to "
"explode once it's created/thrown."
msgstr "``GRENADE_TIME``:手榴弹在创建/抛出后爆炸所需的时间(以秒为单位)。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:94
msgid ""
"``grenade_timer``: A variable for tracking how long the grenade has been "
"created/thrown."
msgstr "``grenade_timer``:一个变量，用于跟踪手榴弹被创建/抛出的时间。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:95
msgid ""
"``EXPLOSION_WAIT_TIME``: The amount of time needed (in seconds) to wait "
"before we destroy the grenade scene after the explosion"
msgstr ""
"``EXPLOSION_WAIT_TIME``:爆炸后我们摧毁手榴弹场景所需的等待时间(以秒为单位)"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:96
msgid ""
"``explosion_wait_timer``: A variable for tracking how much time has passed "
"since the grenade exploded."
msgstr ""
"``explosion_wait_timer``:一个变量，用于跟踪自手榴弹爆炸以来已经过了多少时间。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:97
msgid ""
"``rigid_shape``: The :ref:`CollisionShape <class_CollisionShape>` for the "
"grenade's :ref:`RigidBody <class_RigidBody>`."
msgstr ""
"``rigid_shape``: :ref:`CollisionShape <class_CollisionShape>` 用于手榴弹 :"
"ref:`RigidBody <class_RigidBody>`。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:98
msgid ""
"``grenade_mesh``: The :ref:`MeshInstance <class_MeshInstance>` for the "
"grenade."
msgstr ""
"``grenade_mesh``:手榴弹的参考 :ref:`MeshInstance <class_MeshInstance>` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:99
msgid ""
"``blast_area``: The blast :ref:`Area <class_Area>` used to damage things "
"when the grenade explodes."
msgstr ""
"``blast_area``:爆炸 :ref:`Area <class_Area>` 用于在手榴弹爆炸时损坏东西。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:100
#, fuzzy
msgid ""
"``explosion_particles``: The :ref:`Particles <class_Particles>` that come "
"out when the grenade explodes."
msgstr ""
"``explosion_particles``:当手榴弹爆炸时发挥作用 :ref:`Particles "
"<class_Particles>` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:102
msgid ""
"Notice how ``EXPLOSION_WAIT_TIME`` is a rather strange number (``0.48``). "
"This is because we want ``EXPLOSION_WAIT_TIME`` to be equal to the length of "
"time the explosion particles are emitting, so when the particles are done we "
"destroy/free the grenade. We calculate ``EXPLOSION_WAIT_TIME`` by taking the "
"particle's life time and dividing it by the particle's speed scale. This "
"gets us the exact time the explosion particles will last."
msgstr ""
"注意 ``EXPLOSION_WAIT_TIME`` 是一个相当奇怪的数字(``0.48``)。 这是因为我们希"
"望 ``EXPLOSION_WAIT_TIME`` 等于爆炸粒子发射的时间长度，所以当粒子完成时我们会"
"摧毁/释放手榴弹。 我们通过获取粒子的生命时间并将其除以粒子的速度刻度来计"
"算“EXPLOSION_WAIT_TIME”。 这让我们得到了爆炸粒子持续的确切时间。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:108
msgid "Now let's turn our attention to ``_ready``."
msgstr "现在让我们把注意力转向 ``_ready`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:110
#, fuzzy
msgid ""
"First we get all the nodes we'll need and assign them to the proper class "
"variables."
msgstr "首先，我们得到我们需要的所有节点，并将它们分配给正确的类变量。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:112
msgid ""
"We need to get the :ref:`CollisionShape <class_CollisionShape>` and :ref:"
"`MeshInstance <class_MeshInstance>` because similarly to the target in :ref:"
"`doc_fps_tutorial_part_four`, we will be hiding the grenade's mesh and "
"disabling the collision shape when the grenade explodes."
msgstr ""
"我们需要得到 :ref:`CollisionShape <class_CollisionShape>` 和 :ref:"
"`MeshInstance <class_MeshInstance>` 因为类似于 :ref:"
"`doc_fps_tutorial_part_four`中的目标，我们将隐藏手榴弹的网格并禁用碰撞形状 手"
"榴弹爆炸了。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:115
msgid ""
"The reason we need to get the blast :ref:`Area <class_Area>` is so we can "
"damage everything inside it when the grenade explodes. We'll be using code "
"similar to the knife code in the player. We need the :ref:`Particles "
"<class_Particles>` so we can emit particles when the grenade explodes."
msgstr ""
"我们需要获得爆炸的原因 :ref:`Area <class_Area>` 这样我们可以在手榴弹爆炸时损"
"坏其内部的一切。 我们将使用与游戏角色中的刀代码类似的代码。 我们需要 :ref:"
"`Particles <class_Particles>` 所以我们可以在手榴弹爆炸时发射粒子。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:118
#, fuzzy
msgid ""
"After we get all the nodes and assign them to their class variables, we then "
"make sure the explosion particles are not emitting, and that they are set to "
"emit in one shot. This is to be extra sure the particles will behave the way "
"we expect them to."
msgstr ""
"在我们获得所有节点并将它们分配给它们的类变量之后，我们确保爆炸粒子不会发射，"
"并且它们被设置为一次发射。 这是更加确定粒子将按照我们期望的方式运行。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:123
msgid "Now let's look at ``_process``."
msgstr "现在让我们来看看`_process``。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:125
#, fuzzy
msgid ""
"Firstly, we check to see if the ``grenade_timer`` is less than "
"``GRENADE_TIME``. If it is, we add ``delta`` and return. This is so the "
"grenade has to wait ``GRENADE_TIME`` seconds before exploding, allowing the :"
"ref:`RigidBody <class_RigidBody>` to move around."
msgstr ""
"首先，我们检查 ``grenade_timer`` 是否小于 ``GRENADE_TIMER`` 。 如果是，我们添"
"加 ``delta`` 并返回。 这是因为手榴弹必须在爆炸前等待 ``GRENADE_TIME`` 秒，允"
"许 :ref:`RigidBody <class_RigidBody>` 移动。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:128
msgid ""
"If ``grenade_timer`` is at ``GRENADE_TIMER`` or higher, we then need to "
"check if the grenade has waited long enough and needs to explode. We do this "
"by checking to see if ``explosion_wait_timer`` is equal to ``0`` or less. "
"Since we will be adding ``delta`` to ``explosion_wait_timer`` right after, "
"whatever code under the check will only be called once, right when the "
"grenade has waited long enough and needs to explode."
msgstr ""
"如果 ``grenade_timer`` 位于 ``GRENADE_TIMER`` 或更高，那么我们需要检查手榴弹"
"是否等待了足够长的时间并且需要爆炸。 我们通过检查 ``explosion_wait_timer`` 是"
"否等于 ``0`` 或更少来做到这一点。 因为我们将立即将 ``delta`` 添加到 "
"``explosion_wait_timer`` ，所以检查下的任何代码只会被调用一次，就在手榴弹等待"
"足够长并且需要爆炸时。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:132
msgid ""
"If the grenade has waited long enough to explode, we first tell the "
"``explosion_particles`` to emit. Then we make ``grenade_mesh`` invisible, "
"and disable ``rigid_shape``, effectively hiding the grenade."
msgstr ""
"如果手榴弹已经等待足够长的时间爆炸，我们首先告诉“爆炸_粒子”发射。 然后我们使 "
"``grenade_mesh`` 不可见，并禁用 ``rigid_shape`` ，有效地隐藏了手榴弹。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:135
msgid ""
"We then set the :ref:`RigidBody <class_RigidBody>`'s mode to ``MODE_STATIC`` "
"so the grenade does not move."
msgstr ""
"然后我们将 :ref:`RigidBody <class_RigidBody>的模式设置为 ``MODE_STATIC`` ，这"
"样手榴弹就不会移动了。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:137
#, fuzzy
msgid ""
"Then we get all the bodies in ``blast_area``, check to see if they have the "
"``bullet_hit`` method/function, and if they do, we call it and pass in "
"``GRENADE_DAMAGE`` and the transform from the body looking at the grenade. "
"This makes it where the bodies exploded by the grenade will explode outwards "
"from the grenade's position."
msgstr ""
"然后我们得到 ``blast_area`` 中的所有主体，检查他们是否有 ``bullet_hit`` 方法/"
"函数，如果他们这样做，我们调用它并传入 ``GRENADE_DAMAGE`` 并从中转换 物体看着"
"手榴弹。 这使得手榴弹爆炸的物体会从手榴弹的位置向外爆炸。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:140
#, fuzzy
msgid ""
"We then check to see if ``explosion_wait_timer`` is less than "
"``EXPLOSION_WAIT_TIME``. If it is, we add ``delta`` to "
"``explosion_wait_timer``."
msgstr ""
"然后我们检查 ``explosion_wait_timer`` 是否小于 ``EXPLOSION_WAIT_TIME`` 。 如"
"果是，我们将 ``delta`` 添加到 ``explosion_wait_time`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:142
#, fuzzy
msgid ""
"Next, we check to see if ``explosion_wait_timer`` is greater than or equal "
"to ``EXPLOSION_WAIT_TIME``. Because we added ``delta``, this will only be "
"called once. If ``explosion_wait_timer`` is greater or equal to "
"``EXPLOSION_WAIT_TIME``, the grenade has waited long enough to let the :ref:"
"`Particles <class_Particles>` play and we can free/destroy the grenade, as "
"we no longer need it."
msgstr ""
"接下来我们检查 ``explosion_wait_timer`` 是否大于或等于 "
"``EXPLOSION_WAIT_TIME`` 。 因为我们添加了 ``delta`` ，所以只会调用一次。 如"
"果 ``explosion_wait_timer`` 大于或等于 ``EXPLOSION_WAIT_TIME`` ，则手榴弹已等"
"待足够长时间让 :ref:`Particles <class_Particles>` 玩，我们可以释放/销毁手榴"
"弹，因为我们不再需要它。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:148
msgid ""
"Let's quickly get the sticky grenade set up too. Open up ``Sticky_Grenade."
"tscn``."
msgstr "让我们快速设置粘性手榴弹。 打开 ``Sticky_Grenade.tscn`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:150
msgid ""
"``Sticky_Grenade.tscn`` is almost identical to ``Grenade.tscn``, with one "
"small addition. We now have a second :ref:`Area <class_Area>`, called "
"``Sticky_Area``. We will be using ``Stick_Area`` to detect when the sticky "
"grenade has collided with the environment and needs to stick to something."
msgstr ""
"``Sticky_Grenade.tscn``几乎与``Grenade.tscn``相同，只有一个小的补充。 我们现"
"在有第二个 :ref:`Area <class_Area>`，称为 ``Sticky_Area`` 。 我们将使"
"用“Stick_Area”来检测粘性手榴弹何时与环境相撞并需要粘在某物上。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:154
msgid ""
"Select ``Sticky_Grenade`` and make a new script called ``Sticky_Grenade."
"gd``. Add the following:"
msgstr ""
"选择 ``Sticky_Grenade`` 并制作一个名为 ``Sticky_Grenade.gd`` 的新脚本。 添加"
"以下内容:"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:244
msgid ""
"The code above is almost identical to the code for ``Grenade.gd``, so let's "
"just go over what's changed."
msgstr ""
"上面的代码几乎与 ``Grenade.gd`` 的代码完全相同，所以让我们回顾一下已经改变的"
"代码。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:246
#, fuzzy
msgid "Firstly, we have a few more class variables:"
msgstr "首先，我们还有一些类变量:"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:248
msgid ""
"``attached``: A variable for tracking whether or not the sticky grenade has "
"attached to a :ref:`PhysicsBody <class_PhysicsBody>`."
msgstr ""
"``附加``:一个变量，用于跟踪粘性手榴弹是否附加到 :ref:`PhysicsBody "
"<class_PhysicsBody>`。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:249
#, fuzzy
msgid ""
"``attach_point``: A variable to hold a :ref:`Spatial <class_Spatial>` that "
"will be at the position where the sticky grenade collided."
msgstr ""
"``attach_point``:一个变量，用于保存 :ref:`Spatial <class_Spatial>` ，它将位于"
"粘性手榴弹碰撞的位置。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:250
msgid ""
"``player_body``: The player's :ref:`KinematicBody <class_KinematicBody>`."
msgstr ""
"``player_body``:游戏角色的 :ref:`KinematicBody <class_KinematicBody>`。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:252
#, fuzzy
msgid ""
"They have been added to enable the sticky grenade to stick to any :ref:"
"`PhysicsBody <class_PhysicsBody>` it might hit. We also now need the "
"player's :ref:`KinematicBody <class_KinematicBody>` so the sticky grenade "
"does not stick to the player when the player throws it."
msgstr ""
"这些添加物是如此粘性手榴弹可以坚持任何 :ref:`PhysicsBody <class_PhysicsBody>"
"它碰巧碰到了。 我们现在还需要游戏角色的 :ref:`KinematicBody "
"<class_KinematicBody>` 所以当游戏角色抛出时，粘性手榴弹不会粘在游戏角色身上。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:257
msgid ""
"Now let's look at the small change in ``_ready``. In ``_ready`` we've added "
"a line of code so when any body enters ``Stick_Area``, the "
"``collided_with_body`` function is called."
msgstr ""
"现在让我们来看看`_ready``中的小变化。 在 ``_ready`` 中我们添加了一行代码，因"
"此当任何物体进入 ``Stick_Area`` 时，会调用 ``collided_with_body`` 函数。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:262
msgid "Next let's take a look at ``collided_with_body``."
msgstr "接下来让我们来看看 ``collided_with_body`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:264
#, fuzzy
msgid ""
"Firstly, we make sure the sticky grenade is not colliding with itself. "
"Because the sticky :ref:`Area <class_Area>` does not know it's attached to "
"the grenade's :ref:`RigidBody <class_RigidBody>`, we need to make sure it's "
"not going to stick to itself by checking to make sure the body it has "
"collided with is not itself. If we have collided with ourself, we ignore it "
"by returning."
msgstr ""
"首先，我们确保粘性手榴弹不会与自身发生碰撞。 因为sticky :ref:`Area "
"<class_Area>` 不知道它附加在手榴弹上 :ref:`RigidBody <class_RigidBody>`，我们"
"需要确保它不会坚持自己通过检查以确保它的物体 与之相撞并不是本身。 如果我们与"
"自己发生冲突，我们会通过返回来忽略它。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:269
msgid ""
"We then check to see if we have something assigned to ``player_body``, and "
"if the body the sticky grenade has collided with is the player that threw "
"it. If the body the sticky grenade has collided with is indeed "
"``player_body``, we ignore it by returning."
msgstr ""
"然后我们检查一下是否有东西分配给 ``player_body`` ，如果粘手榴弹碰撞的物体是投"
"掷它的游戏角色。 如果粘手榴弹碰到的物体确实是'`player_body``，我们会通过返回"
"来忽略它。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:272
#, fuzzy
msgid ""
"Next, we check if the sticky grenade has attached to something already or "
"not."
msgstr "接下来，我们检查粘性手榴弹是否已经附着在某物上。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:274
msgid ""
"If the sticky grenade is not attached, we then set ``attached`` to true so "
"we know the sticky grenade has attached to something."
msgstr ""
"如果没有粘贴手榴弹，我们将“附加”设置为真，这样我们就知道粘性手榴弹附着在某物"
"上。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:276
msgid ""
"We then make a new :ref:`Spatial <class_Spatial>` node, and make it a child "
"of the body the sticky grenade collided with. We then set the :ref:`Spatial "
"<class_Spatial>`'s position to the sticky grenade's current global position."
msgstr ""
"然后我们创建一个新的 :ref:`Spatial <class_Spatial>` 节点，并使其成为粘性手榴"
"弹与之碰撞的物体的子节点。 然后我们将 :ref:`Spatial <class_Spatial>的位置设置"
"为粘性手榴弹当前的全球位置。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:279
msgid ""
"Because we've added the :ref:`Spatial <class_Spatial>` as a child of the "
"body the sticky grenade has collided with, it will follow along with said "
"body. We can then use this :ref:`Spatial <class_Spatial>` to set the sticky "
"grenade's position, so it is always at the same position relative to the "
"body it collided with."
msgstr ""
"因为我们已经添加了 :ref:`Spatial <class_Spatial>` 作为粘性手榴弹碰撞的物体的"
"一个子节点，它将跟随所述物体。 然后我们可以使用它 :ref:`Spatial "
"<class_Spatial>` 来设置粘性手榴弹的位置，因此它总是在相对于它碰撞的物体的相同"
"位置。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:282
msgid ""
"We then disable ``rigid_shape`` so the sticky grenade is not constantly "
"moving whatever body it has collided with. Finally, we set our mode to "
"``MODE_STATIC`` so the grenade does not move."
msgstr ""
"然后我们禁用 ``rigid_shape`` ，这样粘手榴弹就不会一直移动它碰到的任何物体。 "
"最后，我们将模式设置为“MODE_STATIC”，因此手榴弹不会移动。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:287
msgid "Finally, lets go over the few changes in ``_process``."
msgstr "最后，让我们回顾一下 ``_process`` 中的一些变化。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:289
msgid ""
"Now we're checking to see if the sticky grenade is attached right at the top "
"of ``_process``."
msgstr "现在我们正在检查粘性手榴弹是否附在“_process`”的顶部。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:291
msgid ""
"If the sticky grenade is attached, we then make sure the attached point is "
"not equal to ``null``. If the attached point is not equal to ``null``, we "
"set the sticky grenade's global position (using its global :ref:`Transform "
"<class_Transform>`'s origin) to the global position of the :ref:`Spatial "
"<class_Spatial>` assigned to ``attach_point`` (using its global :ref:"
"`Transform <class_Transform>`'s origin)."
msgstr ""
"如果连接了粘性手榴弹，我们确保附加的点不等于“null”。 如果附加的点不等于 "
"``null`` ，我们将粘性手榴弹的全局位置(使用其global :ref:`Transform "
"<class_Transform>的原点)设置为 :ref:`Spatial <的全局位置 class_Spatial>` 赋值"
"给 ``attach_point`` (使用它的global :ref:`Transform <class_Transform>` 的原"
"点)。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:295
msgid ""
"The only other change is now before we free/destroy the sticky grenade is to "
"check to see if the sticky grenade has an attached point. If it does, we "
"also call ``queue_free`` on the attach point, so it's also freed/destroyed."
msgstr ""
"在我们释放/销毁粘性手榴弹之前，现在唯一的另一个变化是检查粘性手榴弹是否有附着"
"点。 如果是这样，我们也在连接点上调用 ``queue_free`` ，因此它也被释放/销毁。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:299
msgid "Adding grenades to the player"
msgstr "向游戏角色添加手榴弹"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:301
msgid ""
"Now we need to add some code to ``Player.gd`` so we can use the grenades."
msgstr "现在我们需要在 ``Player.gd`` 中添加一些代码，以便我们可以使用手榴弹。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:303
#, fuzzy
msgid ""
"Firstly, open up ``Player.tscn`` and expand the node tree until you get to "
"``Rotation_Helper``. Notice how in ``Rotation_Helper`` we have a node called "
"``Grenade_Toss_Pos``. This is where we will be spawning the grenades."
msgstr ""
"首先，打开 ``Player.tscn`` 并展开节点树，直到您到达 ``Rotation_Helper`` 。 注"
"意在 ``Rotation_Helper`` 中我们有一个名为 ``Grenade_Toss_Pos`` 的节点。 这是"
"我们将产生手榴弹的地方。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:306
#, fuzzy
msgid ""
"Also notice how it's slightly rotated on the ``X`` axis, so it's not "
"pointing straight, but rather slightly up. By changing the rotation of "
"``Grenade_Toss_Pos``, you can change the angle at which the grenades are "
"tossed."
msgstr ""
"还要注意它是如何在“X”轴上轻微旋转的，所以它不是直指，而是略微向上。 通过改"
"变“Grenade_Toss_Pos”的旋转，您可以改变投掷手榴弹的角度。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:309
msgid ""
"Okay, now let's start making the grenades work with the player. Add the "
"following class variables to ``Player.gd``:"
msgstr ""
"好的，现在让我们开始让手榴弹与游戏角色一起工作。 将以下类变量添加到``Player."
"gd``:"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:319
msgid ""
"``grenade_amounts``: The amount of grenades the player is currently carrying "
"(for each type of grenade)."
msgstr ""
"``grenade_amounts``:游戏角色当前携带的手榴弹数量(针对每种类型的手榴弹)。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:320
msgid ""
"``current_grenade``: The name of the grenade the player is currently using."
msgstr "``current_grenade``:游戏角色目前正在使用的手榴弹的名称。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:321
msgid "``grenade_scene``: The grenade scene we worked on earlier."
msgstr "``grenade_scene``:我们之前工作的手榴弹场景。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:322
msgid ""
"``sticky_grenade_scene``: The sticky grenade scene we worked on earlier."
msgstr "``sticky_grenade_scene``:我们之前工作过的粘手榴弹场景。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:323
#, fuzzy
msgid ""
"``GRENADE_THROW_FORCE``: The force at which the player will throw the "
"grenades."
msgstr "``GRENADE_THROW_FORCE``:游戏角色投掷手榴弹的力量。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:325
msgid "Most of these variables are similar to how we have our weapons set up."
msgstr "大多数这些变量与我们设置武器的方式类似。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:327
msgid ""
"While it's possible to make a more modular grenade system, I found it was "
"not worth the additional complexity for just two grenades. If you were going "
"to make a more complex FPS with more grenades, you'd likely want to make a "
"system for grenades similar to how we have the weapons set up."
msgstr ""
"虽然可以制作更模块化的手榴弹系统，但我发现仅仅两枚手榴弹的额外复杂性是不值得"
"的。 如果您打算制造一个更复杂的FPS和更多的手榴弹，您可能想要建立一个类似于我"
"们如何设置武器的手榴弹系统。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:332
msgid ""
"Now we need to add some code in ``_process_input`` Add the following to "
"``_process_input``:"
msgstr ""
"现在我们需要在 ``_process_input`` 中添加一些代码。将以下内容添加到"
"``_process_input``:"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:364
#, fuzzy
msgid ""
"Firstly, we check to see if the ``change_grenade`` action has just been "
"pressed. If it has, we then check to see which grenade the player is "
"currently using. Based on the name of the grenade the player is currently "
"using, we change ``current_grenade`` to the opposite grenade name."
msgstr ""
"首先，我们检查是否刚刚按下了 ``change_grenade`` 动作。 如果有，我们检查游戏角"
"色当前使用的手榴弹。 根据游戏角色当前使用的手榴弹的名称，我们"
"将“current_grenade”改为相反的手榴弹名称。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:367
msgid ""
"Next we check to see if the ``fire_grenade`` action has just been pressed. "
"If it has, we then check to see if the player has more than ``0`` grenades "
"for the current grenade type selected."
msgstr ""
"接下来我们检查是否刚刚按下了 ``fire_grenade`` 动作。 如果有，我们检查游戏角色"
"是否有超过“0”的手榴弹，用于当前选择的手榴弹类型。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:370
msgid ""
"If the player has more than ``0`` grenades, we then remove one from the "
"grenade amounts for the current grenade. Then, based on the grenade the "
"player is currently using, we instance the proper grenade scene and assign "
"it to ``grenade_clone``."
msgstr ""
"如果游戏角色拥有超过“0”的手榴弹，我们就会从当前手榴弹的手榴弹数量中移除一"
"枚。 然后，根据游戏角色当前正在使用的手榴弹，我们实例化正确的手榴弹场景并将其"
"分配给“grenade_clone”。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:373
msgid ""
"Next we add ``grenade_clone`` as a child of the node at the root and set its "
"global :ref:`Transform <class_Transform>` to ``Grenade_Toss_Pos``'s global :"
"ref:`Transform <class_Transform>`. Finally, we apply an impulse to the "
"grenade so that it is launched forward, relative to the ``Z`` directional "
"vector of ``grenade_clone``'s."
msgstr ""
"接下来，我们将 ``grenade_clone`` 添加为根节点的子节点，并将其global :ref:"
"`Transform <class_Transform>` 设置为 ``Grenade_Toss_Pos`` 的global :ref:"
"`Transform <class_Transform>`。 最后，我们对手榴弹施加一个冲动，使它相对于 "
"``grenade_clone`` 的 ``Z`` 方向向量向前发射。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:379
msgid ""
"Now the player can use both types of grenades, but there are still a few "
"things we should probably add before we move on to adding the other things."
msgstr ""
"现在游戏角色可以使用两种类型的手榴弹，但在我们继续添加其他东西之前，我们应该"
"添加一些东西。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:381
msgid ""
"We still need a way to show the player how many grenades are left, and we "
"should probably add a way to get more grenades when the player picks up ammo."
msgstr ""
"我们仍然需要一种方法向游戏角色展示剩下多少手榴弹，我们应该在游戏角色拿起弹药"
"时增加一种获得更多手榴弹的方法。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:383
#, fuzzy
msgid ""
"Firstly, let's change some of the code in ``Player.gd`` to show how many "
"grenades are left. Change ``process_UI`` to the following:"
msgstr ""
"首先，让我们改变一下“Player.gd”中的一些代码，以显示剩下多少手榴弹。 将 "
"``process_UI`` 更改为以下内容:"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:399
msgid "Now we'll show how many grenades the player has left in the UI."
msgstr "现在我们将展示游戏角色在UI中留下多少手榴弹。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:401
msgid ""
"While we're still in ``Player.gd``, let's add a function to add grenades to "
"the player. Add the following function to ``Player.gd``:"
msgstr ""
"当我们还在 ``Player.gd`` 时，让我们添加一个向游戏角色添加手榴弹的功能。 将以"
"下函数添加到``Player.gd``:"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:409
msgid ""
"Now we can add a grenade using ``add_grenade``, and it will automatically be "
"clamped to a maximum of ``4`` grenades."
msgstr ""
"现在我们可以使用 ``add_grenade`` 添加一个手榴弹，它会自动被夹到最大的 ``4`` "
"手榴弹。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:411
msgid ""
"You can change the ``4`` to a constant if you want. You'd need to make a new "
"global constant, something like ``MAX_GRENADES``, and then change the clamp "
"from ``clamp(grenade_amounts[current_grenade], 0, 4)`` to "
"``clamp(grenade_amounts[current_grenade], 0, MAX_GRENADES)``"
msgstr ""
"如果需要，可以将“4”改为常量。 您需要创建一个新的全局常量，比如 "
"``MAX_GRENADES`` ，然后将钳位从``clamp(grenade_amounts [current_grenade]，"
"0,4)``更改为``clamp(grenade_amounts [current_grenade]， 0，MAX_GRENADES)``"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:414
msgid ""
"If you do not want to limit how many grenades the player can carry, remove "
"the line that clamps the grenades altogether!"
msgstr "如果您不想限制游戏角色可以携带多少手榴弹，那就去掉完全夹住手榴弹的线！"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:416
msgid ""
"Now we have a function to add grenades, let's open up ``AmmoPickup.gd`` and "
"use it!"
msgstr ""
"现在我们有一个添加手榴弹的功能，让我们打开 ``AmmoPickup.gd`` 并使用它！"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:418
msgid ""
"Open up ``AmmoPickup.gd`` and go to the ``trigger_body_entered`` function. "
"Change it to the following:"
msgstr ""
"打开 ``AmmoPickup.gd`` 并转到 ``trigger_body_entered`` 函数。 将其更改为以下"
"内容:"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:433
msgid ""
"Now we are also checking to see if the body has the ``add_grenade`` "
"function. If it does, we call it like we call ``add_ammo``."
msgstr ""
"现在我们还要检查主体是否有 ``add_grenade`` 函数。 如果是这样，我们称之"
"为“add_ammo”。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:435
msgid ""
"You may have noticed we are using a new constant we have not defined yet, "
"``GRENADE_AMOUNTS``. Let's add it! Add the following class variable to "
"``AmmoPickup.gd`` with the other class variables:"
msgstr ""
"您可能已经注意到我们正在使用一个尚未定义的新常量， ``GRENADE_AMOUNTS`` 。 我"
"们加上吧！ 使用其他类变量将以下类变量添加到``AmmoPickup.gd``:"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:442
#, fuzzy
msgid "``GRENADE_AMOUNTS``: The amount of grenades each pickup contains."
msgstr "``GRENADE_AMOUNTS``:每个拾取的手榴弹数量包含。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:444
#, fuzzy
msgid ""
"Notice how the second element in ``GRENADE_AMOUNTS`` is ``0``. This is so "
"the small ammo pickup does not give the player any additional grenades."
msgstr ""
"注意 ``GRENADE_AMOUNTS`` 中的第二个元素是如何 ``0`` 。 这样小的弹药拾取不会给"
"游戏角色任何额外的手榴弹。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:449
msgid "Now you should be able to throw grenades! Go give it a try!"
msgstr "现在您应该可以投掷手榴弹了！ 去尝试吧！"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:453
msgid "Adding the ability to grab and throw RigidBody nodes to the player"
msgstr "添加抓取并将RigidBody节点投射到游戏角色的功能"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:455
#, fuzzy
msgid ""
"Next, let's give the player the ability to pick up and throw :ref:`RigidBody "
"<class_RigidBody>` nodes."
msgstr ""
"接下来让我们给予游戏角色拾取和抛出的能力 :ref:`RigidBody <class_RigidBody>` "
"节点。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:466
msgid ""
"``grabbed_object``: A variable to hold the grabbed :ref:`RigidBody "
"<class_RigidBody>` node."
msgstr ""
"``grabbed_object``:一个用于保存抓取的变量 :ref:`RigidBody <class_RigidBody>` "
"节点。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:467
#, fuzzy
msgid ""
"``OBJECT_THROW_FORCE``: The force with which the player throws the grabbed "
"object."
msgstr "``OBJECT_THROW_FORCE``:游戏角色将被抓物体甩开的力量。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:468
#, fuzzy
msgid ""
"``OBJECT_GRAB_DISTANCE``: The distance away from the camera at which the "
"player holds the grabbed object."
msgstr "``OBJECT_GRAB_DISTANCE``:游戏角色握住被抓物体的距离。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:469
msgid ""
"``OBJECT_GRAB_RAY_DISTANCE``: The distance the :ref:`Raycast "
"<class_Raycast>` goes. This is the player's grab distance."
msgstr ""
"``OBJECT_GRAB_RAY_DISTANCE``:距离 :ref:`Raycast <class_Raycast>` 去了。 这是"
"游戏角色的抓地距离。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:471
msgid ""
"With that done, all we need to do is add some code to ``process_input``:"
msgstr "完成后，我们需要做的就是在 ``process_input`` 中添加一些代码:"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:509
#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:354
msgid "Let's go over what's happening."
msgstr "让我们回顾一下正在发生的事情。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:511
#, fuzzy
msgid ""
"Firstly, we check to see if the action pressed is the ``fire`` action, and "
"that the player is using the ``UNARMED`` 'weapon'. This is because we only "
"want the player to be able to pick up and throw objects when the player is "
"not using any weapons. This is a design choice, but I feel it gives "
"``UNARMED`` a use."
msgstr ""
"首先，我们检查按下的动作是否是“火”动作，并且游戏角色正在使用“UNARMED``'武"
"器'。 这是因为我们只希望游戏角色在游戏角色不使用任何武器时能够拾取和投掷物"
"体。 这是一个设计选择，但我觉得它给 ``UNARMED`` 一个用途。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:515
msgid "Next we check to see whether or not ``grabbed_object`` is ``null``."
msgstr "接下来我们检查 ``grabbed_object`` 是否为 ``null``。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:519
msgid ""
"If ``grabbed_object`` is ``null``, we want to see if we can pick up a :ref:"
"`RigidBody <class_RigidBody>`."
msgstr ""
"如果 ``grabbed_object`` 是 ``null`` ，我们想看看我们是否可以选择 :ref:"
"`RigidBody <class_RigidBody>`。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:521
msgid ""
"We first get the direct space state from the current :ref:`World "
"<class_World>`. This is so we can cast a ray entirely from code, instead of "
"having to use a :ref:`Raycast <class_Raycast>` node."
msgstr ""
"我们首先从当前获得直接空间状态 :ref:`World <class_World>`。 这样我们就可以完"
"全从代码中投射光线，而不必使用 :ref:`Raycast <class_Raycast>` 节点。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:524
msgid ""
"see :ref:`Ray-casting <doc_ray-casting>` for more information on raycasting "
"in Godot."
msgstr ""
"请参阅 :ref:`Ray-casting <doc_ray-casting>` 了解有关Godot的光线投射的更多信"
"息。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:526
msgid ""
"Then we get the center of the screen by dividing the current :ref:`Viewport "
"<class_Viewport>` size in half. We then get the ray's origin point and end "
"point using ``project_ray_origin`` and ``project_ray_normal`` from the "
"camera. If you want to know more about how these functions work, see :ref:"
"`Ray-casting <doc_ray-casting>`."
msgstr ""
"然后我们通过将当前 :ref:`Viewport <class_Viewport>` 大小分成两半来得到屏幕的"
"中心。 然后我们使用摄像机的 ``project_ray_origin`` 和 ``project_ray_normal`` "
"获取射线的原点和终点。 如果您想了解有关这些函数如何工作的更多信息，请参阅 :"
"ref:`Ray-casting <doc_ray-casting>`。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:529
msgid ""
"Next we send the ray into the space state and see if it gets a result. We "
"add the player and the knife's :ref:`Area <class_Area>` as two exceptions so "
"the player cannot carry themselves or the knife's collision :ref:`Area "
"<class_Area>`."
msgstr ""
"接下来，我们将光线发送到空间状态，看看它是否得到了结果。 我们添加了游戏角色和"
"刀子 :ref:`Area <class_Area>` 作为两个例外，因此游戏角色无法携带自己或刀的碰"
"撞 :ref:`Area <class_Area>`。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:532
msgid ""
"Then we check to see if we got a result back from the ray. If we have, we "
"then see if the collider the ray collided with is a :ref:`RigidBody "
"<class_RigidBody>`."
msgstr ""
"然后我们检查一下我们是否从光线中得到了一个结果。 如果有的话，我们会看到射线碰"
"撞的对撞机是否是 :ref:`RigidBody <class_RigidBody>`。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:534
msgid ""
"If the ray collided with a :ref:`RigidBody <class_RigidBody>`, we set "
"``grabbed_object`` to the collider the ray collided with. We then set the "
"mode on the :ref:`RigidBody <class_RigidBody>` we collided with to "
"``MODE_STATIC`` so it doesn't move in our hands."
msgstr ""
"如果光线与 :ref:`RigidBody <class_RigidBody>相撞，我们将 ``grabbed_object`` "
"设置为光线与光线相撞的对撞机。 然后我们将模式设置为 :ref:`RigidBody "
"<class_RigidBody>` 我们与 ``MODE_STATIC`` 相撞，所以它不会在我们手中移动。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:537
msgid ""
"Finally, we set the grabbed :ref:`RigidBody <class_RigidBody>`'s collision "
"layer and collision mask to ``0``. This will make the grabbed :ref:"
"`RigidBody <class_RigidBody>` have no collision layer or mask, which means "
"it will not be able to collide with anything as long as we are holding it."
msgstr ""
"最后，我们将抓取的 :ref:`RigidBody <class_RigidBody>的碰撞层和碰撞掩码设置"
"为“0”。 这将使得抓住 :ref:`RigidBody <class_RigidBody>` 没有碰撞层或掩码，这"
"意味着只要我们拿着它就不会碰到任何东西。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:542
msgid ""
"If ``grabbed_object`` is not ``null``, then we need to throw the :ref:"
"`RigidBody <class_RigidBody>` the player is holding."
msgstr ""
"如果 ``grabbed_object`` 不是 ``null`` ，那么我们需要抛出游戏角色持有的 :ref:"
"`RigidBody <class_RigidBody>。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:544
#, fuzzy
msgid ""
"We first set the mode of the :ref:`RigidBody <class_RigidBody>` we are "
"holding to ``MODE_RIGID``."
msgstr ""
"我们首先设置 :ref:`RigidBody <class_RigidBody>` 我们保持模式为 "
"``MODE_RIGID`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:546
msgid ""
"This is making a rather large assumption that all the rigid bodies will be "
"using ``MODE_RIGID``. While that is the case for this tutorial series, that "
"may not be the case in other projects."
msgstr ""
"这是一个相当大的假设，即所有刚体都将使用“MODE_RIGID”。 虽然本教程系列就是这种"
"情况，但在其他项目中可能并非如此。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:549
#, fuzzy
msgid ""
"If you have rigid bodies with different modes, you may need to store the "
"mode of the :ref:`RigidBody <class_RigidBody>` you have picked up into a "
"class variable so you can change it back to the mode it was in before you "
"picked it up."
msgstr ""
"如果您有 :ref:`RigidBody <class_RigidBody>` 有不同的模式，您可能需要存储 :"
"ref:`RigidBody <class_RigidBody>的模式您已经选择了一个类变量，所以您可以把它"
"改回来 在您拿起它之前的模式。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:552
msgid ""
"Then we apply an impulse to send it flying forward. We send it flying in the "
"direction the camera is facing, using the force we set in the "
"``OBJECT_THROW_FORCE`` variable."
msgstr ""
"然后我们施加冲动将它向前飞。 我们使用我们在 ``OBJECT_THROW_FORCE`` 变量中设置"
"的力将它发送到相机朝向的方向。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:554
msgid ""
"We then set the grabbed :ref:`RigidBody <class_RigidBody>`'s collision layer "
"and mask to ``1``, so it can collide with anything on layer ``1`` again."
msgstr ""
"然后我们将抓取的 :ref:`RigidBody <class_RigidBody>的碰撞层和掩码设置为 "
"``1`` ，这样它就可以再次与层“1”上的任何东西碰撞。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:556
msgid ""
"This is, once again, making a rather large assumption that all the rigid "
"bodies will be only on collision layer ``1``, and all collision masks will "
"be on layer ``1``. If you are using this script in other projects, you may "
"need to store the collision layer/mask of the :ref:`RigidBody "
"<class_RigidBody>` in a variable before you change them to ``0``, so you "
"would have the original collision layer/mask to set for them when you are "
"reversing the process."
msgstr ""
"这又是一个相当大的假设，即所有刚体都只在碰撞层“1”上，所有碰撞掩模都在"
"层“1”上。 如果您在其他项目中使用此脚本，您可能需要在变量中存储 :ref:"
"`RigidBody <class_RigidBody>` 的碰撞图层/掩码，然后将它们更改为“0”，这样您就"
"可以 在您反转过程时为其设置的原始碰撞图层/蒙版。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:559
msgid ""
"Finally, we set ``grabbed_object`` to ``null`` since the player has "
"successfully thrown the held object."
msgstr ""
"最后，我们将 ``grabbed_object`` 设置为 ``null`` ，因为游戏角色已经成功抛出了"
"被保持的对象。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:563
msgid ""
"The last thing we do is check to see whether or not ``grabbed_object`` is "
"equal to ``null``, outside all of the grabbing/throwing related code."
msgstr ""
"我们做的最后一件事是在所有抓取/投掷相关代码之外检查 ``grabbed_object`` 是否等"
"于 ``null`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:565
msgid ""
"While technically not input related, it's easy enough to place the code "
"moving the grabbed object here because it's only two lines, and then all of "
"the grabbing/throwing code is in one place"
msgstr ""
"虽然技术上没有输入相关，但是将代码移动到此处的代码很容易，因为它只有两行，然"
"后所有的抓取/抛出代码都在一个地方"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:568
msgid ""
"If the player is holding an object, we set its global position to the "
"camera's position plus ``OBJECT_GRAB_DISTANCE`` in the direction the camera "
"is facing."
msgstr ""
"如果游戏角色持有一个物体，我们将其全局位置设置为相机的位置以及相机朝向的方向"
"上的“OBJECT_GRAB_DISTANCE”。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:572
msgid ""
"Before we test this, we need to change something in ``_physics_process``. "
"While the player is holding an object, we do not want the player to be able "
"to change weapons or reload, so change ``_physics_process`` to the following:"
msgstr ""
"在我们测试之前，我们需要在 ``_physics_process`` 中改变一些东西。 当游戏角色持"
"有一个物体时，我们不希望游戏角色能够更换武器或重装，所以将 "
"``_physics_process`` 改为:"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:589
msgid "Now the player cannot change weapons or reload while holding an object."
msgstr "现在游戏角色在拿着物体时无法改变武器或重装。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:591
msgid ""
"Now you can grab and throw RigidBody nodes while you're in the ``UNARMED`` "
"state! Go give it a try!"
msgstr ""
"现在，当您处于“UNARMED”状态时，您可以抓住并抛出RigidBody节点！ 去尝试吧！"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:594
msgid "Adding a turret"
msgstr "添加一个炮塔"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:596
msgid "Next, let's make a turret to shoot the player!"
msgstr "接下来，让我们制作一个炮塔射击游戏角色！"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:598
msgid ""
"Open up ``Turret.tscn``. Expand ``Turret`` if it's not already expanded."
msgstr "打开 ``Turret.tscn`` 。 如果尚未展开，请展开 ``Turret`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:600
#, fuzzy
msgid ""
"Notice how the turret is broken up into several parts: ``Base``, ``Head``, "
"``Vision_Area``, and a ``Smoke`` :ref:`Particles <class_Particles>` node."
msgstr ""
"注意炮塔如何分成几个部分。 我们有一个 ``Base`` ， ``Head`` ， "
"``Vision_Area`` 和一个``Smoke`` :ref:`Particles <class_Particles>`。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:602
#, fuzzy
msgid ""
"Open up ``Base`` and you'll find it's a :ref:`StaticBody <class_StaticBody>` "
"and a mesh. Open up ``Head`` and you'll find there are several meshes, a :"
"ref:`StaticBody <class_StaticBody>` and a :ref:`Raycast <class_Raycast>` "
"node."
msgstr ""
"打开 ``Base`` 您会发现它是 :ref:`StaticBody <class_StaticBody>` 和一个网格。 "
"打开 ``Head`` 您会发现有几个网格，a :ref:`StaticBody <class_StaticBody>` 和"
"a :ref:`Raycast <class_Raycast>` 节点。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:605
msgid ""
"One thing to note with the ``Head`` is that the raycast will be where the "
"turret's bullets will fire from if we are using raycasting. We also have two "
"meshes called ``Flash`` and ``Flash_2``. These will be the muzzle flash that "
"briefly shows when the turret fires."
msgstr ""
"“头部”的一个注意事项是，如果我们使用光线投射，光线投射将是炮塔射击的地方。 我"
"们还有两个网格叫做 ``Flash`` 和 ``Flash_2`` 。 这些将是枪口闪光，简要显示炮塔"
"开火时。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:608
msgid ""
"``Vision_Area`` is an :ref:`Area <class_Area>` we'll use as the turret's "
"ability to see. When something enters ``Vision_Area``, we'll assume the "
"turret can see it."
msgstr ""
"``Vision_Area``是 :ref:`Area <class_Area>` 我们将用作炮塔的能力。 当某些东西"
"进入“Vision_Area”时，我们会认为炮塔可以看到它。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:610
msgid ""
"``Smoke`` is a :ref:`Particles <class_Particles>` node that will play when "
"the turret is destroyed and repairing."
msgstr ""
"``Smoke``是一个 :ref:`Particles <class_Particles>` 节点将在炮塔被摧毁和修复时"
"播放。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:614
msgid ""
"Now that we've looked at how the scene is set up, lets start writing the "
"code for the turret. Select ``Turret`` and create a new script called "
"``Turret.gd``. Add the following to ``Turret.gd``:"
msgstr ""
"现在我们已经了解了如何设置场景，让我们开始编写炮塔的代码。 选择 ``Turret`` 并"
"创建一个名为 ``Turret.gd`` 的新脚本。 将以下内容添加到``Turret.gd``:"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:780
msgid ""
"This is quite a bit of code, so let's break it down function by function. "
"Let's first look at the class variables:"
msgstr "这是相当多的代码，所以让我们按功能分解它。 我们先来看一下类变量:"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:782
#, fuzzy
msgid ""
"``use_raycast``: An exported boolean so we can change whether the turret "
"uses objects or raycasting for bullets."
msgstr ""
"``use_raycast``:一个导出的布尔值，这样我们可以改变炮塔是使用物体还是射线投射"
"子弹。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:783
msgid ""
"``TURRET_DAMAGE_BULLET``: The amount of damage a single bullet scene does."
msgstr "``TURRET_DAMAGE_BULLET``:单个子弹场景造成的伤害量。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:784
msgid ""
"``TURRET_DAMAGE_RAYCAST``: The amount of damage a single :ref:`Raycast "
"<class_Raycast>` bullet does."
msgstr ""
"``TURRET_DAMAGE_RAYCAST``:单个损坏的数量 :ref:`Raycast <class_Raycast>` "
"bullet。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:785
msgid ""
"``FLASH_TIME``: The amount of time (in seconds) the muzzle flash meshes are "
"visible."
msgstr "``FLASH_TIME``:枪口闪光网格的可见时间(以秒为单位)。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:786
msgid ""
"``flash_timer``: A variable for tracking how long the muzzle flash meshes "
"have been visible."
msgstr "``flash_timer``:一个变量，用于跟踪枪口闪光网格的可见时间。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:787
msgid "``FIRE_TIME``: The amount of time (in seconds) needed to fire a bullet."
msgstr "``FIRE_TIME``:发射子弹所需的时间(以秒为单位)。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:788
msgid ""
"``fire_timer``: A variable for tracking how much time has passed since the "
"turret last fired."
msgstr "``fire_timer``:一个变量，用于跟踪炮塔上次射击后经过的时间。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:789
msgid "``node_turret_head``: A variable to hold the ``Head`` node."
msgstr "``node_turret_head``:一个用于保存 ``Head`` 节点的变量。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:790
msgid ""
"``node_raycast``: A variable to hold the :ref:`Raycast <class_Raycast>` node "
"attached to the turret's head."
msgstr ""
"``node_raycast``:一个变量，用于保存附加到炮塔头部的 :ref:`Raycast "
"<class_Raycast>` 节点。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:791
msgid ""
"``node_flash_one``: A variable to hold the first muzzle flash :ref:"
"`MeshInstance <class_MeshInstance>`."
msgstr ""
"``node_flash_one``:一个用于保存第一个枪口flash的变量 :ref:`MeshInstance "
"<class_MeshInstance>`。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:792
msgid ""
"``node_flash_two``: A variable to hold the second muzzle flash :ref:"
"`MeshInstance <class_MeshInstance>`."
msgstr ""
"``node_flash_two``:一个用于保存第二个枪口flash的变量 :ref:`MeshInstance "
"<class_MeshInstance>`。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:793
msgid "``ammo_in_turret``: The amount of ammo currently in the turret."
msgstr "``ammo_in_turret``:目前炮塔中的弹药数量。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:794
msgid "``AMMO_IN_FULL_TURRET``: The amount of ammo in a full turret."
msgstr "``AMMO_IN_FULL_TURRET``:完整炮塔中的弹药数量。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:795
msgid "``AMMO_RELOAD_TIME``: The amount of time it takes the turret to reload."
msgstr "``AMMO_RELOAD_TIME``:炮塔重装的时间。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:796
msgid ""
"``ammo_reload_timer``: A variable for tracking how long the turret has been "
"reloading."
msgstr "``ammo_reload_timer``:一个变量，用于跟踪炮塔重装的时间。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:797
msgid "``current_target``: The turret's current target."
msgstr "``current_target``:炮塔的当前目标。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:798
msgid ""
"``is_active``: A variable for tracking whether the turret is able to fire at "
"the target."
msgstr "``is_active``:用于跟踪炮塔是否能够射向目标的变量。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:799
msgid ""
"``PLAYER_HEIGHT``: The amount of height we're adding to the target so we're "
"not shooting at its feet."
msgstr "``PLAYER_HEIGHT``:我们添加到目标的高度，所以我们不会在它的脚下射击。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:800
msgid "``smoke_particles``: A variable to hold the smoke particles node."
msgstr "``smoke_particles``:用于保存烟雾粒子节点的变量。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:801
msgid "``turret_health``: The amount of health the turret currently has."
msgstr "``turret_health``:炮塔目前的健康状况。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:802
msgid "``MAX_TURRET_HEALTH``: The amount of health a fully healed turret has."
msgstr "``MAX_TURRET_HEALTH``:完全愈合的炮塔的健康量。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:803
msgid ""
"``DESTROYED_TIME``: The amount of time (in seconds) it takes for a destroyed "
"turret to repair itself."
msgstr "``DESTROYED_TIME``:被毁坏的炮塔修复自己所花费的时间(以秒为单位)。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:804
msgid ""
"``destroyed_timer``: A variable for tracking the amount of time a turret has "
"been destroyed."
msgstr "``destroyed_timer``:一个变量，用于跟踪炮塔被摧毁的时间。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:805
msgid ""
"``bullet_scene``: The bullet scene the turret fires (same scene as the "
"player's pistol)"
msgstr "``bullet_scene``:炮塔射击的子弹场景(与游戏角色的手枪相同的场景)"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:807
#, fuzzy
msgid "Whew, that's quite a few class variables!"
msgstr "Phew，这是几个类变量！"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:811
msgid "Let's go through ``_ready`` next."
msgstr "接下来我们来看看`_ready``。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:813
#, fuzzy
msgid ""
"Firstly, we get the vision area and connect the ``body_entered`` and "
"``body_exited`` signals to ``body_entered_vision`` and "
"``body_exited_vision``, respectively."
msgstr ""
"首先，我们得到视觉区域，并分别将 ``body_entered`` 和 ``body_exited`` 信号连接"
"到 ``body_entered_vision`` 和 ``body_exited_vision`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:815
#, fuzzy
msgid ""
"We then get all the nodes and assign them to their respective variables."
msgstr "然后，我们获取所有节点并将它们分配给各自的变量。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:817
#, fuzzy
msgid ""
"Next, we add some exceptions to the :ref:`Raycast <class_Raycast>` so the "
"turret cannot hurt itself."
msgstr ""
"接下来我们添加一些例外 :ref:`Raycast <class_Raycast>` 所以炮塔不会伤害自己。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:819
msgid ""
"Then we make both flash meshes invisible at start, since we are not going to "
"be firing during ``_ready``."
msgstr ""
"然后我们在开始时使两个闪存网格都不可见，因为我们不会在“_ready”期间触发。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:821
#, fuzzy
msgid ""
"We then get the smoke particles node and assign it to the "
"``smoke_particles`` variable. We also set ``emitting`` to ``false`` to "
"ensure the particles are not emitting until the turret is broken."
msgstr ""
"然后我们得到烟雾粒子节点并将其分配给 ``smoke_particles`` 节点。 我们还将 "
"``emit`` 设置为 ``false`` 以确保粒子在炮塔断裂之前不会发射。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:824
msgid ""
"Finally, we set the turret's health to ``MAX_TURRET_HEALTH`` so it starts at "
"full health."
msgstr ""
"最后，我们将炮塔的生命值设置为“MAX_TURRET_HEALTH”，以便从完全健康状态开始。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:828
#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:465
msgid "Now let's go through ``_physics_process``."
msgstr "现在让我们来看看`_physics_process``。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:830
#, fuzzy
msgid ""
"Firstly, we check whether the turret is active. If the turret is active, we "
"want to process the firing code."
msgstr ""
"首先，我们检查炮塔是否有效。 如果炮塔处于活动状态，我们希望处理射击代码。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:832
#, fuzzy
msgid ""
"Next, if ``flash_timer`` is greater than zero, meaning the flash meshes are "
"visible, we want to remove delta from ``flash_timer``. If ``flash_timer`` "
"gets to zero or less after we've subtracted ``delta``, we want to hide both "
"of the flash meshes."
msgstr ""
"接下来我们检查 ``flash_timer`` 是否大于零，这意味着flash网格是可见的，我们想"
"从 ``flash_timer`` 中删除delta。 如果在我们减去“delta”之后 ``flash_timer`` 变"
"为零或更小，我们想要隐藏两个闪存网格。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:836
#, fuzzy
msgid ""
"Next, we check whether the turret has a target. If the turret has a target, "
"we make the turret head look at it, adding ``PLAYER_HEIGHT`` so it is not "
"aiming at the player's feet."
msgstr ""
"接下来我们检查炮塔是否有目标。 如果炮塔有目标，我们让炮塔头看它，加"
"上“PLAYER_HEIGHT”，这样它就不会瞄准游戏角色的脚。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:839
#, fuzzy
msgid ""
"We then check whether the turret's health is greater than zero. If it is, we "
"then check whether there is ammo in the turret."
msgstr ""
"然后我们检查炮塔的健康状况是否大于零。 如果是，我们然后检查炮塔中是否有弹药。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:841
#, fuzzy
msgid ""
"If there is, we then check whether ``fire_timer`` is greater than zero. If "
"it is, the turret cannot fire and we need to remove ``delta`` from "
"``fire_timer``. If ``fire_timer`` is less than or equal to zero, the turret "
"can fire a bullet, so we call the ``fire_bullet`` function."
msgstr ""
"如果炮塔中有弹药，我们会检查 ``fire_timer`` 是否大于零。 如果 ``fire_timer`` "
"大于零，炮塔就无法射击，我们需要从 ``fire_timer`` 中删除 ``delta`` 。 如果 "
"``fire_timer`` 等于或小于零，炮塔可以发射子弹，所以我们称之为 "
"``fire_bullet`` 函数。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:844
#, fuzzy
msgid ""
"If there isn't any ammo in the turret, we check whether "
"``ammo_reload_timer`` is greater than zero. If it is, we subtract ``delta`` "
"from ``ammo_reload_timer``. If ``ammo_reload_timer`` is less than or equal "
"to zero, we set ``ammo_in_turret`` to ``AMMO_IN_FULL_TURRET`` because the "
"turret has waited long enough to refill its ammo."
msgstr ""
"如果炮塔中没有任何弹药，我们会检查 ``ammo_reload_timer`` 是否大于零。 如果 "
"``ammo_reload_timer`` 大于零，我们从 ``ammo_reload_timer`` 中减去 "
"``delta`` 。 如果 ``ammo_reload_timer`` 等于或小于零，我们将 "
"``ammo_in_turret`` 设置为 ``AMMO_IN_FULL_TURRET`` ，因为炮塔已等待足够长的时"
"间来重新填充弹药。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:848
#, fuzzy
msgid ""
"Next, we check whether the turret's health is less than or equal to ``0`` "
"outside of whether it is active or not. If the turret's health is zero or "
"less, we then check whether ``destroyed_timer`` is greater than zero. If it "
"is, we subtract ``delta`` from ``destroyed_timer``."
msgstr ""
"接下来我们检查炮塔的健康状况是否小于或等于“0”，除了它是否有效。 如果炮塔的健"
"康状况为零或更低，我们会检查 ``destroyed_timer`` 是否大于零。 如果被破坏的计"
"时器大于零，我们从 ``destroyed_timer`` 中减去 ``delta`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:851
msgid ""
"If ``destroyed_timer`` is less than or equal to zero, we set "
"``turret_health`` to ``MAX_TURRET_HEALTH`` and stop emitting smoke particles "
"by setting ``smoke_particles.emitting`` to ``false``."
msgstr ""
"如果 ``destroyed_timer`` 小于或等于零，我们将 ``turret_health`` 设置为 "
"``MAX_TURRET_HEALTH`` 并通过将 ``smoke_particles.emitting`` 设置为 ``false`` "
"来停止冒烟。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:856
msgid "Next let's go through ``fire_bullet``."
msgstr "接下来让我们来看看 ``fire_bullet`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:858
#, fuzzy
msgid "Firstly, we check whether the turret is using a raycast."
msgstr "首先，我们检查炮塔是否正在使用光线投射。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:860
#, fuzzy
msgid ""
"The code for using a raycast is almost entirely the same as the code in the "
"rifle from :ref:`doc_fps_tutorial_part_two`, so I'm only going to go over it "
"briefly."
msgstr ""
"使用光线投射的代码几乎完全与步枪中的代码相同 :ref:"
"`doc_fps_tutorial_part_two`，所以我只是简单地介绍它。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:863
#, fuzzy
msgid ""
"We first make the raycast look at the target, ensuring the raycast will hit "
"the target if nothing is in the way. We then force the raycast to update so "
"we get a frame perfect collision check. We then check whether the raycast "
"has collided with anything. If it has, we then check whether the collided "
"body has the ``bullet_hit`` method. If it does, we call it and pass in the "
"damage a single raycast bullet does along with the raycast's transform. We "
"then subtract ``1`` from ``ammo_in_turret``."
msgstr ""
"我们首先让光线投射看目标，确保如果没有任何障碍，光线投射将击中目标。 然后，我"
"们强制更新光线投射，以便我们进行帧完美碰撞检查。 然后我们检查光线投射是否与任"
"何东西相撞。 如果光线投射与某些事物发生碰撞，我们会检查碰撞体是否具"
"有“bullet_hit”功能。 如果确实如此，我们称之为并传递一个光线投射子弹与光线投射"
"变换一起造成的伤害。 然后我们从 ``ammo_in_turret`` 中删除 ``1`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:868
msgid ""
"If the turret is not using a raycast, we spawn a bullet object instead. This "
"code is almost entirely the same as the code in the pistol from :ref:"
"`doc_fps_tutorial_part_two`, so like with the raycast code, I'm only going "
"to go over it briefly."
msgstr ""
"如果炮塔没有使用光线投射，我们会生成一个子弹对象。 这段代码几乎完全与手枪中的"
"代码相同 :ref:`doc_fps_tutorial_part_two`，所以与光线播放代码一样，我只是简单"
"地介绍一下。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:871
#, fuzzy
msgid ""
"We first make a bullet clone and assign it to ``clone``. We then add that as "
"a child of the root node. We set the bullet's global transform to the barrel "
"end, scale it up since it's too small, and set its damage and speed using "
"the turret's constant class variables. We then subtract ``1`` from "
"``ammo_in_turret``."
msgstr ""
"我们首先制作一个子弹克隆并将其分配给 ``clone`` 。 然后我们将其添加为根节点的"
"子节点。 我们将子弹的全局变换设置为桶端，由于它太小而将其放大，并使用炮塔的常"
"量类变量设置它的伤害和速度。 然后我们从 ``ammo_in_turret`` 中删除 ``1`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:875
#, fuzzy
msgid ""
"Then, regardless of which bullet method we used, we make both of the muzzle "
"flash meshes visible. We set ``flash_timer`` and ``fire_timer`` to "
"``FLASH_TIME`` and ``FIRE_TIME``, respectively. We then check whether the "
"turret has used the last bullet in its ammo. If it has, we set "
"``ammo_reload_timer`` to ``AMMO_RELOAD_TIME`` so the turret reloads."
msgstr ""
"然后，无论我们使用哪种子弹方法，我们都可以看到两个枪口闪光网格。 我们将 "
"``flash_timer`` 和 ``fire_timer`` 分别设置为 ``FLASH_TIME`` 和 "
"``FIRE_TIME`` 。 然后我们检查炮塔是否使用了弹药中的最后一颗子弹。 如果炮塔使"
"用了最后一个子弹，我们将 ``ammo_reload_timer`` 设置为 ``AMMO_RELOAD_TIME`` ，"
"以便炮塔重新加载。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:881
msgid ""
"Let's look at ``body_entered_vision`` next, and thankfully it is rather "
"short."
msgstr "让我们看看接下来的 ``body_entered_vision`` ，谢天谢地，它很短。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:883
#, fuzzy
msgid ""
"We first check whether the turret currently has a target by checking if "
"``current_target`` is equal to ``null``. If the turret does not have a "
"target, we then check whether the body that has just entered the vision :ref:"
"`Area <class_Area>` is a :ref:`KinematicBody <class_KinematicBody>`."
msgstr ""
"我们首先通过检查 ``current_target`` 是否等于 ``null`` 来检查炮塔当前是否有目"
"标。 如果炮塔没有目标，我们检查刚刚进入视觉的物体 :ref:`Area <class_Area>` "
"是 :ref:`KinematicBody <class_KinematicBody>"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:886
#, fuzzy
msgid ""
"We're assuming the turret should only fire at :ref:`KinematicBody "
"<class_KinematicBody>` nodes since that is what the player is using."
msgstr ""
"我们假设炮塔只应在以下地方开火 :ref:`KinematicBody <class_KinematicBody>` 节"
"点，因为那是游戏角色正在使用的。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:888
msgid ""
"If the body that just entered the vision :ref:`Area <class_Area>` is a :ref:"
"`KinematicBody <class_KinematicBody>`, we set ``current_target`` to the "
"body, and set ``is_active`` to ``true``."
msgstr ""
"如果刚进入视觉的主体 :ref:`Area <class_Area>` 是 :ref:`KinematicBody "
"<class_KinematicBody>`，我们将 ``current_target`` 设置为body，并将 "
"``is_active`` 设置为 ``true`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:893
msgid "Now let's look at ``body_exited_vision``."
msgstr "现在让我们来看看 ``body_exited_vision`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:895
#, fuzzy
msgid ""
"Firstly, we check whether the turret has a target. If it does, we then check "
"whether the body that has just left the turret's vision :ref:`Area "
"<class_Area>` is the turret's target."
msgstr ""
"首先，我们检查炮塔是否有目标。 如果炮塔有目标，我们检查刚刚离开炮塔视线的物"
"体 :ref:`Area <class_Area>` 是炮塔的目标。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:898
#, fuzzy
msgid ""
"If the body that has just left the vision :ref:`Area <class_Area>` is the "
"turret's current target, we set ``current_target`` to ``null``, set "
"``is_active`` to ``false``, and reset all the variables related to firing "
"the turret since the turret no longer has a target to fire at."
msgstr ""
"如果刚刚离开视觉的物体 :ref:`Area <class_Area>` 是炮塔的当前目标，我们将 "
"``current_target`` 设置为 ``null`` ，将 ``is_active`` 设置为 ``false`` ， 并"
"重置所有与发射炮塔有关的变量，因为炮塔不再有射击目标。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:905
#, fuzzy
msgid ""
"We first subtract however much damage the bullet causes from the turret's "
"health."
msgstr "我们首先从炮塔的健康状况中移除子弹造成的大量伤害。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:907
#, fuzzy
msgid ""
"Then, we check whether the turret has been destroyed (health being zero or "
"less). If the turret is destroyed, we start emitting the smoke particles and "
"set ``destroyed_timer`` to ``DESTROYED_TIME`` so the turret has to wait "
"before being repaired."
msgstr ""
"然后我们检查炮塔是否已被摧毁(健康状况为零或更少)。 如果炮塔被摧毁，我们开始冒"
"烟雾颗粒，并将“destroyed_timer”设置为“DESTROYED_TIME”，因此炮塔必须等待才能修"
"复。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:912
#, fuzzy
msgid ""
"Whew, with all of that done and coded, we only have one last thing to do "
"before the turret is ready for use. Open up ``Turret.tscn`` if it's not "
"already open and select one of the :ref:`StaticBody <class_StaticBody>` "
"nodes from either ``Base`` or ``Head``. Create a new script called "
"``TurretBodies.gd`` and attach it to whichever :ref:`StaticBody "
"<class_StaticBody>` you have selected."
msgstr ""
"Phew，完成所有这些并编码后，我们在炮塔准备好使用之前只有最后一件事要做。 如果"
"它还没有打开，打开 ``Turret.tscn`` 并从 ``Base`` 或 ``Head`` 中选择一个 :ref:"
"`StaticBody <class_StaticBody>` 节点。 创建一个名为 ``TurretBodies.gd`` 的新"
"脚本，并将其附加到以下任何一个 :ref:`StaticBody <class_StaticBody>` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:916
msgid "Add the following code to ``TurretBodies.gd``:"
msgstr "将以下代码添加到``TurretBodies.gd``:"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:931
#, fuzzy
msgid ""
"All this code does is call ``bullet_hit`` on whatever node to which "
"``path_to_turret_root`` leads. Go back to the editor and assign the :ref:"
"`NodePath <class_NodePath>` to the ``Turret`` node."
msgstr ""
"所有这些代码都在 ``path_to_turret_root`` 导致的节点上调用 ``bullet_hit`` 。 "
"返回编辑器并将 :ref:`NodePath <class_NodePath>` 分配给 ``Turret`` 节点。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:934
msgid ""
"Now select the other :ref:`StaticBody <class_StaticBody>` node (either in "
"``Body`` or ``Head``) and assign ``TurretBodies.gd`` script to it. Once the "
"script is attached, assign again the :ref:`NodePath <class_NodePath>` to the "
"``Turret`` node."
msgstr ""
"现在选择另一个 :ref:`StaticBody <class_StaticBody>` 节点(在 ``Body`` 或 "
"``Head`` 中)并为其指定 ``TurretBodies.gd`` 脚本。 附加脚本后，再次将 :ref:"
"`NodePath <class_NodePath>` 分配给 ``Turret`` 节点。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:939
#, fuzzy
msgid ""
"The last thing we need to do is add a way for the player to be hurt. Since "
"all the bullets use the ``bullet_hit`` function, we need to add that "
"function to the player."
msgstr ""
"我们需要做的最后一件事是为游戏角色增添一种伤害方式。 由于所有子弹都使用 "
"``bullet_hit`` 函数，我们需要将该函数添加到游戏角色。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:941
msgid "Open ``Player.gd`` and add the following:"
msgstr "打开 ``Player.gd`` 并添加以下内容:"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:948
msgid ""
"With all that done, you should have fully operational turrets! Go place a "
"few in one/both/all of the scenes and give them a try!"
msgstr ""
"完成所有这些后，您应该拥有完全可操作的炮塔！ 在一个/两个/所有场景中进行几次尝"
"试！"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:955
msgid ""
"Now you can pick up :ref:`RigidBody <class_RigidBody>` nodes and throw "
"grenades. We now also have turrets to fire at the player."
msgstr ""
"现在您可以拿起 :ref:`RigidBody <class_RigidBody>` 节点并投掷手榴弹。 我们现在"
"也有炮塔射击游戏角色。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:957
msgid ""
"In :ref:`doc_fps_tutorial_part_six`, we're going to add a main menu and a "
"pause menu, add a respawn system for the player, and change/move the sound "
"system so we can use it from any script."
msgstr ""
"在 :ref:`doc_fps_tutorial_part_six`中，我们将添加一个主菜单和一个暂停菜单，为"
"游戏角色添加重新生成的系统，以及更改/移动声音系统，以便我们可以从任何脚本中使"
"用它。"

#: ../../docs/tutorials/3d/fps_tutorial/part_five.rst:962
msgid ""
"You can download the finished project for this part here: :download:"
"`Godot_FPS_Part_5.zip <files/Godot_FPS_Part_5.zip>`"
msgstr ""
"您可以在这里下载这个部分的完成项目: :download:`Godot_FPS_Part_5.zip <files / "
"Godot_FPS_Part_5.zip>`"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:4
msgid "Part 6"
msgstr "第6部分"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:9
#, fuzzy
msgid ""
"In this part, we're going to add a main menu and pause menu, add a respawn "
"system for the player, and change/move the sound system so we can use it "
"from any script."
msgstr ""
"在这部分中，我们将添加一个主菜单和暂停菜单，为游戏角色添加重新生成的系统，以"
"及更改/移动声音系统，以便我们可以从任何脚本中使用它。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:12
#, fuzzy
msgid ""
"This is the last part of the FPS tutorial; by the end of this, you will have "
"a solid base to build amazing FPS games with Godot!"
msgstr ""
"这是FPS教程的最后一部分，到最后您将有一个坚实的基础，用Godot建立惊人的FPS游"
"戏！"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:16
#, fuzzy
msgid ""
"You are assumed to have finished :ref:`doc_fps_tutorial_part_five` before "
"moving on to this part of the tutorial. The finished project from :ref:"
"`doc_fps_tutorial_part_five` will be the starting project for part 6"
msgstr ""
"在继续本教程的这一部分之前，假设您已完成 :ref:`doc_fps_tutorial_part_five`。 "
"完成的项目来自 :ref:`doc_fps_tutorial_part_four`将成为第6部分的起始项目"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:22
msgid "Adding the main menu"
msgstr "添加主菜单"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:24
#, fuzzy
msgid ""
"Firstly, open up ``Main_Menu.tscn`` and take a look at how the scene is set "
"up."
msgstr "首先，打开 ``Main_Menu.tscn`` 并查看场景的设置方式。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:26
msgid ""
"The main menu is broken up into three different panels, each representing a "
"different 'screen' of our main menu."
msgstr "主菜单分为三个不同的面板，每个面板代表主菜单的不同“屏幕”。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:29
msgid ""
"The ``Background_Animation`` node is just so the background of the menu is a "
"bit more interesting than a solid color. It's a camera looking around the "
"skybox, nothing fancy."
msgstr ""
"``Background_Animation``节点就是这样，菜单的背景比纯色更有趣。 这是一个环顾天"
"空盒的相机，没什么特别的。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:32
#, fuzzy
msgid ""
"Feel free to expand all the nodes and see how they're set up. Remember to "
"keep only ``Start_Menu`` visible when you're done, as that's the screen we "
"want to show first when we enter the main menu."
msgstr ""
"随意扩展所有节点，看看他们如何设置。 记得在完成后只能看到 ``Start_Menu`` ，因"
"为这是我们进入主菜单时想要首先显示的屏幕。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:35
msgid ""
"Select ``Main_Menu`` (the root node) and create a new script called "
"``Main_Menu.gd``. Add the following:"
msgstr ""
"选择 ``Main_Menu`` (根节点)并创建一个名为 ``Main_Menu.gd`` 的新脚本。 添加以"
"下内容:"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:122
msgid ""
"Most of the code here relates to making UIs, which is outside of the purpose "
"of this tutorial series. **We're only going to look at the UI related code "
"briefly.**"
msgstr ""
"这里的大多数代码都与制作UI有关，这超出了本教程系列的目的。 **我们只是简要介绍"
"一下与UI相关的代码。**"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:125
msgid ""
"See :ref:`doc_ui_main_menu` and the tutorials following for better ways to "
"make GUIs and UIs!"
msgstr "请参阅 :ref:`doc_ui_main_menu`以及以下教程，以获得更好的GUI和UI方法！"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:127
msgid "Let's look at the class variables first."
msgstr "我们先来看看类变量。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:129
msgid ""
"``start_menu``: A variable to hold the ``Start_Menu`` :ref:`Panel "
"<class_Panel>`."
msgstr ""
"``start_menu``:一个用于保存``Start_Menu``的变量 :ref:`Panel <class_Panel>`。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:130
msgid ""
"``level_select_menu``: A variable to hold the ``Level_Select_Menu`` :ref:"
"`Panel <class_Panel>`."
msgstr ""
"``level_select_menu``:一个用于保存``Level_Select_Menu``的变量 :ref:`Panel "
"<class_Panel>`。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:131
msgid ""
"``options_menu``: A variable to hold the ``Options_Menu`` :ref:`Panel "
"<class_Panel>`."
msgstr ""
"``options_menu``:一个变量来保存``Options_Menu`` :ref:`Panel <class_Panel>`。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:132
msgid ""
"``testing_area_scene``: The path to the ``Testing_Area.tscn`` file, so we "
"can change to it from this scene."
msgstr ""
"``testing_area_scene``:``Testing_Area.tscn``文件的路径，所以我们可以从这个场"
"景改变它。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:133
msgid ""
"``space_level_scene``: The path to the ``Space_Level.tscn`` file, so we can "
"change to it from this scene."
msgstr ""
"``space_level_scene``:``Space_Level.tscn``文件的路径，所以我们可以从这个场景"
"改变它。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:134
msgid ""
"``ruins_level_scene``: The path to the ``Ruins_Level.tscn`` file, so we can "
"change to it from this scene."
msgstr ""
"``ruins_level_scene``:``Ruins_Level.tscn``文件的路径，所以我们可以从这个场景"
"改变它。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:136
msgid ""
"You'll have to set the paths to the correct files in the editor before "
"testing this script! Otherwise it will not work!"
msgstr ""
"在测试此脚本之前，您必须在编辑器中设置正确文件的路径！ 否则它将无法正常工作！"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:140
msgid "Now let's go over ``_ready``"
msgstr "现在让我们回顾一下 ``_ready``"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:142
#, fuzzy
msgid ""
"Firstly, we get all the :ref:`Panel <class_Panel>` nodes and assign them to "
"the proper variables."
msgstr ""
"首先，我们得到所有 :ref:`Panel <class_Panel>` 节点并将它们分配给适当的变量。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:144
#, fuzzy
msgid ""
"Next, we connect all the buttons ``pressed`` signals to their respective "
"``[panel_name_here]_button_pressed`` functions."
msgstr ""
"接下来，我们将所有按钮 ``pressed`` 信号连接到各自的``[panel_name_here] "
"_button_pressed``函数。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:146
#, fuzzy
msgid ""
"We then set the mouse mode to ``MOUSE_MODE_VISIBLE`` to ensure whenever the "
"player returns to this scene, the mouse will be visible."
msgstr ""
"然后我们将鼠标模式设置为“MOUSE_MODE_VISIBLE”以确保每当游戏角色返回此场景时鼠"
"标将可见。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:148
msgid ""
"Then we get a singleton, called ``Globals``. We then set the values for the :"
"ref:`HSlider <class_HSlider>` nodes so their values line up with the mouse "
"and joypad sensitivity in the singleton."
msgstr ""
"然后我们得到一个叫做“Globals”的单例人士。 然后我们设置 :ref:`HSlider "
"<class_HSlider>` 节点的值，使它们的值与单例中的鼠标和游戏手柄灵敏度对齐。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:151
msgid ""
"We have not made the ``Globals`` singleton yet, so don't worry! We're going "
"to make it soon!"
msgstr "我们还没有制作 ``Globals`` 单例，所以不用担心！ 我们很快就会成功！"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:155
#, fuzzy
msgid ""
"In ``start_menu_button_pressed``, we check to see which button is pressed."
msgstr "在 ``start_menu_pressed`` 中，我们检查按下了哪个按钮。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:157
msgid ""
"Based on the button pressed, we either change the currently visible panel, "
"quit the application, or open the Godot website."
msgstr ""
"根据按下的按钮，我们要么更改当前可见的面板，退出应用程序，要么打开Godot网站。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:161
msgid ""
"In ``level_select_menu_button_pressed``, we check to see which button is "
"pressed."
msgstr "在 ``level_select_menu_button_pressed`` 中，我们检查按下了哪个按钮。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:163
#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:175
msgid ""
"If the ``back`` button has been pressed, we change the currently visible "
"panels to return to the main menu."
msgstr "如果按下“后退”按钮，我们会更改当前可见的面板以返回主菜单。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:165
#, fuzzy
msgid ""
"If one of the scene changing buttons is pressed, we fist call "
"``set_mouse_and_joypad_sensitivity`` so the singleton (``Globals.gd``) has "
"the values from the :ref:`HSlider <class_HSlider>` nodes. Then, we tell the "
"singleton to change nodes using its ``load_new_scene`` function, passing in "
"the file path of the scene the player has selected."
msgstr ""
"如果按下一个场景改变按钮，我们首先调用 "
"``set_mouse_and_joypad_sensitivity`` ，因此单例(``Globals.gd``)具有来自 :ref:"
"`HSlider <class_HSlider>` 节点的值。 然后我们告诉单例使用它的 "
"``load_new_scene`` 函数来改变节点，传入游戏角色选择的场景的文件路径。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:169
msgid "Don't worry about the singleton, we'll get there soon!"
msgstr "不要担心单例人士，我们很快就会到达那里！"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:173
msgid ""
"In ``options_menu_button_pressed``, we check to see which button is pressed."
msgstr "在 ``options_menu_button_pressed`` 中，我们检查按下了哪个按钮。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:177
#, fuzzy
msgid ""
"If the ``fullscreen`` button is pressed, we toggle the :ref:`OS "
"<class_OS>`'s full screen mode by setting it to the flipped version of its "
"current value."
msgstr ""
"如果按下 ``fullscreen`` 按钮，我们通过将其设置为当前值的翻转版本来切换 :ref:"
"`OS <class_OS>的全屏模式。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:179
#, fuzzy
msgid ""
"If the ``vsync`` button is pressed, we set the :ref:`OS <class_OS>`'s Vsync "
"based on the state of the Vsync check button."
msgstr ""
"如果按下 ``vsync`` 按钮，我们根据Vsync检查按钮的状态设置 :ref:`OS <class_OS>"
"的Vsync。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:183
msgid "Finally, lets take a look at ``set_mouse_and_joypad_sensitivity``."
msgstr "最后，让我们来看看 ``set_mouse_and_joypad_sensitivity`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:185
#, fuzzy
msgid ""
"Firstly, we get the ``Globals`` singleton and assign it to a local variable."
msgstr "首先，我们得到 ``Globals`` 单例并将其分配给局部变量。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:187
msgid ""
"We then set the ``mouse_sensitivity`` and ``joypad_sensitivity`` variables "
"to the values in their respective :ref:`HSlider <class_HSlider>` node "
"counterparts."
msgstr ""
"然后我们将 ``mouse_sensitivity`` 和``joypad_sensitivity``变量设置为它们各自的"
"值 :ref:`HSlider <class_HSlider>` 节点对应物。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:190
msgid "Making the ``Globals`` singleton"
msgstr "使 ``Globals`` 单例"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:192
#, fuzzy
msgid ""
"Now, for all this to work, we need to create the ``Globals`` singleton. Make "
"a new script in the ``Script`` tab and call it ``Globals.gd``."
msgstr ""
"现在，为了全部工作，我们需要创建 ``Globals`` 单例。 在 ``Script`` 选项卡中创"
"建一个新脚本，并将其命名为 ``Globals.gd`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:194
msgid ""
"To make the ``Globals`` singleton, go to the ``Script`` tab in the editor, "
"then click ``New`` and a ``Create Script`` box will appear, leave everything "
"unchanged except for the ``Path`` where you need to insert the script's name "
"``Globals.gd``."
msgstr ""
"要制作 ``Globals`` 单例，请转到编辑器中的 ``Script`` 选项卡，然后单击 "
"``New`` 并出现一个``Create Script``框，除了`` 路径``您需要插入脚本名称"
"``Globals.gd``。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:196
msgid "Add the following to ``Globals.gd``."
msgstr "将以下内容添加到 ``Globals.gd`` 中。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:211
#, fuzzy
msgid ""
"As you can see, it's quite small and simple. As this part progresses, we "
"will keep adding more complex logic to ``Globals.gd``, but for now, all it "
"is doing is holding two class variables, and abstract defining how we change "
"scenes."
msgstr ""
"如您所见，它非常小而且简单。 随着这部分的进展，我们将不断向 ``Globals.gd`` 添"
"加更复杂的逻辑，但是现在它所做的只是保存两个类变量，并且抽象定义我们如何改变"
"场景。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:214
msgid ""
"``mouse_sensitivity``: The current sensitivity for our mouse, so we can load "
"it in ``Player.gd``."
msgstr ""
"``mouse_sensitivity``:我们鼠标的当前灵敏度，所以我们可以在 ``Player.gd`` 中加"
"载它。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:215
msgid ""
"``joypad_sensitivity``: The current sensitivity for our joypad, so we can "
"load it in ``Player.gd``."
msgstr ""
"``joypad_sensitivity``:我们游戏手柄的当前灵敏度，所以我们可以在 ``Player."
"gd`` 中加载它。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:217
#, fuzzy
msgid ""
"Right now, all we will be using ``Globals.gd`` for is a way to carry "
"variables across scenes. Because the sensitivities of our mouse and joypad "
"are stored in ``Globals.gd``, any changes we make in one scene (like in "
"``Options_Menu``) will affect the sensitivity for the player."
msgstr ""
"现在我们所有人都使用 ``Globals.gd`` 是一种跨场景传递变量的方法。 因为我们的鼠"
"标和游戏手柄的灵敏度存储在 ``Globals.gd`` 中，我们在一个场景中所做的任何更改"
"(如在`'Options_Menu``中)都会影响游戏角色的灵敏度。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:220
msgid ""
"All we're doing in ``load_new_scene`` is calling :ref:`SceneTree "
"<class_SceneTree>`'s ``change_scene`` function, passing in the scene path "
"given in ``load_new_scene``."
msgstr ""
"我们在 ``load_new_scene`` 中所做的就是调用 :ref:`SceneTree "
"<class_SceneTree>` 的 ``change_scene`` 函数，传入 ``load_new_scene`` 中给出的"
"场景路径。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:222
#, fuzzy
msgid ""
"That's all the code needed for ``Globals.gd`` right now! Before we can test "
"the main menu, we first need to set ``Globals.gd`` as an autoload script."
msgstr ""
"这就是现在 ``Globals.gd`` 所需的全部代码！ 在我们测试主菜单之前，我们首先需要"
"将 ``Globals.gd`` 设置为自动加载脚本。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:224
msgid "Open up the ``Project Settings`` and click the ``AutoLoad`` tab."
msgstr "打开``Project Settings``并单击 ``AutoLoad`` 选项卡。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:228
msgid ""
"Then select the path to ``Globals.gd`` in the ``Path`` field by clicking the "
"button (``..``) beside it. Make sure the name in the ``Node Name`` field is "
"``Globals``. If you have everything like in the picture above, then press "
"``Add``!"
msgstr ""
"然后通过单击旁边的按钮(`````)选择``Path``字段中``Globals.gd``的路径。 确保"
"``Node Name``字段中的名称是``Globals``。 如果您拥有上图所示的所有内容，请"
"按“添加”！"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:231
msgid ""
"This will make ``Globals.gd`` a singleton/autoload script, which will allow "
"us to access it from any script, in any scene."
msgstr ""
"这将使 ``Globals.gd`` 成为单例/自动加载脚本，这将允许我们从任何场景中的任何脚"
"本访问它。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:233
msgid ""
"For more information on singleton/autoload scripts, see :ref:"
"`doc_singletons_autoload`."
msgstr ""
"有关单例/自动加载脚本的更多信息，请参阅 :ref:`doc_singletons_autoload`。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:235
msgid ""
"Now that ``Globals.gd`` is a singleton/autoload script, you can test the "
"main menu!"
msgstr "现在 ``Globals.gd`` 是一个单例/自动加载脚本，您可以测试主菜单！"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:237
msgid ""
"You may want to change the main scene from ``Testing_Area.tscn`` to "
"``Main_Menu.tscn`` so when we export the game the player will start at the "
"main menu. You can do this through the ``Project Settings``, under the "
"``General`` tab. Then in the ``Application`` category, click the ``Run`` "
"subcategory and you can change the main scene by changing the value in "
"``Main Scene``."
msgstr ""
"您可能希望将主场景从 ``Testing_Area.tscn`` 更改为 ``Main_Menu.tscn`` ，因此当"
"我们导出游戏时，游戏角色将从主菜单开始。 您可以通过 ``General`` 选项卡下的"
"``Project Settings``来完成此操作。 然后在 ``Application`` 类别中，单击 "
"``Run`` 子类别，您可以通过更改``Main Scene``中的值来更改主场景。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:241
msgid ""
"You'll have to set the paths to the correct files in ``Main_Menu`` in the "
"editor before testing the main menu! Otherwise you will not be able to "
"change scenes from the level select menu/screen."
msgstr ""
"在测试主菜单之前，您必须在编辑器中的 ``Main_Menu`` 中设置正确文件的路径！ 否"
"则，您将无法从级别选择菜单/屏幕更改场景。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:245
msgid "Adding the debug menu"
msgstr "添加调试菜单"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:247
#, fuzzy
msgid ""
"Now, let's add a simple debugging scene so we can track things like FPS "
"(Frames Per Second) in-game. Open up ``Debug_Display.tscn``."
msgstr ""
"现在让我们添加一个简单的调试场景，以便我们可以跟踪游戏中的FPS(每秒帧数)等内"
"容。 打开 ``Debug_Display.tscn`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:249
#, fuzzy
msgid ""
"You can see it's a :ref:`Panel <class_Panel>` positioned in the top right "
"corner of the screen. It has three :ref:`Labels <class_Label>`, one for "
"displaying the FPS at which the game is running, one for showing on what OS "
"the game is running, and a label for showing with which Godot version the "
"game is running."
msgstr ""
"您可以看到它是 :ref:`Panel <class_Panel>` 位于屏幕的右上角。 它有三个 :ref:"
"`Labels <class_Label>`，一个用于显示游戏运行的FPS，一个用于显示游戏运行的操作"
"系统，以及用于显示游戏运行的Godot版本的标签。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:252
msgid ""
"Let's add the code needed to fill these :ref:`Labels <class_Label>`. Select "
"``Debug_Display`` and create a new script called ``Debug_Display.gd``. Add "
"the following:"
msgstr ""
"让我们添加填充这些代码所需的代码 :ref:`Labels <class_Label>`。 选择 "
"``Debug_Display`` 并创建一个名为 ``Debug_Display.gd`` 的新脚本。 添加以下内"
"容:"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:265
#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1343
msgid "Let's go over what this script does."
msgstr "我们来看看这个脚本的功能。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:269
#, fuzzy
msgid ""
"In ``_ready``, we set the ``OS_Label``'s text to the name provided by :ref:"
"`OS <class_OS>` using the ``get_name`` function. This will return the name "
"of the OS (or Operating System) for which Godot was compiled. For example, "
"when you are running Windows, it will return ``Windows``, while when you are "
"running Linux, it will return ``X11``."
msgstr ""
"在 ``_ready`` 中，我们使用 ``get_name`` 函数将 ``OS_Label`` 的文本设置为 :"
"ref:`OS <class_OS>` 提供的名称。 这将返回Godot编译的OS(或操作系统)的名称。 例"
"如，当您运行Windows时，它将返回“Windows”，而当您运行Linux时，它将返回“X11”。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:273
#, fuzzy
msgid ""
"Then, we set the ``Engine_Label``'s text to the version info provided by "
"``Engine.get_version_info``. ``Engine.get_version_info`` returns a "
"dictionary full of useful information about the version of Godot which is "
"currently running. We only care about the string version, for this label at "
"least, so we get the string and assign that as the ``text`` in "
"``Engine_Label``. See :ref:`Engine <class_Engine>` for more information on "
"the values ``get_version_info`` returns."
msgstr ""
"然后我们将 ``Engine_Label`` 的文本设置为 ``Engine.get_version_info`` 提供的版"
"本信息。 ``Engine.get_version_info``返回一个字典，其中包含有关Godot当前运行版"
"本的有用信息。 我们只关心字符串版本，至少对于这个标签，所以我们得到字符串并将"
"其指定为 ``Engine_Label`` 中的 ``text`` 。 有关值 ``get_version_info`` 返回的"
"更多信息，请参阅 :ref:`Engine <class_Engine>` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:277
#, fuzzy
msgid ""
"In ``_process``, we set the text of the ``FPS_Label`` to ``Engine."
"get_frames_per_second``, but because ``get_frames_per_second`` returns an "
"integer, we have to cast it to a string using ``str`` before we can add it "
"to the :ref:`Label <class_Label>`."
msgstr ""
"在 ``_process`` 中，我们将 ``FPS_Label`` 的文本设置为 ``Engine."
"get_frames_per_second`` ，但是因为 ``get_frames_per_second`` 返回一个整数，我"
"们必须使用``str`将它强制转换为字符串。 `之前我们可以将它添加到 :ref:`Label "
"<class_Label>`。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:282
msgid ""
"Now let's jump back to ``Main_Menu.gd`` and change the following in "
"``options_menu_button_pressed``:"
msgstr ""
"现在让我们跳回到 ``Main_Menu.gd`` 并在 ``options_menu_button_pressed`` 中更改"
"以下内容:"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:289
msgid "to this instead:"
msgstr "改为:"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:296
#, fuzzy
msgid ""
"This will call a new function called ``set_debug_display`` in our singleton, "
"so let's add that next!"
msgstr ""
"这将在我们的单例中调用一个名为 ``set_debug_display`` 的新函数，所以让我们接下"
"来添加它！"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:300
#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:391
msgid "Open up ``Globals.gd`` and add the following class variables:"
msgstr "打开 ``Globals.gd`` 并添加以下类变量:"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:314
msgid ""
"``canvas_layer``: A canvas layer so the GUI/UI created in ``Globals.gd`` is "
"always drawn on top."
msgstr ""
"``canvas_layer``:一个画布层，因此在 ``Globals.gd`` 中创建的GUI / UI总是在顶部"
"绘制。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:315
msgid "``DEBUG_DISPLAY``: The debug display scene we worked on earlier."
msgstr "``DEBUG_DISPLAY``:我们之前处理过的调试显示场景。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:316
msgid ""
"``debug_display``: A variable to hold the debug display when/if there is one."
msgstr "``debug_display``:一个变量，用于在/如果存在时保持调试显示。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:318
msgid ""
"Now that we have the class variables defined, we need to add a few lines to "
"``_ready`` so ``Globals.gd`` will have a canvas layer to use (which we will "
"store in ``canvas_layer``). Change ``_ready`` to the following:"
msgstr ""
"现在我们已经定义了类变量，我们需要在 ``_ready`` 中添加几行，以便 ``Globals."
"gd`` 将使用一个画布层(我们将存储在 ``canvas_layer`` 中)。 将 ``_ready`` 更改"
"为以下内容:"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:327
#, fuzzy
msgid ""
"Now in ``_ready``, we create a new canvas layer, assign it to "
"``canvas_layer`` and add it as a child. Because ``Globals.gd`` is an "
"autoload/singleton, Godot will make a :ref:`Node <class_Node>` when the game "
"is launched, and it will have ``Globals.gd`` attached to it. Since Godot "
"makes a :ref:`Node <class_Node>`, we can treat ``Globals.gd`` like any other "
"node with regard to adding/removing children nodes."
msgstr ""
"现在在 ``_ready`` 中，我们创建一个新的画布层，将其分配给 ``canvas_layer`` 并"
"将其添加为子画面。 因为 ``Globals.gd`` 是一个自动加载/单例，当游戏启动时，"
"Godot将创建一个 :ref:`Node <class_Node>`，它将附加“Globals.gd”。 由于Godot创"
"建了一个 :ref:`Node <class_Node>`，我们可以将 ``Globals.gd`` 视为添加/删除子"
"节点的任何其他节点。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:331
#, fuzzy
msgid ""
"The reason we're adding a :ref:`CanvasLayer <class_CanvasLayer>` is so all "
"our GUI and UI nodes we instance/spawn in ``Globals.gd`` are always drawn on "
"top of everything else."
msgstr ""
"我们添加一个 :ref:`CanvasLayer <class_CanvasLayer>` 的原因是我们在 ``Globals."
"gd`` 中实例/生成的所有GUI和UI节点总是被绘制在其他所有节点之上。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:334
#, fuzzy
msgid ""
"When adding nodes to a singleton/autoload, you have to be careful not to "
"lose reference to any of the child nodes. This is because nodes will not be "
"freed/destroyed when you change the active scene, meaning you can run into "
"memory problems if you are instancing/spawning lots of nodes and you are not "
"freeing them."
msgstr ""
"将节点添加到单例/自动加载时，必须注意不要丢失对任何子节点的引用。 这是因为当"
"您更改场景时不会释放/销毁节点，这意味着如果您实例化/生成大量节点并且您没有释"
"放它们，则可能会遇到内存问题。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:340
msgid "Now we need to add ``set_debug_display`` to ``Globals.gd``:"
msgstr "现在我们需要将 ``set_debug_display`` 添加到``Globals.gd``:"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:356
msgid ""
"First we check to see if ``Globals.gd`` is trying to turn on the debug "
"display, or turn it off."
msgstr "首先，我们检查 ``Globals.gd`` 是否正在尝试打开调试显示，或者将其关闭。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:358
msgid ""
"If ``Globals.gd`` is turning off the display, we then check to see if "
"``debug_display`` is not equal to ``null``. If ``debug_display`` is not "
"equal to ``null``, then ``Globals.gd`` must have a debug display currently "
"active. If ``Globals.gd`` has a debug display active, we free it using "
"``queue_free`` and then assign ``debug_display`` to ``null``."
msgstr ""
"如果 ``Globals.gd`` 正在关闭显示，我们检查 ``debug_display`` 是否不等于 "
"``null`` 。 如果 ``debug_display`` 不等于 ``null`` ，那么 ``Globals.gd`` 必须"
"有一个当前有效的调试显示。 如果 ``Globals.gd`` 的调试显示处于活动状态，我们使"
"用 ``queue_free`` 释放它，然后将 ``debug_display`` 分配给 ``null`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:361
msgid ""
"If ``Globals.gd`` is turning on the display, we then check to make sure "
"``Globals.gd`` do not already have a debug display active. We do this by "
"making sure ``debug_display`` is equal to ``null``. If ``debug_display`` is "
"``null``, we instance a new ``DEBUG_DISPLAY_SCENE``, and add it as a child "
"of ``canvas_layer``."
msgstr ""
"如果 ``Globals.gd`` 打开显示器，我们检查以确保 ``Globals.gd`` 没有激活调试显"
"示。 我们通过确保 ``debug_display`` 等于 ``null`` 来做到这一点。 如果 "
"``debug_display`` 是``null``，我们实例化一个新的 ``DEBUG_DISPLAY_SCENE`` ，并"
"将其添加为 ``canvas_layer`` 的子节点。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:367
msgid ""
"With that done, we can now toggle the debug display on and off by switching "
"the :ref:`CheckButton <class_CheckButton>` in the ``Options_Menu`` panel. Go "
"give it a try!"
msgstr ""
"完成后，我们现在可以通过在 ``Options_Menu`` 面板中切换 :ref:`CheckButton "
"<class_CheckButton>` 来打开和关闭调试显示。 去尝试吧！"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:369
msgid ""
"Notice how the debug display stays even when you change scenes from the "
"``Main_Menu.tscn`` to another scene (like ``Testing_Area.tscn``). This is "
"the beauty of instancing/spawning nodes in a singleton/autoload and adding "
"them as children to the singleton/autoload. Any of the nodes added as "
"children of the singleton/autoload will stay for as long as the game is "
"running, without any additional work on our part!"
msgstr ""
"请注意，即使将“Main_Menu.tscn`”中的场景更改为另一个场景(如“Testing_Area."
"tscn``)，调试显示仍然保持不变。 这是单例/自动加载中实例化/生成节点的美妙之"
"处，并将它们作为子元素添加到单例/自动加载中。 作为单件/自动加载的子节点添加的"
"任何节点将在游戏运行期间保持不变，而我们没有任何额外的工作！"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:374
msgid "Adding a pause menu"
msgstr "添加暂停菜单"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:376
msgid ""
"Let's add a pause menu so we can return to the main menu when we press the "
"``ui_cancel`` action."
msgstr ""
"让我们添加一个暂停菜单，这样当我们按下 ``ui_cancel`` 动作时我们可以返回主菜"
"单。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:378
msgid "Open up ``Pause_Popup.tscn``."
msgstr "打开 ``Pause_Popup.tscn`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:380
#, fuzzy
msgid ""
"Notice how the root node in ``Pause_Popup`` is a :ref:`WindowDialog "
"<class_WindowDialog>`; :ref:`WindowDialog <class_WindowDialog>` inherits "
"from :ref:`Popup <class_Popup>`, which means :ref:`WindowDialog "
"<class_WindowDialog>` can act like a popup."
msgstr ""
"注意 ``Pause_Popup`` 中的根节点是如何 :ref:`WindowDialog "
"<class_WindowDialog>`。 :ref:`WindowDialog <class_WindowDialog>` 继承自 :ref:"
"`Popup <class_Popup>`，这意味着 :ref:`WindowDialog <class_WindowDialog>` 可以"
"像弹出窗口一样。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:383
#, fuzzy
msgid ""
"Select ``Pause_Popup`` and scroll down all the way till you get to the "
"``Pause`` menu in the inspector. Notice how the pause mode is set to "
"``process`` instead of ``inherit`` like it is normally set by default. This "
"makes it so it will continue to process even when the game is paused, which "
"we need in order to interact with the UI elements."
msgstr ""
"选择 ``Pause_Popup`` 并向下滚动，直到您到达属性面板中的 ``Pause`` 菜单。 注意"
"暂停模式如何设置为 ``process`` 而不是 ``inherit`` ，就像它通常默认设置一样。 "
"这使得它即使在游戏暂停时也会继续处理，这是我们为了与UI元素进行交互所需要的。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:387
#, fuzzy
msgid ""
"Now that we've looked at how ``Pause_Popup.tscn`` is set up, let's write the "
"code to make it work. Normally, we'd attach a script to the root node of the "
"scene, ``Pause_Popup`` in this case, but since we'll need to receive a "
"couple of signals in ``Globals.gd``, we'll write all the code for the popup "
"there."
msgstr ""
"现在我们已经了解了如何设置 ``Pause_Popup.tscn`` ，让我们编写代码使其工作。 通"
"常我们会在这种情况下将脚本附加到场景的根节点，“Pause_Popup”。但是由于我们需要"
"在 ``Globals.gd`` 中接收一些信号，我们将全部写入 弹出窗口的代码。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:399
msgid "``MAIN_MENU_PATH``: The path to the main menu scene."
msgstr "``MAIN_MENU_PATH``:主菜单场景的路径。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:400
msgid "``POPUP_SCENE``: The pop up scene we looked at earlier."
msgstr "``POPUP_SCENE``:我们之前看过的弹出场景。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:401
msgid "``popup``: A variable to hold the pop up scene."
msgstr "``popup``:一个用于保存弹出场景的变量。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:403
msgid ""
"Now we need to add ``_process`` to ``Globals.gd`` so it can respond when the "
"``ui_cancel`` action is pressed. Add the following to ``_process``:"
msgstr ""
"现在我们需要将 ``_process`` 添加到 ``Globals.gd`` 中，这样当按下 "
"``ui_cancel`` 动作时它就会响应。 将以下内容添加到``_process``:"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:428
#, fuzzy
msgid ""
"Firstly, we check to see if the ``ui_cancel`` action is pressed. Then, we "
"check to make sure ``Globals.gd`` does not already have a ``popup`` open by "
"checking to see if ``popup`` is equal to ``null``."
msgstr ""
"首先，我们检查是否按下了 ``ui_cancel`` 动作。 然后我们通过检查 ``popup`` 是否"
"等于 ``null`` 来检查 ``Globals.gd`` 是否还没有打开 ``popup`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:431
#, fuzzy
msgid ""
"If ``Globals.gd`` do not have a pop-up open, we instance ``POPUP_SCENE`` and "
"assign it to ``popup``."
msgstr ""
"如果 ``Globals.gd`` 没有弹出窗口，我们实例 ``POPUP_SCENE`` 并将其分配给 "
"``popup`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:433
msgid ""
"We then get the quit button and assign its ``pressed`` signal to "
"``popup_quit``, which we will be adding shortly."
msgstr ""
"然后我们得到退出按钮并将它的 ``pressed`` 信号分配给 ``popup_quit`` ，我们将很"
"快添加。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:435
#, fuzzy
msgid ""
"Next, we assign both the ``popup_hide`` signal from the :ref:`WindowDialog "
"<class_WindowDialog>` and the ``pressed`` signal from the resume button to "
"``popup_closed``, which we will be adding shortly."
msgstr ""
"接下来，我们将来自 :ref:`WindowDialog <class_WindowDialog>` 的 "
"``popup_hide`` 信号和来自resume按钮的 ``pressed`` 信号分配给 "
"``popup_closed`` ，我们将很快添加。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:438
#, fuzzy
msgid ""
"Then, we add ``popup`` as a child of ``canvas_layer`` so it's drawn on top. "
"We then tell ``popup`` to pop up at the center of the screen using "
"``popup_centered``."
msgstr ""
"然后我们添加 ``popup`` 作为 ``canvas_layer`` 的子节点，所以它被绘制在顶部。 "
"然后我们使用 ``popup_centered`` 告诉 ``popup`` 弹出屏幕中心。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:440
#, fuzzy
msgid ""
"Next, we make sure the mouse mode is ``MOUSE_MODE_VISIBLE`` so the player "
"can interact with the pop-up. If we did not do this, the player would not be "
"able to interact with the pop up in any scene where the mouse mode is "
"``MOUSE_MODE_CAPTURED``."
msgstr ""
"接下来，我们确保鼠标模式为“MOUSE_MODE_VISIBLE”，以便游戏角色可以与弹出窗口进"
"行交互。 如果我们不这样做，游戏角色将无法与鼠标模式为“MOUSE_MODE_CAPTURED”的"
"任何场景中的弹出窗口进行交互。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:443
msgid "Finally, we pause the entire :ref:`SceneTree <class_SceneTree>`."
msgstr "最后，我们暂停整个 :ref:`SceneTree <class_SceneTree>`。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:445
msgid "For more information on pausing in Godot, see :ref:`doc_pausing_games`"
msgstr "有关在Godot中暂停的更多信息，请参阅 :ref:`doc_pausing_games`"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:449
#, fuzzy
msgid ""
"Now, we need to add the functions to which we've connected the signals. "
"Let's add ``popup_closed`` first."
msgstr "现在我们需要添加我们已连接信号的功能。 我们先添加 ``popup_closed`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:451
#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:466
msgid "Add the following to ``Globals.gd``:"
msgstr "将以下内容添加到``Globals.gd``:"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:462
#, fuzzy
msgid ""
"``popup_closed`` will resume the game and destroy the pop-up if there is one."
msgstr "``popup_closed``将恢复游戏并摧毁弹出窗口(如果有的话)。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:464
msgid ""
"``popup_quit`` is similar, but we're also making sure the mouse is visible "
"and changing scenes to the title screen."
msgstr "``popup_quit``类似，但我们也确保鼠标可见并将场景更改为标题屏幕。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:481
#, fuzzy
msgid ""
"``popup_quit`` will resume the game, set the mouse mode to "
"``MOUSE_MODE_VISIBLE`` to ensure the mouse is visible in the main menu, "
"destroy the pop-up if there is one, and change scenes to the main menu."
msgstr ""
"``popup_quit``将恢复游戏，将鼠标模式设置为 ``MOUSE_MODE_VISIBLE`` 以确保鼠标"
"在主菜单中可见，如果有则弹出窗口，并将场景更改为主菜单。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:486
#, fuzzy
msgid ""
"Before we're ready to test the pop-up, we should change one thing in "
"``Player.gd``."
msgstr "在我们准备测试弹出窗口之前，我们应该在 ``Player.gd`` 中改变一件事。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:488
msgid ""
"Open up ``Player.gd`` and in ``process_input``, change the code for "
"capturing/freeing the cursor to the following:"
msgstr ""
"打开 ``Player.gd`` 并在 ``process_input`` 中，将捕获/释放光标的代码更改为以下"
"内容:"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:490
msgid "Instead of:"
msgstr "代替:"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:501
msgid "You will leave only:"
msgstr "您只会离开:"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:509
#, fuzzy
msgid ""
"Now, instead of capturing/freeing the mouse, we check whether the current "
"mouse mode is ``MOUSE_MODE_VISIBLE``. If it is, we set it back to "
"``MOUSE_MODE_CAPTURED``."
msgstr ""
"现在，我们不是捕获/释放鼠标，而是检查当前鼠标模式是否"
"为“MOUSE_MODE_VISIBLE”。 如果是，我们将其设置回 ``MOUSE_MODE_CAPTURED`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:512
#, fuzzy
msgid ""
"Because the pop-up makes the mouse mode ``MOUSE_MODE_VISIBLE`` whenever you "
"pause, we no longer have to worry about freeing and capturing the cursor in "
"``Player.gd``."
msgstr ""
"因为只要您暂停，弹出窗口就会使鼠标模式为“MOUSE_MODE_VISIBLE”，我们不再需要担"
"心在“Player.gd”中释放和捕获光标。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:516
#, fuzzy
msgid ""
"Now the pause menu pop-up is finished. You can now pause at any point in the "
"game and return to the main menu!"
msgstr ""
"现在弹出暂停菜单已完成。 您现在可以在游戏中的任何位置暂停并返回主菜单！"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:519
msgid "Starting the respawn system"
msgstr "启动重生系统"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:521
msgid ""
"Since the player can lose all their health, it would be ideal if the player "
"died and respawned too, so let's add that next!"
msgstr ""
"由于游戏角色可以失去所有的健康，如果游戏角色死亡和重生，那将是理想的，所以让"
"我们接下来添加！"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:523
#, fuzzy
msgid ""
"Firstly, open up ``Player.tscn`` and expand ``HUD``. Notice how there is a :"
"ref:`ColorRect <class_ColorRect>` called ``Death_Screen``. When the player "
"dies, we're going to make ``Death_Screen`` visible, and show them how long "
"they have to wait before the player is able to respawn."
msgstr ""
"首先，打开 ``Player.tscn`` 并展开 ``HUD`` 。 注意如何 :ref:`ColorRect "
"<class_ColorRect>` ` ``Death_Screen`` 。 当游戏角色死亡时，我们将使 "
"``Death_Screen`` 可见，并告诉他们在游戏角色能够重生之前他们需要等待多长时间。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:536
msgid "``RESPAWN_TIME``: The amount of time (in seconds) it takes to respawn."
msgstr "``RESPAWN_TIME``:重生的时间(以秒为单位)。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:537
msgid "``dead_time``: A variable to track how long the player has been dead."
msgstr "``dead_time``:一个跟踪游戏角色死亡时间的变量。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:538
msgid ""
"``is_dead``: A variable to track whether or not the player is currently dead."
msgstr "``is_dead``:一个跟踪游戏角色当前是否死亡的变量。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:539
msgid "``globals``: A variable to hold the ``Globals.gd`` singleton."
msgstr "``globals``:一个变量来保存 ``Globals.gd`` 单例。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:543
msgid ""
"We now need to add a couple lines to ``_ready``, so we can use ``Globals."
"gd`` in ``Player.gd``. Add the following to ``_ready``:"
msgstr ""
"我们现在需要在 ``_ready`` 中添加几行，所以我们可以在 ``Player.gd`` 中使用 "
"``Globals.gd`` 。 将以下内容添加到 ``_ready``:"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:551
msgid ""
"Now we're getting the ``Globals.gd`` singleton and assigning it to "
"``globals``. We also set the player's global position by setting the origin "
"in the player's global :ref:`Transform <class_Transform>` to the position "
"returned by ``globals.get_respawn_position``."
msgstr ""
"现在我们得到 ``Globals.gd`` 单例并将其分配给 ``globals``。 我们还通过在游戏角"
"色的全局中设置原点来设置游戏角色的全局位置 :ref:`Transform "
"<class_Transform>` 到 ``globals.get_respawn_position`` 返回的位置。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:554
msgid "Don't worry, we will be adding ``get_respawn_position`` further below!"
msgstr "别担心，我们将在下面添加“get_respawn_position`”！"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:558
#, fuzzy
msgid ""
"Next, we need to make a few changes to ``_physics_process``. Change "
"``_physics_process`` to the following:"
msgstr ""
"接下来我们需要对 ``physics_process`` 进行一些更改。 将 "
"``physics_processing`` 更改为以下内容:"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:576
msgid ""
"Now the player will not be processing input or movement input when the "
"player is dead. We are also now calling ``process_respawn``."
msgstr ""
"现在，当游戏角色死亡时，游戏角色将不会处理输入或移动输入。 我们现在也在调用 "
"``process_respawn`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:578
#, fuzzy
msgid ""
"The ``if !is_dead:`` expression is equivalent and works in the same way as "
"the expression ``if is_dead == false:``. And by removing the ``!`` sign from "
"the expression we obtain the opposite expression ``if is_dead == true:``. It "
"is just a shorter way of writing the same code functionality."
msgstr ""
"``if！is_dead:``表达式是等价的，其工作方式与表达式``if is_dead == false:``相"
"同。 通过从表达式中删除 ``！`` 符号，我们获得了相反的表达式``if is_dead == "
"true:``。 这只是编写相同代码功能的一种较短方式。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:580
msgid "We have not made ``process_respawn`` yet, so let's change that."
msgstr "我们还没有制作 ``process_respawn`` ，所以让我们改变它。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:584
msgid "Let's add ``process_respawn``. Add the following to ``Player.gd``:"
msgstr "让我们添加 ``process_respawn`` 。 将以下内容添加到``Player.gd``:"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:643
msgid "Let's go through what this function is doing."
msgstr "让我们来看看这个功能正在做什么。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:647
#, fuzzy
msgid ""
"Firstly, we check whether the player has just died by checking if ``health`` "
"is less than or equal to ``0`` and ``is_dead`` is ``false``."
msgstr ""
"首先，我们通过检查“健康”是否等于或小于“0”并且“is_dead”是“假”来检查游戏角色是"
"否刚刚死亡。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:649
msgid ""
"If the player has just died, we disable the collision shapes for the player. "
"We do this to make sure the player is not blocking anything with their dead "
"body."
msgstr ""
"如果游戏角色刚刚去世，我们会禁用游戏角色的碰撞形状。 我们这样做是为了确保游戏"
"角色不会用尸体挡住任何东西。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:651
#, fuzzy
msgid ""
"Next, we set ``changing_weapon`` to ``true`` and set "
"``changing_weapon_name`` to ``UNARMED``. This is so, if the player is using "
"a weapon, it is put away when they dies."
msgstr ""
"接下来我们将 ``changing_weapon`` 设置为 ``true`` 并将 "
"``changing_weapon_name`` 设置为 ``UNARMED`` 。 如果游戏角色使用武器就是这样，"
"当游戏角色死亡时它会被收起。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:654
msgid ""
"We then make the ``Death_Screen`` :ref:`ColorRect <class_ColorRect>` visible "
"so the player gets a nice grey overlay over everything when they have died. "
"We then make the rest of the UI, the ``Panel`` and ``Crosshair`` nodes, "
"invisible."
msgstr ""
"然后我们制作``Death_Screen`` :ref:`ColorRect <class_ColorRect>` 可见，这样当"
"游戏角色死亡时，游戏角色会得到漂亮的灰色覆盖。 然后我们制作UI的其余部分， "
"``Panel`` 和``Crosshair``节点，看不见。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:657
#, fuzzy
msgid ""
"Next, we set ``dead_time`` to ``RESPAWN_TIME`` so we can start counting down "
"how long the player has been dead. We also set ``is_dead`` to ``true`` so we "
"know the player has died."
msgstr ""
"接下来我们将 ``dead_time`` 设置为 ``RESPAWN_TIME`` ，这样我们就可以开始倒计时"
"游戏角色死了多久。 我们还将 ``is_dead`` 设置为 ``true`` ，因此我们知道游戏角"
"色已经死亡。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:659
#, fuzzy
msgid ""
"If the player is holding an object when they died, we need to throw it. We "
"first check whether the player is holding an object or not. If the player is "
"holding a object, we throw it using the same code as the throwing code we "
"added in :ref:`doc_fps_tutorial_part_five`."
msgstr ""
"如果游戏角色在死亡时持有物体，我们需要扔掉它。 我们首先检查游戏角色是否持有物"
"体。 如果游戏角色持有一个对象，我们使用与我们添加的抛出代码相同的代码抛出它 :"
"ref:`doc_fps_tutorial_part_five`。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:662
#, fuzzy
msgid ""
"The ``\\n`` combination from the expression ``You have died\\n`` is a "
"command used to display the text following after it on a new line below. "
"This is always useful when you want to nicely group displayed text in "
"multiple lines so it looks better and is more readable by the players of "
"your games."
msgstr ""
"表达式 ``You have died\\n`` 的 ``\\ n`` 组合是一个命令，用于在下面的新行上显"
"示后面的文本。 当您用魔杖很好地将显示的文本分组为多行时，这总是很有用，因此它"
"看起来更好，并且更容易被游戏游戏角色阅读。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:666
#, fuzzy
msgid ""
"Then we check whether the player is dead. If so, we then remove ``delta`` "
"from ``dead_time``."
msgstr ""
"然后我们检查游戏角色是否死了。 如果游戏角色死了，我们就从 ``dead_time`` 中删"
"除 ``delta`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:668
msgid ""
"We then make a new variable called ``dead_time_pretty``, where we convert "
"``dead_time`` to a string, using only the first three characters starting "
"from the left. This gives the player a nice looking string showing how much "
"time the player has left to wait before the player can respawn."
msgstr ""
"然后我们创建一个名为 ``dead_time_pretty`` 的新变量，我们将 ``dead_time`` 转换"
"为字符串，只使用从左边开始的前三个字符。 这为游戏角色提供了一个漂亮的字符串，"
"显示游戏角色在游戏角色重生之前需要等待多长时间。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:671
msgid ""
"We then change the :ref:`Label <class_Label>` in ``Death_Screen`` to show "
"how much time the player has left."
msgstr ""
"然后我们在``Death Screen``中更改 :ref:`Label <class Label>` 来显示游戏角色离"
"开的时间。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:673
msgid ""
"Next we check to see if the player has waited long enough and can respawn. "
"We do this by checking to see if ``dead_time`` is ``0`` or less."
msgstr ""
"接下来我们检查游戏角色是否已经等待足够长时间并且可以重生。 我们通过检查 "
"``dead_time`` 是否为“0”或更少来做到这一点。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:675
msgid ""
"If the player has waited long enough to respawn, we set the player's "
"position to a new respawn position provided by ``get_respawn_position``."
msgstr ""
"如果游戏角色等待足够长时间重生，我们将游戏角色的位置设置"
"为“get_respawn_position”提供的新重生位置。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:677
msgid ""
"We then enable both of the player's collision shapes so the player can "
"collide again with the environment."
msgstr ""
"然后我们启用两个游戏角色的碰撞形状，以便游戏角色可以再次与环境发生碰撞。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:679
#, fuzzy
msgid ""
"Next, we make the ``Death_Screen`` invisible and make the rest of the UI, "
"the ``Panel`` and ``Crosshair`` nodes, visible again."
msgstr ""
"接下来，我们使 ``Death_Screen`` 不可见，并使UI的其余部分， ``Panel`` 和"
"``Crosshair``节点再次可见。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:681
msgid ""
"We then go through each weapon and call its ``reset_weapon`` function, which "
"we will add soon."
msgstr ""
"然后我们通过每个武器并调用它的 ``reset_weapon`` 函数，我们将很快添加它。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:683
#, fuzzy
msgid ""
"Then, we reset ``health`` to ``100``, ``grenade_amounts`` to its default "
"values, and change ``current_grenade`` to ``Grenade``. This effectively "
"resets these variables to their default values."
msgstr ""
"然后我们将 ``health`` 重置为 ``100`` ，将`grenade_amounts``重置为默认值，并"
"将 ``current_grenade`` 改为 ``Grenade`` 。 这有效地将这些变量重置为其默认值。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:686
msgid "Finally, we set ``is_dead`` to ``false``."
msgstr "最后，我们将 ``is_dead`` 设置为 ``false`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:690
msgid ""
"Before we leave ``Player.gd``, we need to add one quick thing to ``_input``. "
"Add the following at the beginning of ``_input``:"
msgstr ""
"在我们离开 ``Player.gd`` 之前，我们需要在 ``_input`` 中添加一个快速的东西。 "
"在`_input``的开头添加以下内容:"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:697
#, fuzzy
msgid "Now, when the player is dead, they cannot look around with the mouse."
msgstr "现在当游戏角色死了，游戏角色无法用鼠标环顾四周。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:700
msgid "Finishing the respawn system"
msgstr "完成重生系统"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:702
#, fuzzy
msgid ""
"Firstly, let's open ``Weapon_Pistol.gd`` and add the ``reset_weapon`` "
"function. Add the following:"
msgstr ""
"首先让我们打开 ``Weapon_Pistol.gd`` 并添加 ``reset_weapon`` 函数。 添加以下内"
"容:"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:710
#, fuzzy
msgid ""
"Now, when we call ``reset_weapon``, the ammo in the pistol and the ammo in "
"the spares will be reset to their default values."
msgstr ""
"现在当我们调用 ``reset_weapon`` 时，手枪中的弹药和备件中的弹药将重置为默认"
"值。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:712
msgid "Now let's add ``reset_weapon`` in ``Weapon_Rifle.gd``:"
msgstr "现在让我们在 ``Weapon_Rifle.gd`` 中添加``reset_weapon``:"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:720
msgid "And add the following to ``Weapon_Knife.gd``:"
msgstr "并将以下内容添加到``Weapon_Knife.gd``:"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:728
#, fuzzy
msgid "Now all the weapons will reset when the player dies."
msgstr "现在，当游戏角色死亡时，所有武器都会重置。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:732
#, fuzzy
msgid ""
"Now we need to add a few things to ``Globals.gd``. Firstly, add the "
"following class variable:"
msgstr "现在我们需要在 ``Globals.gd`` 中添加一些东西。 首先，添加以下类变量:"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:738
#, fuzzy
msgid ""
"``respawn_points``: A variable to hold all the respawn points in a level"
msgstr "``respawn_points``:一个变量，用于保存关卡中的所有重生点"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:740
msgid ""
"Because we're getting a random spawn point each time, we need to randomize "
"the number generator. Add the following to ``_ready``:"
msgstr ""
"因为我们每次都得到一个随机的衍生点，我们需要随机化这个数字生成器。"
"在“_ready”中添加以下内容:"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:746
#, fuzzy
msgid ""
"``randomize`` will get us a new random seed so we get a (relatively) random "
"string of numbers when we use any of the random functions."
msgstr ""
"”randomize“将给我们一个新的随机种子，因此当我们使用任意一个随机函数时，我们得"
"到一个(相对的)随机字符串。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:748
msgid "Now let's add ``get_respawn_position`` to ``Globals.gd``:"
msgstr "现在让我们将 ``get_respawn_position`` 添加到``Globals.gd``:"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:763
#, fuzzy
msgid ""
"Firstly, we check if ``Globals.gd`` has any ``respawn_points`` by checking "
"whether ``respawn_points`` is ``null`` or not."
msgstr ""
"首先，我们通过检查 ``respawn_points`` 是否为 ``null`` 来检查 ``Globals.gd`` "
"是否有任何 ``respawn_points`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:765
msgid ""
"If ``respawn_points`` is ``null``, we return a position of empty :ref:"
"`Vector 3 <class_Vector3>` with the position ``(0, 0, 0)``."
msgstr ""
"如果 ``respawn_points`` 是``null``，我们返回一个空位置 :ref:`Vector 3 "
"<class_Vector3>` ，位置为``(0,0,0)``。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:767
msgid ""
"If ``respawn_points`` is not ``null``, we then get a random number between "
"``0`` and the number of elements we have in ``respawn_points``, minus ``1`` "
"since most programming languages, including ``GDScript``, start counting "
"from ``0`` when you are accessing elements in a list."
msgstr ""
"如果' respawn_points ' '不是' null ' '，那么我们就会得到一个介于' 0 ' '和' "
"respawn_points ' ' '中的元素数量之间的随机数，减去' 1 ' '，因为大多数编程语"
"言，包括' GDScript ' ' '，在访问列表中的元素时，都是从' 0 ' '开始计数的。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:770
msgid ""
"We then return the position of the :ref:`Spatial <class_Spatial>` node at "
"``respawn_point`` position in ``respawn_points``."
msgstr ""
"然后，我们在 ``respawn_points`` 的``respawn_point``位置返回 :ref:`Spatial "
"<class_Spatial>` 节点的位置。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:774
#, fuzzy
msgid ""
"Before we are done with ``Globals.gd``, we need to add the following to "
"``load_new_scene``:"
msgstr ""
"在我们完成 ``Globals.gd`` 之前。 我们需要将以下内容添加到``load_new_scene``:"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:780
msgid ""
"We set ``respawn_points`` to ``null`` so when/if the player gets to a level "
"with no respawn points, we do not respawn the player at the respawn points "
"that were in the level prior."
msgstr ""
"我们将 ``respawn_points`` 设置为 ``null`` ，所以当/如果游戏角色达到没有重生点"
"的等级时，我们不会在先前等级的重生点重生游戏角色。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:785
msgid ""
"Now all we need is a way to set the respawn points. Open up ``Ruins_Level."
"tscn`` and select ``Spawn_Points``. Add a new script called "
"``Respawn_Point_Setter.gd`` and attach it to ``Spawn_Points``. Add the "
"following to ``Respawn_Point_Setter.gd``:"
msgstr ""
"现在我们需要的是一种设置重生点的方法。 打开 ``Ruins_Level.tscn`` 并选择 "
"``Spawn_Points`` 。 添加一个名为 ``Respawn_Point_Setter.gd`` 的新脚本，并将其"
"附加到 ``Spawn_Points`` 。 将以下内容添加到``Respawn_Point_Setter.gd``:"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:796
#, fuzzy
msgid ""
"Now, when a node with ``Respawn_Point_Setter.gd`` has its ``_ready`` "
"function called, all the children nodes of the node with "
"``Respawn_Point_Setter.gd``, ``Spawn_Points`` in the case of ``Ruins_Level."
"tscn``, will be added to ``respawn_points`` in ``Globals.gd``."
msgstr ""
"现在当一个带有 ``Respawn_Point_Setter.gd`` 的节点调用了它的 ``_ready`` 函数"
"时，该节点的所有子节点都带有 ``Respawn_Point_Setter.gd`` ， ``Spawn_Points`` "
"在`` Ruins_Level.tscn``将被添加到``Globals.gd``中的``respawn_points``。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:800
msgid ""
"Any node with ``Respawn_Point_Setter.gd`` has to be above the player in the :"
"ref:`SceneTree <class_SceneTree>` so the respawn points are set before the "
"player needs them in the player's ``_ready`` function."
msgstr ""
"任何带有“Respawn_Point_Setter.gd`”的节点都必须位于 :ref:`SceneTree "
"<class_SceneTree>中的游戏角色上方，所以重新生成的点在游戏角色需要它们在游戏角"
"色的 ``_ready`` 函数之前设置。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:805
#, fuzzy
msgid ""
"Now, when the player dies, they will respawn after waiting ``4`` seconds!"
msgstr "现在当游戏角色死亡时，他们会在等待“4”秒后重生！"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:807
msgid ""
"No spawn points are already set up for any of the levels besides "
"``Ruins_Level.tscn``! Adding spawn points to ``Space_Level.tscn`` is left as "
"an exercise for the reader."
msgstr ""
"除了 ``Ruins_Level.tscn`` 之外，还没有为任何级别设置生成点！ 将生成点添加"
"到“Space_Level.tscn”将留给读者练习。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:811
msgid "Writing a sound system we can use anywhere"
msgstr "编写一个我们可以随处使用的音响系统"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:813
#, fuzzy
msgid ""
"Finally, let's make a sound system so we can play sounds from anywhere, "
"without having to use the player."
msgstr ""
"最后，让我们制作一个音响系统，这样我们就可以在任何地方播放声音，而无需使用播"
"放器。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:815
#, fuzzy
msgid ""
"Firstly, open up ``SimpleAudioPlayer.gd`` and change it to the following:"
msgstr "首先，打开 ``SimpleAudioPlayer.gd`` 并将其更改为以下内容:"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:859
msgid ""
"There are several changes from the old version, first and foremost being we "
"are no longer storing the sound files in ``SimpleAudioPlayer.gd`` anymore. "
"This is much better for performance since we're no longer loading each audio "
"clip when we create a sound, but instead we are forcing an audio stream to "
"be passed in to ``play_sound``."
msgstr ""
"旧版本有一些变化，首先是我们不再将声音文件存储在 ``SimpleAudioPlayer.gd`` "
"中。 这对性能要好得多，因为我们在创建声音时不再加载每个音频片段，而是强制将音"
"频流传递到“play_sound”。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:863
msgid ""
"Another change is we have a new class variable called ``should_loop``. "
"Instead of just destroying the audio player every time it's finished, we "
"instead want to check and see if the audio player is set to loop or not. "
"This allows us to have audio like looping background music without having to "
"spawn a new audio player with the music when the old one is finished."
msgstr ""
"另一个变化是我们有一个名为 ``should_loop`` 的新类变量。 我们不是仅在每次完成"
"时销毁音频播放器，而是要检查并查看音频播放器是否设置为循环播放。 这使得我们可"
"以像循环背景音乐那样使用音频，而不必在旧音频播放完成后用音乐生成新的音频播放"
"器。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:865
msgid ""
"Finally, instead of being instanced/spawned in ``Player.gd``, the audio "
"player is instead going to be spawned in ``Globals.gd`` so we can create "
"sounds from any scene. Now the audio player stores ``Globals.gd`` singleton "
"so when the audio player is destroyed, we can also remove it from a list in "
"``Globals.gd``."
msgstr ""
"最后，不是在 ``Player.gd`` 中实例化/生成，而是在“Globals.gd”中生成音频播放"
"器，这样我们就可以从任何场景创建声音。 现在音频播放器存储了 ``Globals.gd`` 单"
"例，所以当音频播放器被销毁时，我们也可以从 ``Globals.gd`` 中的列表中删除它。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:868
msgid "Let's go over the changes."
msgstr "让我们回顾一下这些变化。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:872
#, fuzzy
msgid ""
"For the class variables, we removed all the ``audio_[insert name here]`` "
"variables since we will instead have these passed in from ``Globals.gd``."
msgstr ""
"对于类变量，我们删除了所有的``audio_ [insert name here]``变量，因为我们将从 "
"``Globals.gd`` 中传入这些变量。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:874
msgid ""
"We also added two new class variables, ``should_loop`` and ``globals``. "
"We'll use ``should_loop`` to tell whether the audio player should loop when "
"the sound has finished, and ``globals`` will hold the ``Globals.gd`` "
"singleton."
msgstr ""
"我们还添加了两个新的类变量 ``should_loop`` 和 ``globals`` 。 我们将使用 "
"``should_loop`` 来判断音频播放器是否应该在声音结束时循环，而 ``globals`` 将保"
"持 ``Globals.gd`` 单例。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:877
#, fuzzy
msgid ""
"The only change in ``_ready`` is now audio player is getting the ``Globals."
"gd`` singleton and assigning it to ``globals``."
msgstr ""
"``_ready``的唯一变化是现在音频播放器正在获得``Globals.gd``单例并将其分配给"
"``globals``"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:879
msgid ""
"``play_sound`` now expects an audio stream, named ``audio_stream``, to be "
"passed in, instead of ``sound_name``. Instead of checking the sound name and "
"setting the stream for the audio player, we instead check to make sure an "
"audio stream was passed in. If an audio stream was not passed in, we print "
"an error message, remove the audio player from a list in the ``Globals.gd`` "
"singleton called ``created_audio``, and then free the audio player."
msgstr ""
"``play_sound``现在需要传入一个名为``audio_stream``的音频流，而不是 "
"``sound_name`` 。 我们不是检查声音名称和设置音频播放器的流，而是检查以确保传"
"入音频流。如果未传入音频流，我们打印错误消息，从列表中删除音频播放器 在 "
"``Globals.gd`` 单例中称为 ``created_audio`` ，然后释放音频播放器。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:883
msgid ""
"Finally, in ``sound_finished`` we first check to see if the audio player is "
"supposed to loop or not using ``should_loop``. If the audio player is "
"supposed to loop, we play the sound again from the start, at position "
"``0.0``. If the audio player is not supposed to loop, we remove the audio "
"player from a list in the ``Globals.gd`` singleton called ``created_audio``, "
"and then free the audio player."
msgstr ""
"最后，在 ``sound_finished`` 中，我们首先检查音频播放器是否应该使用 "
"``should_loop`` 循环。 如果音频播放器应该循环，我们将从头开始再次播放声音，位"
"置为“0.0”。 如果音频播放器不应该循环，我们从名为 ``created_audio`` 的"
"``Globals.gd``单曲列表中删除音频播放器，然后释放音频播放器。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:889
msgid ""
"Now that we've finished our changes to ``SimpleAudioPlayer.gd``, we now need "
"to turn our attention to ``Globals.gd``. First, add the following class "
"variables:"
msgstr ""
"现在我们已完成对 ``SimpleAudioPlayer.gd`` 的更改，现在我们需要将注意力转向 "
"``Globals.gd`` 。 首先，添加以下类变量:"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:905
#, fuzzy
msgid "Let's go over these global variables."
msgstr "让我们来看看这些全局变量。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:907
#, fuzzy
msgid ""
"``audio_clips``: A dictionary holding all the audio clips ``Globals.gd`` can "
"play."
msgstr "``audio_clips``:一个包含所有音频片段``Globals.gd``的字典可以播放。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:908
msgid "``SIMPLE_AUDIO_PLAYER_SCENE``: The simple audio player scene."
msgstr "``SIMPLE_AUDIO_PLAYER_SCENE``:简单的音频播放器场景。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:909
#, fuzzy
msgid ""
"``created_audio``: A list to hold all the simple audio players ``Globals."
"gd`` has created."
msgstr ""
"``created_audio``:一个列表，用于保存所有简单的音频播放器 ``Globals.gd``"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:911
msgid ""
"If you want to add additional audio, you need to add it to ``audio_clips``. "
"No audio files are provided in this tutorial, so you will have to provide "
"your own."
msgstr ""
"如果要添加其他音频，则需要将其添加到“audio_clips”。 本教程中未提供音频文件，"
"因此您必须提供自己的音频文件。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:914
msgid ""
"One site I'd recommend is **GameSounds.xyz**. I'm using the Gamemaster audio "
"gun sound pack included in the Sonniss' GDC Game Audio bundle for 2017. The "
"tracks I've used (with some minor editing) are as follows:"
msgstr ""
"我推荐的一个网站是** GameSounds.xyz **。 我正在使用2017年Sonniss'GDC游戏音频"
"包中包含的Gamemaster音频枪声音包。我使用过的轨道(经过一些小编辑)如下:"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:918
msgid "gun_revolver_pistol_shot_04,"
msgstr "gun_revolver_pistol_shot_04,"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:919
msgid "gun_semi_auto_rifle_cock_02,"
msgstr "gun_semi_auto_rifle_cock_02,"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:920
msgid "gun_submachine_auto_shot_00_automatic_preview_01"
msgstr "gun_submachine_auto_shot_00_automatic_preview_01"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:924
msgid ""
"Now we need to add a new function called ``play_sound`` to ``Globals.gd``:"
msgstr "现在我们需要在 ``Globals.gd`` 中添加一个名为 ``play_sound`` 的新函数:"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:943
#, fuzzy
msgid ""
"Firstly, we check whether ``Globals.gd`` has an audio clip with the name "
"``sound_name`` in ``audio_clips``. If it does not, we print an error message."
msgstr ""
"首先，我们检查 ``Globals.gd`` 是否在 ``audio_clips`` 中有一个名为 "
"``sound_name`` 的音频剪辑。 如果没有，我们会打印一条错误消息。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:945
msgid ""
"If ``Globals.gd`` has an audio clip with the name ``sound_name``, we then "
"instance/spawn a new ``SIMPLE_AUDIO_PLAYER_SCENE`` and assign it to "
"``new_audio``."
msgstr ""
"如果 ``Globals.gd`` 有一个名为 ``sound_name`` 的音频剪辑，我们然后实例/生成一"
"个新的 ``SIMPLE_AUDIO_PLAYER_SCENE`` 并将其分配给 ``new_audio`` 。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:947
msgid ""
"We then set ``should_loop``, and add ``new_audio`` as a child of ``Globals."
"gd``."
msgstr ""
"然后我们设置 ``should_loop`` ，并添加 ``new_audio`` 作为 ``Globals.gd`` 的子"
"节点。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:949
msgid ""
"Remember, we have to be careful adding nodes to a singleton, since these "
"nodes will not be destroyed when changing scenes."
msgstr ""
"请记住，我们必须小心地将节点添加到单个节点，因为在更改场景时这些节点不会被销"
"毁。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:951
msgid ""
"We then call ``play_sound``, passing in the audio clip associated with "
"``sound_name`` and the sound position."
msgstr ""
"然后我们调用 ``play_sound`` ，传入与 ``sound_name`` 相关的音频片段和声音位"
"置。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:955
#, fuzzy
msgid ""
"Before we leave ``Globals.gd``, we need to add a few lines of code to "
"``load_new_scene`` so when the player changes scenes, all the audio is "
"destroyed."
msgstr ""
"在我们离开 ``Globals.gd`` 之前，我们需要在 ``load_new_scene`` 中添加几行代"
"码，这样当播放器改变场景时，所有的音频都会被破坏。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:957
msgid "Add the following to ``load_new_scene``:"
msgstr "将以下内容添加到``load_new_scene``:"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:966
#, fuzzy
msgid ""
"Now, before ``Globals.gd`` changes scenes, it goes through each simple audio "
"player in ``created_sounds`` and frees/destroys them. Once ``Globals.gd`` "
"has gone through all the sounds in ``created_audio``, we clear "
"``created_audio`` so it no longer holds any references to any (now freed/"
"destroyed) simple audio players."
msgstr ""
"现在，在 ``Globals.gd`` 改变场景之前，它会通过 ``created_sounds`` 中的每个简"
"单音频播放器并释放/销毁它们。 一旦 ``Globals.gd`` 完成了 ``created_audio`` 中"
"的所有声音，我们就会清除 ``created_audio`` ，这样它就不再拥有对任何(noew释放/"
"毁坏)简单音频播放器的任何引用。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:971
#, fuzzy
msgid ""
"Let's change ``create_sound`` in ``Player.gd`` to use this new system. "
"First, remove ``simple_audio_player`` from ``Player.gd``'s class variables "
"since we will no longer be directly instancing/spawning sounds in ``Player."
"gd``."
msgstr ""
"让我们改变 ``Player.gd`` 中的 ``create_sound`` 来使用这个新系统。 首先，从 "
"``Player.gd`` 的类变量中删除 ``simple_audio_player`` ，因为我们将不再直接在 "
"``Player.gd`` 中实例化/产生声音。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:974
msgid "Now, change ``create_sound`` to the following:"
msgstr "现在，将 ``create_sound`` 更改为以下内容:"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:981
#, fuzzy
msgid ""
"Now, whenever ``create_sound`` is called, we simply call ``play_sound`` in "
"``Globals.gd``, passing in all the arguments received."
msgstr ""
"现在每当调用 ``create_sound`` 时，我们只需在 ``Globals.gd`` 中调用 "
"``play_sound`` ，传入所有收到的参数。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:985
#, fuzzy
msgid ""
"Now all the sounds in our FPS can be played from anywhere. All we have to do "
"is get the ``Globals.gd`` singleton, and call ``play_sound``, pass in the "
"name of the sound we want to play, whether we want it to loop or not, and "
"the position from which to play the sound."
msgstr ""
"现在我们的FPS中的所有声音都可以在任何地方播放。 我们所要做的就是得到 "
"``Globals.gd`` 单例，并调用 ``play_sound`` ，传入我们想要播放的声音的名称，无"
"论我们是否想要它循环，以及 播放声音。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:988
#, fuzzy
msgid ""
"For example, if you want to play an explosion sound when the grenade "
"explodes you'd need to add a new sound to ``audio_clips`` in ``Globals.gd``, "
"get the ``Globals.gd`` singleton, and then you just need to add something "
"like ``globals.play_sound(\"explosion\", false, global_transform.origin)`` "
"in the grenades ``_process`` function, right after the grenade damages all "
"the bodies within its blast radius."
msgstr ""
"例如，如果您想在手榴弹爆炸时发出爆炸声，您需要在 ``Globals.gd`` 的"
"``audio_clips``中添加一个新的声音，得到 ``Globals.gd`` 单例， 然后您只需要在"
"手榴弹``_ process``函数中添加类似``globals.play_sound(“explosion”，false，"
"global_transform.origin)``的东西，就在手榴弹损坏其爆炸半径范围内的所有物体之"
"后。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:998
msgid "Now you have a fully working single player FPS!"
msgstr "现在您有一个完全工作的单人FPS！"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:1000
#, fuzzy
msgid ""
"At this point, you have a good base to build more complicated FPS games."
msgstr "在这一点上，您有一个很好的基础来构建更复杂的FPS游戏。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:1004
msgid ""
"You can download the finished project for the entire tutorial here: :"
"download:`Godot_FPS_Part_6.zip <files/Godot_FPS_Finished.zip>`"
msgstr ""
"您可以在这里下载整个教程的完成项目: :download:`Godot_FPS_Part_6.zip <files / "
"Godot_FPS_Finished.zip>`"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:1006
#, fuzzy
msgid ""
"The finished project source files contain the same code, just written in a "
"different order. This is because the finished project source files are what "
"the tutorial is based on."
msgstr ""
"完成的项目源文件包含完全相同的代码，只是以不同的顺序编写。 这是因为完成的项目"
"源文件是教程所基于的。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:1009
msgid ""
"The finished project code was written in the order that features were "
"created, not necessarily in a order that is ideal for learning."
msgstr "完成的项目代码是按照创建功能的顺序编写的，不一定是理想的学习顺序。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:1012
msgid ""
"Other than that, the source is exactly the same, just with helpful comments "
"explaining what each part does."
msgstr "除此之外，源代码完全相同，只是提供有用的评论，解释每个部分的作用。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:1015
msgid ""
"The finished project source is hosted on Github as well: https://github.com/"
"TwistedTwigleg/Godot_FPS_Tutorial"
msgstr ""
"完成的项目源也托管在Github上:https://github.com/TwistedTwigleg/"
"Godot_FPS_Tutorial"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:1017
msgid ""
"**Please note that the code in Github may or may not be in sync with the "
"tutorial in the documentation**."
msgstr "**请注意，Github中的代码可能与文档中的教程同步也可能不同步**。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:1019
#, fuzzy
msgid ""
"The code in the documentation is likely better managed and/or more up to "
"date. If you are unsure of which to use, use the project(s) provided in the "
"documentation, as they are maintained by the Godot community."
msgstr ""
"文档中的代码可能更好地管理和/或更新。 如果您不确定使用哪个项目，请使用文档中"
"提供的项目，因为它们由Godot社区维护。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:1022
#, fuzzy
msgid ""
"You can download all the ``.blend`` files used in this tutorial here: :"
"download:`Godot_FPS_BlenderFiles.zip <files/Godot_FPS_BlenderFiles.zip>`"
msgstr ""
"您可以在这里下载本教程中使用的所有 ``.blend`` 文件: :download:"
"`Godot_FPS_BlenderFiles.zip <files / Godot_FPS_BlenderFiles.zip>`"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:1024
msgid ""
"All assets provided in the started assets (unless otherwise noted) were "
"**originally created by TwistedTwigleg, with changes/additions by the Godot "
"community.** All original assets provided for this tutorial are released "
"under the ``MIT`` license."
msgstr ""
"启动资源中提供的所有资源(除非另有说明)最初由TwistedTwigleg创建，由Godot社区进"
"行更改/添加。**本教程提供的所有原始资源均在“MIT”许可下发布。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:1029
msgid ""
"The skybox is created by **StumpyStrust** and can be found at OpenGameArt."
"org. https://opengameart.org/content/space-skyboxes-0 . The skybox is "
"licensed under the ``CC0`` license."
msgstr ""
"天空盒由** StumpyStrust **创建，可以在OpenGameArt.org找到。 https://"
"opengameart.org/content/space-skyboxes-0。 天空盒根据“CC0”许可证授权。"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:1034
msgid ""
"The skybox was converted to a 360 equirectangular image using this tool: "
"https://www.360toolkit.co/convert-cubemap-to-spherical-equirectangular.html"
msgstr ""
"使用此工具将天空盒转换为360 equirectangular图像:https://www.360toolkit.co/"
"convert-cubemap-to-spherical-equirectangular.html"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:1036
msgid ""
"While no sounds are provided, you can find many game ready sounds at https://"
"gamesounds.xyz/"
msgstr ""
"虽然没有提供声音，但您可以在https://gamesounds.xyz/找到许多游戏就绪声音"

#: ../../docs/tutorials/3d/fps_tutorial/part_six.rst:1038
msgid ""
"**OpenGameArt.org, 360toolkit.co, the creator(s) of Titillium-Regular, "
"StumpyStrust, and GameSounds.xyz are in no way involved in this tutorial.**"
msgstr ""
"** OpenGameArt.org，360toolkit.co，Titillium-Regular，StumpyStrust和"
"GameSounds.xyz的创建者都不参与本教程。**"

#: ../../docs/tutorials/3d/vertex_animation/index.rst:2
#, fuzzy
msgid "Animating thousands of objects"
msgstr "所有类型对象的变换动画"

#: ../../docs/tutorials/3d/vertex_animation/animating_thousands_of_fish.rst:4
#, fuzzy
msgid "Animating thousands of fish with MultiMeshInstance"
msgstr "用渐变节点动画生命的损失"

#: ../../docs/tutorials/3d/vertex_animation/animating_thousands_of_fish.rst:6
msgid ""
"This tutorial explores a technique used in the game `ABZU <https://www."
"gdcvault.com/play/1024409/Creating-the-Art-of-ABZ>`_ for rendering and "
"animating thousands of fish using vertex animation and static mesh "
"instancing."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/animating_thousands_of_fish.rst:10
msgid ""
"In Godot, this can be accomplished with a custom :ref:`Shader "
"<class_Shader>` and a :ref:`MultiMeshInstance <class_MultiMeshInstance>`. "
"Using the following technique you can render thousands of animated objects, "
"even on low end hardware."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/animating_thousands_of_fish.rst:14
msgid ""
"We will start by animating one fish. Then, we will see how to extend that "
"animation to thousands of fish."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/animating_thousands_of_fish.rst:18
#, fuzzy
msgid "Animating one Fish"
msgstr "动画"

#: ../../docs/tutorials/3d/vertex_animation/animating_thousands_of_fish.rst:20
#, fuzzy
msgid ""
"We will start with a single fish. Load your fish model into a :ref:"
"`MeshInstance <class_MeshInstance>` and add a new :ref:`ShaderMaterial "
"<class_ShaderMaterial>`."
msgstr ""
"单击下面的材质 :ref:`Plane Mesh <class_MeshInstance>` 菜单并创建一个新的 :"
"ref:`ShaderMaterial <class_ShaderMaterial>`。"

#: ../../docs/tutorials/3d/vertex_animation/animating_thousands_of_fish.rst:23
msgid ""
"Here is the fish we will be using for the example images, you can use any "
"fish model you like."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/animating_thousands_of_fish.rst:27
msgid ""
"The fish model in this tutorial is made by `QuaterniusDev <http://quaternius."
"com>`_ and is shared with a creative commons license. CC0 1.0 Universal (CC0 "
"1.0) Public Domain Dedication https://creativecommons.org/publicdomain/"
"zero/1.0/"
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/animating_thousands_of_fish.rst:31
msgid ""
"Typically, you would use bones and a :ref:`Skeleton <class_Skeleton>` to "
"animate objects. However, bones are animated on the CPU and so you end "
"having to calculate thousands of operations every frame and it becomes "
"impossible to have thousands of objects. Using vertex animation in a vertex "
"shader, you avoid using bones and can instead calculate the full animation "
"in a few lines of code and completely on the GPU."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/animating_thousands_of_fish.rst:37
msgid "The animation will be made of four key motions:"
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/animating_thousands_of_fish.rst:39
msgid "A side to side motion"
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/animating_thousands_of_fish.rst:40
msgid "A pivot motion around the center of the fish"
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/animating_thousands_of_fish.rst:41
msgid "A panning wave motion"
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/animating_thousands_of_fish.rst:42
msgid "A panning twist motion"
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/animating_thousands_of_fish.rst:44
msgid ""
"All the code for the animation will be in the vertex shader with uniforms "
"controlling the amount of motion. We use uniforms to control the strength of "
"the motion so that you can tweak the animation in editor and see the results "
"in real time, without the shader having to recompile."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/animating_thousands_of_fish.rst:48
msgid ""
"All the motions will be made using cosine waves applied to ``VERTEX`` in "
"model space. We want the vertices to be in model space so that the motion is "
"always relative to the orientation of the fish. For example, side-to-side "
"will always be move the fish back and forth in its left to right direction, "
"instead of on the ``x`` axis in the world orientation."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/animating_thousands_of_fish.rst:53
msgid ""
"In order to control the speed of the animation, we will start by defining "
"our own time variable using ``TIME``."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/animating_thousands_of_fish.rst:60
msgid ""
"The first motion we will implement is the side to side motion. It can be "
"made by offsetting ``VERTEX.x`` by ``cos`` of ``TIME``. Each time the mesh "
"is rendered, all the vertices will move to the side by the amount of "
"``cos(time)``."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/animating_thousands_of_fish.rst:69
#, fuzzy
msgid "The resulting animation should look something like this:"
msgstr "卢比计数器应该是这样的"

#: ../../docs/tutorials/3d/vertex_animation/animating_thousands_of_fish.rst:73
msgid ""
"Next, we add the pivot. Because the fish is centered at (0, 0), all we have "
"to do is multiply ``VERTEX`` by a rotation matrix for it to rotate around "
"the center of the fish."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/animating_thousands_of_fish.rst:76
msgid "We construct a rotation matrix like so:"
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/animating_thousands_of_fish.rst:85
msgid ""
"And then we apply it in the ``x`` and ``z`` axes by multiplying it by "
"``VERTEX.xz``."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/animating_thousands_of_fish.rst:91
#, fuzzy
msgid "With only the pivot applied you should see something like this:"
msgstr "如果您选择两个节点，您应该会看到这样的结果"

#: ../../docs/tutorials/3d/vertex_animation/animating_thousands_of_fish.rst:95
msgid ""
"The next two motions need to pan down the spine of the fish. For that, we "
"need a new variable, ``body``. ``body`` is a float that is ``0`` at the tail "
"of the fish and ``1`` at its head."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/animating_thousands_of_fish.rst:102
msgid ""
"The next motion is a cosine wave that moves down the length of the fish. To "
"make it move along the spine of the fish, we offset the input to ``cos`` by "
"the position along the spine, which is the variable we defined above, "
"``body``."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/animating_thousands_of_fish.rst:111
msgid ""
"This looks very similar to the side to side motion we defined above, but in "
"this one, by using ``body`` to offset ``cos`` each vertex along the spine "
"has a different position in the wave making it look like a wave is moving "
"along the fish."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/animating_thousands_of_fish.rst:117
msgid ""
"The last motion is the twist, which is a panning roll along the spine. "
"Similarly to the pivot, we first  construct a rotation matrix."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/animating_thousands_of_fish.rst:126
msgid ""
"We apply the rotation in the ``xy`` axes so that the fish appears to roll "
"around its spine. For this to work, the fishes spine needs to be centered on "
"the ``z`` axis."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/animating_thousands_of_fish.rst:133
#, fuzzy
msgid "Here is the fish with twist applied:"
msgstr "这是GDScript示例代码:"

#: ../../docs/tutorials/3d/vertex_animation/animating_thousands_of_fish.rst:137
msgid ""
"If we apply all these motions one after another, we get a fluid jelly-like "
"motion."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/animating_thousands_of_fish.rst:141
msgid ""
"Normal fish swim mostly with the back half of their body. Accordingly, we "
"need to limit the panning motions to the back half of the fish. To do this, "
"we create a new variable, ``mask``."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/animating_thousands_of_fish.rst:144
msgid ""
"``mask`` is a float that goes from ``0`` at the front of the fish to ``1`` "
"at the end  using ``smoothstep`` to control the point at which the "
"transition from ``0`` to ``1`` happens."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/animating_thousands_of_fish.rst:152
msgid "Below is an image of the fish with ``mask`` used as ``COLOR``:"
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/animating_thousands_of_fish.rst:156
msgid ""
"For the wave, we multiply the motion by ``mask`` which will limit it to the "
"back half."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/animating_thousands_of_fish.rst:163
msgid ""
"In order to apply the mask to the twist, we use ``mix``. ``mix`` allows us "
"to mix the vertex position between a fully rotated vertex and one that is "
"not rotated. We need to use ``mix`` instead of multiplying ``mask`` by the "
"rotated ``VERTEX`` because we are not adding the motion to the ``VERTEX`` we "
"are replacing the ``VERTEX`` with the rotated version. If we multiplied that "
"by ``mask`` we would shrink the fish."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/animating_thousands_of_fish.rst:174
msgid "Putting the four motions together gives us the final animation."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/animating_thousands_of_fish.rst:178
msgid ""
"Go ahead and play with the uniforms in order to alter the swim cycle of the "
"fish. You will find that you can create a wide variety of swim styles using "
"these four motions."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/animating_thousands_of_fish.rst:182
msgid "Making a school of fish"
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/animating_thousands_of_fish.rst:184
#, fuzzy
msgid ""
"Godot makes it easy to render thousands of the same object using a "
"MultiMeshInstance node."
msgstr "godot 使在属性面板中创建自定义资源变得很容易。"

#: ../../docs/tutorials/3d/vertex_animation/animating_thousands_of_fish.rst:186
msgid ""
"A MultiMeshInstance node is created and used the same way you would make a "
"MeshInstance node. For this tutorial, we will name the MultiMeshInstance "
"node ``School``, because it will contain a school of fish."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/animating_thousands_of_fish.rst:190
msgid ""
"Once you have a MultiMeshInstance add a :ref:`MultiMesh <class_MultiMesh>`, "
"and to that MultiMesh add your :ref:`Mesh <class_Mesh>` with the shader from "
"above."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/animating_thousands_of_fish.rst:193
msgid ""
"MultiMeshes draw your Mesh with three additional per-instance properties: "
"Transform (rotation, translation, scale), Color, and Custom. Custom is used "
"to pass in 4 multi-use variables using a :ref:`Color <class_Color>`."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/animating_thousands_of_fish.rst:197
msgid ""
"``instance_count`` specifies how many instances of the mesh you want to "
"draw. For now, leave ``instance_count`` at ``0`` because you cannot change "
"any of the other parameters while ``instance_count`` is larger than ``0``. "
"We will set ``instance count`` in GDScript later."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/animating_thousands_of_fish.rst:201
msgid ""
"``transform_format`` specifies whether the transforms used are 3D or 2D. For "
"this tutorial, select 3D."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/animating_thousands_of_fish.rst:203
msgid ""
"For both ``color_format`` and ``custom_data_format`` you can choose between "
"``None``, ``Byte``, and ``Float``. ``None`` means you won't be passing in "
"that data (either a per-instance ``COLOR`` variable, or ``INSTANCE_CUSTOM``) "
"to the shader. ``Byte`` means each number making up the color you pass in "
"will be stored with 8 bits while ``Float`` means each number will be stored "
"in a floating point number (32 bits). ``Float`` is slower but more precise, "
"``Byte`` will take less memory and be faster, but you may see some visual "
"artifacts."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/animating_thousands_of_fish.rst:210
msgid "Now, set ``instance_count`` to the number of fish you want to have."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/animating_thousands_of_fish.rst:212
msgid "Next we need to set the per-instance transforms."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/animating_thousands_of_fish.rst:214
msgid ""
"There are two ways to set per-instance transforms for MultiMeshes. The first "
"is entirely in editor and is described in the :ref:`MultiMeshInstance "
"tutorial <doc_using_multi_mesh_instance>`."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/animating_thousands_of_fish.rst:217
msgid ""
"The second is to loop over all the instances and set their transforms in "
"code. Below, we use GDScript to loop over all the instances and set their "
"transform to a random position."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/animating_thousands_of_fish.rst:227
msgid ""
"Running this script will place the fish in random positions in a box around "
"the position of the MultiMeshInstance."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/animating_thousands_of_fish.rst:230
msgid ""
"If performance is an issue for you, try running the scene with GLES2 or with "
"fewer fish."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/animating_thousands_of_fish.rst:232
msgid ""
"Notice how all the fish  are all in the same position in their swim cycle? "
"It makes them look very robotic. The next step is to give each fish a "
"different position in the swim cycle so the entire school looks more organic."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/animating_thousands_of_fish.rst:237
#, fuzzy
msgid "Animating a school of fish"
msgstr "动画控件"

#: ../../docs/tutorials/3d/vertex_animation/animating_thousands_of_fish.rst:239
msgid ""
"One of the benefits of animating the fish using ``cos`` functions is that "
"they are animated with one parameter, ``time``. In order to give each fish a "
"unique position in the swim cycle, we only need to offset ``time``."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/animating_thousands_of_fish.rst:243
msgid ""
"We do that by adding the per-instance custom value ``INSTANCE_CUSTOM`` to "
"``time``."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/animating_thousands_of_fish.rst:249
msgid ""
"Next, we need to pass a value into ``INSTANCE_CUSTOM``. We do that by adding "
"one line into the ``for`` loop from above. In the ``for`` loop we assign "
"each instance a set of four random floats to use."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/animating_thousands_of_fish.rst:257
msgid ""
"Now the fish all have unique positions in the swim cycle. You can give them "
"a little more individuality by using ``INSTANCE_CUSTOM`` to make them swim "
"faster or slower by multiplying by ``TIME``."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/animating_thousands_of_fish.rst:266
msgid ""
"You can even experiment with changing the per-instance color the same way "
"you changed the per-instance custom value."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/animating_thousands_of_fish.rst:269
msgid ""
"One problem that you will run into at this point is that the fish are "
"animated, but they are not moving. You can move them by updating the per-"
"instance transform for each fish every frame. Although doing so will be "
"faster then moving thousands of MeshInstances per frame, it is still likely "
"to be slow."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/animating_thousands_of_fish.rst:274
msgid ""
"In the next tutorial we will cover how to use :ref:`Particles "
"<class_Particles>` to take advantage of the GPU and move each fish around "
"individually while still receiving the benefits of instancing."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/controlling_thousands_of_fish.rst:4
msgid "Controlling thousands of fish with Particles"
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/controlling_thousands_of_fish.rst:6
msgid ""
"The problem with :ref:`MeshInstances <class_MeshInstance>` is that it is "
"expensive to update their transform array. It is great for placing many "
"static objects around the scene. But it is still difficult to move the "
"objects around the scene."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/controlling_thousands_of_fish.rst:10
msgid ""
"To make each instance move in an interesting way we will use a :ref:"
"`Particles <class_Particles>` node. Particles take advantage of GPU "
"acceleration by computing and setting the per-instance information in a :ref:"
"`Shader <class_Shader>`."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/controlling_thousands_of_fish.rst:14
msgid ""
"Particles are not available in GLES2, instead use :ref:`CPUParticles "
"<class_CPUParticles>`, which do the same thing as Particles, but do not "
"benefit from GPU acceleration."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/controlling_thousands_of_fish.rst:17
#, fuzzy
msgid ""
"First create a Particles node. Then, under \"Draw Passes\" set the "
"Particle's \"Draw Pass 1\" to your :ref:`Mesh <class_Mesh>`. Then under "
"\"Process Material\" create a new :ref:`ShaderMaterial "
"<class_ShaderMaterial>`."
msgstr ""
"单击下面的材质 :ref:`Plane Mesh <class_MeshInstance>` 菜单并创建一个新的 :"
"ref:`ShaderMaterial <class_ShaderMaterial>`。"

#: ../../docs/tutorials/3d/vertex_animation/controlling_thousands_of_fish.rst:21
msgid "Set the ``shader_type`` to ``particles``."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/controlling_thousands_of_fish.rst:27
#, fuzzy
msgid "Then add the following two functions:"
msgstr "以下是需要注意的事项:"

#: ../../docs/tutorials/3d/vertex_animation/controlling_thousands_of_fish.rst:51
msgid ""
"These functions come from the default :ref:`ParticlesMaterial "
"<class_ParticlesMaterial>`. They are used to generate a random number from  "
"each particle's ``RANDOM_SEED``."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/controlling_thousands_of_fish.rst:54
msgid ""
"A unique thing about particle shaders is that some of the built-in variables "
"are saved across frames. ``TRANSFORM``, ``COLOR``, and ``CUSTOM`` can all be "
"accessed in the Spatial shader of the mesh, and also in the particle shader "
"the next time it is run."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/controlling_thousands_of_fish.rst:58
msgid ""
"Next, setup your ``vertex`` function. Particles shaders only contain a "
"vertex function and no others."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/controlling_thousands_of_fish.rst:61
msgid ""
"First we will distinguish between code that needs to be run only when the "
"particle system starts and code that should always run. We want to give each "
"fish a random position and a random animation offset when the system is "
"first run so we wrap that code in an ``if`` statement that checks the built-"
"in variable ``RESTART`` which becomes true for one frame when the particle "
"system is restarted."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/controlling_thousands_of_fish.rst:66
msgid "From a high level, this looks like:"
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/controlling_thousands_of_fish.rst:78
msgid ""
"Next, we need to generate 4 random numbers: 3 to create a random position "
"and one for the random offset of the swim cycle."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/controlling_thousands_of_fish.rst:81
msgid ""
"First, generate 4 seeds inside the ``RESTART`` block using the ``hash`` "
"function provided above:"
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/controlling_thousands_of_fish.rst:90
msgid ""
"Then, use those seeds to generate random numbers using ``rand_from_seed``:"
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/controlling_thousands_of_fish.rst:99
msgid ""
"Finally, assign ``position`` to ``TRANSFORM[3].xyz``, which is the part of "
"the transform that holds the position information."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/controlling_thousands_of_fish.rst:106
msgid "Remember, all this code so far goes inside the ``RESTART`` block."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/controlling_thousands_of_fish.rst:108
msgid ""
"The vertex shader for your mesh can stay the exact same as it was in the "
"previous tutorial."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/controlling_thousands_of_fish.rst:110
msgid ""
"Now you can move each fish individually each frame, either by adding to the "
"``TRANSFORM`` directly or by writing to ``VELOCITY``."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/controlling_thousands_of_fish.rst:113
msgid "Let's transform the fish by setting their ``VELOCITY``."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/controlling_thousands_of_fish.rst:119
msgid ""
"This is the most basic way to set ``VELOCITY`` every particle (or fish) will "
"have the same velocity."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/controlling_thousands_of_fish.rst:121
msgid ""
"Just by setting ``VELOCITY`` you can make the fish swim however you want. "
"For example, try the code below."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/controlling_thousands_of_fish.rst:128
msgid "This will give each fish a unique speed between ``2`` and ``10``."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/controlling_thousands_of_fish.rst:130
msgid ""
"If you used ``CUSTOM.y`` in the last tutorial, you can also set the speed of "
"the swim animation based on the ``VELOCITY``. Just use ``CUSTOM.y``."
msgstr ""

#: ../../docs/tutorials/3d/vertex_animation/controlling_thousands_of_fish.rst:137
#, fuzzy
msgid "This code gives you the following behavior:"
msgstr "这样做会产生以下行为:"

#: ../../docs/tutorials/3d/vertex_animation/controlling_thousands_of_fish.rst:141
msgid ""
"Using a ParticlesMaterial you can make the fish behavior as simple or "
"complex as you like. In this tutorial we only set Velocity, but in your own "
"Shaders you can also set ``COLOR``, rotation, scale (through ``TRANSFORM``). "
"Please refer to the :ref:`Particles Shader Reference <doc_particle_shader>` "
"for more information on particle shaders."
msgstr ""

#: ../../docs/tutorials/audio/index.rst:2
msgid "Audio"
msgstr "音频"

#: ../../docs/tutorials/audio/audio_buses.rst:4
#: ../../docs/tutorials/audio/audio_buses.rst:43
msgid "Audio buses"
msgstr "音频总线"

#: ../../docs/tutorials/audio/audio_buses.rst:9
msgid ""
"Beginning with Godot 3.0, the audio engine has been rewritten from scratch. "
"The aim now is to present an interface much friendlier to sound design "
"professionals. To achieve this, the audio engine contains a virtual rack "
"where unlimited audio buses can be created and, on each of it, unlimited "
"amount of effect processors can be added (or more like, as long as your CPU "
"holds up!)"
msgstr ""
"从Godot 3.0开始，音频引擎已经从头开始重写。 现在的目标是为声音设计专业人士提"
"供一个更友好的界面。 为实现这一目标，音频引擎包含一个虚拟机架，可以在其中创建"
"无限制的音频总线，并且可以在每个虚拟机架上添加无限量的效果处理器(或者更多，例"
"如，只要您的CPU保持稳定！)"

#: ../../docs/tutorials/audio/audio_buses.rst:16
msgid ""
"The implementation in Godot is pretty efficient and has been written "
"entirely from the ground up, without relying on any existing audio libraries."
msgstr ""
"Godot中的实现非常高效，完全是从头开始编写的，不依赖于任何现有的音频库。"

#: ../../docs/tutorials/audio/audio_buses.rst:19
#, fuzzy
msgid ""
"Even the effect processors were written exclusively for Godot (save for the "
"pitch shifting library), with games in mind. This allows an efficient "
"tradeoff between performance and sound quality."
msgstr ""
"即使是效果处理器也是专为Godot编写的(除了音高变换库)，考虑到游戏。 这允许在性"
"能和声音质量之间进行有效的权衡。"

#: ../../docs/tutorials/audio/audio_buses.rst:24
msgid "Decibel scale"
msgstr "分贝大小"

#: ../../docs/tutorials/audio/audio_buses.rst:26
msgid ""
"The new audio engine works primarily using the decibel scale. We have chosen "
"this over linear representation of amplitude because it's more intuitive for "
"audio professionals."
msgstr ""
"新的音频引擎主要使用分贝音阶。 我们选择了这种宽度的线性表示，因为它对于音频专"
"业人士来说更直观。"

#: ../../docs/tutorials/audio/audio_buses.rst:30
msgid "For those unfamiliar with it, it can be explained with a few facts:"
msgstr "对于那些不熟悉它的人，可以用一些事实来解释:"

#: ../../docs/tutorials/audio/audio_buses.rst:32
msgid ""
"The decibel (dB) scale is a relative scale. It represents the ratio of sound "
"power by using 10 times the base 10 logarithm of the ratio (10×log\\ :sub:"
"`10`\\ (P/P\\ :sub:`0`\\ ))."
msgstr ""
"分贝(dB)标度是相对标度。 它表示声功率的比例，使用10倍于基数10的对数比 (10×log"
"\\ :sub:`10`\\ (P/P\\ :sub:`0`\\ )) 。"

#: ../../docs/tutorials/audio/audio_buses.rst:33
msgid ""
"For every 3dB, sound doubles or halves. 6dB represents a factor 4, 9dB a "
"factor 8, 10dB a factor 10, 20dB a factor 100, etc."
msgstr ""
"对于每3dB，声音加倍或减半。 6dB表示因子4,9dB因子8,10dB因子10,20dB因子100等。"

#: ../../docs/tutorials/audio/audio_buses.rst:34
msgid ""
"Since the scale is logarithmic, true zero (no audio) can't be represented."
msgstr "由于比例是对数的，因此无法表示真零(无音频)。"

#: ../../docs/tutorials/audio/audio_buses.rst:35
#, fuzzy
msgid ""
"0dB is considered the maximum audible volume without *clipping*. This limit "
"is not the human limit, but a limit from the sound hardware. Your sound "
"output simply can't output any sound louder than 0dB without distorting it "
"(clipping it)."
msgstr ""
"0dB被认为是没有 *裁剪* 的最大可听音量。 此限制不是人为限制，而是声音硬件的限"
"制。 您的声音输出根本无法输出任何大于0dB的声音而不会扭曲它(削减它)。"

#: ../../docs/tutorials/audio/audio_buses.rst:36
msgid ""
"Because of the above, your sound mix should work in a way where the sound "
"output of the *Master Bus* (more on that later), should never be above 0dB."
msgstr ""
"由于上述原因，您的声音混音应该以 *Master Bus* 的声音输出(稍后更多)的方式工"
"作，不应超过0dB。"

#: ../../docs/tutorials/audio/audio_buses.rst:37
msgid ""
"Every 3dB below the 0dB limit, sound energy is *halved*. It means the sound "
"volume at -3dB is half as loud as 0dB. -6dB is half as loud as -3dB and so "
"on."
msgstr ""
"低于0dB限制的每3dB，声能 *减半* 。 这意味着-3dB的音量是0dB的一半。 -6dB是-3dB"
"的一半，依此类推。"

#: ../../docs/tutorials/audio/audio_buses.rst:38
msgid ""
"When working with decibels, sound is considered no longer audible between "
"-60dB and -80dB. This makes your working range generally between -60dB and "
"0dB."
msgstr ""
"使用分贝时，声音在-60dB和-80dB之间不再可听见。 这使您的工作范围通常在-60dB和"
"0dB之间。"

#: ../../docs/tutorials/audio/audio_buses.rst:40
msgid ""
"This can take a bit getting used to, but it's friendlier in the end and will "
"allow you to communicate better with audio professionals."
msgstr ""
"这可能需要一点时间习惯，但它最终会更友好，并允许您与音频专业人士更好地沟通。"

#: ../../docs/tutorials/audio/audio_buses.rst:45
#, fuzzy
msgid "Audio buses can be found in the bottom panel of the Godot Editor:"
msgstr "音频总线可以在Godot Editor的底部面板中找到:"

#: ../../docs/tutorials/audio/audio_buses.rst:49
msgid ""
"An *Audio Bus* bus (often called *Audio Channel* too) is a device where "
"audio is channeled. Audio data passes through it and can be *modified* and "
"*re-routed*. A VU meter (the bars that go up and down when sound is played) "
"can measure the loudness of the sound in Decibel scale."
msgstr ""
"*音频总线* 总线(通常也称为 *音频通道* )是一种音频通道的设备。 音频数据通过"
"它，可以 *修改* 和 *重新路由* 。 VU表(播放声音时上下的条)可以以分贝刻度测量声"
"音的响度。"

#: ../../docs/tutorials/audio/audio_buses.rst:51
msgid ""
"The leftmost bus is the *Master Bus*. This bus outputs the mix to your "
"speakers so, as mentioned in the item above (Decibel Scale), make sure that "
"your mix rarely or never goes above 0dB in this bus. The rest of the audio "
"buses are used for *routing*. This means that, after modifying the sound, "
"they must send it to another bus to the left. Routing is always from right "
"to left without exception as this avoids creating infinite routing loops!"
msgstr ""
"最左边的总线是 *Master Bus* 。 此总线将混音输出到您的扬声器，因此，如上面的项"
"目(分贝音阶)中所述，请确保您的混音在此总线中很少或永远不会超过0dB。 其余的音"
"频总线用于 *路由* 。 这意味着，在修改声音后，他们必须将它发送到左边的另一辆公"
"共汽车。 路由总是从右到左无一例外，因为这可以避免创建无限的路由循环！"

#: ../../docs/tutorials/audio/audio_buses.rst:57
#, fuzzy
msgid "In the above image, *Bus 2* is routing its output to the *Master* bus."
msgstr "在上图中，* Bus 2* 将其输出路由到 *Master* 总线。"

#: ../../docs/tutorials/audio/audio_buses.rst:60
msgid "Playback of audio to a bus"
msgstr "播放音频到总线"

#: ../../docs/tutorials/audio/audio_buses.rst:62
msgid ""
"To test playback to a bus, create an AudioStreamPlayer node, load an "
"AudioStream and select a target bus for playback:"
msgstr ""
"要测试回放到总线，请创建AudioStreamPlayer节点，加载AudioStream并选择要回放的"
"目标总线:"

#: ../../docs/tutorials/audio/audio_buses.rst:66
#, fuzzy
msgid "Finally, toggle the \"playing\" property to on and sound will flow."
msgstr "最后将“播放”属性切换为开启，声音将流动。"

#: ../../docs/tutorials/audio/audio_buses.rst:68
msgid ""
"You may also be interested in reading about :ref:`doc_audio-streams` now."
msgstr "您现在可能也有兴趣阅读 :ref:`doc_audio-streams` 。"

#: ../../docs/tutorials/audio/audio_buses.rst:71
msgid "Adding effects"
msgstr "添加特效"

#: ../../docs/tutorials/audio/audio_buses.rst:73
msgid ""
"Audio buses can contain all sorts of effects. These effects modify the sound "
"in one way or another and are applied in order."
msgstr "音频总线可以包含各种效果。 这些效果以某种方式修改声音并按顺序应用。"

#: ../../docs/tutorials/audio/audio_buses.rst:77
msgid "Following is a short description of available effects:"
msgstr "以下是可用效果的简短描述:"

#: ../../docs/tutorials/audio/audio_buses.rst:80
msgid "Amplify"
msgstr "Amplify"

#: ../../docs/tutorials/audio/audio_buses.rst:82
msgid ""
"It's the most basic effect. It changes the sound volume. Amplifying too much "
"can make the sound clip, so be wary of that."
msgstr ""
"这是最基本的效果。 它会改变音量。 放大太多可以使声音被修剪，所以要小心。"

#: ../../docs/tutorials/audio/audio_buses.rst:85
msgid "BandLimit and BandPass"
msgstr "BandLimit and BandPass"

#: ../../docs/tutorials/audio/audio_buses.rst:87
msgid ""
"These are resonant filters which block frequencies around the *Cutoff* "
"point. BandPass is resonant, while BandLimit stretches to the sides."
msgstr ""
"这些是谐振滤波器，可以阻止 *Cutoff * 点附近的频率。 BandPass是共鸣，而"
"BandLimit延伸到两侧。"

#: ../../docs/tutorials/audio/audio_buses.rst:90
msgid "Chorus"
msgstr "Chorus"

#: ../../docs/tutorials/audio/audio_buses.rst:92
msgid ""
"This effect adds extra voices, detuned by LFO and with a small delay, to add "
"more richness to the sound harmonics and stereo width."
msgstr ""
"这种效果增加了额外的声音，由LFO失谐并具有较小的延迟，为声音谐波和立体声宽度增"
"加了更多的丰富感。"

#: ../../docs/tutorials/audio/audio_buses.rst:95
msgid "Compressor"
msgstr "Compressor"

#: ../../docs/tutorials/audio/audio_buses.rst:97
msgid ""
"The aim of a dynamic range compressor is to reduce the level of the sound "
"when the amplitude goes over a certain threshold in Decibels. One of the "
"main uses of a compressor is to increase the dynamic range while clipping "
"the least possible (when sound goes over 0dB)."
msgstr ""
"动态范围压缩器的目的是当幅度超过分贝的某个阈值时降低声音的水平。 压缩器的主要"
"用途之一是增加动态范围，同时尽可能地削减(当声音超过0dB时)。"

#: ../../docs/tutorials/audio/audio_buses.rst:100
#, fuzzy
msgid "The compressor has many uses in the mix, for example:"
msgstr "Compressor可能会在混合中使用，例如:"

#: ../../docs/tutorials/audio/audio_buses.rst:102
#, fuzzy
msgid ""
"It can be used in the Master bus to compress the whole output (Although a "
"Limiter would probably be better)"
msgstr "它可以在主总线中用于压缩整个输出(尽管限制器可能更好)"

#: ../../docs/tutorials/audio/audio_buses.rst:103
msgid ""
"It can be used in voice channels to ensure they sound as even as possible."
msgstr "它可以在语音通道中使用，以确保它们尽可能地发声。"

#: ../../docs/tutorials/audio/audio_buses.rst:104
#, fuzzy
msgid ""
"It can be *Sidechained*. This means it can reduce the sound level using "
"another audio bus for threshold detection. This technique is very common in "
"video game mixing to download the level of Music/SFX while voices are being "
"heard."
msgstr ""
"它可以是 *Sidechained* 。 这意味着，它可以使用另一个音频总线降低声级以进行阈"
"值检测。 这种技术在视频游戏混合中很常见，可以在听到声音时下载Music/SFX 级别。"

#: ../../docs/tutorials/audio/audio_buses.rst:105
msgid ""
"It can accentuate transients by using a bit wider attack, meaning it can "
"make sound effects sound more punchy."
msgstr ""
"它可以通过使用更广泛的攻击来强调瞬态，这意味着它可以使声音效果听起来更有力。"

#: ../../docs/tutorials/audio/audio_buses.rst:107
#, fuzzy
msgid ""
"There is a lot of bibliography written about compressors, and the Godot "
"implementation is rather standard."
msgstr "有很多关于压缩器的参考书目，Godot的实现是相当标准的。"

#: ../../docs/tutorials/audio/audio_buses.rst:110
msgid "Delay"
msgstr "Delay"

#: ../../docs/tutorials/audio/audio_buses.rst:112
msgid ""
"Adds an \"Echo\" effect with a feedback loop. It can be used, together with "
"Reverb, to simulate wide rooms, canyons, etc. where sound bounces are far "
"apart."
msgstr ""
"使用反馈循环添加“Echo”效果。 它可以与Reverb一起用于模拟宽阔的房间，峡谷等，声"
"音反弹很远。"

#: ../../docs/tutorials/audio/audio_buses.rst:115
msgid "Distortion"
msgstr "Distortion"

#: ../../docs/tutorials/audio/audio_buses.rst:117
msgid ""
"Adds classical effects to modify the sound and make it dirty. Godot supports "
"effects like overdrive, tan, or bit crushing. For games, it can simulate "
"sound coming from some saturated device or speaker efficiently."
msgstr ""
"添加经典效果以修改声音并使其变脏。 Godot支持过载，棕褐色或比特压碎等效果。 对"
"于游戏，它可以有效地模拟来自某些饱和设备或扬声器的声音。"

#: ../../docs/tutorials/audio/audio_buses.rst:121
msgid "EQ6, EQ10, EQ21"
msgstr "EQ6, EQ10, EQ21"

#: ../../docs/tutorials/audio/audio_buses.rst:123
#, fuzzy
msgid ""
"Godot provides three models of equalizers with different band counts. "
"Equalizers are useful on the Master Bus to completely master a mix and give "
"it character. They are also useful when a game is run on a mobile device, to "
"adjust the mix to that kind of speakers (it can be added but disabled when "
"headphones are plugged)."
msgstr ""
"Godot提供三种具有不同频带数的均衡器模型。 均衡器在主总线上非常有用，可以完全"
"掌握混音并赋予其特性。 当在移动设备上运行游戏时，它们也很有用，可以调整混合到"
"那种扬声器(可以添加但是在插入耳机时禁用)。"

#: ../../docs/tutorials/audio/audio_buses.rst:127
msgid "HighPassFilter, HighShelfFilter"
msgstr "HighPassFilter, HighShelfFilter"

#: ../../docs/tutorials/audio/audio_buses.rst:129
#, fuzzy
msgid ""
"These are filters that cut frequencies below a specific *Cutoff*. A common "
"use of high pass filters is to add it to effects (or voice) that were "
"recorded too close to a mic and need to sound more realistic. It is commonly "
"used for some types of environment, like space."
msgstr ""
"这些滤波器可将频率降至特定 *截止值* 以下。 高通滤波器的一个常见用途是将其添加"
"到效果(或声音)中，这些效果(或声音)记录得太近麦克风并且需要听起来更逼真。 它通"
"常用于某些类型的环境，如空间。"

#: ../../docs/tutorials/audio/audio_buses.rst:133
msgid "Limiter"
msgstr "Limiter"

#: ../../docs/tutorials/audio/audio_buses.rst:135
msgid ""
"A limiter is similar to a compressor, but it's less flexible and designed to "
"disallow sound going over a given dB threshold. Adding one in the *Master "
"Bus* is always recommended to reduce the effects of clipping."
msgstr ""
"限制器类似于压缩器，但它的灵活性较差，旨在禁止声音超过给定的dB阈值。 始终建议"
"在 *主总线* 中添加一个以减少削波的影响。"

#: ../../docs/tutorials/audio/audio_buses.rst:139
msgid "LowPassFilter, LowShelfFilter"
msgstr "LowPassFilter, LowShelfFilter"

#: ../../docs/tutorials/audio/audio_buses.rst:141
msgid ""
"These are the most common filters, they cut frequencies above a specific "
"*Cutoff* and can also resonate. They can be used for a wide amount of "
"effects, from underwater sound to simulating a sound coming from far away."
msgstr ""
"这些是最常见的滤波器，它们将频率切换到特定 *截止* 以上，并且还可以产生共振。 "
"它们可用于广泛的效果，从水下声音到模拟来自遥远的声音。"

#: ../../docs/tutorials/audio/audio_buses.rst:145
msgid "NotchFilter"
msgstr "NotchFilter"

#: ../../docs/tutorials/audio/audio_buses.rst:147
msgid ""
"The opposite to the BandPassFilter, it removes a band of sound from the "
"frequency spectrum at a given *Cutoff*."
msgstr "与BandPassFilter相反，它在给定的 *Cutoff* 处从频谱中移除一段声音。"

#: ../../docs/tutorials/audio/audio_buses.rst:150
msgid "Panner"
msgstr "Panner"

#: ../../docs/tutorials/audio/audio_buses.rst:152
msgid "This is a simple helper to pan sound left or right."
msgstr "这是一个向左或向右平移声音的简单帮手。"

#: ../../docs/tutorials/audio/audio_buses.rst:155
msgid "Phaser"
msgstr "Phaser"

#: ../../docs/tutorials/audio/audio_buses.rst:157
msgid ""
"It probably does not make much sense to explain that this effect is formed "
"by two signals being dephased and cancelling each other out. It will be "
"sufficient to note that you can make a Darth Vader voice with it, or jet-"
"like sounds."
msgstr ""
"解释这种效应是由两个信号相互脱离并相互抵消而形成的，这可能没什么意义。 只需注"
"意您可以用它制作Darth Vader声音，或类似喷射的声音。"

#: ../../docs/tutorials/audio/audio_buses.rst:161
msgid "PitchShift"
msgstr "PitchShift"

#: ../../docs/tutorials/audio/audio_buses.rst:163
msgid ""
"This effect allows for modulating pitch independently of tempo. All "
"frequencies can be increased/decreased with minimal effect on transients. "
"Can be used for effects such as voice modulation."
msgstr ""
"这种效果允许独立于节奏调节音高。 所有频率都可以增加/减少，对瞬态影响最小。 可"
"用于语音调制等效果。"

#: ../../docs/tutorials/audio/audio_buses.rst:166
msgid "Reverb"
msgstr "Reverb"

#: ../../docs/tutorials/audio/audio_buses.rst:168
msgid ""
"Reverb simulates rooms of different sizes. It has adjustable parameters that "
"can be tweaked to obtain the sound of a specific room. Reverb is commonly "
"outputted from :ref:`Areas <class_Area>` (see :ref:`doc_audio-streams` "
"tutorial, look for the \"Reverb buses\" section), or to apply chamber feel "
"to all sounds."
msgstr ""
"混响模拟不同大小的房间。 它具有可调节的参数，可以调整以获得特定房间的声音。 "
"混响通常从以下输出 :ref:`Areas <class_Area>` (参见 :ref:`doc_audio-streams` "
"教程，寻找“Reverb bus”部分)，或者对所有声音应用腔室感觉。"

#: ../../docs/tutorials/audio/audio_buses.rst:172
msgid "StereoEnhance"
msgstr "StereoEnhance"

#: ../../docs/tutorials/audio/audio_buses.rst:174
msgid ""
"This effect has a few algorithms available to enhance the stereo spectrum, "
"in case this is needed."
msgstr "如果需要，这种效果有一些可用于增强立体声频谱的算法。"

#: ../../docs/tutorials/audio/audio_buses.rst:177
msgid "Automatic bus disabling"
msgstr "自动总线禁用"

#: ../../docs/tutorials/audio/audio_buses.rst:179
#, fuzzy
msgid ""
"There is no need to disable buses manually when not in use; Godot detects "
"that the bus has been silent for a few seconds and disables it (including "
"all effects)."
msgstr ""
"没有必要在不使用时手动禁用总线，Godot检测到总线已经静音几秒钟并禁用它(包括所"
"有效果)。"

#: ../../docs/tutorials/audio/audio_buses.rst:183
msgid "Disabled buses have a blue VU meter."
msgstr "禁止总线有蓝色VU表。"

#: ../../docs/tutorials/audio/audio_buses.rst:186
msgid "Bus rearrangement"
msgstr "总线重排"

#: ../../docs/tutorials/audio/audio_buses.rst:188
msgid ""
"Stream Players use bus names to identify a bus, which allows adding, "
"removing and moving buses around while the reference to them is kept. If a "
"bus is renamed, however, the reference will be lost and the Stream Player "
"will output to Master. This system was chosen because rearranging buses is a "
"more common process than renaming them."
msgstr ""
"流播放器使用总线名称来识别总线，这允许在保持对它们的引用的同时添加，移除和移"
"动总线。 但是，如果重命名总线，则引用将丢失，并且Stream Player将输出到"
"Master。 之所以选择这个系统是因为重新排列总线是比重命名它们更常见的过程。"

#: ../../docs/tutorials/audio/audio_buses.rst:192
msgid "Default bus layout"
msgstr "默认总线布局"

#: ../../docs/tutorials/audio/audio_buses.rst:194
#, fuzzy
msgid ""
"The default bus layout is automatically saved to the ``res://"
"default_bus_layout.tres`` file. Other bus layouts can be saved to/retrieved "
"from files in case of having to change snapshots, but in most cases, this is "
"not necessary."
msgstr ""
"默认总线布局自动保存到 ``res:// default_bus_layout.tres`` 文件中。 在必须更改"
"快照的情况下，可以从文件中保存/检索其他总线布局，但在大多数情况下，这不是必需"
"的。"

#: ../../docs/tutorials/audio/audio_streams.rst:4
msgid "Audio streams"
msgstr "音频流"

#: ../../docs/tutorials/audio/audio_streams.rst:9
#, fuzzy
msgid ""
"As you might have already read in the :ref:`Audio Buses Tutorial<doc_audio-"
"buses>` , sound is sent to each bus via an AudioStreamPlayer."
msgstr ""
"您可能已经阅读过 :ref:`Audio Buses Tutorial <doc_audio-bus>` ，声音通过"
"AudioStreamPlayer发送到每个总线。"

#: ../../docs/tutorials/audio/audio_streams.rst:12
#, fuzzy
msgid ""
"There are many types of AudioStreamPlayer, which will be explained in "
"detail. Each one loads an AudioStream and plays it back."
msgstr ""
"有许多类型的AudioStreamPlayers将详细解释。 每个都加载一个AudioStream并播放"
"它。"

#: ../../docs/tutorials/audio/audio_streams.rst:16
msgid "AudioStream"
msgstr "音频流"

#: ../../docs/tutorials/audio/audio_streams.rst:18
#, fuzzy
msgid ""
"An audio stream is an abstract object that emits sound. It can come from "
"many places, but most commonly from the filesystem. Audio files, such as ."
"wav or .ogg, can be loaded as AudioStreams and placed inside an "
"AudioStreamPlayer."
msgstr ""
"音频流是发出声音的抽象对象。 它可以来自许多地方，但最常见的是来自文件系统。 "
"诸如.wav或.ogg之类的音频文件可以作为AudioStream加载并放在AudioStreamPlayer"
"中。"

#: ../../docs/tutorials/audio/audio_streams.rst:22
#, fuzzy
msgid ""
"Here is a comparison of the two, to help you choose which one fits your "
"specific use case best:"
msgstr "使用这些类型的文件时，您应该选择哪一个最适合您的特定用例:"

#: ../../docs/tutorials/audio/audio_streams.rst:24
#, fuzzy
msgid ""
"Audio files of type *.wav* are quite large, but use little CPU power to play "
"back. Hundreds of them can be played simultaneously with little impact to "
"performance. This format is usually best for short sound effects, as the "
"importer will trim and convert them to IMA-ADPCM."
msgstr ""
"* .wav * 类型的音频文件相当大，但使用少量的CPU来播放。 其中数百个可以同时播"
"放，对性能影响不大。 这种格式通常最适合短音效，因为导入器会修剪它们并将它们转"
"换为IMA-ADPCM。"

#: ../../docs/tutorials/audio/audio_streams.rst:25
#, fuzzy
msgid ""
"Audio files of type *.ogg* are much smaller, but use considerably more CPU "
"power to play back, so only a few can be played back (especially on "
"mobile!). This format is usually best for music or long sound effect "
"sequences. It also works well for voice at relatively low bitrates."
msgstr ""
"* .ogg * 类型的音频文件要小得多，但要回放使用相当多的CPU功率，因此只能播放少"
"量(特别是在移动设备上！)。 这种格式通常最适合音乐或长音效序列。 它也适用于比"
"特率相对较低的语音。"

#: ../../docs/tutorials/audio/audio_streams.rst:27
#, fuzzy
msgid ""
"Keep in mind neither .wav nor .ogg usually contains looping information, so "
"this information must be set on the import options of each:"
msgstr ""
"请记住.wav和.ogg通常不包含循环信息，因此必须在每个的导入选项上设置此信息:"

#: ../../docs/tutorials/audio/audio_streams.rst:31
#, fuzzy
msgid ""
"There are other types of AudioStream, such as AudioStreamRandomPitch, which "
"takes an existing AudioStream and modulates the pitch every time it's played "
"back randomly (great for some sound effects), and more will keep appearing "
"in the future."
msgstr ""
"还有其他类型的AudioStream，例如AudioStreamRandomPitch，它可以接收现有的"
"AudioStream，并在每次随机播放时调整音高(对于某些音效非常有用)，并且将来还会出"
"现更多音频。"

#: ../../docs/tutorials/audio/audio_streams.rst:35
msgid "AudioStreamPlayer"
msgstr "AudioStreamPlayer"

#: ../../docs/tutorials/audio/audio_streams.rst:37
#, fuzzy
msgid ""
"This is the standard stream player; it can play to any given bus. In 5.1 "
"sound, it can send to stereo mix or front speakers."
msgstr ""
"这是标准的流播放器，它可以播放任何给定的总线。 在5.1声音中，它可以发送到立体"
"声混音或前置扬声器。"

#: ../../docs/tutorials/audio/audio_streams.rst:40
msgid "AudioStreamPlayer2D"
msgstr "AudioStreamPlayer2D"

#: ../../docs/tutorials/audio/audio_streams.rst:42
#, fuzzy
msgid ""
"This is a variant of AudioStreamPlayer, but emits sound in a 2D positional "
"environment. When close to the left of the screen, the panning will go left. "
"When close to the right side, it will go right."
msgstr ""
"这是AudioStreamPlayer的变体，但在2D位置环境中发出声音。 当靠近屏幕左侧时，平"
"移将向左移动。 当靠近右侧时，它会向右移动."

#: ../../docs/tutorials/audio/audio_streams.rst:44
#, fuzzy
msgid ""
"While it's possible to send these effects to specific audio buses, one of "
"the best strategies is to use an Area2D to divert sound to a specific bus. "
"This allows you to create buses with different reverb or sound qualities and "
"make it so the emitter will automatically send to them when entering the "
"Area2D shapes."
msgstr ""
"虽然可以将这些效果发送到特定的音频总线，但最好的策略之一是使用Area2D将声音转"
"移到特定的总线。 这允许创建具有不同混响或声音质量的总线，并使得发射器在进入"
"Area2D形状时自动发送给它们。"

#: ../../docs/tutorials/audio/audio_streams.rst:50
msgid "AudioStreamPlayer3D"
msgstr "AudioStreamPlayer3D"

#: ../../docs/tutorials/audio/audio_streams.rst:52
#, fuzzy
msgid ""
"This is a variant of AudioStreamPlayer, but emits sound in a 3D positional "
"environment. Depending on the location of the player relative to the screen, "
"it can position sound in Stereo, 5.1 or 7.1 depending on the chosen audio "
"setup."
msgstr ""
"这是AudioStreamPlayer的变体，但在3D位置环境中发出声音。 根据播放器相对于屏幕"
"的位置，它可以根据所选的音频设置将声音定位在立体声，5.1或7.1中。"

#: ../../docs/tutorials/audio/audio_streams.rst:55
msgid ""
"Similar to AudioStreamPlayer2D, an Area can divert the sound to an audio bus."
msgstr "与AudioStreamPlayer2D类似，Area可以将声音转移到音频总线。"

#: ../../docs/tutorials/audio/audio_streams.rst:59
msgid ""
"Unlike for 2D, the 3D version of AudioStreamPlayer has a few more advanced "
"options:"
msgstr "与2D不同，AudioStreamPlayer的3D版本有一些更高级的选项:"

#: ../../docs/tutorials/audio/audio_streams.rst:62
msgid "Reverb buses"
msgstr "混响总线"

#: ../../docs/tutorials/audio/audio_streams.rst:64
msgid ""
"Godot allows 3D Audio Streams that enter a specific *Area* to send dry and "
"wet audio to separate buses. This is useful when you have several reverb "
"configurations for different types of rooms. This is done by enabling this "
"type of reverb in the *Reverb Bus* section of *Area* properties:"
msgstr ""
"Godot允许进入特定 *Area* 的3D音频流将干湿音频发送到单独的总线。 当您为不同类"
"型的房间设置多个混响配置时，这非常有用。 这是通过在 *Area* 属性的 *Reverb "
"Bus* 部分中启用此类混响来完成的:"

#: ../../docs/tutorials/audio/audio_streams.rst:69
msgid ""
"At the same time, a special bus layout is created where each area receives "
"the reverb info from each area. Of course, an actual Reverb effect must be "
"created in that bus for anything to happen:"
msgstr ""
"同时，创建一个特殊的总线布局，每个区域从每个区域接收混响信息。 当然，必须在该"
"总线中创建实际的混响效果才能发生任何事情:"

#: ../../docs/tutorials/audio/audio_streams.rst:73
#, fuzzy
msgid ""
"The Area Reverb Bus section also has a specific parameter named \"Uniformity"
"\". Some types of rooms bounce sounds more than others (like for example, a "
"typical warehouse), so reverberation can be heard almost uniformly across "
"the room even though the source is far away. Playing around with this "
"parameter can simulate that effect."
msgstr ""
"Area Reverb Bus部分还有一个名为“Uniformity”的特定参数。 有些类型的房间比其他"
"类型的房间反弹声音更多(例如，典型的仓库)，因此即使光源很远，也可以在房间内几"
"乎均匀地听到混响。 使用此参数可以模拟该效果。"

#: ../../docs/tutorials/audio/audio_streams.rst:77
msgid "Doppler"
msgstr "多普勒"

#: ../../docs/tutorials/audio/audio_streams.rst:79
msgid ""
"When the relative velocity between an emitter and listener changes, this is "
"perceived as an increase or decrease of the pitch shift. Godot can track "
"changes in velocities of *AudioStreamPlayer3D* or *Camera*. Both have this "
"property, which must be enabled manually:"
msgstr ""
"当发射器和收听者之间的相对速度改变时，这被认为是音调移位的增加或减少。 Godot"
"可以跟踪 * AudioStreamPlayer3D* 或 *Camera* 的速度变化。 两者都有此属性，必须"
"手动启用:"

#: ../../docs/tutorials/audio/audio_streams.rst:84
msgid ""
"Simply enable it by setting it depending on how objects will be moved "
"(whether on regular *process* or *physics_process* step) and the tracking "
"will happen automatically!"
msgstr ""
"只需根据对象的移动方式(无论是常规 *process* 还是 *physics_process* 步骤)进行"
"设置即可启用它，并且跟踪将自动进行！"

#: ../../docs/tutorials/physics/physics_introduction.rst:4
msgid "Physics introduction"
msgstr "物理介绍"

#: ../../docs/tutorials/physics/physics_introduction.rst:6
#, fuzzy
msgid ""
"In game development, you often need to know when two objects in the game "
"intersect or come into contact. This is known as **collision detection**. "
"When a collision is detected, you typically want something to happen. This "
"is known as **collision response**."
msgstr ""
"在游戏开发中，您经常需要知道游戏中的两个对象何时相交或接触。 这被称为 **碰撞"
"检测** 。 检测到碰撞时，您通常希望发生某些事情。 这被称为 **碰撞响应** 。"

#: ../../docs/tutorials/physics/physics_introduction.rst:11
msgid ""
"Godot offers a number of collision objects in 2D and 3D to provide both "
"collision detection and response. Trying to decide which one to use for your "
"project can be confusing. You can avoid problems and simplify development if "
"you understand how each works and what their pros and cons are."
msgstr ""
"Godot在2D和3D中提供了许多碰撞对象，以提供碰撞检测和响应。 试图决定哪一个用于"
"您的项目可能会令人困惑。 如果您了解每种方法的工作原理以及它们的优缺点，您可以"
"避免出现问题并简化开发。"

#: ../../docs/tutorials/physics/physics_introduction.rst:18
msgid "Godot's four collision object types"
msgstr "Godot的四种碰撞对象类型"

#: ../../docs/tutorials/physics/physics_introduction.rst:19
msgid "How each collision object works"
msgstr "每个碰撞对象的工作原理"

#: ../../docs/tutorials/physics/physics_introduction.rst:20
msgid "When and why to choose one type over another"
msgstr "何时以及为何选择这种类型而不是另一种类型"

#: ../../docs/tutorials/physics/physics_introduction.rst:22
msgid ""
"This document's examples will use 2D objects. Every 2D physics object and "
"collision shape has a direct equivalent in 3D and in most cases they work in "
"much the same way."
msgstr ""
"本文档的示例将使用2D对象。 每个2D物理对象和碰撞形状在3D中具有直接等价物，并且"
"在大多数情况下它们以相同的方式工作。"

#: ../../docs/tutorials/physics/physics_introduction.rst:27
#, fuzzy
msgid "Collision objects"
msgstr "碰撞对象"

#: ../../docs/tutorials/physics/physics_introduction.rst:29
msgid ""
"Godot offers four kinds of physics bodies, extending :ref:`CollisionObject2D "
"<class_CollisionObject2D>`:"
msgstr ""
"Godot提供了四种扩展自 :ref:`CollisionObject2D <class_CollisionObject2D>` 的物"
"体:"

#: ../../docs/tutorials/physics/physics_introduction.rst:35
msgid ":ref:`Area2D <class_Area2D>`"
msgstr ":ref:`Area2D <class_Area2D>`"

#: ../../docs/tutorials/physics/physics_introduction.rst:32
#, fuzzy
msgid ""
"``Area2D`` nodes provide **detection** and **influence**. They can detect "
"when objects overlap and can emit signals when bodies enter or exit. An "
"``Area2D`` can also be used to override physics properties, such as gravity "
"or damping, in a defined area."
msgstr ""
"``Area2D`` 节点提供 **检测** 和 **影响** 。 它们可以检测物体何时重叠，并在物"
"体进入或离开时发出信号。 “Area2D”也可用于覆盖物理属性，例如定义区域中的重力或"
"阻尼。"

#: ../../docs/tutorials/physics/physics_introduction.rst:37
msgid ""
"The other three bodies extend :ref:`PhysicsBody2D <class_PhysicsBody2D>`:"
msgstr "其他三个物体扩展自 :ref:`PhysicsBody2D <class_PhysicsBody2D>` ："

#: ../../docs/tutorials/physics/physics_introduction.rst:43
msgid ":ref:`StaticBody2D <class_StaticBody2D>`"
msgstr ":ref:`StaticBody2D <class_StaticBody2D>`"

#: ../../docs/tutorials/physics/physics_introduction.rst:40
msgid ""
"A static body is one that is not moved by the physics engine. It "
"participates in collision detection, but does not move in response to the "
"collision. They are most often used for objects that are part of the "
"environment or that do not need to have any dynamic behavior."
msgstr ""
"静态主体是物理引擎不移动的主体。 它参与碰撞检测，但不会响应碰撞而移动。 它们"
"通常用于属于环境的对象或不需要任何动态行为的对象。"

#: ../../docs/tutorials/physics/physics_introduction.rst:48
msgid ":ref:`RigidBody2D <class_RigidBody2D>`"
msgstr ":ref:`RigidBody2D <class_RigidBody2D>`"

#: ../../docs/tutorials/physics/physics_introduction.rst:46
msgid ""
"This is the node that implements simulated 2D physics. You do not control a "
"``RigidBody2D`` directly, but instead you apply forces to it (gravity, "
"impulses, etc.) and the physics engine calculates the resulting movement. :"
"ref:`Read more about using rigid bodies. <doc_rigid_body>`"
msgstr ""
"这是实现模拟2D物理的节点。 您不直接控制 ``RigidBody2D`` ，而是您对它施加力(重"
"力，冲动等)，物理引擎计算得到的运动。 :ref:`阅读更多关于使用刚体的信息。 "
"<doc_rigid_body>`"

#: ../../docs/tutorials/physics/physics_introduction.rst:52
msgid ":ref:`KinematicBody2D <class_KinematicBody2D>`"
msgstr ":ref:`KinematicBody2D <class_KinematicBody2D>`"

#: ../../docs/tutorials/physics/physics_introduction.rst:51
msgid ""
"A body that provides collision detection, but no physics. All movement and "
"collision response must be implemented in code."
msgstr ""
"提供碰撞检测的物体，但没有物理特性。 所有移动和碰撞响应必须在代码中实现。"

#: ../../docs/tutorials/physics/physics_introduction.rst:57
msgid ""
"A physics body can hold any number of :ref:`Shape2D <class_Shape2D>` objects "
"as children. These shapes are used to define the object's collision bounds "
"and to detect contact with other objects."
msgstr ""
"物理体可以包含任意数量的 :ref:`Shape2D <class_Shape2D>` 对象作为子对象。 这些"
"形状用于定义对象的碰撞边界并检测与其他对象的接触。"

#: ../../docs/tutorials/physics/physics_introduction.rst:61
msgid ""
"In order to detect collisions, at least one ``Shape2D`` must be assigned to "
"the object."
msgstr "为了检测碰撞，必须至少为对象分配一个“Shape2D”。"

#: ../../docs/tutorials/physics/physics_introduction.rst:64
msgid ""
"The most common way to assign a shape is by adding a :ref:`CollisionShape2D "
"<class_CollisionShape2D>` or :ref:`CollisionPolygon2D "
"<class_CollisionPolygon2D>` as a child of the object. These nodes allow you "
"to draw the shape directly in the editor workspace."
msgstr ""
"分配形状的最常用方法是添加 :ref:`CollisionShape2D <class_CollisionShape2D>` "
"或 :ref:`CollisionPolygon2D <class_CollisionPolygon2D>` 作为对象的子项。 这些"
"节点允许您直接在编辑器工作区中绘制形状。"

#: ../../docs/tutorials/physics/physics_introduction.rst:68
#, fuzzy
msgid ""
"Be careful to never scale your collision shapes in the editor. The \"Scale\" "
"property in the Inspector should remain ``(1, 1)``. When changing the size "
"of the collision shape, you should always use the size handles, **not** the "
"``Node2D`` scale handles. Scaling a shape can result in unexpected collision "
"behavior."
msgstr ""
"小心不要在编辑器中缩放碰撞形状。 属性面板中的“Scale”属性应保持为 ``(1, "
"1)``。 当改变大小调整碰撞形状时，您应该总是使用大小手柄，**而不是 ``Node2D`` "
"缩放手柄。 缩放形状可能会导致意外的碰撞行为。"

#: ../../docs/tutorials/physics/physics_introduction.rst:77
msgid "Physics process callback"
msgstr "物理过程回调"

#: ../../docs/tutorials/physics/physics_introduction.rst:79
msgid ""
"The physics engine may spawn multiple threads to improve performance, so it "
"can use up to a full frame to process physics. Because of this, the value of "
"a body's state variables such as ``position`` or ``linear velocity`` may not "
"be accurate for the current frame."
msgstr ""
"物理引擎可能会产生多个线程以提高性能，因此它可以使用最多一个帧来处理物理。 因"
"此，物体状态变量(如“位置”)或“线速度”的值可能对当前帧不准确。"

#: ../../docs/tutorials/physics/physics_introduction.rst:84
#, fuzzy
msgid ""
"In order to avoid this inaccuracy, any code that needs to access a body's "
"properties should be run in the :ref:`Node._physics_process() "
"<class_Node_method__physics_process>` callback, which is called before each "
"physics step at a constant frame rate (60 times per second by default)."
msgstr ""
"为了避免这种不准确性，任何需要访问物体属性的代码都应该在 :ref:`Node."
"_physics_process()<class_Node_method__physics_process>` 回调中运行，该回调在"
"每个物理步骤之前以恒定的帧速率调用(60 默认情况下每秒的时间)。"

#: ../../docs/tutorials/physics/physics_introduction.rst:90
#, fuzzy
msgid "Collision layers and masks"
msgstr "碰撞层与遮罩"

#: ../../docs/tutorials/physics/physics_introduction.rst:92
#, fuzzy
msgid ""
"One of the most powerful, but frequently misunderstood, collision features "
"is the collision layer system. This system allows you to build up complex "
"interactions between a variety of objects. The key concepts are **layers** "
"and **masks**. Each ``CollisionObject2D`` has 20 different physics layers it "
"can interact with."
msgstr ""
"碰撞层系统是最强大但经常被误解的碰撞特征之一。 该系统允许您在各种对象之间建立"
"复杂的交互。 关键概念是 **层** 和 **遮罩** 。 每个 ``CollisionObject2D`` 都有"
"20个不同的物理层，它可以与之交互。"

#: ../../docs/tutorials/physics/physics_introduction.rst:98
msgid "Let's look at each of the properties in turn:"
msgstr "让我们依次看看每个属性:"

#: ../../docs/tutorials/physics/physics_introduction.rst:102
msgid "collision_layer"
msgstr "collision_layer"

#: ../../docs/tutorials/physics/physics_introduction.rst:101
msgid ""
"This describes the layers that the object appears **in**. By default, all "
"bodies are on layer ``1``."
msgstr "这描述了对象在 **中出现的图层** 。 默认情况下，所有实体都在图层“1”上。"

#: ../../docs/tutorials/physics/physics_introduction.rst:107
msgid "collision_mask"
msgstr "collision_mask"

#: ../../docs/tutorials/physics/physics_introduction.rst:105
msgid ""
"This describes what layers the body will **scan** for collisions. If an "
"object isn't in one of the mask layers, the body will ignore it. By default, "
"all bodies scan layer ``1``."
msgstr ""
"这描述了物体将 **扫描** 以进行碰撞的层。 如果对象不在其中一个遮罩层中，则物体"
"将忽略它。 默认情况下，所有实体都扫描图层是 ``1``。"

#: ../../docs/tutorials/physics/physics_introduction.rst:109
msgid ""
"These properties can be configured via code, or by editing them in the "
"Inspector."
msgstr "可以通过代码配置这些属性，也可以在Inspector中对其进行编辑。"

#: ../../docs/tutorials/physics/physics_introduction.rst:111
msgid ""
"Keeping track of what you're using each layer for can be difficult, so you "
"may find it useful to assign names to the layers you're using. Names can be "
"assigned in Project Settings -> Layer Names."
msgstr ""
"跟踪您正在使用每个图层的内容可能很困难，因此您可能会发现为您正在使用的图层指"
"定名称很有用。 可以在“项目设置” ->“图层名称”中指定名称。"

#: ../../docs/tutorials/physics/physics_introduction.rst:117
msgid "**Example:**"
msgstr "**示例:**"

#: ../../docs/tutorials/physics/physics_introduction.rst:119
msgid ""
"You have four node types in your game: Walls, Player, Enemy, and Coin. Both "
"Player and Enemy should collide with Walls. The Player node should detect "
"collisions with both Enemy and Coin, but Enemy and Coin should ignore each "
"other."
msgstr ""
"游戏中有四种节点类型:Walls，Player，Enemy和Coin。 游戏角色和敌人都应该与沃尔"
"斯碰撞。 游戏角色节点应该检测与敌人和硬币的碰撞，但敌人和硬币应该互相忽略。"

#: ../../docs/tutorials/physics/physics_introduction.rst:124
msgid ""
"Start by naming layers 1-4 \"walls\", \"player\", \"enemies\", and \"coins\" "
"and place each node type in its respective layer using the \"Layer\" "
"property. Then set each node's \"Mask\" property by selecting the layers it "
"should interact with. For example, the Player's settings would look like "
"this:"
msgstr ""
"首先命名1-4层“墙”，“游戏角色”，“敌人”和“硬币”，然后使用“图层”属性将每个节点类"
"型放在其各自的图层中。 然后通过选择应与之交互的图层来设置每个节点的“Mask”属"
"性。 例如，游戏角色的设置如下所示:"

#: ../../docs/tutorials/physics/physics_introduction.rst:133
msgid "Area2D"
msgstr "Area2D"

#: ../../docs/tutorials/physics/physics_introduction.rst:135
#, fuzzy
msgid ""
"Area nodes provide **detection** and **influence**. They can detect when "
"objects overlap and emit signals when bodies enter or exit. Areas can also "
"be used to override physics properties, such as gravity or damping, in a "
"defined area."
msgstr ""
"区域节点提供 **检测** 和 **影响** 。 它们可以检测物体何时重叠并在物体进入或离"
"开时发出信号。 区域也可用于覆盖物理属性，例如定义区域中的重力或阻尼。"

#: ../../docs/tutorials/physics/physics_introduction.rst:140
msgid "There are three main uses for :ref:`Area2D <class_Area2D>`:"
msgstr "有三个主要用途 :ref:`Area2D <class_Area2D>`:"

#: ../../docs/tutorials/physics/physics_introduction.rst:142
#, fuzzy
msgid "Overriding physics parameters (such as gravity) in a given region."
msgstr "覆盖物理参数，例如给定区域中的重力。"

#: ../../docs/tutorials/physics/physics_introduction.rst:144
msgid ""
"Detecting when other bodies enter or exit a region or what bodies are "
"currently in a region."
msgstr "检测其他实体何时进入或退出某个区域或当前哪个实体位于某个区域。"

#: ../../docs/tutorials/physics/physics_introduction.rst:146
msgid "Checking other areas for overlap."
msgstr "检查其他区域是否重叠。"

#: ../../docs/tutorials/physics/physics_introduction.rst:148
msgid "By default, areas also receive mouse and touchscreen input."
msgstr "默认情况下，区域还会接收鼠标和触摸屏输入。"

#: ../../docs/tutorials/physics/physics_introduction.rst:151
msgid "StaticBody2D"
msgstr "StaticBody2D"

#: ../../docs/tutorials/physics/physics_introduction.rst:153
msgid ""
"A static body is one that is not moved by the physics engine. It "
"participates in collision detection, but does not move in response to the "
"collision. However, it can impart motion or rotation to a colliding body "
"**as if** it were moving, using its ``constant_linear_velocity`` and "
"``constant_angular_velocity`` properties."
msgstr ""
"静态主体是物理引擎不移动的主体。 它参与碰撞检测，但不会响应碰撞而移动。 然"
"而，它可以使用它的 ``constant_linear_velocity`` 和"
"``constant_angular_velocity``属性将运动或旋转传递给碰撞体**，好像它正在移动一"
"样。"

#: ../../docs/tutorials/physics/physics_introduction.rst:158
msgid ""
"``StaticBody2D`` nodes are most often used for objects that are part of the "
"environment or that do not need to have any dynamic behavior."
msgstr "``StaticBody2D``节点最常用于属于环境的对象或不需要任何动态行为的对象。"

#: ../../docs/tutorials/physics/physics_introduction.rst:161
msgid "Example uses for ``StaticBody2D``:"
msgstr "“StaticBody2D”的示例用法:"

#: ../../docs/tutorials/physics/physics_introduction.rst:163
msgid "Platforms (including moving platforms)"
msgstr "平台(包括移动平台)"

#: ../../docs/tutorials/physics/physics_introduction.rst:164
msgid "Conveyor belts"
msgstr "输送带"

#: ../../docs/tutorials/physics/physics_introduction.rst:165
msgid "Walls and other obstacles"
msgstr "墙壁和其他障碍"

#: ../../docs/tutorials/physics/physics_introduction.rst:168
msgid "RigidBody2D"
msgstr "RigidBody2D"

#: ../../docs/tutorials/physics/physics_introduction.rst:170
#, fuzzy
msgid ""
"This is the node that implements simulated 2D physics. You do not control a :"
"ref:`RigidBody2D <class_RigidBody2D>` directly. Instead, you apply forces to "
"it and the physics engine calculates the resulting movement, including "
"collisions with other bodies, and collision responses, such as bouncing, "
"rotating, etc."
msgstr ""
"这是实现模拟2D物理的节点。 您不直接控制 :ref:`RigidBody2D "
"<class_RigidBody2D>` 。 相反，您对它施加力，物理引擎计算得到的运动，包括与其"
"他物体的碰撞，以及碰撞响应，如弹跳，旋转等。"

#: ../../docs/tutorials/physics/physics_introduction.rst:176
msgid ""
"You can modify a rigid body's behavior via  properties such as \"Mass\", "
"\"Friction\", or \"Bounce\", which can be set in the Inspector."
msgstr ""
"您可以通过“质量”，“摩擦力”或“弹跳”等属性修改刚体的行为，这些属性可以在属性面"
"板中设置。"

#: ../../docs/tutorials/physics/physics_introduction.rst:179
msgid ""
"The body's behavior is also affected by the world's properties, as set in "
"`Project Settings -> Physics`, or by entering an :ref:`Area2D "
"<class_Area2D>` that is overriding the global physics properties."
msgstr ""
"物体的行为也受到“项目设置 ->物理学”中设置的世界属性的影响，或者通过输入覆盖全"
"局物理属性的 :ref:`Area2D <class_Area2D>` 。"

#: ../../docs/tutorials/physics/physics_introduction.rst:183
#, fuzzy
msgid ""
"When a rigid body is at rest and hasn't moved for a while, it goes to sleep. "
"A sleeping body acts like a static body, and its forces are not calculated "
"by the physics engine. The body will wake up when forces are applied, either "
"by a collision or via code."
msgstr ""
"当刚体处于静止状态并且一段时间没有移动时，它会进入睡眠状态。 沉睡的物体就像一"
"个静止的物体，它的力量不是由物理引擎计算的。 当施加力时，通过碰撞或通过代码，"
"物体将被唤醒。"

#: ../../docs/tutorials/physics/physics_introduction.rst:189
msgid "Rigid body modes"
msgstr "刚体模式"

#: ../../docs/tutorials/physics/physics_introduction.rst:191
msgid "A rigid body can be set to one of four modes:"
msgstr "刚体可以设置为以下四种模式之一:"

#: ../../docs/tutorials/physics/physics_introduction.rst:193
msgid ""
"**Rigid** - The body behaves as a physical object. It collides with other "
"bodies and responds to forces applied to it. This is the default mode."
msgstr ""
"**Rigid** - 物体表现为具有物理属性的对象。 它与其他物体发生碰撞，并对施加于其"
"上的力作出反应。 这是默认模式。"

#: ../../docs/tutorials/physics/physics_introduction.rst:194
msgid ""
"**Static** - The body behaves like a :ref:`StaticBody2D "
"<class_StaticBody2D>` and does not move."
msgstr ""
"**Static** - 物体表现得像 :ref:`StaticBody2D <class_StaticBody2D>` 并且不会移"
"动。"

#: ../../docs/tutorials/physics/physics_introduction.rst:195
#, fuzzy
msgid "**Character** - Similar to \"Rigid\" mode, but the body cannot rotate."
msgstr "**Character** - 类似于“Rigid”模式，但物体无法旋转。"

#: ../../docs/tutorials/physics/physics_introduction.rst:196
msgid ""
"**Kinematic** - The body behaves like a :ref:`KinematicBody2D "
"<class_KinematicBody2D>` and must be moved by code."
msgstr ""
"**Kinematic** - 物体的行为类似于 :ref:`KinematicBody2D "
"<class_KinematicBody2D>` 并且必须通过代码移动。"

#: ../../docs/tutorials/physics/physics_introduction.rst:199
msgid "Using RigidBody2D"
msgstr "使用RigidBody2D"

#: ../../docs/tutorials/physics/physics_introduction.rst:201
msgid ""
"One of the benefits of using a rigid body is that a lot of behavior can be "
"had \"for free\" without writing any code. For example, if you were making "
"an \"Angry Birds\"-style game with falling blocks, you would only need to "
"create RigidBody2Ds and adjust their properties. Stacking, falling, and "
"bouncing would automatically be calculated by the physics engine."
msgstr ""
"使用刚体的一个好处是，可以“免费”获得许多行为而无需编写任何代码。 例如，如果您"
"正在制作一个带有下降块的“愤怒的小鸟”式游戏，您只需要创建RigidBody2D并调整它们"
"的属性。 堆叠，下降和弹跳将由物理引擎自动计算。"

#: ../../docs/tutorials/physics/physics_introduction.rst:207
#, fuzzy
msgid ""
"However, if you do wish to have some control over the body, you should take "
"care - altering the ``position``, ``linear_velocity``, or other physics "
"properties of a rigid body can result in unexpected behavior. If you need to "
"alter any of the physics-related properties, you should use the :ref:"
"`_integrate_forces() <class_RigidBody2D_method__integrate_forces>` callback "
"instead of ``_physics_process()``. In this callback, you have access to the "
"body's :ref:`Physics2DDirectBodyState <class_Physics2DDirectBodyState>`, "
"which allows for safely changing properties and synchronizing them with the "
"physics engine."
msgstr ""
"但是，如果您希望控制物体，那么您应该注意 - 改变 ``position``, "
"``linear_velocity``, 或刚体的其他物理属性可能会导致意外行为。 如果您需要改变"
"任何与物理相关的属性，您应该使用 :ref:`_integrate_forces() "
"<class_RigidBody2D_method__integrate_forces>` 回调而不是 "
"``_physics_process()`` 。 在此回调中，您可以访问物体的 :ref:"
"`Physics2DDirectBodyState <class_Physics2DDirectBodyState>`，它允许安全地更改"
"属性并将它们与物理引擎同步。"

#: ../../docs/tutorials/physics/physics_introduction.rst:216
msgid "For example, here is the code for an \"Asteroids\" style spaceship:"
msgstr "例如，以下是“小行星”式宇宙飞船的代码:"

#: ../../docs/tutorials/physics/physics_introduction.rst:261
msgid ""
"Note that we are not setting the ``linear_velocity`` or ``angular_velocity`` "
"properties directly, but rather applying forces (``thrust`` and ``torque``) "
"to the body and letting the physics engine calculate the resulting movement."
msgstr ""
"请注意，我们不是直接设置 ``linear_velocity`` 或 ``angular_velocity`` 属性，而"
"是将力( ``thrust`` 和 ``torque`` )施加到物体上并让物理引擎计算出最终的运动。"

#: ../../docs/tutorials/physics/physics_introduction.rst:265
#, fuzzy
msgid ""
"When a rigid body goes to sleep, the ``_integrate_forces()`` function will "
"not be called. To override this behavior, you will need to keep the body "
"awake by creating a collision, applying a force to it, or by disabling the :"
"ref:`can_sleep <class_RigidBody2D_property_can_sleep>` property. Be aware "
"that this can have a negative effect on performance."
msgstr ""
"当刚体进入睡眠状态时，不会调用 ``_integrate_forces()`` 函数。 要覆盖此行为，"
"您需要通过创建碰撞，对其施加力或禁用 :ref:`can_sleep "
"<class_RigidBody2D_property_can_sleep>` 属性来使物体保持清醒状态。 请注意，这"
"会对性能产生负面影响。"

#: ../../docs/tutorials/physics/physics_introduction.rst:272
msgid "Contact reporting"
msgstr "接触报告"

#: ../../docs/tutorials/physics/physics_introduction.rst:274
#, fuzzy
msgid ""
"By default, rigid bodies do not keep track of contacts, because this can "
"require a huge amount of memory if many bodies are in the scene. To enable "
"contact reporting, set the :ref:`contacts_reported "
"<class_RigidBody2D_property_contacts_reported>` property to a non-zero "
"value. The contacts can then be obtained via :ref:`Physics2DDirectBodyState."
"get_contact_count() "
"<class_Physics2DDirectBodyState_method_get_contact_count>` and related "
"functions."
msgstr ""
"默认情况下，刚体不存储接触报告，因为如果场景中有许多实体，这可能需要大量内"
"存。 要启用接触报告，请将 :ref:`contacts_reported "
"<class_RigidBody2D_property_contacts_reported>` 属性设置为非零值。 然后可以通"
"过以下方式获得接触: :ref:`Physics2DDirectBodyState.get_contact_count() "
"<class_Physics2DDirectBodyState_method_get_contact_count>` 及相关函数。"

#: ../../docs/tutorials/physics/physics_introduction.rst:281
#, fuzzy
msgid ""
"Contact monitoring via signals can be enabled via the :ref:`contact_monitor "
"<class_RigidBody2D_property_contact_monitor>` property. See :ref:"
"`RigidBody2D <class_RigidBody2D>` for the list of available signals."
msgstr ""
"可以通过 :ref:`contact_monitor <class_RigidBody2D_property_contact_monitor>` "
"属性启用采用信号的接触监视。 请参阅 :ref:`RigidBody2D <class_RigidBody2D>` 获"
"取可用的信号列表。"

#: ../../docs/tutorials/physics/physics_introduction.rst:286
msgid "KinematicBody2D"
msgstr "KinematicBody2D"

#: ../../docs/tutorials/physics/physics_introduction.rst:288
msgid ""
":ref:`KinematicBody2D <class_KinematicBody2D>` bodies detect collisions with "
"other bodies, but are not affected by physics properties like gravity or "
"friction. Instead, they must be controlled by the user via code. The physics "
"engine will not move a kinematic body."
msgstr ""
":ref:`KinematicBody2D <class_KinematicBody2D>` 物体检测与其他物体的碰撞，但不"
"受重力或摩擦等物理属性的影响。 相反，它们必须由用户通过代码控制。 物理引擎不"
"会移动运动体。"

#: ../../docs/tutorials/physics/physics_introduction.rst:293
msgid ""
"When moving a kinematic body, you should not set its ``position`` directly. "
"Instead, you use the ``move_and_collide()`` or ``move_and_slide()`` methods. "
"These methods move the body along a given vector, and it will instantly stop "
"if a collision is detected with another body. After the body has collided, "
"any collision response must be coded manually."
msgstr ""
"移动运动体时，不应直接设置其 ``position`` 。 相反，您使用 "
"``move_and_collide()`` 或 ``move_and_slide()`` 方法。 这些方法沿着给定的向量"
"移动物体，如果与另一个物体检测到碰撞，它将立即停止。 在物体发生碰撞后，必须手"
"动编码任何碰撞响应。"

#: ../../docs/tutorials/physics/physics_introduction.rst:300
msgid "Kinematic collision response"
msgstr "运动碰撞响应"

#: ../../docs/tutorials/physics/physics_introduction.rst:302
msgid ""
"After a collision, you may want the body to bounce, to slide along a wall, "
"or to alter the properties of the object it hit. The way you handle "
"collision response depends on which method you used to move the "
"KinematicBody2D."
msgstr ""
"碰撞后，您可能希望物体反弹，沿着墙壁滑动，或者改变它所击中的物体的属性。 处理"
"碰撞响应的方式取决于您用于移动KinematicBody2D的方法。"

#: ../../docs/tutorials/physics/physics_introduction.rst:307
#, fuzzy
msgid ":ref:`move_and_collide <class_KinematicBody2D_method_move_and_collide>`"
msgstr ""
":ref:`move_and_collide <class_KinematicBody2D_method_move_and_collide>`"

#: ../../docs/tutorials/physics/physics_introduction.rst:309
msgid ""
"When using ``move_and_collide()``, the function returns a :ref:"
"`KinematicCollision2D <class_KinematicCollision2D>` object, which contains "
"information about the collision and the colliding body. You can use this "
"information to determine the response."
msgstr ""
"当使用 ``move_and_collide()`` 时，该函数返回一个 :ref:`KinematicCollision2D "
"<class_KinematicCollision2D>` 对象，其中包含有关碰撞和碰撞体的信息。 您可以使"
"用此信息来确定响应。"

#: ../../docs/tutorials/physics/physics_introduction.rst:314
msgid ""
"For example, if you want to find the point in space where the collision "
"occurred:"
msgstr "例如，如果要查找发生碰撞的空间点:"

#: ../../docs/tutorials/physics/physics_introduction.rst:345
msgid "Or to bounce off of the colliding object:"
msgstr "或者从碰撞物体反弹:"

#: ../../docs/tutorials/physics/physics_introduction.rst:374
#, fuzzy
msgid ":ref:`move_and_slide <class_KinematicBody2D_method_move_and_slide>`"
msgstr ":ref:`move_and_slide <class_KinematicBody2D_method_move_and_slide>`"

#: ../../docs/tutorials/physics/physics_introduction.rst:376
msgid ""
"Sliding is a common collision response; imagine a player moving along walls "
"in a top-down game or running up and down slopes in a platformer. While it's "
"possible to code this response yourself after using ``move_and_collide()``, "
"``move_and_slide()`` provides a convenient way to implement sliding movement "
"without writing much code."
msgstr ""
"滑动是一种常见的碰撞响应; 想象一个游戏角色在上帝视角的游戏中沿着墙壁移动，或"
"者在平台游戏中上下坡。 虽然可在使用 ``move_and_collide()`` 之后自己编写这个响"
"应，但 ``move_and_slide()`` 提供了一种快捷方法来实现滑动且无需编写太多代码。"

#: ../../docs/tutorials/physics/physics_introduction.rst:382
msgid ""
"``move_and_slide()`` automatically includes the timestep in its calculation, "
"so you should **not** multiply the velocity vector by ``delta``."
msgstr ""
"``move_and_slide()`` 在计算中自动包含时间步长，因此您 **不** 应将速度向量乘"
"以 ``delta`` 。"

#: ../../docs/tutorials/physics/physics_introduction.rst:386
msgid ""
"For example, use the following code to make a character that can walk along "
"the ground (including slopes) and jump when standing on the ground:"
msgstr ""
"例如，使用以下代码制作一个可以沿着地面(包括斜坡)行走的角色，并在站在地面时跳"
"跃:"

#: ../../docs/tutorials/physics/physics_introduction.rst:451
msgid ""
"See :ref:`doc_kinematic_character_2d` for more details on using "
"``move_and_slide()``, including a demo project with detailed code."
msgstr ""
"有关使用 ``move_and_slide()`` 的更多详细信息，请参阅 :ref:"
"`doc_kinematic_character_2d` ，包括带有详细代码的演示项目。"

#: ../../docs/tutorials/physics/rigid_body.rst:4
#, fuzzy
msgid "RigidBody"
msgstr "刚体"

#: ../../docs/tutorials/physics/rigid_body.rst:7
msgid "What is a rigid body?"
msgstr "什么是刚体？"

#: ../../docs/tutorials/physics/rigid_body.rst:9
msgid ""
"A rigid body is one that is directly controlled by the physics engine in "
"order to simulate the behavior of physical objects. In order to define the "
"shape of the body, it must have one or more :ref:`Shape <class_Shape>` "
"objects assigned. Note that setting the position of these shapes will affect "
"the body's center of mass."
msgstr ""
"刚体是直接由物理引擎控制以模拟物理对象行为的物体。为了定义物体的形状，必须分"
"配一个或多个 :ref:`Shape <class_Shape>` 对象。注意，设置这些形状的位置将影响"
"物体的重心。"

#: ../../docs/tutorials/physics/rigid_body.rst:13
#, fuzzy
msgid "How to control a rigid body"
msgstr "如何控制刚体"

#: ../../docs/tutorials/physics/rigid_body.rst:15
#, fuzzy
msgid ""
"A rigid body's behavior can be altered by setting its properties, such as "
"friction, mass, bounce, etc. These properties can be set in the Inspector or "
"via code. See :ref:`RigidBody <class_RigidBody>` for the full list of "
"properties and their effects."
msgstr ""
"刚体的行为可以通过设置其特性(如摩擦、质量、弹跳等)而改变。这些特性可以在属性"
"面板中或通过代码设置。有关属性及其效果的完整列表，请参见 :ref:`RigidBody "
"<class_RigidBody>` 。"

#: ../../docs/tutorials/physics/rigid_body.rst:17
msgid ""
"There are several ways to control a rigid body's movement, depending on your "
"desired application."
msgstr "有几种方法可以控制刚体的运动，这取决于您的应用程序。"

#: ../../docs/tutorials/physics/rigid_body.rst:19
#, fuzzy
msgid ""
"If you only need to place a rigid body once, for example to set its initial "
"location, you can use the methods provided by the :ref:`Spatial "
"<class_Spatial>` node, such as ``set_global_transform()`` or ``look_at()``. "
"However, these methods cannot be called every frame or the physics engine "
"will not be able to correctly simulate the body's state. As an example, "
"consider a rigid body that you want to rotate so that it points towards "
"another object. A common mistake when implementing this kind of behavior is "
"to use ``look_at()`` every frame, which breaks the physics simulation. "
"Below, we'll demonstrate how to implement this correctly."
msgstr ""
"如果您只想要放置一个刚体，例如设置它的初始位置，您可以使用 :ref:`Spatial "
"<class_Spatial>` 节点提供的方法，比如 ``set_global_transform()`` 或 "
"``look_at()``。 但是，这些函数不能在每帧调用，否则物理引擎将无法正确模拟物体"
"的状态。 例如，考虑要旋转的刚体，使其指向另一个对象。 实现这种行为时常见的错"
"误是每帧使用 ``look_at()`` ，这会打破物理模拟。 下面，我们将演示如何正确实现"
"这一点。"

#: ../../docs/tutorials/physics/rigid_body.rst:22
#, fuzzy
msgid ""
"The fact that you can't use ``set_global_transform()`` or ``look_at()`` "
"methods doesn't mean that you can't have full control of a rigid body. "
"Instead, you can control it by using the ``_integrate_forces()`` callback. "
"In this method, you can add *forces*, apply *impulses*, or set the "
"*velocity* in order to achieve any movement you desire."
msgstr ""
"您不能使用 ``set_global_transform()`` 或 ``look_at()`` 方法并不意味着您不能完"
"全控制刚体。 相反，您可以使用 ``_integrate_forces()`` 回调来控制它。 在此函数"
"中，您可以添加 *力* ，应用 *脉冲* 或设置 *速度* 以实现您想要的任何移动。"

#: ../../docs/tutorials/physics/rigid_body.rst:25
#, fuzzy
msgid "The \"look at\" method"
msgstr "``import`` 方法"

#: ../../docs/tutorials/physics/rigid_body.rst:27
#, fuzzy
msgid ""
"As described above, using the Spatial node's ``look_at()`` method can't be "
"used each frame to follow a target. Here is a custom ``look_at()`` method "
"that will work reliably with rigid bodies:"
msgstr ""
"如上所述，为跟随目标，不能将Spatial节点的 ``look_at()`` 函数用在每一帧中。 这"
"是一个自定义的 ``look_at()`` 函数，它可以与刚体一起可靠地工作:"

#: ../../docs/tutorials/physics/rigid_body.rst:69
#, fuzzy
msgid ""
"This method uses the rigid body's ``set_angular_velocity()`` method to "
"rotate the body. It first calculates the difference between the current and "
"desired angle and then adds the velocity needed to rotate by that amount in "
"one frame's time."
msgstr ""
"这个函数使用刚体的 ``set_angular_velocity()`` 方法来旋转体。 它首先计算当前角"
"度和所需角度之间的差值，然后在一帧的时间内添加旋转所需的速度。"

#: ../../docs/tutorials/physics/rigid_body.rst:71
#, fuzzy
msgid ""
"This script will not work with rigid bodies in *character mode* because "
"then, the body's rotation is locked. In that case, you would have to rotate "
"the attached mesh node instead using the standard Spatial methods."
msgstr ""
"此脚本不适用于 *角色模式* 中的刚体，因为在此模式下，物体的旋转被锁定了。 在这"
"种情况下，您必须使用标准Spatial方法旋转附加的网格节点。"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:4
msgid "Using KinematicBody2D"
msgstr "使用KinematicBody2D"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:9
msgid ""
"Godot offers a number of collision objects to provide both collision "
"detection and response. Trying to decide which one to use for your project "
"can be confusing. You can avoid problems and simplify development if you "
"understand how each of them works and what their pros and cons are. In this "
"tutorial, we'll look at the :ref:`KinematicBody2D <class_KinematicBody2D>` "
"node and show some examples of how it can be used."
msgstr ""
"为提供碰撞检测和响应，Godot提供了许多碰撞对象。 决定哪一个用于您的项目可能会"
"令人困惑。 如果您了解每个碰撞对象的工作原理以及它们的优缺点，您可以避免出现问"
"题并简化开发。 在本教程中，我们将查看 :ref:`KinematicBody2D "
"<class_KinematicBody2D>` 节点，并展示一些如何使用它的示例。"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:16
msgid ""
"This document assumes you're familiar with Godot's various physics bodies. "
"Please read :ref:`doc_physics_introduction` first."
msgstr ""
"本文假设您熟悉Godot中的各种物理体。 否则请先阅读 :ref:"
"`doc_physics_introduction` 。"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:20
msgid "What is a kinematic body?"
msgstr "什么是运动体？"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:22
#, fuzzy
msgid ""
"``KinematicBody2D`` is for implementing bodies that are to be controlled via "
"code. They detect collisions with other bodies when moving, but are not "
"affected by engine physics properties, like gravity or friction. While this "
"means that you have to write some code to create their behavior, it also "
"means you have more precise control over how they move and react."
msgstr ""
"``KinematicBody2D`` 主要用在需通过代码控制的物体中。 它们在移动时检测碰撞，但"
"不受重力或摩擦等物理引擎特性的影响。 这意味着您必须编写一些代码来创建它们的行"
"为，但这也意味着您可以更精确地控制它们的移动和反应。"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:28
msgid ""
"A `KinematicBody2D` can be affected by gravity and other forces, but you "
"must calculate the movement in code. The physics engine will not move a "
"`KinematicBody2D`."
msgstr ""
"`KinematicBody2D` 可以受到重力和其他力的影响，但您必须在代码中计算它的运动。 "
"物理引擎不会移动 `KinematicBody2D`。"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:33
#, fuzzy
msgid "Movement and collision"
msgstr "运动与碰撞"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:35
msgid ""
"When moving a ``KinematicBody2D``, you should not set its ``position`` "
"property directly. Instead, you use the ``move_and_collide()`` or "
"``move_and_slide()`` methods. These methods move the body along a given "
"vector and will instantly stop if a collision is detected with another body. "
"After a KinematicBody2D has collided, any *collision response* must be coded "
"manually."
msgstr ""
"移动 ``KinematicBody2D`` 时，不应直接设置其 ``position`` 属性。 相反，您使用 "
"``move_and_collide()`` 或 ``move_and_slide()`` 方法。 这些方法沿着给定的向量"
"移动物体，如果检测到与另一个物体发生了碰撞，它将立即停止运动。 在"
"KinematicBody2D发生碰撞后，必须手动编码它的 *碰撞响应* 。"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:41
msgid ""
"Kinematic body movement should only be done in the ``_physics_process()`` "
"callback."
msgstr "运动体的移动应该只在 ``_physics_process()`` 回调中完成。"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:43
#, fuzzy
msgid ""
"The two movement methods serve different purposes, and later in this "
"tutorial, you'll see examples of how they work."
msgstr "这两种移动方法有不同的用途，您将在本教程中看到它们如何工作的示例。"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:47
msgid "``move_and_collide``"
msgstr "``move_and_collide``"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:49
msgid ""
"This method takes one parameter: a :ref:`Vector2 <class_Vector2>` indicating "
"the body's relative movement. Typically, this is your velocity vector "
"multiplied by the frame timestep (``delta``). If the engine detects a "
"collision anywhere along this vector, the body will immediately stop moving. "
"If this happens, the method will return a :ref:`KinematicCollision2D "
"<class_KinematicCollision2D>` object."
msgstr ""
"这个方法有一个 :ref:`Vector2 <class_Vector2>` 参数以表示物体的相对运动。 通"
"常，这是您的速度向量乘以帧时间步长( ``delta`` )。 如果在沿着此向量方向的任何"
"位置，引擎检测到碰撞，则物体将立即停止移动。 如果发生这种情况，该方法将返回 :"
"ref:`KinematicCollision2D <class_KinematicCollision2D>` 对象。"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:55
#, fuzzy
msgid ""
"``KinematicCollision2D`` is an object containing data about the collision "
"and the colliding object. Using this data, you can calculate your collision "
"response."
msgstr ""
"``KinematicCollision2D`` 是包含有关碰撞和碰撞对象的数据。 使用这些数据，您可"
"以计算碰撞响应。"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:60
msgid "``move_and_slide``"
msgstr "``move_and_slide``"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:62
msgid ""
"The ``move_and_slide()`` method is intended to simplify the collision "
"response in the common case where you want one body to slide along the "
"other. This is especially useful in platformers or top-down games, for "
"example."
msgstr ""
"``move_and_slide()`` 方法旨在简化您希望一个物体沿另一个物体滑动的常见情况下的"
"碰撞响应。 这在平台游戏或跳跃游戏中特别有用。"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:66
msgid ""
"``move_and_slide()`` automatically calculates frame-based movement using "
"``delta``. Do *not* multiply your velocity vector by ``delta`` before "
"passing it to ``move_and_slide()``."
msgstr ""
"``move_and_slide()`` 使用 ``delta`` 自动计算基于帧的运动。 在将速度向量传递"
"给 ``move_and_slide()`` 之前，请 *不要* 将速度向量乘以 ``delta``。"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:70
msgid ""
"In addition to the velocity vector, ``move_and_slide()`` takes a number of "
"other parameters allowing you to customize the slide behavior:"
msgstr ""
"除了速度向量之外，``move_and_slide()`` 还有许多其他参数，允许您自定义滑动行"
"为:"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:73
msgid "``floor_normal`` - *default value:* ``Vector2( 0, 0 )``"
msgstr "``floor_normal`` - *默认值:* ``Vector2(0,0)``"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:75
msgid ""
"This parameter allows you to define what surfaces the engine should consider "
"to be the floor. Setting this lets you use the ``is_on_floor()``, "
"``is_on_wall()``, and ``is_on_ceiling()`` methods to detect what type of "
"surface the body is in contact with. The default value means that all "
"surfaces are considered walls."
msgstr ""
"此参数允许您定义引擎应考虑作为地板的表面。 设置它允许您使用 "
"``is_on_floor()`` ， ``is_on_wall()`` 和 ``is_on_ceiling()`` 方法来检测物体接"
"触的表面类型。 默认值表示所有曲面都被视为墙。"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:80
msgid "``slope_stop_min_velocity`` - *default value:* ``5``"
msgstr "``slope_stop_min_velocity`` - *默认值:* ``5``"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:82
msgid ""
"This is the minimum velocity when standing on a slope. This prevents a body "
"from sliding down a slope when standing still."
msgstr "这是站在斜坡上时的最小速度。 这可以防止物体在静止时滑下斜坡。"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:85
msgid "``max_bounces`` - *default value:* ``4``"
msgstr "``max_bounces`` - *默认值:* ``4``"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:87
msgid ""
"This is the maximum number of collisions before the body stops moving. "
"Setting this too low may prevent movement entirely."
msgstr "这是物体停止移动前的最大碰撞次数。 将此设置得太低可能会完全阻止移动。"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:90
msgid ""
"``floor_max_angle`` - *default value:* ``0.785398`` (in radians, equivalent "
"to ``45`` degrees)"
msgstr ""
"``floor_max_angle`` - *默认值:* ``0.785398`` (以弧度表示，相当于 ``45`` 度)"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:92
msgid ""
"This is the maximum angle before a surface is no longer considered a \"floor"
"\"."
msgstr "这是表面不再被视为“地板”之前的最大角度。"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:95
msgid "``move_and_slide_with_snap``"
msgstr "``move_and_slide_with_snap``"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:97
msgid ""
"This method adds some additional functionality to ``move_and_slide()`` by "
"adding the ``snap`` parameter. As long as this vector is in contact with the "
"ground, the body will remain attached to the surface. Note that this means "
"you must disable snapping when jumping, for example. You can do this either "
"by setting ``snap`` to ``Vector2(0, 0)`` or by using ``move_and_slide()`` "
"instead."
msgstr ""
"这个方法通过添加 ``snap`` 参数为 ``move_and_slide()`` 添加了一些额外的功能。 "
"只要该向量与地面接触，物体将保持附着在表面上。 请注意，这意味着您必须在跳跃时"
"禁用捕捉。 您可以通过将 ``snap`` 设置为 ``Vector2(0,0)`` 或者使用 "
"``move_and_slide()`` 来实现。"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:104
msgid "Which movement method to use?"
msgstr "使用哪种运动方式？"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:106
#, fuzzy
msgid ""
"A common question from new Godot users is: \"How do you decide which "
"movement function to use?\" Often, the response is to use "
"``move_and_slide()`` because it's \"simpler\", but this is not necessarily "
"the case. One way to think of it is that ``move_and_slide()`` is a special "
"case, and ``move_and_collide()`` is more general. For example, the following "
"two code snippets result in the same collision response:"
msgstr ""
"一个Godot新用户的常见问题是:“如何决定使用哪种运动函数？” 通常回答是使用 "
"``move_and_slide()`` 因为它“更简单”，但不一定是这种情况。 想到它的一种方法是 "
"``move_and_slide()`` 是一种特殊情况， ``move_and_collide()` `更通用。 例如，"
"以下两个代码段会导致相同的碰撞响应:"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:137
msgid ""
"Anything you do with ``move_and_slide()`` can also be done with "
"``move_and_collide()``, but it might take a little more code. However, as "
"we'll see in the examples below, there are cases where ``move_and_slide()`` "
"doesn't provide the response you want."
msgstr ""
"您用 ``move_and_slide()`` 做的任何事情都可以用 ``move_and_collide()`` 来完"
"成，但它可能需要更多的代码。 但是，正如我们在下面的示例中将看到的，有些情况"
"下 ``move_and_slide()`` 不能提供您想要的响应。"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:142
#: ../../docs/development/compiling/compiling_with_mono.rst:84
msgid "Examples"
msgstr "示例"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:144
msgid ""
"To see these examples in action, download the sample project: :download:"
"`using_kinematic2d.zip <files/using_kinematic2d.zip>`."
msgstr ""
"要查看这些示例，请下载示例项目: :download:`using_kinematic2d.zip <files/"
"using_kinematic2d.zip>`。"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:148
msgid "Movement and walls"
msgstr "移动和墙壁"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:150
#, fuzzy
msgid ""
"If you've downloaded the sample project, this example is in \"BasicMovement."
"tscn\"."
msgstr "如果您已下载示例项目，则此示例位于“BasicMovement.tscn”场景中。"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:152
#, fuzzy
msgid ""
"For this example, add a ``KinematicBody2D`` with two children: a ``Sprite`` "
"and a ``CollisionShape2D``. Use the Godot \"icon.png\" as the Sprite's "
"texture (drag it from the Filesystem dock to the *Texture* property of the "
"``Sprite``). In the ``CollisionShape2D``'s *Shape* property, select \"New "
"RectangleShape2D\" and size the rectangle to fit over the sprite image."
msgstr ""
"对于这个示例，添加一个带有两个子节点的``KinematicBody2D``:一个``Sprite``和一"
"个``CollisionShape2D``。 使用Godot“icon.png”作为Sprite的纹理(将它从"
"Filesystem 面板拖到 ``Sprite`` 的* Texture *属性中)。 在 "
"``CollisionShape2D`` 的* Shape *属性中，选择“New RectangleShape2D”并调整矩形"
"大小以适合精灵图像。"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:158
msgid ""
"See :ref:`doc_2d_movement` for examples of implementing 2D movement schemes."
msgstr "有关实现2D移动方案的示例，请参阅 :ref:`doc_2d_movement` 。"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:160
msgid "Attach a script to the KinematicBody2D and add the following code:"
msgstr "将脚本附加到KinematicBody2D并添加以下代码:"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:223
msgid ""
"Run this scene and you'll see that ``move_and_collide()`` works as expected, "
"moving the body along the velocity vector. Now let's see what happens when "
"you add some obstacles. Add a :ref:`StaticBody2D <class_StaticBody2D>` with "
"a rectangular collision shape. For visibility, you can use a sprite, a "
"Polygon2D, or turn on \"Visible Collision Shapes\" from the \"Debug\" menu."
msgstr ""
"运行这个场景，您会看到 ``move_and_collide()`` 按预期工作，沿着速度向量方向移"
"动物体。 现在让我们看看当您添加一些障碍时会发生什么。 添加一个具有矩形碰撞形"
"状的 :ref:`StaticBody2D <class_StaticBody2D>` 。 为了可见性，您可以使用精灵，"
"Polygon2D，或从“调试”菜单中打开“可见碰撞形状”。"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:229
msgid ""
"Run the scene again and try moving into the obstacle. You'll see that the "
"``KinematicBody2D`` can't penetrate the obstacle. However, try moving into "
"the obstacle at an angle and you'll find that the obstacle acts like glue - "
"it feels like the body gets stuck."
msgstr ""
"再次运行场景并尝试移动到障碍物中。 您会看到 ``KinematicBody2D`` 无法穿透障碍"
"物。 但是，尝试以某个角度进入障碍物，您会发现障碍物就像胶水一样 - 感觉物体被"
"卡住了。"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:233
msgid ""
"This happens because there is no *collision response*. "
"``move_and_collide()`` stops the body's movement when a collision occurs. We "
"need to code whatever response we want from the collision."
msgstr ""
"发生这种情况是因为没有 *碰撞响应* 。 ``move_and_collide()``在碰撞发生时停止物"
"体的运动。 我们需要编写我们想要的碰撞响应。"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:237
msgid ""
"Try changing the function to ``move_and_slide(velocity)`` and running again. "
"Note that we removed ``delta`` from the velocity calculation."
msgstr ""
"尝试将函数更改为 ``move_and_slide(velocity)`` 并再次运行。 请注意，我们从速度"
"计算中删除了“delta”。"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:240
msgid ""
"``move_and_slide()`` provides a default collision response of sliding the "
"body along the collision object. This is useful for a great many game types, "
"and may be all you need to get the behavior you want."
msgstr ""
"``move_and_slide()``提供了一个沿碰撞对象滑动物体的默认碰撞响应。 这对于许多游"
"戏类型都很有用，并且可能是获得所需行为所需的全部内容。"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:245
msgid "Bouncing/reflecting"
msgstr "弹跳/反射"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:247
msgid ""
"What if you don't want a sliding collision response? For this example "
"(\"BounceandCollide.tscn\" in the sample project), we have a character "
"shooting bullets and we want the bullets to bounce off the walls."
msgstr ""
"如果您不想要滑动碰撞响应怎么办？ 对于这个示例(示例项目中的“BounceandCollide."
"tscn”)，我们有一个角色射击子弹，我们希望子弹从墙上反弹。"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:251
msgid ""
"This example uses three scenes. The main scene contains the Player and "
"Walls. The Bullet and Wall are separate scenes so that they can be instanced."
msgstr ""
"此示例使用三个场景。 主场景包含游戏角色和墙壁。 子弹和墙是单独的场景，以便它"
"们可以实例化。"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:254
msgid ""
"The Player is controlled by the `w` and `s` keys for forward and back. "
"Aiming uses the mouse pointer. Here is the code for the Player, using "
"``move_and_slide()``:"
msgstr ""
"游戏角色由'w`和`s`键控制前进和后退。 瞄准使用鼠标指针。 这是游戏角色的代码，"
"使用``move_and_slide()``:"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:341
msgid "And the code for the Bullet:"
msgstr "子弹的代码:"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:403
#, fuzzy
msgid ""
"The action happens in ``_physics_process()``. After using "
"``move_and_collide()``, if a collision occurs, a ``KinematicCollision2D`` "
"object is returned (otherwise, the return is ``Nil``)."
msgstr ""
"动作发生在 ``_physics_process()`` 中。 使用 ``move_and_slide()`` 如果发生碰"
"撞，则返回一个 ``Kinematic Collision 2D`` 对象(否则，返回为 ``Nil``)。"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:407
msgid ""
"If there is a returned collision, we use the ``normal`` of the collision to "
"reflect the bullet's ``velocity`` with the ``Vector2.bounce()`` method."
msgstr ""
"如果有一个返回的碰撞，我们使用碰撞的 ``normal`` 来反映子弹的 ``velocity`` 和 "
"``Vector2.bounce()`` 方法。"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:410
msgid ""
"If the colliding object (``collider``) has a ``hit`` method, we also call "
"it. In the example project, we've added a flashing color effect to the Wall "
"to demonstrate this."
msgstr ""
"如果碰撞对象( ``collider`` )有一个 ``hit`` 方法，我们也称之为。 在示例项目"
"中，我们为Wall添加了一个闪烁的颜色效果来演示这一点。"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:417
msgid "Platformer movement"
msgstr "平台运动"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:419
msgid ""
"Let's try one more popular example: the 2D platformer. ``move_and_slide()`` "
"is ideal for quickly getting a functional character controller up and "
"running. If you've downloaded the sample project, you can find this in "
"\"Platformer.tscn\"."
msgstr ""
"让我们尝试一个更流行的示例:2D平台游戏。 ``move_and_slide()``非常适合快速启动"
"和运行功能字符控制器。 如果您已下载示例项目，可以在“Platformer.tscn”中找到"
"它。"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:423
msgid ""
"For this example, we'll assume you have a level made of ``StaticBody2D`` "
"objects. They can be any shape and size. In the sample project, we're using :"
"ref:`Polygon2D <class_Polygon2D>` to create the platform shapes."
msgstr ""
"对于这个示例，我们假设您有一个由 ``StaticBody2D`` 对象构成的级别。 它们可以是"
"任何形状和大小。 在示例项目中，我们使用 :ref:`Polygon2D <class_Polygon2D>` 来"
"创建平台形状。"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:427
msgid "Here's the code for the player body:"
msgstr "这是游戏角色物体的代码:"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:508
#, fuzzy
msgid ""
"When using ``move_and_slide()``, the function returns a vector representing "
"the movement that remained after the slide collision occurred. Setting that "
"value back to the character's ``velocity`` allows us to smoothly move up and "
"down slopes. Try removing ``velocity =`` and see what happens if you don't "
"do this."
msgstr ""
"当使用 ``move_and_slide()`` 时，该函数返回一个向量，表示滑动碰撞发生后剩余的"
"运动。 将该值设置回角色的“速度”可以让我们平稳地上下移动斜坡。 尝试删除 "
"``velocity =`` ，看看如果您不这样做会发生什么。"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:513
msgid ""
"Also note that we've added ``Vector2(0, -1)`` as the floor normal. This is a "
"vector pointing straight upward. This means that if the character collides "
"with an object that has this normal, it will be considered a floor."
msgstr ""
"另请注意，我们添加了 ``Vector2(0，-1)`` 作为最低法线。 这是向上指向的向量。 "
"这意味着如果角色与具有此法线的对象发生碰撞，则将其视为地板。"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:517
msgid ""
"Using the floor normal allows us to make jumping work, using "
"``is_on_floor()``. This function will only return ``true`` after a "
"``move_and_slide()`` collision where the colliding body's normal is within "
"45 degrees of the given floor vector (this can be adjusted by setting "
"``floor_max_angle``)."
msgstr ""
"使用地板法线允许我们使用 ``is_on_floor()`` 进行跳跃工作。 这个函数只会在 "
"``move_and_slide()`` 碰撞后返回 ``true`` ，其中碰撞体的法线在给定楼层向量的45"
"度范围内(这可以通过设置 ``floor_max_angle`` 来调整)。"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:522
#, fuzzy
msgid ""
"This also allows you to implement other features (like wall jumps) using "
"``is_on_wall()``, for example."
msgstr "这也允许您使用 ``is_on_wall()`` 来实现其他功能，例如墙跳。"

#: ../../docs/tutorials/physics/ray-casting.rst:4
msgid "Ray-casting"
msgstr "发射射线"

#: ../../docs/tutorials/physics/ray-casting.rst:9
msgid ""
"One of the most common tasks in game development is casting a ray (or custom "
"shaped object) and checking what it hits. This enables complex behaviors, "
"AI, etc. to take place. This tutorial will explain how to do this in 2D and "
"3D."
msgstr ""
"游戏开发中最常见的任务之一是发射射线(或自定义形状的对象)并检查其击中的内容。 "
"这可以产生复杂的行为，如AI等。 本教程将介绍如何在2D和3D中执行此操作。"

#: ../../docs/tutorials/physics/ray-casting.rst:14
msgid ""
"Godot stores all the low level game information in servers, while the scene "
"is just a frontend. As such, ray casting is generally a lower-level task. "
"For simple raycasts, node such as :ref:`RayCast <class_RayCast>` and :ref:"
"`RayCast2D <class_RayCast2D>` will work, as they will return every frame "
"what the result of a raycast is."
msgstr ""
"Godot将所有低级游戏信息存储在服务器中，而场景只是一个前端。 因此，发射射线通"
"常是较低级别的任务。 对于简单的射线发射，使用 :ref:`RayCast <class_RayCast>` "
"和 :ref:`RayCast2D <class_RayCast2D>` 节点就可以了，因为它们将每一帧都返回射"
"线投射的结果。"

#: ../../docs/tutorials/physics/ray-casting.rst:21
msgid ""
"Many times, though, ray-casting needs to be a more interactive process so a "
"way to do this by code must exist."
msgstr ""
"但是，很多时候，射线投射应该是一个更具交互性的过程，因此必须存在通过代码执行"
"此操作的方法。"

#: ../../docs/tutorials/physics/ray-casting.rst:25
msgid "Space"
msgstr "空间"

#: ../../docs/tutorials/physics/ray-casting.rst:27
#, fuzzy
msgid ""
"In the physics world, Godot stores all the low level collision and physics "
"information in a *space*. The current 2d space (for 2D Physics) can be "
"obtained by accessing :ref:`CanvasItem.get_world_2d().space "
"<class_CanvasItem_method_get_world_2d>`. For 3D, it's :ref:`Spatial."
"get_world().space <class_Spatial_method_get_world>`."
msgstr ""
"在物理世界中，Godot将所有低级碰撞和物理信息存储在 *空间* 中。 当前的2d空间(用"
"于2D物理)可以通过访问 :ref:`CanvasItem.get_world_2d().space "
"<class_CanvasItem_method_get_world_2d>` 来获得。 对于3D，它是 :ref:`Spatial."
"get_world().space <class_Spatial_method_get_world>`。"

#: ../../docs/tutorials/physics/ray-casting.rst:33
msgid ""
"The resulting space :ref:`RID <class_RID>` can be used in :ref:"
"`PhysicsServer <class_PhysicsServer>` and :ref:`Physics2DServer "
"<class_Physics2DServer>` respectively for 3D and 2D."
msgstr ""
"结果空间 :ref:`RID <class_RID>` 可在3D的 :ref:`PhysicsServer "
"<class_PhysicsServer>` 和2D的 :ref:`Physics2DServer <class_Physics2DServer>` "
"中。"

#: ../../docs/tutorials/physics/ray-casting.rst:38
msgid "Accessing space"
msgstr "获取空间"

#: ../../docs/tutorials/physics/ray-casting.rst:40
#, fuzzy
msgid ""
"Godot physics runs by default in the same thread as game logic, but may be "
"set to run on a separate thread to work more efficiently. Due to this, the "
"only time accessing space is safe is during the :ref:`Node."
"_physics_process() <class_Node_method__physics_process>` callback. Accessing "
"it from outside this function may result in an error due to space being "
"*locked*."
msgstr ""
"Godot物理默认在与游戏逻辑相同的线程中运行，但可以设置为在单独的线程上运行以更"
"有效地工作。 因此，访问空间的唯一时间是安全的 :ref:`Node."
"_physics_process()<class_Node_method__physics_process>` 回调。 从此功能外部访"
"问它可能会因空间被锁定*而导致错误。"

#: ../../docs/tutorials/physics/ray-casting.rst:47
msgid ""
"To perform queries into physics space, the :ref:`Physics2DDirectSpaceState "
"<class_Physics2DDirectSpaceState>` and :ref:`PhysicsDirectSpaceState "
"<class_PhysicsDirectSpaceState>` must be used."
msgstr ""
"要对物理空间执行查询，必须使用 :ref:`Physics2DDirectSpaceState "
"<class_Physics2DDirectSpaceState>` 和 :ref:`PhysicsDirectSpaceState "
"<class_PhysicsDirectSpaceState>` 。"

#: ../../docs/tutorials/physics/ray-casting.rst:52
msgid "Use the following code in 2D:"
msgstr "在2D中使用以下代码:"

#: ../../docs/tutorials/physics/ray-casting.rst:69
msgid "Or more directly:"
msgstr "或者更直接:"

#: ../../docs/tutorials/physics/ray-casting.rst:84
msgid "And in 3D:"
msgstr "在3D中:"

#: ../../docs/tutorials/physics/ray-casting.rst:100
msgid "Raycast query"
msgstr "Raycast查询"

#: ../../docs/tutorials/physics/ray-casting.rst:102
#, fuzzy
msgid ""
"For performing a 2D raycast query, the method :ref:"
"`Physics2DDirectSpaceState.intersect_ray() "
"<class_Physics2DDirectSpaceState_method_intersect_ray>` may be used. For "
"example:"
msgstr ""
"为了执行2D光线投射查询，可以使用以下方法 :ref:`Physics2DDirectSpaceState."
"intersect_ray()<class_Physics2DDirectSpaceState_method_intersect_ray>` 。 例"
"如:"

#: ../../docs/tutorials/physics/ray-casting.rst:123
#, fuzzy
msgid ""
"The result is a dictionary. If the ray didn't hit anything, the dictionary "
"will be empty. If it did hit something, it will contain collision "
"information:"
msgstr ""
"结果是一个字典。 如果射线没有击中任何东西，字典为空。 如果它碰到了什么，它将"
"包含碰撞信息:"

#: ../../docs/tutorials/physics/ray-casting.rst:137
msgid ""
"The ``result`` dictionary when a collision occurs contains the following "
"data:"
msgstr "发生碰撞时， ``result`` 字典包含以下数据:"

#: ../../docs/tutorials/physics/ray-casting.rst:152
msgid "The data is similar in 3D space, using Vector3 coordinates."
msgstr "使用Vector3坐标，数据在3D空间中类似。"

#: ../../docs/tutorials/physics/ray-casting.rst:155
msgid "Collision exceptions"
msgstr "碰撞异常"

#: ../../docs/tutorials/physics/ray-casting.rst:157
msgid ""
"A common use case for ray casting is to enable a character to gather data "
"about the world around it. One problem with this is that the same character "
"has a collider, so the ray will only detect its parent's collider, as shown "
"in the following image:"
msgstr ""
"光线投射的常见用例是使角色能够收集有关其周围世界的数据。 这个问题的一个问题是"
"同一个角色有一个对撞机，因此光线只会检测其父对手，如下图所示:"

#: ../../docs/tutorials/physics/ray-casting.rst:164
msgid ""
"To avoid self-intersection, the ``intersect_ray()`` function can take an "
"optional third parameter which is an array of exceptions. This is an example "
"of how to use it from a KinematicBody2D or any other collision object node:"
msgstr ""
"为了避免自相交， ``intersect_ray()`` 函数可以采用可选的第三个参数，这是一个异"
"常数组。 这是如何从KinematicBody2D或任何其他碰撞对象节点使用它的示例:"

#: ../../docs/tutorials/physics/ray-casting.rst:189
msgid "The exceptions array can contain objects or RIDs."
msgstr "例外数组可以包含对象或RID。"

#: ../../docs/tutorials/physics/ray-casting.rst:192
msgid "Collision Mask"
msgstr "碰撞遮罩"

#: ../../docs/tutorials/physics/ray-casting.rst:194
msgid ""
"While the exceptions method works fine for excluding the parent body, it "
"becomes very inconvenient if you need a large and/or dynamic list of "
"exceptions. In this case, it is much more efficient to use the collision "
"layer/mask system."
msgstr ""
"虽然例外方法适用于排除父体，但如果需要大型和/或动态的例外列表，则会变得非常不"
"方便。 在这种情况下，使用碰撞层/遮罩系统要高效得多。"

#: ../../docs/tutorials/physics/ray-casting.rst:198
#, fuzzy
msgid ""
"The optional fourth argument for ``intersect_ray()`` is a collision mask. "
"For example, to use the same mask as the parent body, use the "
"``collision_mask`` member variable:"
msgstr ""
"``intersect_ray()`` 的可选第四个参数是一个碰撞遮罩。 例如，要使用相同的遮罩作"
"为父主体，请使用 ``collision_mask`` 成员变量:"

#: ../../docs/tutorials/physics/ray-casting.rst:226
msgid "3D ray casting from screen"
msgstr "来自屏幕的3D射线投射"

#: ../../docs/tutorials/physics/ray-casting.rst:228
#, fuzzy
msgid ""
"Casting a ray from screen to 3D physics space is useful for object picking. "
"There is not much need to do this because :ref:`CollisionObject "
"<class_CollisionObject>` has an \"input_event\" signal that will let you "
"know when it was clicked, but in case there is any desire to do it manually, "
"here's how."
msgstr ""
"将光线从屏幕投射到3D物理空间对于对象拾取非常有用。 没有太多需要这样做，因为 :"
"ref:`CollisionObject <class_CollisionObject>` 有一个“input_event”信号，可以让"
"您知道它被点击的时间，但是如果有任何想要手动完成的话，这里是如何。"

#: ../../docs/tutorials/physics/ray-casting.rst:234
msgid ""
"To cast a ray from the screen, you need a :ref:`Camera <class_Camera>` node. "
"A ``Camera`` can be in two projection modes: perspective and orthogonal. "
"Because of this, both the ray origin and direction must be obtained. This is "
"because ``origin`` changes in orthogonal mode, while ``normal`` changes in "
"perspective mode:"
msgstr ""
"要从屏幕投射光线，您需要 :ref:`Camera <class_Camera>` 节点。 “相机”可以是两种"
"投影模式:透视和正交。 因此，必须获得射线原点和方向。 这是因为 ``origin`` 在正"
"交模式下改变，而 ``normal`` 在透视模式下改变:"

#: ../../docs/tutorials/physics/ray-casting.rst:242
msgid "To obtain it using a camera, the following code can be used:"
msgstr "要使用相机获取它，可以使用以下代码:"

#: ../../docs/tutorials/physics/ray-casting.rst:270
msgid ""
"Remember that during ``_input()``, the space may be locked, so in practice "
"this query should be run in ``_physics_process()``."
msgstr ""
"请记住，在 ``_input()`` 期间，空格可能被锁定，所以实际上这个查询应该在 "
"``_physics_process()`` 中运行。"

#: ../../docs/tutorials/physics/ragdoll_system.rst:4
msgid "Ragdoll system"
msgstr "布娃娃系统"

#: ../../docs/tutorials/physics/ragdoll_system.rst:9
#, fuzzy
msgid ""
"Since version 3.1, Godot supports ragdoll physics. Ragdolls rely on physics "
"simulation to create realistic procedural animation. They are used for death "
"animations in many games."
msgstr ""
"从版本3.1开始，Godot支持布娃娃物理。 Ragdolls依靠物理模拟来创建逼真的程序动"
"画。 它们在许多游戏中用于死亡动画。"

#: ../../docs/tutorials/physics/ragdoll_system.rst:11
msgid ""
"In this tutorial, we will be using the Platformer3D demo to set up a ragdoll."
msgstr "在本教程中，我们将使用Platformer3D演示来设置布娃娃。"

#: ../../docs/tutorials/physics/ragdoll_system.rst:13
msgid ""
"You can download the Platformer3D demo on `GitHub <https://github.com/"
"godotengine/godot-demo-projects/tree/master/3d/platformer>`_ or using the "
"`Asset Library <https://godotengine.org/asset-library/asset/125>`_."
msgstr ""
"您可以在 `GitHub <https://github.com/godotengine/godot-demo-projects/tree/"
"master/3d/platformer>`_ 上下载Platformer3D演示或使用 `Asset Library <https://"
"godotengine.org/asset-library/asset/125>`_ 。"

#: ../../docs/tutorials/physics/ragdoll_system.rst:16
msgid "Setting up the ragdoll"
msgstr "设置布娃娃"

#: ../../docs/tutorials/physics/ragdoll_system.rst:19
msgid "Creating physical bones"
msgstr "创建物理骨骼"

#: ../../docs/tutorials/physics/ragdoll_system.rst:21
msgid ""
"Like many other features in the engine, there is a node to set up a ragdoll: "
"the :ref:`PhysicalBone <class_PhysicalBone>` node. To simplify the setup, "
"you can generate ``PhysicalBone`` nodes with the \"Create physical skeleton"
"\" feature in the skeleton node."
msgstr ""
"与引擎中的许多其他功能一样，有一个节点可以设置一个布娃娃: :ref:`PhysicalBone "
"<class_PhysicalBone>` 节点。 为了简化设置，您可以使用骨架节点中的“创建物理骨"
"架”功能生成 ``PhysicalBone`` 节点。"

#: ../../docs/tutorials/physics/ragdoll_system.rst:23
msgid ""
"Open the platformer demo in Godot, and then the Robi scene. Select the "
"``Skeleton`` node. A skeleton button appears on the top bar menu:"
msgstr ""
"在Godot中打开平台演示，然后在Robi场景中打开。 选择 ``Skeleton`` 节点。 顶部栏"
"菜单上显示骨架按钮:"

#: ../../docs/tutorials/physics/ragdoll_system.rst:27
msgid ""
"Click it and select the ``Create physical skeleton`` option. Godot will "
"generate ``PhysicalBone`` nodes and collision shapes for each bone in the "
"skeleton and pin joints to connect them together:"
msgstr ""
"单击它并选择 ``创建物理骨架`` 选项。 Godot将为骨架中的每个骨骼生成 "
"``PhysicalBone`` 节点和碰撞形状，并将针脚连接在一起以将它们连接在一起:"

#: ../../docs/tutorials/physics/ragdoll_system.rst:31
msgid ""
"Some of the generated bones aren't necessary: the ``MASTER`` bone for "
"example. So we're going to clean up the skeleton by removing them."
msgstr ""
"一些生成的骨骼不是必需的:例如 ``MASTER`` 骨骼。 因此，我们将通过删除它们来清"
"理骨架。"

#: ../../docs/tutorials/physics/ragdoll_system.rst:34
msgid "Cleaning up the skeleton"
msgstr "清理骨骼"

#: ../../docs/tutorials/physics/ragdoll_system.rst:36
#, fuzzy
msgid ""
"Each ``PhysicalBone`` the engine needs to simulate has a performance cost, "
"so you want to remove every bone that is too small to make a difference in "
"the simulation, as well as all utility bones."
msgstr ""
"引擎需要模拟的每个“PhysicalBone”都具有性能成本，因此您希望删除每个骨骼，这些"
"骨骼太小而不能在模拟中产生差异，以及所有实用程序骨骼。"

#: ../../docs/tutorials/physics/ragdoll_system.rst:38
msgid ""
"For example, if we take a humanoid, you do not want to have physical bones "
"for each finger. you can use a single bone for the entire hand instead, or "
"one for the palm, one for the thumb, and a last one for the other four "
"fingers."
msgstr ""
"例如，如果我们采用人形生物，您不希望每个手指都有物理骨骼。 您可以使用单个骨骼"
"代替整个手部，或者一个用于手掌，一个用于拇指，最后一个用于其他四个手指。"

#: ../../docs/tutorials/physics/ragdoll_system.rst:40
msgid ""
"Remove these physical bones : ``MASTER``, ``waist``, ``neck``, "
"``headtracker``. This gives us an optimized skeleton and makes it easier to "
"control the ragdoll."
msgstr ""
"删除这些物理骨骼: ``MASTER``, ``waist``, ``neck``, ``headtracker``。 这为我们"
"提供了优化的骨架，使其更容易控制布娃娃。"

#: ../../docs/tutorials/physics/ragdoll_system.rst:43
msgid "Collision shape adjustment"
msgstr "碰撞形状调整"

#: ../../docs/tutorials/physics/ragdoll_system.rst:45
#, fuzzy
msgid ""
"The next task is adjusting the collision shape and the size of physical "
"bones to match the part of the body that each bone should simulate."
msgstr ""
"接下来的任务是调整碰撞形状和物理骨骼的大小，以匹配每个骨骼应该模拟的物体部"
"位。"

#: ../../docs/tutorials/physics/ragdoll_system.rst:50
msgid "Joints adjustment"
msgstr "关节调整"

#: ../../docs/tutorials/physics/ragdoll_system.rst:52
#, fuzzy
msgid ""
"Once you adjusted the collision shapes, your ragdoll is almost ready. You "
"just want to adjust the pin joints to get a better simulation. "
"``PhysicalBone`` nodes have an unconstrained pin joint assigned to them by "
"default. To change the pin joint, select the ``PhysicalBone`` and change the "
"constraint type in the ``Joint`` section. There, you can change the "
"constraint's orientation and its limits."
msgstr ""
"一旦您调整了碰撞形状，您的布娃娃几乎准备好了。 您只想调整销接头以获得更好的模"
"拟效果。 默认情况下， ``PhysicalBone`` 节点有一个无约束的pin关节。 要更改引脚"
"接头，请选择“PhysicalBone”并在“Joint`”部分更改约束类型。 在那里，您可以更改约"
"束的方向及其限制。"

#: ../../docs/tutorials/physics/ragdoll_system.rst:56
msgid "This is the final result:"
msgstr "这是最终效果:"

#: ../../docs/tutorials/physics/ragdoll_system.rst:61
msgid "Simulating the ragdoll"
msgstr "模拟布娃娃"

#: ../../docs/tutorials/physics/ragdoll_system.rst:63
msgid ""
"The ragdoll is now ready to use. To start the simulation and play the "
"ragdoll animation, you need to call the ``physical_bones_start_simulation`` "
"method. Attach a script to the skeleton node and call the method in the "
"``_ready`` method:"
msgstr ""
"布娃娃现在可以使用了。 要开始模拟并播放布娃娃动画，您需要调用 "
"``physical_bones_start_simulation`` 方法。 将脚本附加到骨架节点并在 "
"``_ready`` 方法中调用该方法:"

#: ../../docs/tutorials/physics/ragdoll_system.rst:71
msgid ""
"To stop the simulation, call the ``physical_bones_stop_simulation()`` method."
msgstr "要停止模拟，请调用 ``physical_bones_stop_simulation()`` 方法。"

#: ../../docs/tutorials/physics/ragdoll_system.rst:75
msgid ""
"You can also limit the simulation to only a few bones. To do so, pass the "
"bone names as a parameter. Here's an example of partial ragdoll simulation:"
msgstr ""
"您还可以将模拟限制为仅几个骨骼。 为此，请将骨骼名称作为参数传递。 这是部分布"
"娃娃模拟的一个示例:"

#: ../../docs/tutorials/physics/ragdoll_system.rst:80
msgid "Collision layer and mask"
msgstr "碰撞层与遮罩"

#: ../../docs/tutorials/physics/ragdoll_system.rst:82
msgid ""
"Make sure to set up your collision layers and masks properly so the "
"``KinematicBody``'s capsule doesn't get in the way of the physics simulation:"
msgstr "确保正确设置碰撞层和遮罩，这样“KinematicBody”的胶囊不会妨碍物理模拟:"

#: ../../docs/tutorials/physics/ragdoll_system.rst:86
msgid "For more information, read :ref:`doc_physics_introduction`"
msgstr "有关更多信息，请阅读 :ref:`doc_physics_introduction`"

#: ../../docs/tutorials/physics/kinematic_character_2d.rst:4
#, fuzzy
msgid "Kinematic character (2D)"
msgstr "运动学角色(2D)"

#: ../../docs/tutorials/physics/kinematic_character_2d.rst:9
#, fuzzy
msgid ""
"Yes, the name sounds strange. \"Kinematic Character\". What is that? The "
"reason for the name is that, when physics engines came out, they were called "
"\"Dynamics\" engines (because they dealt mainly with collision responses). "
"Many attempts were made to create a character controller using the dynamics "
"engines, but it wasn't as easy as it seemed. Godot has one of the best "
"implementations of dynamic character controller you can find (as it can be "
"seen in the 2d/platformer demo), but using it requires a considerable level "
"of skill and understanding of physics engines (or a lot of patience with "
"trial and error)."
msgstr ""
"是的，名字听起来很奇怪。 “运动学角色”。 那是什么？ 原因是当物理引擎问世时，它"
"们被称为“动力”引擎(因为它们主要处理碰撞响应)。 人们做了许多尝试，想使用动力引"
"擎创建一个角色控制器，但它并不像看起来那么容易。 Godot拥有您能找到的最好的动"
"态角色控制器(可以在 2d/platformer 这个演示中查看)，但使用它需要相当高水平的技"
"能和对物理引擎的理解(或者对试验和试错有足够的耐心)。"

#: ../../docs/tutorials/physics/kinematic_character_2d.rst:19
#, fuzzy
msgid ""
"Some physics engines, such as Havok seem to swear by dynamic character "
"controllers as the best option, while others (PhysX) would rather promote "
"the kinematic one."
msgstr ""
"像Havok这样的物理引擎似乎认为动态角色控制器是最好的选择，而其他物理引擎"
"(PhysX)则更愿意推广Kinematic。"

#: ../../docs/tutorials/physics/kinematic_character_2d.rst:23
msgid "So, what is the difference?:"
msgstr "那么区别是什么呢？:"

#: ../../docs/tutorials/physics/kinematic_character_2d.rst:25
#, fuzzy
msgid ""
"A **dynamic character controller** uses a rigid body with an infinite "
"inertia tensor. Basically, it's a rigid body that can't rotate. Physics "
"engines always let objects collide, then solve their collisions all "
"together. This makes dynamic character controllers able to interact with "
"other physics objects seamlessly (as seen in the platformer demo), however "
"these interactions are not always predictable. Collisions can also take more "
"than one frame to be solved, so a few collisions may seem to displace a tiny "
"bit. Those problems can be fixed, but require a certain amount of skill."
msgstr ""
"**动态角色控制器** 使用具有无限惯性张量的刚体。 基本上，它是一个不能旋转的刚"
"体。 物理引擎总是让物体碰撞，然后一起解决它们的碰撞。 这使得动态角色控制器能"
"够无缝地与其他物理对象交互(如平台演示程序中所示)，但这些交互并不总是可预测"
"的。 碰撞也可能需要多个帧来解决，因此一些碰撞似乎可以取代一点点。 这些问题可"
"以修复，但需要一定的技能。"

#: ../../docs/tutorials/physics/kinematic_character_2d.rst:34
#, fuzzy
msgid ""
"A **kinematic character controller** is assumed to always begin in a non-"
"colliding state, and will always move to a non colliding state. If it starts "
"in a colliding state, it will try to free itself (like rigid bodies do), but "
"this is the exception, not the rule. This makes their control and motion a "
"lot more predictable and easier to program. However, as a downside, they "
"can't directly interact with other physics objects (unless done by hand in "
"code)."
msgstr ""
"**运动角色控制器** 被假设成以非碰撞状态开始，并且将始终移动到非碰撞状态。 如"
"果它以碰撞状态开始，它会尝试释放自己(就像刚体一样)，但这是例外，而不是规则。 "
"这使得他们的控制和动作更容易被预测并且更容易编程。 但是缺点是，它们不能直接与"
"其他物理对象交互(除非在代码中手动完成)。"

#: ../../docs/tutorials/physics/kinematic_character_2d.rst:42
#, fuzzy
msgid ""
"This short tutorial will focus on the kinematic character controller. "
"Basically, the old-school way of handling collisions (which is not "
"necessarily simpler under the hood, but well hidden and presented as a nice "
"and simple API)."
msgstr ""
"这个简短的教程将重点介绍运动角色控制器。 基本上，oldschool处理碰撞的方式(在引"
"擎盖下不一定简单，但隐藏得很好，并作为一个漂亮和简单的API呈现)。"

#: ../../docs/tutorials/physics/kinematic_character_2d.rst:48
msgid "Physics process"
msgstr "物理过程"

#: ../../docs/tutorials/physics/kinematic_character_2d.rst:50
msgid ""
"To manage the logic of a kinematic body or character, it is always advised "
"to use physics process, because it's called before physics step and its "
"execution is in sync with physics server, also it is called the same amount "
"of times per second, always. This makes physics and motion calculation work "
"in a more predictable way than using regular process, which might have "
"spikes or lose precision if the frame rate is too high or too low."
msgstr ""
"为了管理运动物体或角色的逻辑，总是建议使用物理过程，因为它在物理步骤之前被调"
"用并且它的执行与物理服务器同步，它也被称为每秒相同的次数。 这使得物理和运动计"
"算以比使用常规过程更可预测的方式工作，如果帧速率太高或太低，则可能具有尖峰或"
"丢失精度。"

#: ../../docs/tutorials/physics/kinematic_character_2d.rst:81
msgid ""
"To have something to test, here's the scene (from the tilemap tutorial): :"
"download:`kbscene.zip <files/kbscene.zip>`. We'll be creating a new scene "
"for the character. Use the robot sprite and create a scene like this:"
msgstr ""
"要测试一下，这里是场景(来自tilemap教程): :download:`kbscene.zip <files/"
"kbscene.zip>`。 我们将为角色创造一个新场景。 使用机器人精灵并创建一个这样的场"
"景:"

#: ../../docs/tutorials/physics/kinematic_character_2d.rst:87
#, fuzzy
msgid ""
"You'll notice that there's a warning icon next to our CollisionShape2D node; "
"that's because we haven't defined a shape for it. Create a new CircleShape2D "
"in the shape property of CollisionShape2D. Click on <CircleShape2D> to go to "
"the options for it, and set the radius to 30:"
msgstr ""
"您会注意到我们的CollisionShape2D节点旁边有一个警告图标，这是因为我们没有为它"
"定义形状。 在CollisionShape2D的shape属性中创建一个新的CircleShape2D。 单击"
"<CircleShape2D>转到它的选项，并将半径设置为30:"

#: ../../docs/tutorials/physics/kinematic_character_2d.rst:94
#, fuzzy
msgid ""
"**Note: As mentioned before in the physics tutorial, the physics engine "
"can't handle scale on most types of shapes (only collision polygons, planes "
"and segments work), so always change the parameters (such as radius) of the "
"shape instead of scaling it. The same is also true for the kinematic/rigid/"
"static bodies themselves, as their scale affects the shape scale.**"
msgstr ""
"**注意:如前面在物理教程中所提到的，物理引擎无法处理大多数类型的形状(只有碰撞"
"多边形，平面和线段工作)，所以总是改变形状的参数(如半径) 缩放它。 运动/刚性/静"
"态物体本身也是如此，因为它们的尺度会影响形状比例。**"

#: ../../docs/tutorials/physics/kinematic_character_2d.rst:101
#, fuzzy
msgid ""
"Now, create a script for the character, the one used as an example above "
"should work as a base."
msgstr "现在为角色创建一个脚本，上面用作示例的脚本应该作为基础。"

#: ../../docs/tutorials/physics/kinematic_character_2d.rst:104
msgid ""
"Finally, instance that character scene in the tilemap, and make the map "
"scene the main one, so it runs when pressing play."
msgstr ""
"最后，实例化tilemap中的角色场景，并使地图场景成为主场景，因此在按下播放时运"
"行。"

#: ../../docs/tutorials/physics/kinematic_character_2d.rst:110
#, fuzzy
msgid "Moving the kinematic character"
msgstr "移动运动学角色(2D)"

#: ../../docs/tutorials/physics/kinematic_character_2d.rst:112
#, fuzzy
msgid ""
"Go back to the character scene, and open the script, the magic begins now! "
"Kinematic body will do nothing by default, but it has a useful function "
"called :ref:`KinematicBody2D.move_and_collide() "
"<class_KinematicBody2D_method_move_and_collide>`. This function takes a :ref:"
"`Vector2 <class_Vector2>` as an argument, and tries to apply that motion to "
"the kinematic body. If a collision happens, it stops right at the moment of "
"the collision."
msgstr ""
"回到角色场景，打开脚本，魔法就要开始！ 默认情况下，运动体不会做任何事情，但它"
"有一个有用的函数叫做 :ref:`KinematicBody2D."
"move_and_collide()<class_KinematicBody2D_method_move_and_collide>`。 此函数"
"将 :ref:`Vector2 <class_Vector2>` 作为参数，并尝试将该运动应用于运动体。 如果"
"发生碰撞，它会在碰撞时停止。"

#: ../../docs/tutorials/physics/kinematic_character_2d.rst:120
msgid "So, let's move our sprite downwards until it hits the floor:"
msgstr "所以，让我们向下移动我们的精灵，直到它撞上地板:"

#: ../../docs/tutorials/physics/kinematic_character_2d.rst:144
msgid ""
"The result is that the character will move, but stop right when hitting the "
"floor. Pretty cool, huh?"
msgstr "结果是角色会移动，但在击中地板时会停止。 很酷，对吧？"

#: ../../docs/tutorials/physics/kinematic_character_2d.rst:147
#, fuzzy
msgid ""
"The next step will be adding gravity to the mix, this way it behaves a "
"little more like a regular game character:"
msgstr "下一步将增加重力，这样它的行为更像一个真正的游戏角色:"

#: ../../docs/tutorials/physics/kinematic_character_2d.rst:183
#, fuzzy
msgid ""
"Now the character falls smoothly. Let's make it walk to the sides, left and "
"right when touching the directional keys. Remember that the values being "
"used (for speed at least) are pixels/second."
msgstr ""
"现在角色顺利落下。 当触摸方向键时，让它向左侧和右侧行走。 请记住，所使用的值"
"(至少速度)是像素/秒。"

#: ../../docs/tutorials/physics/kinematic_character_2d.rst:187
msgid "This adds simple walking support by pressing left and right:"
msgstr "通过向左和向右按下可以增加简单的步行支持:"

#: ../../docs/tutorials/physics/kinematic_character_2d.rst:252
msgid "And give it a try."
msgstr "试一试。"

#: ../../docs/tutorials/physics/kinematic_character_2d.rst:254
msgid ""
"This is a good starting point for a platformer. A more complete demo can be "
"found in the demo zip distributed with the engine, or in the https://github."
"com/godotengine/godot-demo-projects/tree/master/2d/kinematic_character."
msgstr ""
"这是平台游戏的良好起点。 可以在随引擎分发的演示zip中找到更完整的演示，或者在"
"https://github.com/godotengine/godot-demo-projects/tree/master/2d/"
"kinematic_character中找到。"

#: ../../docs/tutorials/physics/soft_body.rst:4
#, fuzzy
msgid "SoftBody"
msgstr "StaticBody2D"

#: ../../docs/tutorials/physics/soft_body.rst:6
#, fuzzy
msgid ""
"Soft bodies (or *soft-body dynamics*) simulate movement, changing shape and "
"other physical properties of deformable objects. This can for example be "
"used to simulate cloth or to create more realistic characters."
msgstr ""
"柔体(或*柔体动力学*)模拟可变形物体的运动、改变形状和其他物理特性。例如，这可"
"以用于模拟布料或创建更逼真的角色。"

#: ../../docs/tutorials/physics/soft_body.rst:10
#, fuzzy
msgid "Basic set-up"
msgstr "基本语法:"

#: ../../docs/tutorials/physics/soft_body.rst:12
msgid ""
"A :ref:`SoftBody <class_SoftBody>` node is used for soft body simulations."
msgstr ""

#: ../../docs/tutorials/physics/soft_body.rst:14
msgid "We will create a bouncy cube to demonstrate the setup of a soft body."
msgstr "我们将创建一个弹性立方体来演示软体的设置。"

#: ../../docs/tutorials/physics/soft_body.rst:16
msgid ""
"Create a new scene with a ``Spatial`` node as root. Then, create a "
"``Softbody`` node. Add a ``CubeMesh`` in the ``mesh`` property of the node "
"in the inspector and increase the subdivision of the mesh for simulation."
msgstr ""

#: ../../docs/tutorials/physics/soft_body.rst:20
msgid ""
"Set the parameters to obtain the type of soft body you aim for. Try to keep "
"the ``Simulation Precision`` above 5, otherwise, the soft body may collapse."
msgstr ""

#: ../../docs/tutorials/physics/soft_body.rst:24
msgid ""
"Handle some parameters with care, as some value can lead to strange results. "
"For example, if the shape is not completely closed and you set pressure to "
"more than 0, the softbody will fly around like a plastic bag under strong "
"wind."
msgstr ""

#: ../../docs/tutorials/physics/soft_body.rst:26
#, fuzzy
msgid "Play the scene to view the simulation."
msgstr "播放适当的动画。"

#: ../../docs/tutorials/physics/soft_body.rst:28
msgid ""
"To improve the simulation's result, increase the ``Simulation Precision``, "
"this will give significant improvement at the cost of performance."
msgstr ""

#: ../../docs/tutorials/physics/soft_body.rst:31
#, fuzzy
msgid "Cloak simulation"
msgstr "加载动画"

#: ../../docs/tutorials/physics/soft_body.rst:33
msgid "Let's make a cloak in the Platformer3D demo."
msgstr ""

#: ../../docs/tutorials/physics/soft_body.rst:35
#, fuzzy
msgid ""
"You can download the Platformer3D demo on `GitHub <https://github.com/"
"godotengine/godot-demo-projects/tree/master/3d/platformer>` or `the Asset "
"Library <https://godotengine.org/asset-library/asset/125>`_."
msgstr ""
"您可以在 `GitHub <https://github.com/godotengine/godot-demo-projects/tree/"
"master/3d/platformer>`_ 上下载Platformer3D演示或使用 `Asset Library <https://"
"godotengine.org/asset-library/asset/125>`_ 。"

#: ../../docs/tutorials/physics/soft_body.rst:37
msgid ""
"Open the ``Player`` scene, add a ``SoftBody`` node and assign a "
"``PlaneMesh`` to it."
msgstr ""

#: ../../docs/tutorials/physics/soft_body.rst:39
msgid ""
"Open the ``PlaneMesh`` properties and set the size(x: 0.5 y: 1) then set "
"``Subdivide Width`` and ``Subdivide Depth`` to 5. Adjust the ``SoftBody``'s "
"position. You should end up with something like this:"
msgstr ""

#: ../../docs/tutorials/physics/soft_body.rst:43
msgid "Subdivision generates a more tessellated mesh for better simulations."
msgstr ""

#: ../../docs/tutorials/physics/soft_body.rst:45
msgid ""
"Add a :ref:`BoneAttachment <class_BoneAttachment>` node under the skeleton "
"node and select the Neck bone to attach the cloak to the character skeleton."
msgstr ""

#: ../../docs/tutorials/physics/soft_body.rst:47
msgid ""
"``BoneAttachment`` node is to attach objects to a bone of a armature. The "
"attached object will follow the bone's movement, weapon of a character can "
"be attached this way."
msgstr ""

#: ../../docs/tutorials/physics/soft_body.rst:51
msgid ""
"To create pinned joints, select the upper vertices in the ``SoftBody`` node:"
msgstr ""

#: ../../docs/tutorials/physics/soft_body.rst:55
msgid ""
"The pinned joints can be find in ``SoftBody``'s ``Attachments`` property, "
"choose the ``BoneAttachment`` as the ``SpatialAttachment`` for each pinned "
"joints, the pinned joints are now attached to the neck."
msgstr ""

#: ../../docs/tutorials/physics/soft_body.rst:59
msgid ""
"Last step is to avoid clipping by adding the Kinematic Body `Player` to "
"``Parent Collision Ignore`` of the ``SoftBody``."
msgstr ""

#: ../../docs/tutorials/physics/soft_body.rst:63
msgid "Play the scene and the cloak should simulate correctly."
msgstr ""

#: ../../docs/tutorials/physics/soft_body.rst:67
msgid ""
"This covers the basic settings of softbody, experiment with the parameters "
"to achieve the effect you are aiming for when making your game."
msgstr ""

#: ../../docs/tutorials/math/index.rst:2
msgid "Math"
msgstr "数学"

#: ../../docs/tutorials/math/vector_math.rst:4
msgid "Vector math"
msgstr "向量数学"

#: ../../docs/tutorials/math/vector_math.rst:9
msgid ""
"This tutorial is a short and practical introduction to linear algebra as it "
"applies to game development. Linear algebra is the study of vectors and "
"their uses. Vectors have many applications in both 2D and 3D development and "
"Godot uses them extensively. Developing a good understanding of vector math "
"is essential to becoming a strong game developer."
msgstr ""
"本教程是一个简短而实用的线性代数介绍，因为它适用于游戏开发。线性代数是研究向"
"量及其用途的学科。向量在二维和三维开发中都有许多应用，Godot对它们的应用非常广"
"泛。要成为一名优秀的游戏开发者，对向量数学的理解是必不可少的。"

#: ../../docs/tutorials/math/vector_math.rst:15
msgid ""
"This tutorial is **not** a formal textbook on linear algebra. We will only "
"be looking at how it is applied to game development. For a broader look at "
"the mathematics, see https://www.khanacademy.org/math/linear-algebra"
msgstr ""
"本教程 **不是** 线性代数的正式教科书。我们将只关注它如何应用于游戏开发。要更"
"全面地了解数学，请参见 https://www.khanacademy.org/math/linear-algebra"

#: ../../docs/tutorials/math/vector_math.rst:21
msgid "Coordinate systems (2D)"
msgstr "坐标系统(2D)"

#: ../../docs/tutorials/math/vector_math.rst:23
msgid ""
"In 2D space, coordinates are defined using a horizontal axis (``x``) and a "
"vertical axis (``y``). A particular position in 2D space is written as a "
"pair of values such as ``(4, 3)``."
msgstr ""
"在2D空间中，使用水平轴(“x”)和垂直轴(“y”)定义坐标。2D空间中的特定位置被写成一"
"对值，如``(4, 3)``。"

#: ../../docs/tutorials/math/vector_math.rst:29
msgid ""
"If you're new to computer graphics, it might seem odd that the positive "
"``y`` axis points **downwards** instead of upwards, as you probably learned "
"in math class. However, this is common in most computer graphics "
"applications."
msgstr ""
"如果您是计算机图形学的新手，您可能会觉得很奇怪， ``y`` 轴的正方向是 **向下"
"**，而不是向上(您在数学课上学到的就像那样)。然而，这在大多数计算机图形应用程"
"序中是常见的。"

#: ../../docs/tutorials/math/vector_math.rst:34
msgid ""
"Any position in the 2D plane can be identified by a pair of numbers in this "
"way. However, we can also think of the position ``(4, 3)`` as an **offset** "
"from the ``(0, 0)`` point, or **origin**. Draw an arrow pointing from the "
"origin to the point:"
msgstr ""
"二维平面上的任何位置都可以用一对数字来表示。然而，我们也可以将位置 ``(4, "
"3)`` 看作是从 ``(0, 0)`` 点或 **原点** 出发的 **偏移** 。画一个箭头从原点指向"
"点:"

#: ../../docs/tutorials/math/vector_math.rst:41
msgid ""
"This is a **vector**. A vector represents a lot of useful information. As "
"well as telling us that the point is at ``(4, 3)``, we can also think of it "
"as an angle ``θ`` and a length (or magnitude) ``m``. In this case, the arrow "
"is a **position vector** - it denotes a position in space, relative to the "
"origin."
msgstr ""
"这是一个 **向量** 。向量表示许多有用的信息。除了告诉我们点在 ``(4, 3)`` 之"
"外，我们还可以把它看成角度 ``θ`` 和长度(或幅度) ``m``。在这种情况下，箭头是一"
"个 **位置向量** -它表示空间中相对于原点的位置。"

#: ../../docs/tutorials/math/vector_math.rst:47
msgid ""
"A very important point to consider about vectors is that they only represent "
"**relative** direction and magnitude. There is no concept of a vector's "
"position. The following two vectors are identical:"
msgstr ""
"关于向量，需要考虑的一个重要点是它们仅表示 **相对** 方向和大小。没有一个向量"
"的位置的概念。以下两个向量相同:"

#: ../../docs/tutorials/math/vector_math.rst:53
msgid ""
"Both vectors represent a point 4 units to the right and 3 units below some "
"starting point. It does not matter where on the plane you draw the vector, "
"it always represents a relative direction and magnitude."
msgstr ""
"这两个向量都表示向右4个单位，在某个起始点以下3个单位。不管您在平面上画哪个向"
"量，它总是代表一个相对的方向和大小。"

#: ../../docs/tutorials/math/vector_math.rst:58
msgid "Vector operations"
msgstr "向量运算"

#: ../../docs/tutorials/math/vector_math.rst:60
#, fuzzy
msgid ""
"You can use either method (x and y coordinates or angle and magnitude) to "
"refer to a vector, but for convenience, programmers typically use the "
"coordinate notation. For example, in Godot, the origin is the top-left "
"corner of the screen, so to place a 2D node named ``Node2D`` 400 pixels to "
"the right and 300 pixels down, use the following code:"
msgstr ""
"您可以使用任意一种方法(x和y坐标或角度和大小)来引用向量，但是为了方便起见，程"
"序员通常使用坐标表示法。例如，在Godot中，原点是屏幕左上角，因此要将一个名为"
"``Node2D`` 的2D节点向右放置400像素，向下放置300像素，请使用以下代码:"

#: ../../docs/tutorials/math/vector_math.rst:76
#, fuzzy
msgid ""
"Godot supports both :ref:`Vector2 <class_Vector2>` and :ref:`Vector3 "
"<class_Vector3>` for 2D and 3D usage, respectively. The same mathematical "
"rules discussed in this article apply to both types."
msgstr ""
"Godot支持 :ref:`Vector2 <class_Vector2>` 和 :ref:`Vector3 <class_Vector3>` 分"
"别用于2D和3D。本文讨论的数学规则同样适用于这两种类型。"

#: ../../docs/tutorials/math/vector_math.rst:80
msgid "Member access"
msgstr "成员访问"

#: ../../docs/tutorials/math/vector_math.rst:82
msgid ""
"The individual components of the vector can be accessed directly by name."
msgstr "向量的各个组成部分可以直接通过名称访问。"

#: ../../docs/tutorials/math/vector_math.rst:103
msgid "Adding vectors"
msgstr "添加向量"

#: ../../docs/tutorials/math/vector_math.rst:105
msgid ""
"When adding or subtracting two vectors, the corresponding components are "
"added:"
msgstr "当两个向量相加或相减时，相应的分量相加:"

#: ../../docs/tutorials/math/vector_math.rst:116
msgid ""
"We can also see this visually by adding the second vector at the end of the "
"first:"
msgstr "我们也可以通过在第一个向量的末尾加上第二个向量来直观地看到这一点:"

#: ../../docs/tutorials/math/vector_math.rst:121
msgid "Note that adding ``a + b`` gives the same result as ``b + a``."
msgstr "注意，加法 ``a + b`` 和 ``b + a``得到的结果是一样的。"

#: ../../docs/tutorials/math/vector_math.rst:123
msgid "Scalar multiplication"
msgstr "标量乘法"

#: ../../docs/tutorials/math/vector_math.rst:125
msgid ""
"Vectors represent both direction and magnitude. A value representing only "
"magnitude is called a **scalar**."
msgstr "向量表示方向和幅度。仅表示幅值的值称为 **标量**。"

#: ../../docs/tutorials/math/vector_math.rst:128
msgid "A vector can be multiplied by a **scalar**:"
msgstr "一个向量可以乘以一个标量:"

#: ../../docs/tutorials/math/vector_math.rst:143
msgid ""
"Multiplying a vector by a scalar does not change its direction, only its "
"magnitude. This is how you **scale** a vector."
msgstr "向量乘以标量不会改变它的方向，只会改变它的幅值。这就是缩放向量的方法。"

#: ../../docs/tutorials/math/vector_math.rst:147
msgid "Practical applications"
msgstr "实际应用"

#: ../../docs/tutorials/math/vector_math.rst:149
msgid "Let's look at two common uses for vector addition and subtraction."
msgstr "让我们看看向量加法和减法的两种常见用法。"

#: ../../docs/tutorials/math/vector_math.rst:151
msgid "Movement"
msgstr "移动"

#: ../../docs/tutorials/math/vector_math.rst:153
msgid ""
"A vector can represent **any** quantity with a magnitude and direction. "
"Typical examples are: position, velocity, acceleration, and force. In this "
"image, the spaceship at step 1 has a position vector of ``(1,3)`` and a "
"velocity vector of ``(2,1)``. The velocity vector represents how far the "
"ship moves each step. We can find the position for step 2 by adding the "
"velocity to the current position."
msgstr ""
"向量可以表示具有大小和方向的任何量。典型的示例有:位置、速度、加速度和力。在这"
"幅图像中，在第一步的飞船有一个位置向量为``(1,3)``和一个速度向量为``(2,1)``。"
"速度向量表示船舶每一步移动的距离。通过将速度加到当前位置，我们可以求出步骤2的"
"位置。"

#: ../../docs/tutorials/math/vector_math.rst:161
msgid ""
"Velocity measures the **change** in position per unit of time. The new "
"position is found by adding velocity to the previous position."
msgstr ""
"速度测量单位时间内位置的变化。新的位置是通过在前一个位置上增加速度来找到的。"

#: ../../docs/tutorials/math/vector_math.rst:164
msgid "Pointing toward a target"
msgstr "指向一个目标"

#: ../../docs/tutorials/math/vector_math.rst:166
msgid ""
"In this scenario, you have a tank that wishes to point its turret at a "
"robot. Subtracting the tank's position from the robot's position gives the "
"vector pointing from the tank to the robot."
msgstr ""
"在这个场景中，您有一个坦克，希望它的炮塔指向机器人。从机器人的位置减去坦克的"
"位置就得到了从坦克指向机器人的向量。"

#: ../../docs/tutorials/math/vector_math.rst:172
msgid "To find a vector pointing from ``A`` to ``B`` use ``B - A``."
msgstr "要找到从 ``A`` 指向 ``B`` 的向量，请使用 ``B - A``。"

#: ../../docs/tutorials/math/vector_math.rst:175
msgid "Unit vectors"
msgstr "单位向量"

#: ../../docs/tutorials/math/vector_math.rst:177
msgid ""
"A vector with **magnitude** of ``1`` is called a **unit vector**. They are "
"also sometimes referred to as **direction vectors** or **normals**. Unit "
"vectors are helpful when you need to keep track of a direction."
msgstr ""
"一个 **大小** 为 ``1`` 的向量称为 **单位向量** 。它们有时也被称为 **方向向量"
"** 或 **法线** 。当您需要跟踪一个方向时，单位向量是有用的。"

#: ../../docs/tutorials/math/vector_math.rst:182
msgid "Normalization"
msgstr "归一化"

#: ../../docs/tutorials/math/vector_math.rst:184
msgid ""
"**Normalizing** a vector means reducing its length to ``1`` while preserving "
"its direction. This is done by dividing each of its components by its "
"magnitude:"
msgstr ""
"**归一化** 向量意味着在保持其方向的同时将其长度减少到 ``1`` 。这是通过将每个"
"分量除以其大小来完成的:"

#: ../../docs/tutorials/math/vector_math.rst:203
msgid ""
"Because this is such a common operation, ``Vector2`` and ``Vector3`` provide "
"a method for normalizing:"
msgstr ""
"由于这是一种非常常见的操作， ``Vector2`` 和 ``Vector3`` 提供了归一化的方法:"

#: ../../docs/tutorials/math/vector_math.rst:216
msgid ""
"Because normalization involves dividing by the vector's length, you cannot "
"normalize a vector of length ``0``. Attempting to do so will result in an "
"error."
msgstr ""
"因为归一化需要除以向量的长度，所以不能对长度为“0”的向量进行归一化。试图这样做"
"会导致错误。"

#: ../../docs/tutorials/math/vector_math.rst:221
msgid "Reflection"
msgstr "反射"

#: ../../docs/tutorials/math/vector_math.rst:223
msgid ""
"A common use of unit vectors is to indicate **normals**. Normal vectors are "
"unit vectors aligned perpendicularly to a surface, defining its direction. "
"They are commonly used for lighting, collisions, and other operations "
"involving surfaces."
msgstr ""
"单位向量的一种常见用法是表示 **法线** 。法向量是垂直于曲面的单位向量，定义了"
"曲面的方向。它们通常用于照明、碰撞和涉及表面的其他操作。"

#: ../../docs/tutorials/math/vector_math.rst:228
msgid ""
"For example, imagine we have a moving ball that we want to bounce off a wall "
"or other object:"
msgstr "例如，假设我们有一个移动的球，我们想从墙上或其他物体上弹回来:"

#: ../../docs/tutorials/math/vector_math.rst:233
msgid ""
"The surface normal has a value of ``(0, -1)`` because this is a horizontal "
"surface. When the ball collides, we take its remaining motion (the amount "
"left over when it hits the surface) and reflect it using the normal. In "
"Godot, the :ref:`Vector2 <class_Vector2>` class has a ``bounce()`` method to "
"handle this. Here is a GDScript example of the diagram above using a :ref:"
"`KinematicBody2D <class_KinematicBody2D>`:"
msgstr ""
"因为这是一个水平曲面，所以曲面法线的值为 ``(0, -1)`` 。当球碰撞时，我们取它的"
"剩余运动(当它撞到表面时剩余的量)，用法线反射它。在Godot中， :ref:`Vector2 "
"<class_Vector2>` 类有一个 ``bounce()`` 方法来处理这个问题。上图有一个使用 :"
"ref:`KinematicBody2D <class_KinematicBody2D>` 的GDScript示例:"

#: ../../docs/tutorials/math/vector_math.rst:263
msgid "Dot product"
msgstr "点乘"

#: ../../docs/tutorials/math/vector_math.rst:265
msgid ""
"The **dot product** is one of the most important concepts in vector math, "
"but is often misunderstood. Dot product is an operation on two vectors that "
"returns a **scalar**. Unlike a vector, which contains both magnitude and "
"direction, a scalar value has only magnitude."
msgstr ""
"**点乘** 是向量数学中最重要的概念之一，但经常被误解。点乘是对两个向量的操作，"
"它返回一个 **标量**。与同时包含大小和方向的向量不同，标量值只有大小。"

#: ../../docs/tutorials/math/vector_math.rst:270
msgid "The formula for dot product takes two common forms:"
msgstr "点乘公式有两种常见形式:"

#: ../../docs/tutorials/math/vector_math.rst:272
msgid ""
"A \\cdot B = \\left \\| A \\right \\|\\left \\| B \\right \\|\\cos \\Theta"
msgstr ""
"A \\cdot B = \\left \\| A \\right \\|\\left \\| B \\right \\|\\cos \\Theta"

#: ../../docs/tutorials/math/vector_math.rst:278
msgid "A \\cdot B = A_{x}B_{x} + A_{y}B_{y}"
msgstr "A \\cdot B = A_{x}B_{x} + A_{y}B_{y}"

#: ../../docs/tutorials/math/vector_math.rst:282
msgid ""
"However, in most cases it is easiest to use the built-in method. Note that "
"the order of the two vectors does not matter:"
msgstr ""
"然而，在大多数情况下，使用内置方法是最容易的。注意，两个向量的顺序并不重要:"

#: ../../docs/tutorials/math/vector_math.rst:296
msgid ""
"The dot product is most useful when used with unit vectors, making the first "
"formula reduce to just ``cosθ``. This means we can use the dot product to "
"tell us something about the angle between two vectors:"
msgstr ""
"当与单位向量一起使用时，点积是最有用的，使得第一个公式减少到仅有 ``cosθ``。这"
"意味着我们可以使用点积来告诉我们关于两个向量之间的角度的一些信息:"

#: ../../docs/tutorials/math/vector_math.rst:302
msgid ""
"When using unit vectors, the result will always be between ``-1`` (180°) and "
"``1`` (0°)."
msgstr "当使用单位向量,结果总是会在 ``-1`` (180°) 和 ``1`` (0°) 之间。"

#: ../../docs/tutorials/math/vector_math.rst:306
msgid "Facing"
msgstr "面向问题"

#: ../../docs/tutorials/math/vector_math.rst:308
msgid ""
"We can use this fact to detect whether an object is facing toward another "
"object. In the diagram below, the player ``P`` is trying to avoid the "
"zombies ``A`` and ``B``. Assuming a zombie's field of view is **180°**, can "
"they see the player?"
msgstr ""
"我们可以利用这个事实来检测一个物体是否面向另一个物体。在下图中，游戏角色 "
"``P`` 试图避开丧尸 ``A`` 和 ``B`` 。假设一个丧尸的视野是 **180°** , 他们能看"
"到游戏角色吗?"

#: ../../docs/tutorials/math/vector_math.rst:314
msgid ""
"The green arrows ``fA`` and ``fB`` are **unit vectors** representing the "
"zombies' facing directions and the blue semicircle represents its field of "
"view. For zombie ``A``, we find the direction vector ``AP`` pointing to the "
"player using ``P - A`` and normalize it. If the angle between this vector "
"and the facing vector is less than 90°, then the zombie can see the player."
msgstr ""
"绿色箭头 ``fA`` 和 ``fB`` 是 **单位向量** 表示丧尸的朝向，蓝色半圆表示其视"
"野。对于丧尸 ``A`` ，我们使用 ``P - A`` 找到指向游戏角色的方向向量 ``AP`` 并"
"将其归一化。如果这个向量和面向向量之间的夹角小于90°,那么丧尸可以看到游戏角"
"色。"

#: ../../docs/tutorials/math/vector_math.rst:321
msgid "In code it would look like this:"
msgstr "在代码中是这样的:"

#: ../../docs/tutorials/math/vector_math.rst:339
msgid "Cross product"
msgstr "叉乘"

#: ../../docs/tutorials/math/vector_math.rst:341
#, fuzzy
msgid ""
"Like the dot product, the **cross product** is an operation on two vectors. "
"However, the result of the cross product is a vector with a direction that "
"is perpendicular to both. Its magnitude depends on their relative angle. If "
"two vectors are parallel, the result of their cross product will be a null "
"vector."
msgstr ""
"和点乘一样， **叉乘** 是对两个向量的运算。然而，叉乘的结果是一个方向垂直于这"
"两个向量的向量。它的大小取决于它们的相对角度。如果两个向量是平行的，它们叉乘"
"的结果就是零向量。"

#: ../../docs/tutorials/math/vector_math.rst:346
msgid ""
"\\left \\|a \\times b  \\right \\| = \\left \\| a \\right \\|\\left \\| b "
"\\right \\|\\ |\\sin(a,b)|"
msgstr ""
"\\left \\|a \\times b  \\right \\| = \\left \\| a \\right \\|\\left \\| b "
"\\right \\|\\ |\\sin(a,b)|"

#: ../../docs/tutorials/math/vector_math.rst:352
msgid "The cross product is calculated like this:"
msgstr "叉乘是这样计算的:"

#: ../../docs/tutorials/math/vector_math.rst:371
msgid "With Godot, you can use the built-in method:"
msgstr "使用Godot，您可以使用内置的方法:"

#: ../../docs/tutorials/math/vector_math.rst:382
msgid ""
"In the cross product, order matters. ``a.cross(b)`` does not give the same "
"result as ``b.cross(a)``. The resulting vectors point in **opposite** "
"directions."
msgstr ""
"在叉乘中，顺序很重要。``a.cross(b)`` 和 ``b.cross(a)`` 的结果不一样。得到的向"
"量指向相反的方向。"

#: ../../docs/tutorials/math/vector_math.rst:387
msgid "Calculating normals"
msgstr "法线计算"

#: ../../docs/tutorials/math/vector_math.rst:389
msgid ""
"One common use of cross products is to find the surface normal of a plane or "
"surface in 3D space. If we have the triangle ``ABC`` we can use vector "
"subtraction to find two edges ``AB`` and ``AC``. Using the cross product, "
"``AB x AC`` produces a vector perpendicular to both: the surface normal."
msgstr ""
"叉乘的一种常用方法是在三维空间中求平面或曲面的表面法向量。如果我们有三角形 "
"``ABC`` 我们可以用向量减法找到两条边 ``AB`` 和 ``AC``。通过叉乘， ``AB x "
"AC`` 得到一个垂直于这两个向量的向量:表面法向量。"

#: ../../docs/tutorials/math/vector_math.rst:394
msgid "Here is a function to calculate a triangle's normal:"
msgstr "下面是一个计算三角形法线的函数:"

#: ../../docs/tutorials/math/vector_math.rst:418
msgid "Pointing to a target"
msgstr "指向目标"

#: ../../docs/tutorials/math/vector_math.rst:420
#, fuzzy
msgid ""
"In the dot product section above, we saw how it could be used to find the "
"angle between two vectors. However, in 3D, this is not enough information. "
"We also need to know what axis to rotate around. We can find that by "
"calculating the cross product of the current facing direction and the target "
"direction. The resulting perpendicular vector is the axis of rotation."
msgstr ""
"在上面的点乘部分，我们看到了如何用它来求两个向量之间的夹角。然而，在3D中，这"
"是不够的。我们还需要知道绕哪个轴旋转。这可以通过计算当前方向与目标方向的叉乘"
"得到。得到的垂直向量是旋转轴。"

#: ../../docs/tutorials/math/vector_math.rst:428
msgid "More information"
msgstr "更多信息"

#: ../../docs/tutorials/math/vector_math.rst:430
msgid ""
"For more information on using vector math in Godot, see the following "
"articles:"
msgstr "有关在Godot中使用向量数学的更多信息，请参阅以下文章:"

#: ../../docs/tutorials/math/vector_math.rst:432
msgid ":ref:`doc_vectors_advanced`"
msgstr ":ref:`doc_vectors_advanced`"

#: ../../docs/tutorials/math/vector_math.rst:433
msgid ":ref:`doc_matrices_and_transforms`"
msgstr ":ref:`doc_matrices_and_transforms`"

#: ../../docs/tutorials/math/vectors_advanced.rst:4
msgid "Advanced vector math"
msgstr "高等向量数学"

#: ../../docs/tutorials/math/vectors_advanced.rst:7
msgid "Planes"
msgstr "平面"

#: ../../docs/tutorials/math/vectors_advanced.rst:9
msgid ""
"The dot product has another interesting property with unit vectors. Imagine "
"that perpendicular to that vector (and through the origin) passes a plane. "
"Planes divide the entire space into positive (over the plane) and negative "
"(under the plane), and (contrary to popular belief) you can also use their "
"math in 2D:"
msgstr ""
"点乘对于单位向量还有一个有趣的性质。想象垂直于这个向量(通过原点)经过一个平"
"面。平面将整个空间划分为正(在平面上)和负(在平面下)，(与普遍的看法相反)您也可"
"以在2D中使用它们的数学:"

#: ../../docs/tutorials/math/vectors_advanced.rst:17
msgid ""
"Unit vectors that are perpendicular to a surface (so, they describe the "
"orientation of the surface) are called **unit normal vectors**. Though, "
"usually they are just abbreviated as *normals*. Normals appear in planes, 3D "
"geometry (to determine where each face or vertex is siding), etc. A "
"**normal** *is* a **unit vector**, but it's called *normal* because of its "
"usage. (Just like we call (0,0) the Origin!)."
msgstr ""
"垂直于表面的单位向量(因此，它们描述了表面的方向)称为 **单位法向量** 。不过，"
"它们通常只是缩写为 *法线* 。法线出现在平面、3D几何中(以确定每个面或顶点的侧"
"边)，等等。一个 **法线** 就是一个 **单位向量**，但是由于它的使用，它被称为 *"
"法线* 。(就像我们说坐标(0，0)就是原点一样！)."

#: ../../docs/tutorials/math/vectors_advanced.rst:24
msgid ""
"It's as simple as it looks. The plane passes by the origin and the surface "
"of it is perpendicular to the unit vector (or *normal*). The side towards "
"the vector points to is the positive half-space, while the other side is the "
"negative half-space. In 3D this is exactly the same, except that the plane "
"is an infinite surface (imagine an infinite, flat sheet of paper that you "
"can orient and is pinned to the origin) instead of a line."
msgstr ""
"它就像看起来那样简单。平面经过原点，它的表面垂直于单位向量(或 *法线* )。指向"
"向量的一边是正半空间，而另一边是负半空间。在3维空间中，这完全相同，除了平面是"
"一个无限的表面(想象一张无限伸展的平坦纸张，它固定在原点)而不是直线。"

#: ../../docs/tutorials/math/vectors_advanced.rst:33
msgid "Distance to plane"
msgstr "到平面的距离"

#: ../../docs/tutorials/math/vectors_advanced.rst:35
msgid ""
"Now that it's clear what a plane is, let's go back to the dot product. The "
"dot product between a **unit vector** and any **point in space** (yes, this "
"time we do dot product between vector and position), returns the **distance "
"from the point to the plane**:"
msgstr ""
"现在，我们很清楚了平面是什么，让我们再回到点乘上。 **单位向量** 和任何 **空间"
"点** 之间的点乘(是的，这次我们在向量和位置之间进行点乘)，将返回 **从点到平面"
"的距离** :"

#: ../../docs/tutorials/math/vectors_advanced.rst:49
msgid ""
"But not just the absolute distance, if the point is in the negative half "
"space the distance will be negative, too:"
msgstr "但不仅仅是绝对距离，如果点在负半空间中，距离也是负的:"

#: ../../docs/tutorials/math/vectors_advanced.rst:54
msgid "This allows us to tell which side of the plane a point is."
msgstr "这使我们能够知道点在平面的哪一侧。"

#: ../../docs/tutorials/math/vectors_advanced.rst:57
msgid "Away from the origin"
msgstr "远离原点"

#: ../../docs/tutorials/math/vectors_advanced.rst:59
msgid ""
"I know what you are thinking! So far this is nice, but *real* planes are "
"everywhere in space, not only passing through the origin. You want real "
"*plane* action and you want it *now*."
msgstr ""
"我知道您在想什么！到目前为止，这还不错，但 *真正的* 平面在空间中无处不在，而"
"不仅仅是通过原点的平面。您想要真正的 *平面* ，您 *现在* 就想行动起来。"

#: ../../docs/tutorials/math/vectors_advanced.rst:63
msgid ""
"Remember that planes not only split space in two, but they also have "
"*polarity*. This means that it is possible to have perfectly overlapping "
"planes, but their negative and positive half-spaces are swapped."
msgstr ""
"记住，平面不仅把空间分成两半，而且它们还有 *极性* 。这意味着有可能有完全重叠"
"的平面，但是它们的负半空间和正半空间是相反的。"

#: ../../docs/tutorials/math/vectors_advanced.rst:67
msgid ""
"With this in mind, let's describe a full plane as a **normal** *N* and a "
"**distance from the origin** scalar *D*. Thus, our plane is represented by N "
"and D. For example:"
msgstr ""
"记住这一点，让我们将整个平面描述为 **法线** *N* 和 **距原点的距离** 标量 "
"*D* 。因此，我们的平面将由N和D表示，例如:"

#: ../../docs/tutorials/math/vectors_advanced.rst:73
msgid ""
"For 3D math, Godot provides a :ref:`Plane <class_Plane>` built-in type that "
"handles this."
msgstr ""
"对于3维的情况，Godot提供了一个 :ref:`Plane <class_Plane>` 内置类型来处理这个"
"问题。"

#: ../../docs/tutorials/math/vectors_advanced.rst:76
msgid ""
"Basically, N and D can represent any plane in space, be it for 2D or 3D "
"(depending on the amount of dimensions of N) and the math is the same for "
"both. It's the same as before, but D is the distance from the origin to the "
"plane, travelling in N direction. As an example, imagine you want to reach a "
"point in the plane, you will just do:"
msgstr ""
"基本上，N和D可以表示空间中的任何平面，无论是对于2D还是3D(取决于变量N的维数)，"
"数学上对于两者都是一样的。和以前差不多，但D是原点沿N方向移动到平面的距离。例"
"如，想象一下您想在到达平面上的一个点，您会这样做:"

#: ../../docs/tutorials/math/vectors_advanced.rst:91
msgid ""
"This will stretch (resize) the normal vector and make it touch the plane. "
"This math might seem confusing, but it's actually much simpler than it "
"seems. If we want to tell, again, the distance from the point to the plane, "
"we do the same but adjusting for distance:"
msgstr ""
"这将拉伸(调整大小)法线向量并使其接触平面。这个数学可能看起来很疑惑，但实际上"
"比看起来简单得多。如果我们想再说一遍，从点到平面的距离，我们也会这样做，但是"
"要调整距离:"

#: ../../docs/tutorials/math/vectors_advanced.rst:105
msgid "The same thing, using a built-in function:"
msgstr "使用内置函数做同样的事情:"

#: ../../docs/tutorials/math/vectors_advanced.rst:116
msgid "This will, again, return either a positive or negative distance."
msgstr "这将再次返回一个正或负的距离。"

#: ../../docs/tutorials/math/vectors_advanced.rst:118
msgid ""
"Flipping the polarity of the plane can be done by negating both N and D. "
"This will result in a plane in the same position, but with inverted negative "
"and positive half spaces:"
msgstr ""
"翻转平面的极性可以通过同时对N和D取负来完成。这将导致平面处于相同的位置，但是"
"具有反转的负半空间和正半空间:"

#: ../../docs/tutorials/math/vectors_advanced.rst:133
msgid ""
"Of course, Godot also implements this operator in :ref:`Plane "
"<class_Plane>`, so doing:"
msgstr "当然，Godot也在 :ref:`Plane <class_Plane>` 中实现这个操作，像这样:"

#: ../../docs/tutorials/math/vectors_advanced.rst:145
msgid "Will work as expected."
msgstr "这将按预期工作。"

#: ../../docs/tutorials/math/vectors_advanced.rst:147
msgid ""
"So, remember, a plane is just that and its main practical use is calculating "
"the distance to it. So, why is it useful to calculate the distance from a "
"point to a plane? It's extremely useful! Let's see some simple examples.."
msgstr ""
"所以，记住，平面就是这样，它的主要用途就是计算到它的距离。那么，为什么计算一"
"个点到一个平面的距离是有用的呢？非常有用！让我们来看一些简单示例。"

#: ../../docs/tutorials/math/vectors_advanced.rst:153
msgid "Constructing a plane in 2D"
msgstr "在二维空间中构造平面"

#: ../../docs/tutorials/math/vectors_advanced.rst:155
msgid ""
"Planes clearly don't come out of nowhere, so they must be built. "
"Constructing them in 2D is easy, this can be done from either a normal (unit "
"vector) and a point, or from two points in space."
msgstr ""
"平面显然不是从哪儿冒出来的，所以必须构造。在2D中构造它们很简单，这可以从法线"
"(单位向量)和点，或者用2维空间中的两个点来完成。"

#: ../../docs/tutorials/math/vectors_advanced.rst:159
msgid ""
"In the case of a normal and a point, most of the work is done, as the normal "
"is already computed, so just calculate D from the dot product of the normal "
"and the point."
msgstr ""
"针对法线和点的情况，大部分工作已经完成，因为当法线已经计算出来时，只需从法线"
"和点的点乘得到D。"

#: ../../docs/tutorials/math/vectors_advanced.rst:174
msgid ""
"For two points in space, there are actually two planes that pass through "
"them, sharing the same space but with normal pointing to the opposite "
"directions. To compute the normal from the two points, the direction vector "
"must be obtained first, and then it needs to be rotated 90° degrees to "
"either side:"
msgstr ""
"对于空间中的两个点，实际上会有两个平面同时经过它们，它们共享相同的空间，但是"
"法线方向相反。为了从这两个点计算面的法线，必须首先获得方向向量，然后将向任何"
"一边旋转90°:"

#: ../../docs/tutorials/math/vectors_advanced.rst:201
msgid ""
"The rest is the same as the previous example, either point_a or point_b will "
"work since they are in the same plane:"
msgstr ""
"其余的与前面的示例相同，point_a或point_b都可以工作，因为它们在相同的平面中:"

#: ../../docs/tutorials/math/vectors_advanced.rst:219
msgid ""
"Doing the same in 3D is a little more complex and will be explained further "
"down."
msgstr "在3D中做同样的操作稍微复杂一些，下面将进一步解释。"

#: ../../docs/tutorials/math/vectors_advanced.rst:223
msgid "Some examples of planes"
msgstr "平面的一些示例"

#: ../../docs/tutorials/math/vectors_advanced.rst:225
msgid ""
"Here is a simple example of what planes are useful for. Imagine you have a "
"`convex <https://www.mathsisfun.com/definitions/convex.html>`__ polygon. For "
"example, a rectangle, a trapezoid, a triangle, or just any polygon where no "
"faces bend inwards."
msgstr ""
"这里有一个简单的示例，说明平面的用途。假设您有一个 `凸 <https://www."
"mathsisfun.com/definitions/convex.html>`__ 多边形。例如，矩形、梯形、三角形或"
"任何没有向内弯曲的多边形。"

#: ../../docs/tutorials/math/vectors_advanced.rst:230
msgid ""
"For every segment of the polygon, we compute the plane that passes by that "
"segment. Once we have the list of planes, we can do neat things, for example "
"checking if a point is inside the polygon."
msgstr ""
"对多边形的每个部分，我们计算出经过该部分的平面。一旦我们有了平面的列表，我们"
"就可以做些分类的事情，例如检查一个点是否在多边形内部。"

#: ../../docs/tutorials/math/vectors_advanced.rst:234
msgid ""
"We go through all planes, if we can find a plane where the distance to the "
"point is positive, then the point is outside the polygon. If we can't, then "
"the point is inside."
msgstr ""
"我们遍历所有平面，如果我们能找到使得点到平面的距离为正的平面，那么点在多边形"
"之外。如果我们不能，那么这一点就在多边形内部。"

#: ../../docs/tutorials/math/vectors_advanced.rst:240
#: ../../docs/tutorials/math/vectors_advanced.rst:279
msgid "Code should be something like this:"
msgstr "代码应该是这样的:"

#: ../../docs/tutorials/math/vectors_advanced.rst:265
msgid ""
"Pretty cool, huh? But this gets much better! With a little more effort, "
"similar logic will let us know when two convex polygons are overlapping too. "
"This is called the Separating Axis Theorem (or SAT) and most physics engines "
"use this to detect collision."
msgstr ""
"很酷，是吧？但这可以变得更好！稍加努力，类似的逻辑将让我们知道两个凸多边形是"
"否重叠。这叫做分离轴定理(或SAT)，大多数物理引擎都用这个来检测碰撞。"

#: ../../docs/tutorials/math/vectors_advanced.rst:270
msgid ""
"With a point, just checking if a plane returns a positive distance is enough "
"to tell if the point is outside. With another polygon, we must find a plane "
"where *all* *the* *other* *polygon* *points* return a positive distance to "
"it. This check is performed with the planes of A against the points of B, "
"and then with the planes of B against the points of A:"
msgstr ""
"对于一个点，仅仅检查一个平面是否返回正距离就足以判断该点是否在外面。对于一个"
"多边形，我们必须找到一个平面，使得另一个多边形上的所有点到它的距离为正。这种"
"可以用A平面对B点进行检查，然后用B平面对A点进行检查:"

#: ../../docs/tutorials/math/vectors_advanced.rst:370
msgid ""
"As you can see, planes are quite useful, and this is the tip of the iceberg. "
"You might be wondering what happens with non convex polygons. This is "
"usually just handled by splitting the concave polygon into smaller convex "
"polygons, or using a technique such as BSP (which is not used much nowadays)."
msgstr ""
"正如您所看到的，平面是非常有用的，然而这只是冰山一角。您可能想知道非凸多边形"
"会发生什么。这通常只是通过将凹多边形分割成较小的凸多边形来处理，或者使用诸如"
"BSP(现在使用得不多)之类的技术。"

#: ../../docs/tutorials/math/vectors_advanced.rst:377
msgid "Collision detection in 3D"
msgstr "三维碰撞检测"

#: ../../docs/tutorials/math/vectors_advanced.rst:379
msgid ""
"This is another bonus bit, a reward for being patient and keeping up with "
"this long tutorial. Here is another piece of wisdom. This might not be "
"something with a direct use case (Godot already does collision detection "
"pretty well) but it's used by almost all physics engines and collision "
"detection libraries :)"
msgstr ""
"这是另一个奖励，是对耐心并跟上这个漫长的教程的奖励。这是另一条锦囊妙计。这可"
"能不能直接拿来使用(Godot已经可以进行了相当棒的碰撞检测了)，但是几乎所有的物理"
"引擎和碰撞检测库都使用它的原理:)"

#: ../../docs/tutorials/math/vectors_advanced.rst:385
msgid ""
"Remember that converting a convex shape in 2D to an array of 2D planes was "
"useful for collision detection? You could detect if a point was inside any "
"convex shape, or if two 2D convex shapes were overlapping."
msgstr ""
"还记得把2D中的凸形转换成2D平面阵列对碰撞检测有用吗？您可以检测一个点是否在任"
"何凸形状内，或者两个2D凸形状是否重叠。"

#: ../../docs/tutorials/math/vectors_advanced.rst:389
msgid ""
"Well, this works in 3D too, if two 3D polyhedral shapes are colliding, you "
"won't be able to find a separating plane. If a separating plane is found, "
"then the shapes are definitely not colliding."
msgstr ""
"嗯，这在3D中也适用，如果两个3D多面体形状碰撞，您将无法找到分离平面。如果发现"
"一个分离平面，那么形状肯定不会发生碰撞。"

#: ../../docs/tutorials/math/vectors_advanced.rst:393
msgid ""
"To refresh a bit a separating plane means that all vertices of polygon A are "
"in one side of the plane, and all vertices of polygon B are in the other "
"side. This plane is always one of the face-planes of either polygon A or "
"polygon B."
msgstr ""
"要得到分离平面意味着多边形A的所有顶点都在平面的一侧，而多边形B的所有顶点都在"
"另一侧。该平面始终是多边形A或多边形B的面向平面之一。"

#: ../../docs/tutorials/math/vectors_advanced.rst:398
msgid ""
"In 3D though, there is a problem to this approach, because it is possible "
"that, in some cases a separating plane can't be found. This is an example of "
"such situation:"
msgstr ""
"然而在3D中，这种方法存在一个问题，因为在某些情况下可能找不到分离平面。下面就"
"是这种情况的一个示例:"

#: ../../docs/tutorials/math/vectors_advanced.rst:404
msgid ""
"To avoid it, some extra planes need to be tested as separators, these planes "
"are the cross product between the edges of polygon A and the edges of "
"polygon B"
msgstr ""
"为了避免这种情况，一些额外的平面需要作为分隔器被测试，这些平面是多边形A的边和"
"多边形B的边的叉乘"

#: ../../docs/tutorials/math/vectors_advanced.rst:410
msgid "So the final algorithm is something like:"
msgstr "所以最后的算法是这样的:"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:4
msgid "Matrices and transforms"
msgstr "矩阵与变换"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:9
msgid ""
"Before reading this tutorial, it is advised to read the previous one about :"
"ref:`doc_vector_math` as this one is a direct continuation."
msgstr ""
"在阅读本教程之前，建议阅读关于 :ref:`doc_vector_math` 的前一篇教程，因为这是"
"一个直接的续作。"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:12
msgid ""
"This tutorial will be about *transformations* and will cover a little about "
"matrices (but not in-depth)."
msgstr "本教程将介绍 *转换* 并将介绍一些关于矩阵的内容(但不深入)。"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:15
msgid ""
"Transformations are most of the time applied as translation, rotation and "
"scale so they will be considered as priority here."
msgstr "转换大部分时间用于平移、旋转和缩放，因此这里将优先考虑它们。"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:19
msgid "Oriented coordinate system (OCS)"
msgstr "定向坐标系(OCS)"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:21
msgid ""
"Imagine we have a spaceship somewhere in space. In Godot this is easy, just "
"move the ship somewhere and rotate it:"
msgstr ""
"想象我们有一艘宇宙飞船在太空的某个地方。在Godot中，这很简单，只要把船移动到某"
"个地方，然后旋转它:"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:26
msgid ""
"Ok, so in 2D this looks simple, a position and an angle for a rotation. But "
"remember, we are grown ups here and don't use angles (plus, angles are not "
"even that useful when working in 3D)."
msgstr ""
"在2D中，这个看起来很简单，旋转的位置和角度。但请记住，我们在这里成长，不使用"
"角度(另外，在3D中，角度甚至没有那么有用)。"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:30
msgid ""
"We should realize that at some point, someone *designed* this spaceship. Be "
"it for 2D in a drawing such as Paint.net, Gimp, Photoshop, etc. or in 3D "
"through a 3D DCC tool such as Blender, Max, Maya, etc."
msgstr ""
"我们应该意识到，在某个时刻，有人设计了这个宇宙飞船。无论是用于绘图中的2D，如"
"Paint.net、Gimp、Photoshop等，还是通过3DDCC工具(如Blender、Max、Maya等)进行3D"
"处理。"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:35
msgid ""
"When it was designed, it was not rotated. It was designed in its own "
"*coordinate system*."
msgstr "在设计时，它没有旋转。它是在它自己的坐标系中设计的。"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:40
msgid ""
"This means that the tip of the ship has a coordinate, the fin has another, "
"etc. Be it in pixels (2D) or vertices (3D)."
msgstr ""
"这意味着船的顶端有一个坐标，鳍有另一个坐标，等等，可以是像素(2D)或顶点(3D)。"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:43
msgid "So, let's recall again that the ship was somewhere in space:"
msgstr "那么，让我们再次回忆一下这艘船在太空的某个地方:"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:47
msgid ""
"How did it get there? What moved it and rotated it from the place it was "
"designed to its current position? The answer is... a **transform**, the ship "
"was *transformed* from their original position to the new one. This allows "
"the ship to be displayed where it is."
msgstr ""
"它是如何到达那里的?是什么把它从设计的位置移动和旋转到现在的位置?答案是…一个 "
"**变换**，船从原来的位置 **变换** 到新的位置。这才使得船显示在那里。"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:52
msgid ""
"But transform is too generic of a term to describe this process. To solve "
"this puzzle, we will superimpose the ship's original design position at "
"their current position:"
msgstr ""
"但是变换是描述这个过程的术语过于泛化。为了解决这个难题，我们将将船只的原始设"
"计位置叠加在当前位置:"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:58
msgid ""
"So, we can see that the \"design space\" has been transformed too. How can "
"we best represent this transformation? Let's use 3 vectors for this (in 2D), "
"a unit vector pointing towards X positive, a unit vector pointing towards Y "
"positive and a translation."
msgstr ""
"所以，我们可以看到 \"设计空间\" 也被改造了。我们怎样才能最好地表示这个变换?我"
"们用3个向量(在2D中)一个指向X正的单位向量，一个指向Y正的单位向量和一个平移。"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:65
msgid ""
"Let's call the 3 vectors \"X\", \"Y\" and \"Origin\", and let's also "
"superimpose them over the ship so it makes more sense:"
msgstr ""
"我们称这三个向量为“X”“Y”和“原点”，我们也把它们叠加在飞船上，这样更有意义:"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:70
msgid ""
"Ok, this is nicer, but it still does not make sense. What do X,Y and Origin "
"have to do with how the ship got there?"
msgstr "这个更好，但是仍然没有意义。X,Y和原点和飞船如何到达那里有什么关系?"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:73
msgid "Well, let's take the point from top tip of the ship as reference:"
msgstr "好吧，让我们以船顶端的点作为参考:"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:77
msgid ""
"And let's apply the following operation to it (and to all the points in the "
"ship too, but we'll track the top tip as our reference point):"
msgstr ""
"让我们对它应用下面的操作(对飞船上的所有点也是如此，但我们将跟踪顶端作为参考"
"点):"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:89
msgid "Doing this to the selected point will move it back to the center:"
msgstr "对选定点执行此操作将将其移回中心:"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:93
msgid ""
"This was expected, but then let's do something more interesting. Use the dot "
"product of X and the point, and add it to the dot product of Y and the point:"
msgstr ""
"这是意料之中的，但接下来让我们做一些更有趣的事情。用X和这个点的点积，再加上Y"
"和这个点的点积:"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:106
msgid ""
"Then what we have is.. wait a minute, it's the ship in its design position!"
msgstr "那么我们所拥有的是…等一下，这是船的设计位置!"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:111
msgid ""
"How did this black magic happen? The ship was lost in space, and now it's "
"back home!"
msgstr "这个黑魔法是怎么发生的？船在太空中迷失了方向，现在它又回到了家里！"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:114
msgid ""
"It might seem strange, but it does have plenty of logic. Remember, as we "
"have seen in the :ref:`doc_vector_math`, what happened is that the distance "
"to X axis, and the distance to Y axis were computed. Calculating distance in "
"a direction or plane was one of the uses for the dot product. This was "
"enough to obtain back the design coordinates for every point in the ship."
msgstr ""
"这可能看起来很奇怪，但它确实有很多逻辑。记住，正如我们在 :ref:"
"`doc_vector_math` 中看到的，到X轴的距离和到Y轴的距离是计算出来的。计算方向或"
"平面上的距离是点积的用途之一。这足以获得船上每个点的设计坐标。"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:121
msgid ""
"So, what we have been working with so far (with X, Y and Origin) is an "
"*Oriented Coordinate System*. X an Y are the **Basis**, and *Origin* is the "
"offset."
msgstr ""
"到目前为止，我们一直在研究的(X, Y和原点)是一个 *面向坐标系* 。X和Y是 **基"
"**， *原点* 是偏移量。"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:128
msgid ""
"We know what the Origin is. It's where the 0,0 (origin) of the design "
"coordinate system ended up after being transformed to a new position. This "
"is why it's called *Origin*, But in practice, it's just an offset to the new "
"position."
msgstr ""
"我们知道原点是什么。它是设计坐标系原点(0,0)在变换到一个新位置后的最终位置。这"
"就是为什么它叫做原点，但是在实践中，它只是对新位置的偏移。"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:133
msgid ""
"The Basis is more interesting. The basis is the direction of X and Y in the "
"OCS from the new, transformed location. It tells what has changed, in either "
"2D or 3D. The Origin (offset) and Basis (direction) communicate \"Hey, the "
"original X and Y axes of your design are *right here*, pointing towards "
"*these directions*.\""
msgstr ""
"基础更有趣。 基础是来自新的转换位置的OCS中的X和Y的方向。 它以二维或三维方式告"
"知已发生的变化。 原点(偏移)和基础(方向)通信“嘿，您的设计的原始X轴和Y轴正好 *"
"在这里* ，指向 *这些方向* 。”"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:139
msgid ""
"So, let's change the representation of the basis. Instead of 2 vectors, "
"let's use a *matrix*."
msgstr "所以，让我们改变基础的表示。 我们使用 *矩阵* 而不是2个向量。"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:144
msgid ""
"The vectors are up there in the matrix, horizontally. The next problem now "
"is that.. what is this matrix thing? Well, we'll assume you've never heard "
"of a matrix."
msgstr ""
"向量在矩阵中水平地向上。 现在的下一个问题是......这个矩阵是什么东西？ 好吧，"
"我们假设您从来没有听说过矩阵。"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:149
msgid "Transforms in Godot"
msgstr "Godot中的变换"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:151
msgid ""
"This tutorial will not explain matrix math (and their operations) in depth, "
"only its practical use. There is plenty of material for that, which should "
"be a lot simpler to understand after completing this tutorial. We'll just "
"explain how to use transforms."
msgstr ""
"本教程不会深入解释矩阵数学(及其操作)，只是实际应用。 网上有很多关于矩阵的资"
"料，但是完成本教程后应该会加深对矩阵理解。 我们将解释如何使用变换。"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:159
msgid ""
":ref:`class_Transform2D` is a 3x2 matrix. It has 3 Vector2 elements and it's "
"used for 2D. The \"X\" axis is the element 0, \"Y\" axis is the element 1 "
"and \"Origin\" is element 2. It's not divided in basis/origin for "
"convenience, due to its simplicity."
msgstr ""
":ref:`class_Transform2D` 是一个3x2矩阵。 它有3个Vector2元素，用于2D。 “X”轴是"
"第0个元素，“Y”轴是第1个元素，“Origin”是第2个元素.它不是为了方便而在基础/原点"
"上划分，是因为这样简单。"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:179
msgid ""
"Most operations will be explained with this datatype (Transform2D), but the "
"same logic applies to 3D."
msgstr ""
"大多数操作将使用此数据类型(Transform2D)进行说明，但相同的逻辑适用于3D。"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:183
msgid "Identity"
msgstr "单位矩阵"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:185
msgid "An important transform is the \"identity\" matrix. This means:"
msgstr "一个重要的变换是“单位”矩阵。 这意味着:"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:187
msgid "'X' Points right: Vector2(1,0)"
msgstr "X' 指向右侧:Vector2(1,0)"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:188
msgid "'Y' Points up (or down in pixels): Vector2(0,1)"
msgstr "Y'指向上方(或以像素为单位时，表示指向下方):Vector2(0,1)"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:189
msgid "'Origin' is the origin Vector2(0,0)"
msgstr "'Origin'是原点 Vector2(0,0)"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:193
msgid ""
"It's easy to guess that an *identity* matrix is just a matrix that aligns "
"the transform to its parent coordinate system. It's an *OCS* that hasn't "
"been translated, rotated or scaled."
msgstr ""
"很容易猜到 *单位* 矩阵只是一个将变换对齐其父坐标系的矩阵。 它是尚未平移，旋转"
"或缩放的 *OCS* 。"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:220
msgid "Operations"
msgstr "操作"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:223
#: ../../docs/tutorials/animation/cutout_animation.rst:320
msgid "Rotation"
msgstr "旋转"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:225
msgid "Rotating Transform2D is done by using the \"rotated\" function:"
msgstr "通过使用 \"rotated\" 函数完成旋转Transform2D:"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:241
msgid "Translation"
msgstr "平移"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:243
msgid ""
"There are two ways to translate a Transform2D, the first one is moving the "
"origin:"
msgstr "有两种方法可以平移Transform2D，第一种方法是移动原点:"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:263
msgid "This will always work in global coordinates."
msgstr "这将始终在全局坐标系中工作。"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:265
#, fuzzy
msgid ""
"If instead, translation is desired in *local* coordinates of the matrix "
"(towards where the *basis* is oriented), there is the :ref:`Transform2D."
"translated() <class_Transform2D_method_translated>` method:"
msgstr ""
"相反，如果需要在矩阵的 *局部* 坐标系中进行平移(朝向 *基* 的方向)，则可以使"
"用 :ref:`Transform2D.translated() <class_Transform2D_method_translated>` 方"
"法:"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:287
msgid ""
"You could also transform the global coordinates to local coordinates "
"manually:"
msgstr "您也可以手动将全局坐标系转换为局部坐标系:"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:298
msgid ""
"But even better, there are helper functions for this as you can read in the "
"next sections."
msgstr "但更好的是用辅助函数，您可以在下一节中阅读。"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:301
msgid "Local to global coordinates and vice versa"
msgstr "从本地到全局坐标，反之亦然"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:303
msgid ""
"There are helper methods for converting between local and global coordinates."
msgstr "有用于在局部坐标和全局坐标之间进行转换的辅助方法。"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:305
#, fuzzy
msgid ""
"There are :ref:`Node2D.to_local() <class_Node2D_method_to_local>` and :ref:"
"`Node2D.to_global() <class_Node2D_method_to_global>` for 2D as well as :ref:"
"`Spatial.to_local() <class_Spatial_method_to_local>` and :ref:`Spatial."
"to_global() <class_Spatial_method_to_global>` for 3D."
msgstr ""
"有用于2D的 :ref:`Node2D.to_local() <class_Node2D_to_local>` 和 :ref:`Node2D."
"to_global() <class_Node2D_method_to_global>` 以及用于3D的 :ref:`Spatial."
"to_local() <class_Spatial_to_local>` 和 :ref:`Spatial.to_global() "
"<class_Spatial_method_to_global>` 。"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:311
msgid ""
"A matrix can be scaled too. Scaling will multiply the basis vectors by a "
"vector (X vector by x component of the scale, Y vector by y component of the "
"scale). It will leave the origin alone:"
msgstr ""
"矩阵也可以缩放。 缩放将基向量乘以向量(X向量乘标量的x分量，Y向量乘标量的y分"
"量)。 它让原点不变:"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:330
msgid ""
"These kind of operations in matrices are accumulative. It means every one "
"starts relative to the previous one. For those who have been living on this "
"planet long enough, a good reference of how transform works is this:"
msgstr ""
"矩阵中的这些操作是累积的。 这意味着每个操作都相对于前一个开始的。 对于那些一"
"直生活在这个星球上足够长的人来说，变换如何工作的一个很好的参考是:"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:337
msgid ""
"A matrix is used similarly to a turtle. The turtle most likely had a matrix "
"inside (and you are likely learning this many years *after* discovering "
"Santa is not real)."
msgstr ""
"矩阵与乌龟类似。 乌龟可能内部有一个矩阵(您可能需要在发现圣诞老人是假的后，再"
"过许多年才理解到这句话)。"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:344
msgid ""
"Transform is the act of switching between coordinate systems. To convert a "
"position (either 2D or 3D) from \"designer\" coordinate system to the OCS, "
"the \"xform\" method is used."
msgstr ""
"变换是在坐标系之间切换的行为。 要将位置(2D或3D)从“设计者”坐标系转换为OCS，请"
"使用“xform”方法。"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:357
msgid "And only for basis (no translation):"
msgstr "仅限基(无平移):"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:369
msgid "Inverse transform"
msgstr "逆变换"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:371
msgid ""
"To do the opposite operation (what we did up there with the rocket), the "
"\"xform_inv\" method is used:"
msgstr "为了进行相反的操作(我们用火箭做了什么)，使用了“xform_inv”方法:"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:383
msgid "Only for Basis:"
msgstr "仅适用于基:"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:395
msgid "Orthonormal matrices"
msgstr "正交矩阵"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:397
msgid ""
"However, if the matrix has been scaled (vectors are not unit length), or the "
"basis vectors are not orthogonal (90°), the inverse transform will not work."
msgstr ""
"但是，如果矩阵已被缩放(向量不是单位长度)，或者基向量不是正交的(90°)，则逆变换"
"将不起作用。"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:401
msgid ""
"In other words, inverse transform is only valid in *orthonormal* matrices. "
"For this, these cases an affine inverse must be computed."
msgstr ""
"换句话说，逆变换仅在 *正交* 矩阵中有效。 为此，必须计算仿射逆的这些情况。"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:404
msgid ""
"The transform, or inverse transform of an identity matrix will return the "
"position unchanged:"
msgstr "单位矩阵的变换或逆变换将返回未改变的位置:"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:419
msgid "Affine inverse"
msgstr "仿射逆"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:421
msgid ""
"The affine inverse is a matrix that does the inverse operation of another "
"matrix, no matter if the matrix has scale or the axis vectors are not "
"orthogonal. The affine inverse is calculated with the affine_inverse() "
"method:"
msgstr ""
"仿射逆是一个矩阵，它执行另一个矩阵的逆运算，无论矩阵是否具有比例或者轴向量不"
"是正交的。 使用affine_inverse()方法计算仿射逆:"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:441
msgid "If the matrix is orthonormal, then:"
msgstr "如果矩阵是正交的，那么:"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:459
msgid "Matrix multiplication"
msgstr "矩阵乘法"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:461
msgid ""
"Matrices can be multiplied. Multiplication of two matrices \"chains"
"\" (concatenates) their transforms."
msgstr "矩阵可以做乘法。 两个矩阵的乘法 “链”(连接)它们的变换。"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:464
msgid ""
"However, as per convention, multiplication takes place in reverse order."
msgstr "但是，按照惯例，乘法可以交换顺序。"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:478
msgid "To make it a little clearer, this:"
msgstr "为了更清楚一点，这个:"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:491
msgid "Is the same as:"
msgstr "与下面这个是相同的:"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:504
msgid "However, this is not the same:"
msgstr "实际上，这是不一样的:"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:517
msgid "Because in matrix math, A * B is not the same as B * A."
msgstr "因为在矩阵数学中，A * B与B * A不同。"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:520
msgid "Multiplication by inverse"
msgstr "乘以逆矩阵"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:522
msgid "Multiplying a matrix by its inverse, results in identity:"
msgstr "矩阵乘以逆，将得到单位矩阵:"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:536
msgid "Multiplication by identity"
msgstr "乘以单位矩阵"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:538
msgid "Multiplying a matrix by identity, will result in the unchanged matrix:"
msgstr "矩阵乘以单位矩阵将得到矩阵本身:"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:552
msgid "Matrix tips"
msgstr "矩阵提示"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:554
msgid ""
"When using a transform hierarchy, remember that matrix multiplication is "
"reversed! To obtain the global transform for a hierarchy, do:"
msgstr ""
"使用变换层次结构时，请记住矩阵乘法是相反的！ 要获取层次结构的全局变换，请执行"
"以下操作:"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:566
msgid "For 3 levels:"
msgstr "对3个级别的情况:"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:577
msgid ""
"To make a matrix relative to the parent, use the affine inverse (or regular "
"inverse for orthonormal matrices)."
msgstr "要制作相对于父级的矩阵，请使用仿射逆(或正交矩阵的常规逆)。"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:591
msgid "Revert it just like the example above:"
msgstr "恢复它就像上面的示例:"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:604
msgid ""
"OK, hopefully this should be enough! Let's complete the tutorial by moving "
"to 3D matrices."
msgstr "好的，希望这应该足够了！ 让我们转移到3D矩阵来完成本教程。"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:608
msgid "Matrices & transforms in 3D"
msgstr "3D中的矩阵&变换"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:610
msgid ""
"As mentioned before, for 3D, we deal with 3 :ref:`Vector3 <class_Vector3>` "
"vectors for the rotation matrix, and an extra one for the origin."
msgstr ""
"如前所述，对于3D，我们处理3个用于旋转矩阵的 :ref:`Vector3 <class_Vector3>` 向"
"量，以及用于原点的额外向量。"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:616
#, fuzzy
msgid ""
"Godot has a special type for a 3x3 matrix, named :ref:`Basis <class_Basis>`. "
"It can be used to represent a 3D rotation and scale. Sub vectors can be "
"accessed as:"
msgstr ""
"Godot有一个特殊类型的3x3矩阵，命名为 :ref:`Basis <class_Basis>` 。 它可用于表"
"示3D旋转和缩放。 子向量可以像这样被访问:"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:635
msgid "Or, alternatively as:"
msgstr "或者，像这样:"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:652
msgid "The Identity Basis has the following values:"
msgstr "单位基具有以下值:"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:656
msgid "And can be accessed like this:"
msgstr "并且可以像这样访问:"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:680
msgid "Rotation in 3D"
msgstr "3D中的旋转"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:682
msgid ""
"Rotation in 3D is more complex than in 2D (translation and scale are the "
"same), because rotation is an implicit 2D operation. To rotate in 3D, an "
"*axis*, must be picked. Rotation, then, happens around this axis."
msgstr ""
"3D中的旋转比2D中的旋转更复杂(平移和缩放是相同复杂度)，因为旋转是个隐式2D操"
"作。 要在3D中旋转，必须选取 *轴* 。 然后，围绕该轴旋转。"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:686
msgid ""
"The axis for the rotation must be a *normal vector*. As in, a vector that "
"can point to any direction, but length must be one (1.0)."
msgstr ""
"旋转轴必须是 *法线向量* 。 就像可以指向任何方向的向量，但长度必须为1(1.0)。"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:705
msgid ""
"To add the final component to the mix, Godot provides the :ref:`Transform "
"<class_Transform>` type. Transform has two members:"
msgstr ""
"为了将最终组件添加到混合中，Godot提供了 :ref:`Transform <class_Transform>` 类"
"型。 变换有两个成员:"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:708
msgid "*basis* (of type :ref:`Basis <class_Basis>`)"
msgstr "*basis* (类型是 :ref:`Basis <class_Basis>`)"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:709
msgid "*origin* (of type :ref:`Vector3 <class_Vector3>`)"
msgstr "*origin* (类型是 :ref:`Vector3 <class_Vector3>`)"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:711
msgid ""
"Any 3D transform can be represented with Transform, and the separation of "
"basis and origin makes it easier to work translation and rotation separately."
msgstr ""
"任何3D变换都可以用Transform表示，基础和原点的分离使得分别进行平移和旋转变得更"
"容易。"

#: ../../docs/tutorials/math/matrices_and_transforms.rst:715
msgid "An example:"
msgstr "一个示例:"

#: ../../docs/tutorials/animation/introduction_2d.rst:4
msgid "Introduction to the 2D animation features"
msgstr "2D动画特征介绍"

#: ../../docs/tutorials/animation/introduction_2d.rst:9
msgid ""
"The :ref:`class_AnimationPlayer` node allows you to create anything from "
"simple to complex animations."
msgstr ":ref:`class_AnimationPlayer` 节点允许您创建从简单到复杂的任何动画。"

#: ../../docs/tutorials/animation/introduction_2d.rst:12
msgid "In this guide you learn to:"
msgstr "在本指南中，您将学会:"

#: ../../docs/tutorials/animation/introduction_2d.rst:14
msgid "Work with the Animation Panel"
msgstr "使用动画面板"

#: ../../docs/tutorials/animation/introduction_2d.rst:15
msgid "Animate any property of any node"
msgstr "使任何节点的任何属性变成动画"

#: ../../docs/tutorials/animation/introduction_2d.rst:16
msgid "Create a simple animation"
msgstr "创建一个简单的动画"

#: ../../docs/tutorials/animation/introduction_2d.rst:17
msgid "Call functions with the powerful Call Function Tracks"
msgstr "使用功能强大的Call Function Tracks调用函数"

#: ../../docs/tutorials/animation/introduction_2d.rst:19
#, fuzzy
msgid ""
"In Godot, you can animate anything available in the Inspector, such as Node "
"transforms, sprites, UI elements, particles, visibility and color of "
"materials, and so on. You can also modify values of script variables and "
"call any function."
msgstr ""
"在Godot中，您可以为Inspector中找到的任何内容制作动画。 动画是属性随时间的变"
"化。 这意味着您可以为自然界中的任何视觉效果设置动画:精灵，UI元素，粒子，可见"
"性和纹理颜色。 但不仅如此。 您还可以控制与游戏相关的值并调用任何函数。"

#: ../../docs/tutorials/animation/introduction_2d.rst:25
msgid "Create an AnimationPlayer node"
msgstr "创建一个AnimationPlayer节点"

#: ../../docs/tutorials/animation/introduction_2d.rst:27
msgid ""
"To use the animation tools we first have to create an :ref:"
"`class_AnimationPlayer` node."
msgstr ""
"要使用动画工具，我们首先必须创建一个 :ref:`class_AnimationPlayer` 节点。"

#: ../../docs/tutorials/animation/introduction_2d.rst:30
msgid ""
"The AnimationPlayer node type is the data container for your animations. One "
"AnimationPlayer node can hold multiple animations, that can automatically "
"transition to one another."
msgstr ""
"AnimationPlayer节点类型是动画的数据容器。一个AnimationPlayer节点可以保存多个"
"动画，这些动画可以自动相互转换。"

#: ../../docs/tutorials/animation/introduction_2d.rst:37
msgid "The AnimationPlayer node"
msgstr "AnimationPlayer节点"

#: ../../docs/tutorials/animation/introduction_2d.rst:39
msgid ""
"Click on the AnimationPlayer node in the Node tab to open the Animation "
"Panel at the bottom of the viewport."
msgstr "单击Node选项卡中的AnimationPlayer节点，打开视图底部的动画面板。"

#: ../../docs/tutorials/animation/introduction_2d.rst:45
msgid "The animation panel position"
msgstr "动画面板位置"

#: ../../docs/tutorials/animation/introduction_2d.rst:47
msgid "It consists of five parts:"
msgstr "它由五部分组成:"

#: ../../docs/tutorials/animation/introduction_2d.rst:52
msgid "The animation panel"
msgstr "动画面板"

#: ../../docs/tutorials/animation/introduction_2d.rst:54
msgid "Animation controls (i.e. add, load, save, and delete animations)"
msgstr "动画控件(即添加、加载、保存和删除动画)"

#: ../../docs/tutorials/animation/introduction_2d.rst:55
msgid "The tracks listing"
msgstr "轨道列表"

#: ../../docs/tutorials/animation/introduction_2d.rst:56
msgid "The timeline with keyframes"
msgstr "带有关键帧的时间轴"

#: ../../docs/tutorials/animation/introduction_2d.rst:57
msgid "The keyframe editor (when enabled)"
msgstr "关键帧编辑器(启用时)"

#: ../../docs/tutorials/animation/introduction_2d.rst:58
msgid ""
"The timeline and track controls, where you can zoom the timeline and edit "
"tracks for example."
msgstr "时间轴和轨道控件，例如，您可以在其中缩放时间轴和编辑轨道。"

#: ../../docs/tutorials/animation/introduction_2d.rst:61
msgid ""
"See the `animation panel reference <#animation-panel-reference>`__ below for "
"details."
msgstr ""
"有关详细信息，请参阅下面的 `animation panel reference <#animation-panel-"
"reference>`__ 。"

#: ../../docs/tutorials/animation/introduction_2d.rst:65
msgid "Computer animation relies on keyframes"
msgstr "计算机动画依赖于关键帧"

#: ../../docs/tutorials/animation/introduction_2d.rst:67
msgid "A keyframe defines the value of a property at a certain point in time."
msgstr "关键帧定义属性在某一时间点的值。"

#: ../../docs/tutorials/animation/introduction_2d.rst:69
msgid "White and blue diamond shapes represent keyframes in the timeline."
msgstr "白色和蓝色菱形表示时间轴中的关键帧。"

#: ../../docs/tutorials/animation/introduction_2d.rst:74
msgid "Keyframes in Godot"
msgstr "Godot中的关键帧"

#: ../../docs/tutorials/animation/introduction_2d.rst:76
msgid ""
"The engine interpolates values between keyframes, resulting in a gradual "
"change in values over time."
msgstr "引擎在关键帧之间插入值，导致值随时间逐渐变化。"

#: ../../docs/tutorials/animation/introduction_2d.rst:82
msgid "Two keyframes are all it takes to obtain a smooth motion"
msgstr "只需两个关键帧就可以获得一个平滑运动"

#: ../../docs/tutorials/animation/introduction_2d.rst:84
msgid ""
"The timeline lets you insert keyframes and change their timing. It also "
"defines how long the animation is."
msgstr "时间轴可以插入关键帧并更改它们的时序。它还定义动画的时间。"

#: ../../docs/tutorials/animation/introduction_2d.rst:90
msgid "The timeline in the animation panel"
msgstr "动画面板中的时间轴"

#: ../../docs/tutorials/animation/introduction_2d.rst:92
msgid ""
"Each line of the Animation Panel is an animation track. Normal and Transform "
"tracks reference node properties. Their name or id is a path to the node and "
"the affected property."
msgstr ""
"动画面板的每一行都是一个动画轨道。普通和转换轨道参考节点属性。它们的名称或id"
"是到节点和受影响属性的路径。"

#: ../../docs/tutorials/animation/introduction_2d.rst:99
msgid "Example of Normal animation tracks"
msgstr "普通动画轨道的示例"

#: ../../docs/tutorials/animation/introduction_2d.rst:103
msgid ""
"If you animate the wrong property, you can edit a track's path anytime. "
"Double click on it and type the new path. Play the animation using the "
"\"Play from beginning\" button |Play from beginning| (Default shortcut: Shift"
"+D) to see the changes instantly."
msgstr ""
"如果您让错误的属性变成了动画，您可以随时编辑轨道的路径。双击它并输入新的路"
"径。使用“从开始播放”按钮|从开始播放|(默认快捷方式:Shift+D) 播放动画，可以立即"
"看到变化。"

#: ../../docs/tutorials/animation/introduction_2d.rst:109
msgid "Tutorial: Creating a simple animation"
msgstr "教程:创建一个简单的动画"

#: ../../docs/tutorials/animation/introduction_2d.rst:114
msgid ""
"For this tutorial, we'll going to create an AnimationPlayer node and a "
"sprite node as an AnimationPlayer node child."
msgstr ""
"在本教程中，我们将创建一个AnimationPlayer节点和一个精灵节点作为"
"AnimationPlayer节点的子节点。"

#: ../../docs/tutorials/animation/introduction_2d.rst:120
msgid "Our scene setup"
msgstr "我们的场景设置"

#: ../../docs/tutorials/animation/introduction_2d.rst:122
msgid ""
"The sprite holds an image texture and we animate that sprite to move between "
"two points on the screen. As a starting point, move the sprite to a left "
"position on the screen."
msgstr ""
"精灵拥有一个图像纹理，我们让它在屏幕上的两点之间移动。首先，将精灵移动到屏幕"
"上的左边。"

#: ../../docs/tutorials/animation/introduction_2d.rst:128
msgid ""
"Adding animated nodes as children to the AnimationPlayer node is not "
"required, but it is a nice way of distinguishing animated nodes from non-"
"animated nodes in the Scene Tree."
msgstr ""
"将动画节点作为子节点添加到AnimationPlayer节点不是强制要求的，但是这是一种很好"
"的方法来区分动画节点和场景树中的非动画节点。"

#: ../../docs/tutorials/animation/introduction_2d.rst:132
msgid ""
"Select the AnimationPlayer node and click on \"Add animation\" (|Add "
"Animation|) in the animation tab to add a new animation."
msgstr ""
"选择AnimationPlayer节点，在animation选项卡中点击“Add animation”(|Add "
"animation |)添加一个新的动画。"

#: ../../docs/tutorials/animation/introduction_2d.rst:135
msgid "Enter a name for the animation in the dialog box."
msgstr "在对话框中输入动画名称。"

#: ../../docs/tutorials/animation/introduction_2d.rst:140
msgid "Add a new animation"
msgstr "添加一个新的动画"

#: ../../docs/tutorials/animation/introduction_2d.rst:143
msgid "Adding a track"
msgstr "添加轨道"

#: ../../docs/tutorials/animation/introduction_2d.rst:145
msgid ""
"To add a new track for our sprite, select it and take a look in the toolbar:"
msgstr "要为我们的精灵添加一个新的轨道，选择它并在工具栏中查看:"

#: ../../docs/tutorials/animation/introduction_2d.rst:151
msgid "Convenience buttons"
msgstr "方便按钮"

#: ../../docs/tutorials/animation/introduction_2d.rst:153
msgid ""
"These switches and buttons allow you to add keyframes for the selected "
"node's location, rotation, and scale respectively."
msgstr "这些开关和按钮允许您为选择的节点的位置、旋转和比例分别添加关键帧。"

#: ../../docs/tutorials/animation/introduction_2d.rst:156
msgid ""
"Deselect rotation, because we are only interested in the location of our "
"sprite for this tutorial and click on the key button."
msgstr "取消选择旋转，因为我们只对本教程的精灵位置感兴趣，并单击键按钮。"

#: ../../docs/tutorials/animation/introduction_2d.rst:159
msgid ""
"As we don't have a track already set up for the transform/location property, "
"Godot asks, whether it should set it up for us. Click on \"Create\"."
msgstr ""
"由于我们还没有为转换/位置属性设置轨道，Godot询问是否应该为我们设置它。点击“创"
"建”。"

#: ../../docs/tutorials/animation/introduction_2d.rst:163
msgid ""
"This creates a new track and our first keyframe at the beginning of the "
"timeline:"
msgstr "这会在时间轴的开头创建一个新轨道和第一个关键帧:"

#: ../../docs/tutorials/animation/introduction_2d.rst:169
msgid "The sprite track"
msgstr "精灵跟踪"

#: ../../docs/tutorials/animation/introduction_2d.rst:171
msgid ""
"The track name consists of a Node Path, followed by a colon, followed by a "
"reference to its property, that we would like to modify."
msgstr "轨道名称由节点路径，后跟冒号，后跟对其属性的引用组成，我们要修改它。"

#: ../../docs/tutorials/animation/introduction_2d.rst:174
msgid ""
"In our example, the path is ``AnimationPlayer/Sprite`` and the property is "
"``position``."
msgstr ""
"在我们的示例中，路径是``AnimationPlayer / Sprite``，属性是 ``position`` 。"

#: ../../docs/tutorials/animation/introduction_2d.rst:177
msgid ""
"The path always starts at the AnimationPlayer node's parent (so paths always "
"have to include the AnimationPlayer node itself)."
msgstr ""
"路径始终从AnimationPlayer节点的父节点开始(因此路径始终必须包含AnimationPlayer"
"节点本身)。"

#: ../../docs/tutorials/animation/introduction_2d.rst:182
msgid ""
"Don't worry if you change the names of nodes in the Scene Tree, that you "
"already have tracks for. Godot automatically updates the paths in the tracks."
msgstr ""
"如果更改“场景树”中已有轨道的节点名称，请不要担心。 Godot自动更新轨道中的路"
"径。"

#: ../../docs/tutorials/animation/introduction_2d.rst:187
msgid "The second keyframe"
msgstr "第二个关键帧"

#: ../../docs/tutorials/animation/introduction_2d.rst:189
msgid ""
"Now we need to set the destination where our sprite should be headed and how "
"much time it takes to get there."
msgstr "现在我们需要设置我们的精灵应该到达的目的地以及到达那里需要多长时间。"

#: ../../docs/tutorials/animation/introduction_2d.rst:192
msgid ""
"Let's say, we want it to take 2 seconds to go to the other point. By default "
"the animation is set to last only 1 second, so change this in the timeline "
"controls in animation panel's lower panel to 2."
msgstr ""
"让我们说，我们希望它需要2秒才能到达另一个点。 默认情况下，动画设置为仅持续1"
"秒，因此在动画面板下方面板的时间轴控件中将其更改为2。"

#: ../../docs/tutorials/animation/introduction_2d.rst:199
msgid "Animation length"
msgstr "动画长度"

#: ../../docs/tutorials/animation/introduction_2d.rst:201
msgid ""
"Click on the timeline header near the 2 second mark and move the sprite to "
"the target destination on the right side."
msgstr "单击2秒标记附近的时间轴标题，并将精灵移动到右侧的目标目标。"

#: ../../docs/tutorials/animation/introduction_2d.rst:204
msgid ""
"Again, click the key button in the toolbar. This creates our second keyframe."
msgstr "再次单击工具栏中的键按钮。 这创建了我们的第二个关键帧。"

#: ../../docs/tutorials/animation/introduction_2d.rst:208
msgid "Run the animation"
msgstr "运行动画"

#: ../../docs/tutorials/animation/introduction_2d.rst:210
msgid "Click on the \"Play from beginning\" (|Play from beginning|) button."
msgstr "单击“从头开始播放”(|从开头播放|)按钮。"

#: ../../docs/tutorials/animation/introduction_2d.rst:212
msgid "Yay! Our animation runs:"
msgstr "好极了！ 我们的动画运行:"

#: ../../docs/tutorials/animation/introduction_2d.rst:217
msgid "The animation"
msgstr "动画"

#: ../../docs/tutorials/animation/introduction_2d.rst:220
msgid "Back and forth"
msgstr "来来回回"

#: ../../docs/tutorials/animation/introduction_2d.rst:222
msgid ""
"As you can see, the \"loop\" button is enabled by default and our animation "
"loops. Godot has an additional feature here. Like said before, Godot always "
"calculates the frames between two keyframes. In a loop, the first keyframe "
"is also the last keyframe, if no keyframe is specified at the end."
msgstr ""
"如您所见，默认情况下启用“循环”按钮，我们的动画循环。 Godot在这里有一个额外的"
"功能。 如前所述，Godot总是计算两个关键帧之间的帧。 在循环中，如果最后没有指定"
"关键帧，则第一个关键帧也是最后一个关键帧。"

#: ../../docs/tutorials/animation/introduction_2d.rst:231
msgid "Animation loop"
msgstr "动画循环"

#: ../../docs/tutorials/animation/introduction_2d.rst:233
msgid ""
"If you set the animation length to 4 seconds now, the animation moves back "
"and forth. You can change this behaviour if you change the track's loop "
"mode. This is covered in the next chapter."
msgstr ""
"如果现在将动画长度设置为4秒，则动画来回移动。 如果更改轨道的循环模式，则可以"
"更改此行为。 这将在下一章中介绍。"

#: ../../docs/tutorials/animation/introduction_2d.rst:238
#: ../../docs/tutorials/animation/introduction_2d.rst:246
msgid "Track settings"
msgstr "跟踪设置"

#: ../../docs/tutorials/animation/introduction_2d.rst:240
msgid ""
"Each track has a settings panel at the end, where you can set the update "
"rate, the track interpolation, and the loop mode."
msgstr ""
"每个轨道末尾都有一个设置面板，您可以在其中设置更新速率，轨道插值和循环模式。"

#: ../../docs/tutorials/animation/introduction_2d.rst:248
msgid ""
"The update rate of a track tells Godot when to update the property values. "
"This can be:"
msgstr "轨道的更新速率告诉Godot何时更新属性值。 这可以是:"

#: ../../docs/tutorials/animation/introduction_2d.rst:251
msgid "Continuous: Update the property on each frame"
msgstr "连续:更新每个帧的属性"

#: ../../docs/tutorials/animation/introduction_2d.rst:252
msgid "Discrete: Only update the property on keyframes"
msgstr "离散:仅更新关键帧上的属性"

#: ../../docs/tutorials/animation/introduction_2d.rst:253
msgid "Trigger: Only update the property on keyframes or triggers"
msgstr "触发器:仅更新关键帧或触发器上的属性"

#: ../../docs/tutorials/animation/introduction_2d.rst:258
msgid "Track rate"
msgstr "跟踪率"

#: ../../docs/tutorials/animation/introduction_2d.rst:260
msgid ""
"In normal animations, you usually use \"Continuous\". The other types are "
"used to script complex animations."
msgstr "在普通动画中，您通常使用“连续”。 其他类型用于编写复杂动画的脚本。"

#: ../../docs/tutorials/animation/introduction_2d.rst:263
msgid ""
"The interpolation tells Godot how to calculate the frame values between the "
"keyframes. These interpolation modes are supported:"
msgstr "插值告诉Godot如何计算关键帧之间的帧值。 支持这些插值模式:"

#: ../../docs/tutorials/animation/introduction_2d.rst:266
msgid "Nearest: Set the nearest keyframe value"
msgstr "最近:设置最近的关键帧值"

#: ../../docs/tutorials/animation/introduction_2d.rst:267
msgid ""
"Linear: Set the value based on a linear function calculation between the two "
"keyframes"
msgstr "线性:根据两个关键帧之间的线性函数计算设置值"

#: ../../docs/tutorials/animation/introduction_2d.rst:269
msgid ""
"Cubic: Set the value based on a cubic function calculation between the two "
"keyframes"
msgstr "Cubic:根据两个关键帧之间的三次函数计算设置值"

#: ../../docs/tutorials/animation/introduction_2d.rst:275
msgid "Track interpolation"
msgstr "轨道插补"

#: ../../docs/tutorials/animation/introduction_2d.rst:277
msgid ""
"Cubic interpolation leads to a more natural movement, where the animation is "
"slower at a keyframe and faster between keyframes. This is usually used for "
"character animation. Linear interpolation creates more of a robotic movement."
msgstr ""
"立方插值导致更自然的运动，其中动画在关键帧处较慢而在关键帧之间更快。 这通常用"
"于角色动画。 线性插值创造了更多的机器人运动。"

#: ../../docs/tutorials/animation/introduction_2d.rst:282
msgid ""
"Godot supports two loop modes, which affect the animation if it's set to "
"loop:"
msgstr "Godot支持两种循环模式，如果将其设置为循环，则会影响动画:"

#: ../../docs/tutorials/animation/introduction_2d.rst:288
msgid "Loop modes"
msgstr "循环模式"

#: ../../docs/tutorials/animation/introduction_2d.rst:290
msgid ""
"Clamp loop interpolation: When this is selected, the animation stops after "
"the last keyframe for this track. When the first keyframe is reached again, "
"the animation will reset to its values."
msgstr ""
"钳位循环插值:选择此选项后，动画将在此轨道的最后一个关键帧之后停止。 再次到达"
"第一个关键帧时，动画将重置为其值。"

#: ../../docs/tutorials/animation/introduction_2d.rst:293
msgid ""
"Wrap loop interpolation: When this is selected, Godot calculates the "
"animation after the last keyframe to reach the values of the first keyframe "
"again."
msgstr ""
"包循环插值:当选择此项时，Godot会在最后一个关键帧之后计算动画，以再次达到第一"
"个关键帧的值。"

#: ../../docs/tutorials/animation/introduction_2d.rst:298
#: ../../docs/tutorials/animation/introduction_2d.rst:311
msgid "Keyframes for other properties"
msgstr "其他属性的关键帧"

#: ../../docs/tutorials/animation/introduction_2d.rst:300
msgid ""
"Godot doesn't restrict you to only edit transform properties. Every property "
"can be used as a track where you can set keyframes."
msgstr "Godot不限制您只编辑变换属性。 每个属性都可以用作可以设置关键帧的轨道。"

#: ../../docs/tutorials/animation/introduction_2d.rst:303
msgid ""
"If you select your sprite while the animation panel is visible, you get a "
"small keyframe button for all of the sprite's properties. Click on this "
"button and Godot automatically adds a track and keyframe to the current "
"animation."
msgstr ""
"如果在动画面板可见时选择了精灵，则会获得所有精灵属性的小关键帧按钮。 单击此按"
"钮，Godot会自动为当前动画添加轨道和关键帧。"

#: ../../docs/tutorials/animation/introduction_2d.rst:314
msgid "Edit keyframes"
msgstr "编辑关键帧"

#: ../../docs/tutorials/animation/introduction_2d.rst:316
msgid ""
"For advanced use and to edit keyframe in detail, enable the keyframe editor "
"(|Keyframe editor|)."
msgstr ""
"要获得高级用法并详细编辑关键帧，请启用关键帧编辑器(| Keyframe editor |)。"

#: ../../docs/tutorials/animation/introduction_2d.rst:319
msgid ""
"This adds an editor pane on the right side of the track settings. When you "
"select a keyframe, you can directly edit its values in this editor:"
msgstr ""
"这会在轨道设置的右侧添加一个编辑器窗格。 选择关键帧时，可以在此编辑器中直接编"
"辑其值:"

#: ../../docs/tutorials/animation/introduction_2d.rst:325
msgid "Keyframe editor editing a key"
msgstr "关键帧编辑器编辑一个键"

#: ../../docs/tutorials/animation/introduction_2d.rst:327
msgid "Additionally, you can also edit the transition value for this keyframe:"
msgstr "此外，您还可以编辑此关键帧的转换值:"

#: ../../docs/tutorials/animation/introduction_2d.rst:332
msgid "Keyframe editor editing a transition"
msgstr "关键帧编辑器编辑过渡"

#: ../../docs/tutorials/animation/introduction_2d.rst:334
msgid ""
"This tells Godot, how to change the property values when it reaches this "
"keyframe."
msgstr "这告诉Godot，如何在到达此关键帧时更改属性值。"

#: ../../docs/tutorials/animation/introduction_2d.rst:337
msgid ""
"You usually tweak your animations this way, when the movement doesn't \"look "
"right\"."
msgstr "当这个动作“看起来不正确”时，您通常会以这种方式调整您的动画。"

#: ../../docs/tutorials/animation/introduction_2d.rst:341
msgid "Advanced: Call Func tracks"
msgstr "高级:调用Func轨道"

#: ../../docs/tutorials/animation/introduction_2d.rst:343
msgid ""
"Godot's animation engine doesn't stop here. If you're already comfortable "
"with Godot's scripting language :ref:`doc_gdscript` and :doc:`/classes/"
"index` you know that each node type is a class and has a bunch of callable "
"functions."
msgstr ""
"Godot的动画引擎并不止于此。 如果您已经熟悉Godot的脚本语言 :ref:`doc_gdscript`"
"和:doc:`/ classes / index`您知道每个节点类型都是一个类，并且有一堆可调用的函"
"数。"

#: ../../docs/tutorials/animation/introduction_2d.rst:349
msgid ""
"For example, the :ref:`class_AudioStreamPlayer` node type has a function to "
"play an audio stream."
msgstr "例如， :ref:`class_AudioStreamPlayer`节点类型具有播放音频流的功能。"

#: ../../docs/tutorials/animation/introduction_2d.rst:352
msgid ""
"Wouldn't it be great to play a stream at a specific keyframe in an "
"animation? This is where \"Call Func Tracks\" come in handy. These tracks "
"reference a node again, this time without a reference to a property. "
"Instead, a keyframe holds the name and arguments of a function, that Godot "
"should call when it reaches this keyframe."
msgstr ""
"在动画中的特定关键帧上播放流不是很棒吗？ 这就是“Call Func Tracks”派上用场的地"
"方。 这些轨道再次引用一个节点，这次没有引用属性。 相反，一个关键帧包含一个函"
"数的名称和参数，当Godot到达这个关键帧时应该调用它。"

#: ../../docs/tutorials/animation/introduction_2d.rst:358
msgid ""
"To let Godot play a sample when it reaches a keyframe, follow this list:"
msgstr "要让Godot在到达关键帧时播放样本，请按以下列表:"

#: ../../docs/tutorials/animation/introduction_2d.rst:360
msgid ""
"Add a :ref:`class_AudioStreamPlayer` to the Scene Tree and setup a stream "
"using an audio file you put in your project."
msgstr ""
"在场景树中添加 :ref:`class_AudioStreamPlayer`，并使用放在项目中的音频文件设置"
"流。"

#: ../../docs/tutorials/animation/introduction_2d.rst:366
msgid "Add AudioStreamPlayer"
msgstr "添加AudioStreamPlayer"

#: ../../docs/tutorials/animation/introduction_2d.rst:368
msgid ""
"Click on \"Add track\" (|Add track|) on the animation panel's track controls."
msgstr "单击动画面板轨道控件上的“添加轨道”(|添加轨道|)。"

#: ../../docs/tutorials/animation/introduction_2d.rst:371
msgid "Select \"Add Call Func Track\" from the list of possible track types."
msgstr "从可能的轨道类型列表中选择“添加调用函数轨道”。"

#: ../../docs/tutorials/animation/introduction_2d.rst:376
msgid "Add Call Func Track"
msgstr "添加调用函数轨道"

#: ../../docs/tutorials/animation/introduction_2d.rst:378
msgid ""
"Select the :ref:`class_AudioStreamPlayer` node in the selection window. "
"Godot adds the track with the reference to the node."
msgstr ""
"在选择窗口中选择 :ref:`class_AudioStreamPlayer`节点。 Godot添加了轨道节点的引"
"用。"

#: ../../docs/tutorials/animation/introduction_2d.rst:384
msgid "Select AudioStreamPlayer"
msgstr "选择AudioStreamPlayer"

#: ../../docs/tutorials/animation/introduction_2d.rst:386
msgid ""
"Select the timeline position, where Godot should play the sample by clicking "
"on the timeline header."
msgstr "选择时间轴位置，Godot应该通过单击时间轴标题来播放样本。"

#: ../../docs/tutorials/animation/introduction_2d.rst:389
msgid "Enable the Keyframe Editor by clicking on |Keyframe editor|."
msgstr "单击|关键帧编辑器|启用关键帧编辑器。"

#: ../../docs/tutorials/animation/introduction_2d.rst:391
msgid ""
"Click on \"Add keyframe\" near the settings of our func track (|Add "
"keyframe|) and select the keyframe."
msgstr "单击我们的func轨道设置附近的“添加关键帧”(|添加关键帧|)并选择关键帧。"

#: ../../docs/tutorials/animation/introduction_2d.rst:397
msgid "Add a keyframe to the call func track"
msgstr "将一个关键帧添加到调用函数轨道"

#: ../../docs/tutorials/animation/introduction_2d.rst:399
msgid "Enter \"play\" as the function name."
msgstr "输入“play”作为函数名称。"

#: ../../docs/tutorials/animation/introduction_2d.rst:404
msgid "Keyframe settings of a call func track"
msgstr "调用函数轨道的关键帧设置"

#: ../../docs/tutorials/animation/introduction_2d.rst:406
msgid ""
"When Godot reaches the keyframe, Godot calls the :ref:"
"`class_AnimationPlayer` node's \"play\" function and the stream plays."
msgstr ""
"当Godot到达关键帧时，Godot调用 :ref:`class_AnimationPlayer`节点的“play”函数并"
"播放流。"

#: ../../docs/tutorials/animation/introduction_2d.rst:411
#: ../../docs/development/cpp/object_class.rst:233
#: ../../docs/development/cpp/custom_resource_format_loaders.rst:18
#: ../../docs/development/cpp/custom_resource_format_loaders.rst:39
#: ../../docs/development/cpp/custom_resource_format_loaders.rst:213
#: ../../docs/development/cpp/custom_resource_format_loaders.rst:247
#: ../../docs/development/cpp/custom_godot_servers.rst:19
#: ../../docs/development/cpp/custom_godot_servers.rst:316
msgid "References"
msgstr "参考"

#: ../../docs/tutorials/animation/introduction_2d.rst:414
msgid "Animation panel reference"
msgstr "动画面板参考"

#: ../../docs/tutorials/animation/introduction_2d.rst:419
msgid "The animation panel reference"
msgstr "动画面板参考"

#: ../../docs/tutorials/animation/introduction_2d.rst:421
msgid "The animation panel has the following parts (from left to right):"
msgstr "动画面板包含以下部分(从左到右):"

#: ../../docs/tutorials/animation/introduction_2d.rst:424
#: ../../docs/tutorials/animation/introduction_2d.rst:429
msgid "Animation controls"
msgstr "动画控件"

#: ../../docs/tutorials/animation/introduction_2d.rst:431
msgid "Play animation backwards from current position"
msgstr "从当前位置向后播放动画"

#: ../../docs/tutorials/animation/introduction_2d.rst:432
msgid "Play animation backwards from the animation end"
msgstr "从动画结尾向后播放动画"

#: ../../docs/tutorials/animation/introduction_2d.rst:433
msgid "Stop animation"
msgstr "停止动画"

#: ../../docs/tutorials/animation/introduction_2d.rst:434
msgid "Play animation forwards from the animation beginning"
msgstr "从动画开始向前播放动画"

#: ../../docs/tutorials/animation/introduction_2d.rst:435
msgid "Play animation forwards from the current position"
msgstr "从当前位置向前播放动画"

#: ../../docs/tutorials/animation/introduction_2d.rst:436
msgid "Direct time selection"
msgstr "直接时间选择"

#: ../../docs/tutorials/animation/introduction_2d.rst:439
#: ../../docs/tutorials/animation/introduction_2d.rst:444
msgid "Animation management"
msgstr "动画管理"

#: ../../docs/tutorials/animation/introduction_2d.rst:446
msgid "Create a new animation"
msgstr "创建一个新动画"

#: ../../docs/tutorials/animation/introduction_2d.rst:447
msgid "Load animation"
msgstr "加载动画"

#: ../../docs/tutorials/animation/introduction_2d.rst:448
msgid "Save animation"
msgstr "保存动画"

#: ../../docs/tutorials/animation/introduction_2d.rst:449
msgid "Duplicate animation"
msgstr "重复动画"

#: ../../docs/tutorials/animation/introduction_2d.rst:450
msgid "Rename animation"
msgstr "重命名动画"

#: ../../docs/tutorials/animation/introduction_2d.rst:451
msgid "Delete animation"
msgstr "删除动画"

#: ../../docs/tutorials/animation/introduction_2d.rst:452
msgid "Animation selection"
msgstr "动画选择"

#: ../../docs/tutorials/animation/introduction_2d.rst:453
msgid "Automatically play selected animation"
msgstr "自动播放选定的动画"

#: ../../docs/tutorials/animation/introduction_2d.rst:454
msgid "Edit animation blend times"
msgstr "编辑动画混合时间"

#: ../../docs/tutorials/animation/introduction_2d.rst:455
msgid "Extended animation Tools"
msgstr "扩展动画工具"

#: ../../docs/tutorials/animation/introduction_2d.rst:458
#: ../../docs/tutorials/animation/introduction_2d.rst:463
msgid "Timeline zoom level control"
msgstr "时间线缩放级别控制"

#: ../../docs/tutorials/animation/introduction_2d.rst:466
#: ../../docs/tutorials/animation/introduction_2d.rst:471
msgid "Timeline control"
msgstr "时间线控制"

#: ../../docs/tutorials/animation/introduction_2d.rst:473
msgid "Length of animation"
msgstr "动画长度"

#: ../../docs/tutorials/animation/introduction_2d.rst:474
msgid "Steps of animation"
msgstr "动画的步骤"

#: ../../docs/tutorials/animation/introduction_2d.rst:475
msgid "Toggle loop animation"
msgstr "切换循环动画"

#: ../../docs/tutorials/animation/introduction_2d.rst:478
#: ../../docs/tutorials/animation/introduction_2d.rst:483
msgid "Track control"
msgstr "轨道控制"

#: ../../docs/tutorials/animation/introduction_2d.rst:485
msgid "Add track"
msgstr "添加轨道"

#: ../../docs/tutorials/animation/introduction_2d.rst:486
msgid "Move track up"
msgstr "向上移动轨道"

#: ../../docs/tutorials/animation/introduction_2d.rst:487
msgid "Move track down"
msgstr "向下移动轨道"

#: ../../docs/tutorials/animation/introduction_2d.rst:488
msgid "Delete track"
msgstr "删除轨道"

#: ../../docs/tutorials/animation/introduction_2d.rst:489
msgid "Extended track tools"
msgstr "扩展的跟踪工具"

#: ../../docs/tutorials/animation/introduction_2d.rst:490
msgid "Toggle keyframe editor"
msgstr "切换关键帧编辑器"

#: ../../docs/tutorials/animation/cutout_animation.rst:4
msgid "Cutout animation"
msgstr "剪纸动画"

#: ../../docs/tutorials/animation/cutout_animation.rst:7
#: ../../docs/tutorials/inputs/inputevent.rst:7
msgid "What is it?"
msgstr "它是什么？"

#: ../../docs/tutorials/animation/cutout_animation.rst:9
msgid ""
"Cut-out is a technique of animating in 2D where pieces of paper (or similar "
"material) are cut in special shapes and laid one over the other. The papers "
"are animated and photographed, frame by frame using a stop motion technique "
"(more info `here <https://en.wikipedia.org/wiki/Cutout_animation>`__)."
msgstr ""
"剪纸是一种在2D中制作动画的技术，其中纸张(或类似的材质)被切割成特殊形状并且叠"
"放在一起。使用停止运动技术，这些纸张变成逐帧动画(更多信息见 `这里 <https://"
"en.wikipedia.org/wiki/Cutout_animation>`__)。"

#: ../../docs/tutorials/animation/cutout_animation.rst:15
msgid ""
"With the advent of the digital age, this technique became possible using "
"computers, which resulted in an increased amount of animation TV shows using "
"digital Cut-out. Notable examples are `South Park <https://en.wikipedia.org/"
"wiki/South_Park>`__ or `Jake and the Never Land Pirates <https://en."
"wikipedia.org/wiki/Jake_and_the_Never_Land_Pirates>`__ ."
msgstr ""
"随着数字时代的到来，可以使用计算机实现这种技术，这导致使用数字剪纸动画电视节"
"目的数量增加。 值得注意的示例有 `South Park <https://en.wikipedia.org/wiki/"
"South_Park>`__ 或 `Jake和Never Land Pirates <https://en.wikipedia.org/wiki/"
"Jake_and_the_Never_Land_Pirates>`__ 。"

#: ../../docs/tutorials/animation/cutout_animation.rst:23
msgid ""
"In video games, this technique has also become popular. Examples of this are "
"`Paper Mario <https://en.wikipedia.org/wiki/Super_Paper_Mario>`__ or `Rayman "
"Origins <https://en.wikipedia.org/wiki/Rayman_Origins>`__ ."
msgstr ""
"在视频游戏中，这种技术也变得流行。 例如 `Paper Mario <https://en.wikipedia."
"org/wiki/Super_Paper_Mario>`__ 或 `Rayman Origins <https://en.wikipedia.org/"
"wiki/Rayman_Origins>`__ 。"

#: ../../docs/tutorials/animation/cutout_animation.rst:29
msgid "Cutout in Godot"
msgstr "Godot中的剪纸"

#: ../../docs/tutorials/animation/cutout_animation.rst:31
msgid ""
"Godot provides a few tools for working with these kind of assets, but its "
"overall design makes it ideal for the workflow. The reason is that, unlike "
"other tools meant for this, Godot has the following advantages:"
msgstr ""
"Godot提供了一些工具来处理这些资源，但它的整体设计使其成为工作流程的理想选"
"择。 原因在于，与其他工具不同，Godot具有以下优势:"

#: ../../docs/tutorials/animation/cutout_animation.rst:35
msgid ""
"**The animation system is fully integrated with the engine**: This means, "
"animations can control much more than just motion of objects, such as "
"textures, sprite sizes, pivots, opacity, color modulation, etc. Everything "
"can be animated and blended."
msgstr ""
"**动画系统与引擎完全集成**:这意味着，动画可以控制的不仅仅是物体的运动，例如纹"
"理，精灵大小，枢轴，不透明度，颜色调制等。一切都可以动画和混合。"

#: ../../docs/tutorials/animation/cutout_animation.rst:39
msgid ""
"**Mix with Traditional**: AnimatedSprite allows traditional animation to be "
"mixed, useful for complex objects, such as shape of hands and foot, changing "
"facial expression, etc."
msgstr ""
"**与传统混合**: AnimatedSprite允许混合传统动画，对复杂对象有用，例如手脚形"
"状，改变面部表情等。"

#: ../../docs/tutorials/animation/cutout_animation.rst:42
msgid ""
"**Custom Shaped Elements**: Can be created with :ref:`Polygon2D "
"<class_Polygon2D>` allowing the mixing of UV animation, deformations, etc."
msgstr ""
"**自定义形状元素**: 可以使用 :ref:`Polygon2D <class_Polygon2D>` 创建，允许混"
"合UV动画，变形等。"

#: ../../docs/tutorials/animation/cutout_animation.rst:45
msgid ""
"**Particle Systems**: Can also be mixed with the traditional animation "
"hierarchy, useful for magic effects, jetpacks, etc."
msgstr ""
"**粒子系统**:也可以与传统的动画层次结构混合，对魔术效果，喷气背包等有用。"

#: ../../docs/tutorials/animation/cutout_animation.rst:47
msgid ""
"**Custom Colliders**: Set colliders and influence areas in different parts "
"of the skeletons, great for bosses, fighting games, etc."
msgstr ""
"**自定义碰撞器**:设置碰撞器并影响骨骼不同部位的区域，非常适合老板，格斗游戏"
"等。"

#: ../../docs/tutorials/animation/cutout_animation.rst:49
msgid ""
"**Animation Tree**: Allows complex combinations and blendings of several "
"animations, the same way it works in 3D."
msgstr "**动画树**:允许多个动画的复杂组合和混合，就像在3D中一样。"

#: ../../docs/tutorials/animation/cutout_animation.rst:52
#: ../../docs/tutorials/shading/shader_materials.rst:24
msgid "And much more!"
msgstr "以及更多！"

#: ../../docs/tutorials/animation/cutout_animation.rst:55
#, fuzzy
msgid "Making of GBot"
msgstr "制作GBot！"

#: ../../docs/tutorials/animation/cutout_animation.rst:57
msgid ""
"For this tutorial, we will use as demo content the pieces of the `GBot "
"<https://www.youtube.com/watch?"
"v=S13FrWuBMx4&list=UUckpus81gNin1aV8WSffRKw>`__ character, created by "
"Andreas Esau."
msgstr ""
"在本教程中，我们将使用由Andreas Esau创建的 `GBot <https://www.youtube.com/"
"watch?v=S13FrWuBMx4&list=UUckpus81gNin1aV8WSffRKw>`__ 角色作为演示。"

#: ../../docs/tutorials/animation/cutout_animation.rst:63
msgid ""
"Get your assets: :download:`gbot_resources.zip <files/gbot_resources.zip>`."
msgstr ""
"获得您的资源: :download:`gbot_resources.zip <files/gbot_resources.zip>`。"

#: ../../docs/tutorials/animation/cutout_animation.rst:66
msgid "Setting up the rig"
msgstr "设置装配"

#: ../../docs/tutorials/animation/cutout_animation.rst:68
msgid "Create an empty Node2D as root of the scene, we will work under it:"
msgstr "创建一个空的Node2D作为场景的根，我们将在它下面工作:"

#: ../../docs/tutorials/animation/cutout_animation.rst:72
msgid ""
"OK, the first node of the model that we will create will be the hip. "
"Generally, both in 2D and 3D, the hip is the root of the skeleton. This "
"makes it easier to animate:"
msgstr ""
"好的，我们将创建的模型的第一个节点是臀部。 通常，无论是2D还是3D，臀部都是骨架"
"的根节点。 这使动画变得更容易:"

#: ../../docs/tutorials/animation/cutout_animation.rst:78
msgid ""
"Next will be the torso. The torso needs to be a child of the hip, so create "
"a child sprite and load the torso, later accommodate it properly:"
msgstr ""
"接下来将是躯干。 躯干需要是臀部的子节点，所以创建一个子节点精灵并加载躯干，然"
"后适当地调整它:"

#: ../../docs/tutorials/animation/cutout_animation.rst:83
msgid ""
"This looks good. Let's see if our hierarchy works as a skeleton by rotating "
"the torso. We can do this be pressing ``E`` to enter rotate mode, and "
"dragging with the left mouse button. To exit rotate mode hit ``ESC``."
msgstr ""
"这看起来不错。 让我们通过旋转躯干来看看我们的层次结构是否作为骨架。 我们可以"
"按 ``E`` 进入旋转模式，然后用鼠标左键拖动。 要退出旋转模式，请按 ``ESC``。"

#: ../../docs/tutorials/animation/cutout_animation.rst:89
msgid ""
"Ouch, that doesn't look good! The rotation pivot is wrong, this means it "
"needs to be adjusted."
msgstr "哎哟，看起来不太好看！ 旋转枢轴是错误的，这意味着它需要调整。"

#: ../../docs/tutorials/animation/cutout_animation.rst:92
msgid ""
"This small little cross in the middle of the :ref:`Sprite <class_Sprite>` is "
"the rotation pivot:"
msgstr "这个在 :ref:`Sprite <class_Sprite>` 中间的小十字架是旋转轴:"

#: ../../docs/tutorials/animation/cutout_animation.rst:99
msgid "Adjusting the pivot"
msgstr "调整枢轴"

#: ../../docs/tutorials/animation/cutout_animation.rst:101
msgid ""
"The pivot can be adjusted by changing the *offset* property in the Sprite:"
msgstr "可以通过更改Sprite中的 *offset* 属性来调整pivot:"

#: ../../docs/tutorials/animation/cutout_animation.rst:106
msgid ""
"However, there is a way to do it more *visually*. While hovering over the "
"desired pivot point, simply press the \"v\" key to move the pivot there for "
"the selected Sprite. Alternately, there is a tool in the tool bar that has a "
"similar function."
msgstr ""
"但是，有一种方法可以在 *视觉上* 做得更多。 将鼠标悬停在所需的枢轴点上时，只需"
"按“v”键即可为所选的Sprite移动枢轴。 或者，工具栏中有一个具有类似功能的工具。"

#: ../../docs/tutorials/animation/cutout_animation.rst:113
msgid ""
"Now it looks good! Let's continue adding body pieces, starting by the right "
"arm. Make sure to put the sprites in hierarchy, so their rotations and "
"translations are relative to the parent:"
msgstr ""
"现在看起来不错！ 让我们从右臂开始继续添加物体碎片。 确保将精灵放在层次结构"
"中，因此它们的旋转和平移是相对于父级的:"

#: ../../docs/tutorials/animation/cutout_animation.rst:119
msgid ""
"This seems easy, so continue with the left arm. The rest should be simple! "
"Or maybe not:"
msgstr "这似乎很容易，所以继续左臂。 其余的应该很简单！ 或者可能不是:"

#: ../../docs/tutorials/animation/cutout_animation.rst:124
msgid ""
"Right. In 2D, parent nodes appear below children nodes. Well, this sucks. "
"But how can this problem be solved? We want the left arm to appear behind "
"the hip and the torso. For this, we can move the nodes behind the hip (note "
"that you can bypass this by setting the Node2D Z property, but then you "
"won't learn about all this!):"
msgstr ""
"对。 在2D中，父节点出现在子节点下方。 嗯，这很糟糕。 但是如何解决这个问题"
"呢？ 我们希望左臂出现在臀部和躯干后面。 为此，我们可以移动臀部后面的节点(请注"
"意，您可以通过设置Node2D Z属性来绕过它，但是您将无法了解所有这些！):"

#: ../../docs/tutorials/animation/cutout_animation.rst:132
msgid ""
"But then, we lose the hierarchy layout, which allows to control the skeleton "
"like.. a skeleton. Is there any hope?.. Of Course!"
msgstr ""
"但是，我们失去了层次结构布局，这允许像骨架一样控制骨架。 有什么希望吗？当然！"

#: ../../docs/tutorials/animation/cutout_animation.rst:136
msgid "RemoteTransform2D node"
msgstr "RemoteTransform2D节点"

#: ../../docs/tutorials/animation/cutout_animation.rst:138
msgid ""
"Godot provides a special node, :ref:`RemoteTransform2D "
"<class_RemoteTransform2D>`. This node will transform nodes that are sitting "
"somewhere else in the hierarchy, by applying the transform to the remote "
"nodes."
msgstr ""
"Godot提供了一个特殊节点， :ref:`RemoteTransform2D "
"<class_RemoteTransform2D>`。 通过将转换应用于远程节点，此节点将转换位于层次结"
"构中其他位置的节点。"

#: ../../docs/tutorials/animation/cutout_animation.rst:142
msgid "This enables to have a visibility order independent from the hierarchy."
msgstr "这使得能够具有独立于层次结构的可见性顺序。"

#: ../../docs/tutorials/animation/cutout_animation.rst:145
msgid ""
"Simply create two more nodes as children from torso, remote_arm_l and "
"remote_hand_l and link them to the actual sprites:"
msgstr ""
"只需从torso，remote_arm_l和remote_hand_l创建另外两个节点作为子节点，并将它们"
"链接到实际的sprite:"

#: ../../docs/tutorials/animation/cutout_animation.rst:150
msgid ""
"Moving the remote transform nodes will move the sprites, allowing you to "
"easily animate and pose the character:"
msgstr "移动远程变换节点将移动精灵，使您可以轻松设置角色的动画和姿势:"

#: ../../docs/tutorials/animation/cutout_animation.rst:156
msgid "Completing the skeleton"
msgstr "完成骨架"

#: ../../docs/tutorials/animation/cutout_animation.rst:158
msgid ""
"Complete the skeleton by following the same steps for the rest of the parts. "
"The resulting scene should look similar to this:"
msgstr "按照其余部分的相同步骤完成骨架。 生成的场景应该类似于:"

#: ../../docs/tutorials/animation/cutout_animation.rst:163
msgid ""
"The resulting rig will be easy to animate. By selecting the nodes and "
"rotating them you can animate forward kinematics (FK) efficiently."
msgstr ""
"生成的装备很容易制作动画。 通过选择节点并旋转它们，您可以有效地为前向运动学"
"(FK)设置动画。"

#: ../../docs/tutorials/animation/cutout_animation.rst:166
msgid ""
"For simple objects and rigs this is fine, however the following problems are "
"common:"
msgstr "对于简单的物体和装配，这已足够，但仍有以下常见问题:"

#: ../../docs/tutorials/animation/cutout_animation.rst:169
msgid ""
"Selecting sprites can become difficult for complex rigs, and the scene tree "
"ends being used due to the difficulty of clicking over the proper sprite."
msgstr ""
"对于复杂的装配，选择精灵可能变得困难，并且由于难以点击正确的精灵而使用场景"
"树。"

#: ../../docs/tutorials/animation/cutout_animation.rst:172
msgid "Inverse Kinematics is often desired for extremities."
msgstr "四肢通常需要反向运动学。"

#: ../../docs/tutorials/animation/cutout_animation.rst:174
msgid "To solve these problems, Godot supports a simple method of skeletons."
msgstr "为了解决这些问题，Godot支持一种简单的骨骼方法。"

#: ../../docs/tutorials/animation/cutout_animation.rst:177
msgid "Skeletons"
msgstr "骨架"

#: ../../docs/tutorials/animation/cutout_animation.rst:179
msgid ""
"Godot doesn't actually support *true* Skeletons, but it does feature a "
"helper to create \"bones\" between nodes. This is enough for most cases, but "
"the way it works is not completely obvious."
msgstr ""
"Godot实际上并不支持 *真的* 骨架，但它确实有一个帮助器来创建节点之间的“骨"
"骼”。 对于大多数情况来说这已经足够了，但它的工作方式并不完全明显。"

#: ../../docs/tutorials/animation/cutout_animation.rst:185
msgid ""
"As an example, let's turn the right arm into a skeleton. To create "
"skeletons, a chain of nodes must be selected from top to bottom:"
msgstr ""
"举个示例，让我们将右臂变成骨架。 要创建骨架，必须从上到下选择一系列节点:"

#: ../../docs/tutorials/animation/cutout_animation.rst:190
msgid "Then, click on the Skeleton menu and select ``Make Bones``."
msgstr "然后，单击Skeleton菜单并选择 ``Make Bones`` 。"

#: ../../docs/tutorials/animation/cutout_animation.rst:194
msgid ""
"This will add bones covering the arm, but the result is not quite what is "
"expected."
msgstr "这将增加覆盖手臂的骨骼，但结果并不完全符合预期。"

#: ../../docs/tutorials/animation/cutout_animation.rst:199
msgid ""
"It looks like the bones are shifted up in the hierarchy. The hand connects "
"to the arm, and the arm to the body. So the question is:"
msgstr ""
"看起来骨骼在层次结构中向上移动。 手连接到手臂，手臂连接到物体。 所以问题是:"

#: ../../docs/tutorials/animation/cutout_animation.rst:202
msgid "Why does the hand lack a bone?"
msgstr "为什么手掌缺少骨骼？"

#: ../../docs/tutorials/animation/cutout_animation.rst:203
msgid "Why does the arm connect to the body?"
msgstr "为什么胳膊要连接到物体？"

#: ../../docs/tutorials/animation/cutout_animation.rst:205
msgid ""
"This might seem strange at first, but will make sense later on. In "
"traditional skeleton systems, bones have a position, an orientation and a "
"length. In Godot, bones are mostly helpers so they connect the current node "
"with the parent. Because of this, **toggling a node as a bone will just "
"connect it to the parent**."
msgstr ""
"起初这可能看起来很奇怪，但稍后会有意义。 在传统的骨架系统中，骨骼具有位置，方"
"向和长度。 在Godot中，骨骼主要是帮助者，因此它们将当前节点与父节点连接起来。 "
"因此， **将节点切换为骨骼只会将其连接到父** 。"

#: ../../docs/tutorials/animation/cutout_animation.rst:211
msgid ""
"So, with this knowledge. Let's do the same again so we have an actual, "
"useful skeleton."
msgstr ""
"所以，有了这些知识。 让我们再次这样做，这样我们就有了一个实际的，有用的骨架。"

#: ../../docs/tutorials/animation/cutout_animation.rst:214
msgid ""
"The first step is creating an endpoint node. Any kind of node will do, but :"
"ref:`Position2D <class_Position2D>` is preferred because it's visible in the "
"editor. The endpoint node will ensure that the last bone has orientation."
msgstr ""
"第一步是创建端点节点。 任何类型的节点都可以，但是 :ref:`Position2D "
"<class_Position2D>` 是首选，因为它在编辑器中可见。 端点节点将确保最后一个骨骼"
"具有方向。"

#: ../../docs/tutorials/animation/cutout_animation.rst:221
msgid ""
"Now select the whole chain, from the endpoint to the arm and create bones:"
msgstr "现在选择整个链，从端点到手臂并创建骨骼:"

#: ../../docs/tutorials/animation/cutout_animation.rst:226
msgid ""
"The result resembles a skeleton a lot more, and now the arm and forearm can "
"be selected and animated."
msgstr "结果类似于骨架更多，现在可以选择手臂和前臂并设置动画。"

#: ../../docs/tutorials/animation/cutout_animation.rst:229
msgid ""
"Finally, create endpoints in all meaningful extremities and connect the "
"whole skeleton with bones up to the hip."
msgstr "最后，在所有有意义的四肢中创建端点，并将整个骨骼与骨骼连接起来。"

#: ../../docs/tutorials/animation/cutout_animation.rst:232
msgid ""
"You may notice when connecting the hip and torso, that an extra bone is "
"created. To fix this, select the root and hip node, open the Skeleton menu, "
"click ``clear bones``."
msgstr ""
"您可能会注意到连接臀部和躯干时，会产生额外的骨骼。 要解决这个问题，请选择root"
"和hip节点，打开Skeleton菜单，单击 ``clear bones``。"

#: ../../docs/tutorials/animation/cutout_animation.rst:238
msgid "After fixing that your final skeleton should look something like this:"
msgstr "修复后您的最终骨架应该是这样的:"

#: ../../docs/tutorials/animation/cutout_animation.rst:242
msgid ""
"Finally! the whole skeleton is rigged! On close look, it is noticeable that "
"there is a second set of endpoints in the hands. This will make sense soon."
msgstr ""
"最后！ 整个骨架都被操纵了！ 仔细观察，可以看出手中有第二组端点。 这很快就会有"
"意义。"

#: ../../docs/tutorials/animation/cutout_animation.rst:246
msgid ""
"Now that a whole skeleton is rigged, the next step is setting up the IK "
"chains. IK chains allow for more natural control of extremities."
msgstr "现在整个骨架被装配，下一步是设置IK链。 IK链可以更自然地控制四肢。"

#: ../../docs/tutorials/animation/cutout_animation.rst:250
msgid "IK chains"
msgstr "IK链"

#: ../../docs/tutorials/animation/cutout_animation.rst:252
msgid ""
"IK chains are a powerful animation tool. Imagine you want to pose a "
"character's foot in a specific position on the ground. Without IK chains, "
"each motion of the foot would require rotating and positioning several other "
"bones. This would be quite complex and lead to imprecise results."
msgstr ""
"IK链是一种强大的动画工具。 想象一下，您想要将角色的脚放在地面上的特定位置。 "
"如果没有IK链，脚的每次运动都需要旋转和定位其他几个骨骼。 这将非常复杂并导致不"
"精确的结果。"

#: ../../docs/tutorials/animation/cutout_animation.rst:254
msgid "What if we could move the foot and let the rest of the leg self-adjust?"
msgstr "如果我们想要移动脚并让腿的其余部分自我调整怎么办？"

#: ../../docs/tutorials/animation/cutout_animation.rst:256
msgid "This type of posing is called IK (Inverse Kinematic)."
msgstr "这种类型的姿势称为IK(反向运动学)。"

#: ../../docs/tutorials/animation/cutout_animation.rst:258
msgid ""
"To create an IK chain, simply select a chain of bones from endpoint to the "
"base for the chain. For example, to create an IK chain for the right leg, "
"select the following:"
msgstr ""
"要创建IK链，只需从端点到链的基础选择一串骨骼。 例如，要为右腿创建IK链，请选择"
"以下内容:"

#: ../../docs/tutorials/animation/cutout_animation.rst:264
msgid "Then enable this chain for IK. Go to Edit > Make IK Chain."
msgstr "然后为IK启用此链。 转到编辑>制作IK链。"

#: ../../docs/tutorials/animation/cutout_animation.rst:268
msgid "As a result, the base of the chain will turn *Yellow*."
msgstr "结果，链的基部将变为 *黄色*。"

#: ../../docs/tutorials/animation/cutout_animation.rst:272
msgid ""
"Once the IK chain is set-up, simply grab any of the bones in the extremity, "
"any child or grand-child of the base of the chain and try to grab it and "
"move it. Result will be pleasant, satisfaction warranted!"
msgstr ""
"一旦IK链被设置，只需抓住肢体中的任何骨骼，链条基部的任何儿童或幼儿，并尝试抓"
"住它并移动它。 结果将是愉快的，满意的保证！"

#: ../../docs/tutorials/animation/cutout_animation.rst:281
msgid ""
"The following section will be a collection of tips for creating animation "
"for your rigs. If unsure about how the animation system in Godot works, "
"refresh it by checking again the :ref:`doc_animations`."
msgstr ""
"以下部分将为您的装备创建动画的提示集合。 如果不确定Godot的动画系统是如何工作"
"的，请再次检查 :ref:`doc_animations` 来刷新它。"

#: ../../docs/tutorials/animation/cutout_animation.rst:286
msgid "2D animation"
msgstr "2D动画"

#: ../../docs/tutorials/animation/cutout_animation.rst:288
msgid ""
"When doing animation in 2D, a helper will be present in the top menu. This "
"helper only appears when the animation editor window is opened:"
msgstr ""
"在2D中执行动画时，顶部菜单中将显示帮助程序。 此助手仅在打开动画编辑器窗口时出"
"现:"

#: ../../docs/tutorials/animation/cutout_animation.rst:293
msgid ""
"The key button will insert location/rotation/scale keyframes to the selected "
"objects or bones. This depends on the mask enabled. Green items will insert "
"keys while red ones will not, so modify the key insertion mask to your "
"preference."
msgstr ""
"键按钮将位置/旋转/缩放关键帧插入所选对象或骨骼。 这取决于启用的掩码。 绿色项"
"目将插入键，而红色项目不会，因此根据您的喜好修改键插入掩码。"

#: ../../docs/tutorials/animation/cutout_animation.rst:299
msgid "Rest pose"
msgstr "休息姿势"

#: ../../docs/tutorials/animation/cutout_animation.rst:301
msgid ""
"These kind of rigs do not have a \"rest\" pose, so it's recommended to "
"create a reference rest pose in one of the animations."
msgstr "这些装备没有“休息”姿势，因此建议在其中一个动画中创建参考静止姿势。"

#: ../../docs/tutorials/animation/cutout_animation.rst:304
msgid "Simply do the following steps:"
msgstr "只需执行以下步骤:"

#: ../../docs/tutorials/animation/cutout_animation.rst:306
msgid "Make sure the rig is in \"rest\" (not doing any specific pose)."
msgstr "确保装配处于“休息”状态(不做任何特定姿势)。"

#: ../../docs/tutorials/animation/cutout_animation.rst:308
msgid "Create a new animation, rename it to \"rest\"."
msgstr "创建一个新动画，将其重命名为“rest”。"

#: ../../docs/tutorials/animation/cutout_animation.rst:310
msgid "Select all nodes (box selection should work fine)."
msgstr "选择所有节点(框选择应该正常)。"

#: ../../docs/tutorials/animation/cutout_animation.rst:312
msgid "Select \"loc\" and \"rot\" on the top menu."
msgstr "在顶部菜单中选择“loc”和“rot”。"

#: ../../docs/tutorials/animation/cutout_animation.rst:314
msgid ""
"Push the key button. Keys will be inserted for everything, creating a "
"default pose."
msgstr "按下按键。 将为所有内容插入键，创建默认姿势。"

#: ../../docs/tutorials/animation/cutout_animation.rst:322
msgid ""
"Animating these models means only modifying the rotation of the nodes. "
"Location and scale are rarely used, with the only exception of moving the "
"entire rig from the hip (which is the root node)."
msgstr ""
"动画这些模型意味着只修改节点的旋转。 很少使用位置和比例，唯一的例外是从臀部"
"(根节点)移动整个装备。"

#: ../../docs/tutorials/animation/cutout_animation.rst:326
msgid ""
"As a result, when inserting keys, only the \"rot\" button needs to be "
"pressed most of the time:"
msgstr "因此，在插入键时，大多数时间只需要按下“rot”按钮:"

#: ../../docs/tutorials/animation/cutout_animation.rst:331
msgid ""
"This will avoid the creation of extra animation tracks for the position that "
"will remain unused."
msgstr "这将避免为将保持未使用的位置创建额外的动画轨道。"

#: ../../docs/tutorials/animation/cutout_animation.rst:335
msgid "Keyframing IK"
msgstr "关键帧IK"

#: ../../docs/tutorials/animation/cutout_animation.rst:337
msgid ""
"When editing IK chains, it is not necessary to select the whole chain to add "
"keyframes. Selecting the endpoint of the chain and inserting a keyframe will "
"automatically insert keyframes until the chain base too. This makes the task "
"of animating extremities much simpler."
msgstr ""
"编辑IK链时，无需选择整个链来添加关键帧。 选择链的端点并插入关键帧将自动插入关"
"键帧，直到链基。 这使得动画四肢的任务变得更加简单。"

#: ../../docs/tutorials/animation/cutout_animation.rst:343
#, fuzzy
msgid "Moving sprites above and behind others"
msgstr "移动精灵在其他物体之上和之后。"

#: ../../docs/tutorials/animation/cutout_animation.rst:345
msgid ""
"RemoteTransform2D works in most cases, but sometimes it is necessary to have "
"a node above and below others during an animation. To aid on this the "
"\"Behind Parent\" property exists on any Node2D:"
msgstr ""
"RemoteTransform2D在大多数情况下都有效，但有时在动画期间必须在其他节点之上和之"
"下有一个节点。 为此，在任何Node2D上都存在“Behind Parent”属性:"

#: ../../docs/tutorials/animation/cutout_animation.rst:352
msgid "Batch setting transition curves"
msgstr "批量设置过渡曲线"

#: ../../docs/tutorials/animation/cutout_animation.rst:354
msgid ""
"When creating complex animations and inserting many keyframes, editing the "
"individual keyframe curves for each can become an endless task. For this, "
"the Animation Editor has a small menu where changing animation curves is "
"easy. First select the appropriate keys. Next click on the pencil icon in "
"the bottom right of the animation panel, this will open the transition "
"editor. Now click on one of the curve options most appropriate for your "
"animation."
msgstr ""
"在创建复杂动画和插入许多关键帧时，编辑每个关键帧曲线可能会成为一项无穷无尽的"
"任务。 为此，动画编辑器有一个小菜单，可以轻松更改动画曲线。 首先选择合适的"
"键。 接下来，单击动画面板右下角的铅笔图标，这将打开转换编辑器。 现在单击最适"
"合动画的曲线选项之一。"

#: ../../docs/tutorials/animation/cutout_animation.rst:365
msgid "2D Skeletal deform"
msgstr ""

#: ../../docs/tutorials/animation/cutout_animation.rst:367
msgid ""
"Starting with Godot 3.1, 2D skeletal deform is supported, which can be used "
"to enhance this workflow and add more flexibility (single pieces can deform "
"more organically instead of having to use many separate ones)."
msgstr ""

#: ../../docs/tutorials/animation/cutout_animation.rst:370
msgid ""
"This process is described in a :ref:`separate tutorial <doc_2d_skeletons>`."
msgstr ""

#: ../../docs/tutorials/animation/2d_skeletons.rst:4
#, fuzzy
msgid "2D skeletons"
msgstr "骨架"

#: ../../docs/tutorials/animation/2d_skeletons.rst:9
msgid ""
"When working with 3D, skeletal deforms are common for characters and "
"creatures and most 3D modelling applications support it. For 2D, as this "
"function is not used as often, it's difficult to find mainstream software "
"aimed for this."
msgstr ""

#: ../../docs/tutorials/animation/2d_skeletons.rst:13
msgid ""
"One option is to create animations in third-party software such as Spine or "
"Dragonbones. From Godot 3.1 onwards, though, this functionality is supported "
"built-in."
msgstr ""

#: ../../docs/tutorials/animation/2d_skeletons.rst:16
msgid ""
"Why would you want to do skeletal animations directly in Godot? The answer "
"is that there are many advantages to it:"
msgstr ""

#: ../../docs/tutorials/animation/2d_skeletons.rst:18
msgid ""
"Better integration with the engine, so less hassle importing and editing "
"from an external tool."
msgstr ""

#: ../../docs/tutorials/animation/2d_skeletons.rst:19
msgid ""
"Ability to control particle systems, shaders, sounds, call scripts, colors, "
"transparency, etc. in animations."
msgstr ""

#: ../../docs/tutorials/animation/2d_skeletons.rst:20
msgid ""
"The built-in skeletal system in Godot is very efficient and designed for "
"performance."
msgstr ""

#: ../../docs/tutorials/animation/2d_skeletons.rst:22
msgid "The following tutorial will, then, explain 2D skeletal deformations."
msgstr ""

#: ../../docs/tutorials/animation/2d_skeletons.rst:27
msgid ""
"Before starting, it is advised to go through the :ref:`doc_cutout_animation` "
"tutorial to gain a general understanding of animating within Godot."
msgstr ""

#: ../../docs/tutorials/animation/2d_skeletons.rst:30
msgid ""
"For this tutorial, we will be using a single image to construct our "
"character. Download it from :download:`gBot_pieces.png <img/gBot_pieces."
"png>` or save the image below."
msgstr ""

#: ../../docs/tutorials/animation/2d_skeletons.rst:35
msgid ""
"It is also advised to download the final character image :download:"
"`gBot_complete.png <img/gBot_complete.png>` to have a good reference for "
"putting the different pieces together."
msgstr ""

#: ../../docs/tutorials/animation/2d_skeletons.rst:41
#, fuzzy
msgid "Creating the polygons"
msgstr "创建一个插件"

#: ../../docs/tutorials/animation/2d_skeletons.rst:43
msgid ""
"Create a new scene for your model (if it's going to be an animated "
"character, you may want to use a ``KinematicBody2D``). For ease of use, an "
"empty 2D node is created as a root for the polygons."
msgstr ""

#: ../../docs/tutorials/animation/2d_skeletons.rst:46
msgid ""
"Begin with a ``Polygon2D`` node. There is no need to place it anywhere in "
"the scene for now, so simply create it like this:"
msgstr ""

#: ../../docs/tutorials/animation/2d_skeletons.rst:50
msgid ""
"Select it and assign the texture with the character pieces you have "
"downloaded before:"
msgstr ""

#: ../../docs/tutorials/animation/2d_skeletons.rst:54
msgid ""
"Drawing a polygon directly is not advised. Instead, open the \"UV\" dialog "
"for the polygon:"
msgstr ""

#: ../../docs/tutorials/animation/2d_skeletons.rst:58
msgid ""
"Head over to the *Points* mode, select the pencil and draw a polygon around "
"the desired piece:"
msgstr ""

#: ../../docs/tutorials/animation/2d_skeletons.rst:62
msgid ""
"Duplicate the polygon node, rename it properly, enter the \"UV\" dialog "
"again and replace the old polygon with another one in the new desired piece."
msgstr ""

#: ../../docs/tutorials/animation/2d_skeletons.rst:66
msgid "Keep doing this until all pieces have been mapped."
msgstr ""

#: ../../docs/tutorials/animation/2d_skeletons.rst:70
msgid ""
"You will notice that pieces for nodes appear in the same layout as they do "
"in the original texture. This is because (by default) when you draw a "
"polygon, the UV and points are the same."
msgstr ""

#: ../../docs/tutorials/animation/2d_skeletons.rst:73
msgid ""
"Rearrange the pieces and build the character. This should be pretty quick. "
"There is no need to change pivots, so don't bother making sure rotation "
"pivots for each piece are right; you can leave them be for now."
msgstr ""

#: ../../docs/tutorials/animation/2d_skeletons.rst:78
msgid ""
"Ah, the visual order of the pieces is not correct yet, as some are covering "
"wrong pieces. Rearrange the order of the nodes to fix this:"
msgstr ""

#: ../../docs/tutorials/animation/2d_skeletons.rst:82
msgid ""
"And there you go! It was definitely much easier than in the cutout tutorial."
msgstr ""

#: ../../docs/tutorials/animation/2d_skeletons.rst:85
#, fuzzy
msgid "Creating the skeleton"
msgstr "完成骨架"

#: ../../docs/tutorials/animation/2d_skeletons.rst:87
msgid ""
"Create a ``Skeleton2D`` node as a child of the root node. This will be the "
"base of our skeleton:"
msgstr ""

#: ../../docs/tutorials/animation/2d_skeletons.rst:91
msgid ""
"Create a ``Bone2D`` node as a child of the skeleton. Put it on the hip "
"(usually skeletons start here). The bone will be pointing to the right, but "
"you can ignore this for now."
msgstr ""

#: ../../docs/tutorials/animation/2d_skeletons.rst:96
msgid "Keep creating bones in hierarchy and naming them accordingly."
msgstr ""

#: ../../docs/tutorials/animation/2d_skeletons.rst:100
msgid ""
"At the end of this chain, there will be a *jaw* node. It is, again, very "
"short and pointing to the right. This is normal for bones without children. "
"The length of *tip* bones can be changed with a property in the inspector:"
msgstr ""

#: ../../docs/tutorials/animation/2d_skeletons.rst:105
msgid ""
"In this case, we don't need to rotate the bone (coincidentially the jaw "
"points right in the sprite), but in case you need to, feel free to do it. "
"Again, this is only really needed for tip bones as nodes with children don't "
"usually need a length or a specific rotation."
msgstr ""

#: ../../docs/tutorials/animation/2d_skeletons.rst:108
msgid "Keep going and build the whole skeleton:"
msgstr ""

#: ../../docs/tutorials/animation/2d_skeletons.rst:112
msgid ""
"You will notice that all bones raise an annoying warning about a missing "
"rest pose. This means that it's time to set one. Go to the *skeleton* node "
"and create a rest pose. This pose is the default one, you can come back to "
"it anytime you want (which is very handy for animating):"
msgstr ""

#: ../../docs/tutorials/animation/2d_skeletons.rst:117
msgid ""
"The warnings will go away. If you modify the skeleton (add/remove bones) you "
"will need to set the rest pose again."
msgstr ""

#: ../../docs/tutorials/animation/2d_skeletons.rst:120
#, fuzzy
msgid "Deforming the polygons"
msgstr "试试这个插件"

#: ../../docs/tutorials/animation/2d_skeletons.rst:122
msgid ""
"Select the previously created polygons and assign the skeleton node to their "
"``Skeleton`` property. This will ensure that they can eventually by deformed "
"by it."
msgstr ""

#: ../../docs/tutorials/animation/2d_skeletons.rst:126
msgid "Click the property highlighted above and select the skeleton node:"
msgstr ""

#: ../../docs/tutorials/animation/2d_skeletons.rst:130
msgid ""
"Again, open the UV editor for the polygon and go to the *Bones* section."
msgstr ""

#: ../../docs/tutorials/animation/2d_skeletons.rst:134
msgid ""
"You will not be able to paint weights yet. For this you need to synchronize "
"the list of bones from the skeleton with the polygon. This step is done only "
"once and manually (unless you modify the skeleton by adding/removing/"
"renaming bones). It ensures that your rigging information is kept in the "
"polygon, even if a skeleton node is accidentally lost or the skeleton "
"modified. Push the \"Sync Bones to Polygon\" button to sync the list."
msgstr ""

#: ../../docs/tutorials/animation/2d_skeletons.rst:140
msgid ""
"The list of bones will automatically appear. By default, your polygon has no "
"weight assigned to any of them. Select the bones you want to assign weight "
"to and paint them:"
msgstr ""

#: ../../docs/tutorials/animation/2d_skeletons.rst:145
msgid ""
"Points in white have a full weight assigned, while points in black are not "
"influenced by the bone. If the same point is painted white for multiple "
"bones, the influence will be distributed amongst them (so usually there is "
"not that much need to use shades in-between unless you want to polish the "
"bending effect)."
msgstr ""

#: ../../docs/tutorials/animation/2d_skeletons.rst:151
msgid ""
"After painting the weights, animating the bones (NOT the polygons!) will "
"have the desired effect of modifying and bending the polygons accordingly. "
"As you only need to animate bones in this approach, work becomes much easier!"
msgstr ""

#: ../../docs/tutorials/animation/2d_skeletons.rst:154
msgid ""
"But it's not all roses. Trying to animate bones that bend the polygon will "
"often yield unexpected results:"
msgstr ""

#: ../../docs/tutorials/animation/2d_skeletons.rst:158
msgid ""
"This happens because Godot generates internal triangles that connect the "
"points when drawing the polygon. They don't always bend the way you would "
"expect. To solve this, you need to set hints in the geometry to clarify how "
"you expect it to deform."
msgstr ""

#: ../../docs/tutorials/animation/2d_skeletons.rst:162
#, fuzzy
msgid "Internal vertices"
msgstr "内部资源"

#: ../../docs/tutorials/animation/2d_skeletons.rst:164
msgid ""
"Open the UV menu for each bone again and go to the *Points* section. Add "
"some internal vertices in the regions where you expect the geometry to bend:"
msgstr ""

#: ../../docs/tutorials/animation/2d_skeletons.rst:168
msgid ""
"Now, go to the *Polygon* section and redraw your own polygons with more "
"detail. Imagine that, as your polygons bend, you need to make sure they "
"deform the least possible, so experiment a bit to find the right setup."
msgstr ""

#: ../../docs/tutorials/animation/2d_skeletons.rst:173
msgid ""
"Once you start drawing, the original polygon will disappear and you will be "
"free to create your own:"
msgstr ""

#: ../../docs/tutorials/animation/2d_skeletons.rst:177
msgid ""
"This amount of detail is usually fine, though you may want to have more fine-"
"grained control over where triangles go. Experiment by yourself until you "
"get the results you like."
msgstr ""

#: ../../docs/tutorials/animation/2d_skeletons.rst:179
msgid ""
"**Note:** Don't forget that your newly added internal vertices also need "
"weight painting! Go to the *Bones* section again to assign them to the right "
"bones."
msgstr ""

#: ../../docs/tutorials/animation/2d_skeletons.rst:181
msgid "Once you are all set, you will get much better results:"
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:4
#, fuzzy
msgid "AnimationTree"
msgstr "动画"

#: ../../docs/tutorials/animation/animation_tree.rst:9
msgid ""
"With :ref:`AnimationPlayer <class_AnimationPlayer>`, Godot has one of the "
"most flexible animation systems that you can find in any game engine. The "
"ability to animate pretty much any property in any node or resource, as well "
"as having dedicated transform, bezier, function calling, audio and sub-"
"animation tracks, is pretty much unique."
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:13
msgid ""
"However, the support for blending those animations via ``AnimationPlayer`` "
"is relatively limited, as only a fixed cross-fade transition time can be set."
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:15
msgid ""
":ref:`AnimationTree <class_AnimationTree>` is a new node introduced in Godot "
"3.1 to deal with advanced transitions. It supersedes the ancient "
"``AnimationTreePlayer``, while adding a huge amount of features and "
"flexibility."
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:19
#, fuzzy
msgid "Creating an AnimationTree"
msgstr "创建动画"

#: ../../docs/tutorials/animation/animation_tree.rst:21
msgid ""
"Before starting, it must be made clear that an ``AnimationTree`` node does "
"not contain its own animations. Instead, it uses animations contained in an "
"``AnimationPlayer`` node. This way, you can edit your animations (or import "
"them from a 3D scene) as usual and then use this extra node to control the "
"playback."
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:25
msgid ""
"The most common way to use ``AnimationTree`` is in a 3D scene. When "
"importing your scenes from a 3D exchange format, they will usually come with "
"animations built-in (either multiple ones or split from a large one on "
"import). At the end, the imported Godot scene will contain the animations in "
"a ``AnimationPlayer`` node."
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:29
msgid ""
"As you rarely use imported scenes directly in Godot (they are either "
"instantiated or inherited from), you can place the ``AnimationTree`` node in "
"your new scene which contains the imported one. Afterwards, point the "
"``AnimationTree`` node to the ``AnimationPlayer`` that was created in the "
"imported scene."
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:32
msgid ""
"This is how it's done in the `Third Person Shooter demo <https://github.com/"
"godotengine/tps-demo>`_, for reference:"
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:36
msgid ""
"A new scene was created for the player with a ``KinematicBody`` as root. "
"Inside this scene, the original ``.dae`` (Collada) file was instantiated and "
"an ``AnimationTree`` node was created."
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:40
#, fuzzy
msgid "Creating a tree"
msgstr "创建主题"

#: ../../docs/tutorials/animation/animation_tree.rst:42
msgid ""
"There are three main types of nodes that can be used in ``AnimationTree``:"
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:44
msgid ""
"Animation nodes, which reference an animation from the linked "
"``AnimationTree``."
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:45
msgid "Animation Root nodes, which are used to blend sub-nodes."
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:46
msgid ""
"Animation Blend nodes, which are used within ``AnimationNodeBlendTree`` as "
"single-graph blending via multiple input ports."
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:48
msgid "To set a root node in ``AnimationTree``, a few types are available:"
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:52
msgid ""
"``AnimationNodeAnimation``: Selects an animation from the list and plays it. "
"This is the simplest root node, and generally not used directly as root."
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:53
msgid ""
"``AnimationNodeBlendTree``: Contains many *blend* type nodes, such as mix, "
"blend2, blend3, one shot, etc. This is one of the most commonly used roots."
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:54
msgid ""
"``AnimationNodeStateMachine``: Contains multiple root nodes as children in a "
"graph. Each node is used as a *state*, and provides multiple functions to "
"alternate between states."
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:55
msgid ""
"``AnimationNodeBlendSpace2D``: Allows placing root nodes in a 2D blend "
"space. Control the blend position in 2D to mix between multiple animations."
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:56
msgid "``AnimationNodeBlendSpace1D``: Simplified version of the above (1D)."
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:59
#, fuzzy
msgid "Blend tree"
msgstr "混合模式"

#: ../../docs/tutorials/animation/animation_tree.rst:61
msgid ""
"An ``AnimationNodeBlendTree`` can contain both root and regular nodes used "
"for blending. Nodes are added to the graph from a menu:"
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:65
msgid ""
"All blend trees contain an ``Output`` node by default, and something has to "
"be connected to it in order for animations to play."
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:67
msgid ""
"The easiest way to test this functionality is to connect an ``Animation`` "
"node to it directly:"
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:71
msgid ""
"This will simply play back the animation. Make sure that the "
"``AnimationTree`` is active for something to actually happen."
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:73
#, fuzzy
msgid "Following is a short description of available nodes:"
msgstr "以下是可用效果的简短描述:"

#: ../../docs/tutorials/animation/animation_tree.rst:76
msgid "Blend2 / Blend3"
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:78
msgid ""
"These nodes will blend between two or three inputs by a user-specified blend "
"value:"
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:82
msgid "For more complex blending, it is advised to use blend spaces instead."
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:84
msgid ""
"Blending can also use filters, i.e. you can control individually which "
"tracks go through the blend function. This is very useful for layering "
"animations on top of each other."
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:90
#, fuzzy
msgid "OneShot"
msgstr "一发"

#: ../../docs/tutorials/animation/animation_tree.rst:92
msgid ""
"This node will execute a sub-animation and return once it finishes. Blend "
"times for fading in and out can be customized, as well as filters."
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:97
msgid "Seek"
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:99
msgid ""
"This node can be used to cause a seek command to happen to any sub-children "
"of the graph. After setting the time, this value returns to -1."
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:102
#, fuzzy
msgid "TimeScale"
msgstr "规模"

#: ../../docs/tutorials/animation/animation_tree.rst:104
msgid ""
"Allows scaling the speed of the animation (or reverse it) in any children "
"nodes. Setting it to 0 will pause the animation."
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:107
#, fuzzy
msgid "Transition"
msgstr "平移"

#: ../../docs/tutorials/animation/animation_tree.rst:109
msgid ""
"Very simple state machine (when you don't want to cope with a "
"``StateMachine`` node). Animations can be connected to the outputs and "
"transition times can be specified."
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:112
msgid "BlendSpace2D"
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:114
msgid ""
"``BlendSpace2D`` is a node to do advanced blending in two dimensions. Points "
"are added to a two dimensional space and then a position can be controlled "
"to determine blending:"
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:119
msgid ""
"The ranges in X and Y can be controlled (and labeled for convenience). By "
"default, points can be placed anywhere (just right-click on the coordinate "
"system or use the *add point* button) and triangles will be generated "
"automatically using Delaunay."
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:124
msgid ""
"It is also possible to draw the triangles manually by disabling the *auto "
"triangle* option, though this is rarely necessary:"
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:128
msgid ""
"Finally, it is possible to change the blend mode. By default, blending "
"happens by interpolating points inside the closest triangle. When dealing "
"with 2D animations (frame by frame), you may want to switch to *Discrete* "
"mode. Alternatively, if you want to keep the current play position when "
"switching between discrete animations, there is a *Carry* mode. This mode "
"can be changed in the *Blend* menu:"
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:136
msgid "BlendSpace1D"
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:138
msgid ""
"This is similar to 2D blend spaces, but in one dimension (so triangles are "
"not needed)."
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:141
#, fuzzy
msgid "StateMachine"
msgstr "搜索"

#: ../../docs/tutorials/animation/animation_tree.rst:143
msgid ""
"This node is a relatively simple state machine. Root nodes can be created "
"and connected via lines. States are connected via *Transitions*, which are "
"connections with special properties. Transitions are uni-directional, but "
"two can be used to connect in both ways."
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:148
#, fuzzy
msgid "There are many types of transitions:"
msgstr "过渡的类型"

#: ../../docs/tutorials/animation/animation_tree.rst:152
msgid ""
"*Immeditate*: Will switch to the next state immediately. The current state "
"will end and blend into the beginning of the new one."
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:153
msgid ""
"*Sync*: Will switch to the next state immediately, but will seek the new "
"state to the playback position of the old state."
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:154
msgid ""
"*At End*: Will wait for the current state playback to end, then switch to "
"the beginning of the next state animation."
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:156
msgid ""
"Transitions also have a few properties. Click any transition and it will be "
"displayed in the inspector dock:"
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:160
msgid ""
"*Switch Mode* is the transition type (see above), it can be modified after "
"creation here."
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:161
msgid ""
"*Auto Advance* will turn on the transition automatically when this state is "
"reached. This works best with the *At End* switch mode."
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:162
msgid ""
"*Advance Condition* will turn on auto advance when this condition is set. "
"This is a custom text field that can be filled with a variable name. The "
"variable can be modified from code (more on this later)."
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:164
msgid "*Xfade Time* is the time to cross-fade between this state and the next."
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:165
msgid ""
"*Priority* is used together with the ``travel()`` function from code (more "
"on this later). When travelling from a state to another, give more priority "
"to this node."
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:166
msgid ""
"*Disabled* allows to disable this transition (it will not be used during "
"travel or auto advance)."
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:170
#, fuzzy
msgid "Root motion"
msgstr "旋转"

#: ../../docs/tutorials/animation/animation_tree.rst:172
msgid ""
"When working with 3D animations, a popular technique is for animators to use "
"the root skeleton bone to give motion to the rest of the skeleton. This "
"allows animating characters in a way where steps actually match the floor "
"below. It also allows precise interaction with objects during cinematics."
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:175
msgid ""
"When playing back the animation in Godot, it is possible to select this bone "
"as the *root motion track*. Doing so will cancel the bone transformation "
"visually (the animation will stay in place)."
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:180
msgid ""
"Afterwards, the actual motion can be retrieved via the :ref:`AnimationTree "
"<class_AnimationTree>` API as a transform:"
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:191
msgid ""
"This can be fed to functions such as :ref:`KinematicBody.move_and_slide "
"<class_KinematicBody_method_move_and_slide>` to control the character "
"movement."
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:193
msgid ""
"There is also a tool node, ``RootMotionView``, that can be placed in a scene "
"and will act as a custom floor for your character and animations (this node "
"is normally disabled during the game)."
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:200
#, fuzzy
msgid "Controlling from code"
msgstr "贡献代码"

#: ../../docs/tutorials/animation/animation_tree.rst:202
msgid ""
"After building the tree and previewing it, the only question remaining is "
"\"How is all this controlled from code?\"."
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:204
msgid ""
"Keep in mind that the animation nodes are just resources and, as such, they "
"are shared between all the instances. Setting values in the nodes directly "
"will affect all instances of the scene that uses this ``AnimationTree``. "
"This has some cool use cases, though, e.g. you can copy and paste parts of "
"your animation tree, or reuse nodes with a complex layout (such as a state "
"machine or blend space) in different animation trees."
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:209
msgid ""
"The actual animation data is contained in the ``AnimationTree`` node and is "
"accessed via properties. Check the \"Parameters\" section of the "
"``AnimationTree`` node to see all the parameters that can be modified in "
"real-time:"
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:214
msgid ""
"This is handy because it makes it possible to animate them from an "
"``AnimationPlayer``, or even the ``AnimationTree`` itself, allowing the "
"realisation of very complex animation logic."
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:217
msgid ""
"To modify these values from code, the property path must be obtained. This "
"is done easily by hovering the mouse over any of the parameters:"
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:221
msgid "Which allows setting them or reading them:"
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:236
msgid "State machine travel"
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:238
msgid ""
"One of the nice features in Godot's ``StateMachine`` implementation is the "
"ability to travel. The graph can be instructed to go from the current state "
"to another one, while visiting all the intermediate ones. This is done via "
"the A\\* algorithm."
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:241
msgid ""
"To use the travel ability, you should first retrieve the :ref:"
"`AnimationNodeStateMachinePlayback "
"<class_AnimationNodeStateMachinePlayback>` object from the ``AnimationTree`` "
"node (it is exported as a property)."
msgstr ""

#: ../../docs/tutorials/animation/animation_tree.rst:254
msgid ""
"Once retrieved, it can be used by calling one of the many functions it "
"offers:"
msgstr ""

#: ../../docs/tutorials/inputs/index.rst:2
msgid "Inputs"
msgstr "输入"

#: ../../docs/tutorials/inputs/inputevent.rst:4
msgid "InputEvent"
msgstr "InputEvent"

#: ../../docs/tutorials/inputs/inputevent.rst:9
msgid ""
"Managing input is usually complex, no matter the OS or platform. To ease "
"this a little, a special built-in type is provided, :ref:`InputEvent "
"<class_InputEvent>`. This datatype can be configured to contain several "
"types of input events. Input events travel through the engine and can be "
"received in multiple locations, depending on the purpose."
msgstr ""
"无论是在操作系统或平台上, 管理输入通常很复杂。为了简化输入管理，引擎提供了一"
"个特殊的内置类型 :ref:`InputEvent <class_InputEvent>`。此类型可被设置成包含多"
"种类型的输入事件。输入事件通过引擎传递，可在多个位置接收，具体位置取决于目"
"的。"

#: ../../docs/tutorials/inputs/inputevent.rst:15
msgid "Here is a quick example, closing your game if the escape key is hit:"
msgstr "这里有一个简单的示例，如果Esc键被击中时关闭您的游戏:"

#: ../../docs/tutorials/inputs/inputevent.rst:34
msgid ""
"However, it is cleaner and more flexible to use the provided :ref:`InputMap "
"<class_InputMap>` feature, which allows you to define input actions and "
"assign them different keys. This way, you can define multiple keys for the "
"same action (e.g. they keyboard escape key and the start button on a "
"gamepad). You can then more easily change this mapping in the project "
"settings without updating your code, and even build a key mapping feature on "
"top of it to allow your game to change the key mapping at runtime!"
msgstr ""
"但是，使用引擎提供的 :ref:`InputMap <class_InputMap>` 将更简洁、更灵活，它允"
"许自定义输入操作并为它们分配不同的按键。这样，您可以为同一个动作定义多个键(例"
"如键盘escape键和手柄上的开始按钮)。然后您可以很容易地在项目设置中更改这个映"
"射，而无需更新您的代码，甚至可以在它之上构建一个键映射特性，以允许您的游戏在"
"运行时更改键映射!"

#: ../../docs/tutorials/inputs/inputevent.rst:40
msgid ""
"You can setup your InputMap under **Project > Project Settings > Input Map** "
"and then use those actions like this:"
msgstr ""
"您可以在 **Project > Project Settings > Input Map** 下设置InputMap，然后像这"
"样使用这些操作:"

#: ../../docs/tutorials/inputs/inputevent.rst:60
msgid "How does it work?"
msgstr "它的工作原理是什么?"

#: ../../docs/tutorials/inputs/inputevent.rst:62
msgid ""
"Every input event is originated from the user/player (though it's possible "
"to generate an InputEvent and feed them back to the engine, which is useful "
"for gestures). The OS object for each platform will read events from the "
"device, then feed them to MainLoop. As :ref:`SceneTree <class_SceneTree>` is "
"the default MainLoop implementation, events are fed to it. Godot provides a "
"function to get the current SceneTree object : **get_tree()**."
msgstr ""
"每个输入事件都来源于用户/游戏角色(尽管可以生成一个InputEvent并将其反馈给引"
"擎，这在手势操作中非常有用)。每个平台的操作对象都将从设备读取事件，然后将它们"
"发送到MainLoop。因为 :ref:`SceneTree <class_SceneTree>` 是默认的主循环实现，"
"所以事件被提交给它。Godot提供了一个获取当前SceneTree对象的函数 : "
"**get_tree()**。"

#: ../../docs/tutorials/inputs/inputevent.rst:70
msgid ""
"But SceneTree does not know what to do with the event, so it will give it to "
"the viewports, starting by the \"root\" :ref:`Viewport <class_Viewport>` "
"(the first node of the scene tree). Viewport does quite a lot of stuff with "
"the received input, in order:"
msgstr ""
"但是SceneTree不知道如何处理这个事件，所以SceneTree把它交给视区，从\"根\" :"
"ref:`Viewport <class_Viewport>` (场景树的第一个节点)开始查找。Viewport对接收"
"到的输入做了很多事情，顺序如下:"

#: ../../docs/tutorials/inputs/inputevent.rst:77
msgid ""
"First of all, the standard :ref:`Node._input() <class_Node_method__input>` "
"function will be called in any node that overrides it (and hasn't disabled "
"input processing with :ref:`Node.set_process_input() "
"<class_Node_method_set_process_input>`). If any function consumes the event, "
"it can call :ref:`SceneTree.set_input_as_handled() "
"<class_SceneTree_method_set_input_as_handled>`, and the event will not "
"spread any more. This ensures that you can filter all events of interest, "
"even before the GUI. For gameplay input, :ref:`Node._unhandled_input() "
"<class_Node_method__unhandled_input>` is generally a better fit, because it "
"allows the GUI to intercept the events."
msgstr ""
"首先，标准 :ref:`Node._input() <class_Node_method__input>` 函数将在任何覆写它"
"的节点中被调用(没有使用 :ref:`Node.set_process_input() "
"<class_Node_method_set_process_input>` 来禁用输入处理 )。 如果任何函数消耗了"
"该输入事件，它可以调用 :ref:`SceneTree.set_input_as_handled() "
"<class_SceneTree_method_set_input_as_handled>` ，该事件将不再传播。 这可确保"
"您可以在GUI之前过滤所有感兴趣的事件。 在游戏输入中， :ref:`Node."
"_unhandled_input() <class_Node_method__unhandled_input>` 通常更合适，因为它允"
"许GUI侦听。"

#: ../../docs/tutorials/inputs/inputevent.rst:82
msgid ""
"Second, it will try to feed the input to the GUI, and see if any control can "
"receive it. If so, the :ref:`Control <class_Control>` will be called via the "
"virtual function :ref:`Control._gui_input() "
"<class_Control_method__gui_input>` and the signal \"input_event\" will be "
"emitted (this function is re-implementable by script by inheriting from it). "
"If the control wants to \"consume\" the event, it will call :ref:`Control."
"accept_event() <class_Control_method_accept_event>` and the event will not "
"spread any more. Use the :ref:`Control.mouse_filter "
"<class_Control_property_mouse_filter>` property to control whether a :ref:"
"`Control <class_Control>` is notified of mouse events via :ref:`Control."
"_gui_input() <class_Control_method__gui_input>` callback, and whether these "
"events are propagated further."
msgstr ""
"然后，它会尝试将输入提供给GUI，并查看是否有任何控件可以接收它。 如果是这"
"样， :ref:`Control <class_Control>` 将通过虚函数 :ref:`Control._gui_input() "
"<class_Control_method__gui_input>` 被调用并发出信号 “input_event”(此函数可通"
"过以下方式重新实现: 脚本继承自它)。 如果控件想“消耗”该事件，它将调用 :ref:"
"`Control.accept_event()<class_Control_method_accept_event>` 使得该事件不再传"
"播。 使用 :ref:`Control.mouse_filter <class_Control_property_mouse_filter>` "
"属性来控制是否 :ref:`Control <class_Control>` 通过以下方式通知鼠标事件 :ref:"
"`Control._gui_input()<class_Control_method__gui_input>` 回调，以及是否这些事"
"件进一步传播。"

#: ../../docs/tutorials/inputs/inputevent.rst:92
msgid ""
"If so far no one consumed the event, the unhandled input callback will be "
"called if overridden (and not disabled with :ref:`Node."
"set_process_unhandled_input() "
"<class_Node_method_set_process_unhandled_input>`). If any function consumes "
"the event, it can call :ref:`SceneTree.set_input_as_handled() "
"<class_SceneTree_method_set_input_as_handled>`, and the event will not "
"spread any more. The unhandled input callback is ideal for full-screen "
"gameplay events, so they are not received when a GUI is active."
msgstr ""
"如果到目前为止没有函数消耗该事件，则在被覆盖时将调用未处理的输入回调(并且未使"
"用以下命令禁用 :ref:`Node."
"set_process_unhandled_input()<class_Node_method_set_process_unhandled_input>`)。 "
"如果任何函数使用该事件，它可以调用 :ref:`SceneTree."
"set_input_as_handled()<class_SceneTree_method_set_input_as_handled>`，该事件"
"将不再传播。 未处理的输入回调是全屏游戏事件的理想选择，因此当GUI处于活动状态"
"时不会收到它们。"

#: ../../docs/tutorials/inputs/inputevent.rst:97
msgid ""
"If no one wanted the event so far, and a :ref:`Camera <class_Camera>` is "
"assigned to the Viewport, a ray to the physics world (in the ray direction "
"from the click) will be cast. If this ray hits an object, it will call the :"
"ref:`CollisionObject._input_event() "
"<class_CollisionObject_method__input_event>` function in the relevant "
"physics object (bodies receive this callback by default, but areas do not. "
"This can be configured through :ref:`Area <class_Area>` properties)."
msgstr ""
"如果到目前为止没有人想要这个事件，并且一个 :ref:`Camera <class_Camera>` 被分"
"配给视区，将投射到物理世界的光线(从点击的光线方向)。 如果此光线击中一个对象，"
"它将调用相关物理对象中的 :ref:`CollisionObject._input_event() "
"<class_CollisionObject_method__input_event>` 函数(默认情况下，物体接收此回"
"调，区域不会接受。这可以通过以下方式配置 :ref :`Area <class_Area>` 属性)。"

#: ../../docs/tutorials/inputs/inputevent.rst:103
msgid ""
"Finally, if the event was unhandled, it will be passed to the next Viewport "
"in the tree, otherwise it will be ignored."
msgstr "最后，如果事件未被处理，它将被传递到树的下一个视区中，否则将被忽略。"

#: ../../docs/tutorials/inputs/inputevent.rst:106
msgid ""
"When sending events to all listening nodes within a scene, the viewport will "
"do so in a reverse depth-first order: Starting with the node at the bottom "
"of the scene tree, and ending at the root node:"
msgstr ""
"将事件发送到场景中的所有侦听节点时，视区将以反向深度优先顺序执行:从场景树底部"
"的节点开始，到根节点结束:"

#: ../../docs/tutorials/inputs/inputevent.rst:112
msgid ""
"GUI events also travel up the scene tree but, since these events target "
"specific Controls, only direct ancestors of the targeted Control node "
"receive the event."
msgstr ""
"GUI事件也沿着场景树进行的，但由于这些事件以特定控件为目标，因此只有目标控制节"
"点的父辈节点才会接收事件。"

#: ../../docs/tutorials/inputs/inputevent.rst:115
msgid ""
"In accordance with Godot's node-based design, this enables specialized child "
"nodes to handle and consume particular events, while their ancestors, and "
"ultimately the scene root, can provide more generalized behaviour if needed."
msgstr ""
"根据Godot基于节点的设计，这使得专门的子节点能够处理和消费特定事件，而他们的祖"
"先，以及最终的场景根，可以在需要时提供更广泛的行为。"

#: ../../docs/tutorials/inputs/inputevent.rst:121
msgid "Anatomy of an InputEvent"
msgstr "InputEvent剖析"

#: ../../docs/tutorials/inputs/inputevent.rst:123
msgid ""
":ref:`InputEvent <class_InputEvent>` is just a base built-in type, it does "
"not represent anything and only contains some basic information, such as "
"event ID (which is increased for each event), device index, etc."
msgstr ""
":ref:`InputEvent <class_InputEvent>` 只是一个基本的内置类型，它不代表任何东"
"西，只包含一些基本信息，如事件ID(每个事件增加)，设备索引等。"

#: ../../docs/tutorials/inputs/inputevent.rst:127
msgid ""
"There are several specialised types of InputEvent, described in the table "
"below:"
msgstr "有几种特殊类型的InputEvent，如下表所示:"

#: ../../docs/tutorials/inputs/inputevent.rst:130
msgid "Event"
msgstr "事件"

#: ../../docs/tutorials/inputs/inputevent.rst:130
msgid "Type Index"
msgstr "类型索引"

#: ../../docs/tutorials/inputs/inputevent.rst:132
msgid ":ref:`InputEvent <class_InputEvent>`"
msgstr ":ref:`InputEvent <class_InputEvent>`"

#: ../../docs/tutorials/inputs/inputevent.rst:132
msgid "NONE"
msgstr "NONE"

#: ../../docs/tutorials/inputs/inputevent.rst:132
msgid "Empty Input Event."
msgstr "空输入事件。"

#: ../../docs/tutorials/inputs/inputevent.rst:134
msgid ":ref:`InputEventKey <class_InputEventKey>`"
msgstr ":ref:`InputEventKey <class_InputEventKey>`"

#: ../../docs/tutorials/inputs/inputevent.rst:134
msgid "KEY"
msgstr "KEY"

#: ../../docs/tutorials/inputs/inputevent.rst:134
msgid "Contains a scancode and unicode value, as well as modifiers."
msgstr "包含扫描码和unicode值，以及修饰符。"

#: ../../docs/tutorials/inputs/inputevent.rst:137
msgid ":ref:`InputEventMouseButton <class_InputEventMouseButton>`"
msgstr ":ref:`InputEventMouseButton <class_InputEventMouseButton>`"

#: ../../docs/tutorials/inputs/inputevent.rst:137
msgid "MOUSE_BUTTON"
msgstr "MOUSE_BUTTON"

#: ../../docs/tutorials/inputs/inputevent.rst:137
msgid "Contains click information, such as button, modifiers, etc."
msgstr "包含点击信息，例如按钮，修改器等。"

#: ../../docs/tutorials/inputs/inputevent.rst:140
msgid ":ref:`InputEventMouseMotion <class_InputEventMouseMotion>`"
msgstr ":ref:`InputEventMouseMotion <class_InputEventMouseMotion>`"

#: ../../docs/tutorials/inputs/inputevent.rst:140
msgid "MOUSE_MOTION"
msgstr "MOUSE_MOTION"

#: ../../docs/tutorials/inputs/inputevent.rst:140
msgid ""
"Contains motion information, such as relative, absolute positions and speed."
msgstr "包含运动信息，例如相对位置，绝对位置和速度。"

#: ../../docs/tutorials/inputs/inputevent.rst:143
msgid ":ref:`InputEventJoypadMotion <class_InputEventJoypadMotion>`"
msgstr ":ref:`InputEventJoypadMotion <class_InputEventJoypadMotion>`"

#: ../../docs/tutorials/inputs/inputevent.rst:143
msgid "JOYSTICK_MOTION"
msgstr "JOYSTICK_MOTION"

#: ../../docs/tutorials/inputs/inputevent.rst:143
msgid "Contains Joystick/Joypad analog axis information."
msgstr "包含操纵杆/ Joypad模拟轴信息。"

#: ../../docs/tutorials/inputs/inputevent.rst:146
msgid ":ref:`InputEventJoypadButton <class_InputEventJoypadButton>`"
msgstr ":ref:`InputEventJoypadButton <class_InputEventJoypadButton>`"

#: ../../docs/tutorials/inputs/inputevent.rst:146
msgid "JOYSTICK_BUTTON"
msgstr "JOYSTICK_BUTTON"

#: ../../docs/tutorials/inputs/inputevent.rst:146
msgid "Contains Joystick/Joypad button information."
msgstr "包含操纵杆/ Joypad按钮信息。"

#: ../../docs/tutorials/inputs/inputevent.rst:149
msgid ":ref:`InputEventScreenTouch <class_InputEventScreenTouch>`"
msgstr ":ref:`InputEventScreenTouch <class_InputEventScreenTouch>`"

#: ../../docs/tutorials/inputs/inputevent.rst:149
msgid "SCREEN_TOUCH"
msgstr "SCREEN_TOUCH"

#: ../../docs/tutorials/inputs/inputevent.rst:149
msgid ""
"Contains multi-touch press/release information. (only available on mobile "
"devices)"
msgstr "包含多点触控按下/释放信息。 (仅适用于移动设备)"

#: ../../docs/tutorials/inputs/inputevent.rst:153
msgid ":ref:`InputEventScreenDrag <class_InputEventScreenDrag>`"
msgstr ":ref:`InputEventScreenDrag <class_InputEventScreenDrag>`"

#: ../../docs/tutorials/inputs/inputevent.rst:153
msgid "SCREEN_DRAG"
msgstr "SCREEN_DRAG"

#: ../../docs/tutorials/inputs/inputevent.rst:153
msgid ""
"Contains multi-touch drag information. (only available on mobile devices)"
msgstr "包含多点触控拖动信息。 (仅适用于移动设备)"

#: ../../docs/tutorials/inputs/inputevent.rst:156
msgid ":ref:`InputEventAction <class_InputEventAction>`"
msgstr ":ref:`InputEventAction <class_InputEventAction>`"

#: ../../docs/tutorials/inputs/inputevent.rst:156
msgid "SCREEN_ACTION"
msgstr "SCREEN_ACTION"

#: ../../docs/tutorials/inputs/inputevent.rst:156
msgid ""
"Contains a generic action. These events are often generated by the "
"programmer as feedback. (more on this below)"
msgstr "包含一般动作。 这些事件通常由程序员作为反馈生成。 (以下更多内容)"

#: ../../docs/tutorials/inputs/inputevent.rst:162
msgid "Actions"
msgstr "Actions"

#: ../../docs/tutorials/inputs/inputevent.rst:164
msgid ""
"An InputEvent may or may not represent a pre-defined action. Actions are "
"useful because they abstract the input device when programming the game "
"logic. This allows for:"
msgstr ""
"InputEvent可能代表也可能不代表预定义的动作。 动作很有用，因为它们在编写游戏逻"
"辑时抽象输入设备。 这允许:"

#: ../../docs/tutorials/inputs/inputevent.rst:168
msgid ""
"The same code to work on different devices with different inputs (e.g., "
"keyboard on PC, Joypad on console)."
msgstr ""
"相同的代码可以在具有不同输入的不同设备上工作(例如，PC上的键盘，控制台上的"
"Joypad)。"

#: ../../docs/tutorials/inputs/inputevent.rst:170
msgid "Input to be reconfigured at run-time."
msgstr "输入要在运行时重新配置。"

#: ../../docs/tutorials/inputs/inputevent.rst:172
msgid ""
"Actions can be created from the Project Settings menu in the Actions tab."
msgstr "可以从“操作”选项卡的“项目设置”菜单中创建操作。"

#: ../../docs/tutorials/inputs/inputevent.rst:175
#, fuzzy
msgid ""
"Any event has the methods :ref:`InputEvent.is_action() "
"<class_InputEvent_method_is_action>`, :ref:`InputEvent.is_pressed() "
"<class_InputEvent_method_is_pressed>` and :ref:`InputEvent "
"<class_InputEvent>`."
msgstr ""
"任何事件都有以下方法 :ref:`InputEvent.is_action() "
"<class_InputEvent_method_is_action>`, :ref:`InputEvent.is_pressed() "
"<class_InputEvent_is_pressed>` 和 :ref:`InputEvent <class_InputEvent>`。"

#: ../../docs/tutorials/inputs/inputevent.rst:178
#, fuzzy
msgid ""
"Alternatively, it may be desired to supply the game back with an action from "
"the game code (a good example of this is detecting gestures). The Input "
"singleton has a method for this: :ref:`Input.parse_input_event() "
"<class_input_method_parse_input_event>`. You would normally use it like this:"
msgstr ""
"或者，您可能希望向游戏提供来自游戏代码的动作(例如检测手势)。 Input单例有一个"
"方法: :ref:`Input."
"parse_input_event()<class_input_method_parse_input_event>` 。 您通常会这样使"
"用它:"

#: ../../docs/tutorials/inputs/inputevent.rst:202
msgid "InputMap"
msgstr "InputMap"

#: ../../docs/tutorials/inputs/inputevent.rst:204
msgid ""
"Customizing and re-mapping input from code is often desired. If your whole "
"workflow depends on actions, the :ref:`InputMap <class_InputMap>` singleton "
"is ideal for reassigning or creating different actions at run-time. This "
"singleton is not saved (must be modified manually) and its state is run from "
"the project settings (project.godot). So any dynamic system of this type "
"needs to store settings in the way the programmer best sees fit."
msgstr ""
"通常需要通过代码定制和重新映射输入。 如果整个工作流程依赖于行为， :ref:"
"`InputMap <class_InputMap>` 单例非常适合在运行时重新分配或创建不同的行为。 此"
"单例不会保存(必须手动修改)，其状态从项目设置(project.godot)运行。 因此，这种"
"类型的动态系统需要以程序员最适合的方式存储设置。"

#: ../../docs/tutorials/inputs/mouse_and_input_coordinates.rst:4
msgid "Mouse and input coordinates"
msgstr "鼠标和输入坐标"

#: ../../docs/tutorials/inputs/mouse_and_input_coordinates.rst:9
msgid ""
"The reason for this small tutorial is to clear up many common mistakes about "
"input coordinates, obtaining mouse position and screen resolution, etc."
msgstr ""
"这个小教程的目的是为了清除许多关于输入坐标、获取鼠标位置和屏幕分辨率等常见错"
"误。"

#: ../../docs/tutorials/inputs/mouse_and_input_coordinates.rst:14
msgid "Hardware display coordinates"
msgstr "硬件显示坐标"

#: ../../docs/tutorials/inputs/mouse_and_input_coordinates.rst:16
#, fuzzy
msgid ""
"Using hardware coordinates makes sense in the case of writing complex UIs "
"meant to run on PC, such as editors, MMOs, tools, etc. However, it does not "
"make as much sense outside of that scope."
msgstr ""
"在编写用于在PC上运行的复杂用户界面(如编辑器、MMOs、工具等)时，使用硬件坐标是"
"有意义的。但是，在这个范围之外，使用硬件坐标并没有多大意义。"

#: ../../docs/tutorials/inputs/mouse_and_input_coordinates.rst:21
msgid "Viewport display coordinates"
msgstr "视区显示坐标"

#: ../../docs/tutorials/inputs/mouse_and_input_coordinates.rst:23
msgid ""
"Godot uses viewports to display content, and viewports can be scaled by "
"several options (see :ref:`doc_multiple_resolutions` tutorial). Use, then, "
"the functions in nodes to obtain the mouse coordinates and viewport size, "
"for example:"
msgstr ""
"Godot使用视区显示内容，并且视区可以通过几个选项进行缩放(参见 :ref:"
"`doc_multiple_resolutions` 教程)。然后，使用节点中的函数来获得鼠标坐标和视区"
"大小，例如:"

#: ../../docs/tutorials/inputs/mouse_and_input_coordinates.rst:55
#, fuzzy
msgid ""
"Alternatively, it's possible to ask the viewport for the mouse position:"
msgstr "或者，也可以询问视区的鼠标位置:"

#: ../../docs/tutorials/inputs/mouse_and_input_coordinates.rst:66
msgid ""
"When the mouse mode is set to ``Input.MOUSE_MODE_CAPTURED``, the ``event."
"position`` value from ``InputEventMouseMotion`` is the center of the screen. "
"Use ``event.relative`` instead of ``event.position`` to process mouse "
"movement and position changes."
msgstr ""

#: ../../docs/tutorials/inputs/custom_mouse_cursor.rst:4
msgid "Customizing mouse cursor"
msgstr "自定义鼠标光标"

#: ../../docs/tutorials/inputs/custom_mouse_cursor.rst:6
msgid ""
"You might want to change the appearance of the mouse cursor in your game in "
"order to suit the overall design. There are two ways to customize the mouse "
"cursor:"
msgstr ""
"您可能希望更改游戏中鼠标光标的外观，以便适应总体设计。自定义鼠标光标有两种方"
"法:"

#: ../../docs/tutorials/inputs/custom_mouse_cursor.rst:8
#: ../../docs/tutorials/inputs/custom_mouse_cursor.rst:14
msgid "Using project settings"
msgstr "使用项目设置"

#: ../../docs/tutorials/inputs/custom_mouse_cursor.rst:9
#: ../../docs/tutorials/inputs/custom_mouse_cursor.rst:26
msgid "Using a script"
msgstr "使用脚本"

#: ../../docs/tutorials/inputs/custom_mouse_cursor.rst:11
#, fuzzy
msgid ""
"Using project settings is a simpler (but more limited) way to customize the "
"mouse cursor. The second way is more customizable, but involves scripting."
msgstr ""
"使用项目设置是自定义鼠标光标的更简单但是更有限的方法。第二种方式更具可定制"
"性，但涉及脚本编写。"

#: ../../docs/tutorials/inputs/custom_mouse_cursor.rst:16
msgid ""
"Open project settings, go to Display>Mouse Cursor. You will see Custom Image "
"and Custom Image Hotspot."
msgstr ""
"打开项目设置，转到 Display>Mouse Cursor。您将看到自定义图像和自定义图像热点。"

#: ../../docs/tutorials/inputs/custom_mouse_cursor.rst:20
msgid ""
"Custom Image is the desired image that you would like to set as the mouse "
"cursor. Custom Hotspot is the point in the image that you would like to use "
"as the cursor's detection point."
msgstr ""
"自定义图像是希望设置为鼠标光标的图像。自定义热点是图像中的点，您希望将其用作"
"光标的检测点。"

#: ../../docs/tutorials/inputs/custom_mouse_cursor.rst:23
msgid "The custom image **must** be less than 256x256."
msgstr "自定义图像 **必须** 小于256x256。"

#: ../../docs/tutorials/inputs/custom_mouse_cursor.rst:28
msgid "Create a Node and attach the following script."
msgstr "创建一个节点并附加下面的脚本。"

#: ../../docs/tutorials/inputs/custom_mouse_cursor.rst:64
#, fuzzy
msgid ""
"Check :ref:`Input.set_custom_mouse_cursor() "
"<class_Input_method_set_custom_mouse_cursor>`."
msgstr ""
"检查 :ref:`Input.set_custom_mouse_cursor() "
"<class_Input_method_set_custom_mouse_cursor>`。"

#: ../../docs/tutorials/inputs/custom_mouse_cursor.rst:68
msgid "Demo project"
msgstr "演示项目"

#: ../../docs/tutorials/inputs/custom_mouse_cursor.rst:70
msgid ""
"Find out more by studying this demo project: https://github.com/"
"guilhermefelipecgs/custom_hardware_cursor"
msgstr ""
"通过研究这个演示项目了解更多信息:https://github.com/guilhermefelipecgs/"
"custom_hardware_cursor"

#: ../../docs/tutorials/inputs/custom_mouse_cursor.rst:74
msgid "Cursor list"
msgstr "光标列表"

#: ../../docs/tutorials/inputs/custom_mouse_cursor.rst:76
msgid ""
"As documented in the :ref:`Input <class_Input>` class (see the "
"**CursorShape** enum), there are multiple mouse cursors you can define. "
"Which ones you want to use depends on your use case."
msgstr ""
"正如 :ref:`Input <class_Input>` 类(参见 **CursorShape** enum)中所述，可以定义"
"多个鼠标光标。您想要使用哪一个取决于您的用例。"

#: ../../docs/tutorials/io/index.rst:2
msgid "I/O"
msgstr "I/O"

#: ../../docs/tutorials/io/background_loading.rst:4
msgid "Background loading"
msgstr "后台加载"

#: ../../docs/tutorials/io/background_loading.rst:6
msgid ""
"When switching the main scene of your game (e.g. going to a new level), you "
"might want to show a loading screen with some indication that progress is "
"being made. The main load method (``ResourceLoader::load`` or just ``load`` "
"from GDScript) blocks your thread while the resource is being loaded, so "
"it's not good. This document discusses the ``ResourceInteractiveLoader`` "
"class for smoother load screens."
msgstr ""
"当您切换游戏的主场景时(例如切换到一个新关卡)，您可能想创建一个可以显示进度的"
"加载界面。常用的加载方法( ``ResourceLoader::load`` 或GDScript的 ``load``)会在"
"加载资源时阻塞线程，因此不被采用。本文将讨论用于平滑加载的 "
"``ResourceInteractiveLoader`` 类。"

#: ../../docs/tutorials/io/background_loading.rst:15
msgid "ResourceInteractiveLoader"
msgstr "ResourceInteractiveLoader"

#: ../../docs/tutorials/io/background_loading.rst:17
msgid ""
"The ``ResourceInteractiveLoader`` class allows you to load a resource in "
"stages. Every time the method ``poll`` is called, a new stage is loaded, and "
"control is returned to the caller. Each stage is generally a sub-resource "
"that is loaded by the main resource. For example, if you're loading a scene "
"that loads 10 images, each image will be one stage."
msgstr ""
"``ResourceInteractiveLoader`` 类允许在阶段中加载资源。每次调用 ``poll`` 方法"
"时，都会加载一个新阶段，并将控制权返回给调用方。每个阶段通常是由主资源加载的"
"子资源。例如，如果您正在加载一个场景，该场景加载10幅图像，那么每个图像将是一"
"个阶段。"

#: ../../docs/tutorials/io/background_loading.rst:24
#: ../../docs/community/contributing/updating_the_class_reference.rst:227
msgid "Usage"
msgstr "用法"

#: ../../docs/tutorials/io/background_loading.rst:26
msgid "Usage is generally as follows"
msgstr "一般用法如下"

#: ../../docs/tutorials/io/background_loading.rst:29
msgid "Obtaining a ResourceInteractiveLoader"
msgstr "获取ResourceInteractiveLoader"

#: ../../docs/tutorials/io/background_loading.rst:35
msgid ""
"This method will give you a ResourceInteractiveLoader that you will use to "
"manage the load operation."
msgstr ""
"此方法将向您提供一个ResourceInteractiveLoader，您将使用它来管理加载操作。"

#: ../../docs/tutorials/io/background_loading.rst:39
msgid "Polling"
msgstr "轮询"

#: ../../docs/tutorials/io/background_loading.rst:45
msgid ""
"Use this method to advance the progress of the load. Each call to ``poll`` "
"will load the next stage of your resource. Keep in mind that each stage is "
"one entire \"atomic\" resource, such as an image, or a mesh, so it will take "
"several frames to load."
msgstr ""
"使用此方法可以推进加载的进度。 每次调用 ``poll`` 都会加载资源的下一个阶段。 "
"请记住，每个阶段都是一个完整的“原子”资源，例如图像或网格，它往往需要几帧才能"
"加载。"

#: ../../docs/tutorials/io/background_loading.rst:50
msgid ""
"Returns ``OK`` on no errors, ``ERR_FILE_EOF`` when loading is finished. Any "
"other return value means there was an error and loading has stopped."
msgstr ""
"没有错误时返回 ``OK`` ，加载完成后返回 ``ERR_FILE_EOF`` 。 返回其他任何值时表"
"示存在错误并且已停止加载。"

#: ../../docs/tutorials/io/background_loading.rst:54
msgid "Load progress (optional)"
msgstr "加载进度(可选)"

#: ../../docs/tutorials/io/background_loading.rst:56
msgid "To query the progress of the load, use the following methods:"
msgstr "要查询加载进度，请使用以下方法:"

#: ../../docs/tutorials/io/background_loading.rst:63
msgid ""
"``get_stage_count`` returns the total number of stages to load. "
"``get_stage`` returns the current stage being loaded."
msgstr ""
"``get_stage_count`` 返回要加载的阶段总数。 \n"
"``get_stage`` 返回当前正在加载的阶段。"

#: ../../docs/tutorials/io/background_loading.rst:67
msgid "Forcing completion (optional)"
msgstr "强制完成(可选)"

#: ../../docs/tutorials/io/background_loading.rst:73
msgid ""
"Use this method if you need to load the entire resource in the current "
"frame, without any more steps."
msgstr "如果需要在当前帧中加载整个资源，请使用此方法，而无需执行别的步骤。"

#: ../../docs/tutorials/io/background_loading.rst:77
msgid "Obtaining the resource"
msgstr "获取资源"

#: ../../docs/tutorials/io/background_loading.rst:83
msgid ""
"If everything goes well, use this method to retrieve your loaded resource."
msgstr "如果一切顺利，请使用此方法检索已加载的资源。"

#: ../../docs/tutorials/io/background_loading.rst:89
msgid ""
"This example demonstrates how to load a new scene. Consider it in the "
"context of the :ref:`doc_singletons_autoload` example."
msgstr ""
"此示例演示如何加载新场景。 请结合 :ref:`doc_singletons_autoload` 示例来看。"

#: ../../docs/tutorials/io/background_loading.rst:92
#, fuzzy
msgid ""
"Firstly, we set up some variables and initialize the ``current_scene`` with "
"the main scene of the game:"
msgstr "首先，我们设置一些变量并用游戏的主场景初始化 ``current_scene`` :"

#: ../../docs/tutorials/io/background_loading.rst:106
msgid ""
"The function ``goto_scene`` is called from the game when the scene needs to "
"be switched. It requests an interactive loader, and calls "
"``set_process(true)`` to start polling the loader in the ``_process`` "
"callback. It also starts a \"loading\" animation, which can show a progress "
"bar or loading screen, etc."
msgstr ""
"当需要切换场景时，从游戏中调用 ``goto_scene`` 函数。 它请求一个交互式加载器，"
"并调用 ``set_process(true)`` 同时在 ``_process`` 回调中启动轮询加载器。 它还"
"会启动一个“加载”动画，以显示进度条或加载屏幕等。"

#: ../../docs/tutorials/io/background_loading.rst:128
msgid ""
"``_process`` is where the loader is polled. ``poll`` is called, and then we "
"deal with the return value from that call. ``OK`` means keep polling, "
"``ERR_FILE_EOF`` means load is done, anything else means there was an error. "
"Also note we skip one frame (via ``wait_frames``, set on the ``goto_scene`` "
"function) to allow the loading screen to show up."
msgstr ""
"``_process`` 是加载器被轮询的地方。 调用 ``poll`` ，然后我们处理该调用的返回"
"值。 ``OK`` 表示保持轮询， ``ERR_FILE_EOF`` 表示加载完成，其他任何表示存在错"
"误。 另请注意，我们跳过一帧(通过 ``wait_frames`` ，在 ``goto_scene`` 函数上设"
"置)以允许加载屏幕显示。"

#: ../../docs/tutorials/io/background_loading.rst:134
#, fuzzy
msgid ""
"Note how we use ``OS.get_ticks_msec`` to control how long we block the "
"thread. Some stages might load fast, which means we might be able to cram "
"more than one call to ``poll`` in one frame; some might take way more than "
"your value for ``time_max``, so keep in mind we won't have precise control "
"over the timings."
msgstr ""
"注意我们如何使用 ``OS.get_ticks_msec`` 来控制我们阻塞线程的时间。 某些阶段可"
"能加载速度很快，这意味着我们可以在一帧中调用多次调用 ``poll`` ，有些可能比 "
"``time_max`` 的值更多，所以请记住我们不可以精确控制时间。"

#: ../../docs/tutorials/io/background_loading.rst:170
msgid ""
"Some extra helper functions. ``update_progress`` updates a progress bar, or "
"can also update a paused animation (the animation represents the entire load "
"process from beginning to end). ``set_new_scene`` puts the newly loaded "
"scene on the tree. Because it's a scene being loaded, ``instance()`` needs "
"to be called on the resource obtained from the loader."
msgstr ""
"一些额外的辅助函数。 ``update_progress`` 更新进度条，或者也可以更新暂停的动画"
"(动画从头到尾表示整个加载过程)。 ``set_new_scene`` 将新加载的场景放在树上。 "
"因为它是一个被加载的场景，所以需要在从加载器获得的资源上调用 "
"``instance()`` 。"

#: ../../docs/tutorials/io/background_loading.rst:195
msgid "Using multiple threads"
msgstr "使用多个线程"

#: ../../docs/tutorials/io/background_loading.rst:197
msgid ""
"ResourceInteractiveLoader can be used from multiple threads. A couple of "
"things to keep in mind if you attempt it:"
msgstr ""
"多个线程可以用在ResourceInteractiveLoader中。 如果您尝试一下，请记住以下几点:"

#: ../../docs/tutorials/io/background_loading.rst:201
#, fuzzy
msgid "Use a semaphore"
msgstr "使用信号量"

#: ../../docs/tutorials/io/background_loading.rst:203
#, fuzzy
msgid ""
"While your thread waits for the main thread to request a new resource, use a "
"``Semaphore`` to sleep (instead of a busy loop or anything similar)."
msgstr ""
"当您的线程等待主线程请求新资源时，使用信号量来休眠(而不是繁忙的循环或类似的东"
"西)。"

#: ../../docs/tutorials/io/background_loading.rst:207
msgid "Not blocking main thread during the polling"
msgstr "在轮询期间不阻塞主线程"

#: ../../docs/tutorials/io/background_loading.rst:209
#, fuzzy
msgid ""
"If you have a mutex to allow calls from the main thread to your loader "
"class, don't lock the former while you call ``poll`` on the latter. When a "
"resource is done loading, it might require some resources from the low-level "
"APIs (VisualServer, etc), which might need to lock the main thread to "
"acquire them. This might cause a deadlock if the main thread is waiting for "
"your mutex while your thread is waiting to load a resource."
msgstr ""
"如果您有一个互斥锁允许从主线程到您的加载器类的调用，那么在您在加载器上调用 "
"``poll`` 时不要锁定它。 当资源加载完毕时，可能需要来自低级API(VisualServer等)"
"的一些资源，这可能需要锁定主线程以获取它们。 如果主线程在您的线程正在等待加载"
"资源时等待您的互斥锁，则可能会导致死锁。"

#: ../../docs/tutorials/io/background_loading.rst:218
msgid "Example class"
msgstr "示例类"

#: ../../docs/tutorials/io/background_loading.rst:220
msgid ""
"You can find an example class for loading resources in threads here: :"
"download:`resource_queue.gd <files/resource_queue.gd>`. Usage is as follows:"
msgstr ""
"您可以在这里找到一个用于在线程中加载资源的示例类: :download:`resource_queue."
"gd <files / resource_queue.gd>`。 用法如下:"

#: ../../docs/tutorials/io/background_loading.rst:227
msgid "Call after you instance the class to start the thread."
msgstr "在实例化类之后调用以启动线程。"

#: ../../docs/tutorials/io/background_loading.rst:233
#, fuzzy
msgid ""
"Queue a resource. Use optional argument \"p_in_front\" to put it in front of "
"the queue."
msgstr "排队资源。 使用可选参数“p_in_front”将其放在队列前面。"

#: ../../docs/tutorials/io/background_loading.rst:240
msgid "Remove a resource from the queue, discarding any loading done."
msgstr "从队列中删除资源，丢弃任何已完成的加载。"

#: ../../docs/tutorials/io/background_loading.rst:246
msgid "Returns true if a resource is done loading and ready to be retrieved."
msgstr "如果资源已完成加载并准备好检索，则返回true。"

#: ../../docs/tutorials/io/background_loading.rst:252
msgid ""
"Get the progress of a resource. Returns -1 on error (for example if the "
"resource is not on the queue), or a number between 0.0 and 1.0 with the "
"progress of the load. Use mostly for cosmetic purposes (updating progress "
"bars, etc), use ``is_ready`` to find out if a resource is actually ready."
msgstr ""
"获取资源的进度。 错误时返回-1(例如，如果资源不在队列中)，或者在加载进度的情况"
"下返回介于0.0和1.0之间的数字。 主要用于美容目的(更新进度条等)，使用 "
"``is_ready`` 来查明资源是否实际就绪。"

#: ../../docs/tutorials/io/background_loading.rst:262
msgid ""
"Returns the fully loaded resource, or null on error. If the resource is not "
"done loading (``is_ready`` returns false), it will block your thread and "
"finish the load. If the resource is not on the queue, it will call "
"``ResourceLoader::load`` to load it normally and return it."
msgstr ""
"返回完全加载的资源，或者出错时返回null。 如果资源没有完成加载(``is_ready``返"
"回false)，它将阻塞您的线程并完成加载。 如果资源不在队列中，它将调用"
"``ResourceLoader :: load``来正常加载它并返回它。"

#: ../../docs/tutorials/io/background_loading.rst:298
#, fuzzy
msgid ""
"**Note**: this code, in its current form, is not tested in real world "
"scenarios. Ask punto on IRC (#godotengine on irc.freenode.net) for help."
msgstr ""
"**注意**:当前形式的此代码未在实际场景中进行测试。 在IRC上询问punto(irc."
"freenode.net上的#godotengine)寻求帮助。"

#: ../../docs/tutorials/io/data_paths.rst:4
msgid "Data paths"
msgstr "数据路径"

#: ../../docs/tutorials/io/data_paths.rst:7
msgid "Path separators"
msgstr "路径分隔符"

#: ../../docs/tutorials/io/data_paths.rst:9
#, fuzzy
msgid ""
"For the sake of supporting as many platforms as possible, Godot only accepts "
"UNIX-style path separators (``/``). These work on all platforms, including "
"Windows."
msgstr ""
"为了支持尽可能多的平台，Godot只接受UNIX风格的路径分隔符(``/``)。在包括Windows"
"在内的所有平台上，这种路径分隔符均可以正常工作。"

#: ../../docs/tutorials/io/data_paths.rst:13
msgid "A path like ``C:\\Projects`` will become ``C:/Projects``."
msgstr "像 ``C:\\Projects`` 这样的路径将变成 ``C:/Projects``。"

#: ../../docs/tutorials/io/data_paths.rst:18
msgid ""
"As mentioned before, Godot considers that a project exists in any given "
"folder that contains a ``project.godot`` text file, even if such file is "
"empty."
msgstr ""
"如前所述，Godot认为一个项目文件夹中包含一个 ``project.godot`` 文本文件，即使"
"该文件是空的。"

#: ../../docs/tutorials/io/data_paths.rst:22
msgid ""
"Accessing project files can be done by opening any path with ``res://`` as a "
"base. For example, a texture located in the root of the project folder may "
"be opened from the following path: ``res://some_texture.png``."
msgstr ""
"访问项目文件可以通过打开以 ``res://`` 为基的任何路径来实现。例如，位于项目文"
"件夹根部的纹理可以从以下路径打开: ``res://some_texture.png``。"

#: ../../docs/tutorials/io/data_paths.rst:27
msgid "User path (persistent data)"
msgstr "用户路径(持久化数据)"

#: ../../docs/tutorials/io/data_paths.rst:29
msgid ""
"While the project is running, it is a common scenario that the resource path "
"will be read-only, due to it being inside a package, self-contained "
"executable, or system-wide install location."
msgstr ""
"当项目运行时，由于资源位于一个压缩包内、自包含可执行文件或系统范围的安装位"
"置，因此通常情况下资源路径是只读的。"

#: ../../docs/tutorials/io/data_paths.rst:33
msgid ""
"Storing persistent files in such scenarios should be done by using the "
"``user://`` prefix, for example: ``user://game_save.txt``."
msgstr ""
"在这种情况下，应该通过使用 ``user://`` 前缀来存储持久文件，例如 ``user://"
"game_save.txt`` 。"

#: ../../docs/tutorials/io/data_paths.rst:36
msgid ""
"On some devices (for example, mobile and consoles), this path is unique to "
"the project. On desktop operating systems, the engine uses the typical ``~/."
"local/share/godot/app_userdata/Name`` on macOS and Linux, and ``%APPDATA%/"
"Name`` on Windows. ``Name`` is taken from the application name defined in "
"the Project Settings, but it can be overridden on a per-platform basis "
"using :ref:`feature tags <doc_feature_tags>`."
msgstr ""
"在某些设备(例如，移动设备和游戏机)上，对项目来说此路径是唯一的。 在桌面操作系"
"统上，引擎在macOS和Linux上使用典型的 ``~/.local/share/godot/app_userdata/"
"Name`` 路径，在Windows上使用 ``%APPDATA%/Name`` 路径来表示用户路径。 "
"``Name`` 取自项目设置中定义的应用程序名称，但它可被 :ref:`feature tags "
"<doc_feature_tags>` 命令覆写 。"

#: ../../docs/tutorials/io/saving_games.rst:4
msgid "Saving games"
msgstr "保存游戏"

#: ../../docs/tutorials/io/saving_games.rst:9
msgid ""
"Save games can be complicated. It can be desired to store more information "
"than the current level or number of stars earned on a level. More advanced "
"save games may need to store additional information about an arbitrary "
"number of objects. This will allow the save function to scale as the game "
"grows more complex."
msgstr ""
"保存游戏可能很复杂。可以想想这会存储，比角色等级或在某等级上赚取的星星数量，"
"更多的信息。更高级的保存游戏可能需要存储关于具有任意数量的对象的附加信息。当"
"游戏变得更加复杂时，这将需要保存函数来辅助。"

#: ../../docs/tutorials/io/saving_games.rst:16
msgid "Identify persistent objects"
msgstr "识别持久化对象"

#: ../../docs/tutorials/io/saving_games.rst:18
#, fuzzy
msgid ""
"Firstly, we should identify what objects we want to keep between game "
"sessions and what information we want to keep from those objects. For this "
"tutorial, we will use groups to mark and handle objects to be saved, but "
"other methods are certainly possible."
msgstr ""
"首先，我们应该确定在游戏会话中要保存什么对象，以及我们要从这些对象中保存什么"
"信息。本教程中，我们将使用组来标记和处理要保存的对象，当然也有其他可行的方"
"法。"

#: ../../docs/tutorials/io/saving_games.rst:23
#, fuzzy
msgid ""
"We will start by adding objects we wish to save to the \"Persist\" group. As "
"in the :ref:`doc_scripting_continued` tutorial, we can do this through "
"either the GUI or script. Let's add the relevant nodes using the GUI:"
msgstr ""
"首先我们将添加对象，它将保存到“Persist”组。 在 :ref:"
"`doc_scripting_continued` 教程中，我们学会了通过GUI或脚本完成此操作。 那就让"
"我们使用GUI来添加相关节点吧:"

#: ../../docs/tutorials/io/saving_games.rst:29
#, fuzzy
msgid ""
"Once this is done, when we need to save the game, we can get all objects to "
"save them and then tell them all to save with this script:"
msgstr ""
"完成此操作后， 在我们需要保存游戏时，我们可以获取所有对象以保存它们，然后告诉"
"所有对象通过此脚本保存数据:"

#: ../../docs/tutorials/io/saving_games.rst:49
msgid "Serializing"
msgstr "序列化"

#: ../../docs/tutorials/io/saving_games.rst:51
#, fuzzy
msgid ""
"The next step is to serialize the data. This makes it much easier to read "
"from and store to disk. In this case, we're assuming each member of group "
"Persist is an instanced node and thus has a path. GDScript has helper "
"functions for this, such as :ref:`to_json() "
"<class_@GDScript_method_to_json>` and :ref:`parse_json() "
"<class_@GDScript_method_parse_json>`, so we will use a dictionary. Our node "
"needs to contain a save function that returns this data. The save function "
"will look like this:"
msgstr ""
"下一步是序列化数据。 这使得从硬盘读取数据和存储数据到硬盘变得更加容易。 在这"
"种情况下，我们假设Persist组的每个成员都是一个实例节点，因此有一个路径。 因为"
"GDScript有相关的辅助函数，如 :ref:`to_json() "
"<class_@GDScript_method_to_json>` 和 :ref:`parse_json() "
"<class_@GDScript_parse_json>`，所以我们使用字典来表示数据。 我们的节点需要包"
"含一个返回此类型数据的保存函数。 保存函数如下所示:"

#: ../../docs/tutorials/io/saving_games.rst:114
#, fuzzy
msgid ""
"This gives us a dictionary with the style ``{ \"variable_name\":"
"value_of_variable }``, which will be useful when loading."
msgstr ""
"我们得到一个样式为 ``{ \"variable_name\":that_variables_value }`` 的字典，它"
"在加载游戏数据时很有用。"

#: ../../docs/tutorials/io/saving_games.rst:119
msgid "Saving and reading data"
msgstr "保存和读取数据"

#: ../../docs/tutorials/io/saving_games.rst:121
#, fuzzy
msgid ""
"As covered in the :ref:`doc_filesystem` tutorial, we'll need to open a file "
"and write to it and then later, read from it. Now that we have a way to call "
"our groups and get their relevant data, let's use to_json() to convert it "
"into an easily stored string and store them in a file. Doing it this way "
"ensures that each line is its own object, so we have an easy way to pull the "
"data out of the file as well."
msgstr ""
"正如在 :ref:`doc_filesystem` 教程中所述，我们需要打开一个文件并向其中写入数"
"据，然后可以从中读取数据。 既然我们有办法调用我们的组并获取它们的相关数据，那"
"么就让我们使用 to_json() 将数据转换成一个容易存储的字符串并将它存储在文件中"
"吧。 这样做可以确保每一行都是自包含的对象，因此我们也可以轻松地将数据从文件中"
"提取出来。"

#: ../../docs/tutorials/io/saving_games.rst:166
#, fuzzy
msgid ""
"Game saved! Loading is fairly simple as well. For that, we'll read each "
"line, use parse_json() to read it back to a dict, and then iterate over the "
"dict to read our values. But we'll need to first create the object and we "
"can use the filename and parent values to achieve that. Here is our load "
"function:"
msgstr ""
"游戏保存好了！ 加载也很简单。 为此，我们将读取每一行，使用parse_json() 将其读"
"回到一个字典中，然后遍历字典以读取保存的值。 首先我们需要创建对象，这可以通过"
"使用文件名和父值来实现。 这就是我们的加载函数:"

#: ../../docs/tutorials/io/saving_games.rst:254
#, fuzzy
msgid ""
"And now, we can save and load an arbitrary number of objects laid out almost "
"anywhere across the scene tree! Each object can store different data "
"depending on what it needs to save."
msgstr ""
"现在我们可以保存和加载几乎任何位于场景树中的任意数量的对象了！ 每个对象可以根"
"据需要保存的内容存储不同的数据。"

#: ../../docs/tutorials/io/saving_games.rst:259
msgid "Some notes"
msgstr "一些注释"

#: ../../docs/tutorials/io/saving_games.rst:261
msgid ""
"We may have glossed over a step, but setting the game state to one fit to "
"start loading data can be complicated. This step will need to be heavily "
"customized based on the needs of an individual project."
msgstr ""
"我们可能已经忽略了一个步骤，但将游戏状态设置到适合以加载数据可能很复杂。 需要"
"根据单个项目的需求对此步骤进行大量定制。"

#: ../../docs/tutorials/io/saving_games.rst:265
#, fuzzy
msgid ""
"This implementation assumes no Persist objects are children of other Persist "
"objects. Otherwise, invalid paths would be created. To accommodate nested "
"Persist objects, consider saving objects in stages. Load parent objects "
"first so they are available for the add_child() call when child objects are "
"loaded. You will also need a way to link children to parents as the NodePath "
"will likely be invalid."
msgstr ""
"此实现假定没有Persist对象是其他Persist对象的子对象。 这样做会产生无效路径。 "
"如果这是项目的需求之一，则需要考虑这一点。 分阶段保存对象(父对象优先)，以便在"
"加载子对象时可用它们将确保它们可用于add_child() 调用。 由于NodePath可能无效，"
"因此还需要某种方式将子项链接到父项。"

#: ../../docs/tutorials/io/encrypting_save_games.rst:4
msgid "Encrypting save games"
msgstr "加密保存游戏"

#: ../../docs/tutorials/io/encrypting_save_games.rst:9
#, fuzzy
msgid ""
"Because the world today is not the world of yesterday. A capitalist "
"oligarchy runs the world and forces us to consume in order to keep the gears "
"of this rotten society on track. As such, the biggest market for video game "
"consumption today is the mobile one. It is a market of poor souls forced to "
"compulsively consume digital content in order to forget the misery of their "
"everyday life, commute, or just any other brief free moment they have that "
"they are not using to produce goods or services for the ruling class. These "
"individuals need to keep focusing on their video games (because not doing so "
"will fill them with tremendous existential angst), so they go as far as "
"spending money on them to extend their experience, and their preferred way "
"of doing so is through in-app purchases and virtual currency."
msgstr ""
"因为今天的世界不是昨天的世界。一个资本主义寡头统治世界，强迫我们消费，以便使"
"这个腐朽社会的齿轮保持在轨道上。因此，当今视频游戏消费最大的市场是手机游戏市"
"场。这是一个穷人被迫消费数字内容的市场，以便忘记他们日常生活、通勤的痛苦，或"
"仅仅享受他们没有被用来为统治阶级生产商品或服务的短暂自由时刻。这些人需要继续"
"关注他们的电子游戏(因为不这样做将给他们带来巨大的生存焦虑)，所以他们甚至花钱"
"在游戏上来扩展他们的体验，而他们这样做的首选方式是通过应用内购买和虚拟货币。"

#: ../../docs/tutorials/io/encrypting_save_games.rst:22
#, fuzzy
msgid ""
"But what if someone were to find a way to edit the saved games and assign "
"the items and currency without effort? That would be terrible, because it "
"would help players consume the content much faster, and therefore run out of "
"it sooner than expected. If that happens, they will have nothing that avoids "
"them to think, and the tremendous agony of realizing their own irrelevance "
"would again take over their life."
msgstr ""
"但是，想象一下，如果有人想办法编辑保存的游戏，不用任何努力地就可以分配物品和"
"货币？这将是可怕的，因为它将使得游戏角色更快地消费游戏内容，导致更快地消费完"
"游戏内容。如果发生这种情况，他们将没有别东西可以逃避生活，并且生活的窘迫将再"
"次占据他们的生活。"

#: ../../docs/tutorials/io/encrypting_save_games.rst:29
#, fuzzy
msgid ""
"No, we definitely do not want that to happen, so let's see how to encrypt "
"savegames and protect the world order."
msgstr ""
"不，我们绝对不希望这种情况发生，所以让我们看看如何加密保存游戏从而维护现实世"
"界的秩序。"

#: ../../docs/tutorials/io/encrypting_save_games.rst:33
msgid "How?"
msgstr "怎么用？"

#: ../../docs/tutorials/io/encrypting_save_games.rst:35
msgid ""
"The class :ref:`File <class_File>` can open a file at a location and read/"
"write data (integers, strings and variants). It also supports encryption. To "
"create an encrypted file, a passphrase must be provided, like this:"
msgstr ""
"类 :ref:`File <class_File>` 可以在一个位置打开文件并读/写数据(整数、字符串和"
"变量)。它还支持加密。要创建加密文件，必须提供一个密码，如下所示:"

#: ../../docs/tutorials/io/encrypting_save_games.rst:55
#, fuzzy
msgid ""
"This will make the file unreadable to users, but will still not prevent them "
"from sharing savefiles. To solve this, use the device unique id or some "
"unique user identifier, for example:"
msgstr ""
"对用户而言，这将使文件不可读，但仍然不会阻止他们分享保存的文件。为了解决这个"
"问题，可以使用设备唯一的id或某个唯一用户标识符，例如:"

#: ../../docs/tutorials/io/encrypting_save_games.rst:74
msgid "Note that ``OS.get_unique_id()`` only works on iOS and Android."
msgstr "请注意， ``OS.get_unique_id()`` 只适用于iOS和Android系统。"

#: ../../docs/tutorials/io/encrypting_save_games.rst:76
#, fuzzy
msgid "That is all! Thank you for your cooperation, citizen."
msgstr "这就是全部！谢谢您的合作，公民。"

#: ../../docs/tutorials/io/encrypting_save_games.rst:78
#, fuzzy
msgid ""
"This method cannot really prevent players from editing their savegames "
"locally because, since the encryption key is stored inside the game, the "
"player can still decrypt and edit the file themselves. The only way to "
"prevent this from being possible is to store the save data on a remote "
"server, where players can only make authorized changes to their save data. "
"If your game deals with real money, you need to be doing this anyway."
msgstr ""
"这种方法并不能真正阻止游戏角色在本地编辑他们的保存游戏，因为加密密钥存储在游"
"戏中，所以游戏角色仍然可以对文件本身进行解密和编辑。防止出现这种情况的唯一方"
"法是将保存的游戏数据存储在远程服务器上，其中游戏角色只能对其中的保存数据进行"
"授权更改。如果您的游戏涉及到真正的金钱，您无论如何都需要这样做。"

#: ../../docs/tutorials/i18n/index.rst:2
msgid "Internationalization"
msgstr "国际化"

#: ../../docs/tutorials/i18n/internationalizing_games.rst:4
msgid "Internationalizing games"
msgstr "使游戏国际化"

#: ../../docs/tutorials/i18n/internationalizing_games.rst:9
msgid ""
"Sería excelente que el mundo hablara solo un idioma (It would be great if "
"the world spoke only one language). Unfortunately for us developers, that is "
"not the case. While indie or niche games usually do not need localization, "
"games targeting a more massive market often require localization. Godot "
"offers many tools to make this process more straightforward, so this "
"tutorial is more like a collection of tips and tricks."
msgstr ""
"如果全世界只讲一种语言，那将是很好的(这将是世界上唯一的一种语言)。不幸的是，"
"对于我们的开发人员来说，情况并非如此。虽然独立或利基游戏通常不需要本地化，但"
"瞄准更大市场的游戏通常需要本地化。Godot提供了许多工具来使这个过程更加简单，因"
"此本教程更像一个技巧和技巧的集合。"

#: ../../docs/tutorials/i18n/internationalizing_games.rst:17
msgid ""
"Localization is usually done by specific studios hired for the job and, "
"despite the huge amount of software and file formats available for this, the "
"most common way to do localization to this day is still with spreadsheets. "
"The process of creating the spreadsheets and importing them is already "
"covered in the :ref:`doc_importing_translations` tutorial, so this one could "
"be seen more like a follow-up to that one."
msgstr ""
"本地化通常是通过雇佣特定的工作室来完成的, 尽管有大量的软件和文件格式可供使"
"用, 但迄今为止进行本地化最常见的方式仍然是使用电子表格。创建电子表格并导入电"
"子表格的过程已经在 :ref:`doc_importing_translations` 教程中介绍了，所以这个教"
"程更像是对那个教程的后续。"

#: ../../docs/tutorials/i18n/internationalizing_games.rst:25
msgid ""
"We will be using the official demo as an example; you can `download it from "
"the Asset Library <https://godotengine.org/asset-library/asset/134>`_."
msgstr ""
"我们将使用官方演示作为一个示例, 您可以在 `Asset Library <https://godotengine."
"org/asset-library/asset/134>`_ 下载它们。"

#: ../../docs/tutorials/i18n/internationalizing_games.rst:29
msgid "Configuring the imported translation"
msgstr "配置导入的译文"

#: ../../docs/tutorials/i18n/internationalizing_games.rst:31
msgid ""
"Translations can get updated and re-imported when they change, but they "
"still have to be added to the project. This is done in **Project → Project "
"Settings → Localization**:"
msgstr ""
"翻译可以在更改时得到更新和重新导入, 但仍必须添加到项目中。可通过 **Project → "
"Project Settings → Localization** 来完成:"

#: ../../docs/tutorials/i18n/internationalizing_games.rst:37
msgid "The above dialog is used to add or remove translations project-wide."
msgstr "上述对话框用于添加或删除项目范围内的翻译。"

#: ../../docs/tutorials/i18n/internationalizing_games.rst:40
msgid "Localizing resources"
msgstr "资源文件的本地化处理"

#: ../../docs/tutorials/i18n/internationalizing_games.rst:42
msgid ""
"It is also possible to instruct Godot to use alternate versions of assets "
"(resources) depending on the current language. The **Remaps** tab can be "
"used for this:"
msgstr ""
"根据当前语言，还可以指示Godot使用资源(资源)的替代版本。 **映射** 选项卡可用于"
"此:"

#: ../../docs/tutorials/i18n/internationalizing_games.rst:48
msgid ""
"Select the resource to be remapped, then add some alternatives for each "
"locale."
msgstr "选择需要重映射的资源，并指定它在其他语言地区的替代方案。"

#: ../../docs/tutorials/i18n/internationalizing_games.rst:52
msgid "Converting keys to text"
msgstr "将键转换为文本"

#: ../../docs/tutorials/i18n/internationalizing_games.rst:54
#, fuzzy
msgid ""
"Some controls, such as :ref:`Button <class_Button>` and :ref:`Label "
"<class_Label>`, will automatically fetch a translation if their text matches "
"a translation key. For example, if a label's text is "
"\"MAIN_SCREEN_GREETING1\" and that key exists in the current translation, "
"then the text will automatically be translated."
msgstr ""
"一些控件如 :ref:`Button <class_Button>` 和 :ref:`Label <class_Label>` 将自动"
"获取翻译, 如果它们的文本与翻译键匹配。 例如，如果标签的文本"
"是“MAIN_SCREEN_GREETING1”并且该键存在于当前翻译中，则文本将自动翻译。"

#: ../../docs/tutorials/i18n/internationalizing_games.rst:59
#, fuzzy
msgid ""
"In code, the :ref:`Object.tr() <class_Object_method_tr>` function can be "
"used. This will just look up the text in the translations and convert it if "
"found:"
msgstr ""
"在代码中，可以使用 :ref:`Object.tr() <class_Object_method_tr>` 函数。 这将只"
"查找翻译中的文本并在找到时进行转换:"

#: ../../docs/tutorials/i18n/internationalizing_games.rst:69
msgid "Making controls resizable"
msgstr "使控件可调整大小"

#: ../../docs/tutorials/i18n/internationalizing_games.rst:71
msgid ""
"The same text in different languages can vary greatly in length. For this, "
"make sure to read the tutorial on :ref:`doc_size_and_anchors`, as "
"dynamically adjusting control sizes may help. :ref:`Container "
"<class_Container>` can be useful, as well as the text wrapping options "
"available in :ref:`Label <class_Label>`."
msgstr ""
"不同语言的相同文本的长度差异很大。 为此，请务必阅读以下教程 :ref:"
"`doc_size_and_anchors` ，因为动态调整控件大小可能有所帮助。 :ref:`Container "
"<class_Container>` 可能很有用，以及 :ref:`Label <class_Label>` 的文本包选项。"

#: ../../docs/tutorials/i18n/internationalizing_games.rst:78
msgid "TranslationServer"
msgstr "TranslationServer类"

#: ../../docs/tutorials/i18n/internationalizing_games.rst:80
msgid ""
"Godot has a server handling low-level translation management called the :ref:"
"`TranslationServer <class_TranslationServer>`. Translations can be added or "
"removed during run-time; the current language can also be changed at run-"
"time."
msgstr ""
"Godot有一个处理低级翻译管理的服务器，名为 :ref:`TranslationServer "
"<class_TranslationServer>` 。 可以在运行时添加或删除翻译; 当前语言也可以在运"
"行时更改。"

#: ../../docs/tutorials/i18n/internationalizing_games.rst:86
msgid "Command line"
msgstr "命令行"

#: ../../docs/tutorials/i18n/internationalizing_games.rst:88
msgid ""
"Language can be tested when running Godot from the command line. For "
"example, to test a game in French, the following argument can be supplied:"
msgstr ""
"从命令行运行Godot时可以测试语言。 例如，要使用法语测试游戏，可以提供以下参数:"

#: ../../docs/tutorials/i18n/internationalizing_games.rst:97
msgid "Translating the project name"
msgstr "翻译项目名称"

#: ../../docs/tutorials/i18n/internationalizing_games.rst:99
msgid ""
"The project name becomes the app name when exporting to different operating "
"systems and platforms. To specify the project name in more than one "
"language, create a new setting ``application/name`` in the **Project "
"Settings** and append the locale identifier to it. For instance, for "
"Spanish, this would be ``application/name_es``:"
msgstr ""
"导出到不同的操作系统和平台时，项目名称将成为应用程序名称。 要以多种语言指定项"
"目名称，请在 **项目设置** 中创建一个新设置 ``application / name`` ，并将语言"
"环境标识符附加到其中。 例如，对于西班牙语，这将是 ``application / name_es`` :"

#: ../../docs/tutorials/i18n/internationalizing_games.rst:107
msgid ""
"If you are unsure about the language code to use, refer to the :ref:`list of "
"locale codes <doc_locales>`."
msgstr ""
"如果您不确定要使用的语言代码，请参阅 :ref:`list of locale codes "
"<doc_locales>` 。"

#: ../../docs/tutorials/i18n/locales.rst:4
msgid "Locales"
msgstr "地区设置"

#: ../../docs/tutorials/i18n/locales.rst:6
msgid ""
"This is the list of supported locales and variants in the engine. It's based "
"on the Unix standard locale strings:"
msgstr ""
"这是引擎中支持的区域设置和语言变体的列表。它基于Unix 标准区域设置字符串:"

#: ../../docs/tutorials/i18n/locales.rst:10
msgid "Locale"
msgstr "区域"

#: ../../docs/tutorials/i18n/locales.rst:10
msgid "Language and Variant"
msgstr "语言和变体"

#: ../../docs/tutorials/i18n/locales.rst:12
msgid "aa"
msgstr "aa"

#: ../../docs/tutorials/i18n/locales.rst:12
msgid "Afar"
msgstr "Afar"

#: ../../docs/tutorials/i18n/locales.rst:14
msgid "aa_DJ"
msgstr "aa_DJ"

#: ../../docs/tutorials/i18n/locales.rst:14
msgid "Afar (Djibouti)"
msgstr "Afar (Djibouti)"

#: ../../docs/tutorials/i18n/locales.rst:16
msgid "aa_ER"
msgstr "aa_ER"

#: ../../docs/tutorials/i18n/locales.rst:16
msgid "Afar (Eritrea)"
msgstr "Afar (Eritrea)"

#: ../../docs/tutorials/i18n/locales.rst:18
msgid "aa_ET"
msgstr "aa_ET"

#: ../../docs/tutorials/i18n/locales.rst:18
msgid "Afar (Ethiopia)"
msgstr "Afar (Ethiopia)"

#: ../../docs/tutorials/i18n/locales.rst:20
msgid "af"
msgstr "af"

#: ../../docs/tutorials/i18n/locales.rst:20
msgid "Afrikaans"
msgstr "Afrikaans"

#: ../../docs/tutorials/i18n/locales.rst:22
msgid "af_ZA"
msgstr "af_ZA"

#: ../../docs/tutorials/i18n/locales.rst:22
msgid "Afrikaans (South Africa)"
msgstr "Afrikaans (South Africa)"

#: ../../docs/tutorials/i18n/locales.rst:24
msgid "agr_PE"
msgstr "agr_PE"

#: ../../docs/tutorials/i18n/locales.rst:24
msgid "Aguaruna (Peru)"
msgstr "Aguaruna (Peru)"

#: ../../docs/tutorials/i18n/locales.rst:26
msgid "ak_GH"
msgstr "ak_GH"

#: ../../docs/tutorials/i18n/locales.rst:26
msgid "Akan (Ghana)"
msgstr "Akan (Ghana)"

#: ../../docs/tutorials/i18n/locales.rst:28
msgid "am_ET"
msgstr "am_ET"

#: ../../docs/tutorials/i18n/locales.rst:28
msgid "Amharic (Ethiopia)"
msgstr "Amharic (Ethiopia)"

#: ../../docs/tutorials/i18n/locales.rst:30
msgid "an_ES"
msgstr "an_ES"

#: ../../docs/tutorials/i18n/locales.rst:30
msgid "Aragonese (Spain)"
msgstr "Aragonese (Spain)"

#: ../../docs/tutorials/i18n/locales.rst:32
msgid "anp_IN"
msgstr "anp_IN"

#: ../../docs/tutorials/i18n/locales.rst:32
msgid "Angika (India)"
msgstr "Angika (India)"

#: ../../docs/tutorials/i18n/locales.rst:34
msgid "ar"
msgstr "ar"

#: ../../docs/tutorials/i18n/locales.rst:34
msgid "Arabic"
msgstr "Arabic"

#: ../../docs/tutorials/i18n/locales.rst:36
msgid "ar_AE"
msgstr "ar_AE"

#: ../../docs/tutorials/i18n/locales.rst:36
msgid "Arabic (United Arab Emirates)"
msgstr "Arabic (United Arab Emirates)"

#: ../../docs/tutorials/i18n/locales.rst:38
msgid "ar_BH"
msgstr "ar_BH"

#: ../../docs/tutorials/i18n/locales.rst:38
msgid "Arabic (Bahrain)"
msgstr "Arabic (Bahrain)"

#: ../../docs/tutorials/i18n/locales.rst:40
msgid "ar_DZ"
msgstr "ar_DZ"

#: ../../docs/tutorials/i18n/locales.rst:40
msgid "Arabic (Algeria)"
msgstr "Arabic (Algeria)"

#: ../../docs/tutorials/i18n/locales.rst:42
msgid "ar_EG"
msgstr "ar_EG"

#: ../../docs/tutorials/i18n/locales.rst:42
msgid "Arabic (Egypt)"
msgstr "Arabic (Egypt)"

#: ../../docs/tutorials/i18n/locales.rst:44
msgid "ar_IQ"
msgstr "ar_IQ"

#: ../../docs/tutorials/i18n/locales.rst:44
msgid "Arabic (Iraq)"
msgstr "Arabic (Iraq)"

#: ../../docs/tutorials/i18n/locales.rst:46
msgid "ar_JO"
msgstr "ar_JO"

#: ../../docs/tutorials/i18n/locales.rst:46
msgid "Arabic (Jordan)"
msgstr "Arabic (Jordan)"

#: ../../docs/tutorials/i18n/locales.rst:48
msgid "ar_KW"
msgstr "ar_KW"

#: ../../docs/tutorials/i18n/locales.rst:48
msgid "Arabic (Kuwait)"
msgstr "Arabic (Kuwait)"

#: ../../docs/tutorials/i18n/locales.rst:50
msgid "ar_LB"
msgstr "ar_LB"

#: ../../docs/tutorials/i18n/locales.rst:50
msgid "Arabic (Lebanon)"
msgstr "Arabic (Lebanon)"

#: ../../docs/tutorials/i18n/locales.rst:52
msgid "ar_LY"
msgstr "ar_LY"

#: ../../docs/tutorials/i18n/locales.rst:52
msgid "Arabic (Libya)"
msgstr "Arabic (Libya)"

#: ../../docs/tutorials/i18n/locales.rst:54
msgid "ar_MA"
msgstr "ar_MA"

#: ../../docs/tutorials/i18n/locales.rst:54
msgid "Arabic (Morocco)"
msgstr "Arabic (Morocco)"

#: ../../docs/tutorials/i18n/locales.rst:56
msgid "ar_OM"
msgstr "ar_OM"

#: ../../docs/tutorials/i18n/locales.rst:56
msgid "Arabic (Oman)"
msgstr "Arabic (Oman)"

#: ../../docs/tutorials/i18n/locales.rst:58
msgid "ar_QA"
msgstr "ar_QA"

#: ../../docs/tutorials/i18n/locales.rst:58
msgid "Arabic (Qatar)"
msgstr "Arabic (Qatar)"

#: ../../docs/tutorials/i18n/locales.rst:60
msgid "ar_SA"
msgstr "ar_SA"

#: ../../docs/tutorials/i18n/locales.rst:60
msgid "Arabic (Saudi Arabia)"
msgstr "Arabic (Saudi Arabia)"

#: ../../docs/tutorials/i18n/locales.rst:62
msgid "ar_SD"
msgstr "ar_SD"

#: ../../docs/tutorials/i18n/locales.rst:62
msgid "Arabic (Sudan)"
msgstr "Arabic (Sudan)"

#: ../../docs/tutorials/i18n/locales.rst:64
msgid "ar_SY"
msgstr "ar_SY"

#: ../../docs/tutorials/i18n/locales.rst:64
msgid "Arabic (Syria)"
msgstr "Arabic (Syria)"

#: ../../docs/tutorials/i18n/locales.rst:66
msgid "ar_TN"
msgstr "ar_TN"

#: ../../docs/tutorials/i18n/locales.rst:66
msgid "Arabic (Tunisia)"
msgstr "Arabic (Tunisia)"

#: ../../docs/tutorials/i18n/locales.rst:68
msgid "ar_YE"
msgstr "ar_YE"

#: ../../docs/tutorials/i18n/locales.rst:68
msgid "Arabic (Yemen)"
msgstr "Arabic (Yemen)"

#: ../../docs/tutorials/i18n/locales.rst:70
msgid "as_IN"
msgstr "as_IN"

#: ../../docs/tutorials/i18n/locales.rst:70
msgid "Assamese (India)"
msgstr "Assamese (India)"

#: ../../docs/tutorials/i18n/locales.rst:72
msgid "ast_ES"
msgstr "ast_ES"

#: ../../docs/tutorials/i18n/locales.rst:72
msgid "Asturian (Spain)"
msgstr "Asturian (Spain)"

#: ../../docs/tutorials/i18n/locales.rst:74
msgid "ayc_PE"
msgstr "ayc_PE"

#: ../../docs/tutorials/i18n/locales.rst:74
msgid "Southern Aymara (Peru)"
msgstr "Southern Aymara (Peru)"

#: ../../docs/tutorials/i18n/locales.rst:76
msgid "ay_PE"
msgstr "ay_PE"

#: ../../docs/tutorials/i18n/locales.rst:76
msgid "Aymara (Peru)"
msgstr "Aymara (Peru)"

#: ../../docs/tutorials/i18n/locales.rst:78
msgid "az_AZ"
msgstr "az_AZ"

#: ../../docs/tutorials/i18n/locales.rst:78
msgid "Azerbaijani (Azerbaijan)"
msgstr "Azerbaijani (Azerbaijan)"

#: ../../docs/tutorials/i18n/locales.rst:80
msgid "be"
msgstr "be"

#: ../../docs/tutorials/i18n/locales.rst:80
msgid "Belarusian"
msgstr "Belarusian"

#: ../../docs/tutorials/i18n/locales.rst:82
msgid "be_BY"
msgstr "be_BY"

#: ../../docs/tutorials/i18n/locales.rst:82
msgid "Belarusian (Belarus)"
msgstr "Belarusian (Belarus)"

#: ../../docs/tutorials/i18n/locales.rst:84
msgid "bem_ZM"
msgstr "bem_ZM"

#: ../../docs/tutorials/i18n/locales.rst:84
msgid "Bemba (Zambia)"
msgstr "Bemba (Zambia)"

#: ../../docs/tutorials/i18n/locales.rst:86
msgid "ber_DZ"
msgstr "ber_DZ"

#: ../../docs/tutorials/i18n/locales.rst:86
msgid "Berber languages (Algeria)"
msgstr "Berber languages (Algeria)"

#: ../../docs/tutorials/i18n/locales.rst:88
msgid "ber_MA"
msgstr "ber_MA"

#: ../../docs/tutorials/i18n/locales.rst:88
msgid "Berber languages (Morocco)"
msgstr "Berber languages (Morocco)"

#: ../../docs/tutorials/i18n/locales.rst:90
msgid "bg"
msgstr "bg"

#: ../../docs/tutorials/i18n/locales.rst:90
msgid "Bulgarian"
msgstr "Bulgarian"

#: ../../docs/tutorials/i18n/locales.rst:92
msgid "bg_BG"
msgstr "bg_BG"

#: ../../docs/tutorials/i18n/locales.rst:92
msgid "Bulgarian (Bulgaria)"
msgstr "Bulgarian (Bulgaria)"

#: ../../docs/tutorials/i18n/locales.rst:94
msgid "bhb_IN"
msgstr "bhb_IN"

#: ../../docs/tutorials/i18n/locales.rst:94
msgid "Bhili (India)"
msgstr "Bhili (India)"

#: ../../docs/tutorials/i18n/locales.rst:96
msgid "bho_IN"
msgstr "bho_IN"

#: ../../docs/tutorials/i18n/locales.rst:96
msgid "Bhojpuri (India)"
msgstr "Bhojpuri (India)"

#: ../../docs/tutorials/i18n/locales.rst:98
msgid "bi_TV"
msgstr "bi_TV"

#: ../../docs/tutorials/i18n/locales.rst:98
msgid "Bislama (Tuvalu)"
msgstr "Bislama (Tuvalu)"

#: ../../docs/tutorials/i18n/locales.rst:100
msgid "bn"
msgstr "bn"

#: ../../docs/tutorials/i18n/locales.rst:100
msgid "Bengali"
msgstr "Bengali"

#: ../../docs/tutorials/i18n/locales.rst:102
msgid "bn_BD"
msgstr "bn_BD"

#: ../../docs/tutorials/i18n/locales.rst:102
msgid "Bengali (Bangladesh)"
msgstr "Bengali (Bangladesh)"

#: ../../docs/tutorials/i18n/locales.rst:104
msgid "bn_IN"
msgstr "bn_IN"

#: ../../docs/tutorials/i18n/locales.rst:104
msgid "Bengali (India)"
msgstr "Bengali (India)"

#: ../../docs/tutorials/i18n/locales.rst:106
msgid "bo"
msgstr "bo"

#: ../../docs/tutorials/i18n/locales.rst:106
msgid "Tibetan"
msgstr "Tibetan"

#: ../../docs/tutorials/i18n/locales.rst:108
msgid "bo_CN"
msgstr "bo_CN"

#: ../../docs/tutorials/i18n/locales.rst:108
msgid "Tibetan (China)"
msgstr "Tibetan (China)"

#: ../../docs/tutorials/i18n/locales.rst:110
msgid "bo_IN"
msgstr "bo_IN"

#: ../../docs/tutorials/i18n/locales.rst:110
msgid "Tibetan (India)"
msgstr "Tibetan (India)"

#: ../../docs/tutorials/i18n/locales.rst:112
msgid "br_FR"
msgstr "br_FR"

#: ../../docs/tutorials/i18n/locales.rst:112
msgid "Breton (France)"
msgstr "Breton (France)"

#: ../../docs/tutorials/i18n/locales.rst:114
msgid "brx_IN"
msgstr "brx_IN"

#: ../../docs/tutorials/i18n/locales.rst:114
msgid "Bodo (India)"
msgstr "Bodo (India)"

#: ../../docs/tutorials/i18n/locales.rst:116
msgid "bs_BA"
msgstr "bs_BA"

#: ../../docs/tutorials/i18n/locales.rst:116
msgid "Bosnian (Bosnia and Herzegovina)"
msgstr "Bosnian (Bosnia and Herzegovina)"

#: ../../docs/tutorials/i18n/locales.rst:118
msgid "byn_ER"
msgstr "byn_ER"

#: ../../docs/tutorials/i18n/locales.rst:118
msgid "Bilin (Eritrea)"
msgstr "Bilin (Eritrea)"

#: ../../docs/tutorials/i18n/locales.rst:120
msgid "ca"
msgstr "ca"

#: ../../docs/tutorials/i18n/locales.rst:120
msgid "Catalan"
msgstr "Catalan"

#: ../../docs/tutorials/i18n/locales.rst:122
msgid "ca_AD"
msgstr "ca_AD"

#: ../../docs/tutorials/i18n/locales.rst:122
msgid "Catalan (Andorra)"
msgstr "Catalan (Andorra)"

#: ../../docs/tutorials/i18n/locales.rst:124
msgid "ca_ES"
msgstr "ca_ES"

#: ../../docs/tutorials/i18n/locales.rst:124
msgid "Catalan (Spain)"
msgstr "Catalan (Spain)"

#: ../../docs/tutorials/i18n/locales.rst:126
msgid "ca_FR"
msgstr "ca_FR"

#: ../../docs/tutorials/i18n/locales.rst:126
msgid "Catalan (France)"
msgstr "Catalan (France)"

#: ../../docs/tutorials/i18n/locales.rst:128
msgid "ca_IT"
msgstr "ca_IT"

#: ../../docs/tutorials/i18n/locales.rst:128
msgid "Catalan (Italy)"
msgstr "Catalan (Italy)"

#: ../../docs/tutorials/i18n/locales.rst:130
msgid "ce_RU"
msgstr "ce_RU"

#: ../../docs/tutorials/i18n/locales.rst:130
msgid "Chechen (Russia)"
msgstr "Chechen (Russia)"

#: ../../docs/tutorials/i18n/locales.rst:132
msgid "chr_US"
msgstr "chr_US"

#: ../../docs/tutorials/i18n/locales.rst:132
msgid "Cherokee (United States)"
msgstr "Cherokee (United States)"

#: ../../docs/tutorials/i18n/locales.rst:134
msgid "cmn_TW"
msgstr "cmn_TW"

#: ../../docs/tutorials/i18n/locales.rst:134
msgid "Mandarin Chinese (Taiwan)"
msgstr "Mandarin Chinese (Taiwan)"

#: ../../docs/tutorials/i18n/locales.rst:136
msgid "crh_UA"
msgstr "crh_UA"

#: ../../docs/tutorials/i18n/locales.rst:136
msgid "Crimean Tatar (Ukraine)"
msgstr "Crimean Tatar (Ukraine)"

#: ../../docs/tutorials/i18n/locales.rst:138
msgid "csb_PL"
msgstr "csb_PL"

#: ../../docs/tutorials/i18n/locales.rst:138
msgid "Kashubian (Poland)"
msgstr "Kashubian (Poland)"

#: ../../docs/tutorials/i18n/locales.rst:140
msgid "cs"
msgstr "cs"

#: ../../docs/tutorials/i18n/locales.rst:140
msgid "Czech"
msgstr "Czech"

#: ../../docs/tutorials/i18n/locales.rst:142
msgid "cs_CZ"
msgstr "cs_CZ"

#: ../../docs/tutorials/i18n/locales.rst:142
msgid "Czech (Czech Republic)"
msgstr "Czech (Czech Republic)"

#: ../../docs/tutorials/i18n/locales.rst:144
msgid "cv_RU"
msgstr "cv_RU"

#: ../../docs/tutorials/i18n/locales.rst:144
msgid "Chuvash (Russia)"
msgstr "Chuvash (Russia)"

#: ../../docs/tutorials/i18n/locales.rst:146
msgid "cy_GB"
msgstr "cy_GB"

#: ../../docs/tutorials/i18n/locales.rst:146
msgid "Welsh (United Kingdom)"
msgstr "Welsh (United Kingdom)"

#: ../../docs/tutorials/i18n/locales.rst:148
msgid "da"
msgstr "da"

#: ../../docs/tutorials/i18n/locales.rst:148
msgid "Danish"
msgstr "Danish"

#: ../../docs/tutorials/i18n/locales.rst:150
msgid "da_DK"
msgstr "da_DK"

#: ../../docs/tutorials/i18n/locales.rst:150
msgid "Danish (Denmark)"
msgstr "Danish (Denmark)"

#: ../../docs/tutorials/i18n/locales.rst:152
msgid "de"
msgstr "de"

#: ../../docs/tutorials/i18n/locales.rst:152
msgid "German"
msgstr "German"

#: ../../docs/tutorials/i18n/locales.rst:154
msgid "de_AT"
msgstr "de_AT"

#: ../../docs/tutorials/i18n/locales.rst:154
msgid "German (Austria)"
msgstr "German (Austria)"

#: ../../docs/tutorials/i18n/locales.rst:156
msgid "de_BE"
msgstr "de_BE"

#: ../../docs/tutorials/i18n/locales.rst:156
msgid "German (Belgium)"
msgstr "German (Belgium)"

#: ../../docs/tutorials/i18n/locales.rst:158
msgid "de_CH"
msgstr "de_CH"

#: ../../docs/tutorials/i18n/locales.rst:158
msgid "German (Switzerland)"
msgstr "German (Switzerland)"

#: ../../docs/tutorials/i18n/locales.rst:160
msgid "de_DE"
msgstr "de_DE"

#: ../../docs/tutorials/i18n/locales.rst:160
msgid "German (Germany)"
msgstr "German (Germany)"

#: ../../docs/tutorials/i18n/locales.rst:162
msgid "de_IT"
msgstr "de_IT"

#: ../../docs/tutorials/i18n/locales.rst:162
msgid "German (Italy)"
msgstr "German (Italy)"

#: ../../docs/tutorials/i18n/locales.rst:164
msgid "de_LU"
msgstr "de_LU"

#: ../../docs/tutorials/i18n/locales.rst:164
msgid "German (Luxembourg)"
msgstr "German (Luxembourg)"

#: ../../docs/tutorials/i18n/locales.rst:166
msgid "doi_IN"
msgstr "doi_IN"

#: ../../docs/tutorials/i18n/locales.rst:166
msgid "Dogri (India)"
msgstr "Dogri (India)"

#: ../../docs/tutorials/i18n/locales.rst:168
msgid "dv_MV"
msgstr "dv_MV"

#: ../../docs/tutorials/i18n/locales.rst:168
msgid "Dhivehi (Maldives)"
msgstr "Dhivehi (Maldives)"

#: ../../docs/tutorials/i18n/locales.rst:170
msgid "dz_BT"
msgstr "dz_BT"

#: ../../docs/tutorials/i18n/locales.rst:170
msgid "Dzongkha (Bhutan)"
msgstr "Dzongkha (Bhutan)"

#: ../../docs/tutorials/i18n/locales.rst:172
msgid "el"
msgstr "el"

#: ../../docs/tutorials/i18n/locales.rst:172
msgid "Greek"
msgstr "Greek"

#: ../../docs/tutorials/i18n/locales.rst:174
msgid "el_CY"
msgstr "el_CY"

#: ../../docs/tutorials/i18n/locales.rst:174
msgid "Greek (Cyprus)"
msgstr "Greek (Cyprus)"

#: ../../docs/tutorials/i18n/locales.rst:176
msgid "el_GR"
msgstr "el_GR"

#: ../../docs/tutorials/i18n/locales.rst:176
msgid "Greek (Greece)"
msgstr "Greek (Greece)"

#: ../../docs/tutorials/i18n/locales.rst:178
msgid "English"
msgstr "English"

#: ../../docs/tutorials/i18n/locales.rst:180
msgid "en_AG"
msgstr "en_AG"

#: ../../docs/tutorials/i18n/locales.rst:180
msgid "English (Antigua and Barbuda)"
msgstr "English (Antigua and Barbuda)"

#: ../../docs/tutorials/i18n/locales.rst:182
msgid "en_AU"
msgstr "en_AU"

#: ../../docs/tutorials/i18n/locales.rst:182
msgid "English (Australia)"
msgstr "English (Australia)"

#: ../../docs/tutorials/i18n/locales.rst:184
msgid "en_BW"
msgstr "en_BW"

#: ../../docs/tutorials/i18n/locales.rst:184
msgid "English (Botswana)"
msgstr "English (Botswana)"

#: ../../docs/tutorials/i18n/locales.rst:186
msgid "en_CA"
msgstr "en_CA"

#: ../../docs/tutorials/i18n/locales.rst:186
msgid "English (Canada)"
msgstr "English (Canada)"

#: ../../docs/tutorials/i18n/locales.rst:188
msgid "en_DK"
msgstr "en_DK"

#: ../../docs/tutorials/i18n/locales.rst:188
msgid "English (Denmark)"
msgstr "English (Denmark)"

#: ../../docs/tutorials/i18n/locales.rst:190
msgid "en_GB"
msgstr "en_GB"

#: ../../docs/tutorials/i18n/locales.rst:190
msgid "English (United Kingdom)"
msgstr "English (United Kingdom)"

#: ../../docs/tutorials/i18n/locales.rst:192
msgid "en_HK"
msgstr "en_HK"

#: ../../docs/tutorials/i18n/locales.rst:192
msgid "English (Hong Kong)"
msgstr "English (Hong Kong)"

#: ../../docs/tutorials/i18n/locales.rst:194
msgid "en_IE"
msgstr "en_IE"

#: ../../docs/tutorials/i18n/locales.rst:194
msgid "English (Ireland)"
msgstr "English (Ireland)"

#: ../../docs/tutorials/i18n/locales.rst:196
msgid "en_IL"
msgstr "en_IL"

#: ../../docs/tutorials/i18n/locales.rst:196
msgid "English (Israel)"
msgstr "English (Israel)"

#: ../../docs/tutorials/i18n/locales.rst:198
msgid "en_IN"
msgstr "en_IN"

#: ../../docs/tutorials/i18n/locales.rst:198
msgid "English (India)"
msgstr "English (India)"

#: ../../docs/tutorials/i18n/locales.rst:200
msgid "en_NG"
msgstr "en_NG"

#: ../../docs/tutorials/i18n/locales.rst:200
msgid "English (Nigeria)"
msgstr "English (Nigeria)"

#: ../../docs/tutorials/i18n/locales.rst:202
msgid "en_MT"
msgstr "en_MT"

#: ../../docs/tutorials/i18n/locales.rst:202
msgid "English (Malta)"
msgstr "English (Malta)"

#: ../../docs/tutorials/i18n/locales.rst:204
msgid "en_NZ"
msgstr "en_NZ"

#: ../../docs/tutorials/i18n/locales.rst:204
msgid "English (New Zealand)"
msgstr "English (New Zealand)"

#: ../../docs/tutorials/i18n/locales.rst:206
msgid "en_PH"
msgstr "en_PH"

#: ../../docs/tutorials/i18n/locales.rst:206
msgid "English (Philippines)"
msgstr "English (Philippines)"

#: ../../docs/tutorials/i18n/locales.rst:208
msgid "en_SG"
msgstr "en_SG"

#: ../../docs/tutorials/i18n/locales.rst:208
msgid "English (Singapore)"
msgstr "English (Singapore)"

#: ../../docs/tutorials/i18n/locales.rst:210
msgid "en_US"
msgstr "en_US"

#: ../../docs/tutorials/i18n/locales.rst:210
msgid "English (United States)"
msgstr "English (United States)"

#: ../../docs/tutorials/i18n/locales.rst:212
msgid "en_ZA"
msgstr "en_ZA"

#: ../../docs/tutorials/i18n/locales.rst:212
msgid "English (South Africa)"
msgstr "English (South Africa)"

#: ../../docs/tutorials/i18n/locales.rst:214
msgid "en_ZM"
msgstr "en_ZM"

#: ../../docs/tutorials/i18n/locales.rst:214
msgid "English (Zambia)"
msgstr "English (Zambia)"

#: ../../docs/tutorials/i18n/locales.rst:216
msgid "en_ZW"
msgstr "en_ZW"

#: ../../docs/tutorials/i18n/locales.rst:216
msgid "English (Zimbabwe)"
msgstr "英语(津巴布韦)"

#: ../../docs/tutorials/i18n/locales.rst:218
msgid "eo"
msgstr "eo"

#: ../../docs/tutorials/i18n/locales.rst:218
msgid "Esperanto"
msgstr "世界语"

#: ../../docs/tutorials/i18n/locales.rst:220
msgid "Spanish"
msgstr "西班牙语"

#: ../../docs/tutorials/i18n/locales.rst:222
msgid "es_AR"
msgstr "es_AR"

#: ../../docs/tutorials/i18n/locales.rst:222
msgid "Spanish (Argentina)"
msgstr "Spanish (Argentina)"

#: ../../docs/tutorials/i18n/locales.rst:224
msgid "es_BO"
msgstr "es_BO"

#: ../../docs/tutorials/i18n/locales.rst:224
msgid "Spanish (Bolivia)"
msgstr "Spanish (Bolivia)"

#: ../../docs/tutorials/i18n/locales.rst:226
msgid "es_CL"
msgstr "es_CL"

#: ../../docs/tutorials/i18n/locales.rst:226
msgid "Spanish (Chile)"
msgstr "Spanish (Chile)"

#: ../../docs/tutorials/i18n/locales.rst:228
msgid "es_CO"
msgstr "es_CO"

#: ../../docs/tutorials/i18n/locales.rst:228
msgid "Spanish (Colombia)"
msgstr "Spanish (Colombia)"

#: ../../docs/tutorials/i18n/locales.rst:230
msgid "es_CR"
msgstr "es_CR"

#: ../../docs/tutorials/i18n/locales.rst:230
msgid "Spanish (Costa Rica)"
msgstr "Spanish (Costa Rica)"

#: ../../docs/tutorials/i18n/locales.rst:232
msgid "en_CU"
msgstr "en_CU"

#: ../../docs/tutorials/i18n/locales.rst:232
msgid "Spanish (Cuba)"
msgstr "Spanish (Cuba)"

#: ../../docs/tutorials/i18n/locales.rst:234
msgid "es_DO"
msgstr "es_DO"

#: ../../docs/tutorials/i18n/locales.rst:234
msgid "Spanish (Dominican Republic)"
msgstr "Spanish (Dominican Republic)"

#: ../../docs/tutorials/i18n/locales.rst:236
msgid "es_EC"
msgstr "es_EC"

#: ../../docs/tutorials/i18n/locales.rst:236
msgid "Spanish (Ecuador)"
msgstr "Spanish (Ecuador)"

#: ../../docs/tutorials/i18n/locales.rst:238
msgid "es_ES"
msgstr "es_ES"

#: ../../docs/tutorials/i18n/locales.rst:238
msgid "Spanish (Spain)"
msgstr "Spanish (Spain)"

#: ../../docs/tutorials/i18n/locales.rst:240
msgid "es_GT"
msgstr "es_GT"

#: ../../docs/tutorials/i18n/locales.rst:240
msgid "Spanish (Guatemala)"
msgstr "Spanish (Guatemala)"

#: ../../docs/tutorials/i18n/locales.rst:242
msgid "es_HN"
msgstr "es_HN"

#: ../../docs/tutorials/i18n/locales.rst:242
msgid "Spanish (Honduras)"
msgstr "Spanish (Honduras)"

#: ../../docs/tutorials/i18n/locales.rst:244
msgid "es_MX"
msgstr "es_MX"

#: ../../docs/tutorials/i18n/locales.rst:244
msgid "Spanish (Mexico)"
msgstr "Spanish (Mexico)"

#: ../../docs/tutorials/i18n/locales.rst:246
msgid "es_NI"
msgstr "es_NI"

#: ../../docs/tutorials/i18n/locales.rst:246
msgid "Spanish (Nicaragua)"
msgstr "Spanish (Nicaragua)"

#: ../../docs/tutorials/i18n/locales.rst:248
msgid "es_PA"
msgstr "es_PA"

#: ../../docs/tutorials/i18n/locales.rst:248
msgid "Spanish (Panama)"
msgstr "Spanish (Panama)"

#: ../../docs/tutorials/i18n/locales.rst:250
msgid "es_PE"
msgstr "es_PE"

#: ../../docs/tutorials/i18n/locales.rst:250
msgid "Spanish (Peru)"
msgstr "Spanish (Peru)"

#: ../../docs/tutorials/i18n/locales.rst:252
msgid "es_PR"
msgstr "es_PR"

#: ../../docs/tutorials/i18n/locales.rst:252
msgid "Spanish (Puerto Rico)"
msgstr "Spanish (Puerto Rico)"

#: ../../docs/tutorials/i18n/locales.rst:254
msgid "es_PY"
msgstr "es_PY"

#: ../../docs/tutorials/i18n/locales.rst:254
msgid "Spanish (Paraguay)"
msgstr "Spanish (Paraguay)"

#: ../../docs/tutorials/i18n/locales.rst:256
msgid "es_SV"
msgstr "es_SV"

#: ../../docs/tutorials/i18n/locales.rst:256
msgid "Spanish (El Salvador)"
msgstr "Spanish (El Salvador)"

#: ../../docs/tutorials/i18n/locales.rst:258
msgid "es_US"
msgstr "es_US"

#: ../../docs/tutorials/i18n/locales.rst:258
msgid "Spanish (United States)"
msgstr "Spanish (United States)"

#: ../../docs/tutorials/i18n/locales.rst:260
msgid "es_UY"
msgstr "es_UY"

#: ../../docs/tutorials/i18n/locales.rst:260
msgid "Spanish (Uruguay)"
msgstr "Spanish (Uruguay)"

#: ../../docs/tutorials/i18n/locales.rst:262
msgid "es_VE"
msgstr "es_VE"

#: ../../docs/tutorials/i18n/locales.rst:262
msgid "Spanish (Venezuela)"
msgstr "Spanish (Venezuela)"

#: ../../docs/tutorials/i18n/locales.rst:264
msgid "et"
msgstr "et"

#: ../../docs/tutorials/i18n/locales.rst:264
msgid "Estonian"
msgstr "Estonian"

#: ../../docs/tutorials/i18n/locales.rst:266
msgid "et_EE"
msgstr "et_EE"

#: ../../docs/tutorials/i18n/locales.rst:266
msgid "Estonian (Estonia)"
msgstr "Estonian (Estonia)"

#: ../../docs/tutorials/i18n/locales.rst:268
msgid "eu"
msgstr "eu"

#: ../../docs/tutorials/i18n/locales.rst:268
msgid "Basque"
msgstr "Basque"

#: ../../docs/tutorials/i18n/locales.rst:270
msgid "eu_ES"
msgstr "eu_ES"

#: ../../docs/tutorials/i18n/locales.rst:270
msgid "Basque (Spain)"
msgstr "Basque (Spain)"

#: ../../docs/tutorials/i18n/locales.rst:272
msgid "fa"
msgstr "fa"

#: ../../docs/tutorials/i18n/locales.rst:272
msgid "Persian"
msgstr "Persian"

#: ../../docs/tutorials/i18n/locales.rst:274
msgid "fa_IR"
msgstr "fa_IR"

#: ../../docs/tutorials/i18n/locales.rst:274
msgid "Persian (Iran)"
msgstr "Persian (Iran)"

#: ../../docs/tutorials/i18n/locales.rst:276
msgid "ff_SN"
msgstr "ff_SN"

#: ../../docs/tutorials/i18n/locales.rst:276
msgid "Fulah (Senegal)"
msgstr "Fulah (Senegal)"

#: ../../docs/tutorials/i18n/locales.rst:278
msgid "fi"
msgstr "fi"

#: ../../docs/tutorials/i18n/locales.rst:278
msgid "Finnish"
msgstr "Finnish"

#: ../../docs/tutorials/i18n/locales.rst:280
msgid "fi_FI"
msgstr "fi_FI"

#: ../../docs/tutorials/i18n/locales.rst:280
msgid "Finnish (Finland)"
msgstr "Finnish (Finland)"

#: ../../docs/tutorials/i18n/locales.rst:282
msgid "fil_PH"
msgstr "fil_PH"

#: ../../docs/tutorials/i18n/locales.rst:282
msgid "Filipino (Philippines)"
msgstr "Filipino (Philippines)"

#: ../../docs/tutorials/i18n/locales.rst:284
msgid "fo_FO"
msgstr "fo_FO"

#: ../../docs/tutorials/i18n/locales.rst:284
msgid "Faroese (Faroe Islands)"
msgstr "Faroese (Faroe Islands)"

#: ../../docs/tutorials/i18n/locales.rst:286
msgid "fr"
msgstr "fr"

#: ../../docs/tutorials/i18n/locales.rst:286
msgid "French"
msgstr "French"

#: ../../docs/tutorials/i18n/locales.rst:288
msgid "fr_BE"
msgstr "fr_BE"

#: ../../docs/tutorials/i18n/locales.rst:288
msgid "French (Belgium)"
msgstr "French (Belgium)"

#: ../../docs/tutorials/i18n/locales.rst:290
msgid "fr_CA"
msgstr "fr_CA"

#: ../../docs/tutorials/i18n/locales.rst:290
msgid "French (Canada)"
msgstr "French (Canada)"

#: ../../docs/tutorials/i18n/locales.rst:292
msgid "fr_CH"
msgstr "fr_CH"

#: ../../docs/tutorials/i18n/locales.rst:292
msgid "French (Switzerland)"
msgstr "French (Switzerland)"

#: ../../docs/tutorials/i18n/locales.rst:294
msgid "fr_FR"
msgstr "fr_FR"

#: ../../docs/tutorials/i18n/locales.rst:294
msgid "French (France)"
msgstr "French (France)"

#: ../../docs/tutorials/i18n/locales.rst:296
msgid "fr_LU"
msgstr "fr_LU"

#: ../../docs/tutorials/i18n/locales.rst:296
msgid "French (Luxembourg)"
msgstr "French (Luxembourg)"

#: ../../docs/tutorials/i18n/locales.rst:298
msgid "fur_IT"
msgstr "fur_IT"

#: ../../docs/tutorials/i18n/locales.rst:298
msgid "Friulian (Italy)"
msgstr "Friulian (Italy)"

#: ../../docs/tutorials/i18n/locales.rst:300
msgid "fy_DE"
msgstr "fy_DE"

#: ../../docs/tutorials/i18n/locales.rst:300
msgid "Western Frisian (Germany)"
msgstr "Western Frisian (Germany)"

#: ../../docs/tutorials/i18n/locales.rst:302
msgid "fy_NL"
msgstr "fy_NL"

#: ../../docs/tutorials/i18n/locales.rst:302
msgid "Western Frisian (Netherlands)"
msgstr "Western Frisian (Netherlands)"

#: ../../docs/tutorials/i18n/locales.rst:304
msgid "ga"
msgstr "ga"

#: ../../docs/tutorials/i18n/locales.rst:304
msgid "Irish"
msgstr "Irish"

#: ../../docs/tutorials/i18n/locales.rst:306
msgid "ga_IE"
msgstr "ga_IE"

#: ../../docs/tutorials/i18n/locales.rst:306
msgid "Irish (Ireland)"
msgstr "Irish (Ireland)"

#: ../../docs/tutorials/i18n/locales.rst:308
msgid "gd_GB"
msgstr "gd_GB"

#: ../../docs/tutorials/i18n/locales.rst:308
msgid "Scottish Gaelic (United Kingdom)"
msgstr "Scottish Gaelic (United Kingdom)"

#: ../../docs/tutorials/i18n/locales.rst:310
msgid "gez_ER"
msgstr "gez_ER"

#: ../../docs/tutorials/i18n/locales.rst:310
msgid "Geez (Eritrea)"
msgstr "Geez (Eritrea)"

#: ../../docs/tutorials/i18n/locales.rst:312
msgid "gez_ET"
msgstr "gez_ET"

#: ../../docs/tutorials/i18n/locales.rst:312
msgid "Geez (Ethiopia)"
msgstr "Geez (Ethiopia)"

#: ../../docs/tutorials/i18n/locales.rst:314
msgid "gl_ES"
msgstr "gl_ES"

#: ../../docs/tutorials/i18n/locales.rst:314
msgid "Galician (Spain)"
msgstr "Galician (Spain)"

#: ../../docs/tutorials/i18n/locales.rst:316
msgid "gu_IN"
msgstr "gu_IN"

#: ../../docs/tutorials/i18n/locales.rst:316
msgid "Gujarati (India)"
msgstr "Gujarati (India)"

#: ../../docs/tutorials/i18n/locales.rst:318
msgid "gv_GB"
msgstr "gv_GB"

#: ../../docs/tutorials/i18n/locales.rst:318
msgid "Manx (United Kingdom)"
msgstr "Manx (United Kingdom)"

#: ../../docs/tutorials/i18n/locales.rst:320
msgid "hak_TW"
msgstr "hak_TW"

#: ../../docs/tutorials/i18n/locales.rst:320
msgid "Hakka Chinese (Taiwan)"
msgstr "客家汉语(台湾)"

#: ../../docs/tutorials/i18n/locales.rst:322
msgid "ha_NG"
msgstr "ha_NG"

#: ../../docs/tutorials/i18n/locales.rst:322
msgid "Hausa (Nigeria)"
msgstr "Hausa (Nigeria)"

#: ../../docs/tutorials/i18n/locales.rst:324
msgid "he"
msgstr "he"

#: ../../docs/tutorials/i18n/locales.rst:324
msgid "Hebrew"
msgstr "Hebrew"

#: ../../docs/tutorials/i18n/locales.rst:326
msgid "he_IL"
msgstr "he_IL"

#: ../../docs/tutorials/i18n/locales.rst:326
msgid "Hebrew (Israel)"
msgstr "Hebrew (Israel)"

#: ../../docs/tutorials/i18n/locales.rst:328
msgid "hi"
msgstr "hi"

#: ../../docs/tutorials/i18n/locales.rst:328
msgid "Hindi"
msgstr "Hindi"

#: ../../docs/tutorials/i18n/locales.rst:330
msgid "hi_IN"
msgstr "hi_IN"

#: ../../docs/tutorials/i18n/locales.rst:330
msgid "Hindi (India)"
msgstr "Hindi (India)"

#: ../../docs/tutorials/i18n/locales.rst:332
msgid "hne_IN"
msgstr "hne_IN"

#: ../../docs/tutorials/i18n/locales.rst:332
msgid "Chhattisgarhi (India)"
msgstr "Chhattisgarhi (India)"

#: ../../docs/tutorials/i18n/locales.rst:334
msgid "hr"
msgstr "hr"

#: ../../docs/tutorials/i18n/locales.rst:334
msgid "Croatian"
msgstr "Croatian"

#: ../../docs/tutorials/i18n/locales.rst:336
msgid "hr_HR"
msgstr "hr_HR"

#: ../../docs/tutorials/i18n/locales.rst:336
msgid "Croatian (Croatia)"
msgstr "Croatian (Croatia)"

#: ../../docs/tutorials/i18n/locales.rst:338
msgid "hsb_DE"
msgstr "hsb_DE"

#: ../../docs/tutorials/i18n/locales.rst:338
msgid "Upper Sorbian (Germany)"
msgstr "Upper Sorbian (Germany)"

#: ../../docs/tutorials/i18n/locales.rst:340
msgid "ht_HT"
msgstr "ht_HT"

#: ../../docs/tutorials/i18n/locales.rst:340
msgid "Haitian (Haiti)"
msgstr "Haitian (Haiti)"

#: ../../docs/tutorials/i18n/locales.rst:342
msgid "hu"
msgstr "hu"

#: ../../docs/tutorials/i18n/locales.rst:342
msgid "Hungarian"
msgstr "Hungarian"

#: ../../docs/tutorials/i18n/locales.rst:344
msgid "hu_HU"
msgstr "hu_HU"

#: ../../docs/tutorials/i18n/locales.rst:344
msgid "Hungarian (Hungary)"
msgstr "Hungarian (Hungary)"

#: ../../docs/tutorials/i18n/locales.rst:346
msgid "hus_MX"
msgstr "hus_MX"

#: ../../docs/tutorials/i18n/locales.rst:346
msgid "Huastec (Mexico)"
msgstr "Huastec (Mexico)"

#: ../../docs/tutorials/i18n/locales.rst:348
msgid "hy_AM"
msgstr "hy_AM"

#: ../../docs/tutorials/i18n/locales.rst:348
msgid "Armenian (Armenia)"
msgstr "Armenian (Armenia)"

#: ../../docs/tutorials/i18n/locales.rst:350
msgid "ia_FR"
msgstr "ia_FR"

#: ../../docs/tutorials/i18n/locales.rst:350
msgid "Interlingua (France)"
msgstr "Interlingua (France)"

#: ../../docs/tutorials/i18n/locales.rst:352
msgid "Indonesian"
msgstr "Indonesian"

#: ../../docs/tutorials/i18n/locales.rst:354
msgid "id_ID"
msgstr "id_ID"

#: ../../docs/tutorials/i18n/locales.rst:354
msgid "Indonesian (Indonesia)"
msgstr "Indonesian (Indonesia)"

#: ../../docs/tutorials/i18n/locales.rst:356
msgid "ig_NG"
msgstr "ig_NG"

#: ../../docs/tutorials/i18n/locales.rst:356
msgid "Igbo (Nigeria)"
msgstr "Igbo (Nigeria)"

#: ../../docs/tutorials/i18n/locales.rst:358
msgid "ik_CA"
msgstr "ik_CA"

#: ../../docs/tutorials/i18n/locales.rst:358
msgid "Inupiaq (Canada)"
msgstr "Inupiaq (Canada)"

#: ../../docs/tutorials/i18n/locales.rst:360
msgid "Icelandic"
msgstr "Icelandic"

#: ../../docs/tutorials/i18n/locales.rst:362
msgid "is_IS"
msgstr "is_IS"

#: ../../docs/tutorials/i18n/locales.rst:362
msgid "Icelandic (Iceland)"
msgstr "Icelandic (Iceland)"

#: ../../docs/tutorials/i18n/locales.rst:364
msgid "it"
msgstr "it"

#: ../../docs/tutorials/i18n/locales.rst:364
msgid "Italian"
msgstr "Italian"

#: ../../docs/tutorials/i18n/locales.rst:366
msgid "it_CH"
msgstr "it_CH"

#: ../../docs/tutorials/i18n/locales.rst:366
msgid "Italian (Switzerland)"
msgstr "Italian (Switzerland)"

#: ../../docs/tutorials/i18n/locales.rst:368
msgid "it_IT"
msgstr "it_IT"

#: ../../docs/tutorials/i18n/locales.rst:368
msgid "Italian (Italy)"
msgstr "Italian (Italy)"

#: ../../docs/tutorials/i18n/locales.rst:370
msgid "iu_CA"
msgstr "iu_CA"

#: ../../docs/tutorials/i18n/locales.rst:370
msgid "Inuktitut (Canada)"
msgstr "Inuktitut (Canada)"

#: ../../docs/tutorials/i18n/locales.rst:372
msgid "Japanese"
msgstr "Japanese"

#: ../../docs/tutorials/i18n/locales.rst:374
msgid "ja_JP"
msgstr "ja_JP"

#: ../../docs/tutorials/i18n/locales.rst:374
msgid "Japanese (Japan)"
msgstr "Japanese (Japan)"

#: ../../docs/tutorials/i18n/locales.rst:376
msgid "kab_DZ"
msgstr "kab_DZ"

#: ../../docs/tutorials/i18n/locales.rst:376
msgid "Kabyle (Algeria)"
msgstr "Kabyle (Algeria)"

#: ../../docs/tutorials/i18n/locales.rst:378
msgid "ka_GE"
msgstr "ka_GE"

#: ../../docs/tutorials/i18n/locales.rst:378
msgid "Georgian (Georgia)"
msgstr "Georgian (Georgia)"

#: ../../docs/tutorials/i18n/locales.rst:380
msgid "kk_KZ"
msgstr "kk_KZ"

#: ../../docs/tutorials/i18n/locales.rst:380
msgid "Kazakh (Kazakhstan)"
msgstr "Kazakh (Kazakhstan)"

#: ../../docs/tutorials/i18n/locales.rst:382
msgid "kl_GL"
msgstr "kl_GL"

#: ../../docs/tutorials/i18n/locales.rst:382
msgid "Kalaallisut (Greenland)"
msgstr "Kalaallisut (Greenland)"

#: ../../docs/tutorials/i18n/locales.rst:384
msgid "km_KH"
msgstr "km_KH"

#: ../../docs/tutorials/i18n/locales.rst:384
msgid "Central Khmer (Cambodia)"
msgstr "Central Khmer (Cambodia)"

#: ../../docs/tutorials/i18n/locales.rst:386
msgid "kn_IN"
msgstr "kn_IN"

#: ../../docs/tutorials/i18n/locales.rst:386
msgid "Kannada (India)"
msgstr "Kannada (India)"

#: ../../docs/tutorials/i18n/locales.rst:388
msgid "kok_IN"
msgstr "kok_IN"

#: ../../docs/tutorials/i18n/locales.rst:388
msgid "Konkani (India)"
msgstr "Konkani (India)"

#: ../../docs/tutorials/i18n/locales.rst:390
msgid "ko"
msgstr "ko"

#: ../../docs/tutorials/i18n/locales.rst:390
msgid "Korean"
msgstr "Korean"

#: ../../docs/tutorials/i18n/locales.rst:392
msgid "ko_KR"
msgstr "ko_KR"

#: ../../docs/tutorials/i18n/locales.rst:392
msgid "Korean (South Korea)"
msgstr "Korean (South Korea)"

#: ../../docs/tutorials/i18n/locales.rst:394
msgid "ks_IN"
msgstr "ks_IN"

#: ../../docs/tutorials/i18n/locales.rst:394
msgid "Kashmiri (India)"
msgstr "Kashmiri (India)"

#: ../../docs/tutorials/i18n/locales.rst:396
msgid "ku"
msgstr "ku"

#: ../../docs/tutorials/i18n/locales.rst:396
msgid "Kurdish"
msgstr "Kurdish"

#: ../../docs/tutorials/i18n/locales.rst:398
msgid "ku_TR"
msgstr "ku_TR"

#: ../../docs/tutorials/i18n/locales.rst:398
msgid "Kurdish (Turkey)"
msgstr "Kurdish (Turkey)"

#: ../../docs/tutorials/i18n/locales.rst:400
msgid "kw_GB"
msgstr "kw_GB"

#: ../../docs/tutorials/i18n/locales.rst:400
msgid "Cornish (United Kingdom)"
msgstr "Cornish (United Kingdom)"

#: ../../docs/tutorials/i18n/locales.rst:402
msgid "ky_KG"
msgstr "ky_KG"

#: ../../docs/tutorials/i18n/locales.rst:402
msgid "Kirghiz (Kyrgyzstan)"
msgstr "Kirghiz (Kyrgyzstan)"

#: ../../docs/tutorials/i18n/locales.rst:404
msgid "lb_LU"
msgstr "lb_LU"

#: ../../docs/tutorials/i18n/locales.rst:404
msgid "Luxembourgish (Luxembourg)"
msgstr "Luxembourgish (Luxembourg)"

#: ../../docs/tutorials/i18n/locales.rst:406
msgid "lg_UG"
msgstr "lg_UG"

#: ../../docs/tutorials/i18n/locales.rst:406
msgid "Ganda (Uganda)"
msgstr "Ganda (Uganda)"

#: ../../docs/tutorials/i18n/locales.rst:408
msgid "li_BE"
msgstr "li_BE"

#: ../../docs/tutorials/i18n/locales.rst:408
msgid "Limburgan (Belgium)"
msgstr "Limburgan (Belgium)"

#: ../../docs/tutorials/i18n/locales.rst:410
msgid "li_NL"
msgstr "li_NL"

#: ../../docs/tutorials/i18n/locales.rst:410
msgid "Limburgan (Netherlands)"
msgstr "Limburgan (Netherlands)"

#: ../../docs/tutorials/i18n/locales.rst:412
msgid "lij_IT"
msgstr "lij_IT"

#: ../../docs/tutorials/i18n/locales.rst:412
msgid "Ligurian (Italy)"
msgstr "Ligurian (Italy)"

#: ../../docs/tutorials/i18n/locales.rst:414
msgid "ln_CD"
msgstr "ln_CD"

#: ../../docs/tutorials/i18n/locales.rst:414
msgid "Lingala (Congo)"
msgstr "Lingala (Congo)"

#: ../../docs/tutorials/i18n/locales.rst:416
msgid "lo_LA"
msgstr "lo_LA"

#: ../../docs/tutorials/i18n/locales.rst:416
msgid "Lao (Laos)"
msgstr "Lao (Laos)"

#: ../../docs/tutorials/i18n/locales.rst:418
msgid "lt"
msgstr "lt"

#: ../../docs/tutorials/i18n/locales.rst:418
msgid "Lithuanian"
msgstr "Lithuanian"

#: ../../docs/tutorials/i18n/locales.rst:420
msgid "lt_LT"
msgstr "lt_LT"

#: ../../docs/tutorials/i18n/locales.rst:420
msgid "Lithuanian (Lithuania)"
msgstr "Lithuanian (Lithuania)"

#: ../../docs/tutorials/i18n/locales.rst:422
msgid "lv"
msgstr "lv"

#: ../../docs/tutorials/i18n/locales.rst:422
msgid "Latvian"
msgstr "Latvian"

#: ../../docs/tutorials/i18n/locales.rst:424
msgid "lv_LV"
msgstr "lv_LV"

#: ../../docs/tutorials/i18n/locales.rst:424
msgid "Latvian (Latvia)"
msgstr "Latvian (Latvia)"

#: ../../docs/tutorials/i18n/locales.rst:426
msgid "lzh_TW"
msgstr "lzh_TW"

#: ../../docs/tutorials/i18n/locales.rst:426
msgid "Literary Chinese (Taiwan)"
msgstr "Literary Chinese (Taiwan)"

#: ../../docs/tutorials/i18n/locales.rst:428
msgid "mag_IN"
msgstr "mag_IN"

#: ../../docs/tutorials/i18n/locales.rst:428
msgid "Magahi (India)"
msgstr "Magahi (India)"

#: ../../docs/tutorials/i18n/locales.rst:430
msgid "mai_IN"
msgstr "mai_IN"

#: ../../docs/tutorials/i18n/locales.rst:430
msgid "Maithili (India)"
msgstr "Maithili (India)"

#: ../../docs/tutorials/i18n/locales.rst:432
msgid "mg_MG"
msgstr "mg_MG"

#: ../../docs/tutorials/i18n/locales.rst:432
msgid "Malagasy (Madagascar)"
msgstr "Malagasy (Madagascar)"

#: ../../docs/tutorials/i18n/locales.rst:434
msgid "mh_MH"
msgstr "mh_MH"

#: ../../docs/tutorials/i18n/locales.rst:434
msgid "Marshallese (Marshall Islands)"
msgstr "Marshallese (Marshall Islands)"

#: ../../docs/tutorials/i18n/locales.rst:436
msgid "mhr_RU"
msgstr "mhr_RU"

#: ../../docs/tutorials/i18n/locales.rst:436
msgid "Eastern Mari (Russia)"
msgstr "Eastern Mari (Russia)"

#: ../../docs/tutorials/i18n/locales.rst:438
msgid "mi_NZ"
msgstr "mi_NZ"

#: ../../docs/tutorials/i18n/locales.rst:438
msgid "Maori (New Zealand)"
msgstr "Maori (New Zealand)"

#: ../../docs/tutorials/i18n/locales.rst:440
msgid "miq_NI"
msgstr "miq_NI"

#: ../../docs/tutorials/i18n/locales.rst:440
msgid "Mískito  (Nicaragua)"
msgstr "Mískito  (Nicaragua)"

#: ../../docs/tutorials/i18n/locales.rst:442
msgid "mk"
msgstr "mk"

#: ../../docs/tutorials/i18n/locales.rst:442
msgid "Macedonian"
msgstr "Macedonian"

#: ../../docs/tutorials/i18n/locales.rst:444
msgid "mk_MK"
msgstr "mk_MK"

#: ../../docs/tutorials/i18n/locales.rst:444
msgid "Macedonian (Macedonia)"
msgstr "Macedonian (Macedonia)"

#: ../../docs/tutorials/i18n/locales.rst:446
msgid "ml_IN"
msgstr "ml_IN"

#: ../../docs/tutorials/i18n/locales.rst:446
msgid "Malayalam (India)"
msgstr "Malayalam (India)"

#: ../../docs/tutorials/i18n/locales.rst:448
msgid "mni_IN"
msgstr "mni_IN"

#: ../../docs/tutorials/i18n/locales.rst:448
msgid "Manipuri (India)"
msgstr "Manipuri (India)"

#: ../../docs/tutorials/i18n/locales.rst:450
msgid "mn_MN"
msgstr "mn_MN"

#: ../../docs/tutorials/i18n/locales.rst:450
msgid "Mongolian (Mongolia)"
msgstr "Mongolian (Mongolia)"

#: ../../docs/tutorials/i18n/locales.rst:452
msgid "mr_IN"
msgstr "mr_IN"

#: ../../docs/tutorials/i18n/locales.rst:452
msgid "Marathi (India)"
msgstr "Marathi (India)"

#: ../../docs/tutorials/i18n/locales.rst:454
msgid "ms"
msgstr "ms"

#: ../../docs/tutorials/i18n/locales.rst:454
msgid "Malay"
msgstr "Malay"

#: ../../docs/tutorials/i18n/locales.rst:456
msgid "ms_MY"
msgstr "ms_MY"

#: ../../docs/tutorials/i18n/locales.rst:456
msgid "Malay (Malaysia)"
msgstr "Malay (Malaysia)"

#: ../../docs/tutorials/i18n/locales.rst:458
msgid "mt"
msgstr "mt"

#: ../../docs/tutorials/i18n/locales.rst:458
msgid "Maltese"
msgstr "Maltese"

#: ../../docs/tutorials/i18n/locales.rst:460
msgid "mt_MT"
msgstr "mt_MT"

#: ../../docs/tutorials/i18n/locales.rst:460
msgid "Maltese (Malta)"
msgstr "Maltese (Malta)"

#: ../../docs/tutorials/i18n/locales.rst:462
msgid "my_MM"
msgstr "my_MM"

#: ../../docs/tutorials/i18n/locales.rst:462
msgid "Burmese (Myanmar)"
msgstr "Burmese (Myanmar)"

#: ../../docs/tutorials/i18n/locales.rst:464
msgid "myv_RU"
msgstr "myv_RU"

#: ../../docs/tutorials/i18n/locales.rst:464
msgid "Erzya  (Russia)"
msgstr "Erzya(Russia)"

#: ../../docs/tutorials/i18n/locales.rst:466
msgid "nah_MX"
msgstr "nah_MX"

#: ../../docs/tutorials/i18n/locales.rst:466
msgid "Nahuatl languages (Mexico)"
msgstr "Nahuatl languages (Mexico)"

#: ../../docs/tutorials/i18n/locales.rst:468
msgid "nan_TW"
msgstr "nan_TW"

#: ../../docs/tutorials/i18n/locales.rst:468
msgid "Min Nan Chinese (Taiwan)"
msgstr "Min Nan Chinese (Taiwan)"

#: ../../docs/tutorials/i18n/locales.rst:470
msgid "nb"
msgstr "nb"

#: ../../docs/tutorials/i18n/locales.rst:470
msgid "Norwegian Bokmål"
msgstr "Norwegian Bokmål"

#: ../../docs/tutorials/i18n/locales.rst:472
msgid "nb_NO"
msgstr "nb_NO"

#: ../../docs/tutorials/i18n/locales.rst:472
msgid "Norwegian Bokmål (Norway)"
msgstr "Norwegian Bokmål (Norway)"

#: ../../docs/tutorials/i18n/locales.rst:474
msgid "nds_DE"
msgstr "nds_DE"

#: ../../docs/tutorials/i18n/locales.rst:474
msgid "Low German (Germany)"
msgstr "Low German (Germany)"

#: ../../docs/tutorials/i18n/locales.rst:476
msgid "nds_NL"
msgstr "nds_NL"

#: ../../docs/tutorials/i18n/locales.rst:476
msgid "Low German (Netherlands)"
msgstr "Low German (Netherlands)"

#: ../../docs/tutorials/i18n/locales.rst:478
msgid "ne_NP"
msgstr "ne_NP"

#: ../../docs/tutorials/i18n/locales.rst:478
msgid "Nepali (Nepal)"
msgstr "Nepali (Nepal)"

#: ../../docs/tutorials/i18n/locales.rst:480
msgid "nhn_MX"
msgstr "nhn_MX"

#: ../../docs/tutorials/i18n/locales.rst:480
msgid "Central Nahuatl (Mexico)"
msgstr "Central Nahuatl (Mexico)"

#: ../../docs/tutorials/i18n/locales.rst:482
msgid "niu_NU"
msgstr "niu_NU"

#: ../../docs/tutorials/i18n/locales.rst:482
msgid "Niuean (Niue)"
msgstr "Niuean (Niue)"

#: ../../docs/tutorials/i18n/locales.rst:484
msgid "niu_NZ"
msgstr "niu_NZ"

#: ../../docs/tutorials/i18n/locales.rst:484
msgid "Niuean (New Zealand)"
msgstr "Niuean (New Zealand)"

#: ../../docs/tutorials/i18n/locales.rst:486
msgid "nl"
msgstr "nl"

#: ../../docs/tutorials/i18n/locales.rst:486
msgid "Dutch"
msgstr "Dutch"

#: ../../docs/tutorials/i18n/locales.rst:488
msgid "nl_AW"
msgstr "nl_AW"

#: ../../docs/tutorials/i18n/locales.rst:488
msgid "Dutch (Aruba)"
msgstr "Dutch (Aruba)"

#: ../../docs/tutorials/i18n/locales.rst:490
msgid "nl_BE"
msgstr "nl_BE"

#: ../../docs/tutorials/i18n/locales.rst:490
msgid "Dutch (Belgium)"
msgstr "Dutch (Belgium)"

#: ../../docs/tutorials/i18n/locales.rst:492
msgid "nl_NL"
msgstr "nl_NL"

#: ../../docs/tutorials/i18n/locales.rst:492
msgid "Dutch (Netherlands)"
msgstr "Dutch (Netherlands)"

#: ../../docs/tutorials/i18n/locales.rst:494
msgid "nn"
msgstr "nn"

#: ../../docs/tutorials/i18n/locales.rst:494
msgid "Norwegian Nynorsk"
msgstr "Norwegian Nynorsk"

#: ../../docs/tutorials/i18n/locales.rst:496
msgid "nn_NO"
msgstr "nn_NO"

#: ../../docs/tutorials/i18n/locales.rst:496
msgid "Norwegian Nynorsk (Norway)"
msgstr "Norwegian Nynorsk (Norway)"

#: ../../docs/tutorials/i18n/locales.rst:498
msgid "no"
msgstr "no"

#: ../../docs/tutorials/i18n/locales.rst:498
msgid "Norwegian"
msgstr "Norwegian"

#: ../../docs/tutorials/i18n/locales.rst:500
msgid "no_NO"
msgstr "no_NO"

#: ../../docs/tutorials/i18n/locales.rst:500
msgid "Norwegian (Norway)"
msgstr "Norwegian (Norway)"

#: ../../docs/tutorials/i18n/locales.rst:502
msgid "nr_ZA"
msgstr "nr_ZA"

#: ../../docs/tutorials/i18n/locales.rst:502
msgid "South Ndebele (South Africa)"
msgstr "South Ndebele (South Africa)"

#: ../../docs/tutorials/i18n/locales.rst:504
msgid "nso_ZA"
msgstr "nso_ZA"

#: ../../docs/tutorials/i18n/locales.rst:504
msgid "Pedi (South Africa)"
msgstr "Pedi (South Africa)"

#: ../../docs/tutorials/i18n/locales.rst:506
msgid "oc_FR"
msgstr "oc_FR"

#: ../../docs/tutorials/i18n/locales.rst:506
msgid "Occitan (France)"
msgstr "Occitan (France)"

#: ../../docs/tutorials/i18n/locales.rst:508
msgid "om"
msgstr "om"

#: ../../docs/tutorials/i18n/locales.rst:508
msgid "Oromo"
msgstr "Oromo"

#: ../../docs/tutorials/i18n/locales.rst:510
msgid "om_ET"
msgstr "om_ET"

#: ../../docs/tutorials/i18n/locales.rst:510
msgid "Oromo (Ethiopia)"
msgstr "Oromo (Ethiopia)"

#: ../../docs/tutorials/i18n/locales.rst:512
msgid "om_KE"
msgstr "om_KE"

#: ../../docs/tutorials/i18n/locales.rst:512
msgid "Oromo (Kenya)"
msgstr "Oromo (Kenya)"

#: ../../docs/tutorials/i18n/locales.rst:514
msgid "or_IN"
msgstr "or_IN"

#: ../../docs/tutorials/i18n/locales.rst:514
msgid "Oriya (India)"
msgstr "Oriya (India)"

#: ../../docs/tutorials/i18n/locales.rst:516
msgid "os_RU"
msgstr "os_RU"

#: ../../docs/tutorials/i18n/locales.rst:516
msgid "Ossetian (Russia)"
msgstr "Ossetian (Russia)"

#: ../../docs/tutorials/i18n/locales.rst:518
msgid "pa_IN"
msgstr "pa_IN"

#: ../../docs/tutorials/i18n/locales.rst:518
msgid "Panjabi (India)"
msgstr "Panjabi (India)"

#: ../../docs/tutorials/i18n/locales.rst:520
msgid "pap"
msgstr "pap"

#: ../../docs/tutorials/i18n/locales.rst:520
msgid "Papiamento"
msgstr "Papiamento"

#: ../../docs/tutorials/i18n/locales.rst:522
msgid "pap_AN"
msgstr "pap_AN"

#: ../../docs/tutorials/i18n/locales.rst:522
msgid "Papiamento (Netherlands Antilles)"
msgstr "Papiamento (Netherlands Antilles)"

#: ../../docs/tutorials/i18n/locales.rst:524
msgid "pap_AW"
msgstr "pap_AW"

#: ../../docs/tutorials/i18n/locales.rst:524
msgid "Papiamento (Aruba)"
msgstr "Papiamento (Aruba)"

#: ../../docs/tutorials/i18n/locales.rst:526
msgid "pap_CW"
msgstr "pap_CW"

#: ../../docs/tutorials/i18n/locales.rst:526
msgid "Papiamento (Curaçao)"
msgstr "Papiamento (Curaçao)"

#: ../../docs/tutorials/i18n/locales.rst:528
msgid "pa_PK"
msgstr "pa_PK"

#: ../../docs/tutorials/i18n/locales.rst:528
msgid "Panjabi (Pakistan)"
msgstr "Panjabi (Pakistan)"

#: ../../docs/tutorials/i18n/locales.rst:530
msgid "pl"
msgstr "pl"

#: ../../docs/tutorials/i18n/locales.rst:530
msgid "Polish"
msgstr "Polish"

#: ../../docs/tutorials/i18n/locales.rst:532
msgid "pl_PL"
msgstr "pl_PL"

#: ../../docs/tutorials/i18n/locales.rst:532
msgid "Polish (Poland)"
msgstr "Polish (Poland)"

#: ../../docs/tutorials/i18n/locales.rst:534
msgid "pr"
msgstr "pr"

#: ../../docs/tutorials/i18n/locales.rst:534
msgid "Pirate"
msgstr "Pirate"

#: ../../docs/tutorials/i18n/locales.rst:536
msgid "ps_AF"
msgstr "ps_AF"

#: ../../docs/tutorials/i18n/locales.rst:536
msgid "Pushto (Afghanistan)"
msgstr "Pushto (Afghanistan)"

#: ../../docs/tutorials/i18n/locales.rst:538
msgid "pt"
msgstr "pt"

#: ../../docs/tutorials/i18n/locales.rst:538
msgid "Portuguese"
msgstr "Portuguese"

#: ../../docs/tutorials/i18n/locales.rst:540
msgid "pt_BR"
msgstr "pt_BR"

#: ../../docs/tutorials/i18n/locales.rst:540
msgid "Portuguese (Brazil)"
msgstr "Portuguese (Brazil)"

#: ../../docs/tutorials/i18n/locales.rst:542
msgid "pt_PT"
msgstr "pt_PT"

#: ../../docs/tutorials/i18n/locales.rst:542
msgid "Portuguese (Portugal)"
msgstr "Portuguese (Portugal)"

#: ../../docs/tutorials/i18n/locales.rst:544
msgid "quy_PE"
msgstr "quy_PE"

#: ../../docs/tutorials/i18n/locales.rst:544
msgid "Ayacucho Quechua (Peru)"
msgstr "Ayacucho Quechua (Peru)"

#: ../../docs/tutorials/i18n/locales.rst:546
msgid "quz_PE"
msgstr "quz_PE"

#: ../../docs/tutorials/i18n/locales.rst:546
msgid "Cusco Quechua (Peru)"
msgstr "Cusco Quechua (Peru)"

#: ../../docs/tutorials/i18n/locales.rst:548
msgid "raj_IN"
msgstr "raj_IN"

#: ../../docs/tutorials/i18n/locales.rst:548
msgid "Rajasthani (India)"
msgstr "Rajasthani (India)"

#: ../../docs/tutorials/i18n/locales.rst:550
msgid "ro"
msgstr "ro"

#: ../../docs/tutorials/i18n/locales.rst:550
msgid "Romanian"
msgstr "Romanian"

#: ../../docs/tutorials/i18n/locales.rst:552
msgid "ro_RO"
msgstr "ro_RO"

#: ../../docs/tutorials/i18n/locales.rst:552
msgid "Romanian (Romania)"
msgstr "Romanian (Romania)"

#: ../../docs/tutorials/i18n/locales.rst:554
msgid "ru"
msgstr "ru"

#: ../../docs/tutorials/i18n/locales.rst:554
msgid "Russian"
msgstr "Russian"

#: ../../docs/tutorials/i18n/locales.rst:556
msgid "ru_RU"
msgstr "ru_RU"

#: ../../docs/tutorials/i18n/locales.rst:556
msgid "Russian (Russia)"
msgstr "Russian (Russia)"

#: ../../docs/tutorials/i18n/locales.rst:558
msgid "ru_UA"
msgstr "ru_UA"

#: ../../docs/tutorials/i18n/locales.rst:558
msgid "Russian (Ukraine)"
msgstr "Russian (Ukraine)"

#: ../../docs/tutorials/i18n/locales.rst:560
msgid "rw_RW"
msgstr "rw_RW"

#: ../../docs/tutorials/i18n/locales.rst:560
msgid "Kinyarwanda (Rwanda)"
msgstr "Kinyarwanda (Rwanda)"

#: ../../docs/tutorials/i18n/locales.rst:562
msgid "sa_IN"
msgstr "sa_IN"

#: ../../docs/tutorials/i18n/locales.rst:562
msgid "Sanskrit (India)"
msgstr "Sanskrit (India)"

#: ../../docs/tutorials/i18n/locales.rst:564
msgid "sat_IN"
msgstr "sat_IN"

#: ../../docs/tutorials/i18n/locales.rst:564
msgid "Santali (India)"
msgstr "Santali (India)"

#: ../../docs/tutorials/i18n/locales.rst:566
msgid "sc_IT"
msgstr "sc_IT"

#: ../../docs/tutorials/i18n/locales.rst:566
msgid "Sardinian (Italy)"
msgstr "Sardinian (Italy)"

#: ../../docs/tutorials/i18n/locales.rst:568
msgid "sco"
msgstr "sco"

#: ../../docs/tutorials/i18n/locales.rst:568
msgid "Scots"
msgstr "Scots"

#: ../../docs/tutorials/i18n/locales.rst:570
msgid "sd_IN"
msgstr "sd_IN"

#: ../../docs/tutorials/i18n/locales.rst:570
msgid "Sindhi (India)"
msgstr "Sindhi (India)"

#: ../../docs/tutorials/i18n/locales.rst:572
msgid "se_NO"
msgstr "se_NO"

#: ../../docs/tutorials/i18n/locales.rst:572
msgid "Northern Sami (Norway)"
msgstr "Northern Sami (Norway)"

#: ../../docs/tutorials/i18n/locales.rst:574
msgid "sgs_LT"
msgstr "sgs_LT"

#: ../../docs/tutorials/i18n/locales.rst:574
msgid "Samogitian (Lithuania)"
msgstr "Samogitian (Lithuania)"

#: ../../docs/tutorials/i18n/locales.rst:576
msgid "shs_CA"
msgstr "shs_CA"

#: ../../docs/tutorials/i18n/locales.rst:576
msgid "Shuswap (Canada)"
msgstr "Shuswap (Canada)"

#: ../../docs/tutorials/i18n/locales.rst:578
msgid "sid_ET"
msgstr "sid_ET"

#: ../../docs/tutorials/i18n/locales.rst:578
msgid "Sidamo (Ethiopia)"
msgstr "Sidamo (Ethiopia)"

#: ../../docs/tutorials/i18n/locales.rst:580
msgid "si_LK"
msgstr "si_LK"

#: ../../docs/tutorials/i18n/locales.rst:580
msgid "Sinhala (Sri Lanka)"
msgstr "Sinhala (Sri Lanka)"

#: ../../docs/tutorials/i18n/locales.rst:582
msgid "sk"
msgstr "sk"

#: ../../docs/tutorials/i18n/locales.rst:582
msgid "Slovak"
msgstr "Slovak"

#: ../../docs/tutorials/i18n/locales.rst:584
msgid "sk_SK"
msgstr "sk_SK"

#: ../../docs/tutorials/i18n/locales.rst:584
msgid "Slovak (Slovakia)"
msgstr "Slovak (Slovakia)"

#: ../../docs/tutorials/i18n/locales.rst:586
msgid "sl"
msgstr "sl"

#: ../../docs/tutorials/i18n/locales.rst:586
msgid "Slovenian"
msgstr "Slovenian"

#: ../../docs/tutorials/i18n/locales.rst:588
msgid "so"
msgstr "so"

#: ../../docs/tutorials/i18n/locales.rst:588
msgid "Somali"
msgstr "Somali"

#: ../../docs/tutorials/i18n/locales.rst:590
msgid "so_DJ"
msgstr "so_DJ"

#: ../../docs/tutorials/i18n/locales.rst:590
msgid "Somali (Djibouti)"
msgstr "Somali (Djibouti)"

#: ../../docs/tutorials/i18n/locales.rst:592
msgid "so_ET"
msgstr "so_ET"

#: ../../docs/tutorials/i18n/locales.rst:592
msgid "Somali (Ethiopia)"
msgstr "Somali (Ethiopia)"

#: ../../docs/tutorials/i18n/locales.rst:594
msgid "so_KE"
msgstr "so_KE"

#: ../../docs/tutorials/i18n/locales.rst:594
msgid "Somali (Kenya)"
msgstr "Somali (Kenya)"

#: ../../docs/tutorials/i18n/locales.rst:596
msgid "so_SO"
msgstr "so_SO"

#: ../../docs/tutorials/i18n/locales.rst:596
msgid "Somali (Somalia)"
msgstr "Somali (Somalia)"

#: ../../docs/tutorials/i18n/locales.rst:598
msgid "son_ML"
msgstr "son_ML"

#: ../../docs/tutorials/i18n/locales.rst:598
msgid "Songhai languages (Mali)"
msgstr "Songhai languages (Mali)"

#: ../../docs/tutorials/i18n/locales.rst:600
msgid "sq"
msgstr "sq"

#: ../../docs/tutorials/i18n/locales.rst:600
msgid "Albanian"
msgstr "Albanian"

#: ../../docs/tutorials/i18n/locales.rst:602
msgid "sq_AL"
msgstr "sq_AL"

#: ../../docs/tutorials/i18n/locales.rst:602
msgid "Albanian (Albania)"
msgstr "Albanian (Albania)"

#: ../../docs/tutorials/i18n/locales.rst:604
msgid "sq_KV"
msgstr "sq_KV"

#: ../../docs/tutorials/i18n/locales.rst:604
msgid "Albanian (Kosovo)"
msgstr "Albanian (Kosovo)"

#: ../../docs/tutorials/i18n/locales.rst:606
msgid "sq_MK"
msgstr "sq_MK"

#: ../../docs/tutorials/i18n/locales.rst:606
msgid "Albanian (Macedonia)"
msgstr "Albanian (Macedonia)"

#: ../../docs/tutorials/i18n/locales.rst:608
msgid "sr"
msgstr "sr"

#: ../../docs/tutorials/i18n/locales.rst:608
msgid "Serbian"
msgstr "Serbian"

#: ../../docs/tutorials/i18n/locales.rst:610
msgid "sr_BA"
msgstr "sr_BA"

#: ../../docs/tutorials/i18n/locales.rst:610
msgid "Serbian (Bosnia and Herzegovina)"
msgstr "Serbian (Bosnia and Herzegovina)"

#: ../../docs/tutorials/i18n/locales.rst:612
msgid "sr_CS"
msgstr "sr_CS"

#: ../../docs/tutorials/i18n/locales.rst:612
msgid "Serbian (Serbia and Montenegro)"
msgstr "Serbian (Serbia and Montenegro)"

#: ../../docs/tutorials/i18n/locales.rst:614
msgid "sr_ME"
msgstr "sr_ME"

#: ../../docs/tutorials/i18n/locales.rst:614
msgid "Serbian (Montenegro)"
msgstr "Serbian (Montenegro)"

#: ../../docs/tutorials/i18n/locales.rst:616
msgid "sr_RS"
msgstr "sr_RS"

#: ../../docs/tutorials/i18n/locales.rst:616
msgid "Serbian (Serbia)"
msgstr "Serbian (Serbia)"

#: ../../docs/tutorials/i18n/locales.rst:618
msgid "ss_ZA"
msgstr "ss_ZA"

#: ../../docs/tutorials/i18n/locales.rst:618
msgid "Swati (South Africa)"
msgstr "Swati (South Africa)"

#: ../../docs/tutorials/i18n/locales.rst:620
msgid "st_ZA"
msgstr "st_ZA"

#: ../../docs/tutorials/i18n/locales.rst:620
msgid "Southern Sotho (South Africa)"
msgstr "Southern Sotho (South Africa)"

#: ../../docs/tutorials/i18n/locales.rst:622
msgid "sv"
msgstr "sv"

#: ../../docs/tutorials/i18n/locales.rst:622
msgid "Swedish"
msgstr "Swedish"

#: ../../docs/tutorials/i18n/locales.rst:624
msgid "sv_FI"
msgstr "sv_FI"

#: ../../docs/tutorials/i18n/locales.rst:624
msgid "Swedish (Finland)"
msgstr "Swedish (Finland)"

#: ../../docs/tutorials/i18n/locales.rst:626
msgid "sv_SE"
msgstr "sv_SE"

#: ../../docs/tutorials/i18n/locales.rst:626
msgid "Swedish (Sweden)"
msgstr "Swedish (Sweden)"

#: ../../docs/tutorials/i18n/locales.rst:628
msgid "sw_KE"
msgstr "sw_KE"

#: ../../docs/tutorials/i18n/locales.rst:628
msgid "Swahili (Kenya)"
msgstr "Swahili (Kenya)"

#: ../../docs/tutorials/i18n/locales.rst:630
msgid "sw_TZ"
msgstr "sw_TZ"

#: ../../docs/tutorials/i18n/locales.rst:630
msgid "Swahili (Tanzania)"
msgstr "Swahili (Tanzania)"

#: ../../docs/tutorials/i18n/locales.rst:632
msgid "szl_PL"
msgstr "szl_PL"

#: ../../docs/tutorials/i18n/locales.rst:632
msgid "Silesian (Poland)"
msgstr "Silesian (Poland)"

#: ../../docs/tutorials/i18n/locales.rst:634
msgid "ta"
msgstr "ta"

#: ../../docs/tutorials/i18n/locales.rst:634
msgid "Tamil"
msgstr "Tamil"

#: ../../docs/tutorials/i18n/locales.rst:636
msgid "ta_IN"
msgstr "ta_IN"

#: ../../docs/tutorials/i18n/locales.rst:636
msgid "Tamil (India)"
msgstr "Tamil (India)"

#: ../../docs/tutorials/i18n/locales.rst:638
msgid "ta_LK"
msgstr "ta_LK"

#: ../../docs/tutorials/i18n/locales.rst:638
msgid "Tamil (Sri Lanka)"
msgstr "Tamil (Sri Lanka)"

#: ../../docs/tutorials/i18n/locales.rst:640
msgid "tcy_IN"
msgstr "tcy_IN"

#: ../../docs/tutorials/i18n/locales.rst:640
msgid "Tulu (India)"
msgstr "Tulu (India)"

#: ../../docs/tutorials/i18n/locales.rst:642
msgid "te_IN"
msgstr "te_IN"

#: ../../docs/tutorials/i18n/locales.rst:642
msgid "Telugu (India)"
msgstr "Telugu (India)"

#: ../../docs/tutorials/i18n/locales.rst:644
msgid "tg_TJ"
msgstr "tg_TJ"

#: ../../docs/tutorials/i18n/locales.rst:644
msgid "Tajik (Tajikistan)"
msgstr "Tajik (Tajikistan)"

#: ../../docs/tutorials/i18n/locales.rst:646
msgid "the_NP"
msgstr "the_NP"

#: ../../docs/tutorials/i18n/locales.rst:646
msgid "Chitwania Tharu (Nepal)"
msgstr "Chitwania Tharu (Nepal)"

#: ../../docs/tutorials/i18n/locales.rst:648
msgid "th"
msgstr "th"

#: ../../docs/tutorials/i18n/locales.rst:648
msgid "Thai"
msgstr "Thai"

#: ../../docs/tutorials/i18n/locales.rst:650
msgid "th_TH"
msgstr "th_TH"

#: ../../docs/tutorials/i18n/locales.rst:650
msgid "Thai (Thailand)"
msgstr "Thai (Thailand)"

#: ../../docs/tutorials/i18n/locales.rst:652
msgid "th_TH_TH"
msgstr "th_TH_TH"

#: ../../docs/tutorials/i18n/locales.rst:652
msgid "Thai (Thailand,TH)"
msgstr "Thai (Thailand,TH)"

#: ../../docs/tutorials/i18n/locales.rst:654
msgid "ti"
msgstr "ti"

#: ../../docs/tutorials/i18n/locales.rst:654
msgid "Tigrinya"
msgstr "Tigrinya"

#: ../../docs/tutorials/i18n/locales.rst:656
msgid "ti_ER"
msgstr "ti_ER"

#: ../../docs/tutorials/i18n/locales.rst:656
msgid "Tigrinya (Eritrea)"
msgstr "Tigrinya (Eritrea)"

#: ../../docs/tutorials/i18n/locales.rst:658
msgid "ti_ET"
msgstr "ti_ET"

#: ../../docs/tutorials/i18n/locales.rst:658
msgid "Tigrinya (Ethiopia)"
msgstr "Tigrinya (Ethiopia)"

#: ../../docs/tutorials/i18n/locales.rst:660
msgid "tig_ER"
msgstr "tig_ER"

#: ../../docs/tutorials/i18n/locales.rst:660
msgid "Tigre (Eritrea)"
msgstr "Tigre (Eritrea)"

#: ../../docs/tutorials/i18n/locales.rst:662
msgid "tk_TM"
msgstr "tk_TM"

#: ../../docs/tutorials/i18n/locales.rst:662
msgid "Turkmen (Turkmenistan)"
msgstr "Turkmen (Turkmenistan)"

#: ../../docs/tutorials/i18n/locales.rst:664
msgid "tl_PH"
msgstr "tl_PH"

#: ../../docs/tutorials/i18n/locales.rst:664
msgid "Tagalog (Philippines)"
msgstr "Tagalog (Philippines)"

#: ../../docs/tutorials/i18n/locales.rst:666
msgid "tn_ZA"
msgstr "tn_ZA"

#: ../../docs/tutorials/i18n/locales.rst:666
msgid "Tswana (South Africa)"
msgstr "Tswana (South Africa)"

#: ../../docs/tutorials/i18n/locales.rst:668
msgid "tr"
msgstr "tr"

#: ../../docs/tutorials/i18n/locales.rst:668
msgid "Turkish"
msgstr "Turkish"

#: ../../docs/tutorials/i18n/locales.rst:670
msgid "tr_CY"
msgstr "tr_CY"

#: ../../docs/tutorials/i18n/locales.rst:670
msgid "Turkish (Cyprus)"
msgstr "Turkish (Cyprus)"

#: ../../docs/tutorials/i18n/locales.rst:672
msgid "tr_TR"
msgstr "tr_TR"

#: ../../docs/tutorials/i18n/locales.rst:672
msgid "Turkish (Turkey)"
msgstr "Turkish (Turkey)"

#: ../../docs/tutorials/i18n/locales.rst:674
msgid "ts_ZA"
msgstr "ts_ZA"

#: ../../docs/tutorials/i18n/locales.rst:674
msgid "Tsonga (South Africa)"
msgstr "Tsonga (South Africa)"

#: ../../docs/tutorials/i18n/locales.rst:676
msgid "tt_RU"
msgstr "tt_RU"

#: ../../docs/tutorials/i18n/locales.rst:676
msgid "Tatar (Russia)"
msgstr "Tatar (Russia)"

#: ../../docs/tutorials/i18n/locales.rst:678
msgid "ug_CN"
msgstr "ug_CN"

#: ../../docs/tutorials/i18n/locales.rst:678
msgid "Uighur (China)"
msgstr "Uighur (China)"

#: ../../docs/tutorials/i18n/locales.rst:680
msgid "uk"
msgstr "uk"

#: ../../docs/tutorials/i18n/locales.rst:680
msgid "Ukrainian"
msgstr "Ukrainian"

#: ../../docs/tutorials/i18n/locales.rst:682
msgid "uk_UA"
msgstr "uk_UA"

#: ../../docs/tutorials/i18n/locales.rst:682
msgid "Ukrainian (Ukraine)"
msgstr "Ukrainian (Ukraine)"

#: ../../docs/tutorials/i18n/locales.rst:684
msgid "unm_US"
msgstr "unm_US"

#: ../../docs/tutorials/i18n/locales.rst:684
msgid "Unami (United States)"
msgstr "Unami (United States)"

#: ../../docs/tutorials/i18n/locales.rst:686
msgid "ur"
msgstr "ur"

#: ../../docs/tutorials/i18n/locales.rst:686
msgid "Urdu"
msgstr "Urdu"

#: ../../docs/tutorials/i18n/locales.rst:688
msgid "ur_IN"
msgstr "ur_IN"

#: ../../docs/tutorials/i18n/locales.rst:688
msgid "Urdu (India)"
msgstr "Urdu (India)"

#: ../../docs/tutorials/i18n/locales.rst:690
msgid "ur_PK"
msgstr "ur_PK"

#: ../../docs/tutorials/i18n/locales.rst:690
msgid "Urdu (Pakistan)"
msgstr "Urdu (Pakistan)"

#: ../../docs/tutorials/i18n/locales.rst:692
msgid "uz"
msgstr "uz"

#: ../../docs/tutorials/i18n/locales.rst:692
msgid "Uzbek"
msgstr "Uzbek"

#: ../../docs/tutorials/i18n/locales.rst:694
msgid "uz_UZ"
msgstr "uz_UZ"

#: ../../docs/tutorials/i18n/locales.rst:694
msgid "Uzbek (Uzbekistan)"
msgstr "Uzbek (Uzbekistan)"

#: ../../docs/tutorials/i18n/locales.rst:696
msgid "ve_ZA"
msgstr "ve_ZA"

#: ../../docs/tutorials/i18n/locales.rst:696
msgid "Venda (South Africa)"
msgstr "Venda (South Africa)"

#: ../../docs/tutorials/i18n/locales.rst:698
msgid "vi"
msgstr "vi"

#: ../../docs/tutorials/i18n/locales.rst:698
msgid "Vietnamese"
msgstr "Vietnamese"

#: ../../docs/tutorials/i18n/locales.rst:700
msgid "vi_VN"
msgstr "vi_VN"

#: ../../docs/tutorials/i18n/locales.rst:700
msgid "Vietnamese (Vietnam)"
msgstr "Vietnamese (Vietnam)"

#: ../../docs/tutorials/i18n/locales.rst:702
msgid "wa_BE"
msgstr "wa_BE"

#: ../../docs/tutorials/i18n/locales.rst:702
msgid "Walloon (Belgium)"
msgstr "Walloon (Belgium)"

#: ../../docs/tutorials/i18n/locales.rst:704
msgid "wae_CH"
msgstr "wae_CH"

#: ../../docs/tutorials/i18n/locales.rst:704
msgid "Walser (Switzerland)"
msgstr "Walser (Switzerland)"

#: ../../docs/tutorials/i18n/locales.rst:706
msgid "wal_ET"
msgstr "wal_ET"

#: ../../docs/tutorials/i18n/locales.rst:706
msgid "Wolaytta (Ethiopia)"
msgstr "Wolaytta (Ethiopia)"

#: ../../docs/tutorials/i18n/locales.rst:708
msgid "wo_SN"
msgstr "wo_SN"

#: ../../docs/tutorials/i18n/locales.rst:708
msgid "Wolof (Senegal)"
msgstr "Wolof (Senegal)"

#: ../../docs/tutorials/i18n/locales.rst:710
msgid "xh_ZA"
msgstr "xh_ZA"

#: ../../docs/tutorials/i18n/locales.rst:710
msgid "Xhosa (South Africa)"
msgstr "Xhosa (South Africa)"

#: ../../docs/tutorials/i18n/locales.rst:712
msgid "yi_US"
msgstr "yi_US"

#: ../../docs/tutorials/i18n/locales.rst:712
msgid "Yiddish (United States)"
msgstr "Yiddish (United States)"

#: ../../docs/tutorials/i18n/locales.rst:714
msgid "yo_NG"
msgstr "yo_NG"

#: ../../docs/tutorials/i18n/locales.rst:714
msgid "Yoruba (Nigeria)"
msgstr "Yoruba (Nigeria)"

#: ../../docs/tutorials/i18n/locales.rst:716
msgid "yue_HK"
msgstr "yue_HK"

#: ../../docs/tutorials/i18n/locales.rst:716
msgid "Yue Chinese (Hong Kong)"
msgstr "Yue Chinese (Hong Kong)"

#: ../../docs/tutorials/i18n/locales.rst:718
msgid "zh"
msgstr "zh"

#: ../../docs/tutorials/i18n/locales.rst:718
msgid "Chinese"
msgstr "Chinese"

#: ../../docs/tutorials/i18n/locales.rst:720
msgid "zh_CN"
msgstr "zh_CN"

#: ../../docs/tutorials/i18n/locales.rst:720
msgid "Chinese (China)"
msgstr "Chinese (China)"

#: ../../docs/tutorials/i18n/locales.rst:722
msgid "zh_HK"
msgstr "zh_HK"

#: ../../docs/tutorials/i18n/locales.rst:722
msgid "Chinese (Hong Kong)"
msgstr "Chinese (Hong Kong)"

#: ../../docs/tutorials/i18n/locales.rst:724
msgid "zh_SG"
msgstr "zh_SG"

#: ../../docs/tutorials/i18n/locales.rst:724
msgid "Chinese (Singapore)"
msgstr "Chinese (Singapore)"

#: ../../docs/tutorials/i18n/locales.rst:726
msgid "zh_TW"
msgstr "zh_TW"

#: ../../docs/tutorials/i18n/locales.rst:726
msgid "Chinese (Taiwan)"
msgstr "Chinese (Taiwan)"

#: ../../docs/tutorials/i18n/locales.rst:728
msgid "zu_ZA"
msgstr "zu_ZA"

#: ../../docs/tutorials/i18n/locales.rst:728
msgid "Zulu (South Africa)"
msgstr "Zulu (South Africa)"

#: ../../docs/tutorials/gui/index.rst:2
msgid "GUI"
msgstr "GUI"

#: ../../docs/tutorials/gui/gui_skinning.rst:4
msgid "GUI skinning"
msgstr "GUI 外观定制"

#: ../../docs/tutorials/gui/gui_skinning.rst:7
#, fuzzy
msgid "Oh, beautiful GUI!"
msgstr "哦, 美丽的 GUI!"

#: ../../docs/tutorials/gui/gui_skinning.rst:9
msgid ""
"This tutorial is about advanced skinning of an user interface. Most games "
"generally don't need this, as they end up just relying on :ref:`Label "
"<class_Label>`, :ref:`TextureRect <class_TextureRect>`, :ref:`TextureButton "
"<class_TextureButton>` and :ref:`TextureProgress <class_TextureProgress>`."
msgstr ""
"本教程介绍用户界面的高级外观定制。大多数游戏通常不需要这样做, 因为它们到最后"
"只依赖于 :ref:`Label <class_Label>`, :ref:`TextureRect "
"<class_TextureRect>`, :ref:`TextureButton <class_TextureButton>` 以及 :ref:"
"`TextureProgress <class_TextureProgress>`。"

#: ../../docs/tutorials/gui/gui_skinning.rst:15
#, fuzzy
msgid ""
"However, many types of games often need complex user interfaces, like MMOs, "
"traditional RPGs, Simulators, Strategy, etc. These kinds of interface are "
"also common in some games that include editors to create content, or "
"interfaces for network connectivity."
msgstr ""
"然而, 许多类型的游戏往往需要复杂的用户界面, 如大型多人在线(MMO)网游, 传统的角"
"色扮演(RPG), 模拟类, 战略类游戏等。这些界面在那些含有用原来创建内容的编辑器，"
"或含有用于网络连接的界面的游戏来说也很常见。"

#: ../../docs/tutorials/gui/gui_skinning.rst:20
#, fuzzy
msgid ""
"Godot's user interface uses these kinds of control with the default theme, "
"but they can be skinned to resemble pretty much any kind of user interface."
msgstr ""
"Godot的用户界面使用了这些控件的默认主题, 但它们可以被外观定制成几乎任何类型的"
"用户界面。"

#: ../../docs/tutorials/gui/gui_skinning.rst:25
msgid "Theme"
msgstr "主题"

#: ../../docs/tutorials/gui/gui_skinning.rst:27
#, fuzzy
msgid ""
"The GUI is skinned through the :ref:`Theme <class_Theme>` resource. Theme "
"contains all the information required to change the entire visual styling of "
"all controls. Theme options are named, so it's not obvious which name "
"changes what (especially from code), but several tools are provided. The "
"ultimate place to look at what each theme option is for each control, which "
"will always be more up to date than any documentation, is the file `scene/"
"resources/default_theme/default_theme.cpp <https://github.com/godotengine/"
"godot/blob/master/scene/resources/default_theme/default_theme.cpp>`__. The "
"rest of this document will explain the different tools used to customize the "
"theme."
msgstr ""
"GUI 通过 :ref:`Theme <class_Theme>` 资源进行外观定制。主题包含更改所有控件的"
"整个视觉样式所需的所有信息。主题选项是命名的, 因此每个名称更改了什么不是很明"
"显 (特别是在代码里), 但我们提供了几个工具。用来查看每个控件的每个主题选项的最"
"终位置, 始终比任何文档都更新的, 是这个文件 `scene/resources/default_theme/"
"default_theme.cpp <https://github.com/godotengine/godot/blob/master/scene/"
"resources/default_theme/default_theme.cpp>`__。本文档的其余部分将解释用于自定"
"义主题的不同工具。"

#: ../../docs/tutorials/gui/gui_skinning.rst:38
#, fuzzy
msgid ""
"A Theme can be applied to any control in the scene. As a result, all "
"children and grand-children controls will use that same theme, too (unless "
"another theme is specified further down the tree). If a value is not found "
"in a theme, it will be searched in themes higher up in the hierarchy, "
"towards the root. If nothing was found, the default theme is used. This "
"system allows for flexible overriding of themes in complex user interfaces."
msgstr ""
"一个“主题”能作用于场景中的任何控件。因此, 所有子孙控件也将使用相同的主题 (除"
"非在节点树结构下额外指定了另一个主题)。如果在主题中找不到某个值, 则将在向着树"
"根方向层次结构更高的主题中进行搜索。如果依然找不到这个值, 则使用默认主题。此"
"系统允许在复杂的用户界面中灵活地覆写主题。"

#: ../../docs/tutorials/gui/gui_skinning.rst:47
msgid "Theme options"
msgstr "主题选项"

#: ../../docs/tutorials/gui/gui_skinning.rst:49
msgid "Each kind of option in a theme can be:"
msgstr "一个主题中的每种选项可以是:"

#: ../../docs/tutorials/gui/gui_skinning.rst:51
msgid ""
"**An integer constant**: A single numerical constant. Generally used to "
"define spacing between components or alignment."
msgstr "**整数常量**: 一个数值常量。通用用于定义组件之间的间距和对齐相关设置。"

#: ../../docs/tutorials/gui/gui_skinning.rst:53
msgid ""
"**A Color**: A single color, with or without transparency. Colors are "
"usually applied to fonts and icons."
msgstr ""
"**颜色**:  一种颜色, 具备或不具备透明度皆可。颜色通常应用于字体和图标。"

#: ../../docs/tutorials/gui/gui_skinning.rst:55
#, fuzzy
msgid ""
"**A Texture**: A single image. Textures are not often used, but when they "
"are, they represent handles to pick or icons in a complex control (such as a "
"file dialog)."
msgstr ""
"**纹理**: 一张图像。一般情况下纹理并不常用, 除非需要在复杂控件 (如文件对话"
"框) 中描绘一个可以点选的操作杆或是图标时。"

#: ../../docs/tutorials/gui/gui_skinning.rst:58
msgid ""
"**A Font**: Every control that uses text can be assigned the fonts used to "
"draw strings."
msgstr "**字体**: 每个使用文本的控件都可以设置字体用于绘制字符串。"

#: ../../docs/tutorials/gui/gui_skinning.rst:60
msgid ""
"**A StyleBox**: Stylebox is a resource that defines how to draw a panel in "
"varying sizes (more information on them later)."
msgstr ""
"**风格箱**: 风格箱是一种资源, 用以定义如何绘制不同大小的面板 (之后见更多信"
"息)。"

#: ../../docs/tutorials/gui/gui_skinning.rst:63
#, fuzzy
msgid "Every option is associated with:"
msgstr "每个选项都与以下内容关联:"

#: ../../docs/tutorials/gui/gui_skinning.rst:65
msgid "A name (the name of the option)"
msgstr "名称 (选项的名称)"

#: ../../docs/tutorials/gui/gui_skinning.rst:66
msgid "A Control (the name of the control)"
msgstr "控件 (控件的名称)"

#: ../../docs/tutorials/gui/gui_skinning.rst:68
msgid "An example usage:"
msgstr "示例用法:"

#: ../../docs/tutorials/gui/gui_skinning.rst:87
#, fuzzy
msgid ""
"In the example above, a new theme is created. The \"font_color\" option is "
"changed and then applied to a label. As a result, the label (and all "
"children and grandchildren labels) will use that color."
msgstr ""
"在上面的示例中, 创建了一个新主题。\"font_color\" 选项被更改, 然后应用于一个标"
"签。因此, 这个标签 (和所有他所有的子孙节点标签) 将使用这种颜色。"

#: ../../docs/tutorials/gui/gui_skinning.rst:91
#, fuzzy
msgid ""
"It is possible to override those options without using the theme directly, "
"and only for a specific control, by using the override API in :ref:`Control."
"add_color_override() <class_Control_method_add_color_override>`:"
msgstr ""
"不通过使用主题而直接针对指定的控件覆写那些选项也是可能的，通过这个API来覆写即"
"可 :ref:`Control.add_color_override() "
"<class_Control_method_add_color_override>`:"

#: ../../docs/tutorials/gui/gui_skinning.rst:106
msgid ""
"In the inline help of Godot (in the script tab) you can check which theme "
"options are overrideable, or check the :ref:`Control <class_Control>` class "
"reference."
msgstr ""
"在Godot的内置帮助 (在 \"脚本\" 选项卡中), 您可以查看哪些主题选项是可覆写的, "
"或者查看 :ref:`Control <class_Control>` 类的参考资料。"

#: ../../docs/tutorials/gui/gui_skinning.rst:110
msgid "Customizing a control"
msgstr "自定义控件"

#: ../../docs/tutorials/gui/gui_skinning.rst:112
msgid ""
"If only a few controls need to be skinned, it is often not necessary to "
"create a new theme. Controls offer their theme options as special kinds of "
"properties. If checked, overriding will take place:"
msgstr ""
"如果只需要外观定制少数几个控件, 通常没有必要创建一个新主题。控件提供其主题选"
"项作为特殊类型的属性(在检查面板上)。一旦勾选, 覆写就会生效:"

#: ../../docs/tutorials/gui/gui_skinning.rst:118
#, fuzzy
msgid ""
"As can be seen in the image above, theme options have little check boxes. If "
"checked, they can be used to override the value of the theme just for that "
"control."
msgstr ""
"如上图所示, 主题选项中有几个勾选框。一旦勾选, 就可以用他们来覆盖主题的值，仅"
"针对该控件。"

#: ../../docs/tutorials/gui/gui_skinning.rst:123
msgid "Creating a theme"
msgstr "创建主题"

#: ../../docs/tutorials/gui/gui_skinning.rst:125
#, fuzzy
msgid ""
"The simplest way to create a theme is to edit a theme resource. Create a "
"Theme from the resource menu; the editor will appear immediately. After "
"that, save it (for example, with the name mytheme.theme):"
msgstr ""
"创建主题最简单的方法是编辑主题资源。从 \"资源\" 菜单创建一个主题, 编辑面板将"
"立即出现。然后, 将其保存为主题文件 (例如, mytheme.thm):"

#: ../../docs/tutorials/gui/gui_skinning.rst:131
msgid ""
"This will create an empty theme that can later be loaded and assigned to "
"controls."
msgstr "这将创建一个空主题, 之后可以将其加载并分配给控件。"

#: ../../docs/tutorials/gui/gui_skinning.rst:135
msgid "Example: theming a button"
msgstr "示例:指定一个按钮的主题"

#: ../../docs/tutorials/gui/gui_skinning.rst:137
msgid ""
"Take some assets (:download:`skin_assets.zip <files/skin_assets.zip>`), go "
"to the \"theme\" menu and select \"Add Class Item\":"
msgstr ""
"首先获取这份资源 (:download:`skin_assets.zip <files/skin_assets.zip>`), 转到 "
"\"Theme\" 菜单并选择 \"Add Class Items\":"

#: ../../docs/tutorials/gui/gui_skinning.rst:142
msgid ""
"A menu will appear prompting the type of control to create. Select \"Button"
"\":"
msgstr "然后将出现一个菜单, 提示要创建的控件类型。选择 \"Button\":"

#: ../../docs/tutorials/gui/gui_skinning.rst:147
msgid ""
"Immediately, all button theme options will appear in the property editor, "
"where they can be edited:"
msgstr "所有按钮主题选项都将立刻显示在属性面板中, 可以在其中进行编辑:"

#: ../../docs/tutorials/gui/gui_skinning.rst:152
#, fuzzy
msgid ""
"From ``Styles``, open the \"Normal\" drop-down menu next to where it "
"probably says \"null\" and create a \"New StyleBoxTexture\", then edit it. A "
"texture stylebox basically contains a texture and the size of the margins "
"that will not stretch when the texture is stretched. This is called \"3x3\" "
"stretching:"
msgstr ""
"选择名为\"Normal\"的stylebox 并创建一个新的 \"StyleBoxTexture\", 然后编辑它。"
"纹理 stylebox 基本上包本身含纹理和“纹理拉伸保留边距”，拉伸时，边距范围内不受"
"拉伸影响。这被称为 \"3x3\" 拉伸(译注:九宫格拉伸):"

#: ../../docs/tutorials/gui/gui_skinning.rst:160
msgid ""
"Repeat the steps and add the other assets. There is no hover or disabled "
"image in the example files, so use the same stylebox as in normal. Set the "
"supplied font as the button font and change the font color to black. Soon, "
"your button will look different and retro:"
msgstr ""
"重复上述步骤并添加其他资源。示例文件中没有提供“Hover”或“Disabled”的图像, 因此"
"使用与“Normal”状态相同的 stylebox。将提供的字体设置为按钮字体, 并将字体颜色更"
"改为黑色。很快地, 您的按钮将看起来不同了，并且变得复古:"

#: ../../docs/tutorials/gui/gui_skinning.rst:167
#, fuzzy
msgid ""
"Save this theme to the .theme file. Go to the 2D editor and create a few "
"buttons:"
msgstr "将此主题保存到 .thm 文件中。转到 2D 编辑器并创建几个按钮:"

#: ../../docs/tutorials/gui/gui_skinning.rst:172
#, fuzzy
msgid ""
"Now, go to the root node of the scene and locate the \"theme\" property, "
"replace it with the theme that was just created. It should look like this:"
msgstr ""
"现在, 转到场景的根节点并找到 \"Theme\" 属性, 将其替换为刚刚创建的主题。它应该"
"看起来像这样:"

#: ../../docs/tutorials/gui/gui_skinning.rst:177
msgid "Congratulations! You have created a reusable GUI Theme!"
msgstr "恭喜咯！您已经创建了一个可反复使用的 GUI 主题!"

#: ../../docs/tutorials/gui/custom_gui_controls.rst:4
msgid "Custom GUI controls"
msgstr "定制 GUI 的Control节点"

#: ../../docs/tutorials/gui/custom_gui_controls.rst:7
msgid "So many controls..."
msgstr "已经有好多control节点了..."

#: ../../docs/tutorials/gui/custom_gui_controls.rst:9
#, fuzzy
msgid ""
"Yet there are never enough. Creating your own custom controls that act just "
"the way you want them to is an obsession of almost every GUI programmer. "
"Godot provides plenty of them, but they may not work exactly the way you "
"want. Before contacting the developers with a pull-request to support "
"diagonal scrollbars, at least it will be good to know how to create these "
"controls easily from script."
msgstr ""
"然而, 这永远不会够。创建自定义的控件让其如您所想般工作, 几乎让每个 GUI 程序员"
"着迷。Godot提供了大量的控件, 但他们也许不能精确的按照您所想要的方式工作。在联"
"系开发人员请求合并一个“支持对角线滚动条”的pull-request之前, 至少最好知道如何"
"用脚本轻松地创建这样的控件。"

#: ../../docs/tutorials/gui/custom_gui_controls.rst:17
msgid "Drawing"
msgstr "绘制"

#: ../../docs/tutorials/gui/custom_gui_controls.rst:19
msgid ""
"For drawing, it is recommended to check the :ref:`doc_custom_drawing_in_2d` "
"tutorial. The same applies. Some functions are worth mentioning due to their "
"usefulness when drawing, so they will be detailed next:"
msgstr ""
"谈到绘制, 推荐看看这篇 :ref:`doc_custom_drawing_in_2d` 的教程。同样的原理适用"
"与控件绘制。这里有些函数值得一提, 因为它们在绘制时有用, 所以接下来将进行详细"
"说明:"

#: ../../docs/tutorials/gui/custom_gui_controls.rst:24
msgid "Checking control size"
msgstr "检查控件的大小"

#: ../../docs/tutorials/gui/custom_gui_controls.rst:26
#, fuzzy
msgid ""
"Unlike 2D nodes, \"size\" is important with controls, as it helps to "
"organize them in proper layouts. For this, the :ref:`Control.rect_size "
"<class_Control_property_rect_size>` property is provided. Checking it during "
"``_draw()`` is vital to ensure everything is kept in-bounds."
msgstr ""
"与2D节点不同，”大小“对控件而言很重要，因为它有助于在合适的布局中组织控件。为"
"此，我们提供了 :ref:`Control.rect_size <class_Control_property_rect_size>` 成"
"员变量。为确保所有内容保持在边界内，在 _draw () 中检查这个变量至关重要。"

#: ../../docs/tutorials/gui/custom_gui_controls.rst:33
msgid "Checking focus"
msgstr "检查输入焦点"

#: ../../docs/tutorials/gui/custom_gui_controls.rst:35
#, fuzzy
msgid ""
"Some controls (such as buttons or text editors) might provide input focus "
"for keyboard or joypad input. Examples of this are entering text or pressing "
"a button. This is controlled with the :ref:`Control.focus_mode "
"<class_Control_property_focus_mode>` property. When drawing, and if the "
"control supports input focus, it is always desired to show some sort of "
"indicator (highlight, box, etc.) to indicate that this is the currently "
"focused control. To check for this status, the :ref:`Control.has_focus() "
"<class_Control_method_has_focus>` method exists. Example"
msgstr ""
"有些控件 (如按钮或文本编辑器) 可能为键盘或手柄输入提供输入焦点。比如正在输入"
"文本或按下按钮的时候。这由 :ref:`Control.focus_mode "
"<class_Control_property_focus_mode>` 成员变量控制。当绘制控件时, 如果该控件支"
"持输入焦点, 则它总是需要显示某种指示符 (高亮、方框等), 以指示这是当前焦点所在"
"的控件。要检查此状态, 我们提供了 :ref:`Control.has_focus() "
"<class_Control_method_has_focus>` 方法。请看示例"

#: ../../docs/tutorials/gui/custom_gui_controls.rst:69
msgid "Sizing"
msgstr "调整大小"

#: ../../docs/tutorials/gui/custom_gui_controls.rst:71
#, fuzzy
msgid ""
"As mentioned before, size is important to controls. This allows them to lay "
"out properly, when set into grids, containers, or anchored. Controls, most "
"of the time, provide a *minimum size* to help properly lay them out. For "
"example, if controls are placed vertically on top of each other using a :ref:"
"`VBoxContainer <class_VBoxContainer>`, the minimum size will make sure your "
"custom control is not squished by the other controls in the container."
msgstr ""
"如前所述, 大小对控件很重要。当控件被设置到网格、容器里面或进行锚定时, 大小让"
"它们可以正确布局。大多数时候控件提供 * 最小大小 * 以帮助正确地放置它们。例"
"如, 如果许多控件使用 :ref:`VBoxContainer <class_VBoxContainer>` 垂直放置在彼"
"此的顶部, 则最小大小将确保您的自定义控件不会被容器中的其他控件压扁。"

#: ../../docs/tutorials/gui/custom_gui_controls.rst:79
#, fuzzy
msgid ""
"To provide this callback, just override :ref:`Control.get_minimum_size() "
"<class_Control_method_get_minimum_size>`, for example:"
msgstr ""
"要提供此回调，只需覆写 :ref:`Control.get_minimum_size() "
"<class_Control_method_get_minimum_size>`， 例如:"

#: ../../docs/tutorials/gui/custom_gui_controls.rst:96
msgid "Or alternatively, set it via function:"
msgstr "或者, 通过函数设置:"

#: ../../docs/tutorials/gui/custom_gui_controls.rst:112
#: ../../docs/tutorials/viewports/viewports.rst:38
msgid "Input"
msgstr "输入"

#: ../../docs/tutorials/gui/custom_gui_controls.rst:114
msgid ""
"Controls provide a few helpers to make managing input events much easier "
"than regular nodes."
msgstr "控件(Control)节点提供了一些帮助, 使管理输入事件比常规节点容易得多。"

#: ../../docs/tutorials/gui/custom_gui_controls.rst:118
msgid "Input events"
msgstr "输入事件"

#: ../../docs/tutorials/gui/custom_gui_controls.rst:120
msgid ""
"There are a few tutorials about input before this one, but it's worth "
"mentioning that controls have a special input method that only works when:"
msgstr ""
"在此之前有几个关于输入的教程, 但值得一提的是, 控件有一个特殊的输入方法, 只有"
"在以下情况下才起作用:"

#: ../../docs/tutorials/gui/custom_gui_controls.rst:124
msgid "The mouse pointer is over the control."
msgstr "鼠标指针悬停在控件上。"

#: ../../docs/tutorials/gui/custom_gui_controls.rst:125
msgid ""
"The button was pressed over this control (control always captures input "
"until button is released)"
msgstr "鼠标按键在此控件上被按下 (控件始终捕获输入, 直到按钮被释放)"

#: ../../docs/tutorials/gui/custom_gui_controls.rst:127
#, fuzzy
msgid ""
"Control provides keyboard/joypad focus via :ref:`Control.focus_mode "
"<class_Control_property_focus_mode>`."
msgstr ""
"控件通过以下方式提供键盘/手柄焦点 :ref:`Control.focus_mode "
"<class_Control_property_focus_mode>`。"

#: ../../docs/tutorials/gui/custom_gui_controls.rst:130
#, fuzzy
msgid ""
"This function is :ref:`Control._gui_input() "
"<class_Control_method__gui_input>`. Simply override it in your control. No "
"processing needs to be set."
msgstr ""
"这个特殊的函数就是 :ref:`Control._gui_input() "
"<class_Control_method__gui_input>`。只需在您的控件中覆写它。不需要设置任何处"
"理。"

#: ../../docs/tutorials/gui/custom_gui_controls.rst:153
msgid ""
"For more information about events themselves, check the :ref:"
"`doc_inputevent` tutorial."
msgstr "有关事件(event)本身的详细信息, 请查看 :ref:`doc_inputevent` 教程。"

#: ../../docs/tutorials/gui/custom_gui_controls.rst:159
#, fuzzy
msgid ""
"Controls also have many useful notifications for which no dedicated callback "
"exists, but which can be checked with the _notification callback:"
msgstr ""
"控件还具有许多不存在对应回调函数的有用通知(notification), 但可以使用 "
"_notification 回调进行检查:"

#: ../../docs/tutorials/gui/size_and_anchors.rst:4
msgid "Size and anchors"
msgstr "大小和锚定点"

#: ../../docs/tutorials/gui/size_and_anchors.rst:6
msgid ""
"If a game was always going to be run on the same device and at the same "
"resolution, positioning controls would be a simple matter of setting the "
"position and size of each one of them. Unfortunately, that is rarely the "
"case."
msgstr ""
"如果一个游戏总是用同一分辨率在同样的设备上运行, 摆放控件将是一个简单的事, 只"
"要逐个设置它们的位置属性和大小属性即可。不幸的是, 能像这样处理的情况很少。"

#: ../../docs/tutorials/gui/size_and_anchors.rst:11
msgid ""
"Only TVs nowadays have a standard resolution and aspect ratio. Everything "
"else, from computer monitors to tablets, portable consoles and mobile phones "
"have different resolutions and aspect ratios."
msgstr ""
"如今只有电视机有标准分辨率和纵横比。而其他所有设备，从计算机显示器到平板电"
"脑、便携游戏主机和手机等等，都有不同的分辨率和纵横比。"

#: ../../docs/tutorials/gui/size_and_anchors.rst:15
#, fuzzy
msgid ""
"There are several ways to handle this, but for now, let's just imagine that "
"the screen resolution has changed and the controls need to be re-positioned. "
"Some will need to follow the bottom of the screen, others the top of the "
"screen, or maybe the right or left margins."
msgstr ""
"有好几种方法可以处理此问题, 但现在让我们试想一下, 当屏幕分辨率被改变后, 控件"
"需要重新摆放位置的情况。有些控件需要跟随屏幕的底边, 其他的一些要跟着屏幕的顶"
"部, 或者可能是右边或左边的边距。"

#: ../../docs/tutorials/gui/size_and_anchors.rst:22
#, fuzzy
msgid ""
"This is done by editing the *margin* properties of controls. Each control "
"has four margins: left, right, bottom and top. By default, all of them "
"represent a distance in pixels relative to the top-left corner of the parent "
"control or (in case there is no parent control) the viewport."
msgstr ""
"这样的需求通过编辑控件的 * 边距 *(*margin*) 属性来实现。每个控件都有四个页边"
"距: 左、右、下和上。默认情况下, 它们都表示相对于父控件或 (如果没有父控件) 视"
"区的左上角的像素距离。"

#: ../../docs/tutorials/gui/size_and_anchors.rst:29
#, fuzzy
msgid ""
"When horizontal (left,right) and/or vertical (top,bottom) anchors are "
"changed to 1, the margin values become relative to the bottom-right corner "
"of the parent control or viewport."
msgstr ""
"当水平 (左、右) 和/或垂直 (顶部、底部) 锚点变为END值时, 边距值将以父控件或视"
"区的右下角作为参照点。"

#: ../../docs/tutorials/gui/size_and_anchors.rst:35
#, fuzzy
msgid ""
"Here, the control is set to expand its bottom-right corner with that of the "
"parent, so when re-sizing the parent, the control will always cover it, "
"leaving a 20 pixel margin:"
msgstr ""
"这幅图中的示例表示, 控件被设置为延展到父控件的右下角, 因此当重新调整父控件(或"
"视区)大小时, 控件将始终覆盖父控件, 每边留下20像素的边距:"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:4
msgid "BBCode in RichTextLabel"
msgstr "RichTextLabel中的BBCode"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:9
#, fuzzy
msgid ""
":ref:`class_RichTextLabel` allows the display of complex text markup in a "
"control. It has a built-in API for generating the markup, but can also parse "
"a BBCode."
msgstr ""
":ref:`class_RichTextLabel` 类允许在控件上显示复杂的标记。它提供了内置的API用"
"以生成这些标记，并且能解析BBCode。"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:12
#, fuzzy
msgid ""
"Note that the BBCode tags can also be used, to some extent, in the :ref:`XML "
"source of the class reference <doc_updating_the_class_reference>`."
msgstr ""
"需要注意到BBCode 标记也可以在某种程度上使用于“类的参考资料”，见 :ref:`XML "
"source of the class reference <doc_updating_the_class_reference>`。"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:18
#, fuzzy
msgid ""
"For a ``RichTextLabel`` to work properly, it must be set up. That means "
"loading the intended fonts in the relevant properties:"
msgstr ""
"要让 RichTextLabel 正常工作, 必须设置它。这意味着要在相关属性中加载预期的字"
"体:"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:24
#: ../../docs/development/cpp/inheritance_class_tree.rst:10
msgid "Reference"
msgstr "参考"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:27
msgid "Command"
msgstr "命令"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:27
#: ../../docs/community/contributing/updating_the_class_reference.rst:227
msgid "Tag"
msgstr "标签"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:29
msgid "**bold**"
msgstr "**bold**"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:29
msgid "``[b]{text}[/b]``"
msgstr "``[b]{text}[/b]``"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:29
msgid "Makes {text} bold."
msgstr "使得 {text} 呈现粗体。"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:31
msgid "**italics**"
msgstr "**italics**"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:31
msgid "``[i]{text}[/i]``"
msgstr "``[i]{text}[/i]``"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:31
msgid "Makes {text} italics."
msgstr "使得 {text} 呈现斜体。"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:33
msgid "**underline**"
msgstr "**underline**"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:33
msgid "``[u]{text}[/u]``"
msgstr "``[u]{text}[/u]``"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:33
msgid "Makes {text} underline."
msgstr "使得 {text} 呈现下划线。"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:35
msgid "**strikethrough**"
msgstr "**strikethrough**"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:35
msgid "``[s]{text}[/s]``"
msgstr "``[s]{text}[/s]``"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:35
msgid "Makes {text} strikethrough."
msgstr "使{text}删除。"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:37
msgid "**code**"
msgstr "**code**"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:37
msgid "``[code]{text}[/code]``"
msgstr "``[code]{text}[/code]``"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:37
msgid "Makes {text} monospace."
msgstr "使得 {text} 呈现等宽(monospace)字体样式。"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:39
msgid "**center**"
msgstr "**center**"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:39
msgid "``[center]{text}[/center]``"
msgstr "``[center]{text}[/center]``"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:39
msgid "Makes {text} centered."
msgstr "使得 {text} 居中。"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:41
msgid "**right**"
msgstr "**right**"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:41
msgid "``[right]{text}[/right]``"
msgstr "``[right]{text}[/right]``"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:41
msgid "Makes {text} right-aligned."
msgstr "使得 {text} 右对齐。"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:43
msgid "**fill**"
msgstr "**fill**"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:43
msgid "``[fill]{text}[/fill]``"
msgstr "``[fill]{text}[/fill]``"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:43
msgid "Makes {text} fill width."
msgstr "使得 {text} 填充整个宽度。"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:45
msgid "**indent**"
msgstr "**indent**"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:45
msgid "``[indent]{text}[/indent]``"
msgstr "``[indent]{text}[/indent]``"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:45
msgid "Increase indent level of {text}."
msgstr "增加 {text} 的缩进级别。"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:47
msgid "**url**"
msgstr "**url**"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:47
msgid "``[url]{url}[/url]``"
msgstr "``[url]{url}[/url]``"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:47
msgid "Show {url} as such."
msgstr "将 {url} 显示为一个统一资源定位符(URL，Uniform Resource Locator)。"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:49
msgid "**url (ref)**"
msgstr "**url (ref)**"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:49
msgid "``[url=<url>]{text}[/url]``"
msgstr "``[url=<url>]{text}[/url]``"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:49
msgid "Makes {text} reference <url>."
msgstr "使得 {text} 引用指向 <url> 。"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:51
msgid "**image**"
msgstr "**image**"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:51
msgid "``[img]{path}[/img]``"
msgstr "``[img]{path}[/img]``"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:51
msgid "Insert image at resource {path}."
msgstr "插入由资源路径 {path} 所指示的图片。"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:53
msgid "**font**"
msgstr "**font**"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:53
msgid "``[font=<path>]{text}[/font]``"
msgstr "``[font=<path>]{text}[/font]``"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:53
msgid "Use custom font at <path> for {text}."
msgstr "为 {text} 内容设置自定义字体，字体由 <path> 指定。"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:55
msgid "**color**"
msgstr "**color**"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:55
msgid "``[color=<code/name>]{text}[/color]``"
msgstr "``[color=<code/name>]{text}[/color]``"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:55
#, fuzzy
msgid "Change {text} color; use name or # format, such as #ff00ff."
msgstr ""
"改变 {text} 的颜色, 可以使用十六进制码指定颜色，如#ff00ff。或者使用颜色名称。"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:59
msgid "Built-in color names"
msgstr "内置的颜色名称列表"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:61
msgid "List of valid color names for the [color=<name>] tag:"
msgstr "以下列出[color=<name>]标签所支持的有效颜色名称:"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:63
msgid "aqua"
msgstr "aqua"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:64
msgid "black"
msgstr "black"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:65
msgid "blue"
msgstr "blue"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:66
msgid "fuchsia"
msgstr "fuchsia"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:67
msgid "gray"
msgstr "gray"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:68
msgid "green"
msgstr "green"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:69
msgid "lime"
msgstr "lime"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:70
msgid "maroon"
msgstr "maroon"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:71
msgid "navy"
msgstr "navy"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:72
msgid "purple"
msgstr "purple"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:73
msgid "red"
msgstr "red"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:74
msgid "silver"
msgstr "silver"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:75
msgid "teal"
msgstr "teal"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:76
msgid "white"
msgstr "white"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:77
msgid "yellow"
msgstr "yellow"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:80
msgid "Hexadecimal color codes"
msgstr "十六进制颜色代码"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:82
msgid ""
"For opaque RGB colors, any valid 6-digit hexadecimal code is supported, e.g. "
"``[color=#ffffff]white[/color]``."
msgstr ""
"对于不透明的 RGB 颜色, 支持任何有效的6位数的十六进制代码, 例如 "
"``[color=#ffffff]white[/color]``。"

#: ../../docs/tutorials/gui/bbcode_in_richtextlabel.rst:84
msgid ""
"For transparent RGB colors, any 8-digit hexadecimal code can be used, e.g. "
"``[color=#88ffffff]translucent white[/color]``. In this case, note that the "
"alpha channel is the **first** component of the color code, not the last one."
msgstr ""
"对于透明的 RGB 颜色, 可以使用任意8位的十六进制代码, 例如 "
"``[color=#88ffffff]translucent white[/color]``。在这种情况下, 请注意 alpha 通"
"道是颜色代码的第一个分量, 而不是最后一个。"

#: ../../docs/tutorials/viewports/viewports.rst:9
#, fuzzy
msgid ""
"Think of a :ref:`Viewport <class_Viewport>` as a screen onto which the game "
"is projected. In order to see the game, we need to have a surface on which "
"to draw it; that surface is the Root :ref:`Viewport <class_Viewport>`."
msgstr ""
"将 :ref:`Viewports <class_Viewport>` 想成投影游戏的荧幕。 为了看到游戏，我们"
"需要有一个表面来绘制它，这个表面是根节点的 :ref:`Viewport <class_Viewport>`。"

#: ../../docs/tutorials/viewports/viewports.rst:16
#, fuzzy
msgid ""
":ref:`Viewports <class_Viewport>` can also be added to the scene so that "
"there are multiple surfaces to draw on. When we are drawing to a :ref:"
"`Viewport <class_Viewport>` that is not the Root, we call it a render "
"target. We can access the contents of a render target by accessing its "
"corresponding :ref:`texture <class_ViewportTexture>`. By using a :ref:"
"`Viewport <class_Viewport>` as a render target, we can either render "
"multiple scenes simultaneously or we can render to a :ref:`texture "
"<class_ViewportTexture>` which is applied to an object in the scene, for "
"example a dynamic skybox."
msgstr ""
":ref:`Viewports <class_Viewport>` 也可以添加到场景中，以便绘制多视区。 当我们"
"绘制到一个不是根节点的 :ref:`Viewport <class_Viewport>` 时， 我们将该视区称为"
"渲染目标。 我们可以通过访问它对应的 :ref:`texture <class_ViewportTexture>` 属"
"性来访问渲染目标的内容。 通过使用作为渲染目标的 :ref:`Viewport "
"<class_Viewport>` ，我们要么可以同时渲染多个场景，要么可以渲染到场景中对象"
"的 :ref:`texture <class_ViewportTexture>` ，例如 一个动态的天空盒。"

#: ../../docs/tutorials/viewports/viewports.rst:25
#, fuzzy
msgid ""
":ref:`Viewports <class_Viewport>` have a variety of use cases, including:"
msgstr ":ref:`Viewports <class_Viewport>` 有各种用例，包括:"

#: ../../docs/tutorials/viewports/viewports.rst:27
msgid "Rendering 3D objects within a 2D game"
msgstr "在2D游戏中渲染3D物体"

#: ../../docs/tutorials/viewports/viewports.rst:28
msgid "Rendering 2D elements in a 3D game"
msgstr "在3D游戏中渲染2D元素"

#: ../../docs/tutorials/viewports/viewports.rst:29
msgid "Rendering dynamic textures"
msgstr "渲染动态纹理"

#: ../../docs/tutorials/viewports/viewports.rst:30
msgid "Generating procedural textures at runtime"
msgstr "在游戏运行时生成过程纹理"

#: ../../docs/tutorials/viewports/viewports.rst:31
msgid "Rendering multiple cameras in the same scene"
msgstr "在同一场景中渲染多个摄像机"

#: ../../docs/tutorials/viewports/viewports.rst:33
#, fuzzy
msgid ""
"What all these use cases have in common is that you are given the ability to "
"draw objects to a texture as if it were another screen and can then choose "
"what to do with the resulting texture."
msgstr ""
"所有这些用例的共同之处在于，您可以将对象绘制到纹理中，就像它在另一个屏幕那"
"样，然后您可以选择如何处理生成的纹理。"

#: ../../docs/tutorials/viewports/viewports.rst:40
#, fuzzy
msgid ""
":ref:`Viewports <class_Viewport>` are also responsible for delivering "
"properly adjusted and scaled input events to all their children nodes. "
"Typically, input is received by the nearest :ref:`Viewport <class_Viewport>` "
"in the tree, but you can set :ref:`Viewports <class_Viewport>` not to "
"receive input by checking 'Disable Input' to 'on'; this will allow the next "
"nearest :ref:`Viewport <class_Viewport>` in the tree to capture the input."
msgstr ""
":ref:`Viewports <class_Viewport>` 还负责向其所有子节点提供正确调整和缩放的输"
"入事件。 通常输入是由树中最近的 :ref:`Viewport <class_Viewport>` 接收的，但您"
"可以通过选中 '禁用输入' 为 'on' 来设置 :ref:`Viewports <class_Viewport>` 不接"
"收输入，这将允许树中下个最近的 :ref:`Viewport <class_Viewport>` 来捕获输入。"

#: ../../docs/tutorials/viewports/viewports.rst:48
#, fuzzy
msgid ""
"For more information on how Godot handles input, please read the :ref:`Input "
"Event Tutorial<doc_inputevent>`."
msgstr ""
"有关Godot如何处理输入的更多信息，请阅读 :ref:`Input Event "
"Tutorial<doc_inputevent>` 。"

#: ../../docs/tutorials/viewports/viewports.rst:51
msgid "Listener"
msgstr "侦听器"

#: ../../docs/tutorials/viewports/viewports.rst:53
#, fuzzy
msgid ""
"Godot supports 3D sound (in both 2D and 3D nodes); more on this can be found "
"in the :ref:`Audio Streams Tutorial<doc_audio-streams>`. For this type of "
"sound to be audible, the :ref:`Viewport <class_Viewport>` needs to be "
"enabled as a listener (for 2D or 3D). If you are using a custom :ref:"
"`Viewport <class_Viewport>` to display your :ref:`World <class_World>`, "
"don't forget to enable this!"
msgstr ""
"Godot支持3D声音(在2D和3D节点中)，更多内容可以在 :ref:`Audio Streams "
"Tutorial<doc_audio-streams>` 中找到。 要使这种类型的声音被听到，需要启用 :"
"ref:`Viewport <class_Viewport>` 作为侦听器(用于2D或3D)。 如果您使用自定义 :"
"ref:`Viewport <class_Viewport>` 来显示您的 :ref:`World <class_World>` ，别忘"
"了开启它！"

#: ../../docs/tutorials/viewports/viewports.rst:60
msgid "Cameras (2D & 3D)"
msgstr "摄像机 (2D和3D)"

#: ../../docs/tutorials/viewports/viewports.rst:62
msgid ""
"When using a :ref:`Camera <class_Camera>` / :ref:`Camera2D "
"<class_Camera2D>`, cameras will always display on the closest parent :ref:"
"`Viewport <class_Viewport>` (going towards the root). For example, in the "
"following hierarchy:"
msgstr ""
"当使用 :ref:`Camera <class_Camera>` / :ref:`Camera2D <class_Camera2D>` 时，摄"
"像机将始终显示在最近的父节点上 :ref:`Viewport <class_Viewport>` (朝向根节"
"点)。 例如，在下面的层次结构中:"

#: ../../docs/tutorials/viewports/viewports.rst:69
msgid ""
"CameraA will display on the Root :ref:`Viewport <class_Viewport>` and it "
"will draw MeshA. CameraB will be captured by the :ref:`Viewport "
"<class_Viewport>` Node along with MeshB. Even though MeshB is in the scene "
"hierarchy, it will still not be drawn to the Root :ref:`Viewport "
"<class_Viewport>`. Similarly MeshA will not be visible from the :ref:"
"`Viewport <class_Viewport>` node because :ref:`Viewport <class_Viewport>` "
"nodes only capture nodes below them in the hierarchy."
msgstr ""
"CameraA将显示根节点的 :ref:`Viewport <class_Viewport>` ，它将绘制MeshA。 "
"CameraB将被 :ref:`Viewport <class_Viewport>` 节点以及MeshB捕获。 即使MeshB在"
"场景层次结构中，它仍然不会被绘制到根节点的 :ref:`Viewport <class_Viewport>` "
"中。 类似地，在 :ref:`Viewport <class_Viewport>` 节点中不会看到MeshA，因为 :"
"ref:`Viewport <class_Viewport>` 节点仅捕获层次结构中它下面的节点。"

#: ../../docs/tutorials/viewports/viewports.rst:75
msgid ""
"There can only be one active camera per :ref:`Viewport <class_Viewport>`, so "
"if there is more than one, make sure that the desired one has the \"current"
"\" property set, or make it the current camera by calling:"
msgstr ""
"每个视区只能有一个激活的摄像机, 因此, 如果有多个摄像机时, 请确保您需要的那个"
"摄像机的“current”属性被设置上，或者通过调用以下语句来使其成为当前摄像机:"

#: ../../docs/tutorials/viewports/viewports.rst:84
msgid "Scale & stretching"
msgstr "缩放和拉伸"

#: ../../docs/tutorials/viewports/viewports.rst:86
#, fuzzy
msgid ""
":ref:`Viewports <class_Viewport>` have a \"size\" property, which represents "
"the size of the :ref:`Viewport <class_Viewport>` in pixels. For :ref:"
"`Viewports <class_Viewport>` which are children of :ref:`ViewportContainers "
"<class_viewportcontainer>`, these values are overridden, but for all others, "
"this sets their resolution."
msgstr ""
":ref:`Viewports <class_Viewport>` 有一个“size”属性，以像素为单位表示 :ref:"
"`Viewports <class_Viewport>` 的大小。 对 :ref:`ViewportContainers "
"<class_viewportcontainer>` 的子节点 :ref:`Viewports <class_Viewport>` ，这些"
"值被覆盖，但是在其他情况下，它设置了视区的分辨率。"

#: ../../docs/tutorials/viewports/viewports.rst:90
#, fuzzy
msgid ""
"It is also possible to scale the 2D content and make the :ref:`Viewport "
"<class_Viewport>` resolution different from the one specified in size, by "
"calling:"
msgstr ""
"通过调用以下语句，还可以缩放2D内容, 使其忽略 :ref:`Viewport "
"<class_Viewport>` 中已指定的视区分辨率:"

#: ../../docs/tutorials/viewports/viewports.rst:98
msgid ""
"The root :ref:`Viewport <class_Viewport>` uses this for the stretch options "
"in the project settings. For more information on scaling and stretching "
"visit the :ref:`Multiple Resolutions Tutorial <doc_multiple_resolutions>`"
msgstr ""
"根节点的 :ref:`Viewport <class_Viewport>` 用到项目设置中的拉伸选项。 有关缩放"
"和拉伸的更多信息，请访问 :ref:`Multiple Resolutions Tutorial "
"<doc_multiple_resolutions>`"

#: ../../docs/tutorials/viewports/viewports.rst:102
msgid "Worlds"
msgstr "世界"

#: ../../docs/tutorials/viewports/viewports.rst:104
#, fuzzy
msgid ""
"For 3D, a :ref:`Viewport <class_Viewport>` will contain a :ref:`World "
"<class_World>`. This is basically the universe that links physics and "
"rendering together. Spatial-base nodes will register using the :ref:`World "
"<class_World>` of the closest :ref:`Viewport <class_Viewport>`. By default, "
"newly created :ref:`Viewports <class_Viewport>` do not contain a :ref:`World "
"<class_World>` but use the same as their parent :ref:`Viewport "
"<class_Viewport>` (the root :ref:`Viewport <class_Viewport>` always contains "
"a :ref:`World <class_World>`, which is the one objects are rendered to by "
"default). A :ref:`World <class_World>` can be set in a :ref:`Viewport "
"<class_Viewport>` using the \"world\" property, and that will separate all "
"children nodes of that :ref:`Viewport <class_Viewport>` from interacting "
"with the parent :ref:`Viewport's <class_Viewport>` :ref:`World "
"<class_World>`. This is especially useful in scenarios where, for example, "
"you might want to show a separate character in 3D imposed over the game "
"(like in StarCraft)."
msgstr ""
"对于3D, 视区将包含一个 :ref:`World <class_World>` 类。这基本上就是一个把物理"
"和渲染联系在一起的宇宙世界。基于空间概念的节点将使用最接近的视区的世界进行注"
"册。默认情况下, 新创建的视区并不包含一个新的World对象, 而是使用与父视区相同的"
"World (但是根视区确实会包含一个World对象, 其他对象默认会渲染在里面)。可以使"
"用 \"world\" 属性在视区中设置一个世界, 这将隔离该视区的所有子节点同该视区的父"
"视区交互。这在某些情形下尤为有用, 例如, 您可能希望在游戏中以三维视角来看的上"
"方显示一个单独的字符(比如星际争霸)。"

#: ../../docs/tutorials/viewports/viewports.rst:116
msgid ""
"As a helper for situations where you want to create :ref:`Viewports "
"<class_Viewport>` that display single objects and don't want to create a :"
"ref:`World <class_World>`, :ref:`Viewport <class_Viewport>` has the option "
"to use its own :ref:`World <class_World>`. This is useful when you want to "
"instance 3D characters or objects in a 2D :ref:`World <class_World2D>`."
msgstr ""
"作为您想要创建的情况的帮助 :ref:`Viewports <class_Viewport>` 显示单个对象而不"
"想创建 :ref:`World <class_World>`， :ref:`Viewport <class_Viewport>` 可以选择"
"使用自己的 :ref:`World <class_World>`。 当您想要在2D :ref:`World "
"<class_World2D>` 中实例化3D角色或对象时，这非常有用。"

#: ../../docs/tutorials/viewports/viewports.rst:121
msgid ""
"For 2D, each :ref:`Viewport <class_Viewport>` always contains its own :ref:"
"`World2D <class_World2D>`. This suffices in most cases, but in case sharing "
"them may be desired, it is possible to do so by setting the :ref:`Viewport's "
"<class_Viewport>` :ref:`World2D <class_World2D>` manually."
msgstr ""
"对于2D，每个 :ref:`Viewport <class_Viewport>` 总是包含它自己的 :ref:`World2D "
"<class_World2D>` 。 这在大多数情况下都足够了，但是如果需要共享它们，可以手动"
"设置 :ref:`Viewport的 <class_Viewport>` :ref:`World2D <class_World2D>` 。"

#: ../../docs/tutorials/viewports/viewports.rst:125
#, fuzzy
msgid ""
"For an example of how this works, see the demo projects `3D in 2D <https://"
"github.com/godotengine/godot-demo-projects/tree/master/viewport/3d_in_2d>`_ "
"and `2D in 3D <https://github.com/godotengine/godot-demo-projects/tree/"
"master/viewport/2d_in_3d>`_ respectively."
msgstr ""
"有关其工作原理的示例，请分别参阅演示项目 `3D in 2D <https://github.com/"
"godotengine/godot-demo-projects/tree/master/viewport/3d_in_2d>`_ 和 `2D in "
"3D <https://github.com/godotengine/godot-demo-projects/tree/master/"
"viewport/2d_in_3d>`_ 。"

#: ../../docs/tutorials/viewports/viewports.rst:128
msgid "Capture"
msgstr "截图"

#: ../../docs/tutorials/viewports/viewports.rst:130
#, fuzzy
msgid ""
"It is possible to query a capture of the :ref:`Viewport <class_Viewport>` "
"contents. For the root :ref:`Viewport <class_Viewport>`, this is effectively "
"a screen capture. This is done with the following code:"
msgstr ""
"可以查询 :ref:`Viewport <class_Viewport>` 内容的捕获。 对于root :ref:"
"`Viewport <class_Viewport>` 这实际上是一个屏幕截图。 这是通过以下代码完成的:"

#: ../../docs/tutorials/viewports/viewports.rst:147
#, fuzzy
msgid ""
"But if you use this in _ready() or from the first frame of the :ref:"
"`Viewport's <class_Viewport>` initialization, you will get an empty texture "
"because there is nothing to get as texture. You can deal with it using (for "
"example):"
msgstr ""
"但是如果您在_ready()或者从 :ref:`Viewport的<class_Viewport>` 初始化的第一帧中"
"使用它，您将获得一个空纹理，因为没有什么可以作为纹理。 您可以使用(例如)处理"
"它:"

#: ../../docs/tutorials/viewports/viewports.rst:158
#, fuzzy
msgid ""
"If the returned image is empty, capture still didn't happen, wait a little "
"more, as Godot's rendering API is asynchronous. For a working example of "
"this, check out the `Screen Capture example <https://github.com/godotengine/"
"godot-demo-projects/tree/master/viewport/screen_capture>`_ in the demo "
"projects"
msgstr ""
"如果返回的图像为空，则捕获仍然没有发生，等待一点，因为Godot的渲染API是异步"
"的。 有关此示例，请查看演示项目中的 `屏幕捕获示例 <https://github.com/"
"godotengine/godot-demo-projects/tree/master/viewport/screen_capture>`_"

#: ../../docs/tutorials/viewports/viewports.rst:163
msgid "Viewport Container"
msgstr "视区容器"

#: ../../docs/tutorials/viewports/viewports.rst:165
msgid ""
"If the :ref:`Viewport <class_Viewport>` is a child of a :ref:"
"`ViewportContainer <class_viewportcontainer>`, it will become active and "
"display anything it has inside. The layout looks like this:"
msgstr ""
"如果 :ref:`Viewport <class_Viewport>` 是 :ref:`ViewportContainer "
"<class_viewportcontainer>` 的子节点，它将变为活动状态并显示其内部的任何内"
"容。 布局看起来像这样:"

#: ../../docs/tutorials/viewports/viewports.rst:169
msgid ""
"The :ref:`Viewport <class_Viewport>` will cover the area of its parent :ref:"
"`ViewportContainer <class_viewportcontainer>` completely if stretch is set "
"to true in :ref:`ViewportContainer <class_viewportcontainer>`. Note: The "
"size of the :ref:`ViewportContainer <class_viewportcontainer>` cannot be "
"smaller than the size of the :ref:`Viewport <class_Viewport>`."
msgstr ""
":ref:`Viewport <class_Viewport>` 将覆盖其父级的区域 :ref:`ViewportContainer "
"<class_viewportcontainer>` 如果在以下情况下将stretch设置为true :ref:"
"`ViewportContainer <class_viewportcontainer>`。 注意: :ref:"
"`ViewportContainer <class_viewportcontainer>` 的大小不能小于 :ref:`Viewport "
"<class_Viewport>` 的大小。"

#: ../../docs/tutorials/viewports/viewports.rst:176
#, fuzzy
msgid ""
"Due to the fact that the :ref:`Viewport <class_Viewport>` is an entryway "
"into another rendering surface, it exposes a few rendering properties that "
"can be different from the project settings. The first is MSAA; you can "
"choose to use a different level of MSAA for each :ref:`Viewport "
"<class_Viewport>`; the default behavior is DISABLED. You can also set the :"
"ref:`Viewport <class_Viewport>` to use HDR, HDR is very useful for when you "
"want to store values in the texture that are outside the range 0.0 - 1.0."
msgstr ""
"由于以下事实 :ref:`Viewport <class_Viewport>` 是进入另一个渲染表面的入口，它"
"会暴露一些可能与项目设置不同的渲染属性。 第一个是MSAA，您可以选择为每个使用不"
"同级别的MSAA :ref:`Viewport <class_Viewport>`，默认行为是DISABLED。 您还可以"
"设置 :ref:`Viewport <class_Viewport>` 以使用HDR，当您想要在纹理中存储超出"
"0.0  -  1.0范围的值时，HDR非常有用。"

#: ../../docs/tutorials/viewports/viewports.rst:181
#, fuzzy
msgid ""
"If you know how the :ref:`Viewport <class_Viewport>` is going to be used, "
"you can set its Usage to either 3D or 2D. Godot will then restrict how the :"
"ref:`Viewport <class_Viewport>` is drawn to in accordance with your choice; "
"default is 3D."
msgstr ""
"如果您知道如何使用 :ref:`Viewport <class_Viewport>` ，您可以将其用法设置为3D"
"或2D。 然后Godot将限制如何 :ref:`Viewport <class_Viewport>` 根据您的选择绘"
"制，默认为3D。"

#: ../../docs/tutorials/viewports/viewports.rst:184
msgid ""
"Godot also provides a way of customizing how everything is drawn inside :ref:"
"`Viewports <class_Viewport>` using “Debug Draw”. Debug Draw allows you to "
"specify one of four options for how the :ref:`Viewport <class_Viewport>` "
"will display things drawn inside it. Debug Draw is disabled by default."
msgstr ""
"Godot还提供了一种自定义内部绘制方式的方法 :ref:`Viewports <class_Viewport>` "
"使用“Debug Draw”。 Debug Draw允许您指定以下四个选项之一 :ref:`Viewport "
"<class_Viewport>` 将显示在其中绘制的内容。 默认情况下禁用Debug Draw。"

#: ../../docs/tutorials/viewports/viewports.rst:190
msgid "*A scene drawn with Debug Draw disabled*"
msgstr "*禁用Debug Draw绘制的场景*"

#: ../../docs/tutorials/viewports/viewports.rst:192
msgid ""
"The other three options are Unshaded, Overdraw, and Wireframe. Unshaded "
"draws the scene without using lighting information so all the objects appear "
"flatly colored the color of their albedo."
msgstr ""
"其他三个选项是Unhaded，Overdraw和Wireframe。 无阴影在不使用光照信息的情况下绘"
"制场景，因此所有对象都显示为其反照率颜色的扁平颜色。"

#: ../../docs/tutorials/viewports/viewports.rst:198
msgid "*The same scene with Debug Draw set to Unshaded*"
msgstr "* Debug Draw设置为Unshaded *的相同场景"

#: ../../docs/tutorials/viewports/viewports.rst:200
msgid ""
"Overdraw draws the meshes semi-transparent with an additive blend so you can "
"see how the meshes overlap."
msgstr "Overdraw使用添加剂混合绘制半透明的网格，以便您可以看到网格重叠的方式。"

#: ../../docs/tutorials/viewports/viewports.rst:204
msgid "*The same scene with Debug Draw set to Overdraw*"
msgstr "* Debug Draw设置为Overdraw的同一场景*"

#: ../../docs/tutorials/viewports/viewports.rst:206
msgid ""
"Lastly, Wireframe draws the scene using only the edges of triangles in the "
"meshes. NOTE: As of this writing (v3.0.2), wireframe mode is not functional "
"and currently renders the scene normally."
msgstr ""
"最后，Wireframe仅使用网格中三角形的边缘绘制场景。 注意:在撰写本文时(v3.0.2)，"
"线框模式不起作用，并且当前正常渲染场景。"

#: ../../docs/tutorials/viewports/viewports.rst:210
msgid "Render target"
msgstr "渲染目标"

#: ../../docs/tutorials/viewports/viewports.rst:212
#, fuzzy
msgid ""
"When rendering to a :ref:`Viewport <class_Viewport>`, whatever is inside "
"will not be visible in the scene editor. To display the contents, you have "
"to draw the :ref:`Viewport's <class_Viewport>` :ref:`ViewportTexture "
"<class_ViewportTexture>` somewhere. This can be requested via code using "
"(for example):"
msgstr ""
"渲染到 :ref:`Viewport <class_Viewport>时，内部的任何内容都不会在场景编辑器中"
"显示。 要显示内容，您必须绘制 :ref:`Viewport的<class_Viewport>` :ref:"
"`ViewportTexture <class_ViewportTexture>` 某处。 这可以通过代码使用(例如):"

#: ../../docs/tutorials/viewports/viewports.rst:222
msgid ""
"Or it can be assigned in the editor by selecting \"New ViewportTexture\""
msgstr "或者可以通过选择“New ViewportTexture”在编辑器中指定它"

#: ../../docs/tutorials/viewports/viewports.rst:226
msgid ""
"and then selecting the :ref:`Viewport <class_Viewport>` you want to use."
msgstr "然后选择您想要使用的 :ref:`Viewport <class_Viewport>。"

#: ../../docs/tutorials/viewports/viewports.rst:230
#, fuzzy
msgid ""
"Every frame, the :ref:`Viewport <class_Viewport>`'s texture is cleared away "
"with the default clear color (or a transparent color if Transparent BG is "
"set to true). This can be changed by setting Clear Mode to Never or Next "
"Frame. As the name implies, Never means the texture will never be cleared, "
"while next frame will clear the texture on the next frame and then set "
"itself to Never."
msgstr ""
"每个帧 :ref:`Viewport <class_Viewport>` 的纹理用默认的清晰颜色(如果"
"Transparent BG设置为true，则为透明颜色)清除。 这可以通过将清除模式设置为从不"
"或下一帧来更改。 顾名思义，Never表示纹理永远不会被清除，而下一帧将清除下一帧"
"的纹理，然后将自己设置为Never。"

#: ../../docs/tutorials/viewports/viewports.rst:235
#, fuzzy
msgid ""
"By default, re-rendering of the :ref:`Viewport <class_Viewport>` happens "
"when the :ref:`Viewport <class_Viewport>`'s :ref:`ViewportTexture "
"<class_ViewportTexture>` has been drawn in a frame. If visible, it will be "
"rendered; otherwise, it will not. This behavior can be changed to manual "
"rendering (once), or always render, no matter if visible or not. This "
"flexibility allows users to render an image once and then use the texture "
"without incurring the cost of rendering every frame."
msgstr ""
"默认情况下，重新渲染 :ref:`Viewport <class_Viewport>` 发生在 :ref:`Viewport "
"<class_Viewport>` s :ref:`ViewportTexture <class_ViewportTexture>` 已经在框架"
"中绘制。 如果可见，它将被渲染，否则不会。 无论是否可见，此行为都可以更改为手"
"动渲染(一次)或始终渲染。 这种灵活性允许用户渲染一次图像然后使用纹理而不会产生"
"渲染每一帧的成本。"

#: ../../docs/tutorials/viewports/viewports.rst:243
msgid ""
"Make sure to check the Viewport demos! Viewport folder in the demos archive "
"available to download, or https://github.com/godotengine/godot-demo-projects/"
"tree/master/viewport"
msgstr ""
"一定要查看Viewport演示！ 可以下载演示档案中的Viewport文件夹，或https://"
"github.com/godotengine/godot-demo-projects/tree/master/viewport"

#: ../../docs/tutorials/viewports/multiple_resolutions.rst:4
msgid "Multiple resolutions"
msgstr "多分辨率"

#: ../../docs/tutorials/viewports/multiple_resolutions.rst:7
msgid "Base size"
msgstr "基本大小"

#: ../../docs/tutorials/viewports/multiple_resolutions.rst:9
msgid ""
"A base size for the window can be specified in the project settings under "
"\"Display\", \"Window\"."
msgstr "可以在“显示”，“窗口”下的项目设置中指定窗口的基本大小。"

#: ../../docs/tutorials/viewports/multiple_resolutions.rst:14
msgid ""
"However, what it does is not completely obvious; the engine will *not* "
"attempt to switch the monitor to this resolution. Rather, think of this "
"setting as the \"design size\", i.e. the size of the area that you work with "
"in the editor. This setting corresponds directly to the size of the blue "
"rectangle in the 2D editor."
msgstr ""
"然而，它的作用并不完全明显; 引擎将 *不* 尝试将显示器切换到此分辨率。 相反，将"
"此设置视为“设计大小”，即您在编辑器中使用的区域的大小。 此设置直接对应于2D编辑"
"器中蓝色矩形的大小。"

#: ../../docs/tutorials/viewports/multiple_resolutions.rst:20
msgid ""
"There is often a need to support devices with screen and window sizes that "
"are different from this base size. Godot offers many ways to control how the "
"viewport will be resized and stretched to different screen sizes."
msgstr ""
"通常需要支持具有与该基本大小不同的屏幕和窗口大小的设备。 Godot提供了许多方法"
"来控制视区的大小调整和拉伸到不同的屏幕大小。"

#: ../../docs/tutorials/viewports/multiple_resolutions.rst:26
msgid "Resizing"
msgstr "调整大小"

#: ../../docs/tutorials/viewports/multiple_resolutions.rst:28
msgid ""
"There are several types of devices, with several types of screens, which in "
"turn have different pixel density and resolutions. Handling all of them can "
"be a lot of work, so Godot tries to make the developer's life a little "
"easier. The :ref:`Viewport <class_Viewport>` node has several functions to "
"handle resizing, and the root node of the scene tree is always a viewport "
"(scenes loaded are instanced as a child of it, and it can always be accessed "
"by calling ``get_tree().get_root()`` or ``get_node(\"/root\")``)."
msgstr ""
"市面上有着各种各样的设备, 拥有各种类型的屏幕, 依次有着不同的像素密度和分辨"
"率。处理所有的类型工作量巨大, 所以Godot试图让开发者的生活变得更简单。 :ref:"
"`Viewport <class_Viewport>` 节点提供了几个处理大小调整的函数, 而场景树的根节"
"点始终是一个Viewport (场景将作为它的子节点被实例化, 并且始终可以通过调用"
"``get_tree().get_root()`` 或``get_node(\"/root\")`` 来访问它。"

#: ../../docs/tutorials/viewports/multiple_resolutions.rst:37
msgid ""
"In any case, while changing the root Viewport params is probably the most "
"flexible way to deal with the problem, it can be a lot of work, code and "
"guessing, so Godot provides a simple set of parameters in the project "
"settings to handle multiple resolutions."
msgstr ""
"在任何情况下, 虽然更改”根视区“的参数可能是解决问题的最灵活方法, 但这样做的可"
"能包含大量工作、大量代码和大量推测过程, 因此Godot在“项目设置”中提供了一组简单"
"的参数来处理多分辨率问题。"

#: ../../docs/tutorials/viewports/multiple_resolutions.rst:43
msgid "Stretch settings"
msgstr "拉伸设置"

#: ../../docs/tutorials/viewports/multiple_resolutions.rst:45
msgid ""
"Stretch settings are located in the project settings, it's just a bunch of "
"configuration variables that provide several options:"
msgstr "拉伸设置位于项目设置中, 它只是一系列提供多种选项的配置变量:"

#: ../../docs/tutorials/viewports/multiple_resolutions.rst:51
msgid "Stretch Mode"
msgstr "拉伸模式 (Stretch mode)"

#: ../../docs/tutorials/viewports/multiple_resolutions.rst:53
msgid ""
"The \"Stretch Mode\" setting defines how the base size is stretched to fit "
"the resolution of the window or screen."
msgstr "“拉伸模式”设置定义如何拉伸基本大小以适合窗口或屏幕的分辨率。"

#: ../../docs/tutorials/viewports/multiple_resolutions.rst:58
msgid ""
"The animations below use a \"base size\" of just 16×9 pixels to demonstrate "
"the effect of different stretch modes. A single sprite, also 16×9 pixels in "
"size, covers the entire viewport, and a diagonal :ref:`Line2D "
"<class_Line2D>` is added on top of it:"
msgstr ""
"下面的动画使用仅16×9像素的“基本大小”来演示不同拉伸模式的效果。 单个精灵，大小"
"也是16×9像素，覆盖整个视区，并在其上添加一个对角线 :ref:`Line2D "
"<class_Line2D>` :"

#: ../../docs/tutorials/viewports/multiple_resolutions.rst:68
msgid ""
"Stretch Mode = **Disabled** (default): No stretching happens. One unit in "
"the scene corresponds to one pixel on the screen. In this mode, the "
"\"Stretch Aspect\" setting has no effect."
msgstr ""
"拉伸模式= **禁用**(默认值):不进行拉伸。 场景中的一个单元对应于屏幕上的一个像"
"素。 在此模式下，“拉伸纵横比”设置无效。"

#: ../../docs/tutorials/viewports/multiple_resolutions.rst:72
msgid ""
"This is a good option if you want full control over every screen pixel, and "
"is probably the best option for 3D games."
msgstr ""
"如果您想要完全控制每个屏幕像素，这是一个不错的选择，并且可能是3D游戏的最佳选"
"择。"

#: ../../docs/tutorials/viewports/multiple_resolutions.rst:77
msgid ""
"Stretch Mode = **2D**: In this mode, the size specified in display/width and "
"display/height in the project settings will be stretched to cover the whole "
"screen (taking the \"Stretch Aspect\" setting into account). This means that "
"everything will be rendered directly at the target resolution. 3D will be "
"largely unaffected, while in 2D there is no longer a 1:1 correspondence "
"between sprite pixels and screen pixels, which may result in scaling "
"artifacts."
msgstr ""
"拉伸模式= ** 2D**: 在此模式下，项目设置中显示/宽度和显示/高度中指定的大小将被"
"拉伸以覆盖整个屏幕(考虑“拉伸方面”设置)。 这意味着所有内容都将直接以目标分辨率"
"呈现。 3D将基本上不受影响，而在2D中，精灵像素和屏幕像素之间不再存在1:1的对应"
"关系，这可能导致缩放伪像。"

#: ../../docs/tutorials/viewports/multiple_resolutions.rst:85
msgid ""
"This is a good option if your 2D artwork has a sufficiently high resolution "
"and does not require pixel-perfect rendering. Consider enabling texture "
"filtering and mipmapping on your 2D textures and fonts."
msgstr ""
"如果您的2D图稿具有足够高的分辨率并且不需要像素完美渲染，那么这是一个不错的选"
"择。 考虑在2D纹理和字体上启用纹理过滤和mipmapping。"

#: ../../docs/tutorials/viewports/multiple_resolutions.rst:92
msgid ""
"Stretch Mode = **Viewport**: Viewport scaling means that the size of the "
"root :ref:`Viewport <class_Viewport>` is set precisely to the base size "
"specified in the \"Display\" section of the project settings. The scene is "
"rendered to this viewport first. Finally, this viewport is scaled to fit the "
"screen (taking the \"Stretch Aspect\" setting into account)."
msgstr ""
"拉伸模式= **Viewport**: 视区缩放意味着根 :ref:`Viewport <class_Viewport>` 的"
"大小精确设置为项目设置的“显示”部分中指定的基本大小。 首先将场景渲染到此视"
"区。 最后，缩放此视区以适合屏幕(考虑“拉伸方面”设置)。"

#: ../../docs/tutorials/viewports/multiple_resolutions.rst:99
msgid ""
"This mode is useful when working with pixel-precise games, or for the sake "
"of rendering to a lower resolution for improving performance."
msgstr ""
"在使用像素精确游戏时，或者为了提高性能而渲染到较低分辨率，此模式非常有用。"

#: ../../docs/tutorials/viewports/multiple_resolutions.rst:105
msgid "Stretch Aspect"
msgstr "拉伸比例(Stretch aspect)"

#: ../../docs/tutorials/viewports/multiple_resolutions.rst:107
msgid ""
"The second setting is the stretch aspect. Note that this only takes effect "
"if \"Stretch Mode\" is set to something other than \"disabled\"."
msgstr ""
"第二个设置是拉伸方面。 请注意，仅当“拉伸模式”设置为“禁用”以外的其他值时，此操"
"作才会生效。"

#: ../../docs/tutorials/viewports/multiple_resolutions.rst:110
msgid ""
"In the animations below, you will notice gray and black areas. The black "
"areas are added by the engine and cannot be drawn into. The gray areas are "
"part of your scene, and can be drawn to. The gray areas correspond to the "
"region outside the blue frame you see in the 2D editor."
msgstr ""
"在下面的动画中，您会注意到灰色和黑色区域。 黑色区域由引擎添加，无法绘制。 灰"
"色区域是场景的一部分，可以绘制。 灰色区域对应于您在2D编辑器中看到的蓝色框架外"
"的区域。"

#: ../../docs/tutorials/viewports/multiple_resolutions.rst:115
msgid ""
"Stretch Aspect = **Ignore**: Ignore the aspect ratio when stretching the "
"screen. This means that the original resolution will be stretched to exactly "
"fill the screen, even if it's wider or narrower. This may result in "
"nonuniform stretching: things looking wider or taller than designed."
msgstr ""
"拉伸纵横比= **忽略**:拉伸屏幕时忽略纵横比。 这意味着原始分辨率将被拉伸以准确"
"填充屏幕，即使它更宽或更窄。 这可能导致拉伸不均匀:看起来比设计更宽或更高的东"
"西。"

#: ../../docs/tutorials/viewports/multiple_resolutions.rst:123
msgid ""
"Stretch Aspect = **Keep**: Keep aspect ratio when stretching the screen. "
"This means that the viewport retains its original size regardless of the "
"screen resolution, and black bars will be added to the top/bottom of the "
"screen (\"letterboxing\") or the sides (\"pillarboxing\")."
msgstr ""
"拉伸纵横比= **保持**:拉伸屏幕时保持纵横比。 这意味着无论屏幕分辨率如何，视区"
"都会保留其原始大小，并且黑色条将添加到屏幕的顶部/底部(“letterboxing”)或侧面"
"(“pillarboxing”)。"

#: ../../docs/tutorials/viewports/multiple_resolutions.rst:129
msgid ""
"This is a good option if you know the aspect ratio of your target devices in "
"advance, or if you don't want to handle different aspect ratios."
msgstr ""
"如果您事先知道目标设备的宽高比，或者您不想处理不同的宽高比，这是一个不错的选"
"择。"

#: ../../docs/tutorials/viewports/multiple_resolutions.rst:135
msgid ""
"Stretch Aspect = **Keep Width**: Keep aspect ratio when stretching the "
"screen. If the screen is wider than the base size, black bars are added at "
"the left and right (pillarboxing). But if the screen is taller than the base "
"resolution, the viewport will be grown in the vertical direction (and more "
"content will be visible to the bottom). You can also think of this as "
"\"Expand Vertically\"."
msgstr ""
"拉伸纵横比= **保持宽度**:拉伸屏幕时保持纵横比。 如果屏幕宽于基本大小，则在左"
"侧和右侧添加黑条(柱框)。 但是如果屏幕高于基本分辨率，则视区将在垂直方向上生长"
"(并且底部可以看到更多内容)。 您也可以将其视为“垂直展开”。"

#: ../../docs/tutorials/viewports/multiple_resolutions.rst:142
msgid ""
"This is usually the best option for creating GUIs or HUDs that scale, so "
"some controls can be anchored to the bottom (:ref:`doc_size_and_anchors`)."
msgstr ""
"这通常是创建可扩展的GUI或HUD的最佳选择，因此一些控件可以锚定到底部( :ref:"
"`doc_size_and_anchors`)。"

#: ../../docs/tutorials/viewports/multiple_resolutions.rst:148
msgid ""
"Stretch Aspect = **Keep Height**: Keep aspect ratio when stretching the "
"screen. If the screen is taller than the base size, black bars are added at "
"the top and bottom (letterboxing). But if the screen is wider than the base "
"resolution, the viewport will be grown in the horizontal direction (and more "
"content will be visible to the right). You can also think of this as "
"\"Expand Horizontally\"."
msgstr ""
"拉伸纵横比= **保持高度**:拉伸屏幕时保持纵横比。 如果屏幕高于基本大小，则在顶"
"部和底部添加黑条(letterboxing)。 但是，如果屏幕比基本分辨率宽，则视区将在水平"
"方向上生长(并且右侧可以看到更多内容)。 您也可以将其视为“水平扩展”。"

#: ../../docs/tutorials/viewports/multiple_resolutions.rst:155
msgid ""
"This is usually the best option for 2D games that scroll horizontally (like "
"runners or platformers)."
msgstr "这通常是水平滚动的2D游戏的最佳选择(如跑步者或平台游戏者)。"

#: ../../docs/tutorials/viewports/multiple_resolutions.rst:160
msgid ""
"Stretch Aspect = **Expand**: Keep aspect ratio when stretching the screen, "
"but keep neither the base width nor height. Depending on the screen aspect "
"ratio, the viewport will either be larger in the horizontal direction (if "
"the screen is wider than the base size) or in the vertical direction (if the "
"screen is taller than the original size)."
msgstr ""
"拉伸纵横比= **展开**:拉伸屏幕时保持纵横比，但既不保持基本宽度也不保持高度。 "
"根据屏幕宽高比，视区将在水平方向上较大(如果屏幕宽于基本大小)或在垂直方向上(如"
"果屏幕高于原始大小)。"

#: ../../docs/tutorials/viewports/multiple_resolutions.rst:170
msgid "Stretch Shrink"
msgstr "拉伸收缩"

#: ../../docs/tutorials/viewports/multiple_resolutions.rst:172
msgid ""
"The \"Shrink\" setting allows you to add an extra scaling factor on top of "
"what the \"Stretch\" options above already provide. The default value of 1 "
"means that no scaling occurs."
msgstr ""
"“收缩”设置允许您在上面提供的“拉伸”选项之上添加额外的缩放系数。 默认值1表示不"
"进行缩放。"

#: ../../docs/tutorials/viewports/multiple_resolutions.rst:176
msgid ""
"If, for example, you set \"Shrink\" to 4 and leave \"Stretch Mode\" on "
"\"Disabled\", each unit in your scene will correspond to 4×4 pixels on the "
"screen."
msgstr ""
"例如，如果将“Shrink”设置为4并将“Stretch Mode”设置为“Disabled”，则场景中的每个"
"单元将对应于屏幕上的4×4像素。"

#: ../../docs/tutorials/viewports/multiple_resolutions.rst:180
msgid ""
"If \"Stretch Mode\" is set to something other than \"Disabled\", the size of "
"the root viewport is scaled down by the \"Shrink\" factor, and pixels in the "
"output are scaled up by the same amount. This is rarely useful for 2D games, "
"but can be used to increase performance in 3D games by rendering them at a "
"lower resolution."
msgstr ""
"如果将“拉伸模式”设置为“禁用”以外的其他值，则根视区的大小将按“缩小”因子缩小，"
"并且输出中的像素按比例放大。 这对2D游戏很少有用，但可以通过以较低分辨率渲染来"
"提高3D游戏的性能。"

#: ../../docs/tutorials/viewports/multiple_resolutions.rst:187
msgid "From scripts"
msgstr "来自脚本"

#: ../../docs/tutorials/viewports/multiple_resolutions.rst:189
#, fuzzy
msgid ""
"To configure stretching at runtime from a script, use the ``get_tree()."
"set_screen_stretch()`` function (see :ref:`SceneTree.set_screen_stretch() "
"<class_SceneTree_method_set_screen_stretch>`)."
msgstr ""
"要在运行时从脚本配置拉伸，请使用 ``get_tree().set_screen_stretch()`` 函数(请"
"参阅 :ref:`SceneTree.set_screen_stretch() "
"<class_SceneTree_method_set_screen_stretch>`)。"

#: ../../docs/tutorials/viewports/using_viewport_as_texture.rst:4
msgid "Using a Viewport as a texture"
msgstr "使用视区作为纹理"

#: ../../docs/tutorials/viewports/using_viewport_as_texture.rst:9
#, fuzzy
msgid ""
"This tutorial will introduce you to using the :ref:`Viewport "
"<class_Viewport>` as a texture that can be applied to 3D objects. In order "
"to do so, it will walk you through the process of making a procedural planet "
"like the one below:"
msgstr ""
"本教程将向您介绍如何使用 :ref:`Viewport <class_Viewport>` 作为可应用于3D对象"
"的纹理。 为了做到这一点，它将引导您完成制作程序行星的过程，如下所示:"

#: ../../docs/tutorials/viewports/using_viewport_as_texture.rst:15
msgid ""
"This tutorial does not cover how to code a dynamic atmosphere like the one "
"this planet has."
msgstr "本教程没有介绍如何编写像这个星球那样的动态氛围。"

#: ../../docs/tutorials/viewports/using_viewport_as_texture.rst:17
msgid ""
"This tutorial assumes you are familiar with how to set up a basic scene "
"including: a :ref:`Camera <class_Camera>`, a :ref:`light source "
"<class_OmniLight>`, a :ref:`Mesh Instance <class_MeshInstance>` with a :ref:"
"`Primitive Mesh <class_PrimitiveMesh>`, and applying a :ref:`Spatial "
"Material <class_SpatialMaterial>` to the mesh. The focus will be on using "
"the :ref:`Viewport <class_Viewport>` to dynamically create textures that can "
"be applied to the mesh."
msgstr ""
"本教程假设您熟悉如何设置基本场景，包括:a :ref:`Camera <class_Camera>`，a :"
"ref:`light source <class_OmniLight>`，a :ref:`Mesh Instance "
"<class_MeshInstance>` 使用a :ref:`Primitive Mesh <class_PrimitiveMesh>`，并"
"将 :ref:`Spatial Material <class_SpatialMaterial>` 应用于网格。 重点是使用 :"
"ref:`Viewport <class_Viewport>` 来动态创建可应用于网格的纹理。"

#: ../../docs/tutorials/viewports/using_viewport_as_texture.rst:23
#, fuzzy
msgid "During the course of this tutorial, we'll cover the following topics:"
msgstr "在本教程中，课程将涵盖以下主题:"

#: ../../docs/tutorials/viewports/using_viewport_as_texture.rst:25
msgid "How to use a :ref:`Viewport <class_Viewport>` as a render texture"
msgstr "如何使用 :ref:`Viewport <class_Viewport>` 作为渲染纹理"

#: ../../docs/tutorials/viewports/using_viewport_as_texture.rst:26
msgid "Mapping a texture to a sphere with equirectangular mapping"
msgstr "使用equirectangular映射将纹理映射到球体"

#: ../../docs/tutorials/viewports/using_viewport_as_texture.rst:27
msgid "Fragment shader techniques for procedural planets"
msgstr "程序行星的碎片着色器技术"

#: ../../docs/tutorials/viewports/using_viewport_as_texture.rst:28
msgid ""
"Setting a Roughness map from a :ref:`Viewport Texture "
"<class_ViewportTexture>`"
msgstr "从a :ref:`Viewport Texture <class_ViewportTexture>` 设置粗糙度贴图"

#: ../../docs/tutorials/viewports/using_viewport_as_texture.rst:31
msgid "Setting up the Viewport"
msgstr "设置视区"

#: ../../docs/tutorials/viewports/using_viewport_as_texture.rst:33
msgid "First, add a :ref:`Viewport <class_Viewport>` to the scene."
msgstr "首先，在场景中添加 :ref:`Viewport <class_Viewport>` 。"

#: ../../docs/tutorials/viewports/using_viewport_as_texture.rst:35
#, fuzzy
msgid ""
"Next, set the size of the :ref:`Viewport <class_Viewport>` to ``(1024, "
"512)``. The :ref:`Viewport <class_Viewport>` can actually be any size so "
"long as the width is double the height. The width needs to be double the "
"height so that the image will accurately map onto the sphere, as we will be "
"using equirectangular projection, but more on that later."
msgstr ""
"接下来，将 :ref:`Viewport <class_Viewport>` 的大小设置为``(1024,512)``。 :"
"ref:`Viewport <class_Viewport>` 实际上可以是任何大小，只要宽度是高度的两倍。 "
"宽度需要是高度的两倍，以便图像准确地映射到球体上，因为我们将使用"
"equirectangular投影，但稍后会更多。"

#: ../../docs/tutorials/viewports/using_viewport_as_texture.rst:42
#, fuzzy
msgid ""
"Next, disable HDR and disable 3D. We don't need HDR because our planet's "
"surface will not be especially bright, so values between ``0`` and ``1`` "
"will be fine. And we will be using a :ref:`ColorRect <class_ColorRect>` to "
"render the surface, so we don't need 3D either."
msgstr ""
"接下来，禁用HDR并禁用3D。 我们不需要HDR，因为我们的行星表面不会特别明亮，所"
"以“0”和“1”之间的值会很好。 我们将使用 :ref:`ColorRect <class_ColorRect>` 来渲"
"染表面，所以我们也不需要3D。"

#: ../../docs/tutorials/viewports/using_viewport_as_texture.rst:46
msgid ""
"Select the Viewport and add a :ref:`ColorRect <class_ColorRect>` as a child."
msgstr "选择视区并添加 :ref:`ColorRect <class_ColorRect>` 作为子项。"

#: ../../docs/tutorials/viewports/using_viewport_as_texture.rst:48
msgid ""
"Set the anchors \"Right\" and \"Bottom\" to ``1``, then make sure all the "
"margins are set to ``0``. This will ensure that the :ref:`ColorRect "
"<class_ColorRect>` takes up the entire :ref:`Viewport <class_Viewport>`."
msgstr ""
"将锚“Right”和“Bottom”设置为“1”，然后确保所有边距都设置为“0”。 这将确保 :ref:"
"`ColorRect <class_ColorRect>` 占用整个 :ref:`Viewport <class_Viewport>`。"

#: ../../docs/tutorials/viewports/using_viewport_as_texture.rst:53
#, fuzzy
msgid ""
"Next, we add a :ref:`Shader Material <class_ShaderMaterial>` to the :ref:"
"`ColorRect <class_ColorRect>` (ColorRect > CanvasItem > Material > Material "
"> ``New ShaderMaterial``)."
msgstr ""
"接下来，我们将 :ref:`Shader Material <class_ShaderMaterial>` 添加到 :ref:"
"`ColorRect <class_ColorRect>`。"

#: ../../docs/tutorials/viewports/using_viewport_as_texture.rst:55
#, fuzzy
msgid ""
"Basic familiarity with shading is recommended for this tutorial. However, "
"even if you are new to shaders, all the code will be provided, so you should "
"have no problem following along."
msgstr ""
"我们假设您熟悉本教程的着色基础知识。 即使您不是，所有的代码仍然会提供，所以您"
"应该没有问题。"

#: ../../docs/tutorials/viewports/using_viewport_as_texture.rst:58
msgid ""
"ColorRect > CanvasItem > Material > Material > click / Edit > ShaderMaterial "
"> Shader > ``New Shader`` > click / Edit:"
msgstr ""

#: ../../docs/tutorials/viewports/using_viewport_as_texture.rst:68
msgid "The above code renders a gradient like the one below."
msgstr "上面的代码呈现如下所示的渐变。"

#: ../../docs/tutorials/viewports/using_viewport_as_texture.rst:72
msgid ""
"Now we have the basics of a :ref:`Viewport <class_Viewport>` that we render "
"to and we have a unique image that we can apply to the sphere."
msgstr ""
"现在我们有一个基础 :ref:`Viewport <class_Viewport>` 我们渲染到的，我们有一个"
"可以应用于球体的独特图像。"

#: ../../docs/tutorials/viewports/using_viewport_as_texture.rst:76
msgid "Applying the texture"
msgstr "应用纹理"

#: ../../docs/tutorials/viewports/using_viewport_as_texture.rst:78
msgid ""
"MeshInstance > GeometryInstance > Geometry > Material Override > ``New "
"SpatialMaterial``:"
msgstr ""

#: ../../docs/tutorials/viewports/using_viewport_as_texture.rst:80
msgid ""
"Now we go into the :ref:`Mesh Instance <class_MeshInstance>` and add a :ref:"
"`Spatial Material <class_SpatialMaterial>` to it. No need for a special :ref:"
"`Shader Material <class_ShaderMaterial>` (although that would be a good idea "
"for more advanced effects, like the atmosphere in the example above)."
msgstr ""
"现在我们进入 :ref:`Mesh Instance <class_MeshInstance>` 并向它添加一个 :ref:"
"`Spatial Material <class_SpatialMaterial>` 。 不需要特殊的 :ref:`Shader "
"Material <class_ShaderMaterial>` (虽然这对于更高级的效果来说是个好主意，比如"
"上面示例中的氛围)。"

#: ../../docs/tutorials/viewports/using_viewport_as_texture.rst:84
msgid ""
"MeshInstance > GeometryInstance > Geometry > Material Override > ``click`` / "
"``Edit``:"
msgstr ""

#: ../../docs/tutorials/viewports/using_viewport_as_texture.rst:86
msgid ""
"Open the newly created :ref:`Spatial Material <class_SpatialMaterial>` and "
"scroll down to the \"Albedo\" section and click beside the \"Texture\" "
"property to add an Albedo Texture. Here we will apply the texture we made. "
"Choose \"New ViewportTexture\""
msgstr ""
"打开新创建的 :ref:`Spatial Material <class_SpatialMaterial>` 并向下滚动"
"到“Albedo”部分，然后单击“Texture”属性旁边的以添加Albedo纹理。 在这里，我们将"
"应用我们制作的纹理。 选择“New ViewportTexture”"

#: ../../docs/tutorials/viewports/using_viewport_as_texture.rst:92
#, fuzzy
msgid ""
"Then, from the menu that pops up, select the Viewport that we rendered to "
"earlier."
msgstr "然后从弹出的菜单中选择我们之前渲染的视区。"

#: ../../docs/tutorials/viewports/using_viewport_as_texture.rst:96
#, fuzzy
msgid ""
"Your sphere should now be colored in with the colors we rendered to the "
"Viewport."
msgstr "现在，您的球体应使用我们渲染到视区的颜色进行着色"

#: ../../docs/tutorials/viewports/using_viewport_as_texture.rst:100
#, fuzzy
msgid ""
"Notice the ugly seam that forms where the texture wraps around? This is "
"because we are picking a color based on UV coordinates and UV coordinates do "
"not wrap around the texture. This is a classic problem in 2D map projection. "
"Game developers often have a 2-dimensional map they want to project onto a "
"sphere, but when it wraps around, it has large seams. There is an elegant "
"workaround for this problem that we will illustrate in the next section."
msgstr ""
"注意形成纹理的地方形成的丑陋缝隙？ 这是因为我们正在选择基于UV坐标的颜色，并且"
"UV坐标不会环绕纹理。 这是2D地图投影中的经典问题。 Gamedevs通常有一个他们希望"
"投射到球体上的二维地图，但当它环绕时它有大的接缝。 这个问题有一个优雅的工作，"
"我们将在下一节中说明。"

#: ../../docs/tutorials/viewports/using_viewport_as_texture.rst:107
msgid "Making the planet texture"
msgstr "使行星纹理"

#: ../../docs/tutorials/viewports/using_viewport_as_texture.rst:109
#, fuzzy
msgid ""
"So now, when we render to our :ref:`Viewport <class_Viewport>`, it appears "
"magically on the sphere. But there is an ugly seam created by our texture "
"coordinates. So how do we get a range of coordinates that wrap around the "
"sphere in a nice way? One solution is to use a function that repeats on the "
"domain of our texture. ``sin`` and ``cos`` are two such functions. Let's "
"apply them to the texture and see what happens."
msgstr ""
"所以现在我们渲染到我们的 :ref:`Viewport <class_Viewport>` 它在球体上神奇地出"
"现了。 但是我们的纹理坐标会产生一个丑陋的缝隙。 那么我们如何以一种很好的方式"
"获得围绕球体的一系列坐标？ 一种解决方案是使用在纹理域上重复的函数。 ``sin``和"
"``cos``是两个这样的函数。 让我们将它们应用于纹理，看看会发生什么"

#: ../../docs/tutorials/viewports/using_viewport_as_texture.rst:120
#, fuzzy
msgid ""
"Not too bad. If you look around, you can see that the seam has now "
"disappeared, but in its place, we have pinching at the poles. This pinching "
"is due to the way Godot maps textures to spheres in its :ref:`Spatial "
"Material <class_SpatialMaterial>`. It uses a projection technique called "
"equirectangular projection, which translates a spherical map onto a 2D plane."
msgstr ""
"还不错。 如果您环顾四周，您可以看到接缝已经消失了，但在它的位置，我们已经在两"
"极捏了一下。 这种捏合是由于Godot将纹理映射到其中的球体的方式 :ref:`Spatial "
"Material <class_SpatialMaterial>`。 它使用一种称为equirectangular投影的投影技"
"术。 这将球形地图转换为2D平面。"

#: ../../docs/tutorials/viewports/using_viewport_as_texture.rst:125
#, fuzzy
msgid ""
"If you are interested in a little extra information on the technique, we "
"will be converting from spherical coordinates into Cartesian coordinates. "
"Spherical coordinates map the longitude and latitude of the sphere, while "
"Cartesian coordinates are, for all intents and purposes, a vector from the "
"center of the sphere to the point."
msgstr ""
"如果您对该技术的一些额外信息感兴趣，我们将从球坐标转换为笛卡尔坐标。 球面坐标"
"映射球体的经度和纬度，而笛卡尔坐标用于所有意图和目的，是从球体中心到点的向"
"量。"

#: ../../docs/tutorials/viewports/using_viewport_as_texture.rst:130
#, fuzzy
msgid ""
"For each pixel, we will calculate its 3D position on the sphere. From that, "
"we will use 3D noise to determine a color value. By calculating the noise in "
"3D, we solve the problem of the pinching at the poles. To understand why, "
"picture the noise being calculated across the surface of the sphere instead "
"of across the 2D plane. When you calculate across the surface of the sphere, "
"you never hit an edge, and hence you never create a seam or a pinch point on "
"the pole. The following code converts the ``UVs`` into Cartesian coordinates."
msgstr ""
"对于每个像素，我们将计算其在球体上的3D位置。 由此我们将使用3D噪声来确定颜色"
"值。 通过计算3D中的噪声，我们解决了极点挤压的问题。 要了解原因，请记录在球体"
"表面而不是在2D平面上计算的噪声。 当您跨越球体表面进行计算时，您永远不会碰到边"
"缘，因此您永远不会在杆上创建接缝或夹点。 以下代码将 ``UVs`` 转换为Cartesion坐"
"标。"

#: ../../docs/tutorials/viewports/using_viewport_as_texture.rst:149
#, fuzzy
msgid "And if we use ``unit`` as an output ``COLOR`` value, we get:"
msgstr "如果我们使用 ``unit`` 作为输出 ``COLOR`` 值，我们得到。"

#: ../../docs/tutorials/viewports/using_viewport_as_texture.rst:153
#, fuzzy
msgid ""
"Now that we can calculate the 3D position of the surface of the sphere, we "
"can use 3D noise to make the planet. We will be using this noise function "
"directly from a `Shadertoy <https://www.shadertoy.com/view/Xsl3Dl>`_:"
msgstr ""
"现在我们可以计算球体表面的3D位置，我们可以使用3D噪声来制作行星。 我们将直接从"
"`Shadertoy <https://www.shadertoy.com/view/4dffRH>`_ 使用此噪音功能:"

#: ../../docs/tutorials/viewports/using_viewport_as_texture.rst:181
#, fuzzy
msgid ""
"All credit goes to the author, Inigo Quilez. It is published under the "
"``MIT`` licence."
msgstr "归功于最初的作者Inigo Quilez。 它与 ``MIT`` 许可证一起发布。"

#: ../../docs/tutorials/viewports/using_viewport_as_texture.rst:183
msgid ""
"Now to use ``noise``, add the following to the    ``fragment`` function:"
msgstr "现在使用 ``noised`` ，将以下内容添加到 ``fragment`` 函数中:"

#: ../../docs/tutorials/viewports/using_viewport_as_texture.rst:192
msgid "In order to highlight the texture, we set the material to unshaded."
msgstr "为了突出显示纹理，我们将材质设置为无阴影。"

#: ../../docs/tutorials/viewports/using_viewport_as_texture.rst:194
#, fuzzy
msgid ""
"You can see now that the noise indeed wraps seamlessly around the sphere. "
"Although this looks nothing like the planet you were promised. So let's move "
"onto something more colorful."
msgstr ""
"您现在可以看到噪音确实在球体周围无缝包。 虽然这看起来不像您所承诺的星球。 所"
"以让我们进入更丰富多彩的东西。"

#: ../../docs/tutorials/viewports/using_viewport_as_texture.rst:198
msgid "Coloring the planet"
msgstr "着色这个星球"

#: ../../docs/tutorials/viewports/using_viewport_as_texture.rst:200
#, fuzzy
msgid ""
"Now to make the planet colors. While there are many ways to do this, for "
"now, we will stick with a gradient between water and land."
msgstr ""
"现在要让行星变色。 虽然，有很多方法可以做到这一点，现在我们将坚持水和土地之间"
"的梯度。"

#: ../../docs/tutorials/viewports/using_viewport_as_texture.rst:203
#, fuzzy
msgid ""
"To make a gradient in GLSL, we use the ``mix`` function. ``mix`` takes two "
"values to interpolate between and a third argument to choose how much to "
"interpolate between them; in essence, it *mixes* the two values together. In "
"other APIs, this function is often called ``lerp``. However, ``lerp`` is "
"typically reserved for mixing two floats together; ``mix`` can take any "
"values whether it be floats or vector types."
msgstr ""
"要在glsl中创建渐变，我们使用 ``mix`` 函数。  ``mix`` 需要两个值来插值和第三个"
"参数来选择在它们之间插入多少，实质上它*将两个值混合在一起。 在其他API中，此函"
"数通常称为 ``lerp`` 。 虽然 ``lerp`` 通常用于将两个浮点数混合在一起，但 "
"``mix`` 可以取任何值，无论它是浮点数还是向量类型。"

#: ../../docs/tutorials/viewports/using_viewport_as_texture.rst:213
#, fuzzy
msgid ""
"The first color is blue for the ocean. The second color is a kind of reddish "
"color (because all alien planets need red terrain). And finally, they are "
"mixed together by ``n * 0.5 + 0.5``. ``n`` smoothly varies between ``-1`` "
"and ``1``. So we map it into the ``0-1`` range that ``mix`` expects. Now you "
"can see that the colors change between blue and red."
msgstr ""
"海洋的第一种颜色是蓝色。 第二种颜色是一种带红色的颜色(因为所有外星球都需要红"
"色地形)。 最后他们通过``n.x * 0.5 + 0.5``混合在一起。 ``n.x``在``-1``和``1``"
"之间平滑变化。 所以我们把它映射到 ``mix`` 期望的 ``0-1`` 范围。 现在您可以看"
"到颜色在蓝色和红色之间变化。"

#: ../../docs/tutorials/viewports/using_viewport_as_texture.rst:220
#, fuzzy
msgid ""
"That is a little more blurry than we want. Planets typically have a "
"relatively clear separation between land and sea. In order to do that, we "
"will change the last term to ``smoothstep(-0.1, 0.0, n)``. And thus the "
"whole line becomes:"
msgstr ""
"这比我们想要的要模糊一些。 行星通常在陆地和海洋之间具有相对清晰的分离。 为了"
"做到这一点，我们将最后一个术语改为“smoothstep(-0.1,0.0，n.x)``。 因此整条线变"
"为:"

#: ../../docs/tutorials/viewports/using_viewport_as_texture.rst:228
#, fuzzy
msgid ""
"What ``smoothstep`` does is return ``0`` if the third argument is below the "
"first and ``1`` if the third argument is larger than the second and smoothly "
"blends between ``0`` and ``1`` if the third number is between the first and "
"the second. So in this line, ``smoothstep`` returns ``0`` whenever ``n`` is "
"less than ``-0.1`` and it returns ``1`` whenever ``n`` is above ``0``."
msgstr ""
"如果第三个参数低于第一个参数，那么`smoothstep``会返回``0``，如果第三个参数大"
"于第二个参数，则返回1，如果第三个参数在第一个参数之间平滑地混合，则返回 "
"``0`` ` 第三个数字在第一个和第二个之间。 因此，当 ``nx`` 小于`-0.1``时， "
"``smoothstep`` 返回 ``0`` ，并且每当 ``nx`` 高于``0时'它返回``1```。"

#: ../../docs/tutorials/viewports/using_viewport_as_texture.rst:235
#, fuzzy
msgid ""
"One more thing to make this a little more planet-y. The land shouldn't be so "
"blobby; let's make the edges a little rougher. A trick that is often used in "
"shaders to make rough looking terrain with noise is to layer levels of noise "
"over one another at various frequencies. We use one layer to make the "
"overall blobby structure of the continents. Then another layer breaks up the "
"edges a bit, and then another, and so on. What we will do is calculate ``n`` "
"with four lines of shader code instead of just one. ``n`` becomes:"
msgstr ""
"还有一件事要让它变得更加美丽。 土地不应该如此臃肿让边缘变得更粗糙。 在着色器"
"中经常用于制作具有噪声的粗糙地形的技巧是在不同频率下将噪声层叠在彼此之上。 我"
"们使用一层来构建大陆的整体blobby结构。 然后另一层分裂边缘，然后是另一层，依此"
"类推。 我们要做的是用四行着色器代码计算 ``n`` 而不是一行。 ``n``成为:"

#: ../../docs/tutorials/viewports/using_viewport_as_texture.rst:249
msgid "And now the planet looks like:"
msgstr "现在这个星球看起来像:"

#: ../../docs/tutorials/viewports/using_viewport_as_texture.rst:253
#, fuzzy
msgid "And with shading turned back on, it looks like:"
msgstr "随着阴影重新开启，它看起来像:"

#: ../../docs/tutorials/viewports/using_viewport_as_texture.rst:258
msgid "Making an ocean"
msgstr "制作海洋"

#: ../../docs/tutorials/viewports/using_viewport_as_texture.rst:260
msgid ""
"One final thing to make this look more like a planet. The ocean and the land "
"reflect light differently. So we want the ocean to shine a little more than "
"the land. We can do this by passing a fourth value into the ``alpha`` "
"channel of our output ``COLOR`` and using it as a Roughness map."
msgstr ""
"让这个看起来更像是一颗行星的最后一件事。 海洋和陆地以不同的方式反射光线。 因"
"此，我们希望海洋比陆地更加闪耀。 我们可以通过将第四个值传递到输出 ``COLOR`` "
"的``alpha``通道并将其用作粗糙度图来实现。"

#: ../../docs/tutorials/viewports/using_viewport_as_texture.rst:268
#, fuzzy
msgid ""
"This line returns ``0.3`` for water and ``1.0`` for land. This means that "
"the land is going to be quite rough, while the water will be quite smooth."
msgstr ""
"这一行返回水的“0.3”和土地的“1.0”。 这意味着土地将非常粗糙，而水将非常平坦。"

#: ../../docs/tutorials/viewports/using_viewport_as_texture.rst:271
#, fuzzy
msgid ""
"And then, in the material, under the \"Metallic\" section, make sure "
"``Metallic`` is set to ``0`` and ``Specular`` is set to ``1``. The reason "
"for this is the water reflects light really well, but isn't metallic. These "
"values are not physically accurate, but they are good enough for this demo."
msgstr ""
"然后在“Metallic”部分下的材质中确保 ``Metallic`` 设置为 ``0`` 并且 "
"``Specular`` 设置为 ``1`` 。 原因是水很好地反射光，但不是金属。 这些值在物理"
"上并不准确，但它们对于此演示来说已经足够好了。"

#: ../../docs/tutorials/viewports/using_viewport_as_texture.rst:275
#, fuzzy
msgid ""
"Next, under the \"Roughness\" section, set ``Roughness`` to ``1`` and set "
"the roughness texture to a :ref:`Viewport Texture <class_ViewportTexture>` "
"pointing to our planet texture :ref:`Viewport <class_Viewport>`. Finally, "
"set the ``Texture Channel`` to ``Alpha``. This instructs the renderer to use "
"the ``alpha`` channel of our output ``COLOR`` as the ``Roughness`` value."
msgstr ""
"接下来在“粗糙度”部分将“粗糙度”设置为“1”并将粗糙度纹理设置为 :ref:`Viewport "
"Texture <class_ViewportTexture>` 指向我们的行星纹理 :ref:`Viewport "
"<class_Viewport>`。 最后将``Texture Channel``设置为``Alpha``。 这指示渲染器使"
"用输出 ``COLOR`` 的``alpha``通道作为``Roughness``值。"

#: ../../docs/tutorials/viewports/using_viewport_as_texture.rst:282
#, fuzzy
msgid ""
"You'll notice that very little changes except that the planet is no longer "
"reflecting the sky. This is happening because, by default, when something is "
"rendered with an alpha value, it gets drawn as a transparent object over the "
"background. And since the default background of the :ref:`Viewport "
"<class_Viewport>` is opaque, the ``alpha`` channel of the :ref:`Viewport "
"Texture <class_ViewportTexture>` is ``1``, resulting in the planet texture "
"being drawn with slightly fainter colors and a ``Roughness`` value of ``1`` "
"everywhere. To correct this, we go into the :ref:`Viewport <class_Viewport>` "
"and set \"Transparent Bg\" to on. Since we are now rendering one transparent "
"object on top of another, we want to enable ``blend_premul_alpha``:"
msgstr ""
"除了行星不再反射天空之外，您会注意到很少的变化。 发生这种情况是因为默认情况"
"下，当使用alpha值渲染某些内容时，它会在背景上绘制为透明对象。 由于 :ref:"
"`Viewport <class_Viewport>` 的默认背景是不透明的，因此 :ref:`Viewport "
"Texture <class_ViewportTexture>` 的 ``alpha`` 通道是 ``1`` ，导致行星纹理被 "
"随处可见的颜色略微偏淡，“粗糙度”值为“1”。 为了纠正这个问题，我们进入 :ref:"
"`Viewport <class_Viewport>` 并将“Transparent Bg”设置为on。 由于我们现在将一个"
"透明对象渲染到另一个上面，我们想要启用``blend_premul_alpha``:"

#: ../../docs/tutorials/viewports/using_viewport_as_texture.rst:295
#, fuzzy
msgid ""
"This pre-multiplies the colors by the ``alpha`` value and then blends them "
"correctly together. Typically, when blending one transparent color on top of "
"another, even if the background has an ``alpha`` of ``0`` (as it does in "
"this case), you end up with weird color bleed issues. Setting "
"``blend_premul_alpha`` fixes that."
msgstr ""
"这会将颜色预先乘以“alpha”值，然后将它们正确地混合在一起。 通常情况下，当一个"
"透明颜色混合在另一个上面时，即使背景的“alpha``为”0“(就像在这种情况下一样)，您"
"最终会出现奇怪的颜色流失问题。 设置 ``blend_premul_alpha`` 修复了这个问题。"

#: ../../docs/tutorials/viewports/using_viewport_as_texture.rst:299
msgid ""
"Now the planet should look like it is reflecting light on the ocean but not "
"the land. If you haven't done so already, add an :ref:`OmniLight "
"<class_OmniLight>` to the scene so you can move it around and see the effect "
"of the reflections on the ocean."
msgstr ""
"现在这个星球应该看起来像是在海洋上反射光而不是在陆地上。 如果您还没有这样做，"
"请在场景中添加 :ref:`OmniLight <class_OmniLight>` ，这样您就可以移动它并查看"
"反射对海洋的影响。"

#: ../../docs/tutorials/viewports/using_viewport_as_texture.rst:305
msgid ""
"And there you have it. A procedural planet generated using a :ref:`Viewport "
"<class_Viewport>`."
msgstr "您有它。 使用 :ref:`Viewport <class_Viewport>` 生成的简单程序行星。"

#: ../../docs/tutorials/viewports/custom_postprocessing.rst:4
msgid "Custom post-processing"
msgstr "自定义后期处理"

#: ../../docs/tutorials/viewports/custom_postprocessing.rst:9
#, fuzzy
msgid ""
"Godot provides many post-processing effects out of the box, including Bloom, "
"DOF, and SSAO. Sometimes you want to write your own custom effect. Here's "
"how you can do so."
msgstr ""
"Godot提供了许多开箱即用的后处理效果，包括Bloom，DOF和SSAO。 有时您想编写自己"
"的自定义效果。 这是您如何做到的。"

#: ../../docs/tutorials/viewports/custom_postprocessing.rst:12
msgid ""
"Post-processing effects are shaders applied to a frame after Godot rendered "
"it. You first want to render your scene into a :ref:`Viewport "
"<class_Viewport>`, then render the ``Viewport`` inside a :ref:"
"`ViewportTexture <class_ViewportTexture>` and show it on the screen."
msgstr ""
"后处理效果是在Godot渲染后应用于帧的着色器。 首先想要将场景渲染为 :ref:"
"`Viewport <class_Viewport>`，然后在 :ref:`ViewportTexture "
"<class_ViewportTexture>` 中渲染 ``Viewport`` 并在屏幕上显示它。"

#: ../../docs/tutorials/viewports/custom_postprocessing.rst:16
msgid ""
"The easiest way to implement a custom post-processing shader is to use "
"Godot's built-in ability to read from the screen texture. If you're not "
"familiar with this, you should read the :ref:`Screen Reading Shaders "
"Tutorial <doc_screen-reading_shaders>` first."
msgstr ""
"实现自定义后处理着色器的最简单方法是使用Godot的内置功能从屏幕纹理中读取。 如"
"果您不熟悉这个，您应该先阅读 :ref:`屏幕阅读着色器教程<doc_screen-"
"reading_shaders>` 。"

#: ../../docs/tutorials/viewports/custom_postprocessing.rst:22
#, fuzzy
msgid ""
"As of the time of writing, Godot does not support rendering to multiple "
"buffers at the same time. Your post-processing shader will not have access "
"to normals or other render passes. You only have access to the rendered "
"frame."
msgstr ""
"在撰写本文时，Godot不支持同时渲染到多个缓冲区。 您的后期处理着色器将无法访问"
"法线或其他渲染过程。 您只能访问渲染帧。"

#: ../../docs/tutorials/viewports/custom_postprocessing.rst:27
msgid "Single pass post-processing"
msgstr "单通后处理"

#: ../../docs/tutorials/viewports/custom_postprocessing.rst:29
msgid ""
"You will need a ``Viewport`` to render your scene to, and a scene to render "
"your ``Viewport`` on the screen. You can use a :ref:`ViewportContainer "
"<class_ViewportContainer>` to display your ``Viewport`` on the entire screen "
"or inside another :ref:`Control <class_Control>` node."
msgstr ""
"您需要一个 ``Viewport`` 来渲染场景，一个场景在屏幕上渲染您的 ``Viewport`` 。 "
"您可以使用 :ref:`ViewportContainer <class_ViewportContainer>` 在整个屏幕上或"
"另一个屏幕内显示您的``Viewport`` :ref:`Control <class_Control>` 节点。"

#: ../../docs/tutorials/viewports/custom_postprocessing.rst:36
#, fuzzy
msgid ""
"Rendering using a ``Viewport`` gives you control over how the scene render, "
"including the framerate, and you can use the ``ViewportContainer`` to render "
"3D objects in a 2D scene."
msgstr ""
"使用 ``Viewport`` 渲染可以控制场景的渲染方式，包括帧速率，您可以使用 "
"``ViewportContainer`` 在2D场景中渲染3D对象。"

#: ../../docs/tutorials/viewports/custom_postprocessing.rst:40
#, fuzzy
msgid ""
"For this demo, we will use a :ref:`Node2D <class_Node2D>` with a "
"``ViewportContainer`` and finally a ``Viewport``. Your **Scene** tab should "
"look like this:"
msgstr ""
"对于这个演示，我们将使用 :ref:`Node2D <class_Node2D>` 和 "
"``ViewportContainer`` ，最后是 ``Viewport`` 。 您的“节点”选项卡应如下所示:"

#: ../../docs/tutorials/viewports/custom_postprocessing.rst:45
#, fuzzy
msgid ""
"Inside the ``Viewport``, you can have whatever you want. This will contain "
"your main scene. For this tutorial, we will use a field of random boxes:"
msgstr ""
"在“Viewport”里，您可以得到任何您想要的东西。这将包含您的主场景。对于本教程，"
"我们将使用一个随机框字段:"

#: ../../docs/tutorials/viewports/custom_postprocessing.rst:50
#, fuzzy
msgid ""
"Add a new :ref:`ShaderMaterial <class_ShaderMaterial>` to the "
"``ViewportContainer``, and assign a new shader resource to it. You can "
"access your rendered ``Viewport`` with the built-in ``TEXTURE`` uniform."
msgstr ""
"在 ``ViewportContainer`` 中添加一个新的a :ref:`ShaderMaterial "
"<class_ShaderMaterial>` ，并为其分配一个新的着色器资源。 您可以使用内置的 "
"``TEXTURE`` 制服来访问渲染的 ``Viewport`` 。"

#: ../../docs/tutorials/viewports/custom_postprocessing.rst:55
#, fuzzy
msgid ""
"You can choose not to use a ``ViewportContainer``, but if you do so, you "
"will need to create your own uniform in the shader and pass the ``Viewport`` "
"texture in manually, like so:"
msgstr ""
"您可以选择不使用 ``ViewportContainer`` ，但如果这样做，您将需要在着色器中创建"
"自己的制服并手动传递 ``Viewport`` 纹理，如下所示:"

#: ../../docs/tutorials/viewports/custom_postprocessing.rst:64
msgid "And you can pass the texture into the shader from GDScript like so:"
msgstr "您可以将纹理从GDScript传递到着色器中，如下所示:"

#: ../../docs/tutorials/viewports/custom_postprocessing.rst:72
msgid ""
"Copy the following code to your shader. The above code is a single pass edge "
"detection filter, a `Sobel filter <https://en.wikipedia.org/wiki/"
"Sobel_operator>`_."
msgstr ""
"将以下代码复制到着色器。 上面的代码是单通道边缘检测滤波器， `Sobel滤波器 "
"<https://en.wikipedia.org/wiki/Sobel_operator>`_ 。"

#: ../../docs/tutorials/viewports/custom_postprocessing.rst:94
msgid ""
"The Sobel filter reads pixels in a 9x9 grid around the current pixel and "
"adds them together, using weight. What makes it interesting is that it "
"assigns weights to each pixel; +1 for each of the eight around the center "
"and -8 for the center pixel. The choice of weights is called a \"kernel\". "
"You can use different kernels to create edge detection filters, outlines, "
"and all sorts of effects."
msgstr ""
"Sobel滤波器读取当前像素周围9x9网格中的像素，并使用权重将它们加在一起。 令人感"
"兴趣的是它为每个像素分配权重; 围绕中心的八个中的每一个都是+1，对于中心像素"
"是-8。 权重的选择称为“核心”。 您可以使用不同的内核来创建边缘检测过滤器，轮廓"
"和各种效果。"

#: ../../docs/tutorials/viewports/custom_postprocessing.rst:102
msgid "Multi-pass post-processing"
msgstr "多通后处理"

#: ../../docs/tutorials/viewports/custom_postprocessing.rst:104
msgid ""
"Some post-processing effects like blur are resource intensive. If you break "
"them down in multiple passes however, you can make them run a lot faster. In "
"a multipass material, each pass takes the result from the previous pass as "
"an input and processes it."
msgstr ""
"像模糊这样的后处理效果是资源密集型的。 但是如果您在多次通过中将它们分解，您可"
"以让它们运行得更快。 在多通道材质中，每次传递都将前一次传递的结果作为输入并对"
"其进行处理。"

#: ../../docs/tutorials/viewports/custom_postprocessing.rst:108
#, fuzzy
msgid ""
"To make a multi-pass post-processing shader, you stack ``Viewport`` nodes. "
"In the example above, you rendered the content of one ``Viewport`` object "
"into the root ``Viewport``, through a ``ViewportContainer`` node. You can do "
"the same thing for a multi-pass shader by rendering the content of one "
"``Viewport`` into another and then rendering the last ``Viewport`` into the "
"root ``Viewport``."
msgstr ""
"要制作多遍后处理着色器，请堆叠“Viewport”节点。 在上面的示例中，您通过 "
"``ViewportContainer`` 节点将一个 ``Viewport`` 对象的内容渲染到根 "
"``Viewport`` 中。 您可以通过将一个 ``Viewport`` 的内容渲染到另一个，然后将最"
"后一个 ``Viewport`` 渲染到根 ``Viewport`` 中来为多遍着色器做同样的事情。"

#: ../../docs/tutorials/viewports/custom_postprocessing.rst:113
msgid "Your scene hierarchy will look something like this:"
msgstr "您的场景层次结构将如下所示:"

#: ../../docs/tutorials/viewports/custom_postprocessing.rst:117
msgid ""
"Godot will render the bottom ``Viewport`` node first. So if the order of the "
"passes matters for your shaders, make sure that you assign the shader you "
"want to apply first to the lowest ``ViewportContainer`` in the tree."
msgstr ""
"Godot将首先渲染底部的 ``Viewport`` 节点。 因此，如果遍历的顺序对着色器很重"
"要，请确保将要首先应用的着色器指定给树中最低的 ``ViewportContainer`` 。"

#: ../../docs/tutorials/viewports/custom_postprocessing.rst:123
msgid ""
"You can also render your Viewports separately without nesting them like "
"this. You just need to use two Viewports and to render them one after the "
"other."
msgstr ""
"您也可以单独渲染视区，而不必像这样嵌套它们。 您只需要使用两个视区并一个接一个"
"地渲染它们。"

#: ../../docs/tutorials/viewports/custom_postprocessing.rst:126
#, fuzzy
msgid ""
"Apart from the node structure, the steps are the same as with the single-"
"pass post-processing shader."
msgstr "除节点结构外，步骤与单遍后处理着色器相同。"

#: ../../docs/tutorials/viewports/custom_postprocessing.rst:128
msgid ""
"As an example, you could write a full screen Gaussian blur effect by "
"attaching the following pieces of code to each of the :ref:"
"`ViewportContainers <class_ViewportContainer>`. The order in which you apply "
"the shaders does not matter:"
msgstr ""
"例如，您可以通过将以下代码段附加到以下每个代码来编写全屏高斯模糊效果 :ref:"
"`ViewportContainers <class_ViewportContainer>`。 应用着色器的顺序无关紧要:"

#: ../../docs/tutorials/viewports/custom_postprocessing.rst:168
#, fuzzy
msgid ""
"Using the above code, you should end up with a full screen blur effect like "
"below."
msgstr "使用上面的代码，您应该得到如下所示的全屏模糊效果。"

#: ../../docs/tutorials/viewports/custom_postprocessing.rst:172
#, fuzzy
msgid ""
"For more information on how ``Viewport`` nodes work, see the :ref:`Viewports "
"Tutorial <doc_viewports>`."
msgstr ""
"有关 ``Viewport`` 节点如何工作的更多信息，请参阅 :ref:`Viewports Tutorial "
"<doc_viewports>`。"

#: ../../docs/tutorials/shading/shading_reference/index.rst:2
#, fuzzy
msgid "Shading reference"
msgstr "动画面板参考"

#: ../../docs/tutorials/shading/shading_reference/shaders.rst:4
#, fuzzy
msgid "Shaders"
msgstr "着色器"

#: ../../docs/tutorials/shading/shading_reference/shaders.rst:9
msgid ""
"Shaders are unique programs that run on the GPU. They are used to specify "
"how to take mesh data (vertex positions, colors, normals, etc.) and draw "
"them to the screen. Shaders do not process information the same way a normal "
"program does because they are optimized for running on the GPU. One "
"consequence of this is that shaders do not retain their data after they run; "
"they output a final color to the screen and then move on. Accordingly, there "
"is no way of accessing the color output from the last run of the shader."
msgstr ""

#: ../../docs/tutorials/shading/shading_reference/shaders.rst:16
msgid ""
"Godot uses a shader language very similar to GLSL, but with added "
"functionality and slightly less flexibility. The reason for doing this is "
"that Godot integrates built-in functionality to make writing complex shaders "
"substantially easier. Godot wraps the user-written shader code in code of "
"its own. That way, Godot handles a lot of the low-level stuff that the user "
"doesn't need to worry about, and it is able to parse your shader code and "
"use it to affect the rendering pipeline. For more advanced shaders, you can "
"turn this functionality off using a render_mode."
msgstr ""

#: ../../docs/tutorials/shading/shading_reference/shaders.rst:23
msgid ""
"This document provides you with some information about shaders, specific to "
"Godot. For a detailed reference of the shading language in Godot see the :"
"ref:`Godot shading language doc<doc_shading_language>`."
msgstr ""

#: ../../docs/tutorials/shading/shading_reference/shaders.rst:27
#, fuzzy
msgid "Shader types"
msgstr "着色器类型"

#: ../../docs/tutorials/shading/shading_reference/shaders.rst:29
#, fuzzy
msgid ""
"Instead of supplying a general purpose configuration for all uses (2D, 3D, "
"particles), Godot shaders must specify what they are intended for. Different "
"types support different render modes, built-in variables, and processing "
"functions."
msgstr ""
"Godot着色语言必须指定着色器的用途，而不是提供通用配置。 根据类型，支持不同的"
"渲染模式，内置变量和处理功能。"

#: ../../docs/tutorials/shading/shading_reference/shaders.rst:33
#, fuzzy
msgid ""
"All shaders need to specify their type in the first line, in the following "
"format:"
msgstr "任何着色器都需要指定此类型的第一行，格式如下:"

#: ../../docs/tutorials/shading/shading_reference/shaders.rst:41
#, fuzzy
msgid ":ref:`spatial <doc_spatial_shader>`: For 3D rendering."
msgstr "“spatial”:用于3D渲染。"

#: ../../docs/tutorials/shading/shading_reference/shaders.rst:42
#, fuzzy
msgid ":ref:`canvas_item <doc_canvas_item_shader>`: For 2D rendering."
msgstr "“canvas_item”:用于2D渲染。"

#: ../../docs/tutorials/shading/shading_reference/shaders.rst:43
#, fuzzy
msgid ":ref:`particles <doc_particle_shader>`: For particle systems."
msgstr "\"particles\":用于粒子系统。"

#: ../../docs/tutorials/shading/shading_reference/shaders.rst:45
msgid ""
"For detailed information on each shading type, see the corresponding "
"reference document."
msgstr ""

#: ../../docs/tutorials/shading/shading_reference/shaders.rst:48
#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:12
#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:14
#: ../../docs/tutorials/shading/shading_reference/particle_shader.rst:27
#, fuzzy
msgid "Render modes"
msgstr "渲染模式"

#: ../../docs/tutorials/shading/shading_reference/shaders.rst:50
#, fuzzy
msgid ""
"Different shader types support different render modes. They are optional "
"and, if specified, must be after the *shader_type*. Render modes are used to "
"alter the way built-in functionality is handled. For example, it is common "
"to use the render mode ``unshaded`` to skip the built-in light processor "
"function."
msgstr ""
"不同的着色器类型支持不同的渲染模式。它们是可选的，但如果指定，则必须在 "
"*shader_type* 之后。下面是示例语法:"

#: ../../docs/tutorials/shading/shading_reference/shaders.rst:55
msgid "Render modes are specified underneath the shader type:"
msgstr ""

#: ../../docs/tutorials/shading/shading_reference/shaders.rst:62
msgid ""
"Each shader type has a different list of render modes available. See the "
"document for each shader type for a complete list of render modes."
msgstr ""

#: ../../docs/tutorials/shading/shading_reference/shaders.rst:66
#, fuzzy
msgid "Processor functions"
msgstr "处理器函数"

#: ../../docs/tutorials/shading/shading_reference/shaders.rst:68
#, fuzzy
msgid ""
"Depending on the shader type, different processor functions may be "
"optionally overridden. For \"spatial\" and \"canvas_item\", it is possible "
"to override ``vertex``, ``fragment``, and ``light``. For \"particles\", only "
"``vertex`` can be overridden."
msgstr ""
"根据着色器类型的不同，处理器函数可以被选择性地重写。对"
"于“spatial”和“canvas_item”，可以重写“vertex”、“fragment”和“light”。对"
"于“particles”，只能重写“vertex”。"

#: ../../docs/tutorials/shading/shading_reference/shaders.rst:73
#, fuzzy
msgid "Vertex processor"
msgstr "顶点处理器"

#: ../../docs/tutorials/shading/shading_reference/shaders.rst:75
#, fuzzy
msgid ""
"The ``vertex`` processing function is called once for every vertex in "
"\"spatial\" and \"canvas_item\" shaders. For \"particles\" shaders, it is "
"called once for every particle."
msgstr "为每个顶点，2D或3D调用“顶点”处理函数。 对于粒子，它被称为每个粒子。"

#: ../../docs/tutorials/shading/shading_reference/shaders.rst:78
msgid ""
"The ``vertex`` function is used to modify per-vertex information that will "
"be passed on to the fragment function. It can also be used to establish "
"variables that will be sent to the fragment function by using varyings(see "
"other doc)."
msgstr ""

#: ../../docs/tutorials/shading/shading_reference/shaders.rst:82
msgid ""
"By default, Godot will take your vertex information and transform it "
"accordingly to be drawn. If this is undesirable, you can use render modes to "
"transform the data yourself; see the :ref:`Spatial shader doc "
"<doc_spatial_shader>` for an example of this."
msgstr ""

#: ../../docs/tutorials/shading/shading_reference/shaders.rst:87
#, fuzzy
msgid "Fragment processor"
msgstr "片段处理器"

#: ../../docs/tutorials/shading/shading_reference/shaders.rst:89
#, fuzzy
msgid ""
"The ``fragment`` processing function is used to set up the Godot material "
"parameters per pixel. This code runs on every visible pixel the object or "
"primitive draws. It is only available in \"spatial\" and \"canvas_item\" "
"shaders."
msgstr ""
"“片段”处理器用于设置每个像素的Godot材质参数。 此代码在对象或基元被绘制到的每"
"个可见像素上运行。"

#: ../../docs/tutorials/shading/shading_reference/shaders.rst:93
msgid ""
"The standard use of the fragment function is to set up material properties "
"that will be used to calculate lighting. For example, you would set values "
"for ``ROUGHNESS``, ``RIM``, or ``TRANSMISSION`` which would tell the light "
"function how the lights respond to that fragment. This makes it possible to "
"control a complex shading pipeline without the user having to write much "
"code. If you don't need this built-in functionality, you can ignore it and "
"write your own light processing function and Godot will optimize it away. "
"For example, if you do not write a value to ``RIM``, Godot will not "
"calculate rim lighting. During compilation, Godot checks to see if ``RIM`` "
"is used; if not, it cuts all the corresponding code out. Therefore, you will "
"not waste calculations on effects that you do not use."
msgstr ""

#: ../../docs/tutorials/shading/shading_reference/shaders.rst:103
#, fuzzy
msgid "Light processor"
msgstr "光处理器"

#: ../../docs/tutorials/shading/shading_reference/shaders.rst:105
#, fuzzy
msgid ""
"The ``light`` processor runs per pixel too, but also runs for every light "
"that affects the object (and does not run if no lights affect the object). "
"It exists as a function called inside the ``fragment`` processor and "
"typically operates on the material properties setup inside the ``fragment`` "
"function."
msgstr ""
"“光”处理器也按像素运行，但也会影响每个影响对象的光(如果没有光影响对象，则不会"
"运行)。"

#: ../../docs/tutorials/shading/shading_reference/shaders.rst:110
msgid ""
"The ``light`` processor works differently in 2D than it does in 3D; for a "
"description of how it works in each, see their documentation, :ref:"
"`CanvasItem shaders <doc_canvas_item_shader>` and :ref:`Spatial shaders "
"<doc_spatial_shader>`, respectively."
msgstr ""

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:4
#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:120
msgid "Shading language"
msgstr "着色语言"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:9
msgid ""
"Godot uses a shading language similar to GLSL ES 3.0. Most datatypes and "
"functions are supported, and the few remaining ones will likely be added "
"over time."
msgstr ""
"Godot使用类似于GLSL ES 3.0的着色语言。 支持大多数数据类型和函数，并且可能会随"
"着时间的推移添加少数几种类型和函数。"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:12
msgid ""
"If you are already familiar with GLSL, the :ref:`Godot Shader Migration "
"Guide<doc_migrating_to_godot_shader_language>` is a resource that will help "
"you transition from regular GLSL to Godot's shading language."
msgstr ""

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:16
msgid "Data types"
msgstr "数据类型"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:18
msgid "Most GLSL ES 3.0 datatypes are supported:"
msgstr "支持大多数GLSL ES 3.0数据类型:"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:23
msgid "**void**"
msgstr "**void**"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:23
msgid "Void datatype, useful only for functions that return nothing."
msgstr "Void数据类型，只对不返回任何内容的函数有用。"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:25
#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:391
msgid "**bool**"
msgstr "**bool**"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:25
msgid "Boolean datatype, can only contain \"true\" or \"false\""
msgstr "布尔数据类型，只能包含“true”或“false”"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:27
msgid "**bvec2**"
msgstr "**bvec2**"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:27
#, fuzzy
msgid "Two-component vector of booleans."
msgstr "布尔双组分向量。"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:29
msgid "**bvec3**"
msgstr "**bvec3**"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:29
#, fuzzy
msgid "Three-component vector of booleans."
msgstr "布尔三组分传染媒介。"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:31
msgid "**bvec4**"
msgstr "**bvec4**"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:31
#, fuzzy
msgid "Four-component vector of booleans."
msgstr "布尔值的四个组分向量。"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:33
#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:393
msgid "**int**"
msgstr "**int**"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:33
msgid "Signed scalar integer."
msgstr "签名标量整数。"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:35
msgid "**ivec2**"
msgstr "**ivec2**"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:35
#, fuzzy
msgid "Two-component vector of signed integers."
msgstr "有符号整数的双组分载体。"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:37
msgid "**ivec3**"
msgstr "**ivec3**"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:37
#, fuzzy
msgid "Three-component vector of signed integers."
msgstr "有符号整数的三个分量向量。"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:39
msgid "**ivec4**"
msgstr "**ivec4**"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:39
#, fuzzy
msgid "Four-component vector of signed integers."
msgstr "有符号整数的四个分量向量。"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:41
msgid "**uint**"
msgstr "**uint**"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:41
#, fuzzy
msgid "Unsigned scalar integer; can't contain negative numbers."
msgstr "无符号标量整型，不能包含负数。"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:43
msgid "**uvec2**"
msgstr "**uvec2**"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:43
#, fuzzy
msgid "Two-component vector of unsigned integers."
msgstr "无符号整数的两个分量向量。"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:45
msgid "**uvec3**"
msgstr "**uvec3**"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:45
#, fuzzy
msgid "Three-component vector of unsigned integers."
msgstr "无符号整数的三个分量向量。"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:47
msgid "**uvec4**"
msgstr "**uvec4**"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:47
#, fuzzy
msgid "Four-component vector of unsigned integers."
msgstr "无符号整数的四个分量向量。"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:49
#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:395
msgid "**float**"
msgstr "**float**"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:49
msgid "Floating point scalar."
msgstr "浮点标量。"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:51
#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:397
msgid "**vec2**"
msgstr "**vec2**"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:51
#, fuzzy
msgid "Two-component vector of floating point values."
msgstr "浮点值的双分量向量。"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:53
#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:399
msgid "**vec3**"
msgstr "**vec3**"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:53
#, fuzzy
msgid "Three-component vector of floating point values."
msgstr "浮点值的三分量向量。"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:55
#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:368
#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:401
msgid "**vec4**"
msgstr "**vec4**"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:55
#, fuzzy
msgid "Four-component vector of floating point values."
msgstr "浮点值的四分量向量。"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:57
msgid "**mat2**"
msgstr "**mat2**"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:57
msgid "2x2 matrix, in column major order."
msgstr "2x2矩阵，按主要顺序排列。"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:59
msgid "**mat3**"
msgstr "**mat3**"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:59
msgid "3x3 matrix, in column major order."
msgstr "3x3矩阵，在列的主要顺序。"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:61
#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:403
#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:405
msgid "**mat4**"
msgstr "**mat4**"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:61
msgid "4x4 matrix, in column major order."
msgstr "4x4矩阵，按主要顺序排列。"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:63
#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:372
#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:374
#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:376
#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:378
#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:380
#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:382
msgid "**sampler2D**"
msgstr "**sampler2D**"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:63
#, fuzzy
msgid "Sampler type for binding 2D textures, which are read as float."
msgstr "采样器类型，用于绑定2D纹理，读取为float。"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:65
msgid "**isampler2D**"
msgstr "**isampler2D**"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:65
msgid "Sampler type for binding 2D textures, which are read as signed integer."
msgstr "用于绑定2D纹理的采样器类型，它们被读取为有符号整数。"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:67
msgid "**usampler2D**"
msgstr "**usampler2D**"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:67
msgid ""
"Sampler type for binding 2D textures, which are read as unsigned integer."
msgstr "用于绑定2D纹理的采样器类型，读取为无符号整数。"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:69
msgid "**samplerCube**"
msgstr "**samplerCube**"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:69
msgid "Sampler type for binding Cubemaps, which are read as floats."
msgstr "用于绑定Cubemaps的采样器类型，读取为浮点数。"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:75
msgid ""
"Just like GLSL ES 3.0, implicit casting between scalars and vectors of the "
"same size but different type is not allowed. Casting of types of different "
"size is also not allowed. Conversion must be done explicitly via "
"constructors."
msgstr ""
"就像GLSL ES 3.0一样，不允许在标量和相同大小但不同类型的向量之间进行隐式转"
"换。 也不允许铸造不同大小的类型。 转换必须通过构造函数明确完成。"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:86
msgid ""
"Default integer constants are signed, so casting is always needed to convert "
"to unsigned:"
msgstr "默认整数常量是有符号的，所以转换为无符号总是需要强制类型转换:"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:95
msgid "Members"
msgstr "成员"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:97
#, fuzzy
msgid ""
"Individual scalar members of vector types are accessed via the \"x\", \"y\", "
"\"z\" and \"w\" members. Alternatively, using \"r\", \"g\", \"b\" and \"a\" "
"also works and is equivalent. Use whatever fits best for your needs."
msgstr ""
"通过“x”，“y”，“z”和“w”成员访问向量类型的各个标量成员。 或者，使"
"用“r”，“g”，“b”和“a”也起作用并且是等同的。 使用最适合您的用例的任何东西。"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:101
#, fuzzy
msgid ""
"For matrices, use the ``m[row][column]`` indexing syntax to access each "
"scalar, or ``m[idx]`` to access a vector by row index. For example, for "
"accessing the y position of an object in a mat4 you  use ``m[3][1]``."
msgstr ""
"对于矩阵，使用m [row] [column]索引语法来访问每个标量，或使用m [idx]来访问逐行"
"索引。 例如，要访问mat4中对象的y位置，必须使用m [3] [1]语法。"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:106
msgid "Constructing"
msgstr "建设"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:108
msgid "Construction of vector types must always pass:"
msgstr "向量类型的构造必须始终通过:"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:120
#, fuzzy
msgid ""
"Construction of matrix types requires vectors of the same dimension as the "
"matrix. You can also build a diagonal matrix using ``matx(float)`` syntax. "
"Accordingly, ``mat4(1.0)`` is an identity matrix."
msgstr ""
"矩阵类型的构造需要与矩阵相同维度的传递向量。 您还可以使用matx(float)语法构建"
"对角矩阵。 所以mat4(1.0)是一个单位矩阵。"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:130
#, fuzzy
msgid ""
"Matrices can also be built from a matrix of another dimension. There are two "
"rules : If a larger matrix is constructed from a smaller matrix, the "
"additional rows and columns are set to the values they would have in an "
"identity matrix. If a smaller matrix is constructed from a larger matrix, "
"the top, left submatrix of the larger matrix is used."
msgstr ""
"矩阵也可以从另一个维度的矩阵构建。 有两个规则:如果从较小的矩阵构造较大的矩"
"阵，则将额外的行和列设置为它们在单位矩阵中将具有的值。 如果从较大的矩阵构造较"
"小的矩阵，则选择较大矩阵的顶部左子矩阵。"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:143
msgid "Swizzling"
msgstr "混写"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:145
#, fuzzy
msgid ""
"It is possible to obtain any combination of components in any order, as long "
"as the result is another vector type (or scalar). This is easier shown than "
"explained:"
msgstr ""
"只要结果是另一种向量类型(或标量)，就可以以任何顺序获得它们的任何组合。 这显示"
"比解释更容易:"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:158
#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:116
msgid "Precision"
msgstr "精确"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:160
#, fuzzy
msgid ""
"It is possible to add precision modifiers to datatypes; use them for "
"uniforms, variables, arguments and varyings:"
msgstr "可以将精度修饰符添加到数据类型，将它们用于制服，变量，参数和变换:"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:169
#, fuzzy
msgid ""
"Using lower precision for some operations can speed up the math involved (at "
"the cost of less precision). This is rarely needed in the vertex processor "
"function (where full precision is needed most of the time), but is often "
"useful in the fragment processor."
msgstr ""
"对某些操作使用较低的精度可以加快所涉及的数学计算(当然，代价是较低的精度)。这"
"在顶点着色器中很少需要(大多数情况下需要完全精确)，但是在片段着色器中经常需"
"要。"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:173
#, fuzzy
msgid ""
"Keep in mind that some architectures (mainly mobile) benefit a lot from "
"this, but are also restricted (conversion between precisions has a cost). "
"Please read the relevant documentation on the target architecture to find "
"out more. In all honesty though, mobile drivers are buggy, so, to stay out "
"of trouble, make simple shaders without specifying precision unless you "
"*really* need to."
msgstr ""
"请记住，一些体系结构(主要是移动端)从中获益良多，但也受到限制(精度之间的转换是"
"有代价的)。请阅读目标体系结构的相关文档以了解更多信息。事实上，移动驱动程序是"
"有bug的，所以为了避免麻烦，您可以制作简单的着色器而不需要指定精度，除非您真的"
"需要。"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:181
msgid ""
"Godot shading language supports the same set of operators as GLSL ES 3.0. "
"Below is the list of them in precedence order:"
msgstr ""
"Godot 着色器语言支持与GLSL ES 3.0相同的操作符集。下面是它们的优先级列表:"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:184
msgid "Precedence"
msgstr "优先级"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:184
msgid "Class"
msgstr "类"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:184
msgid "Operator"
msgstr "操作符"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:186
msgid "1 (highest)"
msgstr "1 (最高)"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:186
msgid "parenthetical grouping"
msgstr "括号分组"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:186
msgid "**()**"
msgstr "**()**"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:188
#: ../../docs/tutorials/misc/binary_serialization_api.rst:29
msgid "2"
msgstr "2"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:188
msgid "unary"
msgstr "unary"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:188
msgid "**+, -, !, ~**"
msgstr "**+, -, !, ~**"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:190
#: ../../docs/tutorials/misc/binary_serialization_api.rst:31
msgid "3"
msgstr "3"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:190
msgid "multiplicative"
msgstr "multiplicative"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:190
msgid "**/, \\*, %**"
msgstr "**/, \\*, %**"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:192
#: ../../docs/tutorials/misc/binary_serialization_api.rst:33
#: ../../docs/tutorials/misc/binary_serialization_api.rst:94
#: ../../docs/tutorials/misc/binary_serialization_api.rst:103
#: ../../docs/tutorials/misc/binary_serialization_api.rst:112
#: ../../docs/tutorials/misc/binary_serialization_api.rst:121
#: ../../docs/tutorials/misc/binary_serialization_api.rst:134
#: ../../docs/tutorials/misc/binary_serialization_api.rst:136
#: ../../docs/tutorials/misc/binary_serialization_api.rst:145
#: ../../docs/tutorials/misc/binary_serialization_api.rst:147
#: ../../docs/tutorials/misc/binary_serialization_api.rst:149
#: ../../docs/tutorials/misc/binary_serialization_api.rst:151
#: ../../docs/tutorials/misc/binary_serialization_api.rst:160
#: ../../docs/tutorials/misc/binary_serialization_api.rst:162
#: ../../docs/tutorials/misc/binary_serialization_api.rst:164
#: ../../docs/tutorials/misc/binary_serialization_api.rst:173
#: ../../docs/tutorials/misc/binary_serialization_api.rst:175
#: ../../docs/tutorials/misc/binary_serialization_api.rst:177
#: ../../docs/tutorials/misc/binary_serialization_api.rst:179
#: ../../docs/tutorials/misc/binary_serialization_api.rst:181
#: ../../docs/tutorials/misc/binary_serialization_api.rst:183
#: ../../docs/tutorials/misc/binary_serialization_api.rst:192
#: ../../docs/tutorials/misc/binary_serialization_api.rst:194
#: ../../docs/tutorials/misc/binary_serialization_api.rst:196
#: ../../docs/tutorials/misc/binary_serialization_api.rst:198
#: ../../docs/tutorials/misc/binary_serialization_api.rst:207
#: ../../docs/tutorials/misc/binary_serialization_api.rst:209
#: ../../docs/tutorials/misc/binary_serialization_api.rst:211
#: ../../docs/tutorials/misc/binary_serialization_api.rst:213
#: ../../docs/tutorials/misc/binary_serialization_api.rst:222
#: ../../docs/tutorials/misc/binary_serialization_api.rst:224
#: ../../docs/tutorials/misc/binary_serialization_api.rst:226
#: ../../docs/tutorials/misc/binary_serialization_api.rst:228
#: ../../docs/tutorials/misc/binary_serialization_api.rst:230
#: ../../docs/tutorials/misc/binary_serialization_api.rst:232
#: ../../docs/tutorials/misc/binary_serialization_api.rst:241
#: ../../docs/tutorials/misc/binary_serialization_api.rst:243
#: ../../docs/tutorials/misc/binary_serialization_api.rst:245
#: ../../docs/tutorials/misc/binary_serialization_api.rst:247
#: ../../docs/tutorials/misc/binary_serialization_api.rst:249
#: ../../docs/tutorials/misc/binary_serialization_api.rst:251
#: ../../docs/tutorials/misc/binary_serialization_api.rst:253
#: ../../docs/tutorials/misc/binary_serialization_api.rst:255
#: ../../docs/tutorials/misc/binary_serialization_api.rst:257
#: ../../docs/tutorials/misc/binary_serialization_api.rst:266
#: ../../docs/tutorials/misc/binary_serialization_api.rst:268
#: ../../docs/tutorials/misc/binary_serialization_api.rst:270
#: ../../docs/tutorials/misc/binary_serialization_api.rst:272
#: ../../docs/tutorials/misc/binary_serialization_api.rst:274
#: ../../docs/tutorials/misc/binary_serialization_api.rst:276
#: ../../docs/tutorials/misc/binary_serialization_api.rst:278
#: ../../docs/tutorials/misc/binary_serialization_api.rst:280
#: ../../docs/tutorials/misc/binary_serialization_api.rst:282
#: ../../docs/tutorials/misc/binary_serialization_api.rst:284
#: ../../docs/tutorials/misc/binary_serialization_api.rst:286
#: ../../docs/tutorials/misc/binary_serialization_api.rst:288
#: ../../docs/tutorials/misc/binary_serialization_api.rst:297
#: ../../docs/tutorials/misc/binary_serialization_api.rst:299
#: ../../docs/tutorials/misc/binary_serialization_api.rst:301
#: ../../docs/tutorials/misc/binary_serialization_api.rst:303
#: ../../docs/tutorials/misc/binary_serialization_api.rst:312
#: ../../docs/tutorials/misc/binary_serialization_api.rst:332
#: ../../docs/tutorials/misc/binary_serialization_api.rst:334
#: ../../docs/tutorials/misc/binary_serialization_api.rst:342
#: ../../docs/tutorials/misc/binary_serialization_api.rst:361
#: ../../docs/tutorials/misc/binary_serialization_api.rst:373
#: ../../docs/tutorials/misc/binary_serialization_api.rst:385
#: ../../docs/tutorials/misc/binary_serialization_api.rst:398
#: ../../docs/tutorials/misc/binary_serialization_api.rst:400
#: ../../docs/tutorials/misc/binary_serialization_api.rst:409
#: ../../docs/tutorials/misc/binary_serialization_api.rst:411
#: ../../docs/tutorials/misc/binary_serialization_api.rst:420
#: ../../docs/tutorials/misc/binary_serialization_api.rst:428
#: ../../docs/tutorials/misc/binary_serialization_api.rst:441
#: ../../docs/tutorials/misc/binary_serialization_api.rst:443
#: ../../docs/tutorials/misc/binary_serialization_api.rst:445
#: ../../docs/tutorials/misc/binary_serialization_api.rst:454
#: ../../docs/tutorials/misc/binary_serialization_api.rst:456
#: ../../docs/tutorials/misc/binary_serialization_api.rst:458
#: ../../docs/tutorials/misc/binary_serialization_api.rst:460
#: ../../docs/tutorials/misc/binary_serialization_api.rst:469
#: ../../docs/tutorials/misc/binary_serialization_api.rst:471
#: ../../docs/tutorials/misc/binary_serialization_api.rst:473
#: ../../docs/tutorials/misc/binary_serialization_api.rst:475
#: ../../docs/tutorials/misc/binary_serialization_api.rst:477
msgid "4"
msgstr "4"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:192
msgid "additive"
msgstr "additive"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:192
msgid "**+, -**"
msgstr "**+, -**"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:194
#: ../../docs/tutorials/misc/binary_serialization_api.rst:35
msgid "5"
msgstr "5"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:194
msgid "bit-wise shift"
msgstr "逐位移位"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:194
msgid "**<<, >>**"
msgstr "**<<, >>**"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:196
#: ../../docs/tutorials/misc/binary_serialization_api.rst:37
msgid "6"
msgstr "6"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:196
msgid "relational"
msgstr "相关的"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:196
msgid "**<, >, <=, >=**"
msgstr "**<, >, <=, >=**"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:198
#: ../../docs/tutorials/misc/binary_serialization_api.rst:39
msgid "7"
msgstr "7"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:198
msgid "equality"
msgstr "平等"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:198
msgid "**==, !=**"
msgstr "**==, !=**"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:200
#: ../../docs/tutorials/misc/binary_serialization_api.rst:41
#: ../../docs/tutorials/misc/binary_serialization_api.rst:123
#: ../../docs/tutorials/misc/binary_serialization_api.rst:136
#: ../../docs/tutorials/misc/binary_serialization_api.rst:147
#: ../../docs/tutorials/misc/binary_serialization_api.rst:162
#: ../../docs/tutorials/misc/binary_serialization_api.rst:175
#: ../../docs/tutorials/misc/binary_serialization_api.rst:194
#: ../../docs/tutorials/misc/binary_serialization_api.rst:209
#: ../../docs/tutorials/misc/binary_serialization_api.rst:224
#: ../../docs/tutorials/misc/binary_serialization_api.rst:243
#: ../../docs/tutorials/misc/binary_serialization_api.rst:268
#: ../../docs/tutorials/misc/binary_serialization_api.rst:299
#: ../../docs/tutorials/misc/binary_serialization_api.rst:321
#: ../../docs/tutorials/misc/binary_serialization_api.rst:334
msgid "8"
msgstr "8"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:200
msgid "bit-wise and"
msgstr "按位和"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:200
msgid "**&**"
msgstr "**&**"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:202
#: ../../docs/tutorials/misc/binary_serialization_api.rst:43
msgid "9"
msgstr "9"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:202
msgid "bit-wise exclusive or"
msgstr "按位排他或"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:202
msgid "**^**"
msgstr "**^**"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:204
#: ../../docs/tutorials/misc/binary_serialization_api.rst:45
msgid "10"
msgstr "10"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:204
msgid "bit-wise inclusive or"
msgstr "按位包含或"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:204
msgid "**|**"
msgstr "**|**"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:206
#: ../../docs/tutorials/misc/binary_serialization_api.rst:47
msgid "11"
msgstr "11"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:206
msgid "logical and"
msgstr "逻辑和"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:206
msgid "**&&**"
msgstr "**&&**"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:208
msgid "12 (lowest)"
msgstr "12(最低)"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:208
msgid "logical inclusive or"
msgstr "逻辑或"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:208
msgid "**||**"
msgstr "**||**"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:212
#, fuzzy
msgid "Flow control"
msgstr "流程控制"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:214
msgid "Godot Shading language supports the most common types of flow control:"
msgstr "Godot 着色器语言支持最常见的控制流类型:"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:236
#, fuzzy
msgid ""
"Keep in mind that, in modern GPUs, an infinite loop can exist and can freeze "
"your application (including editor). Godot can't protect you from this, so "
"be careful not to make this mistake!"
msgstr ""
"请记住，在现代GPU中，无限循环可以存在，并且可以冻结应用程序(包括编辑器)。"
"Godot不能保护您，所以小心不要犯这个错误！"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:240
msgid "Discarding"
msgstr "丢弃"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:242
msgid ""
"Fragment and light functions can use the **discard** keyword. If used, the "
"fragment is discarded and nothing is written."
msgstr ""
"片段和灯光功能可以使用 **discard** 关键字。 如果使用，则丢弃该片段并且不写入"
"任何内容。"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:247
#, fuzzy
msgid ""
"It is possible to define functions in a Godot shader. They use the following "
"syntax:"
msgstr "可以在Godot着色器中定义任何函数。它们的语法如下:"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:262
msgid ""
"You can only use functions that have been defined above (higher in the "
"editor) the function from which you are calling them."
msgstr ""

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:265
#, fuzzy
msgid "Function arguments can have special qualifiers:"
msgstr "函数的参数可以有特殊修饰符:"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:267
msgid "**in**: Means the argument is only for reading (default)."
msgstr "**in**: 表示参数仅用于读取(默认)。"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:268
msgid "**out**: Means the argument is only for writing."
msgstr "**out**: 表示该参数只用于写入。"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:269
msgid "**inout**: Means the argument is fully passed via reference."
msgstr "**inout**: 表示该参数以引用传递。"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:271
msgid "Example below:"
msgstr "示例:"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:280
#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:57
msgid "Varyings"
msgstr "Varyings"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:282
#, fuzzy
msgid ""
"To send data from the vertex to the fragment processor function, *varyings* "
"are used. They are set for every primitive vertex in the *vertex processor*, "
"and the value is interpolated for every pixel in the fragment processor."
msgstr ""
"要将数据从顶点发送到片段着色器，请使用* varyings *。 它们被设置为 *顶点处理器"
"* 中的每个原始顶点，并且当到达片段处理器中的每个像素时，该值被内插(并且透视校"
"正)。"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:300
msgid "Interpolation qualifiers"
msgstr "插值限定符"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:302
msgid ""
"Certain values are interpolated during the shading pipeline. You can modify "
"how these interpolations are done by using *interpolation qualifiers*."
msgstr ""
"在着色管线期间内插某些值。 您可以使用 *插值限定符* 修改这些插值的完成方式。"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:319
#, fuzzy
msgid "There are two possible interpolation qualifiers:"
msgstr "有三种可能的插值限定符:"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:322
msgid "Qualifier"
msgstr "限定符"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:324
msgid "**flat**"
msgstr "**flat**"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:324
#, fuzzy
msgid "The value is not interpolated."
msgstr "该值未插值"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:326
msgid "**smooth**"
msgstr "**smooth**"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:326
#, fuzzy
msgid ""
"The value is interpolated in a perspective-correct fashion. This is the "
"default."
msgstr "该值以透视正确的方式进行插值。 这是默认值"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:331
#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:250
msgid "Uniforms"
msgstr "制服"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:333
#, fuzzy
msgid ""
"Passing values to shaders is possible. These are global to the whole shader "
"and are called *uniforms*. When a shader is later assigned to a material, "
"the uniforms will appear as editable parameters in it. Uniforms can't be "
"written from within the shader."
msgstr ""
"将值传递给着色器是可能的。 这些是整个着色器的全局，称为 *制服* 。 稍后将着色"
"器指定给材质时，制服将在其上显示为可编辑参数。 无法在着色器中编写制服。"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:343
msgid ""
"You can set uniforms in the editor in the material. Or you can set them "
"through GDScript:"
msgstr ""

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:349
msgid ""
"The first argument to ``set_shader_param`` is the name of the uniform in the "
"shader. It must match *exactly* to the name of the uniform in the shader or "
"else it will not be recognized."
msgstr ""

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:352
#, fuzzy
msgid ""
"Any GLSL type except for *void* can be a uniform. Additionally, Godot "
"provides optional shader hints to make the compiler understand for what the "
"uniform is used."
msgstr ""
"除* void *之外的任何类型都可以是统一的。 此外，Godot提供可选的着色器提示，以"
"使编译器了解统一使用的内容。"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:363
msgid "Full list of hints below:"
msgstr "以下提示的完整列表:"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:366
msgid "Hint"
msgstr "暗示"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:368
msgid "hint_color"
msgstr "hint_color"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:368
msgid "Used as color"
msgstr "用作颜色"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:370
msgid "**int, float**"
msgstr "**int, float**"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:370
msgid "hint_range(min,max [,step] )"
msgstr "hint_range(min,max [,step] )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:370
msgid "Used as range (with min/max/step)"
msgstr "用作范围(最小/最大/步)"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:372
msgid "hint_albedo"
msgstr "hint_albedo"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:372
msgid "Used as albedo color, default white"
msgstr "用作反照率颜色，默认为白色"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:374
msgid "hint_black_albedo"
msgstr "hint_black_albedo"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:374
msgid "Used as albedo color, default black"
msgstr "用作反照率颜色，默认为黑色"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:376
msgid "hint_normal"
msgstr "hint_normal"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:376
msgid "Used as normalmap"
msgstr "用作法线贴图"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:378
msgid "hint_white"
msgstr "hint_white"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:378
msgid "As value, default to white."
msgstr "作为值，默认为白色。"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:380
msgid "hint_black"
msgstr "hint_black"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:380
msgid "As value, default to black"
msgstr "作为值，默认为黑色"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:382
msgid "hint_aniso"
msgstr "hint_aniso"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:382
msgid "As flowmap, default to right."
msgstr "作为流程图，默认为右。"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:385
msgid ""
"GDScript uses different variable types than GLSL does, so when passing "
"variables from GDScript to shaders, Godot converts the type automatically. "
"Below is a table of the corresponding types:"
msgstr ""

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:389
#, fuzzy
msgid "GDScript type"
msgstr "GDScript"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:389
#, fuzzy
msgid "GLSL type"
msgstr "一种类型"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:397
#, fuzzy
msgid "**Vector2**"
msgstr "Vector"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:399
#, fuzzy
msgid "**Vector3**"
msgstr "Vector"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:401
#, fuzzy
msgid "**Color**"
msgstr "**color**"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:403
#, fuzzy
msgid "**Transform**"
msgstr "变换"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:405
#, fuzzy
msgid "**Transform2D**"
msgstr "Transform2D"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:408
msgid ""
"Be careful when setting shader uniforms from GDScript, no error will be "
"thrown if the type does not match. Your shader will just exhibit undefined "
"behaviour."
msgstr ""

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:411
#, fuzzy
msgid ""
"As Godot's 3D engine renders in linear color space, it's important to "
"understand that textures that are supplied as color (i.e. albedo) need to be "
"specified as such for proper sRGB->linear conversion."
msgstr ""
"由于Godot 3D引擎呈现在线性颜色空间中，因此需要理解的是，作为颜色提供的纹理(即"
"反照率)需要指定为正确的SRGB->线性转换。"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:415
msgid "Uniforms can also be assigned default values:"
msgstr "制服也可以分配默认值:"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:425
#, fuzzy
msgid "Built-in functions"
msgstr "内置功能"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:427
#, fuzzy
msgid ""
"A large number of built-in functions are supported, conforming to GLSL ES "
"3.0. When vec_type (float), vec_int_type, vec_uint_type, vec_bool_type "
"nomenclature is used, it can be scalar or vector."
msgstr ""
"支持大量内置函数，主要符合GLSL ES 3.0。 当使用vec_type(float)，vec_int_type，"
"vec_uint_type，vec_bool_type命名法时，它可以是标量或向量。"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:430
msgid ""
"For a list of the functions that are not available in the GLES2 backend, "
"please see the :ref:`Differences between GLES2 and GLES3 doc "
"<doc_gles2_gles3_differences>`."
msgstr ""

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:434
#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:128
msgid "Function"
msgstr "函数"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:436
msgid "vec_type **radians** ( vec_type )"
msgstr "vec_type **radians** ( vec_type )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:436
msgid "Convert degrees to radians"
msgstr "将度数转换为弧度"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:438
msgid "vec_type **degrees** ( vec_type )"
msgstr "vec_type **degrees** ( vec_type )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:438
msgid "Convert radians to degrees"
msgstr "将弧度转换为度数"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:440
msgid "vec_type **sin** ( vec_type )"
msgstr "vec_type **sin** ( vec_type )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:440
msgid "Sine"
msgstr "正弦"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:442
msgid "vec_type **cos** ( vec_type )"
msgstr "vec_type **cos** ( vec_type )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:442
msgid "Cosine"
msgstr "余弦"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:444
msgid "vec_type **tan** ( vec_type )"
msgstr "vec_type **tan** ( vec_type )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:444
msgid "Tangent"
msgstr "正切"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:446
msgid "vec_type **asin** ( vec_type )"
msgstr "vec_type **asin** ( vec_type )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:446
msgid "Arc-Sine"
msgstr "反正弦"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:448
msgid "vec_type **acos** ( vec_type )"
msgstr "vec_type **acos** ( vec_type )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:448
msgid "Arc-Cosine"
msgstr "反余弦"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:450
msgid "vec_type **atan** ( vec_type )"
msgstr "vec_type **atan** ( vec_type )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:450
msgid "Arc-Tangent"
msgstr "反正切"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:452
msgid "vec_type **atan** ( vec_type x, vec_type y )"
msgstr "vec_type **atan** ( vec_type x, vec_type y )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:452
msgid "Arc-Tangent to convert vector to angle"
msgstr "Arc-Tangent将向量转换为角度"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:454
#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:130
msgid "vec_type **sinh** ( vec_type )"
msgstr "vec_type **sinh** ( vec_type )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:454
msgid "Hyperbolic-Sine"
msgstr "双曲正弦"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:456
#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:132
msgid "vec_type **cosh** ( vec_type )"
msgstr "vec_type **cosh** ( vec_type )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:456
msgid "Hyperbolic-Cosine"
msgstr "双曲余弦"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:458
#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:134
msgid "vec_type **tanh** ( vec_type )"
msgstr "vec_type **tanh** ( vec_type )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:458
msgid "Hyperbolic-Tangent"
msgstr "双曲正切"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:460
#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:136
msgid "vec_type **asinh** ( vec_type )"
msgstr "vec_type **asinh** ( vec_type )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:460
msgid "Inverse-Hyperbolic-Sine"
msgstr "反双曲正弦"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:462
#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:138
msgid "vec_type **acosh** ( vec_type )"
msgstr "vec_type **acosh** ( vec_type )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:462
msgid "Inverse-Hyperbolic-Cosine"
msgstr "反双曲余弦"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:464
#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:140
msgid "vec_type **atanh** ( vec_type )"
msgstr "vec_type **atanh** ( vec_type )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:464
msgid "Inverse-Hyperbolic-Tangent"
msgstr "反双曲正切"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:466
msgid "vec_type **pow** ( vec_type, vec_type )"
msgstr "vec_type **pow** ( vec_type, vec_type )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:466
msgid "Power"
msgstr "幂"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:468
msgid "vec_type **exp** ( vec_type )"
msgstr "vec_type **exp** ( vec_type )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:468
msgid "Base-e Exponential"
msgstr "以e为底的指数"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:470
msgid "vec_type **exp2** ( vec_type )"
msgstr "vec_type **exp2** ( vec_type )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:470
msgid "Base-2 Exponential"
msgstr "2为底的指数"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:472
msgid "vec_type **log** ( vec_type )"
msgstr "vec_type **log** ( vec_type )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:472
msgid "Natural Logarithm"
msgstr "自然对数"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:474
msgid "vec_type **log2** ( vec_type )"
msgstr "vec_type **log2** ( vec_type )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:474
msgid "Base-2 Logarithm"
msgstr "2为底的对数"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:476
msgid "vec_type **sqrt** ( vec_type )"
msgstr "vec_type **sqrt** ( vec_type )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:476
msgid "Square Root"
msgstr "平方根"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:478
msgid "vec_type **inversesqrt** ( vec_type )"
msgstr "vec_type **inversesqrt** ( vec_type )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:478
msgid "Inverse Square Root"
msgstr "反平方根"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:480
msgid "vec_type **abs** ( vec_type )"
msgstr "vec_type **abs** ( vec_type )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:480
#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:482
msgid "Absolute"
msgstr "绝对"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:482
msgid "vec_int_type **abs** ( vec_int_type )"
msgstr "vec_int_type **abs** ( vec_int_type )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:484
msgid "vec_type **sign** ( vec_type )"
msgstr "vec_type **sign** ( vec_type )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:484
#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:486
msgid "Sign"
msgstr "符号"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:486
msgid "vec_int_type **sign** ( vec_int_type )"
msgstr "vec_int_type **sign** ( vec_int_type )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:488
msgid "vec_type **floor** ( vec_type )"
msgstr "vec_type **floor** ( vec_type )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:488
msgid "Floor"
msgstr "向下取整"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:490
#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:142
msgid "vec_type **round** ( vec_type )"
msgstr "vec_type **round** ( vec_type )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:490
msgid "Round"
msgstr "四舍五入"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:492
#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:144
msgid "vec_type **roundEven** ( vec_type )"
msgstr "vec_type **roundEven** ( vec_type )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:492
msgid "Round nearest even"
msgstr "最近的偶数"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:494
#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:146
msgid "vec_type **trunc** ( vec_type )"
msgstr "vec_type ** trunc **(vec_type)"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:494
msgid "Truncation"
msgstr "截断"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:496
msgid "vec_type **ceil** ( vec_type )"
msgstr "vec_type **ceil** ( vec_type )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:496
msgid "Ceiling"
msgstr "向上取整"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:498
msgid "vec_type **fract** ( vec_type )"
msgstr "vec_type **fract** ( vec_type )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:498
msgid "Fractional"
msgstr "Fractional"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:500
msgid "vec_type **mod** ( vec_type, vec_type )"
msgstr "vec_type **mod** ( vec_type, vec_type )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:500
#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:502
msgid "Remainder"
msgstr "余"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:502
msgid "vec_type **mod** ( vec_type, float )"
msgstr "vec_type **mod** ( vec_type, float )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:504
#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:148
msgid "vec_type **modf** ( vec_type x, out vec_type i )"
msgstr "vec_type **modf** ( vec_type x, out vec_type i )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:504
msgid "Fractional of x, with i has integer part"
msgstr "x的分数，有整数部分"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:506
msgid "vec_scalar_type **min** ( vec_scalar_type a, vec_scalar_type b )"
msgstr "vec_scalar_type **min** ( vec_scalar_type a, vec_scalar_type b )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:506
msgid "Minimum"
msgstr "最小值"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:508
msgid "vec_scalar_type **max** ( vec_scalar_type a, vec_scalar_type b )"
msgstr "vec_scalar_type **max** ( vec_scalar_type a, vec_scalar_type b )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:508
msgid "Maximum"
msgstr "最大值"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:510
msgid ""
"vec_scalar_type **clamp** ( vec_scalar_type value, vec_scalar_type min, "
"vec_scalar_type max )"
msgstr ""
"vec_scalar_type **clamp** ( vec_scalar_type value, vec_scalar_type min, "
"vec_scalar_type max )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:510
msgid "Clamp to Min-Max"
msgstr "钳到Min-Max"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:512
msgid "vec_type **mix** ( vec_type a, vec_type b, float c )"
msgstr "vec_type **mix** ( vec_type a, vec_type b, float c )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:512
msgid "Linear Interpolate (Scalar Coef.)"
msgstr "线性插值(Scalar Coef。)"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:514
msgid "vec_type **mix** ( vec_type a, vec_type b, vec_type c )"
msgstr "vec_type **mix** ( vec_type a, vec_type b, vec_type c )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:514
msgid "Linear Interpolate (Vector Coef.)"
msgstr "线性插值(Vector Coef。)"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:516
msgid "vec_type **mix** ( vec_type a, vec_type b, bool c )"
msgstr "vec_type **mix** ( vec_type a, vec_type b, bool c )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:516
msgid "Linear Interpolate (Bool Selection)"
msgstr "线性插值(Bool选择)"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:518
msgid "vec_type **mix** ( vec_type a, vec_type b, vec_bool_type c )"
msgstr "vec_type **mix** ( vec_type a, vec_type b, vec_bool_type c )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:518
msgid "Linear Interpolate (Bool-Vector Selection)"
msgstr "线性插值(Bool-Vector选择)"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:520
msgid "vec_type **step** ( vec_type a, vec_type b )"
msgstr "vec_type **step** ( vec_type a, vec_type b )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:520
#, fuzzy
msgid "``b[i] < a[i] ? 0.0 : 1.0``"
msgstr "\\` b[i] < a[i] ? 0.0 : 1.0 \\`"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:522
msgid "vec_type **step** ( float a, vec_type b )"
msgstr "vec_type **step** ( float a, vec_type b )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:522
#, fuzzy
msgid "``b[i] < a ? 0.0 : 1.0``"
msgstr "\\` b[i] < a ? 0.0 : 1.0 \\`"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:524
msgid "vec_type **smoothstep** ( vec_type a, vec_type b, vec_type c )"
msgstr "vec_type **smoothstep** ( vec_type a, vec_type b, vec_type c )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:524
#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:526
msgid "Hermite Interpolate"
msgstr "埃尔米特插值"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:526
msgid "vec_type **smoothstep** ( float a, float b, vec_type c )"
msgstr "vec_type **smoothstep** ( float a, float b, vec_type c )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:528
#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:150
msgid "vec_bool_type **isnan** ( vec_type )"
msgstr "vec_bool_type **isnan** ( vec_type )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:528
msgid "Scalar, or vector component being nan"
msgstr "标量或向量分量为nan"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:530
#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:152
msgid "vec_bool_type **isinf** ( vec_type )"
msgstr "vec_bool_type **isinf** ( vec_type )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:530
msgid "Scalar, or vector component being inf"
msgstr "标量或向量分量为inf"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:532
#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:154
msgid "vec_int_type **floatBitsToInt** ( vec_type )"
msgstr "vec_int_type **floatBitsToInt** ( vec_type )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:532
msgid "Float->Int bit copying, no conversion"
msgstr "Float-> Int位复制，无转换"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:534
#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:156
msgid "vec_uint_type **floatBitsToUint** ( vec_type )"
msgstr "vec_uint_type **floatBitsToUint** ( vec_type )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:534
msgid "Float->UInt bit copying, no conversion"
msgstr "Float-> UInt位复制，无转换"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:536
#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:158
msgid "vec_type **intBitsToFloat** ( vec_int_type )"
msgstr "vec_type **intBitsToFloat** ( vec_int_type )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:536
msgid "Int->Float bit copying, no conversion"
msgstr "Int-> Float位复制，无转换"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:538
#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:160
msgid "vec_type **uintBitsToFloat** ( vec_uint_type )"
msgstr "vec_type **uintBitsToFloat** ( vec_uint_type )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:538
msgid "UInt->Float bit copying, no conversion"
msgstr "UInt->浮点复制，无转换"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:540
msgid "float **length** ( vec_type )"
msgstr "float **length** ( vec_type )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:540
msgid "Vector Length"
msgstr "向量长度"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:542
msgid "float **distance** ( vec_type, vec_type )"
msgstr "float **distance** ( vec_type, vec_type )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:542
msgid "Distance between vector"
msgstr "向量之间的距离"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:544
msgid "float **dot** ( vec_type, vec_type )"
msgstr "float **dot** ( vec_type, vec_type )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:544
msgid "Dot Product"
msgstr "点积"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:546
msgid "vec3 **cross** ( vec3, vec3 )"
msgstr "vec3 **cross** ( vec3, vec3 )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:546
msgid "Cross Product"
msgstr "叉积"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:548
msgid "vec_type **normalize** ( vec_type )"
msgstr "vec_type **normalize** ( vec_type )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:548
msgid "Normalize to unit length"
msgstr "标准化为单位长度"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:550
msgid "vec3 **reflect** ( vec3 I, vec3 N )"
msgstr "vec3 **reflect** ( vec3 I, vec3 N )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:550
msgid "Reflect"
msgstr "反映"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:552
msgid "vec3 **refract** ( vec3 I, vec3 N, float eta )"
msgstr "vec3 ** refract **(vec3 I，vec3 N，float eta)"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:552
msgid "Refract"
msgstr "折射"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:554
msgid "vec_type **faceforward** ( vec_type N, vec_type I, vec_type Nref )"
msgstr "vec_type **faceforward** ( vec_type N, vec_type I, vec_type Nref )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:554
#, fuzzy
msgid "If dot(Nref, I) < 0, return N, otherwise –N"
msgstr "如果dot(Nref，I)<0则返回N，否则返回-N"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:556
msgid "mat_type **matrixCompMult** ( mat_type, mat_type )"
msgstr "mat_type **matrixCompMult** ( mat_type, mat_type )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:556
msgid "Matrix Component Multiplication"
msgstr "矩阵分量乘法"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:558
#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:162
msgid "mat_type **outerProduct** ( vec_type, vec_type )"
msgstr "mat_type **outerProduct** ( vec_type, vec_type )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:558
msgid "Matrix Outer Product"
msgstr "矩阵外积"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:560
#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:164
msgid "mat_type **transpose** ( mat_type )"
msgstr "mat_type **transpose** ( mat_type )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:560
msgid "Transpose Matrix"
msgstr "转置矩阵"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:562
#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:166
msgid "float **determinant** ( mat_type )"
msgstr "float **determinant** ( mat_type )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:562
msgid "Matrix Determinant"
msgstr "矩阵行列式"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:564
#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:168
msgid "mat_type **inverse** ( mat_type )"
msgstr "mat_type **inverse** ( mat_type )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:564
msgid "Inverse Matrix"
msgstr "逆矩阵"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:566
msgid "vec_bool_type **lessThan** ( vec_scalar_type, vec_scalar_type )"
msgstr "vec_bool_type **lessThan** ( vec_scalar_type, vec_scalar_type )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:566
msgid "Bool vector cmp on < int/uint/float vectors"
msgstr "Bool向量cmp on <int / uint / float vectors"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:568
msgid "vec_bool_type **greaterThan** ( vec_scalar_type, vec_scalar_type )"
msgstr "vec_bool_type **greaterThan** ( vec_scalar_type, vec_scalar_type )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:568
msgid "Bool vector cmp on > int/uint/float vectors"
msgstr "Bool向量cmp on> int / uint / float向量"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:570
msgid "vec_bool_type **lessThanEqual** ( vec_scalar_type, vec_scalar_type )"
msgstr "vec_bool_type **lessThanEqual** ( vec_scalar_type, vec_scalar_type )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:570
msgid "Bool vector cmp on <= int/uint/float vectors"
msgstr "Bool vector cmp on <= int/uint/float vectors"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:572
msgid "vec_bool_type **greaterThanEqual** ( vec_scalar_type, vec_scalar_type )"
msgstr ""
"vec_bool_type **greaterThanEqual** ( vec_scalar_type, vec_scalar_type )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:572
msgid "Bool vector cmp on >= int/uint/float vectors"
msgstr "Bool vector cmp on >= int/uint/float vectors"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:574
msgid "vec_bool_type **equal** ( vec_scalar_type, vec_scalar_type )"
msgstr "vec_bool_type **equal** ( vec_scalar_type, vec_scalar_type )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:574
msgid "Bool vector cmp on == int/uint/float vectors"
msgstr "Bool vector cmp on == int/uint/float vectors"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:576
msgid "vec_bool_type **notEqual** ( vec_scalar_type, vec_scalar_type )"
msgstr "vec_bool_type **notEqual** ( vec_scalar_type, vec_scalar_type )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:576
msgid "Bool vector cmp on != int/uint/float vectors"
msgstr "Bool vector cmp on != int/uint/float vectors"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:578
msgid "bool **any** ( vec_bool_type )"
msgstr "bool **any** ( vec_bool_type )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:578
msgid "Any component is true"
msgstr "任何组件是真实的"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:580
msgid "bool **all** ( vec_bool_type )"
msgstr "bool **all** ( vec_bool_type )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:580
msgid "All components are true"
msgstr "所有组件都是真实的"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:582
msgid "bool **not** ( vec_bool_type )"
msgstr "bool **not** ( vec_bool_type )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:582
msgid "No components are true"
msgstr "没有组件是真的"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:584
#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:170
msgid "ivec2 **textureSize** ( sampler2D_type s, int lod )"
msgstr "ivec2 **textureSize** ( sampler2D_type s, int lod )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:584
msgid "Get the size of a texture"
msgstr "获取纹理的大小"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:586
#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:172
msgid "ivec2 **textureSize** ( samplerCube s, int lod )"
msgstr "ivec2 **textureSize** ( samplerCube s, int lod )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:586
msgid "Get the size of a cubemap"
msgstr "获取立方体贴图的大小"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:588
#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:174
msgid "vec4_type **texture** ( sampler2D_type s, vec2 uv [, float bias] )"
msgstr "vec4_type **texture** ( sampler2D_type s, vec2 uv [, float bias] )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:588
msgid "Perform a 2D texture read"
msgstr "执行2D纹理读取"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:590
#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:176
msgid "vec4_type **texture** ( samplerCube s, vec3 uv [, float bias] )"
msgstr "vec4_type **texture** ( samplerCube s, vec3 uv [, float bias] )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:590
msgid "Perform a Cube texture read"
msgstr "执行立方织构读"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:592
#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:178
msgid "vec4_type **textureProj** ( sampler2D_type s, vec3 uv [, float bias] )"
msgstr "vec4_type **textureProj** ( sampler2D_type s, vec3 uv [, float bias] )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:592
#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:594
msgid "Perform a texture read with projection"
msgstr "使用投影执行纹理读取"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:594
#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:180
msgid "vec4_type **textureProj** ( sampler2D_type s, vec4 uv [, float bias] )"
msgstr "vec4_type **textureProj** ( sampler2D_type s, vec4 uv [, float bias] )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:596
#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:182
msgid "vec4_type **textureLod** ( sampler2D_type s, vec2 uv, float lod )"
msgstr "vec4_type **textureLod** ( sampler2D_type s, vec2 uv, float lod )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:596
msgid "Perform a 2D texture read at custom mipmap"
msgstr "在自定义mipmap上执行2D纹理读取"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:598
#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:184
msgid "vec4_type **textureLod** ( samplerCube s, vec3 uv, float lod )"
msgstr "vec4_type **textureLod** ( samplerCube s, vec3 uv, float lod )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:598
msgid "Perform a Cube texture read at custom mipmap"
msgstr "执行立方织构的自定义纹理贴图读取"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:600
#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:186
msgid "vec4_type **textureProjLod** ( sampler2D_type s, vec3 uv, float lod )"
msgstr "vec4_type **textureProjLod** ( sampler2D_type s, vec3 uv, float lod )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:600
#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:602
msgid "Perform a texture read with projection/lod"
msgstr "使用projection / lod执行纹理读取"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:602
#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:188
msgid "vec4_type **textureProjLod** ( sampler2D_type s, vec4 uv, float lod )"
msgstr "vec4_type **textureProjLod** ( sampler2D_type s, vec4 uv, float lod )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:604
#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:190
msgid "vec4_type **texelFetch** ( sampler2D_type s, ivec2 uv, int lod )"
msgstr "vec4_type **texelFetch** ( sampler2D_type s, ivec2 uv, int lod )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:604
msgid "Fetch a single texel using integer coords"
msgstr "使用整数坐标获取单个纹素"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:606
#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:192
msgid "vec_type **dFdx** ( vec_type )"
msgstr "vec_type **dFdx** ( vec_type )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:606
msgid "Derivative in x using local differencing"
msgstr "使用局部差分在x中导数"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:608
#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:194
msgid "vec_type **dFdy** ( vec_type )"
msgstr "vec_type **dFdy** ( vec_type )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:608
msgid "Derivative in y using local differencing"
msgstr "使用局部差分在y中导数"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:610
#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:196
msgid "vec_type **fwidth** ( vec_type )"
msgstr "vec_type **fwidth** ( vec_type )"

#: ../../docs/tutorials/shading/shading_reference/shading_language.rst:610
msgid "Sum of absolute derivative in x and y"
msgstr "x和y的绝对导数之和"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:4
#, fuzzy
msgid "Spatial shaders"
msgstr "空间节点"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:6
msgid ""
"Spatial shaders are used for shading 3D objects. They are the most complex "
"type of shader Godot offers. Spatial shaders are highly configurable with "
"different render modes and different rendering options (e.g. Subsurface "
"Scattering, Transmission, Ambient Occlusion, Rim lighting etc). Users can "
"optionally write vertex, fragment, and light processor functions to affect "
"how objects are drawn."
msgstr ""

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:15
#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:17
#: ../../docs/tutorials/shading/shading_reference/particle_shader.rst:30
#, fuzzy
msgid "Render mode"
msgstr "渲染模式"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:17
#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:19
msgid "**blend_mix**"
msgstr "**blend_mix**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:17
#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:19
msgid "Mix blend mode (alpha is transparency), default."
msgstr "混合混合模式(alpha是透明度)，默认。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:19
#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:21
msgid "**blend_add**"
msgstr "**blend_add**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:19
#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:21
msgid "Additive blend mode."
msgstr "添加剂混合模式。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:21
#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:23
msgid "**blend_sub**"
msgstr "**blend_sub**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:21
#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:23
msgid "Subtractive blend mode."
msgstr "减法混合模式。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:23
#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:25
msgid "**blend_mul**"
msgstr "**blend_mul**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:23
#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:25
msgid "Multiplicative blend mode."
msgstr "乘法混合模式。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:25
msgid "**depth_draw_opaque**"
msgstr "**depth_draw_opaque**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:25
msgid "Only draw depth for opaque geometry (not transparent)."
msgstr "仅绘制不透明几何体的深度(不透明)。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:27
msgid "**depth_draw_always**"
msgstr "**depth_draw_always**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:27
msgid "Always draw depth (opaque and transparent)."
msgstr "始终绘制深度(不透明和透明)。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:29
msgid "**depth_draw_never**"
msgstr "**depth_draw_never**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:29
msgid "Never draw depth."
msgstr "永远不要画深度。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:31
msgid "**depth_draw_alpha_prepass**"
msgstr "**depth_draw_alpha_prepass**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:31
msgid "Do opaque depth pre-pass for transparent geometry."
msgstr "对透明几何体进行不透明的深度预传。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:33
msgid "**depth_test_disable**"
msgstr "**depth_test_disable**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:33
msgid "Disable depth testing."
msgstr "禁用深度测试。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:35
msgid "**cull_front**"
msgstr "**cull_front**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:35
msgid "Cull front-faces."
msgstr "剔除正面。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:37
msgid "**cull_back**"
msgstr "**cull_back**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:37
msgid "Cull back-faces (default)."
msgstr "剔除背面(默认)。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:39
msgid "**cull_disabled**"
msgstr "**cull_disabled**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:39
msgid "Culling disabled (double sided)."
msgstr "剔除禁用(双面)。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:41
#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:31
msgid "**unshaded**"
msgstr "**unshaded**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:41
#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:31
msgid "Result is just albedo. No lighting/shading happens in material."
msgstr "结果只是反照率。 材质中不会发生照明/阴影。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:43
msgid "**diffuse_lambert**"
msgstr "**diffuse_lambert**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:43
msgid "Lambert shading for diffuse (default)."
msgstr "漫反射的Lambert着色(默认)。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:45
msgid "**diffuse_lambert_wrap**"
msgstr "**diffuse_lambert_wrap**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:45
msgid "Lambert wrapping (roughness dependent) for diffuse."
msgstr "Lambert包(取决于粗糙度)用于漫射。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:47
msgid "**diffuse_oren_nayar**"
msgstr "**diffuse_oren_nayar**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:47
msgid "Oren Nayar for diffuse."
msgstr "Oren Nayar弥漫。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:49
msgid "**diffuse_burley**"
msgstr "**diffuse_burley**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:49
msgid "Burley (Disney PBS) for diffuse."
msgstr "Burley(迪士尼PBS)弥漫。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:51
msgid "**diffuse_toon**"
msgstr "**diffuse_toon**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:51
msgid "Toon shading for diffuse."
msgstr "香椿着色为漫反射。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:53
msgid "**specular_schlick_ggx**"
msgstr "**specular_schlick_ggx**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:53
msgid "Schlick-GGX for specular (default)."
msgstr "Schlick-GGX用于镜面反射(默认)。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:55
msgid "**specular_blinn**"
msgstr "**specular_blinn**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:55
msgid "Blinn for specular (compatibility)."
msgstr "Blinn for specular(兼容性)。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:57
msgid "**specular_phong**"
msgstr "**specular_phong**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:57
msgid "Phong for specular (compatibility)."
msgstr "Phong for specular(兼容性)。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:59
msgid "**specular_toon**"
msgstr "**specular_toon**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:59
msgid "Toon for specular."
msgstr "香椿镜面反射。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:61
msgid "**specular_disabled**"
msgstr "**specular_disabled**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:61
msgid "Disable specular."
msgstr "禁用镜面反射。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:63
#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:35
msgid "**skip_vertex_transform**"
msgstr "**skip_vertex_transform**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:63
#, fuzzy
msgid "VERTEX/NORMAL/etc. need to be transformed manually in vertex function."
msgstr "VERTEX / NORMAL / etc需要在VS中手动转换。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:65
msgid "**world_vertex_coords**"
msgstr "**world_vertex_coords**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:65
#, fuzzy
msgid "VERTEX/NORMAL/etc. are modified in world coordinates instead of local."
msgstr "VERTEX / NORMAL / etc在世界坐标中而不是在本地坐标中进行修改。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:67
msgid "**ensure_correct_normals**"
msgstr ""

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:67
msgid "Use when non-uniform scale is applied to mesh."
msgstr ""

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:69
msgid "**vertex_lighting**"
msgstr "**vertex_lighting**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:69
msgid "Use vertex-based lighting."
msgstr "使用基于顶点的照明。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:71
#, fuzzy
msgid "**shadows_disabled**"
msgstr "**specular_disabled**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:71
msgid "Disable computing shaders in shader."
msgstr ""

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:73
#, fuzzy
msgid "**ambient_light_disabled**"
msgstr "**depth_test_disable**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:73
msgid "Disable contribution from ambient light and radiance map."
msgstr ""

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:77
#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:39
#: ../../docs/tutorials/shading/shading_reference/particle_shader.rst:40
#, fuzzy
msgid "Vertex built-ins"
msgstr "顶点内置"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:79
#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:41
#: ../../docs/tutorials/shading/shading_reference/particle_shader.rst:42
#, fuzzy
msgid ""
"Values marked as \"in\" are read-only. Values marked as \"out\" are for "
"optional writing and will not necessarily contain sensible values. Values "
"marked as \"inout\" provide a sensible default value, and can optionally be "
"written to. Samplers are not subjects of writing and they are not marked."
msgstr ""
"标记为“in”的值是只读的。 标记为“out”的值用于可选写入。 取样器不是书写对象，也"
"没有标记。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:84
#, fuzzy
msgid ""
"Vertex data (``VERTEX``, ``NORMAL``, ``TANGENT``, ``BITANGENT``) are "
"presented in local model space. If not written to, these values will not be "
"modified and be passed through as they came."
msgstr ""
"顶点数据(VERTEX，NORMAL，TANGENT，BITANGENT)显示在本地模型空间中。 如果没有写"
"入，这些值将不会被修改并在它们到来时传递。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:88
#, fuzzy
msgid ""
"They can optionally be presented in world space by using the "
"*world_vertex_coords* render mode."
msgstr ""
"通过添加* world_vertex_coords *渲染模式，可以选择将它们设置为在世界空间中呈现"
"(在被世界变换之后)。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:90
#, fuzzy
msgid ""
"Users can disable the built-in modelview transform (projection will still "
"happen later) and do it manually with the following code:"
msgstr ""
"可以使用以下代码完全禁用内置模型视图变换(投影仍将在稍后进行)，因此可以手动完"
"成:"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:104
#, fuzzy
msgid ""
"Other built-ins, such as UV, UV2 and COLOR, are also passed through to the "
"fragment function if not modified."
msgstr "如果不修改，其他内置函数(如UV，UV2和COLOR)也会传递给片段函数。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:106
msgid ""
"Users can override the modelview and projection transforms using the "
"``POSITION`` built-in. When ``POSITION`` is used, the value from ``VERTEX`` "
"is ignored and projection does not happen. However, the value passed to the "
"fragment shader still comes from ``VERTEX``."
msgstr ""

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:110
#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:87
msgid ""
"For instancing, the INSTANCE_CUSTOM variable contains the instance custom "
"data. When using particles, this information is usually:"
msgstr ""
"对于实例化，INSTANCE_CUSTOM变量包含实例自定义数据。 使用粒子时，此信息通常是:"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:113
#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:90
msgid "**x**: Rotation angle in radians."
msgstr "** x**: 以弧度表示的旋转角度。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:114
#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:91
msgid "**y**: Phase during lifetime (0 to 1)."
msgstr "** y**: 寿命期间的相位(0到1)。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:115
#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:92
msgid "**z**: Animation frame."
msgstr "** z**: 动画帧。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:117
#, fuzzy
msgid ""
"This allows you to easily adjust the shader to a particle system using "
"default particles material. When writing a custom particles shader, this "
"value can be used as desired."
msgstr ""
"这允许使用默认粒子材质轻松地将着色器调整到粒子系统。 编写自定义粒子着色器时，"
"可以根据需要使用此值。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:121
#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:175
#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:288
#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:95
#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:144
#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:193
#: ../../docs/tutorials/shading/shading_reference/particle_shader.rst:51
msgid "Built-in"
msgstr "内建的"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:123
#, fuzzy
msgid "inout mat4 **WORLD_MATRIX**"
msgstr "out mat4 **WORLD_MATRIX**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:123
#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:179
#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:292
msgid "Model space to world space transform."
msgstr "模型空间到世界空间变换。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:125
#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:181
#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:294
msgid "in mat4 **INV_CAMERA_MATRIX**"
msgstr "in mat4 **INV_CAMERA_MATRIX**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:125
#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:181
#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:294
msgid "World space to view space transform."
msgstr "观看空间变换的世界空间。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:127
#, fuzzy
msgid "inout mat4 **PROJECTION_MATRIX**"
msgstr "out mat4 **PROJECTION_MATRIX**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:127
#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:185
#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:298
#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:101
msgid "View space to clip space transform."
msgstr "查看空间以剪切空间变换。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:129
#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:183
#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:296
msgid "in mat4 **CAMERA_MATRIX**"
msgstr "in mat4 **CAMERA_MATRIX**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:129
#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:183
#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:296
msgid "View space to world space transform."
msgstr "查看空间到世界空间变换。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:131
#, fuzzy
msgid "inout mat4 **MODELVIEW_MATRIX**"
msgstr "out mat4 **MODELVIEW_MATRIX**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:131
msgid "Model space to view space transform (use if possible)."
msgstr "用于查看空间变换的模型空间(如果可能，请使用)。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:133
#, fuzzy
msgid "inout mat4 **INV_PROJECTION_MATRIX**"
msgstr "out mat4 **INV_PROJECTION_MATRIX**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:133
#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:187
#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:300
msgid "Clip space to view space transform."
msgstr "用于查看空间变换的剪辑空间。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:135
#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:189
#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:302
#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:103
#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:174
#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:215
#: ../../docs/tutorials/shading/shading_reference/particle_shader.rst:67
msgid "in float **TIME**"
msgstr "in float **TIME**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:135
#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:189
#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:302
msgid "Elapsed total time in seconds."
msgstr "经过的总时间(秒)。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:137
#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:191
#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:304
msgid "in vec2 **VIEWPORT_SIZE**"
msgstr "in vec2 **VIEWPORT_SIZE**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:137
#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:191
#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:304
msgid "Size of viewport (in pixels)."
msgstr "视区大小(以像素为单位)。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:139
#, fuzzy
msgid "inout vec3 **VERTEX**"
msgstr "out vec2 **VERTEX**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:139
#, fuzzy
msgid "Vertex in local coordinates."
msgstr "切线在当地的坐标。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:141
#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:199
#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:148
#, fuzzy
msgid "inout vec3 **NORMAL**"
msgstr "out vec3 **NORMAL**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:141
#, fuzzy
msgid "Normal in local coordinates."
msgstr "局部坐标正常。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:143
#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:201
#, fuzzy
msgid "inout vec3 **TANGENT**"
msgstr "out vec3 **TANGENT**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:143
#, fuzzy
msgid "Tangent in local coordinates."
msgstr "切线在当地的坐标。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:145
#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:203
#, fuzzy
msgid "inout vec3 **BINORMAL**"
msgstr "out vec3 **BINORMAL**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:145
#, fuzzy
msgid "Binormal in local coordinates."
msgstr "本地坐标中的正常。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:147
#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:115
#, fuzzy
msgid "inout vec2 **UV**"
msgstr "out vec2 **UV**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:147
msgid "UV main channel."
msgstr "紫外线主通道。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:149
#, fuzzy
msgid "inout vec2 **UV2**"
msgstr "out vec2 **UV**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:149
msgid "UV secondary channel."
msgstr "紫外辅助通道。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:151
#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:117
#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:157
#: ../../docs/tutorials/shading/shading_reference/particle_shader.rst:53
#, fuzzy
msgid "inout vec4 **COLOR**"
msgstr "out vec4 **COLOR**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:151
msgid "Color from vertices."
msgstr "顶点颜色。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:153
#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:119
#, fuzzy
msgid "inout float **POINT_SIZE**"
msgstr "out float **POINT_SIZE**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:153
msgid "Point size for point rendering."
msgstr "点渲染的点大小。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:155
#, fuzzy
msgid "out vec4  **POSITION**"
msgstr "out vec4 **COLOR**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:155
msgid "If written to, overrides final vertex position."
msgstr ""

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:157
msgid "in int **INSTANCE_ID**"
msgstr "in int **INSTANCE_ID**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:157
msgid "Instance ID for instancing."
msgstr "实例化的实例ID。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:159
#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:105
msgid "in vec4 **INSTANCE_CUSTOM**"
msgstr "in vec4 **INSTANCE_CUSTOM**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:159
msgid "Instance custom data (for particles, mostly)."
msgstr "实例自定义数据(主要用于粒子)。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:161
#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:223
msgid "out float **ROUGHNESS**"
msgstr "out float **ROUGHNESS**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:161
msgid "Roughness for vertex lighting."
msgstr "顶点照明的粗糙度。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:163
#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:259
#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:326
#, fuzzy
msgid "in bool **OUTPUT_IS_SRGB**"
msgstr "in float **ROUGHNESS**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:163
#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:259
#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:326
msgid ""
"True when calculations happen in sRGB color space (true in GLES2, false in "
"GLES3)."
msgstr ""

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:168
#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:123
#, fuzzy
msgid "Fragment built-ins"
msgstr "片段内置"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:170
msgid ""
"The default use of a Godot fragment processor function is to set up the "
"material properties of your object and to let the built-in renderer handle "
"the final shading. However, you are not required to use all these "
"properties, and if you don't write to them, Godot will optimize away the "
"corresponding functionality."
msgstr ""

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:177
#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:290
#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:146
#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:195
msgid "in vec4 **FRAGCOORD**"
msgstr "在vec4 ** FRAGCOORD **"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:177
#, fuzzy
msgid "Fragment coordinate, pixel adjusted. In screen space."
msgstr "片段坐标，像素调整。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:179
#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:292
#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:97
msgid "in mat4 **WORLD_MATRIX**"
msgstr "在mat4 ** WORLD_MATRIX **"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:185
#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:298
#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:101
msgid "in mat4 **PROJECTION_MATRIX**"
msgstr "in mat4 **PROJECTION_MATRIX**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:187
#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:300
msgid "in mat4 **INV_PROJECTION_MATRIX**"
msgstr "in mat4 **INV_PROJECTION_MATRIX**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:193
msgid "in vec3 **VERTEX**"
msgstr "in vec3 **VERTEX**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:193
#, fuzzy
msgid "Vertex that comes from vertex function (default, in view space)."
msgstr "来自顶点函数的顶点，在视图空间中。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:195
#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:308
msgid "in vec3 **VIEW**"
msgstr "in vec3 **VIEW**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:195
#, fuzzy
msgid "Vector from camera to fragment position (in view space)."
msgstr "来自顶点函数的顶点，在视图空间中。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:197
msgid "in bool **FRONT_FACING**"
msgstr "in bool **FRONT_FACING**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:197
#, fuzzy
msgid "True if current face is front face."
msgstr "当前面是否是正面是真的。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:199
#, fuzzy
msgid "Normal that comes from vertex function (default, in view space)."
msgstr "来自顶点函数的正常，在视图空间中。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:201
msgid "Tangent that comes from vertex function."
msgstr "来自顶点函数的切线。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:203
msgid "Binormal that comes from vertex function."
msgstr "来自顶点函数的Binormal。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:205
#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:150
msgid "out vec3 **NORMALMAP**"
msgstr "out vec3 **NORMALMAP**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:205
#, fuzzy
msgid "Set normal here if reading normal from a texture instead of NORMAL."
msgstr "如果从纹理而不是NORMAL读取法线，则输出此值。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:207
msgid "out float **NORMALMAP_DEPTH**"
msgstr "out float **NORMALMAP_DEPTH**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:207
msgid "Depth from variable above. Defaults to 1.0."
msgstr "从变量上方深度。 默认为1.0。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:209
#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:155
#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:200
msgid "in vec2 **UV**"
msgstr "in vec2 **UV**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:209
msgid "UV that comes from vertex function."
msgstr "来自顶点功能的UV。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:211
msgid "in vec2 **UV2**"
msgstr "in vec2 **UV2**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:211
msgid "UV2 that comes from vertex function."
msgstr "来自顶点功能的UV2。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:213
#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:202
msgid "in vec4 **COLOR**"
msgstr "in vec4 **COLOR**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:213
msgid "COLOR that comes from vertex function."
msgstr "来自顶点功能的颜色。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:215
msgid "out vec3 **ALBEDO**"
msgstr "out vec3 **ALBEDO**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:215
msgid "Albedo (default white)."
msgstr "反照率(默认为白色)。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:217
msgid "out float **ALPHA**"
msgstr "out float **ALPHA**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:217
#, fuzzy
msgid ""
"Alpha (0..1); if written to, the material will go to the transparent "
"pipeline."
msgstr "Alpha(0..1)，如果写入材质将转到透明管道。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:219
msgid "out float **METALLIC**"
msgstr "out float **METALLIC**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:219
msgid "Metallic (0..1)."
msgstr "Metallic (0..1)."

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:221
msgid "out float **SPECULAR**"
msgstr "out float **SPECULAR**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:221
#, fuzzy
msgid ""
"Specular. Defaults to 0.5, best not to modify unless you want to change IOR."
msgstr "镜面。 默认为0.5，除非您想要更改IOR，否则最好不要修改。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:223
msgid "Roughness (0..1)."
msgstr "粗糙度(0..1)。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:225
msgid "out float **RIM**"
msgstr "out float **RIM**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:225
msgid "Rim (0..1). If used, Godot calculates rim lighting."
msgstr ""

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:227
msgid "out float **RIM_TINT**"
msgstr "out float **RIM_TINT**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:227
#, fuzzy
msgid ""
"Rim Tint, goes from 0 (white) to 1 (albedo). If used, Godot calculates rim "
"lighting."
msgstr "Rim Tint，从0(白色)变为1(反照率)。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:229
msgid "out float **CLEARCOAT**"
msgstr "out float **CLEARCOAT**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:229
msgid "Small added specular blob. If used, Godot calculates Clearcoat."
msgstr ""

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:231
msgid "out float **CLEARCOAT_GLOSS**"
msgstr "out float **CLEARCOAT_GLOSS**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:231
msgid "Gloss of Clearcoat. If used, Godot calculates Clearcoat."
msgstr ""

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:233
msgid "out float **ANISOTROPY**"
msgstr "out float **ANISOTROPY**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:233
msgid "For distorting the specular blob according to tangent space."
msgstr "用于根据切线空间扭曲镜面斑点。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:235
msgid "out vec2 **ANISOTROPY_FLOW**"
msgstr "out vec2 **ANISOTROPY_FLOW**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:235
msgid "Distortion direction, use with flowmaps."
msgstr "失真方向，与流程图一起使用。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:237
msgid "out float **SSS_STRENGTH**"
msgstr "out float **SSS_STRENGTH**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:237
msgid ""
"Strength of Subsurface Scattering. If used, Subsurface Scattering will be "
"applied to object."
msgstr ""

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:239
msgid "out vec3 **TRANSMISSION**"
msgstr "out vec3 **TRANSMISSION**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:239
msgid ""
"Transmission mask (default 0,0,0). Allows light to pass through object. Only "
"applied if used."
msgstr ""

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:241
msgid "out float **AO**"
msgstr "out float **AO**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:241
#, fuzzy
msgid "Strength of Ambient Occlusion. For use with pre-baked AO."
msgstr "环境遮挡(预烘焙)。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:243
msgid "out float **AO_LIGHT_AFFECT**"
msgstr "out float **AO_LIGHT_AFFECT**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:243
#, fuzzy
msgid "How much AO affects lights (0..1; default 0)."
msgstr "AO对灯光的影响程度(0..1。默认为0，无)。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:245
msgid "out vec3 **EMISSION**"
msgstr "out vec3 **EMISSION**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:245
msgid "Emission color (can go over 1,1,1 for HDR)."
msgstr "发射颜色(HDR可以超过1,1,1)。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:247
msgid "sampler2D **SCREEN_TEXTURE**"
msgstr "sampler2D **SCREEN_TEXTURE**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:247
msgid ""
"Built-in Texture for reading from the screen. Mipmaps contain increasingly "
"blurred copies."
msgstr "内置纹理，用于从屏幕上读取。 Mipmap包含越来越模糊的副本。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:249
msgid "sampler2D **DEPTH_TEXTURE**"
msgstr "sampler2D **DEPTH_TEXTURE**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:249
msgid ""
"Built-in Texture for reading depth from the screen. Must convert to linear "
"using INV_PROJECTION."
msgstr "内置纹理，用于从屏幕读取深度。 必须使用INV_PROJECTION转换为线性。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:251
msgid "out float **DEPTH**"
msgstr "out float **DEPTH**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:251
msgid "Custom depth value (0..1)."
msgstr "自定义深度值(0..1)。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:253
#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:168
#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:211
msgid "in vec2 **SCREEN_UV**"
msgstr "in vec2 **SCREEN_UV**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:253
msgid "Screen UV coordinate for current pixel."
msgstr "屏幕当前像素的UV坐标。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:255
#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:172
#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:213
msgid "in vec2 **POINT_COORD**"
msgstr "in vec2 **POINT_COORD**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:255
#, fuzzy
msgid "Point Coordinate for drawing points with POINT_SIZE."
msgstr "使用POINT_SIZE绘制点的点坐标。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:257
msgid "out float **ALPHA_SCISSOR**"
msgstr "out float **ALPHA_SCISSOR**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:257
msgid "If written to, values below a certain amount of alpha are discarded."
msgstr "如果写入，则丢弃低于一定量alpha的值。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:264
#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:182
#, fuzzy
msgid "Light built-ins"
msgstr "轻型内置"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:266
msgid ""
"Writing light processor functions is completely optional. You can skip the "
"light function by setting render_mode to ``unshaded``. If no light function "
"is written, Godot will use the material properties written to in the "
"fragment function to calculate the lighting for you (subject to the "
"render_mode)."
msgstr ""

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:271
#, fuzzy
msgid ""
"To write a light function, assign something to ``DIFFUSE_LIGHT`` or "
"``SPECULAR_LIGHT``. Assigning nothing means no light is processed."
msgstr ""
"要编写灯光着色器，只需确保将某些内容分配给DIFFUSE_LIGHT或SPECULAR_LIGHT即"
"可。 无任何分配意味着不处理光。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:274
msgid ""
"The light function is called for every light in every pixel. It is called "
"within a loop for each light type."
msgstr ""

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:277
msgid ""
"Below is an example of a custom light function using a Lambertian lighting "
"model:"
msgstr ""

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:285
msgid ""
"If you want the lights to add together, add the light contribution to "
"``DIFFUSE_LIGHT`` using ``+=``, rather than overwriting it."
msgstr ""

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:290
#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:146
msgid "Fragment coordinate, pixel adjusted."
msgstr "片段坐标，像素调整。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:306
#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:197
msgid "in vec3 **NORMAL**"
msgstr "in vec3 **NORMAL**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:306
#, fuzzy
msgid "Normal vector, in view space."
msgstr "来自顶点函数的正常，在视图空间中。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:308
#, fuzzy
msgid "View vector, in view space."
msgstr "图像空间中的顶点。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:310
msgid "in vec3 **LIGHT**"
msgstr "in vec3 **LIGHT**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:310
#, fuzzy
msgid "Light Vector, in view space."
msgstr "图像空间中的顶点。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:312
msgid "in vec3 **LIGHT_COLOR**"
msgstr "in vec3 **LIGHT_COLOR**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:312
msgid "Color of light multiplied by energy."
msgstr "光的颜色乘以能量。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:314
msgid "in vec3 **ATTENUATION**"
msgstr "in vec3 **ATTENUATION**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:314
msgid "Attenuation based on distance or shadow."
msgstr "基于距离或阴影的衰减。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:316
msgid "in vec3 **ALBEDO**"
msgstr "in vec3 **ALBEDO**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:316
msgid "Base albedo."
msgstr "基地反照率。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:318
msgid "in vec3 **TRANSMISSION**"
msgstr "in vec3 **TRANSMISSION**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:318
msgid "Transmission mask."
msgstr "传输掩模。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:320
msgid "in float **ROUGHNESS**"
msgstr "in float **ROUGHNESS**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:320
msgid "Roughness."
msgstr "粗糙度。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:322
msgid "out vec3 **DIFFUSE_LIGHT**"
msgstr "out vec3 **DIFFUSE_LIGHT**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:322
msgid "Diffuse light result."
msgstr "漫射光效果。"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:324
msgid "out vec3 **SPECULAR_LIGHT**"
msgstr "out vec3 **SPECULAR_LIGHT**"

#: ../../docs/tutorials/shading/shading_reference/spatial_shader.rst:324
msgid "Specular light result."
msgstr "镜面光效果。"

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:4
#, fuzzy
msgid "CanvasItem shaders"
msgstr "CanvasItem"

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:6
msgid ""
"CanvasItem shaders are used to draw all 2D elements in Godot. These include "
"all nodes that inherit from CanvasItems, and all GUI elements."
msgstr ""

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:9
msgid ""
"CanvasItem shaders contain less built-in variables and functionality than "
"Spatial shaders, but they maintain the same basic structure with vertex, "
"fragment, and light processor functions."
msgstr ""

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:27
msgid "**blend_premul_alpha**"
msgstr "**blend_premul_alpha**"

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:27
#, fuzzy
msgid "Pre-multiplied alpha blend mode."
msgstr "预乘alpha混合模式。"

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:29
#, fuzzy
msgid "**blend_disabled**"
msgstr "**cull_disabled**"

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:29
msgid "Disable blending, values (including alpha) are written as-is."
msgstr ""

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:33
msgid "**light_only**"
msgstr "**light_only**"

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:33
#, fuzzy
msgid "Only draw on light pass."
msgstr "仅绘制光通过(使用多通道时)。"

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:35
#, fuzzy
msgid "VERTEX/NORMAL/etc need to be transformed manually in vertex function."
msgstr "VERTEX / NORMAL / etc需要在VS中手动转换。"

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:46
#, fuzzy
msgid ""
"Vertex data (``VERTEX``) is presented in local space (pixel coordinates, "
"relative to the camera). If not written to, these values will not be "
"modified and be passed through as they came."
msgstr ""
"顶点数据(VERTEX)显示在本地空间中。 如果没有写入，这些值将不会被修改并在它们到"
"来时传递。"

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:49
#, fuzzy
msgid ""
"The user can disable the built-in modelview transform (projection will still "
"happen later) and do it manually with the following code:"
msgstr ""
"可以使用以下代码完全禁用内置模型视图变换(投影仍将在稍后进行)，因此可以手动完"
"成:"

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:62
msgid ""
"``WORLD_MATRIX`` is actually a modelview matrix. It takes input in local "
"space and transforms it into view space."
msgstr ""

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:65
msgid ""
"In order to get the world space coordinates of a vertex, you have to pass in "
"a custom uniform like so:"
msgstr ""

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:72
#, fuzzy
msgid "Then, in your vertex shader:"
msgstr "我们像这样定义顶点着色器:"

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:83
msgid ""
"``world_position`` can then be used in either the vertex or fragment "
"functions."
msgstr ""

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:85
#, fuzzy
msgid ""
"Other built-ins, such as UV and COLOR, are also passed through to the "
"fragment function if not modified."
msgstr "如果不修改，其他内置函数(如UV和COLOR)也会传递给片段函数。"

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:97
#, fuzzy
msgid "Image space to view space transform."
msgstr "用于查看空间变换的剪辑空间。"

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:99
msgid "in mat4 **EXTRA_MATRIX**"
msgstr "in mat4 **EXTRA_MATRIX**"

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:99
msgid "Extra transform."
msgstr "额外的转变。"

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:103
msgid "Global time, in seconds."
msgstr "全球时间，以秒为单位。"

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:105
msgid "Instance custom data."
msgstr "实例自定义数据。"

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:107
#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:176
msgid "in bool **AT_LIGHT_PASS**"
msgstr "in bool **AT_LIGHT_PASS**"

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:107
#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:176
#, fuzzy
msgid "True if this is a light pass."
msgstr "如果这是光通过则为真(对于多次通过光渲染)。"

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:109
#, fuzzy
msgid "inout vec2 **VERTEX**"
msgstr "out vec2 **VERTEX**"

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:109
#, fuzzy
msgid "Vertex, in image space."
msgstr "图像空间中的顶点。"

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:111
#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:164
#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:207
msgid "in vec2 **TEXTURE_PIXEL_SIZE**"
msgstr "in vec2 **TEXTURE_PIXEL_SIZE**"

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:111
#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:164
#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:207
msgid ""
"Normalized pixel size of default 2D texture. For a Sprite with a texture of "
"size 64x32px, **TEXTURE_PIXEL_SIZE** = :code:`vec2(1/64, 1/32)`"
msgstr ""
"默认2D纹理的标准化像素大小。 对于纹理大小为64x32px的Sprite，** "
"TEXTURE_PIXEL_SIZE ** =:code:`vec2(1 / 64,1 / 32)`"

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:115
msgid "UV."
msgstr "UV."

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:117
msgid "Color from vertex primitive."
msgstr "来自顶点原语的颜色。"

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:119
msgid "Point size for point drawing."
msgstr "点绘图的点大小。"

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:125
msgid ""
"Certain Nodes (for example, :ref:`Sprites <class_Sprite>`) display a texture "
"by default. However, when a custom fragment function is attached to these "
"nodes, the texture lookup needs to be done manually. Godot does not provide "
"the texture color in the ``COLOR`` built-in variable; to read the texture "
"color for such nodes, use:"
msgstr ""

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:134
msgid ""
"This differs from the behaviour of the built-in normal map. If a normal map "
"is attached, Godot uses it by default and assigns its value to the built-in "
"``NORMAL`` variable. If you are using a normal map meant for use in 3D, it "
"will appear inverted. In order to use it in your shader, you must assign it "
"to the ``NORMALMAP`` property. Godot will handle converting it for use in 2D "
"and overwriting ``NORMAL``."
msgstr ""

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:148
#, fuzzy
msgid "Normal read from **NORMAL_TEXTURE**. Writable."
msgstr "sampler2D **NORMAL_TEXTURE**"

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:150
msgid ""
"Configures normal maps meant for 3D for use in 2D. If used, overwrites "
"**NORMAL**."
msgstr ""

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:153
#, fuzzy
msgid "inout float **NORMALMAP_DEPTH**"
msgstr "out float **NORMALMAP_DEPTH**"

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:153
msgid "Normalmap depth for scaling."
msgstr "用于缩放的法线贴图深度。"

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:155
msgid "UV from vertex function."
msgstr "来自顶点功能的UV。"

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:157
msgid ""
"Color from vertex function and output fragment color. If unused, will be set "
"to **TEXTURE** color."
msgstr ""

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:160
#, fuzzy
msgid "in sampler2D **TEXTURE**"
msgstr "sampler2D **TEXTURE**"

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:160
msgid "Default 2D texture."
msgstr "默认的2D纹理。"

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:162
#, fuzzy
msgid "in sampler2D **NORMAL_TEXTURE**"
msgstr "sampler2D **NORMAL_TEXTURE**"

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:162
msgid "Default 2D normal texture."
msgstr "默认2D普通纹理。"

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:168
#, fuzzy
msgid "Screen UV for use with **SCREEN_TEXTURE**."
msgstr "屏幕UV用于SCREEN_TEXTURE。"

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:170
msgid "in vec2 **SCREEN_PIXEL_SIZE**"
msgstr "in vec2 **SCREEN_PIXEL_SIZE**"

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:170
msgid "Size of individual pixels. Equal to inverse of resolution."
msgstr "单个像素的大小。 等于分辨率的倒数。"

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:172
msgid "Coordinate for drawing points."
msgstr "协调绘图点。"

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:174
#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:215
#: ../../docs/tutorials/shading/shading_reference/particle_shader.rst:67
msgid "Global time in seconds."
msgstr "全球时间以秒为单位。"

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:178
#, fuzzy
msgid "in sampler2D **SCREEN_TEXTURE**"
msgstr "sampler2D **SCREEN_TEXTURE**"

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:178
msgid "Screen texture, mipmaps contain gaussian blurred versions."
msgstr "屏幕纹理，mipmap包含高斯模糊版本。"

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:184
msgid ""
"Light processor functions work differently in 2D than they do in 3D. In "
"CanvasItem shaders, the shader is called once for the object being drawn, "
"and then once for each light touching that object in the scene. Use "
"render_mode ``unshaded`` if you do not want any light passes to occur for "
"that object. Use render_mode ``light_only`` if you only want light passes to "
"occur for that object; this can be useful when you only want the object "
"visible where it is covered by light."
msgstr ""

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:190
msgid ""
"When the shader is on a light pass, the ``AT_LIGHT_PASS`` variable will be "
"``true``."
msgstr ""

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:195
#, fuzzy
msgid "Fragment coordinate of pixel center. Origin at lower left."
msgstr "片段坐标，像素调整。"

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:197
msgid ""
"Input Normal. Although this value is passed in, **normal calculation still "
"happens outside of this function**."
msgstr "输入正常。 虽然传入了这个值，但 **正常计算仍然发生在此函数之外** 。"

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:200
msgid "UV from vertex function, equivalent to the UV in the fragment function."
msgstr "来自顶点函数的UV，相当于片段函数中的UV。"

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:202
msgid ""
"Input Color. This is the output of the fragment function with final "
"modulation applied."
msgstr "输入颜色。 这是应用了最终调制的片段函数的输出。"

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:205
msgid "sampler2D **TEXTURE**"
msgstr "sampler2D **TEXTURE**"

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:205
msgid "Current texture in use for CanvasItem."
msgstr "CanvasItem使用的当前纹理。"

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:211
#, fuzzy
msgid "**SCREEN_TEXTURE** Coordinate (for using with screen texture)."
msgstr "屏幕纹理坐标(用于屏幕纹理)。"

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:213
#, fuzzy
msgid "UV for Point Sprite."
msgstr "Point Sprite的当前UV。"

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:217
#, fuzzy
msgid "inout vec2 **LIGHT_VEC**"
msgstr "out vec2 **LIGHT_VEC**"

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:217
msgid ""
"Vector from light to fragment, can be modified to alter shadow computation."
msgstr "向量从光到片段，可以修改以改变阴影计算。"

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:219
#, fuzzy
msgid "inout float **LIGHT_HEIGHT**"
msgstr "out float **LIGHT_HEIGHT**"

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:219
msgid "Height of Light. Only effective when normals are used."
msgstr ""

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:221
#, fuzzy
msgid "inout vec4 **LIGHT_COLOR**"
msgstr "out vec4 **LIGHT_COLOR**"

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:221
msgid "Color of Light."
msgstr "光的颜色。"

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:223
#, fuzzy
msgid "in vec2 **LIGHT_UV**"
msgstr "out vec2 **LIGHT_UV**"

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:223
msgid "UV for Light texture."
msgstr "紫外线对质地轻。"

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:225
msgid "out vec4 **SHADOW_COLOR**"
msgstr "out vec4 **SHADOW_COLOR**"

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:225
#, fuzzy
msgid "Shadow Color of Light."
msgstr "光的颜色。"

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:227
#, fuzzy
msgid "inout vec4 **LIGHT**"
msgstr "out vec4 **LIGHT**"

#: ../../docs/tutorials/shading/shading_reference/canvas_item_shader.rst:227
msgid ""
"Value from the Light texture and output color. Can be modified. If not used, "
"the light function is ignored."
msgstr ""

#: ../../docs/tutorials/shading/shading_reference/particle_shader.rst:4
#, fuzzy
msgid "Particle shaders"
msgstr "ParticlesMaterial"

#: ../../docs/tutorials/shading/shading_reference/particle_shader.rst:6
#, fuzzy
msgid ""
"Particle shaders are a special type of vertex shader that runs before the "
"object is drawn. They are used for calculating material properties such as "
"color, position, and rotation. They are drawn with any regular material for "
"CanvasItem or Spatial, depending on whether they are 2D or 3D."
msgstr ""
"粒子阴影仅支持顶点处理。 它们使用CanvasItem或Spatial的任何常规材质绘制，具体"
"取决于它们是2D还是3D。"

#: ../../docs/tutorials/shading/shading_reference/particle_shader.rst:11
msgid ""
"Particle shaders are unique because they are not used to draw the object "
"itself; they are used to calculate particle properties, which are then used "
"by the CanvasItem of Spatial shader. They contain only a vertex processor "
"function that outputs multiple properties (see built-ins below)."
msgstr ""

#: ../../docs/tutorials/shading/shading_reference/particle_shader.rst:16
msgid ""
"Particle shaders use a transform feedback shader, which is a special type of "
"vertex shader that runs on its own. It takes in data in a buffer like a "
"regular vertex shader does, but it also outputs to data buffers instead of "
"outputting to the fragment shader for pixel-processing. Because of this, "
"transform feedback shaders can build on themselves each run, unlike other "
"shaders that discard the data they have calculated once they draw to the "
"frame buffer."
msgstr ""

#: ../../docs/tutorials/shading/shading_reference/particle_shader.rst:23
msgid ""
"Particle shaders are only available in the GLES3 renderer. If you need "
"particles in GLES2, use :ref:`CPUParticles <class_CPUParticles>`."
msgstr ""

#: ../../docs/tutorials/shading/shading_reference/particle_shader.rst:32
msgid "**keep_data**"
msgstr "**keep_data**"

#: ../../docs/tutorials/shading/shading_reference/particle_shader.rst:32
msgid "Do not clear previous data on restart."
msgstr "不要在重启时清除以前的数据。"

#: ../../docs/tutorials/shading/shading_reference/particle_shader.rst:34
msgid "**disable_force**"
msgstr "**disable_force**"

#: ../../docs/tutorials/shading/shading_reference/particle_shader.rst:34
msgid "Disable attractor force. (Not currently implemented in 3.1)"
msgstr ""

#: ../../docs/tutorials/shading/shading_reference/particle_shader.rst:36
msgid "**disable_velocity**"
msgstr "**disable_velocity**"

#: ../../docs/tutorials/shading/shading_reference/particle_shader.rst:36
#, fuzzy
msgid "Ignore **VELOCITY** value."
msgstr "out vec3 **VELOCITY**"

#: ../../docs/tutorials/shading/shading_reference/particle_shader.rst:47
msgid ""
"In order to use the ``COLOR`` variable in a SpatialMaterial, set "
"``use_vertex_as_albedo`` to ``true``. In a ShaderMaterial, access it with "
"the ``COLOR`` variable."
msgstr ""

#: ../../docs/tutorials/shading/shading_reference/particle_shader.rst:53
#, fuzzy
msgid ""
"Particle color, can be written to and accessed in mesh's vertex function."
msgstr "粒子颜色，可写入。"

#: ../../docs/tutorials/shading/shading_reference/particle_shader.rst:55
#, fuzzy
msgid "inout vec3 **VELOCITY**"
msgstr "out vec3 **VELOCITY**"

#: ../../docs/tutorials/shading/shading_reference/particle_shader.rst:55
msgid "Particle velocity, can be modified."
msgstr "粒子速度，可以修改。"

#: ../../docs/tutorials/shading/shading_reference/particle_shader.rst:57
msgid "out float **MASS**"
msgstr "out float **MASS**"

#: ../../docs/tutorials/shading/shading_reference/particle_shader.rst:57
#, fuzzy
msgid "Particle mass, use for attractors (not implemented in 3.1)."
msgstr "粒子质量，用于吸引子(默认1)。"

#: ../../docs/tutorials/shading/shading_reference/particle_shader.rst:59
#, fuzzy
msgid "inout bool **ACTIVE**"
msgstr "out bool **ACTIVE**"

#: ../../docs/tutorials/shading/shading_reference/particle_shader.rst:59
#, fuzzy
msgid "True when Particle is active, can be set to false."
msgstr "粒子是活动的，可以设置为false。"

#: ../../docs/tutorials/shading/shading_reference/particle_shader.rst:61
msgid "in bool **RESTART**"
msgstr "in bool **RESTART**"

#: ../../docs/tutorials/shading/shading_reference/particle_shader.rst:61
#, fuzzy
msgid "True when particle must restart (lifetime cycled)."
msgstr "当粒子必须重新启动(生命周期循环)时设置为true。"

#: ../../docs/tutorials/shading/shading_reference/particle_shader.rst:63
#, fuzzy
msgid "inout vec4 **CUSTOM**"
msgstr "out vec4 **CUSTOM**"

#: ../../docs/tutorials/shading/shading_reference/particle_shader.rst:63
msgid ""
"Custom particle data. Accessible from shader of mesh as **INSTANCE_CUSTOM**."
msgstr ""

#: ../../docs/tutorials/shading/shading_reference/particle_shader.rst:65
#, fuzzy
msgid "inout mat4 **TRANSFORM**"
msgstr "out mat4 **TRANSFORM**"

#: ../../docs/tutorials/shading/shading_reference/particle_shader.rst:65
msgid "Particle transform."
msgstr "粒子变换。"

#: ../../docs/tutorials/shading/shading_reference/particle_shader.rst:69
msgid "in float **LIFETIME**"
msgstr "in float **LIFETIME**"

#: ../../docs/tutorials/shading/shading_reference/particle_shader.rst:69
msgid "Particle lifetime."
msgstr "粒子寿命。"

#: ../../docs/tutorials/shading/shading_reference/particle_shader.rst:71
msgid "in float **DELTA**"
msgstr "in float **DELTA**"

#: ../../docs/tutorials/shading/shading_reference/particle_shader.rst:71
msgid "Delta process time."
msgstr "达美处理时间。"

#: ../../docs/tutorials/shading/shading_reference/particle_shader.rst:73
msgid "in uint **NUMBER**"
msgstr "in uint **NUMBER**"

#: ../../docs/tutorials/shading/shading_reference/particle_shader.rst:73
msgid "Unique number since emission start."
msgstr "排放开始后的唯一编号。"

#: ../../docs/tutorials/shading/shading_reference/particle_shader.rst:75
msgid "in int **INDEX**"
msgstr "in int **INDEX**"

#: ../../docs/tutorials/shading/shading_reference/particle_shader.rst:75
msgid "Particle index (from total particles)."
msgstr "颗粒指数(来自总颗粒)。"

#: ../../docs/tutorials/shading/shading_reference/particle_shader.rst:77
msgid "in mat4 **EMISSION_TRANSFORM**"
msgstr "in mat4 **EMISSION_TRANSFORM**"

#: ../../docs/tutorials/shading/shading_reference/particle_shader.rst:77
msgid "Emitter transform (used for non-local systems)."
msgstr "发射器变换(用于非本地系统)。"

#: ../../docs/tutorials/shading/shading_reference/particle_shader.rst:79
msgid "in uint **RANDOM_SEED**"
msgstr "in uint **RANDOM_SEED**"

#: ../../docs/tutorials/shading/shading_reference/particle_shader.rst:79
msgid "Random seed used as base for random."
msgstr "随机种子被用作随机的基础。"

#: ../../docs/tutorials/shading/shader_materials.rst:4
msgid "Shader materials"
msgstr "着色器材质"

#: ../../docs/tutorials/shading/shader_materials.rst:9
#, fuzzy
msgid ""
"For the most common cases, Godot provides ready to use materials for most "
"types of shaders, such as :ref:`SpatialMaterial <class_SpatialMaterial>`, :"
"ref:`CanvasItemMaterial <class_CanvasItemMaterial>` and :ref:"
"`ParticlesMaterial <class_ParticlesMaterial>`. They are flexible "
"implementations that cover most use cases."
msgstr ""
"对于最常见的情况，Godot为大多数类型的着色器提供了随时可用的材质，例如"
"SpatialMaterial，CanvasItemMaterial和ParticlesMaterial(@TODO链接到教程/类)。 "
"它们是灵活的实现，涵盖了大多数用例。"

#: ../../docs/tutorials/shading/shader_materials.rst:14
msgid ""
"Shader materials allow writing a custom shader directly, for maximum "
"flexibility. Examples of this are:"
msgstr ""
"着色器材质允许直接编写自定义着色器，以获得最大的灵活性。 这方面的示例是:"

#: ../../docs/tutorials/shading/shader_materials.rst:17
msgid "Create procedural textures."
msgstr "创建程序纹理。"

#: ../../docs/tutorials/shading/shader_materials.rst:18
#, fuzzy
msgid "Create complex texture blending effects."
msgstr "创建复杂的纹理混合。"

#: ../../docs/tutorials/shading/shader_materials.rst:19
#, fuzzy
msgid "Create animated materials, or materials that change over time."
msgstr "创建随时间变化的动画材质或材质。"

#: ../../docs/tutorials/shading/shader_materials.rst:20
msgid "Create refractive effects or other advanced effects."
msgstr "创建折射效果或其他高级效果。"

#: ../../docs/tutorials/shading/shader_materials.rst:21
msgid "Create special lighting shaders for more exotic materials."
msgstr "为更具异国情调的材质创建特殊照明着色器。"

#: ../../docs/tutorials/shading/shader_materials.rst:22
msgid "Animate vertices, like tree leaves or grass."
msgstr "动画顶点，如树叶或草。"

#: ../../docs/tutorials/shading/shader_materials.rst:23
#, fuzzy
msgid "Create custom particle code."
msgstr "自定义粒子数据。"

#: ../../docs/tutorials/shading/shader_materials.rst:26
#, fuzzy
msgid ""
"Godot provides built in functionality to make frequent operations easier. "
"Additionally, Godot's shader editor will detect errors as you type, so you "
"can see your edited shaders in real-time. It is also possible to edit "
"shaders using a visual, node-based graph editor."
msgstr ""
"传统上，大多数引擎会要求您学习GLSL，HLSL或CG，这对于大多数艺术家来说都是相当"
"复杂的。 Godot使用着色器语言的简化版本，可以在您键入时检测错误，因此您可以实"
"时查看已编辑的着色器。 此外，可以使用基于节点的可视化图形编辑器编辑着色器。"

#: ../../docs/tutorials/shading/shader_materials.rst:32
msgid "Creating a ShaderMaterial"
msgstr "创建ShaderMaterial"

#: ../../docs/tutorials/shading/shader_materials.rst:34
msgid ""
"Create a new ShaderMaterial in some object of your choice. Go to the "
"\"Material\" property and create a ShaderMaterial."
msgstr ""
"在您选择的某个对象中创建一个新的ShaderMaterial。 转到“材质”属性并创建"
"ShaderMaterial。"

#: ../../docs/tutorials/shading/shader_materials.rst:39
msgid "Edit the newly created shader, and the shader editor will open:"
msgstr "编辑新创建的着色器，着色器编辑器将打开:"

#: ../../docs/tutorials/shading/shader_materials.rst:44
msgid "Converting to ShaderMaterial"
msgstr "转换为ShaderMaterial"

#: ../../docs/tutorials/shading/shader_materials.rst:46
#, fuzzy
msgid ""
"It is possible to convert from SpatialMaterial, CanvasItemMaterial and "
"ParticlesMaterial to ShaderMaterial. To do so, go to the material properties "
"and select the convert option."
msgstr ""
"可以将SpatialMaterial，CanvasItemMaterial和ParticlesMaterial转换为"
"ShaderMaterial。 要执行此操作，请转到材质属性并启用转换选项。"

#: ../../docs/tutorials/shading/intro_to_shaders_water_workshop.rst:4
msgid "Intro to shaders: 2D and 3D water"
msgstr "着色器简介:2D和3D水"

#: ../../docs/tutorials/shading/intro_to_shaders_water_workshop.rst:8
msgid ""
"In this hands-on video series, you will create your first water shaders in "
"2D and in 3D. If you're new to shaders, you should start 2D, because you "
"need some basic understanding of the shading language, vertex and fragment "
"shaders, to build upon. 3D adds quite a bit of complexity when it comes to "
"writing shader programs, as you will see in the third video."
msgstr ""
"在这个动手实践的视频系列中，您将创建2D和3D中的第一个水着色器。 如果您是着色器"
"的新手，则应该启动2D，因为您需要对着色语言，顶点和片段着色器有一些基本的了解"
"才能构建。 在编写着色器程序时，3D会增加相当多的复杂性，您将在第三个视频中看"
"到。"

#: ../../docs/tutorials/shading/intro_to_shaders_water_workshop.rst:15
msgid "Watch the tutorials"
msgstr "观看教程"

#: ../../docs/tutorials/shading/intro_to_shaders_water_workshop.rst:19
msgid ""
"You can watch the `full playlist on YouTube <https://www.youtube.com/watch?"
"v=xoyk_A0RSpI&list=PLhqJJNjsQ7KHqNMYmTwtsYTeTrqrRP_fP>`__. Here are the "
"individual videos:"
msgstr ""
"您可以在YouTube上观看 `完整播放列表 <https://www.youtube.com/watch?"
"v=xoyk_A0RSpI&list=PLhqJJNjsQ7KHqNMYmTwtsYTeTrqrRP_fP>`__。 以下是各个视频:"

#: ../../docs/tutorials/shading/intro_to_shaders_water_workshop.rst:21
msgid ""
"`Intro to Shader Programming <https://www.youtube.com/watch?v=xoyk_A0RSpI>`__"
msgstr "`着色器编程简介 <https://www.youtube.com/watch?v=xoyk_A0RSpI>`__"

#: ../../docs/tutorials/shading/intro_to_shaders_water_workshop.rst:22
msgid ""
"`Animated Water and UV Coordinates <https://www.youtube.com/watch?"
"v=U91nqeUe1qQ>`__"
msgstr "`动画水和紫外线坐标 <https://www.youtube.com/watch?v=U91nqeUe1qQ>`__"

#: ../../docs/tutorials/shading/intro_to_shaders_water_workshop.rst:24
msgid "`Water in 3D <https://www.youtube.com/watch?v=vm9Sdvhq6ho>`__"
msgstr "`3D中的水 <https://www.youtube.com/watch?v=vm9Sdvhq6ho>`__"

#: ../../docs/tutorials/shading/intro_to_shaders_water_workshop.rst:25
msgid ""
"`Texture-based Deformation <https://www.youtube.com/watch?v=Pg79tztNZeA>`__"
msgstr "`基于纹理的变形 <https://www.youtube.com/watch?v=Pg79tztNZeA>`__"

#: ../../docs/tutorials/shading/intro_to_shaders_water_workshop.rst:27
msgid ""
"`Merging the Two Waves Together <https://www.youtube.com/watch?"
"v=aC5Yzx7tS74>`__"
msgstr "`将两波融合在一起 <https://www.youtube.com/watch?v=aC5Yzx7tS74>`__"

#: ../../docs/tutorials/shading/intro_to_shaders_water_workshop.rst:29
msgid ""
"`Functions in ShaderScript <https://www.youtube.com/watch?v=1eNWPbfph1E>`__"
msgstr "`ShaderScript中的函数 <https://www.youtube.com/watch?v=1eNWPbfph1E>`__"

#: ../../docs/tutorials/shading/intro_to_shaders_water_workshop.rst:31
msgid ""
"`Water Shadow and Masking <https://www.youtube.com/watch?v=Xqv7C9mVhak>`__"
msgstr "`水影和遮蔽 <https://www.youtube.com/watch?v=Xqv7C9mVhak>`__"

#: ../../docs/tutorials/shading/intro_to_shaders_water_workshop.rst:35
msgid "Download the source code"
msgstr "下载源代码"

#: ../../docs/tutorials/shading/intro_to_shaders_water_workshop.rst:37
#, fuzzy
msgid ""
"Download the intro to shaders project here to follow along: :download:"
"`2d_water_shader.zip <files/2d_water_shader.zip>`."
msgstr ""
"下载到着色器项目: :download:`2d_water_shader.zip <files/2d_water_shader."
"zip>`。"

#: ../../docs/tutorials/shading/intro_to_shaders_water_workshop.rst:40
msgid ""
"It comes with a `start` folder to follow along with the 2D tutorials, and an "
"`end` folder that contains the final code."
msgstr ""
"它附带一个跟随2D教程的 `start` 文件夹，以及一个包含最终代码的 `end` 文件夹。"

#: ../../docs/tutorials/shading/intro_to_shaders_water_workshop.rst:43
#, fuzzy
msgid ""
"You will find the 3D water project on `this GitHub repository <https://"
"github.com/BastiaanOlij/shader_tutorial>`_. We didn't include it here, as it "
"is a little heavy."
msgstr ""
"您会在 `this GitHub repository <https://github.com/BastiaanOlij/"
"shader_tutorial>`_ 找到3D水项目。 我们没有在这里包含它，因为它有点大。"

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:4
msgid "Screen-reading shaders"
msgstr "屏幕阅读着色器"

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:9
#, fuzzy
msgid ""
"Very often, it is desired to make a shader that reads from the same screen "
"to which it's writing. 3D APIs, such as OpenGL or DirectX, make this very "
"difficult because of internal hardware limitations. GPUs are extremely "
"parallel, so reading and writing causes all sorts of cache and coherency "
"problems. As a result, not even the most modern hardware supports this "
"properly."
msgstr ""
"通常需要制作一个着色器，它从它写入的同一个屏幕上读取。 由于内部硬件限制，诸如"
"OpenGL或DirectX之类的3D API使这非常困难。 GPU非常平行，因此读写会导致各种缓存"
"和一致性问题。 因此，即使是最现代的硬件也不能正确支持。"

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:16
#, fuzzy
msgid ""
"The workaround is to make a copy of the screen, or a part of the screen, to "
"a back-buffer and then read from it while drawing. Godot provides a few "
"tools that make this process easy!"
msgstr ""
"解决方法是将屏幕或屏幕的一部分复制到后台缓冲区，然后在绘制时从中读取。 Godot"
"提供了一些工具，使这个过程变得简单！"

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:21
#, fuzzy
msgid "SCREEN_TEXTURE built-in texture"
msgstr "SCREEN_TEXTURE内置纹理。"

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:23
#, fuzzy
msgid ""
"Godot :ref:`doc_shading_language` has a special texture, \"SCREEN_TEXTURE"
"\" (and \"DEPTH_TEXTURE\" for depth, in the case of 3D). It takes as "
"argument the UV of the screen and returns a vec3 RGB with the color. A "
"special built-in varying: SCREEN_UV can be used to obtain the UV for the "
"current fragment. As a result, this simple 2D fragment shader:"
msgstr ""
"Godot :ref:`doc_shading_language` 有一个特殊的纹理，“SCREEN_TEXTURE”(对于深"
"度，如果是3D，则为“DEPTH_TEXTURE”)。 它将屏幕的UV作为参数，并返回带有颜色的"
"vec3 RGB。 一个特殊的内置变量:SCREEN_UV可用于获取当前片段的UV。 因此，这个简"
"单的2D片段着色器:"

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:34
msgid "results in an invisible object, because it just shows what lies behind."
msgstr "导致一个不可见的对象，因为它只是显示了背后的东西。"

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:36
msgid ""
"The reason why textureLod must be used is because, when Godot copies back a "
"chunk of the screen, it also does an efficient separatable gaussian blur to "
"its mipmaps."
msgstr ""
"之所以必须使用textureLod是因为，当Godot复制一大块屏幕时，它还会对其mipmap执行"
"有效的可分离高斯模糊。"

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:39
msgid ""
"This allows for not only reading from the screen, but reading from it with "
"different amounts of blur at no cost."
msgstr "这不仅允许从屏幕上读取，而且可以免费读取具有不同模糊量的屏幕。"

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:43
msgid "SCREEN_TEXTURE example"
msgstr "SCREEN_TEXTURE示例"

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:45
#, fuzzy
msgid ""
"SCREEN_TEXTURE can be used for many things. There is a special demo for "
"*Screen Space Shaders*, that you can download to see and learn. One example "
"is a simple shader to adjust brightness, contrast and saturation:"
msgstr ""
"SCREEN_TEXTURE可用于很多事情。 有一个 *Screen Space Shaders* 的特殊演示，您可"
"以下载查看和学习。 一个示例是一个简单的着色器来调整亮度，对比度和饱和度:"

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:69
msgid "Behind the scenes"
msgstr "在幕后"

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:71
msgid ""
"While this seems magical, it's not. The SCREEN_TEXTURE built-in, when first "
"found in a node that is about to be drawn, does a full-screen copy to a back-"
"buffer. Subsequent nodes that use it in shaders will not have the screen "
"copied for them, because this ends up being inefficient."
msgstr ""
"虽然这看起来很神奇，但事实并非如此。 内置的SCREEN_TEXTURE，当首次在即将绘制的"
"节点中找到时，会将全屏复制到后台缓冲区。 在着色器中使用它的后续节点将不会为它"
"们复制屏幕，因为这最终效率低下。"

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:77
msgid ""
"As a result, if shaders that use SCREEN_TEXTURE overlap, the second one will "
"not use the result of the first one, resulting in unexpected visuals:"
msgstr ""
"因此，如果使用SCREEN_TEXTURE的着色器重叠，则第二个着色器将不使用第一个着色器"
"的结果，从而导致意外的视觉效果:"

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:83
msgid ""
"In the above image, the second sphere (top right) is using the same source "
"for SCREEN_TEXTURE as the first one below, so the first one \"disappears\", "
"or is not visible."
msgstr ""
"在上图中，第二个球体(右上角)使用与下面第一个相同的SCREEN_TEXTURE源，因此第一"
"个“消失”或不可见。"

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:87
msgid ""
"In 3D, this is unavoidable because copying happens when opaque rendering "
"completes."
msgstr "在3D中，这是不可避免的，因为在不透明渲染完成时会发生复制。"

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:90
#, fuzzy
msgid ""
"In 2D, this can be corrected via the :ref:`BackBufferCopy "
"<class_BackBufferCopy>` node, which can be instantiated between both "
"spheres. BackBufferCopy can work by either specifying a screen region or the "
"whole screen:"
msgstr ""
"在2D中，这可以通过 :ref:`BackBufferCopy <class_BackBufferCopy>` 节点来纠正，"
"该节点可以在两个球体之间实例化。 BackBufferCopy可以通过指定屏幕区域或整个屏幕"
"来工作:"

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:96
msgid "With correct back-buffer copying, the two spheres blend correctly:"
msgstr "通过正确的后缓冲区复制，两个球体正确混合:"

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:101
msgid "Back-buffer logic"
msgstr "后缓冲逻辑"

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:103
msgid ""
"So, to make it clearer, here's how the backbuffer copying logic works in "
"Godot:"
msgstr "所以，为了更清楚，这里是backbuffer复制逻辑在Godot中的工作原理:"

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:106
#, fuzzy
msgid ""
"If a node uses the SCREEN_TEXTURE, the entire screen is copied to the back "
"buffer before drawing that node. This only happens the first time; "
"subsequent nodes do not trigger this."
msgstr ""
"如果节点使用SCREEN_TEXTURE，则在绘制该节点之前将整个屏幕复制到后台缓冲区。 这"
"仅在第一次发生，后续节点不会触发此操作。"

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:109
#, fuzzy
msgid ""
"If a BackBufferCopy node was processed before the situation in the point "
"above (even if SCREEN_TEXTURE was not used), the behavior described in the "
"point above does not happen. In other words, automatic copying of the entire "
"screen only happens if SCREEN_TEXTURE is used in a node for the first time "
"and no BackBufferCopy node (not disabled) was found before in tree-order."
msgstr ""
"如果在上述点的情况之前处理BackBufferCopy节点(即使未使用SCREEN_TEXTURE)，则上"
"述点中描述的此行为不会发生。 换句话说，只有在第一次在节点中使用SCREEN_TEXTURE"
"并且在树顺序之前没有找到BackBufferCopy节点(未禁用)时，才会自动复制整个屏幕。"

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:115
msgid ""
"BackBufferCopy can copy either the entire screen or a region. If set to only "
"a region (not the whole screen) and your shader uses pixels not in the "
"region copied, the result of that read is undefined (most likely garbage "
"from previous frames). In other words, it's possible to use BackBufferCopy "
"to copy back a region of the screen and then use SCREEN_TEXTURE on a "
"different region. Avoid this behavior!"
msgstr ""
"BackBufferCopy可以复制整个屏幕或区域。 如果仅设置为区域(不是整个屏幕)，并且着"
"色器使用不在复制区域中的像素，则该读取的结果是未定义的(很可能是前一帧中的垃"
"圾)。 换句话说，可以使用BackBufferCopy复制屏幕区域，然后在不同区域使用"
"SCREEN_TEXTURE。 避免这种行为！"

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:124
msgid "DEPTH_TEXTURE"
msgstr "DEPTH_TEXTURE"

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:126
#, fuzzy
msgid ""
"For 3D Shaders, it's also possible to access the screen depth buffer. For "
"this, the DEPTH_TEXTURE built-in is used. This texture is not linear; it "
"must be converted via the inverse projection matrix."
msgstr ""
"对于3D着色器，还可以访问屏幕深度缓冲区。 为此，使用内置的DEPTH_TEXTURE。 该纹"
"理不是线性的，必须通过逆投影矩阵进行转换。"

#: ../../docs/tutorials/shading/screen-reading_shaders.rst:130
msgid ""
"The following code retrieves the 3D position below the pixel being drawn:"
msgstr "以下代码检索正在绘制的像素下方的3D位置:"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:4
#, fuzzy
msgid "Migrating to Godot's shading language"
msgstr "迁移到Godot着色语言"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:9
msgid ""
"This document explains the differences between Godot's shading language and "
"GLSL and gives practical advice on how to migrate shaders from other "
"sources, such as Shadertoy and The Book of Shaders, into Godot shaders."
msgstr ""
"本文档解释了Godot的着色语言和GLSL之间的区别，并提供了有关如何将着色器从其他来"
"源(如Shadertoy和The Book of Shaders)迁移到Godot着色器的实用建议。"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:13
#, fuzzy
msgid ""
"For detailed information on Godot's shading language, please refer to the :"
"ref:`Shading Language <doc_shading_language>` reference."
msgstr ""
"有关Godot着色语言的详细信息，请参阅 :ref:`Shading Language "
"<doc_shading_language>` 参考。"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:17
msgid "GLSL"
msgstr "GLSL"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:19
msgid ""
"Godot uses a shading language based on GLSL with the addition of a few "
"quality-of-life features. Accordingly, most features available in GLSL are "
"available in Godot's shading language."
msgstr ""
"Godot使用基于GLSL的着色语言，增加了一些生活质量特征。 因此，GLSL中提供的大多"
"数功能都可以使用Godot的着色语言。"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:23
#, fuzzy
msgid "Shader programs"
msgstr "着色器程序"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:25
#, fuzzy
msgid ""
"In GLSL, each shader uses a separate program. You have one program for the "
"vertex shader and one for the fragment shader. In Godot, you have a single "
"shader that contains a ``vertex`` and/or a ``fragment`` function. If you "
"only choose to write one, Godot will supply the other."
msgstr ""
"在GLSL中，每个着色器使用单独的程序。 您有一个用于顶点着色器的程序和一个用于片"
"段着色器的程序。 在Godot中，您有一个着色器，它包含一个 ``vertex`` 和/或一个 "
"``fragment`` 函数。 如果您只选择写一个，Godot将提供另一个。"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:29
#, fuzzy
msgid ""
"Godot allows uniform variables and functions to be shared by defining the "
"fragment and vertex shaders in one file. In GLSL, the vertex and fragment "
"programs cannot share variables except when varyings are used."
msgstr ""
"Godot允许通过在一个文件中定义片段和顶点着色器来共享统一变量和函数。 在GLSL"
"中，顶点和片段程序不能共享变量，除非使用变量。"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:34
msgid "Vertex attributes"
msgstr "顶点属性"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:36
#, fuzzy
msgid ""
"In GLSL, you can pass in per-vertex information using attributes and have "
"the flexibility to pass in as much or as little as you want. In Godot, you "
"have a set number of input attributes, including ``VERTEX`` (position), "
"``COLOR``, ``UV``, ``UV2``, ``NORMAL``. For a complete list, see the :ref:"
"`Shading language reference <doc_shading_language>`."
msgstr ""
"在GLSL中，您可以使用属性传递每顶点信息。 在GLSL中，您可以根据需要灵活地传"
"入。 在Godot中您有一定数量的输入属性，包括 ``VERTEX`` (位置)， ``COLOR`` ，"
"``UV``， ``UV2`` ，``NORMAL``。 有关完整列表，请参阅 :ref:`着色语言参考"
"<doc_shading_language>`。"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:42
#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:98
msgid "gl_Position"
msgstr "gl_Position"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:44
#, fuzzy
msgid ""
"``gl_Position`` receives the final position of a vertex specified in the "
"vertex shader. It is specified by the user in clip space. Typically, in "
"GLSL, the model space vertex position is passed in using a vertex attribute "
"called ``position`` and you handle the conversion from model space to clip "
"space manually."
msgstr ""
"``gl_Position`` 接收顶点着色器中指定的顶点的最终位置。 它由用户在剪辑空间中指"
"定。 通常在GLSL中，使用名为“position”的顶点属性传入模型空间顶点位置，并手动处"
"理从模型空间到剪辑空间的转换。"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:49
#, fuzzy
msgid ""
"In Godot, ``VERTEX`` specifies the vertex position in model space at the "
"beginning of the ``vertex`` function. Godot also handles the final "
"conversion to clip space after the user-defined ``vertex`` function is run. "
"If you want to skip the conversion from model to view space, you can set the "
"``render_mode`` to ``skip_vertex_transform``. If you want to skip all "
"transforms, set ``render_mode`` to ``skip_vertex_transform`` and set the "
"``PROJECTION_MATRIX`` to ``mat4(1.0)`` in order to nullify the final "
"transform from view space to clip space."
msgstr ""
"在Godot ``VERTEX`` 中指定了 ``vertex`` 函数开头的模型空间中的顶点位置。 在用"
"户定义的 ``vertex`` 函数运行后，Godot还处理最终转换为剪辑空间。 如果要跳过从"
"模型到视图空间的转换，可以将 ``render_mode`` 设置为 "
"``skip_vertex_transform`` 。 如果您想跳过所有变换，将 ``render_mode`` 设置为 "
"``skip_vertex_transform`` 并将 ``PROJECTION_MATRIX`` 设置为 ``mat4(1.0)`` 以"
"使最终变换从视图空间无效到剪辑空间。"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:59
#, fuzzy
msgid ""
"Varyings are a type of variable that can be passed from the vertex shader to "
"the fragment shader. In modern GLSL (3.0 and up), varyings are defined with "
"the ``in`` and ``out`` keywords. A variable going out of the vertex shader "
"is defined with ``out`` in the vertex shader and ``in`` inside the fragment "
"shader."
msgstr ""
"变量是一种可以从顶点着色器传递到片段着色器的变量。 在现代GLSL(3.0及更高版本)"
"中，使用 ``in`` 和``out``关键字定义变化。 从顶点着色器输出的变量在顶点着色器"
"中定义为 ``out`` ，在片段着色器内定义为 ``in`` 。"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:64
#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:206
msgid "Main"
msgstr "主要"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:66
#, fuzzy
msgid ""
"In GLSL, each shader program looks like a self-contained C-style program. "
"Accordingly, the main entry point is ``main``. If you are copying a vertex "
"shader, rename ``main`` to ``vertex`` and if you are copying a fragment "
"shader, rename ``main`` to ``fragment``."
msgstr ""
"在GLSL中，每个着色器程序看起来都像是一个独立的C风格程序。 因此，主要入口点"
"是“主要”。 如果要复制顶点着色器，请将 ``main`` 重命名为 ``vertex`` ，如果要复"
"制片段着色器，请将 ``main`` 重命名为 ``fragment`` 。"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:73
msgid ""
"Godot currently does not support constants. You can fake the functionality "
"by using a uniform initialized to the value, but you will not benefit from "
"the increased speed from using a constant."
msgstr ""
"Godot目前不支持常数。 您可以使用初始化为值的统一来伪造功能，但是您不会从使用"
"常量的速度提高中受益。"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:77
msgid "Macros"
msgstr "宏"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:79
#, fuzzy
msgid ""
"In keeping with its similarity to C, GLSL lets you use macros. Commonly "
"``#define`` is used to define constants or small functions. There is no "
"straightforward way to translate defines to Godot's shading language. If it "
"is a function that is defined, then replace with a function, and if it is a "
"constant, then replace with a uniform. For other macros (``#if``, "
"``#ifdef``, etc.), there is no equivalent because they run during the pre-"
"processing stage of compilation."
msgstr ""
"为了与C的相似性，GLSL允许您使用宏。 通常 ``#define`` 用于定义常量或小函数。 "
"没有直接的方法将定义翻译成Godot的着色语言。 如果它是一个已定义的函数，则用函"
"数替换，如果它是常量，则用统一替换。 对于其他宏(``＃if``， ``#ifdef`` 等)，没"
"有等价物，因为它们在编译的预处理阶段运行。"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:88
#, fuzzy
msgid ""
"GLSL has many built-in variables that are hard-coded. These variables are "
"not uniforms, so they are not editable from the main program."
msgstr ""
"GLSL有许多内置的硬编码变量。 这些变量不是制服，因此它们不能从主程序中编辑。"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:92
#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:158
#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:218
msgid "Variable"
msgstr "变量"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:92
#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:158
#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:218
msgid "Equivalent"
msgstr "等价物"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:94
#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:220
msgid "gl_FragColor"
msgstr "gl_FragColor"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:94
#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:160
#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:220
msgid "out vec4"
msgstr "out vec4"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:94
#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:160
#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:220
msgid "COLOR"
msgstr "COLOR"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:94
#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:160
#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:220
msgid "Output color for each pixel."
msgstr "每个像素的输出颜色。"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:96
#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:222
msgid "gl_FragCoord"
msgstr "gl_FragCoord"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:96
#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:98
#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:174
#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:176
#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:222
msgid "vec4"
msgstr "vec4"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:96
#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:162
#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:222
msgid "FRAGCOORD"
msgstr "FRAGCOORD"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:96
#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:162
#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:222
#, fuzzy
msgid "For full screen quads. For smaller quads, use UV."
msgstr "适用于全屏四边形。 对于较小的四边形使用UV。"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:98
msgid "VERTEX"
msgstr "VERTEX"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:98
msgid "Position of Vertex, output from Vertex Shader."
msgstr "顶点的位置，从顶点着色器输出。"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:100
msgid "gl_PointSize"
msgstr "gl_PointSize"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:100
msgid "POINT_SIZE"
msgstr "POINT_SIZE"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:100
msgid "Size of Point primitive."
msgstr "Point原语的大小。"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:102
msgid "gl_PointCoord"
msgstr "gl_PointCoord"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:102
#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:162
#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:224
#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:228
msgid "vec2"
msgstr "vec2"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:102
msgid "POINT_COORD"
msgstr "POINT_COORD"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:102
msgid "Position on point when drawing Point primitives."
msgstr "绘制Point基元时在点上的位置。"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:104
msgid "gl_FrontFacing"
msgstr "gl_FrontFacing"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:104
msgid "FRONT_FACING"
msgstr "FRONT_FACING"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:104
msgid "True if front face of primitive."
msgstr "如果原始的正面，则为真。"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:110
#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:184
#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:232
msgid "Coordinates"
msgstr "坐标"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:112
msgid ""
"``gl_FragCoord`` in GLSL and ``FRAGCOORD`` in the Godot shading language use "
"the same coordinate system. If using UV in Godot, the y-coordinate will be "
"flipped upside down."
msgstr ""
"GLSL中的`gl_FragCoord``和Godot着色语言中的``FRAGCOORD``使用相同的坐标系。 如"
"果在Godot中使用UV，则y坐标将颠倒翻转。"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:118
#, fuzzy
msgid ""
"In GLSL, you can define the precision of a given type (float or int) at the "
"top of the shader with the ``precision`` keyword. In Godot, you can set the "
"precision of individual variables as you need by placing precision "
"qualifiers ``lowp``, ``mediump``, and ``highp`` before the type when "
"defining the variable. For more information, see the :ref:`Shading Language "
"<doc_shading_language>` reference."
msgstr ""
"在GLSL中，您可以使用 ``precision`` 关键字在着色器顶部定义给定类型(float或int)"
"的精度。 在Godot中，您可以根据需要设置单个变量的精度，方法是在定义变量时在类"
"型之前放置精度限定符 ``lowp`` ，``mediump``和``highp``。 有关更多信息，请参"
"阅 :ref:`着色语言<doc_shading_language>` 参考。"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:124
msgid "Shadertoy"
msgstr "Shadertoy"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:126
msgid ""
"`Shadertoy <https://www.shadertoy.com>`_ is a website that makes it easy to "
"write fragment shaders and create `pure magic <https://www.shadertoy.com/"
"view/4tjGRh>`_."
msgstr ""
"`Shadertoy <https://www.shadertoy.com>`_ 是一个网站，可以轻松编写片段着色器并"
"创建`纯魔术<https://www.shadertoy.com/view/4tjGRh>`_ 。"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:129
#, fuzzy
msgid ""
"Shadertoy does not give the user full control over the shader. It handles "
"all the input and uniforms and only lets the user write the fragment shader."
msgstr ""
"Shadertoy不会让用户完全控制着色器。 它只允许用户编写片段着色器。 它处理所有输"
"入和制服，只允许用户编写片段着色器。"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:133
#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:200
msgid "Types"
msgstr "类型"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:135
#, fuzzy
msgid ""
"Shadertoy uses the webgl spec, so it runs a slightly different version of "
"GLSL. However, it still has the regular types, including `Constants`_ and "
"macros."
msgstr ""
"Shadertoy使用webgl规范，因此它运行略有不同的GLSL版本。 但是，它仍然具有常规类"
"型，包括`常量`_和宏。"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:139
msgid "mainImage"
msgstr "mainImage"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:141
#, fuzzy
msgid ""
"The main point of entry to a Shadertoy shader is the ``mainImage`` function. "
"``mainImage`` has two parameters, ``fragColor`` and ``fragCoord``, which "
"correspond to ``COLOR`` and ``FRAGCOORD`` in Godot, respectively. These "
"parameters are handled automatically in Godot, so you do not need to include "
"them as parameters yourself. Anything in the ``mainImage`` function should "
"be copied into the ``fragment`` function when porting to Godot."
msgstr ""
"Shadertoy着色器的主要入口是 ``mainImage`` 函数。 ``mainImage``有两个参数， "
"``fragColor`` 和``fragCoord``，分别对应Godot中的 ``COLOR`` 和``FRAGCOORD``。 "
"这些参数在Godot中自动处理，因此您无需自己将它们作为参数包含在内。 当移植到"
"Godot时， ``mainImage`` 函数中的任何内容都应该被复制到 ``fragment`` 函数中。"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:150
msgid ""
"In order to make writing fragment shaders straightforward and easy, "
"Shadertoy handles passing a lot of helpful information from the main program "
"into the fragment shader for you. A few of these have no equivalents in "
"Godot because Godot has chosen not to make them available by default. This "
"is okay because Godot gives you the ability to make your own uniforms. For "
"variables whose equivalents are listed as \"Provide with Uniform\", the user "
"is responsible for creating that uniform themself. The description gives the "
"reader a hint about what they can pass in as a substitute."
msgstr ""
"为了使编写片段着色器简单明了，Shadertoy处理将主程序中的大量有用信息传递给片段"
"着色器。 其中一些在Godot中没有等价物，因为Godot选择不在默认情况下使它们可"
"用。 这没关系，因为Godot让您有能力制作自己的制服。 对于其等价物被列"
"为“Provide with Uniform”的变量，用户有责任自己创建该统一。 该描述为读者提供了"
"关于他们可以作为替代品传递什么的提示。"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:160
msgid "fragColor"
msgstr "fragColor"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:162
msgid "fragCoord"
msgstr "fragColor"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:164
msgid "iResolution"
msgstr "iResolution"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:164
#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:178
msgid "vec3"
msgstr "vec3"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:164
#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:224
msgid "1.0 / SCREEN_PIXEL_SIZE"
msgstr "1.0 / SCREEN_PIXEL_SIZE"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:164
#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:224
msgid "Can also pass in manually."
msgstr "也可以手动传递。"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:166
msgid "iTime"
msgstr "iTime"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:166
#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:226
msgid "TIME"
msgstr "TIME"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:166
#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:226
msgid "Time since shader started."
msgstr "着色器启动后的时间。"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:168
msgid "iTimeDelta"
msgstr "iTimeDelta"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:168
#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:170
#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:172
#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:174
#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:176
#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:228
msgid "Provide with Uniform"
msgstr "提供统一"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:168
msgid "Time to render previous frame."
msgstr "渲染前一帧的时间。"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:170
msgid "iFrame"
msgstr "iFrame"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:170
msgid "Frame number."
msgstr "帧号。"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:172
msgid "iChannelTime[4]"
msgstr "iChannelTime[4]"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:172
msgid "Time since that particular texture started."
msgstr "帧号。"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:174
msgid "iMouse"
msgstr "iMouse"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:174
#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:228
msgid "Mouse position in pixel coordinates."
msgstr "鼠标在像素坐标中的位置。"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:176
msgid "iDate"
msgstr "iDate"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:176
msgid "Current date, expressed in seconds."
msgstr "当前日期，以秒为单位表示。"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:178
msgid "iChannelResolution[4]"
msgstr "iChannelResolution[4]"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:178
msgid "1.0 / TEXTURE_PIXEL_SIZE"
msgstr "1.0 / TEXTURE_PIXEL_SIZE"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:178
msgid "Resolution of particular texture."
msgstr "特殊纹理的分辨率。"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:180
msgid "iChanneli"
msgstr "iChanneli"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:180
msgid "Sampler2D"
msgstr "Sampler2D"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:180
msgid "TEXTURE"
msgstr "TEXTURE"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:180
#, fuzzy
msgid "Godot provides only one built-in; user can make more."
msgstr "Godot只提供一个内置，用户可以做更多。"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:186
msgid ""
"``fragCoord`` behaves the same as ``gl_FragCoord`` in :ref:`GLSL "
"<glsl_coordinates>` and ``FRAGCOORD`` in Godot."
msgstr ""
"``fragCoord``的行为与``gl_FragCoord``相同 :ref:`GLSL <glsl_coordinates>` 和"
"Godot中的 ``FRAGCOORD`` 。"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:190
msgid "The Book of Shaders"
msgstr "着色之书"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:192
#, fuzzy
msgid ""
"Similar to Shadertoy, `The Book of Shaders <https://thebookofshaders.com>`_ "
"provides access to a fragment shader in the web browser, with which the user "
"may interact. The user is restricted to writing fragment shader code with a "
"set list of uniforms passed in and with no ability to add additional "
"uniforms."
msgstr ""
"与Shadertoy类似，“着色书”<https://thebookofshaders.com>`_ 提供对Web浏览器中片"
"段着色器的访问，供用户与之交互。 用户只能编写片段着色器代码，其中包含一组传入"
"的制服，并且无法添加其他制服。"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:196
msgid ""
"For further help on porting shaders to various frameworks generally, The "
"Book of Shaders provides a `page <https://thebookofshaders.com/04>`_ on "
"running shaders in various frameworks."
msgstr ""
"有关将着色器移植到各种框架的进一步帮助，The Book of Shaders在各种框架中运行着"
"色器时提供了一个“page <https://thebookofshaders.com/04>`_ 。"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:202
#, fuzzy
msgid ""
"The Book of Shaders uses the webgl spec, so it runs a slightly different "
"version of GLSL. However, it still has the regular types, including "
"`Constants`_ and macros."
msgstr ""
"The Book of Shaders使用webgl规范，因此它运行的GLSL略有不同。 但是，它仍然具有"
"常规类型，包括`常量`_和宏。"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:208
msgid ""
"The entry point for a Book of Shaders fragment shader is ``main``, just like "
"in GLSL. Everything written in a Book of Shaders ``main`` function should be "
"copied into Godot's ``fragment`` function."
msgstr ""
"Book of Shaders片段着色器的入口点是 ``main`` ，就像在GLSL中一样。 使用着色器 "
"``main`` 函数编写的所有内容都应该复制到Godot的 ``fragment`` 函数中。"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:214
msgid ""
"The Book of Shaders sticks closer to plain GLSL than Shadertoy does. It also "
"implements fewer uniforms than Shadertoy."
msgstr "着色书比Shadertoy更接近普通GLSL。 它也比Shadertoy实施更少的制服。"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:224
msgid "u_resolution"
msgstr "u_resolution"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:226
msgid "u_time"
msgstr "u_time"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:228
msgid "u_mouse"
msgstr "u_mouse"

#: ../../docs/tutorials/shading/migrating_to_godot_shader_language.rst:234
msgid ""
"The Book of Shaders uses the same coordinate system as :ref:`GLSL "
"<glsl_coordinates>`."
msgstr "Shaders使用相同的坐标系 :ref:`GLSL <glsl_coordinates>`。"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:4
msgid "Vertex displacement with shaders"
msgstr "使用着色器的顶点偏移"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:9
#, fuzzy
msgid ""
"This tutorial will teach you how to displace the vertices of a :ref:`Plane "
"Mesh<class_PlaneMesh>` inside a shader. Vertex displacement can be used for "
"a wide variety of effects, but most commonly it is used as a quick way to "
"turn a flat plane into a simple terrain. Typically this is done using a "
"heightmap, but in order to keep everything self contained, in this tutorial, "
"we will use noise in a shader. At the end of this tutorial, we will have a "
"deformed plane that looks like a miniature terrain complete with dynamic "
"lighting."
msgstr ""
"本教程将教您如何在着色器中替换 :ref:`Plane Mesh <class_PlaneMesh>` 的顶点。 "
"顶点位移可用于各种效果，但最常见的是它用作将平面转变为简单地形的快速方法。 通"
"常这是使用高度图完成的，但为了保持所有内容的自包含，在本教程中我们将使用着色"
"器中的噪声。 在本教程结束时，我们将看到一个变形的平面，看起来像一个完整的动态"
"光照的微型地形。"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:18
#, fuzzy
msgid "By reading this tutorial, you should gain a basic understanding of:"
msgstr "通过阅读本教程，您应该基本了解:"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:20
msgid "How to create and subdivide a :ref:`Plane Mesh<class_PlaneMesh>`"
msgstr "如何创建和细分 :ref:`Plane Mesh <class_PlaneMesh>`"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:21
msgid ""
"How to create and assign a material to a :ref:`Mesh<class_MeshInstance>`"
msgstr "如何创建和分配材质到 :ref:`Mesh <class_MeshInstance>`"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:22
msgid ""
"How to write a :ref:`Shader<class_Shader>` that displaces the vertices of a :"
"ref:`Mesh<class_MeshInstance>`"
msgstr ""
"如何写一个 :ref:`Shader <class_Shader>` 替换a :ref:`Mesh <class_MeshInstance>"
"的顶点"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:23
msgid ""
"How to pass values (Uniforms) into a :ref:`Shader<class_Shader>` to update "
"the :ref:`Mesh<class_MeshInstance>` in realtime"
msgstr ""
"如何将值(Uniforms)传递到 :ref:`Shader <class_Shader>` 以实时更新 :ref:`Mesh "
"<class_MeshInstance>`"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:24
msgid "How to approximate normals from a height function"
msgstr "如何从高度函数近似法线"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:25
msgid "How to use a light with a custom material"
msgstr "如何使用自定义材质的灯光"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:28
msgid "The plane mesh"
msgstr "平面网格"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:30
msgid ""
"First, add a :ref:`Spatial<class_Spatial>` node to the scene to act as the "
"root. Next, add a :ref:`MeshInstance<class_MeshInstance>` as a child."
msgstr ""
"首先，在场景中添加一个 :ref:`Spatial <class_Spatial>` 节点作为根。 接下来，添"
"加 :ref:`MeshInstance <class_MeshInstance>` 作为子节点。"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:35
msgid ""
"Select the newly created :ref:`MeshInstance<class_MeshInstance>`. Then click "
"on the button that says \"null\" next to the :ref:`Mesh<class_MeshInstance>` "
"in the Inspector. This will bring up a list of :ref:"
"`PrimitiveMeshes<class_PrimitiveMesh>`. Select \"New PlaneMesh\"."
msgstr ""
"选择新创建的 :ref:`MeshInstance <class_MeshInstance>`。 然后单击Inspector中 :"
"ref:`Mesh <class_MeshInstance>` 旁边的“null”按钮。 这将显示一个列表 :ref:"
"`PrimitiveMeshes <class_PrimitiveMesh>`。 选择“New PlaneMesh”。"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:41
msgid ""
"The button will change into a small image of a plane. Click on it to enter "
"into the Inspector for the :ref:`Plane Mesh<class_MeshInstance>`."
msgstr ""
"该按钮将变为平面的小图像。 单击它进入Inspector，进入 :ref:`Plane Mesh "
"<class_MeshInstance>`。"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:44
msgid ""
"Then, in the viewport, click in the upper left corner where it says "
"[Perspective]. A menu will appear. In the middle of the menu are options for "
"how to display the scene. Select 'Display Wireframe'."
msgstr ""
"然后，在视区中，单击左上角，显示[透视]。 将出现一个菜单。 菜单中间是如何显示"
"场景的选项。 选择“显示线框”。"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:50
msgid "This will allow you to see the triangles making up the plane."
msgstr "这将允许您查看构成平面的三角形。"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:54
msgid "Now set the ``Subdivide Width`` and ``Subdivide Height`` to ``32``."
msgstr "现在将``Subdivide Width``和``Subdivide Height``设置为``32``。"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:58
#, fuzzy
msgid ""
"You can see that there are now many more triangles in the :ref:"
"`Mesh<class_MeshInstance>`. This will give us more vertices to work with and "
"thus allow us to add more detail."
msgstr ""
"您可以看到现在有更多三角形 :ref:`Mesh <class_MeshInstance>`。 这将为我们提供"
"更多顶点，从而允许我们添加更多细节。"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:65
msgid "Shader magic"
msgstr "着色器魔术"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:67
#, fuzzy
msgid ""
"Now that we have a :ref:`Plane Mesh<class_MeshInstance>` to draw, let's set "
"up the material that will deform the :ref:`Mesh<class_MeshInstance>`."
msgstr ""
"现在我们有了一个 :ref:`Plane Mesh <class_MeshInstance>` 来绘制让我们设置将变"
"形的材质 :ref:`Mesh <class_MeshInstance>`。"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:69
msgid ""
"Click beside material in the :ref:`Plane Mesh<class_MeshInstance>` Menu and "
"create a new :ref:`ShaderMaterial<class_ShaderMaterial>`."
msgstr ""
"单击下面的材质 :ref:`Plane Mesh <class_MeshInstance>` 菜单并创建一个新的 :"
"ref:`ShaderMaterial <class_ShaderMaterial>`。"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:73
msgid "Then click on the created :ref:`ShaderMaterial<class_ShaderMaterial>`."
msgstr "然后单击created :ref:`ShaderMaterial <class_ShaderMaterial>`。"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:75
msgid ""
"Then click beside 'shader' and create a new :ref:`Shader<class_Shader>`."
msgstr "然后单击“着色器”旁边的并创建一个新的 :ref:`Shader <class_Shader>`。"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:79
msgid ""
"Click into the newly created :ref:`Shader<class_Shader>`. You should now see "
"Godot's Shader editor."
msgstr ""
"单击新创建的 :ref:`Shader <class_Shader>`。 您现在应该看看Godot的Shader编辑"
"器。"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:83
msgid ""
"Notice how it is throwing an error? This is because the shader editor "
"reloads shaders on the fly automatically. The first thing Godot shaders need "
"is a declaration of what type of shader they are. Accordingly, we set the "
"variable ``shader_type`` to ``spatial``. One more thing we will add is the "
"``render_mode``, we will set it to ``unshaded``. This means that Godot won't "
"run the light shader on this object."
msgstr ""
"注意它是如何抛出错误的？ 这是因为着色器编辑器会自动重新加载着色器。 Godot着色"
"器需要的第一件事就是声明它们是什么类型的着色器。 因此，我们将变量 "
"``shader_type`` 设置为 ``spatial`` 。 我们要添加的另一件事是 "
"``render_mode`` ，我们将它设置为 ``unshaded`` 。 这意味着Godot不会在此对象上"
"运行灯光着色器。"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:94
#, fuzzy
msgid ""
"This should remove the errors and your :ref:`Mesh<class_MeshInstance>` "
"should turn white. If you were to comment out the ``render_mode``, the plane "
"would appear blue because it would pick up the sky colors."
msgstr ""
"这应该删除错误，您的 :ref:`Mesh <class_MeshInstance>` 应该变成白色。 如果您要"
"注释掉 ``render_mode`` ，飞机会显得很蓝，因为它会拾取天空的颜色。"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:97
msgid ""
"Next we will define a vertex shader. The vertex shader determines where the "
"vertices of your :ref:`Mesh<class_MeshInstance>` appear in the final scene. "
"We will be using it to offset the height of each vertex and make our flat "
"plane appear like a little terrain."
msgstr ""
"接下来我们将定义一个顶点着色器。 顶点着色器确定最终场景中出现的地址 :ref:"
"`Mesh <class_MeshInstance>` 的顶点。 我们将使用它来偏移每个顶点的高度，并使我"
"们的平面看起来像一个小地形。"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:101
msgid "We define the vertex shader like so:"
msgstr "我们像这样定义顶点着色器:"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:109
#, fuzzy
msgid ""
"With nothing in the ``vertex`` function, Godot will use its default vertex "
"shader. We can easily start to make changes by adding a single line:"
msgstr ""
"在 ``vertex`` 函数中没有任何内容，Godot将使用其默认的顶点着色器。 我们可以通"
"过添加一行来轻松开始进行更改:"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:118
#, fuzzy
msgid "Adding this line, you should get an image like the one below."
msgstr "添加此行您应该得到如下图像。"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:122
#, fuzzy
msgid ""
"Okay, let's unpack this. The ``y`` value of the ``VERTEX`` is being "
"increased. And we are passing the ``x`` and ``z`` components of the "
"``VERTEX`` as arguments to ``cos`` and ``sin``; that gives us a wave-like "
"appearance across the ``x`` and ``z`` axes."
msgstr ""
"好吧，让我们打开它。 ``VERTEX``的``y``值正在增加。 我们传递 ``VERTEX`` 的"
"``x``和``z``组件作为 ``cos`` 和``sin``的参数，这给了我们一个横跨``x的波浪外"
"观 ``和 ``z`` 轴。"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:126
#, fuzzy
msgid ""
"What we want to achieve is the look of little hills; after all. ``cos`` and "
"``sin`` already look kind of like hills. We do so by scaling the inputs to "
"the ``cos`` and ``sin`` functions."
msgstr ""
"我们想要实现的是小山丘的外观，毕竟 ``cos`` 和``sin``看起来有点像山丘。 我们通"
"过缩放“cos``和``sin``函数的输入来实现。"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:137
msgid ""
"This looks better, but it is still too spiky. This is because ``cos`` and "
"``sin`` output values between ``-1`` and ``1``, so the range of the output "
"is much too high. We correct this by multiplying the result by ``0.5`` to "
"reduce the size."
msgstr ""
"这看起来更好，但它仍然太尖刻。 这是因为 ``cos`` 和``sin``在``-1``和````之间输"
"出值，所以输出的范围太高了。 我们通过将结果乘以“0.5”来纠正这个问题以减小大"
"小。"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:148
#, fuzzy
msgid ""
"Looks much more hilly now. But ``cos`` and ``sin`` are boring. Let's move "
"onto something more interesting."
msgstr ""
"现在看起来更加丘陵了。 但是 ``cos`` 和``sin``很无聊。 让我们进入更有趣的事"
"情。"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:151
msgid "Noise"
msgstr "噪声"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:153
#, fuzzy
msgid ""
"Noise is a very popular tool for procedural generation. Think of it as "
"similar to the cosine function where you have repeating hills except, with "
"noise, each hill has a different height. Understanding noise is not "
"necessary for this tutorial. There is nothing wrong with simply copying and "
"pasting the code below."
msgstr ""
"噪声是一种非常流行的程序生成工具。 可以认为它类似于余弦函数，除了噪音外，每个"
"山都有不同的高度。 本教程不需要了解噪声。 简单地复制和粘贴下面的代码没有任何"
"问题。"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:158
msgid ""
"The first function we use to generate the noise is the ``hash`` function. It "
"gives the random height for each of the hill tops."
msgstr "我们用来生成噪波的第一个函数是“hash”函数。它给出了每个山顶的随机高度。"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:167
#, fuzzy
msgid ""
"You will find similar functions to this all over the internet. It is "
"lovingly referred to as the 'one-liner hash function'. It works well for "
"simple noise, but there are many better alternatives floating around as "
"well. For this tutorial, it will work fine."
msgstr ""
"您将在整个互联网上找到类似的功能。 它被巧妙地称为“单线程哈希函数”。 它适用于"
"简单的噪音，但也有许多更好的替代方案。 对于本教程，它将正常工作。"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:171
#, fuzzy
msgid ""
"Next we define the ``noise`` function. It smoothly interpolates between the "
"random heights. Again, if this code seems daunting, do not worry; just copy, "
"paste and move on with the tutorial."
msgstr ""
"接下来我们定义“noise”函数。它平滑地插入到随机高度之间。同样，如果这段代码看起"
"来很吓人，不要担心，只需复制粘贴并且跟着教程继续学习。"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:185
#, fuzzy
msgid ""
"Lastly, to add detail, we combine successive layers of noise using something "
"called fractal brownian motion or FBM. Scary name aside, FBM noise just adds "
"together layers of noise with increasing frequency and decreasing amplitude. "
"To implement it, we run over a for loop where we increase the frequency each "
"level, decrease the amplitude, and calculate a new layer of noise."
msgstr ""
"最后，为了添加细节，我们使用分形布朗运动或FBM来组合连续的噪声层。 除了FBM噪声"
"之外，可怕的名称只会增加噪声层，增加频率并降低幅度。 为了实现它，我们运行for"
"循环，我们增加每个级别的频率，减小幅度，并计算新的噪声层。"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:204
msgid ""
"We can now use this noise function in place of ``cos`` and ``sin`` in the "
"previous section."
msgstr "我们现在可以使用这个噪声函数代替上一节中的 ``cos`` 和``sin``。"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:213
#, fuzzy
msgid ""
"With the noise function in place, we already have something that looks kind "
"of cool. There is a lot of detail, it kind of looks hilly or mountainous."
msgstr ""
"有了噪音功能，我们已经有了一些看起来很酷的东西。 有很多细节，有点像丘陵或山"
"区。"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:217
msgid "Fragment shader"
msgstr "片段着色器"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:219
msgid ""
"The difference between a vertex shader and a fragment shader is that the "
"vertex shader runs per vertex and sets properties such as ``VERTEX`` "
"(position) and ``NORMAL``, while the fragment shader runs per pixel and, "
"most importantly, sets the ``ALBEDO`` color of the :ref:"
"`Mesh<class_MeshInstance>`."
msgstr ""
"顶点着色器和片段着色器之间的区别在于顶点着色器每个顶点运行并设置诸"
"如“VERTEX”(位置)和“正常”的属性，而片段着色器按像素运行，最重要的是， 设置 :"
"ref:`Mesh <class_MeshInstance>` 的 ``ALBEDO`` 颜色。"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:223
#, fuzzy
msgid ""
"Now let's look at the :ref:`Mesh<class_MeshInstance>` with a regular shader "
"instead of the wireframe. Set the viewport back to 'Display Normal'."
msgstr ""
"现在让我们看一下 :ref:`Mesh <class_MeshInstance>` 用常规着色器而不是线框。 将"
"视区设置回“显示正常”。"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:228
#, fuzzy
msgid ""
"The :ref:`Mesh<class_MeshInstance>` appears completely white because the "
"fragment shader is coloring each pixel white; but if every pixel is white, "
"we lose detail on the :ref:`Mesh<class_MeshInstance>`. So let's color each "
"pixel based on the height calculated in the vertex shader. We do so by "
"setting the ``COLOR`` variable in the vertex shader. And by setting the "
"``ALBEDO`` in the fragment shader to the calculated ``COLOR`` variable."
msgstr ""
":ref:`Mesh <class_MeshInstance>` 看起来是完全白色的，因为片段着色器将每个像素"
"着色为白色，但如果每个像素都是白色，我们就会丢失详细信息 :ref:`Mesh "
"<class_MeshInstance>`。 因此，让我们根据顶点着色器中计算的高度为每个像素着"
"色。 我们通过在顶点着色器中设置 ``COLOR`` 变量来实现。 并通过将片段着色器中"
"的“ALBEDO”设置为计算的“COLOR”变量。"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:245
#, fuzzy
msgid ""
"With this change, we can see the detail of the :ref:"
"`Mesh<class_MeshInstance>`, even without displaying the :ref:"
"`Mesh<class_MeshInstance>`'s wireframe."
msgstr ""
"通过这个更改，我们可以看到 :ref:`Mesh <class_MeshInstance>` 的细节，即使没有"
"显示 :ref:`Mesh <class_MeshInstance>` 的线框。"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:252
#, fuzzy
msgid ""
"Uniform variables allow you to pass data from the game into the shader. They "
"can be very useful for controlling shader effects. Uniforms can be almost "
"any datatype that can be used in the shader. To use a uniform, you declare "
"it in your :ref:`Shader<class_Shader>` using the keyword ``uniform``."
msgstr ""
"统一变量允许您将数据从游戏传递到着色器。 它们对于控制着色器效果非常有用。 制"
"服几乎可以是着色器中可以使用的任何数据类型。 要使用制服，请使用关键字 "
"``uniform`` 在 :ref:`Shader <class_Shader>` 中声明它。"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:257
#, fuzzy
msgid "Let's make a uniform that changes the height of the terrain."
msgstr "让我们制作一个改变地形高度的制服。"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:264
#, fuzzy
msgid ""
"Godot lets you initialize a uniform with a value; here, ``height_scale`` is "
"set to ``0.5``. You can set uniforms from GDScript by calling the function "
"``set_shader_param`` on the material corresponding to the shader. The value "
"passed from GDScript takes precedence over the value used to initialize it "
"in the shader."
msgstr ""
"Godot允许您用值初始化一个制服，这里 ``height_scale`` 设置为 ``0.5`` 。 您可以"
"通过在与着色器对应的材质上调用函数 ``set_shader_param`` 来设置gdscript中的制"
"服。 从gdscript传递的值优先于用于在着色器中初始化它的值。"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:273
msgid ""
"Remember that the string passed into ``set_shader_param`` must match the "
"name of the uniform variable in the :ref:`Shader<class_Shader>`. You can use "
"the uniform variable anywhere inside your :ref:`Shader<class_Shader>`. Here, "
"we will use it to set the height value instead of arbitrarily multiplying by "
"``0.5``."
msgstr ""
"请记住，传递给 ``set_shader_param`` 的字符串必须与 :ref:`Shader "
"<class_Shader>` 中的统一变量的名称匹配。 您可以在 :ref:`Shader "
"<class_Shader>` 中的任何位置使用统一变量。 在这里，我们将使用它来设置高度值，"
"而不是任意乘以“0.5”。"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:282
msgid ""
"The terrain should look exactly the same, but now we have control over the "
"height easily. Here is the same terrain with ``height_scale`` set to ``1``:"
msgstr ""
"地形应该看起来完全一样，但现在我们可以轻松控制高度。 这里是 ``height_scale`` "
"设置为 ``1`` 的相同地形:"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:287
msgid "And here it is with ``height_scale`` set to ``0.2``:"
msgstr "在这里， ``height_scale`` 设置为``0.2``:"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:291
#, fuzzy
msgid ""
"Using uniforms, we can even change the value every frame to animate the "
"height of the terrain. Combined with :ref:`Tweens<class_Tween>`, this can be "
"especially useful for simple animations."
msgstr ""
"使用制服我们甚至可以改变每帧的值来设置地形的高度。 结合 :ref:`Tweens "
"<class_Tween>` 这对简单的动画特别有用。"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:295
msgid "Interacting with light"
msgstr "与光交互"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:297
#, fuzzy
msgid ""
"As a final part of this tutorial, let's try to set up the terrain to "
"interact with light. First, we will add an :ref:`OmniLight<class_OmniLight>` "
"to the scene."
msgstr ""
"作为本教程的最后一部分，我们尝试设置地形以与光交互。 首先，我们将向场景中添"
"加 :ref:`OmniLight <class_OmniLight>` 。"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:303
#, fuzzy
msgid ""
"You should notice that nothing changes. That is because we set the "
"``render_mode`` to ``unshaded`` at the beginning of this tutorial; let's "
"remove that."
msgstr ""
"您应该注意到没有任何变化，这是因为我们在本教程的开头将 ``render_mode`` 设置"
"为 ``unshaded`` ，让我们删除它。"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:313
#, fuzzy
msgid ""
"It looks slightly better now; you can see the light affecting the terrain, "
"and it has turned blue as a result of the sky. The problem is the light is "
"affecting the terrain as if it were a flat plane. This is because the light "
"shader uses the normals of the :ref:`Mesh<class_MeshInstance>` to calculate "
"light. The normals are stored in the :ref:`Mesh<class_MeshInstance>`, but we "
"are changing the shape of the :ref:`Mesh<class_MeshInstance>` in the shader, "
"so the normals are no longer correct. To fix this, we need to recalculate "
"the normals in the shader. Godot makes this easy for us; all we have to do "
"is calculate the new normal and set ``NORMAL`` to that value in the vertex "
"shader. With ``NORMAL`` set, Godot will do all the difficult lighting "
"calculations for us."
msgstr ""
"它现在看起来稍微好一点，您可以看到影响地形的光线，并且它因天空而变成了蓝色。 "
"问题是光线正在影响地形，好像它是一个平面。 这是因为灯光着色器使用 :ref:`Mesh "
"<class_MeshInstance>` 的法线来计算光。 法线存储在 :ref:`Mesh "
"<class_MeshInstance>` 中，但是我们正在改变着色器中的 :ref:`Mesh "
"<class_MeshInstance>` 的形状，因此法线不再正确。 要解决此问题，我们需要重新计"
"算着色器中的法线。 Godot让我们很容易，我们所要做的就是计算新法线并在顶点着色"
"器中将 ``NORMAL`` 设置为该值。 通过 ``NORMAL`` 设置，Godot将为我们完成所有困"
"难的灯光计算。"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:322
#, fuzzy
msgid ""
"To calculate the normal from noise, we are going to use a technique called "
"'central differences'. This is used a lot, especially in places like "
"Shadertoy, to calculate normals in shaders. What we will do is calculate the "
"noise at four points surrounding the vertex in the ``x`` and ``z`` "
"directions and then calculate the slope at the vertex from that. After all, "
"a normal is just an indicator of the slope of the noise."
msgstr ""
"为了从噪声中计算法线，我们将使用一种称为“中心差异”的技术。 这很常用，特别是在"
"像shadertoy这样的地方，用于计算着色器中的法线。 我们要做的是计算“x”和“z”方向"
"顶点周围四个点的噪声，然后计算顶点的斜率。 毕竟法线只是噪音斜率的指标。"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:328
msgid "We calculate the normal with one line in the vertex shader."
msgstr "我们在顶点着色器中用一条线计算法线。"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:336
msgid ""
"The variable ``e`` just makes it easier to add and subtract the right value "
"from the ``VERTEX``. Setting ``e`` to a lower number will increase the level "
"of detail of the normal."
msgstr ""
"变量 ``e`` 只是更容易从 ``VERTEX`` 中添加和减去正确的值。 将 ``e`` 设置为较低"
"的数字将增加法线的细节水平。"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:339
#, fuzzy
msgid "With ``NORMAL`` calculated, the terrain now looks like:"
msgstr "使用“NORMAL”计算地形现在看起来像:"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:343
#, fuzzy
msgid ""
"This still does not look how we want it to. The issue here is that the noise "
"changes faster than the vertices do. So when we calculate the normal at the "
"point of the ``VERTEX``, it does not align with what we see in the final :"
"ref:`Mesh<class_MeshInstance>`. In order to fix this, we add more vertices. "
"The below image is made with a :ref:`Mesh<class_MeshInstance>` with "
"``subdivision`` set to ``100``."
msgstr ""
"这看起来仍然不是我们想要的。 这里的问题是噪声变化比顶点变化得快。 因此，当我"
"们计算“VERTEX”点时的法线时，它与我们在final中看到的不一致 :ref:`Mesh "
"<class_MeshInstance>`。 为了解决这个问题，我们添加了更多顶点。 下面的图像是"
"用 :ref:`Mesh <class_MeshInstance>`， ``subdivision`` 设置为 ``100`` 。"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:351
#, fuzzy
msgid ""
"Now, we can drag the light around and the lighting will update automatically."
msgstr "现在我们可以拖动灯光，灯光会自动更新。"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:357
#, fuzzy
msgid ""
"If you zoom the camera out, you can see that the :ref:"
"`Mesh<class_MeshInstance>` now looks like a small terrain."
msgstr ""
"如果您缩小相机，您可以看到 :ref:`Mesh <class_MeshInstance>` 现在看起来像一个"
"小地形。"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:361
#, fuzzy
msgid ""
"That is everything for this tutorial. Hopefully, you now understand the "
"basics of vertex shaders in Godot. As a further exercise, try changing the "
"``height_scale`` from gdscript, try using different :ref:`Primitive "
"Meshes<class_PrimitiveMesh>`, and try making your own functions to calculate "
"``height``."
msgstr ""
"这就是本教程的一切。 希望您了解Godot的顶点着色器的基础知识。 作为进一步的练习"
"尝试从gdscript更改 ``height_scale`` ，尝试使用不同的 :ref:`Primitive Meshes "
"<class_PrimitiveMesh>`，并尝试使用自己的函数来计算 ``height`` 。"

#: ../../docs/tutorials/shading/vertex_displacement_with_shaders.rst:366
#, fuzzy
msgid ""
"For further information on how to use shaders in Godot, you should check out "
"the :ref:`doc_shading_language` page."
msgstr ""
"有关如何在Godot中使用着色器的更多信息，请查看 :ref:`doc_shading_language`页"
"面。"

#: ../../docs/tutorials/shading/advanced_postprocessing.rst:4
msgid "Advanced post-processing"
msgstr "高级后处理"

#: ../../docs/tutorials/shading/advanced_postprocessing.rst:9
msgid ""
"This tutorial describes an advanced method for post-processing in Godot. In "
"particular, it will explain how to write a post-processing shader that uses "
"the depth buffer. You should already be familiar with post-processing "
"generally and, in particular, with the methods outlined in the :ref:`custom "
"post-processing tutorial <doc_custom_postprocessing>`."
msgstr ""
"本教程描述了一种在Godot中进行后处理的高级方法。值得注意的是，它将解释如何编写"
"使用深度缓冲区的后处理着色器。您应该已经熟悉后处理，特别是使用 :ref:`custom "
"post-processing tutorial <doc_custom_postprocessing>` 中介绍的方法。"

#: ../../docs/tutorials/shading/advanced_postprocessing.rst:14
#, fuzzy
msgid ""
"In the previous post-processing tutorial, we rendered the scene to a :ref:"
"`Viewport <class_Viewport>` and then rendered the Viewport in a :ref:"
"`ViewportContainer <class_ViewportContainer>` to the main scene. One "
"limitation of this method is that we could not access the depth buffer "
"because the depth buffer is only available in spatial shaders and Viewports "
"do not maintain depth information."
msgstr ""
"在之前的后期处理教程中，我们将场景渲染为 :ref:`Viewport <class_Viewport>` 然"
"后在一个 :ref:`ViewportContainer <class_ViewportContainer>` 中将视区呈现给主"
"场景。此方法的一个限制是我们无法访问深度缓冲区，因为深度缓冲区仅在空间着色器"
"中可用，而视区不保持深度信息。"

#: ../../docs/tutorials/shading/advanced_postprocessing.rst:21
msgid "Full screen quad"
msgstr "全屏四核"

#: ../../docs/tutorials/shading/advanced_postprocessing.rst:23
#, fuzzy
msgid ""
"In the :ref:`custom post-processing tutorial <doc_custom_postprocessing>`, "
"we covered how to use a Viewport to make custom post-processing effects. "
"There are two main drawbacks of using a Viewport:"
msgstr ""
"在 :ref:`自定义后处理教程<doc_custom_postprocessing>` 中，我们介绍了如何使用"
"Viewport进行自定义后处理效果。使用Viewport有两个主要缺点:"

#: ../../docs/tutorials/shading/advanced_postprocessing.rst:27
msgid "The depth buffer cannot be accessed"
msgstr "无法访问深度缓冲区"

#: ../../docs/tutorials/shading/advanced_postprocessing.rst:28
msgid "The effect of the post-processing shader is not visible in the editor"
msgstr "在编辑器中看不到后处理着色器的效果"

#: ../../docs/tutorials/shading/advanced_postprocessing.rst:30
msgid ""
"To get around the limitation on using the depth buffer, use a :ref:"
"`MeshInstance <class_MeshInstance>` with a :ref:`QuadMesh <class_QuadMesh>` "
"primitive. This allows us to use a spatial shader and to access the depth "
"texture of the scene. Next, use a vertex shader to make the quad cover the "
"screen at all times so that the post-processing effect will be applied at "
"all times, including in the editor."
msgstr ""
"要解决使用深度缓冲区的限制，请使用 :ref:`MeshInstance <class_MeshInstance>` "
"并使用 :ref:`QuadMesh <class_QuadMesh>` 原语。这允许我们使用空间着色器并访问"
"场景的深度纹理。接下来，使用顶点着色器使四边形始终覆盖屏幕，以便始终应用后处"
"理效果，包括在编辑器中。"

#: ../../docs/tutorials/shading/advanced_postprocessing.rst:36
#, fuzzy
msgid ""
"First, create a new MeshInstance and set its mesh to a QuadMesh. This "
"creates a quad centered at position ``(0, 0, 0)`` with a width and height of "
"``1``. Set the width and height to ``2``. Right now, the quad occupies a "
"position in world space at the origin; however, we want it to move with the "
"camera so that it always covers the entire screen. To do this, we will "
"bypass the coordinate transforms that translate the vertex positions through "
"the difference coordinate spaces and treat the vertices as if they were "
"already in clip space."
msgstr ""
"首先，创建一个新的MeshInstance并将其网格设置为QuadMesh。这会创建一个以 ``(0, "
"0, 0)`` 为中心的四边形，其宽度和高度为 ``1``。将宽度和高度设置为 ``2``。现"
"在，四边形在原点的世界空间中占据一个位置，但是，我们希望它与相机一起移动，以"
"便它始终覆盖整个屏幕。为此，我们将绕过通过差异坐标空间转换顶点位置的坐标变"
"换，并将顶点视为已经在剪辑空间中。"

#: ../../docs/tutorials/shading/advanced_postprocessing.rst:44
#, fuzzy
msgid ""
"The vertex shader expects coordinates to be output in clip space, which are "
"coordinates ranging from ``-1`` at the left and bottom of the screen to "
"``1`` at the top and right of the screen. This is why the QuadMesh needs to "
"have height and width of ``2``. Godot handles the transform from model to "
"view space to clip space behind the scenes, so we need to nullify the "
"effects of Godot's transformations. We do this by setting the ``POSITION`` "
"built-in to our desired position. ``POSITION`` bypasses the built-in "
"transformations and sets the vertex position directly."
msgstr ""
"顶点着色器需要在剪辑空间中输出坐标，这些坐标的范围从屏幕左下角的 ``-1`` 到屏"
"幕顶部和右侧的 ``1``。这就是QuadMesh需要高度和宽度为 ``2`` 的原因。Godot处理"
"从模型到视图空间的变换到幕后的剪辑空间，因此我们需要消除Godot变换的效果。"

#: ../../docs/tutorials/shading/advanced_postprocessing.rst:60
#, fuzzy
msgid ""
"Even with this vertex shader, the quad keeps disappearing. This is due to "
"frustum culling, which is done on the CPU. Frustum culling uses the camera "
"matrix and the AABBs of Meshes to determine if the Mesh will be visible "
"*before* passing it to the GPU. The CPU has no knowledge of what we are "
"doing with the vertices, so it assumes the coordinates specified refer to "
"world positions, not clip space positions, which results in Godot culling "
"the quad when we turn away from the center of the scene. In order to keep "
"the quad from being culled, there are a few options:"
msgstr ""
"即使使用此顶点着色器，四边形也会不断消失。这是由于在CPU上完成的截头剔除。 "
"Frustum剔除使用相机矩阵和网格物体的AABB来确定在将网格传递到GPU之前网格是否可"
"见*。 CPU不知道我们对顶点做了什么，所以它假设指定的坐标是指世界位置，而不是剪"
"辑空间位置，这导致当我们转离场景中心时Godot剔除四边形。为了防止四边形被剔除，"
"有几个选择:"

#: ../../docs/tutorials/shading/advanced_postprocessing.rst:68
msgid ""
"Add the QuadMesh as a child to the camera, so the camera is always pointed "
"at it"
msgstr "将QuadMesh作为子节点添加到相机，因此相机始终指向它"

#: ../../docs/tutorials/shading/advanced_postprocessing.rst:69
msgid ""
"Set the Geometry property ``extra_cull_margin`` as large as possible in the "
"QuadMesh"
msgstr ""

#: ../../docs/tutorials/shading/advanced_postprocessing.rst:71
#, fuzzy
msgid ""
"The second option ensures that the quad is visible in the editor, while the "
"first option guarantees that it will still be visible even if the camera "
"moves outside the cull margin. You can also use both options."
msgstr ""
"第二个选项确保四元组在编辑器中可见。虽然第一个选项保证即使相机移出AABB也仍然"
"可见。您也可以使用这两个选项。"

#: ../../docs/tutorials/shading/advanced_postprocessing.rst:76
msgid "Depth texture"
msgstr "深度纹理"

#: ../../docs/tutorials/shading/advanced_postprocessing.rst:78
msgid ""
"To read from the depth texture, perform a texture lookup using ``texture()`` "
"and the uniform variable ``DEPTH_TEXTURE``."
msgstr ""
"要从深度纹理中读取，请使用 ``texture()`` 和统一变量 ``DEPTH_TEXTURE`` 执行纹"
"理查找。"

#: ../../docs/tutorials/shading/advanced_postprocessing.rst:85
#, fuzzy
msgid ""
"Similar to accessing the screen texture, accessing the depth texture is only "
"possible when reading from the current viewport. The depth texture cannot be "
"accessed from another viewport to which you have rendered."
msgstr ""
"与访问屏幕纹理类似，只有在从当前视区读取时才能访问深度纹理。无法从已渲染的另"
"一个视区访问深度纹理。"

#: ../../docs/tutorials/shading/advanced_postprocessing.rst:89
#, fuzzy
msgid ""
"The values returned by ``DEPTH_TEXTURE`` are between ``0`` and ``1`` and are "
"nonlinear. When displaying depth directly from the ``DEPTH_TEXTURE``, "
"everything will look almost white unless it is very close. This is because "
"the depth buffer stores objects closer to the camera using more bits than "
"those further, so most of the detail in depth buffer is found close to the "
"camera. In order to make the depth value align with world or model "
"coordinates, we need to linearise the value. When we apply the projection "
"matrix to the vertex position, the z value is made nonlinear, so to "
"linearise it, we multiply it by the inverse of the projection matrix, which "
"in Godot, is accessible with the variable ``INV_PROJECTION_MATRIX``."
msgstr ""
"``DEPTH_TEXTURE`` 返回的值介于 ``0`` 和 ``1`` 之间，并且是非线性的。当直接"
"从“DEPTH_TEXTURE”显示深度时，除非它非常接近，否则一切都会看起来几乎是白色的。"
"这是因为深度缓冲区使用比进一步更多的位来存储更靠近相机的对象，因此深度缓冲区"
"中的大部分细节都靠近相机。为了使深度值与世界或模型坐标对齐，我们需要将值线性"
"化。当我们将投影矩阵应用于顶点位置时，z值是非线性的，所以为了线性化它我们将它"
"乘以投影矩阵的倒数，在Godot中可以用变量 ``INV_PROJECTION_MATRIX`` 访问它"

#: ../../docs/tutorials/shading/advanced_postprocessing.rst:99
#, fuzzy
msgid ""
"Firstly, take the screen space coordinates and transform them into "
"normalized device coordinates (NDC). NDC run from ``-1`` to ``1``, similar "
"to clip space coordinates. Reconstruct the NDC using ``SCREEN_UV`` for the "
"``x`` and ``y`` axis, and the depth value for ``z``."
msgstr ""
"首先获取屏幕空间坐标并将其转换为标准化设备坐标(NDC)。 NDC从“-1”运行到“1”，类"
"似于剪辑空间坐标。使用 ``SCREEN_UV`` 为``x``和``y``轴重建NDC，并使用 ``z`` 的"
"深度值。"

#: ../../docs/tutorials/shading/advanced_postprocessing.rst:111
#, fuzzy
msgid ""
"Convert NDC to view space by multiplying the NDC by "
"``INV_PROJECTION_MATRIX``. Recall that view space gives positions relative "
"to the camera, so the ``z`` value will give us the distance to the point."
msgstr ""
"通过将NDC乘以 ``INV_PROJECTION_MATRIX`` 来将NDC转换为查看空间。回想一下，视图"
"空间给出了相对于相机的位置，因此 ``z`` 值将为我们提供到该点的距离。"

#: ../../docs/tutorials/shading/advanced_postprocessing.rst:124
#, fuzzy
msgid ""
"Because the camera is facing the negative ``z`` direction, the position will "
"have a negative ``z`` value. In order to get a usable depth value, we have "
"to negate ``view.z``."
msgstr ""
"因为相机面向负 ``z`` 方向，所以位置将具有负 ``z`` 值。为了获得可用的深度值，"
"我们必须否定 ``view.z`` 。"

#: ../../docs/tutorials/shading/advanced_postprocessing.rst:127
#, fuzzy
msgid ""
"The world position can be constructed from the depth buffer using the "
"following code. Note that the ``CAMERA_MATRIX`` is needed to transform the "
"position from view space into world space, so it needs to be passed to the "
"fragment shader with a varying."
msgstr ""
"可以使用以下代码从深度缓冲区构造世界位置。请注意，需要使用 ``CAMERA_MATRIX`` "
"将位置从视图空间转换为世界空间，因此需要将其传递给具有变化的片段着色器。"

#: ../../docs/tutorials/shading/advanced_postprocessing.rst:146
msgid "An optimization"
msgstr "优化"

#: ../../docs/tutorials/shading/advanced_postprocessing.rst:148
msgid ""
"You can benefit from using a single large triangle rather than using a full "
"screen quad. The reason for this is explained `here <https://michaldrobot."
"com/2014/04/01/gcn-execution-patterns-in-full-screen-passes>`_. However, the "
"benefit is quite small and only beneficial when running especially complex "
"fragment shaders."
msgstr ""
"您可以使用单个大三角形而不是使用全屏四边形。解释的原因在 `这里 <https://"
"michaldrobot.com/2014/04/01/gcn-execution-patterns-in-full-screen-"
"passes>`_ 。但是，这种好处非常小，只有在运行特别复杂的片段着色器时才有用。"

#: ../../docs/tutorials/shading/advanced_postprocessing.rst:153
msgid ""
"Set the Mesh in the MeshInstance to an :ref:`ArrayMesh <class_ArrayMesh>`. "
"An ArrayMesh is a tool that allows you to easily construct a Mesh from "
"Arrays for vertices, normals, colors, etc."
msgstr ""
"将MeshInstance中的Mesh设置为 :ref:`ArrayMesh <class_ArrayMesh>`。 ArrayMesh是"
"一个工具，允许您从顶点，法线，颜色等方便地从数组构造网格。"

#: ../../docs/tutorials/shading/advanced_postprocessing.rst:157
msgid "Now, attach a script to the MeshInstance and use the following code:"
msgstr "现在，将脚本附加到MeshInstance并使用以下代码："

#: ../../docs/tutorials/shading/advanced_postprocessing.rst:179
msgid ""
"The triangle is specified in normalized device coordinates. Recall, NDC run "
"from ``-1`` to ``1`` in both the ``x`` and ``y`` directions. This makes the "
"screen ``2`` units wide and ``2`` units tall. In order to cover the entire "
"screen with a single triangle, use a triangle that is ``4`` units wide and "
"``4`` units tall, double its height and width."
msgstr ""
"三角形在标准化设备坐标中指定。回想一下，NDC在 ``x`` 和``y``方向都从``-1``到 "
"``1`` 运行。这使得屏幕 ``2`` 单位宽， ``2`` 单位高。为了用一个三角形覆盖整个"
"屏幕，使用一个 ``4`` 单位宽和 ``4`` 单位高的三角形，高度和宽度加倍。"

#: ../../docs/tutorials/shading/advanced_postprocessing.rst:185
msgid ""
"Assign the same vertex shader from above and everything should look exactly "
"the same."
msgstr "从上面分配相同的顶点着色器，所有内容应该看起来完全相同。"

#: ../../docs/tutorials/shading/advanced_postprocessing.rst:187
msgid ""
"The one drawback to using an ArrayMesh over using a QuadMesh is that the "
"ArrayMesh is not visible in the editor because the triangle is not "
"constructed until the scene is run. To get around that, construct a single "
"triangle Mesh in a modelling program and use that in the MeshInstance "
"instead."
msgstr ""
"使用ArrayMesh而不是使用QuadMesh的一个缺点是ArrayMesh在编辑器中不可见，因为在"
"运行场景之前不会构造三角形。为了解决这个问题，在建模程序中构建一个三角形"
"Mesh，然后在MeshInstance中使用它。"

#: ../../docs/tutorials/networking/index.rst:2
msgid "Networking"
msgstr "网络"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:4
msgid "High level multiplayer"
msgstr "高级多人游戏"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:7
msgid "High level vs low level API"
msgstr "高级API vs 低级API"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:9
msgid ""
"The following explains the differences of high- and low-level networking in "
"Godot as well as some fundamentals. If you want to jump in head-first and "
"add networking to your first nodes, skip to `Initializing the network`_ "
"below. But make sure to read the rest later on!"
msgstr ""
"下面解释了Godot高级、低级网络的区别以及一些基本原理。如果您等不及了且将网络添"
"加到您的第一个节点中，请跳到下面的 `初始化网络`_  。但是请确保稍后阅读其余部"
"分!"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:11
#, fuzzy
msgid ""
"Godot always supported standard low-level networking via UDP, TCP and some "
"higher level protocols such as SSL and HTTP. These protocols are flexible "
"and can be used for almost anything. However, using them to synchronize game "
"state manually can be a large amount of work. Sometimes that work can't be "
"avoided or is worth it, for example when working with a custom server "
"implementation on the backend. But in most cases, it's worthwhile to "
"consider Godot's high-level networking API, which sacrifices some of the "
"fine-grained control of low-level networking for greater ease of use."
msgstr ""
"Godot始终支持通过UDP、TCP和一些更高级别的协议(如SSL和HTTP)进行标准的低级网络"
"连接。这些协议非常灵活，几乎可以用于任何事情。然而，使用它们来手动同步游戏状"
"态可能需要大量的工作。有时这种工作是无法避免的，或者是值得的，例如在后台使用"
"自定义服务器实现时。但在大多数情况下，考虑Godot的高级网络API是值得的，它牺牲"
"了对低级网络的一些细粒度控制，以获得更大的易用性。"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:14
msgid "This is due to the inherent limitations of the low-level protocols:"
msgstr "这是由于低级协议的固有限制:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:16
msgid ""
"TCP ensures packets will always arrive reliably and in order, but latency is "
"generally higher due to error correction. It's also quite a complex protocol "
"because it understands what a \"connection\" is, and optimizes for goals "
"that often don't suit applications like multiplayer games. Packets are "
"buffered to be sent in larger batches, trading less per-packet overhead for "
"higher latency. This can be useful for things like HTTP, but generally not "
"for games. Some of this can be configured and disabled (e.g. by disabling "
"\"Nagle's algorithm\" for the TCP connection)."
msgstr ""
"TCP确保包总是可靠地、有序地到达，但是由于错误纠正，延迟通常更高。它也是一个相"
"当复杂的协议，因为它理解什么是“连接”，并针对通常不适合多人游戏等应用程序的目"
"标进行优化。包被缓冲成更大的批发送，每包开销更少，延迟更高。这对于HTTP之类的"
"东西可能很有用，但对于游戏通常不太有用。其中一些可以配置和禁用(例如禁用TCP连"
"接的 \"Nagle's algorithm\" )。"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:18
#, fuzzy
msgid ""
"UDP is a simpler protocol, which only sends packets (and has no concept of a "
"\"connection\"). No error correction makes it pretty quick (low latency), "
"but packets may be lost along the way or received in the wrong order. Added "
"to that, the MTU (maximum packet size) for UDP is generally low (only a few "
"hundred bytes), so transmitting larger packets means splitting them, "
"reorganizing them and retrying if a part fails."
msgstr ""
"UDP是一个简单的协议，它只发送数据包(没有“连接”的概念)。没有错误纠正使其非常快"
"(低延迟)，但是包可能在过程中丢失或以错误的顺序接收。此外，UDP的MTU(最大数据包"
"大小)通常很低(只有几百字节)，因此传输更大的数据包意味着对它们进行分割、重新组"
"织它们，并在部分失败时重试。"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:23
#, fuzzy
msgid ""
"In general, TCP can be thought of as reliable, ordered, and slow; UDP as "
"unreliable, unordered and fast. Because of the large difference in "
"performance, it often makes sense to re-build the parts of TCP wanted for "
"games (optional reliability and packet order), while avoiding the unwanted "
"parts (congestion/traffic control features, Nagle's algorithm, etc). Due to "
"this, most game engines come with such an implementation, and Godot is no "
"exception."
msgstr ""
"一般来说，TCP可以被认为是可靠的、有序的和缓慢的;UDP作为不可靠，无序和快速。由"
"于性能上的巨大差异，在避免不需要的部分(拥塞/流量控制特性、Nagle算法等)的同"
"时，重新构建游戏所需的TCP部分(可选的可靠性和包顺序)通常是有意义的。正因为如"
"此，大多数游戏引擎都带有这样的实现，Godot也不例外。"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:26
#, fuzzy
msgid ""
"In summary, you can use the low-level networking API for maximum control and "
"implement everything on top of bare network protocols or use the high-level "
"API based on :ref:`SceneTree <class_SceneTree>` that does most of the heavy "
"lifting behind the scenes in a generally optimized way."
msgstr ""
"综上所述，您可以使用低级网络API来实现最大限度的控制，并在裸网络协议之上实现所"
"有功能，或者使用基于 :ref:`SceneTree <class_SceneTree>` 的高级API，后者以通常"
"优化的方式在后台完成大部分繁重的工作。"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:28
msgid ""
"Most of Godot's supported platforms offer all or most of the mentioned high- "
"and low-level networking features. As networking is always largely hardware "
"and operating system dependent, however, some features may change or not be "
"available on some target platforms. Most notably, the HTML5 platform "
"currently only offers WebSocket support and lacks some of the higher level "
"features as well as raw access to low-level protocols like TCP and UDP."
msgstr ""
"Godot支持的大多数平台都提供所有或大部分上述的高、低网络功能。但是，由于网络在"
"很大程度上依赖于硬件和操作系统，一些特性可能会改变，或者在某些目标平台上不可"
"用。最值得注意的是，HTML5平台目前只提供WebSocket支持，缺乏一些高级功能，以及"
"对TCP和UDP等低级协议的原始访问。"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:34
msgid ""
"More about TCP/IP, UDP, and networking: https://gafferongames.com/post/"
"udp_vs_tcp/"
msgstr ""
"关于TCP/IP、UDP和网络的更多信息 : https://gafferongames.com/post/udp_vs_tcp/"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:37
msgid ""
"Gaffer On Games has a lot of useful articles about networking in Games "
"(`here <https://gafferongames.com/tags/networking>`__), including the "
"comprehensive `introduction to networking models in games <https://"
"gafferongames.com/post/"
"what_every_programmer_needs_to_know_about_game_networking/>`__."
msgstr ""
"Gaffer On Games上有很多关于游戏中联网的有用文章 (`here <https://"
"gafferongames.com/tags/networking>`__), 包括综合型的 `introduction to "
"networking models in games <https://gafferongames.com/post/"
"what_every_programmer_needs_to_know_about_game_networking/>`__。"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:41
msgid ""
"If you want to use your low-level networking library of choice instead of "
"Godot's built-in networking, see here for an example: https://github.com/"
"PerduGames/gdnet3"
msgstr ""
"如果您想使用您选择的底层网络库来代替Godot的内置网络，请参阅这里的示例 : "
"https://github.com/PerduGames/gdnet3"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:45
msgid ""
"Adding networking to your game comes with some responsibility. It can make "
"your application vulnerable if done wrong and may lead to cheats or "
"exploits. It may even allow an attacker to compromise the machines your "
"application runs on and use your servers to send spam, attack others or "
"steal your users data if they play your game."
msgstr ""
"在您的游戏中加入社交网络需要承担一定的责任。如果做错了，它会使您的应用程序很"
"容易受到攻击，并可能导致欺骗或利用。它甚至可能允许攻击者破坏您的应用程序运行"
"在的机器，并使用您的服务器发送垃圾邮件，攻击其他人或窃取您的用户数据，如果他"
"们玩您的游戏。"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:50
msgid ""
"This is always the case when networking is involved and has nothing to do "
"with Godot. You can of course experiment, but when you release a networked "
"application, always take care of any possible security concerns."
msgstr ""
"当涉及到网络而与Godot无关时，情况总是如此。当然，您可以进行试验，但是在发布网"
"络应用程序时，请始终注意任何可能的安全问题。"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:55
msgid "Mid level abstraction"
msgstr "中间层的抽象"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:57
msgid ""
"Before going into how we would like to synchronize a game across the "
"network, it can be helpful to understand how the base network API for "
"synchronization works."
msgstr ""
"在讨论我们希望如何跨网络同步游戏之前，了解用于同步的基本网络API是如何工作的可"
"能会有所帮助。"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:59
msgid ""
"Godot uses a mid-level object :ref:`NetworkedMultiplayerPeer "
"<class_NetworkedMultiplayerPeer>`. This object is not meant to be created "
"directly, but is designed so that several implementations can provide it:"
msgstr ""
"Godot使用了一个中层对象 :ref:`NetworkedMultiplayerPeer "
"<class_NetworkedMultiplayerPeer>`。这个对象并不是直接创建的，而是设计成几个实"
"现可以提供它:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:64
msgid ""
"This object extends from :ref:`PacketPeer <class_PacketPeer>`, so it "
"inherits all the useful methods for serializing, sending and receiving data. "
"On top of that, it adds methods to set a peer, transfer mode, etc. It also "
"includes signals that will let you know when peers connect or disconnect."
msgstr ""
"这个对象扩展自 :ref:`PacketPeer <class_PacketPeer>`，因此它继承了所有用于序列"
"化、发送和接收数据的方法。除此之外，它还添加了设置节点、传输模式等的方法。它"
"同时还包括当节点连接或断开时将通知您的信号。"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:66
#, fuzzy
msgid ""
"This class interface can abstract most types of network layers, topologies "
"and libraries. By default, Godot provides an implementation based on ENet (:"
"ref:`NetworkedMultiplayerEnet <class_NetworkedMultiplayerENet>`), but this "
"could be used to implement mobile APIs (for adhoc WiFi, Bluetooth) or custom "
"device/console-specific networking APIs."
msgstr ""
"这个类接口可以表示大多数类型的网络层、拓扑结构和库。默认情况下，Godot提供基于"
"ENet的实现 ( :ref:`NetworkedMultiplayerEnet "
"<class_NetworkedMultiplayerENet>`),  但是这也可以用于实现手机的API(针对专用"
"WiFi、蓝牙)或自定义设备/特定的控制台的网络API。"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:69
msgid ""
"For most common cases, using this object directly is discouraged, as Godot "
"provides even higher level networking facilities. Yet it is made available "
"in case a game has specific needs for a lower level API."
msgstr ""
"大多数常见情况下，不鼓励直接使用这个对象，因为Godot提供了更高级别的网络使用。"
"只有当游戏对较低级别的API有特殊需求的情况下，才使用它。"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:73
msgid "Initializing the network"
msgstr "初始化网络"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:75
msgid ""
"The object that controls networking in Godot is the same one that controls "
"everything tree-related: :ref:`SceneTree <class_SceneTree>`."
msgstr ""
"在Godot中, 控制联网的对象与控制所有与树相关的东西的对象是相同的: :ref:"
"`SceneTree <class_SceneTree>`。"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:77
msgid ""
"To initialize high level networking, the SceneTree must be provided a "
"NetworkedMultiplayerPeer object."
msgstr ""
"为了初始化高级别网络，必须为SceneTree提供一个NetworkedMultiplayerPeer对象。"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:79
#, fuzzy
msgid ""
"To create that object, it first has to be initialized as a server or client."
msgstr "要创建该对象，必须首先将其初始化为服务器或客户端。"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:81
msgid ""
"Initializing as a server, listening on the given port, with a given maximum "
"number of peers:"
msgstr "作为服务器初始化，监听给定的端口，指定最大节点的数量:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:89
msgid "Initializing as a client, connecting to a given IP and port:"
msgstr "作为客户端初始化，连接到给定的IP和端口:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:97
msgid ""
"Note that it may make sense to store the local network peer instance on the "
"SceneTree to be able to access it later, as there currently is no "
"`get_tree().get_network_peer()`. This can be done via SceneTree's metadata "
"feature:"
msgstr ""
"注意，有必要在SceneTree上存储本地网络的节点实例, 以便以后能够访问它，因为当前"
"没有这个`get_tree().get_network_peer()` 函数。这可以通过使用SceneTree的元数据"
"特征来完成:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:104
msgid "Checking whether the tree is initialized as a server or client:"
msgstr "检查树是否被初始化为服务器或客户端:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:110
msgid "Terminating the networking feature:"
msgstr "停止联网功能:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:116
msgid ""
"(Although it may make sense to send a message first to let the other peers "
"know you're going away instead of letting the connection close or timeout, "
"depending on your game.)"
msgstr ""
"(更加合理的做法是, 首先发送消息让其他节点知道您正在离开，而不是直接让连接关闭"
"或让连接超时，但这也取决于您的游戏设计。)"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:119
msgid "Managing connections"
msgstr "管理连接"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:121
msgid ""
"Some games accept connections at any time, others during the lobby phase. "
"Godot can be requested to no longer accept connections at any point (see "
"`set_refuse_new_network_connections(bool)` and related methods on :ref:"
"`SceneTree <class_SceneTree>`). To manage who connects, Godot provides the "
"following signals in SceneTree:"
msgstr ""
"有些游戏在任何时候都可以接受连接，也有游戏只在大厅阶段接受连接。可以请求Godot"
"在任何时间点不再接受连接(参见 `set_refuse_new_network_connections(bool)`  "
"和 :ref:`SceneTree <class_SceneTree>` 的相关方法)。为了管理连接的节点，Godot"
"在SceneTree中提供了以下信号:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:124
msgid "Server and Clients:"
msgstr "服务器和客户端:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:126
msgid "`network_peer_connected(int id)`"
msgstr "`network_peer_connected(int id)`"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:127
msgid "`network_peer_disconnected(int id)`"
msgstr "`network_peer_disconnected(int id)`"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:129
#, fuzzy
msgid ""
"The above signals are called on every peer connected to the server "
"(including on the server) when a new peer connects or disconnects. Clients "
"will connect with a unique ID greater than 1, while network peer ID 1 is "
"always the server. Anything below 1 should be handled as invalid. You can "
"retrieve the ID for the local system via :ref:`SceneTree."
"get_network_unique_id() <class_SceneTree_method_get_network_unique_id>`. "
"These IDs will be useful mostly for lobby management and should generally be "
"stored, as they identify connected peers and thus players. You can also use "
"IDs to send messages only to certain peers."
msgstr ""
"当新的节点加入或断开时，上述信号会在每个连接到服务器的节点(包括在服务器上的节"
"点)中被调用。客户端将用一个大于1的唯一ID连接服务器，而服务器的网络节点ID始终"
"是1。凡低于1的ID被当作无效处理。可以通过 :ref:`SceneTree."
"get_network_unique_id() <class_SceneTree_method_get_network_unique_id>` 查看"
"本地系统的ID。这些ID主要用在大厅管理中，并且通常被存储, 因为它们可以辨别连接"
"的节点即游戏角色。您还可以使用ID号向特定的节点发送消息。"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:135
msgid "Clients:"
msgstr "客户端:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:137
msgid "`connected_to_server`"
msgstr "`connected_to_server`"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:138
msgid "`connection_failed`"
msgstr "`connection_failed`"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:139
msgid "`server_disconnected`"
msgstr "`server_disconnected`"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:141
#, fuzzy
msgid ""
"Again, all these functions are mainly useful for lobby management or for "
"adding/removing players on the fly. For these tasks, the server clearly has "
"to work as a server and you have to perform tasks manually such as sending a "
"newly connected player information about other already connected players (e."
"g. their names, stats, etc)."
msgstr ""
"再说一遍，所有这些函数主要用于大厅管理或动态添加/删除游戏角色。对于这些任务，"
"服务器显然必须作为服务器工作，并且您必须手动执行任务，例如向一个新连接的游戏"
"角色发送其他已经连接游戏角色的信息(例如，他们的姓名、统计数据等)。"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:145
msgid ""
"Lobbies can be implemented any way you want, but the most common way is to "
"use a node with the same name across scenes in all peers. Generally, an "
"autoloaded node/singleton is a great fit for this, to always have access to, "
"e.g. \"/root/lobby\"."
msgstr ""
"您可以用任何您想要的方式实现大厅，但是最常见的方式是用一个在所有游戏角色的场"
"景中具有相同名字的节点。通常，一个自动加载的节点/单例非常适合于此，这样就可以"
"在任何时候访问它，例如“/root/lobby”。"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:149
msgid "RPC"
msgstr "RPC"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:151
msgid ""
"To communicate between peers, the easiest way is to use RPCs (remote "
"procedure calls). This is implemented as a set of functions in :ref:`Node "
"<class_Node>`:"
msgstr ""
"为了在节点之间进行通信，最简单的方法是使用RPC(远程过程调用)。它是靠一组 :ref:"
"`Node <class_Node>` 的函数实现的:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:154
msgid "`rpc(\"function_name\", <optional_args>)`"
msgstr "`rpc(\"函数名\", <可选参数>)`"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:155
msgid "`rpc_id(<peer_id>,\"function_name\", <optional_args>)`"
msgstr "`rpc_id(<节点ID>,\"函数名\", <可选参数>)`"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:156
msgid "`rpc_unreliable(\"function_name\", <optional_args>)`"
msgstr "`rpc_unreliable(\"函数名\", <可选参数>)`"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:157
msgid "`rpc_unreliable_id(<peer_id>, \"function_name\", <optional_args>)`"
msgstr "`rpc_unreliable_id(<节点ID>, \"函数名\", <可选参数>)`"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:159
msgid "Synchronizing member variables is also possible:"
msgstr "同步成员变量也是可能的:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:161
msgid "`rset(\"variable\", value)`"
msgstr "`rset(\"变量\", 值)`"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:162
msgid "`rset_id(<peer_id>, \"variable\", value)`"
msgstr "`rset_id(<节点ID>, \"变量\", 值)`"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:163
msgid "`rset_unreliable(\"variable\", value)`"
msgstr "`rset_unreliable(\"变量\", 值)`"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:164
msgid "`rset_unreliable_id(<peer_id>, \"variable\", value)`"
msgstr "`rset_unreliable_id(<节点ID>, \"变量\", 值)`"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:166
msgid "Functions can be called in two fashions:"
msgstr "可以用两种方式来调用函数:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:168
msgid ""
"Reliable: the function call will arrive no matter what, but may take longer "
"because it will be re-transmitted in case of failure."
msgstr ""
"可靠的:函数调用无论如何都会到达，但是可能需要更长的时间，因为在发生故障时它将"
"被重新发送。"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:169
#, fuzzy
msgid ""
"Unreliable: if the function call does not arrive, it will not be re-"
"transmitted; but if it arrives, it will do it quickly."
msgstr ""
"不可靠的:如果函数调用没有到达，它将不会被重新发送，但如果它到达，它将很快完"
"成。"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:171
msgid ""
"In most cases, reliable is desired. Unreliable is mostly useful when "
"synchronizing object positions (sync must happen constantly, and if a packet "
"is lost, it's not that bad because a new one will eventually arrive and it "
"would likely be outdated because the object moved further in the meantime, "
"even if it was resent reliably)."
msgstr ""
"在大多数情况下，需要可靠的调用。当同步对象位置时，不可靠的调用才很有用(因为同"
"步必须持续发生，如果包丢失，这并不那么糟糕，因为新的包最终会到达；同时包很可"
"能会过时，因为对象在此期间进一步移动了，即使它被可靠地怨恨)。"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:174
#, fuzzy
msgid ""
"There is also the `get_rpc_sender_id` function in `SceneTree`, which can be "
"used to check which peer (or peer ID) sent an RPC."
msgstr ""
"`SceneTree` 中还有 `get_rpc_sender_id` 函数，这可以用来检查是哪个节点(或节点"
"ID)发送了RPC调用。"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:177
msgid "Back to lobby"
msgstr "回到大厅"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:179
msgid ""
"Let's get back to the lobby. Imagine that each player that connects to the "
"server will tell everyone about it."
msgstr ""
"让我们回到大厅。想象一下，连接到服务器的每个游戏角色都会将他的到来告诉其他每"
"一个人。"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:230
#, fuzzy
msgid ""
"You might have already noticed something different, which is the usage of "
"the `remote` keyword on the `register_player` function:"
msgstr ""
"您可能已经注意到一些不同，即 `register_player` 函数中使用 `remote` 关键字:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:236
#, fuzzy
msgid ""
"This keyword has two main uses. The first is to let Godot know that this "
"function can be called from RPC. If no keywords are added, Godot will block "
"any attempts to call functions for security. This makes security work a lot "
"easier (so a client can't call a function to delete a file on another "
"client's system)."
msgstr ""
"这个关键字有两个主要用途。第一个是让Godot知道这个函数可以从RPC调用。如果没有"
"添加关键字，出于安全考虑, Godot将阻止任何调用该函数的尝试。这使得安全工作变得"
"更加容易(因此一个客户端不能通过调用函数来删除其他客户端电脑上的文件)。"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:240
msgid ""
"The second use is to specify how the function will be called via RPC. There "
"are four different keywords:"
msgstr "第二个用途是指定如何通过RPC调用该函数。这里又有四个不同的关键字:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:242
msgid "`remote`"
msgstr "`remote`"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:243
msgid "`remotesync`"
msgstr "`remotesync`"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:244
msgid "`master`"
msgstr "`master`"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:245
msgid "`puppet`"
msgstr "`puppet`"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:247
msgid ""
"The `remote` keyword means that the `rpc()` call will go via network and "
"execute remotely."
msgstr "`remote` 关键字意味着 `rpc()` 调用将通过网络发送并远程执行。"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:249
msgid ""
"The `remotesync` keyword means that the `rpc()` call will go via network and "
"execute remotely, but will also execute locally (do a normal function call)."
msgstr ""
"`remotesync` 关键字意味着 `rpc()` 调用将通过网络发送并远程执行，但也将在本地"
"执行(执行一次普通函数调用)。"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:251
msgid ""
"The others will be explained further down. Note that you could also use the "
"`get_rpc_sender_id` function on `SceneTree` to check which peer actually "
"made the RPC call to `register_player`."
msgstr ""
"其他函数将被进一步解释。注意，还可以使用 `SceneTree` 上的 "
"`get_rpc_sender_id` 函数来检查哪个节点实际对 `register_player` 进行了RPC调"
"用。"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:254
#, fuzzy
msgid ""
"With this, lobby management should be more or less explained. Once you have "
"your game going, you will most likely want to add some extra security to "
"make sure clients don't do anything funny (just validate the info they send "
"from time to time, or before game start). For the sake of simplicity and "
"because each game will share different information, this is not shown here."
msgstr ""
"基于上面的介绍，也多多少少地解释了大厅管理。一旦您开始开发游戏，您很可能会想"
"增加一些额外的安全措施来确保客户不会做任何有趣的事情(仅仅验证他们随时发送的信"
"息，或者在游戏开始之前)。为了简单起见，并且因为每个游戏将分享不同的信息，所以"
"就不写这方面了。"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:259
msgid "Starting the game"
msgstr "开始游戏"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:261
msgid ""
"Once enough players have gathered in the lobby, the server should probably "
"start the game. This is nothing special in itself, but we'll explain a few "
"nice tricks that can be done at this point to make your life much easier."
msgstr ""
"一旦有足够的游戏角色聚集在大厅时，服务器应该开始游戏。这本身没有什么特别的，"
"但是我们将解释一些很好的技巧，这些技巧可以在这点上让您的生活更容易。"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:265
msgid "Player scenes"
msgstr "游戏角色场景"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:267
msgid ""
"In most games, each player will likely have its own scene. Remember that "
"this is a multiplayer game, so in every peer you need to instance **one "
"scene for each player connected to it**. For a 4 player game, each peer "
"needs to instance 4 player nodes."
msgstr ""
"在大多数游戏中，每个游戏角色都可能有自己的场景。请记住，这是一个多人游戏，所"
"以在每个客户端中，您需要为连接到它的每个游戏角色实例化 **一个场景** 。对于一"
"个4人游戏，每个客户端需要4个游戏角色节点实例。"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:270
#, fuzzy
msgid ""
"So, how to name such nodes? In Godot, nodes need to have a unique name. It "
"must also be relatively easy for a player to tell which node represents each "
"player ID."
msgstr ""
"那么，如何命名这些节点呢？在Godot中, 节点需要具有唯一的名称。对于游戏角色来"
"说，识别哪个节点代表哪个游戏角色ID必须相对容易。"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:273
msgid ""
"The solution is to simply name the *root nodes of the instanced player "
"scenes as their network ID*. This way, they will be the same in every peer "
"and RPC will work great! Here is an example:"
msgstr ""
"解决方案是简单地将 *实例化后的游戏角色场景的根节点命名为它的网络ID* 。这样，"
"它们在每一个客户端中都是一样的，RPC调用也会很容易！下面是一个示例:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:302
#, fuzzy
msgid ""
"Depending on when you execute pre_configure_game(), you may need to change "
"any calls to ``add_child()`` to be deferred via ``call_deferred()``, as the "
"SceneTree is locked while the scene is being created (e.g. when ``_ready()`` "
"is being called)."
msgstr ""
"根据您何时执行 pre_configure_game() ，您可能需要将任何调用更改为 "
"``add_child()`` ，以便通过 ``call_deferred()`` 推迟，因为SceneTree在场景创建"
"时被锁定(例如，当 ``_ready()`` 被调用时)。"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:306
msgid "Synchronizing game start"
msgstr "同步游戏开始"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:308
#, fuzzy
msgid ""
"Setting up players might take different amounts of time for every peer due "
"to lag, different hardware, or other reasons. To make sure the game will "
"actually start when everyone is ready, pausing the game until all players "
"are ready can be useful:"
msgstr ""
"由于延迟、不同的硬件或其他原因，设置游戏角色在每个客户端上花费的时间可能不"
"同。为了确保游戏会在每个人都准备好的时候真正开始，有必要暂停游戏直到所有的游"
"戏角色都准备好:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:317
msgid ""
"When the server gets the OK from all the peers, it can tell them to start, "
"as for example:"
msgstr "当服务器从所有客户端获得OK时，它才告诉他们开始游戏，例如:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:338
msgid "Synchronizing the game"
msgstr "同步游戏"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:340
#, fuzzy
msgid ""
"In most games, the goal of multiplayer networking is that the game runs "
"synchronized on all the peers playing it. Besides supplying an RPC and "
"remote member variable set implementation, Godot adds the concept of network "
"masters."
msgstr ""
"在多数游戏中，多人联网的目标是确保游戏在所有正在玩游戏的客户端上同步运行。除"
"了提供RPC和远程成员变量集之外，Godot还添加了网络主人的概念。"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:344
msgid "Network master"
msgstr "网络主人"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:346
msgid ""
"The network master of a node is the peer that has the ultimate authority "
"over it."
msgstr "一个节点的网络主人是对该节点具有终极权限的客户端。"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:348
#, fuzzy
msgid ""
"When not explicitly set, the network master is inherited from the parent "
"node, which if not changed, is always going to be the server (ID 1). Thus "
"the server has authority over all nodes by default."
msgstr ""
"当未显式设置时，网络主人从父节点继承，这个父节点如果未更改，则始终是服务器"
"(ID 1)。因此，默认情况下，服务器拥有所有节点的权限。"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:350
#, fuzzy
msgid ""
"The network master can be set with the function :ref:`Node."
"set_network_master(id, recursive) <class_Node_method_set_network_master>` "
"(recursive is true by default and means the network master is recursively "
"set on all child nodes of the node as well)."
msgstr ""
"可以使用函数 :ref:`Node.set_network_master(id, recursive) "
"<class_Node_method_set_network_master>` 来设置网络主人(默认情况下recursive为"
"true，这意味着在节点的所有子节点上也递归地设置了网络主人)。"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:353
#, fuzzy
msgid ""
"Checking that a specific node instance on a peer is the network master for "
"this node for all connected peers is done by calling :ref:`Node."
"is_network_master() <class_Node_method_is_network_master>`. This will return "
"true when executed on the server and false on all client peers."
msgstr ""
"通过调用 :ref:`Node.is_network_master() "
"<class_Node_method_is_network_master>` 来检查客户端上的特定节点实例是否是该节"
"点用于所有连接的客户端的网络主人。这在服务器上执行时将返回true，在所有客户端"
"上将返回false。"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:355
#, fuzzy
msgid ""
"If you have paid attention to the previous example, it's possible you "
"noticed that each peer was set to have network master authority for their "
"own player (Node) instead of the server:"
msgstr ""
"如果您已经注意了前面的示例，则可能注意到本地客户端拥有针对它自己的游戏角色的"
"网络主人权限，而不是服务器:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:375
msgid ""
"Each time this piece of code is executed on each peer, the peer makes itself "
"master on the node it controls, and all other nodes remain as puppets with "
"the server being their network master."
msgstr ""
"每当在客户端上执行这段代码时，客户端就使得它控制的节点上成为主人，同时其他所"
"有节点仍然保持为傀儡(服务器是它们的网络主人)。"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:377
msgid ""
"To clarify, here is an example of how this looks in the `bomber demo "
"<https://github.com/godotengine/godot-demo-projects/tree/master/networking/"
"multiplayer_bomber>`_:"
msgstr ""
"为了阐明这点，可以看看这个 `轰炸机演示 <https://github.com/godotengine/godot-"
"demo-projects/tree/master/networking/multiplayer_bomber>`_ :"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:384
msgid "Master and puppet keywords"
msgstr "主人和傀儡关键词"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:388
msgid ""
"The real advantage of this model is when used with the `master`/`puppet` "
"keywords in GDScript (or their equivalent in C# and Visual Script). "
"Similarly to the `remote` keyword, functions can also be tagged with them:"
msgstr ""
"该模型的真正优点是当使用GDScript中的 `master`/`puppet` 关键字(或者它们在C#和"
"Visual Script中的等价关键词)时。与 `remote` 关键字相似，可以将它们放在函数名"
"前面标记:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:391
msgid "Example bomb code:"
msgstr "炸弹代码的示例:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:399
msgid "Example player code:"
msgstr "游戏角色代码的示例:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:413
msgid ""
"In the above example, a bomb explodes somewhere (likely managed by whoever "
"is master). The bomb knows the bodies in the area, so it checks them and "
"checks that they contain an `exploded` function."
msgstr ""
"在上面的示例中，炸弹在某个地方爆炸(可能由主人来确定)。炸弹知道该地区的物体，"
"因此它检查物体并检查它们是否具有 `exploded` 函数。"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:416
msgid ""
"If they do, the bomb calls `exploded` on it. However, the `exploded` method "
"in the player has a `master` keyword. This means that only the player who is "
"master for that instance will actually get the function."
msgstr ""
"如果它们有，炸弹就会调用它们的 `exploded` 函数。然而，游戏角色中的 `master` "
"函数上有一个 `master` 关键字。这意味着，只有当游戏角色是该实例的主人时, 才能"
"实际上获得该函数。"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:419
#, fuzzy
msgid ""
"This instance, then, calls the `stun` method in the same instances of that "
"same player (but in different peers), and only those which are set as "
"puppet, making the player look stunned in all the peers (as well as the "
"current, master one)."
msgstr ""
"然后，这个实例调用在同一个游戏角色(但是在不同的客户端中)的同一实例中的 "
"`stun` 函数，并且只调用那些设置为傀儡的函数，使得该游戏角色在所有客户端(以及"
"当前的主人)中看起来被击晕。"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:422
#, fuzzy
msgid ""
"Note that you could also send the stun() message only to a specific player "
"by using rpc_id(<id>, \"exploded\", bomb_owner). This may not make much "
"sense for an area-of-effect case like the bomb, but in other cases, like "
"single target damage."
msgstr ""
"请注意，您也可以使用 rpc_id(<id>, \"exploded\", bomb_owner) 将 stun() 消息仅"
"发送到特定的游戏角色。这对于像炸弹这样的范围攻击来说可能没有多大意义，但在其"
"他情况下有意义，比如单目标伤害时。"

#: ../../docs/tutorials/networking/http_request_class.rst:4
msgid "Making HTTP requests"
msgstr "制作HTTP请求"

#: ../../docs/tutorials/networking/http_request_class.rst:6
msgid ""
"The :ref:`HTTPRequest <class_HTTPRequest>` node is the easiest way to make "
"HTTP requests in Godot. It is backed by the more low-level :ref:`HTTPClient "
"<class_HTTPClient>`, for which a tutorial is available :ref:`here "
"<doc_http_client_class>`."
msgstr ""
"在Godot中, 用 :ref:`HTTPRequest <class_HTTPRequest>` 节点发出HTTP请求是最简单"
"的方法。 它继承自更低级别的 :ref:`HTTPClient <class_HTTPClient>` ，相关的教程"
"见 :ref:`here <doc_http_client_class>`。"

#: ../../docs/tutorials/networking/http_request_class.rst:9
msgid ""
"For the sake of this example, we will create a simple UI with a button, that "
"when pressed will start the HTTP request to the specified URL."
msgstr ""
"这个示例中，我们将创建一个带有按钮的简单UI，按下该按钮时将发送对指定网址的"
"HTTP请求。"

#: ../../docs/tutorials/networking/http_request_class.rst:12
msgid "Preparing scene"
msgstr "准备场景"

#: ../../docs/tutorials/networking/http_request_class.rst:14
#, fuzzy
msgid ""
"Create a new empty scene, add a CanvasLayer as the root node and add a "
"script to it. Then add two child nodes to it: a Button and an HTTPRequest "
"node. You will need to connect the following signals to the CanvasLayer "
"script:"
msgstr ""
"创建一个新的空场景，添加CanvasLayer作为其根节点并向其添加脚本。 然后向其添加"
"两个子节点:Button和HTTPRequest节点。 您需要将以下信号连接到CanvasLayer节点的"
"脚本:"

#: ../../docs/tutorials/networking/http_request_class.rst:16
msgid "Button.pressed: When the button is pressed, we will start the request."
msgstr "Button.pressed:  按下按钮后，我们将发送请求。"

#: ../../docs/tutorials/networking/http_request_class.rst:17
msgid ""
"HTTPRequest.request_completed: When the request is completed, we will get "
"the requested data as an argument."
msgstr ""
"HTTPRequest.request_completed: 当请求完成后，我们将获取请求的数据作为参数。"

#: ../../docs/tutorials/networking/http_request_class.rst:24
msgid ""
"Below is all the code we need to make it work. The URL points to an online "
"API mocker; it returns a pre-defined JSON string, which we will then parse "
"to get access to the data."
msgstr ""
"下面是我们使其工作所需的所有代码。 该网址指向一个在线API模拟器; 它将返回一个"
"预先定义好的JSON字符串，然后我们将解析它以获取对数据的访问权限。"

#: ../../docs/tutorials/networking/http_request_class.rst:40
msgid ""
"With this, you should see ``(hello:world)`` printed on the console; hello "
"being a key, and world being a value, both of them strings."
msgstr ""
"有了这个，您应该在控制台上看到 ``(hello:world)`` ; hello是关键字，world是值，"
"两者都是字符串。"

#: ../../docs/tutorials/networking/http_request_class.rst:42
msgid ""
"For more information on parsing JSON, see the class references for :ref:"
"`JSON <class_JSON>` and :ref:`JSONParseResult <class_JSONParseResult>`."
msgstr ""
"有关解析JSON的更多信息，请参阅类型参考 :ref:`JSON <class_JSON>` 和 :ref:"
"`JSONParseResult <class_JSONParseResult>` 。"

#: ../../docs/tutorials/networking/http_request_class.rst:44
msgid ""
"Note that you may want to check whether the ``result`` equals "
"``RESULT_SUCCESS`` and whether a JSON parsing error occurred, see the JSON "
"class reference and :ref:`HTTPRequest <class_HTTPRequest>` for more."
msgstr ""
"请注意，您可能需要检查 ``result`` 是否等于 ``RESULT_SUCCESS`` 以及JSON解析错"
"误是否发生，要了解更多信息, 请参阅JSON类型参考和 :ref:`HTTPRequest "
"<class_HTTPRequest>` 。"

#: ../../docs/tutorials/networking/http_request_class.rst:46
msgid ""
"Of course, you can also set custom HTTP headers. These are given as a string "
"array, with each string containing a header in the format ``\"header: value"
"\"``. For example, to set a custom user agent (the HTTP ``user-agent`` "
"header) you could use the following:"
msgstr ""
"当然，您也可以设置自定义的HTTP头部。 它们以字符串数组的形式给出，每个字符串都"
"包含一个格式为 ``\"header: value\"`` 的头部。 例如，要设置自定义用户代理(HTTP"
"的 ``user-agent`` 头部部分)，您可以像这样使用:"

#: ../../docs/tutorials/networking/http_request_class.rst:53
#, fuzzy
msgid ""
"Please note that, for SSL/TLS encryption and thus HTTPS URLs to work, you "
"may need to take some steps as described :ref:`here <doc_ssl_certificates>`."
msgstr ""
"请注意，为可以用到SSL/TLS加密即HTTPS 格式的网址上，您可能需要额外的操作, 见 :"
"ref:`here <doc_ssl_certificates>` 。"

#: ../../docs/tutorials/networking/http_request_class.rst:55
msgid ""
"Also, when calling APIs using authorization, be aware that someone might "
"analyse and decompile your released application and thus may gain access to "
"any embedded authorization information like tokens, usernames or passwords. "
"That means it is usually not a good idea to embed things such as database "
"access credentials inside your game. Avoid providing information useful to "
"an attacker whenever possible."
msgstr ""
"此外，在使用授权调用API时，请注意有人可能会分析和反编译已发布的应用程序，因此"
"可能会访问到任何嵌入程序的授权信息，如令牌, 用户名或密码等。 这意味着在游戏中"
"嵌入诸如数据库访问凭证之类的东西通常不是一个好主意。 尽可能避免提供对攻击者有"
"用的信息。"

#: ../../docs/tutorials/networking/http_request_class.rst:59
msgid "Sending data to server"
msgstr "将数据发送到服务器"

#: ../../docs/tutorials/networking/http_request_class.rst:61
#, fuzzy
msgid ""
"Until now, we have limited ourselves to requesting data from a server. But "
"what if you need to send data to the server? Here is a common way of doing "
"it:"
msgstr ""
"到目前为止，我们仅限于从服务器请求数据。 但是，如果您需要将数据发送到服务器"
"呢？ 下面是一种常见的做法:"

#: ../../docs/tutorials/networking/http_request_class.rst:72
msgid ""
"Keep in mind that you have to wait for a request to finish before sending "
"another one. Making multiple request at once requires you to have one node "
"per request. A common strategy is to create and delete HTTPRequest nodes at "
"runtime as necessary."
msgstr ""
"请记住，在发送另一个请求之前，您必须等待请求完成。 一次发出多个请求需要每个请"
"求有一个节点。 常见的策略是在运行时根据需要创建和删除HTTPRequest节点。"

#: ../../docs/tutorials/networking/http_client_class.rst:4
msgid "HTTP client class"
msgstr "HTTP客户端类"

#: ../../docs/tutorials/networking/http_client_class.rst:6
#, fuzzy
msgid ""
":ref:`HTTPClient <class_HTTPClient>` provides low-level access to HTTP "
"communication. For a higher-level interface, you may want to take a look at :"
"ref:`HTTPRequest <class_HTTPRequest>` first, which has a tutorial available :"
"ref:`here <doc_http_request_class>`."
msgstr ""
":ref:`HTTPClient <class_HTTPClient>` 提供对HTTP通信的低级别访问。 关于更高级"
"别的接口，您可能需要先看一下 :ref:`HTTPRequest <class_HTTPRequest>` ，这儿有"
"一个教程 :ref:`here <doc_http_request_class>` 。"

#: ../../docs/tutorials/networking/http_client_class.rst:10
msgid ""
"Here's an example of using the :ref:`HTTPClient <class_HTTPClient>` class. "
"It's just a script, so it can be run by executing:"
msgstr ""
"这是使用 :ref:`HTTPClient <class_HTTPClient>` 类的示例。 它只是一个脚本，因此"
"它可以通过执行以下命令来运行:"

#: ../../docs/tutorials/networking/http_client_class.rst:17
msgid "It will connect and fetch a website."
msgstr "它将连接并获取一个网站。"

#: ../../docs/tutorials/networking/ssl_certificates.rst:4
msgid "SSL certificates"
msgstr "SSL证书"

#: ../../docs/tutorials/networking/ssl_certificates.rst:9
msgid ""
"It is often desired to use SSL connections for communications to avoid \"man "
"in the middle\" attacks. Godot has a connection wrapper, :ref:`StreamPeerSSL "
"<class_StreamPeerSSL>`, which can take a regular connection and add security "
"around it. The :ref:`HTTPClient <class_HTTPClient>` class also supports "
"HTTPS by using this same wrapper."
msgstr ""
"通常希望使用SSL连接进行通信，这可以避免“中间人”攻击。 Godot有一个连接包装器 :"
"ref:`StreamPeerSSL <class_StreamPeerSSL>` ，它可以进行更安全的连接。 :ref:"
"`HTTPClient <class_HTTPClient>` 类也通过使用相同的包装器来支持HTTPS。"

#: ../../docs/tutorials/networking/ssl_certificates.rst:16
msgid ""
"For SSL to work, certificates need to be provided. A .crt file must be "
"specified in the project settings:"
msgstr "为了使SSL工作，需要提供证书。必须在项目设置中指定.crt文件:"

#: ../../docs/tutorials/networking/ssl_certificates.rst:21
msgid ""
"This file should contain any number of public certificates in https://en."
"wikipedia.org/wiki/Privacy-enhanced_Electronic_Mail format."
msgstr ""
"此文件应包含了许多具有 https://en.wikipedia.org/wiki/Privacy-"
"enhanced_Electronic_Mail 格式的公共证书。"

#: ../../docs/tutorials/networking/ssl_certificates.rst:24
msgid ""
"Of course, remember to add .crt as filter so the exporter recognizes this "
"when exporting your project."
msgstr "当然，请记住将.crt添加为过滤器，以便导出器在导出项目时识别这一点。"

#: ../../docs/tutorials/networking/ssl_certificates.rst:29
msgid "There are two ways to obtain certificates:"
msgstr "获取证书有两种方法:"

#: ../../docs/tutorials/networking/ssl_certificates.rst:32
msgid "Approach 1: self signed cert"
msgstr "方法1:自签名证书"

#: ../../docs/tutorials/networking/ssl_certificates.rst:34
msgid ""
"The first approach is the simplest: generate a private and public key pair, "
"and put the public pair in the .crt file (again, in PEM format). The private "
"key should go to your server."
msgstr ""
"第一种方法是最简单的:生成一副私钥和公钥对，并将公钥放在.crt文件中(再说一遍，"
"是PEM格式)。 私钥应该放到您的服务器中。"

#: ../../docs/tutorials/networking/ssl_certificates.rst:38
msgid ""
"OpenSSL has `some documentation <https://raw.githubusercontent.com/openssl/"
"openssl/master/doc/HOWTO/keys.txt>`__ about this. This approach also **does "
"not require domain validation** nor requires you to spend a considerable "
"amount of money in purchasing certificates from a CA."
msgstr ""
"OpenSSL有 `一些文档 <https://raw.githubusercontent.com/openssl/openssl/"
"master/doc/HOWTO/keys.txt>`__  谈到这些。 这种方法也 **不需要域名验证** 也不"
"要求您花费现金从CA购买证书。"

#: ../../docs/tutorials/networking/ssl_certificates.rst:45
msgid "Approach 2: CA cert"
msgstr "方法2:CA证书"

#: ../../docs/tutorials/networking/ssl_certificates.rst:47
msgid ""
"The second approach consists of using a certificate authority (CA) such as "
"Verisign, Geotrust, etc. This is a more cumbersome process, but it's more "
"\"official\" and ensures your identity is clearly represented."
msgstr ""
"第二种方法借助于证书颁发机构(CA)，如Verisign，Geotrust等。这是一个更加繁琐的"
"过程，但它更加“正式”并且确保您的身份被清晰地表示。"

#: ../../docs/tutorials/networking/ssl_certificates.rst:52
#, fuzzy
msgid ""
"Unless you are working with large companies or corporations, or need to "
"connect to someone else's servers (i.e., connecting to Google or some other "
"REST API provider via HTTPS), this method is not as useful."
msgstr ""
"除非您在大型公司工作或与其合作，或者需要连接到其他人的服务器(即通过HTTPS连接"
"到Google或其他REST API提供商)，否则此方法并不实用。"

#: ../../docs/tutorials/networking/ssl_certificates.rst:56
msgid ""
"Also, when using a CA issued cert, **you must enable domain validation**, to "
"ensure the domain you are connecting to is the one intended, otherwise any "
"website can issue any certificate in the same CA and it will work."
msgstr ""
"此外，当使用CA颁发的证书时， **您必须启用域名验证** ，以确保您要连接的域名是"
"您想连接的域名，否则一个CA颁发的证书将会成功用到任意数量的网站中。"

#: ../../docs/tutorials/networking/ssl_certificates.rst:61
msgid ""
"If you are using Linux, you can use the supplied certs file, generally "
"located in:"
msgstr "如果您使用的是Linux，则可以使用系统提供的证书文件，通常位于:"

#: ../../docs/tutorials/networking/ssl_certificates.rst:68
msgid ""
"This file allows HTTPS connections to virtually any website (i.e., Google, "
"Microsoft, etc.)."
msgstr "此文件允许HTTPS连接到几乎任何网站(即Google，Microsoft等)。"

#: ../../docs/tutorials/networking/ssl_certificates.rst:71
msgid ""
"Or pick any of the more specific certificates there if you are connecting to "
"a specific one."
msgstr "或者，如果要连接到特定网站，请选择任何更加具体的证书。"

#: ../../docs/tutorials/assetlib/index.rst:2
msgid "Asset Library"
msgstr "资源馆"

#: ../../docs/tutorials/assetlib/what_is_assetlib.rst:4
msgid "About the Asset Library"
msgstr "关于资源馆"

#: ../../docs/tutorials/assetlib/what_is_assetlib.rst:6
msgid ""
"The Godot Asset Library, otherwise known as the AssetLib, is a repository of "
"user-submitted Godot addons, scripts, tools and other resources, "
"collectively referred to as assets. They're available to all Godot users for "
"download directly from within the engine, but it can also be accessed at "
"Godot's `official website <https://godotengine.org/asset-library/asset>`_."
msgstr ""
"Godot资源馆，也称为AssetLib，是用户提交的Godot插件，脚本，工具和其他资源(统称"
"为资源)的存储库。 它们可供所有Godot用户直接从引擎内下载，或从Godot的 `官方网"
"站 <https://godotengine.org/asset-library/asset>`_ 上下载。"

#: ../../docs/tutorials/assetlib/what_is_assetlib.rst:11
#, fuzzy
msgid ""
"On the surface, the Asset Library might look and function similar to asset "
"stores available for other engines, such as Unity's Asset Store, or Unreal "
"Engine's Marketplace, where you can submit both freely-available assets, as "
"well as paid, commercial ones. In addition, often times such assets are "
"distributed under non-free, proprietary licenses, limiting what you can do "
"with them."
msgstr ""
"从表面上看，资源馆的外观和功能类似于其他引擎的资源商店，例如Unity的资源商店或"
"虚幻引擎的市场，您可以在其中提交可自由使用的资源以及付费的商业资源。 此外，此"
"类资源通常在非自由的专有许可下分发，限制了您对它们的使用。"

#: ../../docs/tutorials/assetlib/what_is_assetlib.rst:17
msgid ""
"The Asset Library is different - all assets are distributed free of charge, "
"and under a host of open-source licenses (such as the MIT license, the GPL, "
"and the Boost Software License). This makes the AssetLib more similar to the "
"software repositories of a Linux distribution."
msgstr ""
"资源馆是不同的 - 所有资源都是免费分发的，并且服从多种开源许可证(例如MIT许可"
"证，GPL和Boost软件许可证)。 这使得AssetLib更类似于Linux发行版的软件存储库。"

#: ../../docs/tutorials/assetlib/what_is_assetlib.rst:21
msgid ""
"This set of pages will cover how to use the AssetLib (both from inside "
"Godot, and on the website), how you can submit your own assets, and what the "
"guidelines for submission are."
msgstr ""
"接下的内容将介绍如何使用AssetLib(从Godot引擎内部或网站上)，如何提交自己的资"
"源，以及提交指南。"

#: ../../docs/tutorials/assetlib/what_is_assetlib.rst:24
msgid ""
"Please note that the AssetLib is relatively young - it may have various pain "
"points, bugs and usability issues. As with all Godot projects, the code "
"repository is available on `GitHub <https://github.com/godotengine/godot-"
"asset-library>`_, where you can submit pull requests and issues, so please "
"do not hesitate to visit it!"
msgstr ""
"请注意，AssetLib相对年轻 - 它可能有各种不足，错误和可用性问题。 与所有Godot项"
"目一样，AssetLib的代码存储库可以在 `GitHub <https://github.com/godotengine/"
"godot-asset-library>`_ 上找到，您可以在那里提交请求和问题，请不要犹豫地访问它"
"吧！"

#: ../../docs/tutorials/assetlib/what_is_assetlib.rst:32
msgid "Can paid assets be uploaded to the asset library?"
msgstr "需要收费的资源可以上传到资源馆吗？"

#: ../../docs/tutorials/assetlib/what_is_assetlib.rst:34
#, fuzzy
msgid ""
"Not to the official one, though in the future, there might be other asset "
"libraries which allow it. That said, you are allowed to monetize and sell "
"Godot assets outside the Asset Library."
msgstr ""
"官方的资源馆不行，不过将来可能有其他的资源馆允许这样做。也就是说，您可以在资"
"源馆之外出售Godot资源。"

#: ../../docs/tutorials/assetlib/using_assetlib.rst:4
msgid "Using the AssetLib"
msgstr "使用资源馆"

#: ../../docs/tutorials/assetlib/using_assetlib.rst:7
msgid "On the website"
msgstr "在网站上"

#: ../../docs/tutorials/assetlib/using_assetlib.rst:12
msgid ""
"As mentioned before, you can access the web frontend of the AssetLib on "
"`Godot's official website <https://godotengine.org/asset-library/asset>`_, "
"and this is what it looks like when you first visit it:"
msgstr ""
"如前所述，您可以在 `Godot的官方网站 <https://godotengine.org/asset-library/"
"asset>`_ 上访问AssetLib的网页，这就是您第一次访问它时的样子:"

#: ../../docs/tutorials/assetlib/using_assetlib.rst:18
#, fuzzy
msgid ""
"At the top, you see the **header**, which takes you to various other parts "
"of the AssetLib - at the moment, it's empty, as we are not logged in."
msgstr ""
"在顶部，您会看到 **标题** ，它将您带到AssetLib的各个其他部分 - 此时它还是空"
"的，因为我们尚未登录。"

#: ../../docs/tutorials/assetlib/using_assetlib.rst:22
msgid "Searching"
msgstr "搜索"

#: ../../docs/tutorials/assetlib/using_assetlib.rst:24
msgid ""
"In the center is the **search bar + settings** section, and the **assets** "
"section below it - this lets you filter out certain kinds of assets based on "
"a host of criteria. These include the asset **category** (such as 2D tools, "
"scripts and demos), **engine version** they are intended for, **sorting "
"order** (by update date, by name, etc.) and **support level**."
msgstr ""
"在中心是 **搜索栏+设置** 部分，以及它下面的 **资源** 部分 - 这使您可以根据一"
"系列标准过滤掉某些类型的资源。 这些包括资源的 **类别** (例如2D工具，脚本和演"
"示)， **引擎版本** ， **排序** (按更新日期，按名称等)和 **支持级别** 。"

#: ../../docs/tutorials/assetlib/using_assetlib.rst:30
msgid ""
"While most other filter settings should be fairly self-explanatory, it's "
"worth going over what \"support level\" means in the Asset Library. "
"Currently there are three support levels, and each asset can belong to only "
"one."
msgstr ""
"虽然大多数其他过滤器设置是不言自明的，但值得讨论是资源馆中“支持级别”的含义。 "
"目前有三个支持级别，每个资源只能属于一个。"

#: ../../docs/tutorials/assetlib/using_assetlib.rst:34
msgid ""
"**Official** assets are created and maintained by the official Godot Engine "
"developers. Currently, these include the official engine demos, which "
"showcase how various areas of the engine work."
msgstr ""
"**官方** 资源由官方Godot Engine开发人员创建和维护。 目前，这些资源包括官方引"
"擎演示，它们展示了引擎工作的各个方面。"

#: ../../docs/tutorials/assetlib/using_assetlib.rst:38
msgid ""
"**Community** assets are submitted and maintained by the members of the "
"Godot community."
msgstr "**社区** 资源由Godot社区成员提交和维护。"

#: ../../docs/tutorials/assetlib/using_assetlib.rst:41
msgid ""
"**Testing** assets are works-in-progress, and may contain bugs and usability "
"issues. They are not recommended for use in serious projects, but you are "
"encouraged to download, test them, and submit issues to the original authors."
msgstr ""
"**测试** 资源是正在开发中的资源，可能包含错误和可用性问题。 建议不要将它们用"
"于正式的项目中，但建议您下载并测试它们从而向原作者报告问题。"

#: ../../docs/tutorials/assetlib/using_assetlib.rst:45
msgid ""
"You can mix and match any of the search filters and criteria, and upon "
"clicking the Search button, receive the list of all assets in the Library "
"that match them."
msgstr ""
"您可以混合和匹配任何搜索过滤器和条件，并在单击“搜索”按钮后，接收库中与其匹配"
"的所有资源的列表。"

#: ../../docs/tutorials/assetlib/using_assetlib.rst:50
msgid ""
"Note that the search results are not updated in real-time, so you will have "
"to re-submit the search query each time you change the query settings."
msgstr ""
"请注意，搜索结果不会实时更新，因此每次更改查询设置时都必须重新提交搜索查询。"

#: ../../docs/tutorials/assetlib/using_assetlib.rst:54
msgid "Breakdown of an asset"
msgstr "资源的细分"

#: ../../docs/tutorials/assetlib/using_assetlib.rst:56
msgid ""
"Now let's take a look at what an asset's page looks like and what it "
"contains."
msgstr "现在让我们来看看资源的页面是什么样的以及它包含的内容。"

#: ../../docs/tutorials/assetlib/using_assetlib.rst:60
msgid "Asset's thumbnail/icon."
msgstr "资源的缩略图/图标。"

#: ../../docs/tutorials/assetlib/using_assetlib.rst:61
msgid "Asset's name."
msgstr "资源的名称。"

#: ../../docs/tutorials/assetlib/using_assetlib.rst:62
msgid "Current version number of the asset."
msgstr "资源的当前版本号。"

#: ../../docs/tutorials/assetlib/using_assetlib.rst:63
msgid ""
"Asset's average rating, displayed in stars. (This is currently "
"unimplemented.)"
msgstr "资源的平均评级，以星标显示。 (目前尚未实现。)"

#: ../../docs/tutorials/assetlib/using_assetlib.rst:64
msgid "Asset's category, Godot version, and support status."
msgstr "资源类别，Godot版本和支持状态。"

#: ../../docs/tutorials/assetlib/using_assetlib.rst:65
msgid "Asset's original author/submitter."
msgstr "资源的原作者/提交者。"

#: ../../docs/tutorials/assetlib/using_assetlib.rst:66
msgid "The license the asset is distributed under."
msgstr "资源分配的许可证。"

#: ../../docs/tutorials/assetlib/using_assetlib.rst:67
msgid "The date of the asset's latest edit/update."
msgstr "资源的最新编辑/更新日期。"

#: ../../docs/tutorials/assetlib/using_assetlib.rst:68
msgid "A textual description of the asset."
msgstr "资源的文字描述。"

#: ../../docs/tutorials/assetlib/using_assetlib.rst:69
msgid "Links related to the asset (download link, file list, issue tracker)."
msgstr "与资源相关的链接(下载链接，文件列表，问题跟踪器)。"

#: ../../docs/tutorials/assetlib/using_assetlib.rst:70
msgid "A SHA-256 hash of the asset, for download validation purposes."
msgstr "资源的SHA-256哈希值，用于下载验证。"

#: ../../docs/tutorials/assetlib/using_assetlib.rst:71
msgid "Images and videos showcasing the asset."
msgstr "展示资源的图片和视频。"

#: ../../docs/tutorials/assetlib/using_assetlib.rst:74
msgid "Registering and logging in"
msgstr "注册并登录"

#: ../../docs/tutorials/assetlib/using_assetlib.rst:76
msgid ""
"In order to upload assets to the AssetLib, you need to be logged in, and to "
"do that, you need a registered user account. In the future, this may also "
"give you access to other features, such as commenting on or rating the "
"existing assets. You do *not* need to be logged in to browse and download "
"the assets."
msgstr ""
"要将资源上传到AssetLib，您需要登录，为此，您需要一个注册用户帐户。 将来，这还"
"可以让您访问其他功能，例如对现有资源评论或评级。 您 *不* 需要登录就可以浏览和"
"下载资源。"

#: ../../docs/tutorials/assetlib/using_assetlib.rst:81
msgid "The login/registration page can be accessed from the AssetLib header."
msgstr "可以从AssetLib标题部分访问登录/注册页面。"

#: ../../docs/tutorials/assetlib/using_assetlib.rst:85
msgid ""
"From here, you can register your account, which requires a valid email "
"address, a username, and a (preferably strong) password."
msgstr ""
"在这里，您可以注册您的帐户，该帐户需要有效的电子邮件地址，用户名和密码(最好是"
"强密码)。"

#: ../../docs/tutorials/assetlib/using_assetlib.rst:90
msgid "Then, you can use your username and password to log in."
msgstr "然后，您可以使用您的用户名和密码登录。"

#: ../../docs/tutorials/assetlib/using_assetlib.rst:94
#, fuzzy
msgid ""
"This will change the look of the AssetLib header. Now you get access to a "
"handful of new functions:"
msgstr "这将更改AssetLib标题部分的外观。 现在您可以访问一些新功能:"

#: ../../docs/tutorials/assetlib/using_assetlib.rst:97
msgid ""
"The feed, which shows a list of status updates on your submitted assets (and "
"possibly more in the future)."
msgstr "Feed，显示已提交资源的状态更新列表(将来可能更多)。"

#: ../../docs/tutorials/assetlib/using_assetlib.rst:98
msgid "A list of your uploaded assets."
msgstr "您上传的资源列表。"

#: ../../docs/tutorials/assetlib/using_assetlib.rst:99
msgid "The ability to submit new assets."
msgstr "提交新资源的能力。"

#: ../../docs/tutorials/assetlib/using_assetlib.rst:101
msgid "|image6|"
msgstr "|image6|"

#: ../../docs/tutorials/assetlib/using_assetlib.rst:103
#, fuzzy
msgid ""
"You can learn how to submit assets to the Library, and what the asset "
"submission guidelines are, in the next part of this tutorial, :ref:"
"`doc_uploading_to_assetlib`."
msgstr ""
"您可以在本教程的下一部分 : :ref:`doc_uploading_to_assetlib` 中学习如何向资源"
"馆提交资源以及了解资源提交指南。"

#: ../../docs/tutorials/assetlib/using_assetlib.rst:107
msgid "In the editor"
msgstr "在编辑器中"

#: ../../docs/tutorials/assetlib/using_assetlib.rst:109
msgid ""
"You can also access the AssetLib directly from Godot. It is available from "
"two places - in the Project Manager's Templates tab, and inside of a "
"project, from the workspaces list."
msgstr ""
"您也可以直接在Godot引擎中访问AssetLib。 它可以从两个位置访问- 在项目管理器"
"的“模板”选项卡中，或则在项目内部的工作区列表中。"

#: ../../docs/tutorials/assetlib/using_assetlib.rst:117
msgid ""
"Click on it, and Godot will fetch info about the assets from the AssetLib. "
"Once it's finished, you will see a window similar to what the AssetLib "
"website looks like, with some differences:"
msgstr ""
"单击它，Godot将从AssetLib获取有关资源的信息。 一旦完成，您将看到一个类似于"
"AssetLib网站的窗口，但有一些不同之处:"

#: ../../docs/tutorials/assetlib/using_assetlib.rst:123
msgid ""
"Similarly to the web version of the AssetLib, here you can search for assets "
"by category, name, and sort them by factors such as name or edit date."
msgstr ""
"与AssetLib的网页版本类似，您可以在此处按类别，名称搜索资源，并按名称或编辑日"
"期等因素对其进行排序。"

#: ../../docs/tutorials/assetlib/using_assetlib.rst:126
msgid ""
"Notably, you can only fetch assets for the current version of Godot you are "
"running. Also, you can only download Projects, Demos and Templates from the "
"Project Manager view of the AssetLib, while Addons (tools, scripts, "
"materials etc.) can only be downloaded from the in-project AssetLib. In "
"addition, unlike when using the web frontend, the search results are updated "
"in real-time (you do not have to press Search after every change to your "
"search query for the changes to take place)."
msgstr ""
"值得注意的是，您只能获取当前正在运行的Godot版本的资源。 此外，您只能从"
"AssetLib的项目管理器视图中下载项目，演示和模板，而插件(工具，脚本，材质等)只"
"能从项目内的AssetLib下载。 此外，与使用网页前端不同的是，搜索结果会实时更新"
"(您不必在每次更改搜索查询后再按搜索)。"

#: ../../docs/tutorials/assetlib/using_assetlib.rst:134
msgid ""
"In the future, you will be able to choose a different AssetLib provider to "
"fetch assets from (using the Site dropdown menu), however currently only the "
"official `Godot website <https://godotengine.org>`_ version of the AssetLib "
"is supported, as well as the version that may be running on your local "
"machine's web server (the localhost option)."
msgstr ""
"将来，您将能够选择一个不同的AssetLib提供程序来获取资源(使用Site的下拉菜单)，"
"但是目前只支持官方的 `Godot网站 <https://godotengine.org>`_ 版本的AssetLib ，"
"和可能在本地Web服务器上运行的资源馆(见localhost选项)。"

#: ../../docs/tutorials/assetlib/using_assetlib.rst:140
msgid "When you click on an asset, you will see more information about it."
msgstr "单击资源时，您将看到有关它的更多信息。"

#: ../../docs/tutorials/assetlib/using_assetlib.rst:144
msgid ""
"If you click on the Install button, Godot will fetch an archive of the "
"asset, and will track download progress of it at the bottom of the editor "
"window. If the download fails, you can retry it using the Retry button."
msgstr ""
"如果单击Install按钮，Godot引擎将下载资源的压缩包，并将在编辑器窗口的底部显示"
"它的下载进度。 如果下载失败，您可以使用Retry按钮重试。"

#: ../../docs/tutorials/assetlib/using_assetlib.rst:150
msgid ""
"When it finishes, you can proceed to install it using the Install button. "
"This will bring up the Package Installer window."
msgstr ""
"完成后，您可以使用Install按钮继续安装它。 这将打开Package Installer窗口。"

#: ../../docs/tutorials/assetlib/using_assetlib.rst:155
msgid ""
"Here you can see a list of all the files that will be installed. You can "
"tick off any of the files that you do not wish to install, and Godot will "
"also inform you about any problems with files that it cannot install. These "
"files will be shown in red, and hovering over them will show you a message "
"stating why it cannot be installed."
msgstr ""
"在这里，您可以看到将要安装的所有文件的列表。 您可以勾选您不想安装的任何文件，"
"Godot引擎也会告知您无法安装的文件的任何问题。 这些文件将以红色显示，将鼠标悬"
"停在它们上方会显示一条消息，说明无法安装的原因。"

#: ../../docs/tutorials/assetlib/using_assetlib.rst:163
msgid ""
"Once you are done, you can press the Install button, which will unzip all "
"the files in the archive, and import any assets contained therein, such as "
"images or 3D models. Once this is done, you should see a message stating "
"that the Package installation is complete."
msgstr ""
"完成后，您可以按Install按钮，该按钮将解压缩存档中的所有文件，并导入其中包含的"
"所有资源，例如图像或3D模型。 完成此操作后，您应该会看到一条消息，指出Package"
"安装已完成。"

#: ../../docs/tutorials/assetlib/using_assetlib.rst:170
msgid ""
"You may also use the Import button to import asset archives obtained "
"elsewhere (such as downloading them directly from the AssetLib web "
"frontend), which will take you through the same package installation "
"procedure as with the assets downloaded directly via Godot that we just "
"covered."
msgstr ""
"您还可以使用Import按钮导入在其他位置获取的资源压缩包(例如直接从AssetLib 网页"
"前端下载的)，这将引导您完成与我们刚刚通过Godot引擎实现的程序包安装过程。"

#: ../../docs/tutorials/assetlib/uploading_to_assetlib.rst:4
msgid "Submitting to the Asset Library"
msgstr "提交资源到资源馆"

#: ../../docs/tutorials/assetlib/uploading_to_assetlib.rst:9
#, fuzzy
msgid ""
"This tutorial aims to serve as a guide on how you can submit your own assets "
"to the Godot Asset Library and share them with the Godot community."
msgstr "本教程旨在指导您如何向Godot资源馆提交自己的资源并与Godot社区共享它们。"

#: ../../docs/tutorials/assetlib/uploading_to_assetlib.rst:12
msgid ""
"As mentioned in the :ref:`doc_using_assetlib` document, in order to be able "
"to submit assets to the AssetLib, you need to have a registered account, and "
"be logged in."
msgstr ""
"正如 :ref:`doc_using_assetlib` 文档中提到的，为了能够向AssetLib提交资源，您需"
"要有一个注册的帐户，并且需要登录。"

#: ../../docs/tutorials/assetlib/uploading_to_assetlib.rst:17
msgid "Submitting"
msgstr "提交"

#: ../../docs/tutorials/assetlib/uploading_to_assetlib.rst:19
msgid ""
"Once you are logged in, you will be able to head over to the \"Submit Assets"
"\" page of the AssetLib, which will look like this:"
msgstr "一旦您登录，您将能够转到AssetLib的“提交资源”页面，该页面如下所示:"

#: ../../docs/tutorials/assetlib/uploading_to_assetlib.rst:24
msgid ""
"While it may look like a lot (and there is more as you scroll down), each "
"field is described in terms of what you should put in. We will nonetheless "
"go over what is required in the submission form here as well."
msgstr ""
"虽然它可能看起来很多(并且向下滚动时会显示更多)，每个字段都是根据您应该放入的"
"内容进行描述的。但是，我们仍坚持在这里将提交表单中所需的内容详细阐述一遍。"

#: ../../docs/tutorials/assetlib/uploading_to_assetlib.rst:29
msgid "**Asset Name**:"
msgstr "**资源的名称**:"

#: ../../docs/tutorials/assetlib/uploading_to_assetlib.rst:29
msgid ""
"The name of your asset. Should be a unique, descriptive title of what your "
"asset is."
msgstr "您的资源名称。 应该是您资源的特有描述性标题。"

#: ../../docs/tutorials/assetlib/uploading_to_assetlib.rst:35
msgid "**Category**:"
msgstr "**分类**:"

#: ../../docs/tutorials/assetlib/uploading_to_assetlib.rst:32
msgid ""
"The category that your asset belongs to, and will be shown in search "
"results. The category is split into **Addons** and **Projects**. In-editor, "
"assets of the Project type (Templates, Demos, Projects) only show up when "
"viewing the AssetLib from the Project Manager, while assets of the Addon "
"type will only be visible from inside a project."
msgstr ""
"您的资源所属的类别，并将显示在搜索结果中。 该类别分为 **插件** 和 **项目"
"** 。 在编辑器中，项目类型(模板，演示，项目)的资源将显示在项目管理器的"
"AssetLib中，而插件类型的资源仅显示在项目内部中。"

#: ../../docs/tutorials/assetlib/uploading_to_assetlib.rst:41
msgid "**Godot version**:"
msgstr "**Godot 版本**:"

#: ../../docs/tutorials/assetlib/uploading_to_assetlib.rst:38
#, fuzzy
msgid ""
"The version of the engine that the asset works with. Currently, it's not "
"possible to have a single asset entry contain downloads for multiple engine "
"versions, so you may need to re-submit the asset multiple times, with an "
"entry for each Godot version it supports. This is particularly important "
"when dealing with major versions of the engine, such as Godot 2.x and Godot "
"3.x."
msgstr ""
"资源使用的引擎版本。 目前，单个资源条目不可能包含多个引擎版本的下载，因此您可"
"能需要多次重新提交资源，并为其支持的每个Godot版本添加一个条目。 这在处理引擎"
"的主要版本时尤其重要，例如Godot 2.x和Godot 3.x."

#: ../../docs/tutorials/assetlib/uploading_to_assetlib.rst:48
msgid "**Version**:"
msgstr "**版本**:"

#: ../../docs/tutorials/assetlib/uploading_to_assetlib.rst:44
msgid ""
"The version number of the asset. While you are free to choose and use any "
"versioning scheme that you like, you may want to look into something such as "
"`SemVer <https://semver.org>`_ if you want your asset's versioning scheme to "
"be clear and consistent. Note that there is also an internal version number, "
"incremented every time the asset download URL is changed or updated."
msgstr ""
"资源的版本号。 虽然您可以自由选择和使用您喜欢的任何版本控制方案，但如果您希望"
"资源的版本控制方案清晰且一致，您可能需要查看诸如 `SemVer <https://semver."
"org>`_ 之类的内容。 请注意，系统内还有一个内部版本号，每次更改或更新资源下载"
"地址时都会增加。"

#: ../../docs/tutorials/assetlib/uploading_to_assetlib.rst:53
msgid "**Repository host**:"
msgstr "**存储库主机**:"

#: ../../docs/tutorials/assetlib/uploading_to_assetlib.rst:51
#, fuzzy
msgid ""
"Assets uploaded to the AssetLib are not hosted on it directly. Instead, they "
"point to repositories hosted on third-party Git providers, such as GitHub, "
"GitLab or Bitbucket. This is where you choose which provider your asset "
"uses, so the site can compute the final download link."
msgstr ""
"上传到AssetLib的资源不直接托管在资源馆上。 相反，他们指向第三方Git提供商(如"
"GitHub，GitLab或Bitbucket)上的托管存储库。 您可以在此处选择资源使用的提供商，"
"以便网站可以计算最终下载链接。"

#: ../../docs/tutorials/assetlib/uploading_to_assetlib.rst:56
msgid "**Repository URL**:"
msgstr "**存储库地址**:"

#: ../../docs/tutorials/assetlib/uploading_to_assetlib.rst:56
msgid ""
"The URL to your asset's files/webpage. This will vary based on your choice "
"of provider, but it should look similar to `https://github.com/<user>/"
"<project>`."
msgstr ""
"资源文件/网页的地址。 这将根据您选择的提供商而有所不同，但它的结构类似于 "
"`https://github.com/<user>/<project>`。"

#: ../../docs/tutorials/assetlib/uploading_to_assetlib.rst:61
msgid "**Issues URL**:"
msgstr "**问题地址**:"

#: ../../docs/tutorials/assetlib/uploading_to_assetlib.rst:59
msgid ""
"The URL to your asset's issue tracker. Again, this will differ from "
"repository host to repository host, but will likely look similar to `https://"
"github.com/<user>/<project>/issues`. You may leave this field empty if you "
"use your provider's issue tracker, and it's part of the same repository."
msgstr ""
"资源问题跟踪器的地址。 同样，这将不同于存储库主机，但结构类似于 `https://"
"github.com/<user>/<project>/issues`。 如果您使用提供商的问题跟踪器，则可以将"
"此字段留空，因为它是资源存储库的一部分。"

#: ../../docs/tutorials/assetlib/uploading_to_assetlib.rst:65
msgid "**Download Commit/Tag**:"
msgstr "**下载提交/标记**:"

#: ../../docs/tutorials/assetlib/uploading_to_assetlib.rst:64
msgid ""
"The commit or tag of the asset. For example, "
"`b1d3172f89b86e52465a74f63a74ac84c491d3e1` or `v1.0`. The site computes the "
"actual download URL from this."
msgstr ""
"资源的提交或标记。 例如， `b1d3172f89b86e52465a74f63a74ac84c491d3e1` 或 "
"`v1.0` 。 资源馆网站根据此计算出实际下载地址。"

#: ../../docs/tutorials/assetlib/uploading_to_assetlib.rst:69
msgid "**Icon URL**:"
msgstr "**图标地址**:"

#: ../../docs/tutorials/assetlib/uploading_to_assetlib.rst:68
msgid ""
"The URL to your asset's icon (which will be used as a thumbnail in the "
"AssetLib search results and on the asset's page). Should be an image in "
"either the PNG or JPG format."
msgstr ""
"资源图标的地址(将在AssetLib搜索结果和资源页面中用作缩略图)。 应该是PNG或JPG格"
"式的图像。"

#: ../../docs/tutorials/assetlib/uploading_to_assetlib.rst:74
msgid "**License**:"
msgstr "**许可证**:"

#: ../../docs/tutorials/assetlib/uploading_to_assetlib.rst:72
msgid ""
"The license under which you are distributing the asset. The list includes a "
"variety of free and open-source software licenses, such as GPL (v2 and v3), "
"MIT, BSD and Boost Software License. You can visit `OpenSource.org <https://"
"opensource.org>`_ for a detailed description of each of the listed licenses."
msgstr ""
"您分发资源的许可证。 该列表包括各种免费和开源软件许可证，例如GPL(v2和v3)，"
"MIT，BSD和Boost软件许可证。 您可以访问 `OpenSource.org <https://opensource."
"org>`_ 获取每个列出的许可证的详细说明。"

#: ../../docs/tutorials/assetlib/uploading_to_assetlib.rst:80
msgid "**Description**:"
msgstr "**描述**:"

#: ../../docs/tutorials/assetlib/uploading_to_assetlib.rst:77
msgid ""
"Finally, you can use the Description field for a textual overview of your "
"asset, its features and behavior, a changelog, et cetera. In the future, "
"formatting with Markdown will be supported, but currently, your only option "
"is plain text."
msgstr ""
"最后，您可以使用Description字段来查看资源，其功能和行为，更改日志等文本概"
"述。 将来，将支持使用Markdown格式，但目前只支持纯文本。"

#: ../../docs/tutorials/assetlib/uploading_to_assetlib.rst:82
msgid ""
"You may also include up to three video and/or image previews, which will be "
"shown at the bottom of the asset page. Use the \"Enable\" checkbox on each "
"of the preview submission boxes to enable them."
msgstr ""
"您还可以包含最多三个视频和/或图像预览，这些预览将显示在资源页面的底部。 请使"
"用每个预览提交框上的“启用”复选框从而启用它们。"

#: ../../docs/tutorials/assetlib/uploading_to_assetlib.rst:86
msgid "**Type**:"
msgstr "**类型**:"

#: ../../docs/tutorials/assetlib/uploading_to_assetlib.rst:87
msgid "Either an image, or a video."
msgstr "图像或视频。"

#: ../../docs/tutorials/assetlib/uploading_to_assetlib.rst:88
msgid "**Image/YouTube URL**:"
msgstr "**图片/ YouTube的网址**:"

#: ../../docs/tutorials/assetlib/uploading_to_assetlib.rst:89
msgid "Either a link to the image, or to a video, hosted on YouTube."
msgstr "YouTube上托管的图片或视频链接。"

#: ../../docs/tutorials/assetlib/uploading_to_assetlib.rst:93
msgid "**Thumbnail URL**:"
msgstr "**缩略图地址**:"

#: ../../docs/tutorials/assetlib/uploading_to_assetlib.rst:91
#, fuzzy
msgid ""
"A URL to an image that will be used as a thumbnail for the preview. This "
"option will be removed eventually, and thumbnails will be automatically "
"computed instead."
msgstr ""
"图像的地址，将用作预览的缩略图。 此选项最终将被删除，相反缩略图将会被自动计算"
"出。"

#: ../../docs/tutorials/assetlib/uploading_to_assetlib.rst:95
msgid ""
"Once you are done, hit Submit. Your asset will be entered into the pending "
"queue, which you can visit on the AssetLib `here <https://godotengine.org/"
"asset-library/asset/edit?&asset=-1>`_ . The approval process is manual and "
"may take up to a few days for your addon to be accepted (or rejected), so "
"please be patient! You will be informed when your asset is reviewed. If it "
"was rejected, you will be told why that may have been, and you will be able "
"to submit it again with the appropriate changes. You may have some luck "
"accelerating the approval process by messaging the moderators/assetlib "
"reviewers on IRC (the #godotengine-atelier channel on Freenode), or the "
"official Discord server."
msgstr ""
"完成后，点击提交。 您的资源将被输入到待处理队列中，您可以在AssetLib上访问 `此"
"处 <https://godotengine.org/asset-library/asset/edit?&asset=-1>`_ 。 审批流程"
"是手动的，可能需要几天的时间才能接受(或拒绝)您的插件，所以请耐心等待！ 审核您"
"的资源时会通知您。 如果它被拒绝，您将被告知为什么会这样，并且您将能够通过适当"
"的更改再次提交。 您可以通过向IRC(Freenode上的 #godotengine-atelier 频道)或官"
"方Discord服务器的版主/ assetlib审稿人发送消息来加快审批流程。"

#: ../../docs/tutorials/assetlib/uploading_to_assetlib.rst:106
msgid "Submission guidelines"
msgstr "提交指南"

#: ../../docs/tutorials/assetlib/uploading_to_assetlib.rst:108
msgid "[TODO]"
msgstr "[开发中]"

#: ../../docs/tutorials/vr/vr_primer.rst:4
msgid "AR/VR primer"
msgstr "AR / VR示例"

#: ../../docs/tutorials/vr/vr_primer.rst:6
msgid ""
"This tutorial gives you a springboard into the world of AR and VR in the "
"Godot game engine."
msgstr "本教程为您提供了迈向Godot游戏引擎中AR和VR世界的跳板。"

#: ../../docs/tutorials/vr/vr_primer.rst:8
#, fuzzy
msgid ""
"A new architecture was introduced in Godot 3 called the AR/VR Server. On top "
"of this architecture, specific implementations are available as interfaces, "
"most of which are plugins based on GDNative. This tutorial focuses purely on "
"the core elements abstracted by the core architecture. This architecture has "
"enough features for you to create an entire VR experience that can then be "
"deployed for various interfaces. However, each platform often has some "
"unique features that are impossible to abstract. Such features will be "
"documented on the relevant interfaces and fall outside of the scope of this "
"primer."
msgstr ""
"在Godot 3中引入了一种称为AR / VR Server的新架构。 在此体系结构之上，特定的实"
"现可用作接口，其中大多数是基于GDNative的插件。 本教程仅关注核心架构抽象的核心"
"元素。 此体系结构具有足够的功能，您可以创建整个VR体验，然后可以为各种界面进行"
"部署。 但是，每个平台通常都有一些不可能抽象的独特功能。 这些特征将记录在相关"
"界面上，并且不属于本入门手册的范围。"

#: ../../docs/tutorials/vr/vr_primer.rst:12
msgid "AR/VR server"
msgstr "AR / VR服务器"

#: ../../docs/tutorials/vr/vr_primer.rst:14
#, fuzzy
msgid ""
"When Godot starts, each available interface will make itself known to the AR/"
"VR server. GDNative interfaces are setup as singletons; as long as they are "
"added to the list of GDNative singletons in your project, they will make "
"themselves known to the server."
msgstr ""
"当Godot启动时，每个可用的接口将使自己为AR / VR服务器所知。 GDNative接口设置为"
"单例，只要它们被添加到项目中的GDNative单例列表中，它们就会让服务器知道它们。"

#: ../../docs/tutorials/vr/vr_primer.rst:16
#, fuzzy
msgid ""
"You can use the function :ref:`get_interfaces() "
"<class_ARVRServer_method_get_interfaces>` to return a list of available "
"interfaces, but for this tutorial, we're going to use the :ref:`native "
"mobile VR interface <class_MobileVRInterface>` in our examples. This "
"interface is a straightforward implementation that uses the 3DOF sensors on "
"your phone for orientation and outputs a stereoscopic image to the screen. "
"It is also available in the Godot core and outputs to screen on desktop, "
"which makes it ideal for prototyping or a tutorial such as this one."
msgstr ""
"您可以使用函数 :ref:`get_interfaces <class_ARVRServer_get_interfaces>` 返回可"
"用接口列表，但在本教程中，我们将在示例中使用 :ref:`native mobile VR "
"interface <class_MobileVRInterface>` 。 此界面是一种简单的实现，它使用手机上"
"的3DOF传感器进行定位并将立体图像输出到屏幕。 它也可以在Godot核心中使用，并输"
"出到桌面上的屏幕，这使其成为原型设计或此类教程的理想选择。"

#: ../../docs/tutorials/vr/vr_primer.rst:18
#, fuzzy
msgid "To enable an interface, you execute the following code:"
msgstr "要启用界面，请执行以下代码:"

#: ../../docs/tutorials/vr/vr_primer.rst:35
#, fuzzy
msgid ""
"This code finds the interface we wish to use, initializes it and, if that is "
"successful, binds the main viewport to the interface. This last step gives "
"some control over the viewport to the interface, which automatically enables "
"things like stereoscopic rendering on the viewport."
msgstr ""
"此代码找到我们希望使用的界面，对其进行初始化，如果成功，则将主视区绑定到界"
"面。 最后一步是对视区的一些控制，它可以自动启用视区上的立体渲染。"

#: ../../docs/tutorials/vr/vr_primer.rst:37
#, fuzzy
msgid ""
"For our mobile VR interface, and any interface where the main input is "
"directly displayed on screen, the main viewport needs to be the viewport "
"where arvr is set to true. But for interfaces that render on an externally "
"attached device, you can use a secondary viewport. In the latter case, a "
"viewport that shows its output on screen will show an undistorted version of "
"the left eye, while showing the fully processed stereoscopic output on the "
"device."
msgstr ""
"对于我们的移动vr界面，以及主要输入直接显示在屏幕上的任何界面，主视区需要是"
"arvr设置为true的视区。 但是对于在外部连接设备上呈现的界面，您可以使用辅助视"
"区。 在后一种情况下，在屏幕上显示其输出的视区将显示左眼的未失真版本，同时在设"
"备上显示完全处理的立体输出。"

#: ../../docs/tutorials/vr/vr_primer.rst:39
#, fuzzy
msgid ""
"Finally, you should only initialize an interface once; switching scenes and "
"reinitializing interfaces will just introduce a lot of overhead. If you want "
"to turn the headset off temporarily, just disable the viewport or set arvr "
"to false on the viewport. In most scenarios though, you wouldn't disable the "
"headset once you're in VR, this can be disconcerting to the gamer."
msgstr ""
"最后您应该只初始化一次界面，切换场景和重新初始化界面只会引入很多开销。 如果要"
"暂时关闭耳机，只需禁用视区或在视区上将arvr设置为false。 在大多数情况下，虽然"
"您在VR中不会禁用耳机，但这可能会让游戏游戏角色感到不安。"

#: ../../docs/tutorials/vr/vr_primer.rst:42
msgid "New AR/VR nodes"
msgstr "新的AR / VR节点"

#: ../../docs/tutorials/vr/vr_primer.rst:44
msgid ""
"Three new node types have been added for supporting AR and VR in Godot and "
"one additional node type especially for AR. These are:"
msgstr ""
"添加了三种新节点类型，用于支持Godot中的AR和VR，以及一种额外的节点类型，尤其是"
"AR。 这些是:"

#: ../../docs/tutorials/vr/vr_primer.rst:46
msgid ":ref:`ARVROrigin <class_ARVROrigin>` - our origin point in the world"
msgstr ":ref:`ARVROrigin <class_ARVROrigin>` - 我们在世界上的起源点"

#: ../../docs/tutorials/vr/vr_primer.rst:47
#, fuzzy
msgid ""
":ref:`ARVRCamera <class_ARVRCamera>` - a special subclass of the camera, "
"which is positionally tracked"
msgstr ":ref:`ARVRCamera <class_ARVRCamera>` - 位置跟踪的摄像机的特殊子类"

#: ../../docs/tutorials/vr/vr_primer.rst:48
#, fuzzy
msgid ""
":ref:`ARVRController <class_ARVRController>` - a new spatial class, which "
"tracks the location of a controller"
msgstr ""
":ref:`ARVRController <class_ARVRController>` - 一个轨道控制器位置的新空间类"

#: ../../docs/tutorials/vr/vr_primer.rst:49
msgid ""
":ref:`ARVRAnchor <class_ARVRAnchor>` - an anchor point for an AR "
"implementation mapping a real world location into your virtual world"
msgstr ""
":ref:`ARVRAnchor <class_ARVRAnchor>` - AR实现的一个定位点，将真实世界的位置映"
"射到您的虚拟世界"

#: ../../docs/tutorials/vr/vr_primer.rst:51
msgid ""
"The first two must exist in your scene for AR/VR to work and this tutorial "
"focuses purely on them."
msgstr "前两个必须存在于场景中，AR / VR才能工作，本教程仅关注它们。"

#: ../../docs/tutorials/vr/vr_primer.rst:53
#, fuzzy
msgid ""
":ref:`ARVROrigin <class_ARVROrigin>` is an important node, you must have one "
"and only one of these somewhere in your scene. This node maps the center of "
"your real world tracking space to a location in your virtual world. "
"Everything else is positionally tracked in relation to this point. Where "
"this point lies exactly differs from one implementation to another, but the "
"best example to understand how this node works is to take a look at a room "
"scale location. While we have functions to adjust the point to center it on "
"the player by default, the origin point will be the center location of the "
"room you are in. As you physically walk around the room, the location of the "
"HMD is tracked in relation to this center position and the tracking is "
"mirror in the virtual world."
msgstr ""
":ref:`ARVROrigin <class_ARVROrigin>` 是一个重要的节点，您必须在场景中的某个地"
"方只有一个节点。 此节点将您的真实世界跟踪空间的中心映射到虚拟世界中的某个位"
"置。 其他所有内容都与这一点进行了位置跟踪。 这一点与一个实现完全不同，但理解"
"该节点如何工作的最佳示例是查看房间比例位置。 虽然我们有调整点的功能，但默认情"
"况下，原点将是您所在房间的中心位置。当您在房间内走动时，HMD的位置会相对于该中"
"心进行跟踪 位置和跟踪在虚拟世界中是镜像。"

#: ../../docs/tutorials/vr/vr_primer.rst:55
#, fuzzy
msgid ""
"To keep things simple, when you physically move around your room, the ARVR "
"Origin point stays where it is, the position of the camera and controllers "
"will be adjusted according to your movements. When you move through the "
"virtual world, either through controller input or when you implement a "
"teleport system, it is the position of the origin point which you will have "
"to adjust."
msgstr ""
"为了简单起见，当您在房间内移动时，ARVR Origin点保持原样，相机和控制器的位置将"
"根据您的移动进行调整。 当您在虚拟世界中移动时，无论是通过控制器输入还是实施传"
"送系统，它都是您必须调整位置的原点。"

#: ../../docs/tutorials/vr/vr_primer.rst:58
#, fuzzy
msgid ""
":ref:`ARVRCamera <class_ARVRCamera>` is the second node that must always be "
"a part of your scene and it must always be a child node of your origin node. "
"It is a subclass of Godot's normal camera. However, its position is "
"automatically updated each frame based on the physical orientation and "
"position of the HMD. Also due to the precision required for rendering to an "
"HMD or rendering an AR overlay over a real world camera, most of the "
"standard camera properties are ignored. The only properties of the camera "
"that are used are the near and far plane settings. The FOV, aspect ratio and "
"projection mode are all ignored."
msgstr ""
":ref:`ARVRCamera <class_ARVRCamera>` 是第二个必须始终作为场景一部分的节点，它"
"必须始终是原始节点的子节点。 它是Godot普通相机的子类。 然而，其位置基于HMD的"
"物理定向和位置每帧自动更新。 此外，由于渲染到HMD或在真实世界相机上渲染AR覆盖"
"所需的精度，大多数标准相机属性都被忽略。 使用的相机的唯一属性是近平面和远平面"
"设置。 FOV，宽高比和投影模式都被忽略。"

#: ../../docs/tutorials/vr/vr_primer.rst:60
#, fuzzy
msgid ""
"Note that, for our native mobile VR implementation, there is no positional "
"tracking, only the orientation of the phone and by extension, the HMD is "
"tracked. This implementation artificially places the camera at a height (Y) "
"of 1.85."
msgstr ""
"请注意，对于我们的原生移动VR实施，没有位置跟踪，只跟踪电话的方向和扩展HMD。 "
"该实现人为地将相机放置在1.85的高度(Y)处。"

#: ../../docs/tutorials/vr/vr_primer.rst:62
#, fuzzy
msgid ""
"Conclusion: your minimum setup in your scene to make AR or VR work should "
"look like this:"
msgstr "结论，您在场景中进行AR或VR工作的最小设置应如下所示:"

#: ../../docs/tutorials/vr/vr_primer.rst:66
#, fuzzy
msgid ""
"And that's all you need to get started. Obviously, you need to add something "
"more into your scene, so there is something to see, but after that, you can "
"export the game to your phone of choice, pop it into a viewer and away you "
"go."
msgstr ""
"这就是您开始所需要的一切。 显然您需要在场景中添加更多内容，以便有一些东西可以"
"看，但之后您可以将游戏导出到您选择的手机中，将其弹出到观众中然后离开。"

#: ../../docs/tutorials/vr/vr_primer.rst:69
msgid "Other things to consider"
msgstr "其他需要考虑的事情"

#: ../../docs/tutorials/vr/vr_primer.rst:71
msgid ""
"There are a few other subjects that we need to briefly touch upon in this "
"primer that are important to know."
msgstr "我们需要在本入门手册中简要介绍一些其他一些重要的知识。"

#: ../../docs/tutorials/vr/vr_primer.rst:73
#, fuzzy
msgid ""
"The first are our units. In normal 3D games, you don't have to think a lot "
"about units. As long as everything is at the same scale, a box sized 1 unit "
"by 1 unit by 1 unit can be any size from a cube you can hold in your hand to "
"something the size of a building. In AR and VR, this changes because things "
"in your virtual world are mapped to things in the real world. If you step 1 "
"meter forward in the real world, but you only move 1 cm forward in your "
"virtual world, you have a problem. The same with the position of your "
"controllers; if they don't appear in the right relative space, it breaks the "
"immersion for the player. Most VR platforms, including our AR/VR Server, "
"assume that 1 unit = 1 meter. The AR/VR server, however, has a property "
"that, for convenience, is also exposed on the ARVROrigin node called world "
"scale. For instance, setting this to a value of 10 changes our coordinate "
"system so 10 units = 1 meter."
msgstr ""
"首先是我们的单位。 在普通的3D游戏中，您不必考虑很多单位。 只要所有东西都处于"
"相同的比例，一个1个单位乘1个单位的盒子就可以是任何大小，从您可以握在手中的立"
"方体到建筑物的大小。 在AR和VR中，这会发生变化，因为虚拟世界中的事物被映射到现"
"实世界中的事物。 如果您在现实世界中向前迈出1米，但是您只在您的虚拟世界中向前"
"移动1厘米，那您就有问题了。 与控制器的位置相同，如果它们没有出现在正确的相对"
"空间中，则会打破游戏角色的沉浸感。 大多数VR平台，包括我们的AR / VR服务器，假"
"设1个单位= 1米。 然而，AR / VR服务器具有一个属性，为方便起见，该属性也在称为"
"世界规模的ARVROrigin节点上公开。 例如，将其设置为值10，它会更改我们的坐标系，"
"因此10个单位= 1米。"

#: ../../docs/tutorials/vr/vr_primer.rst:77
#, fuzzy
msgid ""
"Performance is another thing that needs to be carefully considered. "
"Especially VR taxes your game a lot more than most people realise. For "
"mobile VR, you have to be extra careful here, but even for desktop games, "
"there are three factors that make life extra difficult:"
msgstr ""
"性能是另一件需要仔细考虑的事情。 特别是VR对您的游戏征税比大多数人意识到的要多"
"得多。 对于移动VR，您必须要格外小心，但即使是桌面游戏，也有三个因素会让生活变"
"得更加困难:"

#: ../../docs/tutorials/vr/vr_primer.rst:79
msgid ""
"You are rendering stereoscopic, two for the price of one. While not exactly "
"doubling the work load and with things in the pipeline such as supporting "
"the new MultiView OpenGL extension in mind, there still is an extra workload "
"in rendering images for both eyes"
msgstr ""
"您正在渲染立体，两个以一个的价格。 虽然没有完全加倍工作量和管道中的东西，例如"
"考虑到支持新的MultiView OpenGL扩展，但双眼渲染图像仍然存在额外的工作量"

#: ../../docs/tutorials/vr/vr_primer.rst:80
#, fuzzy
msgid ""
"A normal game will run acceptably on 30fps and ideally manages 60fps. That "
"gives you a big range to play with between lower end and higher end "
"hardware. For any HMD application of AR or VR, however, 60fps is the "
"absolute minimum and you should target your games to run at a stable 90fps "
"to ensure your users don't get motion sickness right off the bat."
msgstr ""
"正常游戏将以30fps的速度运行，理想情况下可以管理60fps。 这使您可以在低端和高端"
"硬件之间进行大范围的操作。 对于AR或VR的任何HMD应用，但60fps是绝对最小值，您应"
"该将游戏定位为稳定的90fps，以确保您的用户不会立即晕车。"

#: ../../docs/tutorials/vr/vr_primer.rst:81
msgid ""
"The high FOV and related lens distortion effect require many VR experiences "
"to render at double the resolution. Yes a VIVE may only have a resolution of "
"1080x1200 per eye, we're rendering each eye at 2160x2400 as a result. This "
"is less of an issue for most AR applications."
msgstr ""
"高FOV和相关的镜头失真效果需要许多VR体验才能以两倍的分辨率呈现。 是的，VIVE可"
"能只有每只眼睛1080x1200的分辨率，因此我们将每只眼睛渲染为2160x2400。 对于大多"
"数AR应用程序来说，这不是一个问题。"

#: ../../docs/tutorials/vr/vr_primer.rst:83
#, fuzzy
msgid ""
"All in all, the workload your GPU has in comparison with a normal 3D game is "
"a fair amount higher. While things are in the pipeline to improve this, such "
"as MultiView and foveated rendering, these aren't supported on all devices. "
"This is why you see many VR games using a more art style and if you pay "
"close attention to those VR games that go for realism, you'll probably "
"notice they're a bit more conservative on the effects or use some good old "
"optical trickery."
msgstr ""
"总而言之，与普通3D游戏相比，GPU的工作负载相当高。 虽然有些东西正在改进中，例"
"如MultiView和foveated渲染，但并不是所有设备都支持这些。 这就是为什么您看到许"
"多VR游戏使用更多的艺术风格，如果您密切关注那些真实的VR游戏，您可能会注意到它"
"们对效果更加保守或使用一些好的旧光学技巧。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:4
msgid "VR starter tutorial"
msgstr "VR入门教程"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:11
#, fuzzy
msgid ""
"This tutorial will show you how to make a beginner VR game project in Godot."
msgstr "本教程系列将向您展示如何制作单人FPS游戏。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:13
msgid ""
"Keep in mind, **one of the most important things when making VR content is "
"getting the scale of your assets correct**! It can take lots of practice and "
"iterations to get this right, but there are a few things you can do to make "
"it easier:"
msgstr ""
"请记住， **制作VR内容时最重要的事情之一是保证您的资源大小合适** ！ 这可以通过"
"大量练习和反复调整来实现这一目标，但是您可以采取一些措施来简化这个过程:"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:16
#, fuzzy
msgid ""
"In VR, 1 unit is typically considered 1 meter. If you design your assets "
"around that standard, you can save yourself a lot of headache."
msgstr ""
"在VR中，1个单位通常被认为是1米。 如果按照该标准设计资源，可以省去很多麻烦。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:17
#, fuzzy
msgid ""
"In your 3D modeling program, see if there is a way to measure and use real "
"world distances. In Blender, you can use the MeasureIt add-on; in Maya, you "
"can use the Measure Tool."
msgstr ""
"在3D模型程序中，查看是否有测量和使用真实世界距离的方法。 在Blender中，您可以"
"使用MeasureIt插件，在Maya中，您可以使用测量工具。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:18
msgid ""
"You can make rough models using a tool like `Google Blocks <https://vr."
"google.com/blocks/>`_, and then refine in another 3D modelling program."
msgstr ""
"您可以使用诸如 `Google Blocks <https://vr.google.com/blocks/>`_ 之类的工具制"
"作粗略模型，然后在另一个3D建模程序中进行优化。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:19
msgid ""
"Test often, as the assets can look dramatically different in VR than on a "
"flat screen!"
msgstr "经常测试，因为VR中的资源看起来与平面屏幕上的显着不同！"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:21
msgid "Throughout the course of this tutorial, we will cover:"
msgstr "在本教程的整个过程中，我们将介绍:"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:23
msgid "How to tell Godot to run in VR."
msgstr "如何让Godot以VR模式运行。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:24
msgid "How to make a teleportation system for moving the player."
msgstr "如何制作用于移动游戏角色的传送系统。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:25
msgid ""
"How to make a directional movement system (locomotion) for moving the player."
msgstr "如何制作用于移动游戏角色的定向移动系统(移动)。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:26
#, fuzzy
msgid ""
"How to make a :ref:`RigidBody <class_RigidBody>`-based pick up and drop "
"system."
msgstr "如何制作一个 :ref:`RigidBody <class_RigidBody>` 基于拾取和放下系统。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:27
#, fuzzy
msgid "How to make various items that can be used in VR."
msgstr "如何制作可在VR中使用的各种物品"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:29
msgid ""
"While this tutorial can be completed by beginners, it is highly advised to "
"complete :ref:`doc_your_first_game`, if you are new to Godot and/or game "
"development and have some experience with making 3D games **before** going "
"through this tutorial series."
msgstr ""
"虽然本教程可以由初学者完成，但强烈建议您完成 :ref:`doc_your_first_game`，如果"
"您是Godot和/或游戏开发的新手，并且在完成本教程之前有一些制作3D游戏的经验** 系"
"列。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:34
#, fuzzy
msgid ""
"This tutorial assumes you have experience working with the Godot editor, "
"have basic programming experience in GDScript, and have basic 3D game "
"development experience."
msgstr ""
"本教程假设您具有使用Godot编辑器的经验，具有GDScript的基本编程经验，并具有基本"
"的3D游戏开发经验。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:37
#, fuzzy
msgid ""
"Also, it is assumed you have both an OpenVR-ready headset and two OpenVR-"
"ready controllers! This tutorial was written using a Windows Mixed Reality "
"headset on Windows 10, so the tutorial is written to work on that headset. "
"It has also been tested on the HTC Vive. You may need to adjust the code to "
"work with other VR headsets, such as the Oculus Rift."
msgstr ""
"此外，假设您有一个支持OpenVR的耳机和两个支持OpenVR的控制器！ 本教程是在"
"Windows 10上使用Windows Mixed Reality耳机编写的，因此编写本教程是为了使用该耳"
"机。 您可能需要调整代码以使用其他VR耳机，例如Oculus Rift或HTC Vive。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:40
msgid ""
"You can find the start assets for this tutorial here: :download:"
"`VR_Starter_Tutorial_Start.zip <files/VR_Starter_Tutorial_Start.zip>`"
msgstr ""
"您可以在此处找到本教程的起始资源: :download:`VR_Starter_Tutorial_Start.zip "
"<files / VR_Starter_Tutorial_Start.zip>`"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:42
msgid ""
"The provided starter assets contain some 3D models, sounds, and a few scenes "
"already set up and configured for this tutorial."
msgstr ""
"提供的初始化资源包含一些3D模型，声音以及已为本教程设置和配置的一些场景。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:46
#, fuzzy
msgid ""
"The sky panorama was created by **CGTuts** (`original source <https://cgi."
"tutsplus.com/articles/freebie-8-awesome-ocean-hdris--cg-5684>`_)."
msgstr ""
"天空全景由 **CGTuts** 创建，可在 `此处找到 <https://cgi.tutsplus.com/"
"articles/freebie-8-awesome-ocean-hdris--cg-5684>`_ 。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:48
msgid ""
"The font used is **Titillium-Regular**, and is licensed under the SIL Open "
"Font License, Version 1.1."
msgstr ""
"使用的字体是** Titillium-Regular **，并根据SIL Open Font License 1.1版获得许"
"可。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:50
#, fuzzy
msgid ""
"The audio used are from several different sources, all downloaded from the "
"**Sonnis #GameAudioGDC Bundle** (`license in PDF format <https://sonniss.com/"
"gdc-bundle-license/>`_). The folders where the audio files are stored have "
"the same name as folders in the bundle."
msgstr ""
"所使用的音频来自几个不同的来源，都来自 **Sonnis #GameAudioGDC Bundle**。 声音"
"效果的许可证包含在PDF `此处 <https://sonniss.com/gdc-bundle-license/>`_ 中。 "
"存储音频文件的文件夹与包中的文件夹具有相同的名称。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:53
msgid ""
"The **OpenVR addon** was created by Bastiaan Olij and is released under the "
"MIT license. It can be found both `on the Asset Library <https://godotengine."
"org/asset-library/asset/150>`_ and `on GitHub <https://github.com/GodotVR/"
"godot-openvr-asset>`_."
msgstr ""
"** OpenVR插件**由Bastiaan Olij创建，并在MIT许可下发布。 它可以在 `资源馆 "
"<https://godotengine.org/asset-library/asset/150>`_ 和在 `GitHub上找到 "
"<https://github.com/GodotVR/godot-openvr-asset>`_ 。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:55
msgid ""
"Everything else is original and created solely for this tutorial by "
"TwistedTwigleg. They are released under the MIT license, so feel free to use "
"them however you see fit!"
msgstr ""
"其他一切都是原创的，仅由TwistedTwigleg为本教程创建。 它们是在MIT许可下发布"
"的，所以您可以随意使用它们，但是您认为合适！"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:57
msgid "You can find the finished project at the bottom of this page."
msgstr "您可以在本页底部找到已完成的项目。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:64
#, fuzzy
msgid ""
"While these assets are not necessarily required to use the scripts provided "
"in this tutorial, they will make the tutorial much easier to follow, as "
"there are several premade scenes we will be using throughout the tutorial "
"series."
msgstr ""
"虽然这些资源不一定需要使用本教程中提供的脚本，但它们将使教程更容易理解，因为"
"我们将在整个教程系列中使用几个预制场景。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:68
msgid ""
"First, you may notice there is already quite a bit set up. This includes a "
"pre-built level, several instanced scenes placed around, some background "
"music, and several GUI-related :ref:`MeshInstances <class_MeshInstance>` "
"nodes."
msgstr ""
"首先，您可能会注意到已经设置了很多。 这包括预先构建的级别，放置的几个实例场"
"景，一些背景音乐，以及几个与GUI相关的 :ref:`MeshInstances "
"<class_MeshInstance>` 节点。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:71
#, fuzzy
msgid ""
"You may also notice that the GUI-related meshes already have a script "
"attached to them. This is used to show whatever is inside the :ref:`Viewport "
"<class_Viewport>` on the mesh. Feel free to take a look if you want, but "
"this tutorial will not be going over how to use the :ref:`Viewport "
"<class_Viewport>` nodes for making 3D GUI :ref:`MeshInstance "
"<class_MeshInstance>` nodes."
msgstr ""
"您可能会注意到与GUI相关的网格已经附加了一个脚本，这只是用于显示网格上的 :ref:"
"`Viewport <class_Viewport>` 内的任何内容。 如果您愿意，请随意查看，但本教程不"
"会讨论如何使用 :ref:`Viewport <class_Viewport>` 节点来制作3D GUI :ref:"
"`MeshInstance <class_MeshInstance>` 节点。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:75
#, fuzzy
msgid ""
"The other thing to notice, before we jump into writing the code, is how the :"
"ref:`ARVROrigin <class_ARVROrigin>` node works. How it works is kind of hard "
"to explain, especially if you have never used VR before, but here is the "
"gist of it: The :ref:`ARVROrigin <class_ARVROrigin>` node is the center "
"point of the room. If there is no room-scale tracking, then the :ref:"
"`ARVROrigin <class_ARVROrigin>` will be directly below the player, but if "
"there is room-scale tracking, then the :ref:`ARVROrigin <class_ARVROrigin>` "
"will be the center of the tracked room."
msgstr ""
"在我们开始编写代码之前要注意的另一件事是 :ref:`ARVROrigin "
"<class_ARVROrigin>` 节点是如何工作的。 它是如何工作的有点难以解释，特别是如果"
"您之前从未使用过VR，但这里有它的要点: :ref:`ARVROrigin <class_ARVROrigin>` 节"
"点是房间的中心点。 如果没有房间尺度跟踪，那么 :ref:`ARVROrigin "
"<class_ARVROrigin>` 将直接位于游戏角色的下方，但是如果有房间尺度跟踪，那么 :"
"ref:`ARVROrigin <class_ARVROrigin>` 将是 被跟踪的房间的中心。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:80
#, fuzzy
msgid ""
"This is a bit of a simplification, and honestly, I do not know enough about "
"the various different VR headsets and how they work to give a more detailed "
"and complete explanation. Consider it like this: The :ref:`ARVROrigin "
"<class_ARVROrigin>` is the center of the VR world. If there is room "
"tracking, the player can move away from the center point, the :ref:"
"`ARVROrigin <class_ARVROrigin>` node, but only as far as the room scaling "
"tracks."
msgstr ""
"这有点简化，老实说，我对各种不同的VR耳机以及它们如何工作以提供更详细和完整的"
"解释知之甚少。 简单的方法就是这样看:它 :ref:`ARVROrigin <class_ARVROrigin>` "
"是VR世界的中心。 如果有房间跟踪，游戏角色可以远离中心点，即 :ref:`ARVROrigin "
"<class_ARVROrigin>` 节点，但只能移动到房间缩放轨道。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:84
msgid ""
"If you select the :ref:`ARVROrigin <class_ARVROrigin>` node, you may notice "
"that the world scale is set to ``1.4``. This is because I originally made "
"the world too big, and so I needed to scale the VR player slightly so they "
"better fit the world. As mentioned earlier, keeping the scale relatively "
"constant is very important!"
msgstr ""
"如果选择 :ref:`ARVROrigin <class_ARVROrigin>` 节点，您可能会注意到世界比例设"
"置为“1.4”。 这是因为我最初让世界变得太大，所以我需要稍微扩展VR游戏角色以便它"
"们更适合这个世界。 如前所述，保持比例相对稳定非常重要！"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:87
#, fuzzy
msgid ""
"Another thing to notice here is how we have everything set up under the :ref:"
"`ARVROrigin <class_ARVROrigin>` node. The player camera is an :ref:"
"`ARVRCamera <class_ARVRCamera>` that represents the player's head in the "
"game. The :ref:`ARVRCamera <class_ARVRCamera>` will be offset by the "
"player's height, and if there is room tracking, then the camera can move "
"around 3D space as well, relative to the :ref:`ARVROrigin "
"<class_ARVROrigin>`. This is important to note, especially for later when we "
"add teleporting."
msgstr ""
"另外需要注意的是我们如何在 :ref:`ARVROrigin <class_ARVROrigin>` 节点下设置所"
"有内容。 游戏角色相机是 :ref:`ARVRCamera <class_ARVRCamera>` 代表游戏角色在游"
"戏中的头部。 :ref:`ARVRCamera <class_ARVRCamera>` 将被游戏角色的高度偏移，如"
"果有房间跟踪，那么相对于 :ref:`ARVROrigin <class_ARVROrigin>`，相机也可以在3D"
"空间中移动。 这一点很重要，特别是以后我们添加传送时。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:91
msgid ""
"Notice how there is a :ref:`ColorRect <class_ColorRect>` node called "
"``Movement_Vignette``. This will be a vignette shader that will only be "
"visible when the player is moving. We are going to use the vignette shader "
"to help reduce motion sickness while moving in VR. The reason it is a child "
"of :ref:`ARVROrigin <class_ARVROrigin>` is because we want it to easily "
"access the VR controllers."
msgstr ""
"注意如何 :ref:`ColorRect <class_ColorRect>` 节点名为 "
"``Movement_Vignette`` 。 这将是一个小插图着色器，只有在游戏角色移动时才会显"
"示。 我们将使用晕影着色器来帮助减少在VR中移动时的晕动病。 它是子节点的原因 :"
"ref:`ARVROrigin <class_ARVROrigin>` 是因为我们希望它能够轻松访问VR控制器。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:95
#, fuzzy
msgid ""
"The final thing to note is that there are two :ref:`ARVRController "
"<class_ARVRController>` nodes, and these will represent the left and right "
"controllers in 3D space. An :ref:`ARVRController <class_ARVRController>` "
"with an ID of 1 is the left hand, while an :ref:`ARVRController "
"<class_ARVRController>` with an ID of 2 is the right hand."
msgstr ""
"最后要注意的是有两个 :ref:`ARVRController <class_ARVRController>` 节点，这些"
"节点将代表3D空间中的左右控制器。 答 :ref:`ARVRController "
"<class_ARVRController>` 的ID是左手，而a :ref:`ARVRController "
"<class_ARVRController>` 的ID是右手。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:99
msgid "Starting VR"
msgstr "启动VR"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:101
#, fuzzy
msgid ""
"First, let's get the VR up and going! While ``Game.tscn`` is open, select "
"the ``Game`` node and make a new script called ``Game.gd``. Add the "
"following code:"
msgstr ""
"首先，让我们开始VR吧！ 当 ``Game.tscn`` 打开时，选择 ``Game`` 节点并创建一个"
"名为 ``Game.gd`` 的新脚本。 添加以下代码:"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:142
msgid ""
"For this to work, you will need to have the `OpenVR asset from the Asset "
"Library <https://godotengine.org/asset-library/asset/150>`_. The OpenVR "
"asset is included in the starter assets, but there may be newer versions "
"that work better, so I would highly suggest deleting the ``addons`` folder, "
"then going to the Asset Library and downloading the newest version."
msgstr ""
"要实现这一点，您需要拥有资源馆中的 `OpenVR资源 <https://godotengine.org/"
"asset-library/asset/150>`_ 。 OpenVR资源包含在初始资源中，但可能有更新版本更"
"好，所以我强烈建议删除 ``addons`` 文件夹，然后转到资源馆并下载最新版本。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:146
msgid "With that done, let's quickly go over what this script does."
msgstr "完成后，让我们快速浏览一下这个脚本的功能。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:148
#, fuzzy
msgid ""
"First, we find a VR interface from the ARVR server. We do this because by "
"default Godot does not include any VR interfaces, but rather exposes an API "
"so anyone can make AR/VR interfaces with GDNative/C++. Next, we check to see "
"if an OpenVR interface was found, and then we initialize it."
msgstr ""
"首先，我们从ARVR服务器找到VR界面。 我们这样做是因为默认情况下，Godot不包含任"
"何VR界面，而是公开API，因此任何人都可以使用GDNative / C++制作AR / VR界面。 接"
"下来，我们检查是否找到了OpenVR界面，然后我们初始化它。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:151
#, fuzzy
msgid ""
"Assuming nothing went wrong with initializing, we then turn the main :ref:"
"`Viewport <class_Viewport>` into an AR/VR viewport, by setting ``arvr`` to "
"``true``. We also set HDR to ``false``, since you cannot use HDR in OpenVR."
msgstr ""
"假设初始化没有出错，我们将main :ref:`Viewport <class_Viewport>` 转换为AR / VR"
"视区，将 ``arvr`` 设置为 ``true`` 。 我们还将HDR设置为“false”，因为您无法在"
"OpenVR中使用HDR。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:154
#, fuzzy
msgid ""
"Then, we disable V-Sync and set the target FPS to 90 frames per second. Most "
"VR headsets run at 90 Hz, and since the game will display on both the VR "
"headset and the computer's monitor, we want to disable V-Sync and set the "
"target FPS manually, so the computer's monitor does not drag the VR display "
"down to 60 FPS."
msgstr ""
"然后我们禁用V-Sync并将目标FPS设置为每秒90帧。 大多数VR头戴式耳机以90 Hz的频率"
"运行，由于游戏将同时显示在VR头戴式耳机和计算机的显示器上，我们希望禁用V-Sync"
"并手动设置目标FPS，以便计算机的显示器不会将VR显示器拖动到 60 FPS。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:157
msgid ""
"One thing to notice as well is that the physics FPS is also set to 90! This "
"makes the physics run at the same frame rate as the display, which makes "
"things look smoother in VR."
msgstr ""
"有一点需要注意的是，物理FPS也设置为90！ 这使得物理运行与显示器的帧速率相同，"
"这使VR中的内容看起来更平滑。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:162
msgid ""
"With that done, go ahead and give the game a try! If everything goes well, "
"you will now be able to look around the world! If you have a VR headset with "
"room tracking, you will be able to move around as far as the room tracking "
"allows."
msgstr ""
"完成后，继续尝试游戏吧！ 如果一切顺利，您现在可以环顾世界！ 如果您的VR耳机具"
"有房间跟踪功能，您可以在房间跟踪允许的情况下四处移动。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:166
msgid "Coding the controllers"
msgstr "编码控制器"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:168
#, fuzzy
msgid ""
"While perhaps interesting if we were making a VR film, we really want to do "
"more than stand around and look. Currently, we cannot move outside of the "
"room tracking boundaries (assuming your VR headset has room tracking) and we "
"cannot interact with anything! Let's change that!"
msgstr ""
"虽然我们制作VR电影可能很有意思，但我们真的想做的不仅仅是站着看看。 目前我们无"
"法移动到房间跟踪边界之外(假设您的VR耳机有房间跟踪)，我们无法与任何东西互动！ "
"让我们改变它！"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:171
msgid ""
"You may have noticed that you have a pair of green and black hands following "
"the controllers. Let's write the code for those controllers, which will "
"allow the player to teleport around the world and allow the player to grab "
"and release :ref:`RigidBody <class_RigidBody>` nodes."
msgstr ""
"您可能已经注意到控制器后面有一对绿色和黑色指针。 让我们为这些控制器编写代码，"
"这将允许游戏角色在世界各地传送并允许游戏角色抓取并释放 :ref:`RigidBody "
"<class_RigidBody>` 节点。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:174
#, fuzzy
msgid ""
"Open either ``Left_Controller.tscn`` or ``Right_Controller.tscn``. Feel free "
"to look at how the scene is set up; there are only a couple things of note "
"to point out."
msgstr ""
"打开 ``Left_Controller.tscn`` 或``Right_Controller.tscn``。 随意看看场景是如"
"何设置的; 只有几点值得注意。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:176
#, fuzzy
msgid ""
"First, notice how there are a couple :ref:`Raycast <class_Raycast>` nodes. "
"We will be using one :ref:`Raycast <class_Raycast>` to teleport around the "
"game world (``Raycast``) and we will use the other for picking up objects "
"(``GrabCast``) if the player is using :ref:`Raycast <class_Raycast>` nodes "
"to pick up objects."
msgstr ""
"首先，注意如何有一对 :ref:`Raycast <class_Raycast>` 节点。 我们将使用一个 :"
"ref:`Raycast <class_Raycast>` 来传送游戏世界(``Raycast``)，如果游戏角色正在使"
"用，我们将使用另一个来拾取对象(``GrabCast``) :ref:`Raycast <class_Raycast>` "
"节点来拾取对象。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:179
#, fuzzy
msgid ""
"The other thing to note is how there is an :ref:`Area <class_Area>` called "
"``Area``, that is a small sphere in the palm of the hand. This will be used "
"to detect objects the player can pick up with that hand if the player is "
"using :ref:`Area <class_Area>` nodes to pick up objects."
msgstr ""
"另外需要注意的是:如何存在 :ref:`Area <class_Area>` 简称为 ``Area`` ，这是手掌"
"中的一个小球体。 如果游戏角色正在使用，这将用于检测游戏角色可以用该手拿起的对"
"象 :ref:`Area <class_Area>` 节点来拾取对象。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:182
#, fuzzy
msgid ""
"We also have a larger :ref:`Area <class_Area>` called ``Sleep_Area``, which "
"will be used to wake :ref:`RigidBody <class_RigidBody>` nodes when the hands "
"get close."
msgstr ""
"我们还有一个更大的 :ref:`Area <class_Area>` 名为 ``Sleep_Area`` ，它只是用来"
"唤醒:当手靠近时ref:`RigidBody <class_RigidBody>` 节点。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:184
msgid ""
"Select the root node, either ``Left_Controller`` or ``Right_Controller`` "
"depending on which scene you chose, and create a new script called "
"``VR_Controller.gd``. Add the following to ``VR_Controller.gd``:"
msgstr ""
"根据您选择的场景选择根节点， ``Left_Controller`` 或``Right_Controller``，并创"
"建一个名为 ``VR_Controller.gd`` 的新脚本。 将以下内容添加到``VR_Controller."
"gd``:"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:428
msgid ""
"This is quite a bit of code to go through, so let's break it down bit by "
"bit. Let's start with the class variables, which are variables outside of "
"any/all functions."
msgstr ""
"这是相当多的代码，所以让我们一点一点地分解它。 让我们从类变量开始，这些变量是"
"任何/所有函数之外的变量。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:431
msgid ""
"``controller_velocity``: The velocity the controller is moving at. We will "
"calculate this by changes in position every physics frame."
msgstr ""
"``controller_velocity``:控制器移动的速度。 我们将通过每个物理框架的位置变化来"
"计算它。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:432
msgid ""
"``prior_controller_position``: The controller's previous position. We will "
"use this to calculate the controller's velocity."
msgstr ""
"``prior_controller_position``:控制器的先前位置。 我们将使用它来计算控制器的速"
"度。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:433
msgid ""
"``prior_controller_velocities``: The last 30 calculated velocities (1/3 of a "
"second worth of velocities, assuming the game is running at 90 FPS)."
msgstr ""
"``prior_controller_velocities``:最后30个计算的速度(速度的1/3，假设游戏以90 "
"FPS运行)。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:434
msgid ""
"``held_object``: The currently-held object, a :ref:`RigidBody "
"<class_RigidBody>`, if there is one."
msgstr ""
"``held_object``:当前持有的对象，a :ref:`RigidBody <class_RigidBody>`，如果有"
"的话。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:435
msgid ""
"``held_object_data``: The data of the currently-held object, used to reset "
"the object when it is no longer being held."
msgstr ""
"``held_object_data``:当前保持对象的数据，用于在不再保持对象时重置对象。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:436
msgid "``grab_area``: The :ref:`Area <class_Area>` node used to grab objects."
msgstr "``grab_area``:用于抓取对象的 :ref:`Area <class_Area>` 节点。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:437
msgid "``grab_pos_node``: The position where held objects stay."
msgstr "``grab_pos_node``:保持对象所在的位置。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:438
msgid ""
"``hand_mesh``: The hand mesh, used to represent the player's hand when they "
"are not holding anything."
msgstr "``hand_mesh``:手形网格，用于表示游戏角色手上没有任何东西时的手牌。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:439
#, fuzzy
msgid ""
"``teleport_pos``: The position at which the teleport :ref:`Raycast "
"<class_Raycast>` is aimed."
msgstr "``teleport_pos``:传送的位置 :ref:`Raycast <class_Raycast>` 的目标是。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:440
#, fuzzy
msgid "``teleport_mesh``: The mesh used to represent the teleport position."
msgstr "``teleport_mesh``:用于表示传送位置的网格。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:441
msgid ""
"``teleport_button_down``: A variable for tracking whether the teleport "
"button is being held down or not."
msgstr "``teleport_button_down``:用于跟踪传送按钮是否被按下的变量。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:442
msgid ""
"``teleport_raycast``: The teleport :ref:`Raycast <class_Raycast>` node, used "
"for calculating the teleportation position."
msgstr ""
"``teleport_raycast``:传送 :ref:`Raycast <class_Raycast>` 节点，用于计算传送位"
"置。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:443
msgid ""
"``CONTROLLER_DEADZONE``: The dead zone for both the trackpad and the "
"joystick."
msgstr "``CONTROLLER DEADZONE``:触控板和操纵杆的死区。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:444
msgid ""
"``MOVEMENT_SPEED``: The speed the player moves at when moving using the "
"trackpad and/or the joystick."
msgstr "``MOVEMENT_SPEED``:使用触控板和/或操纵杆移动时游戏角色移动的速度。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:445
msgid ""
"``directional_movement``: A boolean to track whether the player is moving "
"using this controller."
msgstr ""
"``directional_movement``:一个布尔值，用于跟踪游戏角色是否正在使用此控制器移"
"动。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:449
msgid "Next, let's go through ``_ready``."
msgstr "接下来，让我们通过 ``_ready`` 。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:451
#, fuzzy
msgid ""
"Firstly, we get the teleport :ref:`Raycast <class_Raycast>` node and assign "
"it to ``teleport_raycast``."
msgstr ""
"首先我们得到teleport :ref:`Raycast <class_Raycast>` 节点并将其分配给 "
"``teleport_raycast`` 。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:453
msgid ""
"Next, we get the teleport mesh; notice how we are getting it from ``Game/"
"Teleport_Mesh`` using ``get_tree().root``. This is because we need the "
"teleport mesh to be separate from the controller, so moving and rotating the "
"controller does not affect the position and rotation of the teleportation "
"mesh."
msgstr ""
"接下来，我们得到了传送网; 注意我们如何使用 ``get_tree().root`` 从``Game / "
"Teleport_Mesh``获取它。 这是因为我们需要将传送网格与控制器分开，因此移动和旋"
"转控制器不会影响传送网格的位置和旋转。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:456
msgid ""
"Then we get the grab area, grab :ref:`Raycast <class_Raycast>`, and position "
"node and assign them to the proper variables."
msgstr ""
"然后我们得到抓取区域，抓住 :ref:`Raycast <class_Raycast>`，并定位节点并将它们"
"分配给适当的变量。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:458
msgid ""
"We set the default grab mode to ``AREA`` so it uses the :ref:`Area "
"<class_Area>` node to grab objects by default."
msgstr ""
"我们将默认的抓取模式设置为 ``AREA`` ，因此它使用 :ref:`Area <class_Area>` 节"
"点默认抓取对象。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:460
msgid ""
"Then we connect the ``body_entered`` and ``body_exited`` signals from the "
"sleep area node, we get the hand mesh and assign it the proper variable, and "
"finally we connect the ``button_pressed`` and ``button_released`` signals "
"from the :ref:`ARVRController <class_ARVRController>`."
msgstr ""
"然后我们连接来自睡眠区域节点的 ``body_entered`` 和``body_exited``信号，我们获"
"得手网格并为其分配适当的变量，最后我们连接 ``button_pressed`` 和"
"``button_released`` 来自 :ref:`ARVRController <class_ARVRController>` 的信"
"号。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:467
#, fuzzy
msgid ""
"Firstly, we check to see if the teleportation button is down or not. If the "
"teleportation button is down, we then force the teleportation :ref:`Raycast "
"<class_Raycast>` to update, which will give us frame perfect collision "
"detection. We then check to see if the :ref:`Raycast <class_Raycast>` is "
"colliding with anything."
msgstr ""
"首先，我们检查传送按钮是否关闭。 如果传送按钮关闭，我们然后强制传送 :ref:"
"`Raycast <class_Raycast>` 更新，这将给我们帧完美的碰撞检测。 然后我们检查 :"
"ref:`Raycast <class_Raycast>` 是否与任何东西发生碰撞。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:470
#, fuzzy
msgid ""
"Next, we check to see if the collision body the :ref:`Raycast "
"<class_Raycast>` is colliding with is a :ref:`StaticBody "
"<class_StaticBody>`. We do this to ensure the player can only teleport on :"
"ref:`StaticBody <class_StaticBody>` nodes. We then check to see if the ``Y`` "
"value returned by the :ref:`Raycast <class_Raycast>`'s "
"``get_collision_normal`` function is more than ``0.85``, which is mostly "
"pointing straight up. This allows the player only to teleport on fairly flat "
"faces pointing upwards."
msgstr ""
"接下来，我们检查一下碰撞体是否与 :ref:`Raycast <class_Raycast>` 碰撞的是 :"
"ref:`StaticBody <class_StaticBody>`。 我们这样做是为了确保游戏角色只能传送 :"
"ref:`StaticBody <class_StaticBody>` 节点。 然后我们检查一下 :ref:`Raycast "
"<class_Raycast>` 的 ``get_collision_normal`` 函数返回的 ``Y`` 值是否大于 "
"``0.85`` ，这大多指向直线。 这允许游戏角色仅在相当平坦的面向上传送。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:474
msgid ""
"If all those checks for the teleport :ref:`Raycast <class_Raycast>` return "
"true, we then set ``teleport_pos`` to the collision point, and we move the "
"teleportation mesh to ``teleport_pos``."
msgstr ""
"如果对teleport的所有检查 :ref:`Raycast <class_Raycast>` 返回true，我们将 "
"``teleport_pos`` 设置为碰撞点，然后我们将远程传送网格移动到 "
"``teleport_pos`` 。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:477
#, fuzzy
msgid ""
"The next thing we check is to see if the :ref:`ARVRController "
"<class_ARVRController>` is active or not. If the :ref:`ARVRController "
"<class_ARVRController>` is active, then that means there is a controller and "
"it is being tracked. If the controller is active, we then reset "
"``controller_velocity`` to an empty :ref:`Vector3 <class_Vector3>`."
msgstr ""
"接下来我们要检查的是 :ref:`ARVRController <class_ARVRController>` 是否处于活"
"动状态。 如果 :ref:`ARVRController <class_ARVRController>` 处于活动状态，则表"
"示存在控制器并且正在跟踪它。 如果控制器处于活动状态，我们将 "
"``controller_velocity`` 重置为空 :ref:`Vector3 <class_Vector3>`。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:480
msgid ""
"We then add all of the prior velocity calculations in "
"``prior_controller_velocities`` to ``controller_velocity``. By using the "
"prior calculations, we get a smoother throwing/catching experience, although "
"it is not perfect. We want to get the average of these velocities, as "
"otherwise we'd get crazy high velocity numbers that are not realistic."
msgstr ""
"然后，我们将 ``prior_controller_velocities`` 中的所有先前速度计算添加到 "
"``controller_velocity`` 中。 通过使用先前的计算，我们获得了更平滑的投掷/捕捉"
"体验，尽管它并不完美。 我们希望得到这些速度的平均值，否则我们会得到疯狂的高速"
"数字，这是不现实的。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:483
#, fuzzy
msgid ""
"Next, we calculate the velocity from the position where the controller is "
"currently, from the position the controller was at. We can use this "
"difference in position to help track the controller's velocity."
msgstr ""
"接下来，我们从控制器当前所处的位置，从控制器所处的位置计算速度。 我们可以使用"
"这种位置差异来帮助追踪控制器的速度。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:486
msgid ""
"We then add the velocity from the controller this physics frame and the last "
"physics frame to ``controller_velocity``. We then update "
"``prior_controller_position`` to the current position, so we can use it in "
"the calculations in the velocity next physics frame."
msgstr ""
"然后我们将控制器的速度从物理框架和最后一个物理框架添加"
"到“controller_velocity”。 然后我们将 ``prior_controller_position`` 更新到当前"
"位置，这样我们就可以在速度下一个物理帧的计算中使用它。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:489
#, fuzzy
msgid ""
"The way we are calculating velocity is not perfect by any means, since it "
"relies on a consistent amount of frames per second. Ideally, we would be "
"able to find the velocity directly from the VR controller, but currently in "
"OpenVR, there is no way to access the controller's velocity. We can get "
"pretty close to the real velocity by comparing positions between frames "
"though, and this will work just fine for this project."
msgstr ""
"我们计算速度的方式无论如何都不是完美的，因为它依赖于每秒一致的帧数。 理想情况"
"下，我们可以直接从VR控制器中找到速度，但目前在OpenVR中无法访问控制器的速度。 "
"通过比较帧之间的位置，我们可以非常接近真实速度，这对于这个项目来说效果很好。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:493
#, fuzzy
msgid ""
"Then, we check to see if we have more than 30 stored velocities (more than a "
"third of a second). If there are more than 30, we remove the oldest velocity "
"from ``prior_controller_velocities``."
msgstr ""
"然后我们检查我们是否有超过30个存储的速度(超过三分之一秒)。 如果超过30，我们"
"从 ``prior_controller_velocities`` 中删除最旧的速度。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:497
#, fuzzy
msgid ""
"Next, we check to see whether there is a held object. If there is, we update "
"the position and rotation of the held object to the position and rotation of "
"``grab_pos_node``. Because of how scale works, we need to temporarily store "
"the scale and then reset the scale once we have updated the transform; "
"otherwise, the scale would always be the same as the controller, which would "
"ruin immersion if the player grabbed a scaled object."
msgstr ""
"接下来我们检查是否有被保持的物体。 如果有，我们将被保持对象的位置和旋转更新"
"为“grab_pos_node”的位置和旋转。 由于比例是如何工作的，我们需要暂时存储比例，"
"然后在我们更新变换后重置比例，否则比例将始终与控制器相同，如果游戏角色抓取比"
"例对象，这将打破沉浸。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:502
msgid ""
"The last thing we are going to do in ``_physics_process`` is move the player "
"if they are moving the trackpad/joystick on the VR controller."
msgstr ""
"我们在 ``_physics_process`` 中要做的最后一件事是移动游戏角色，如果他们正在移"
"动VR控制器上的触控板/操纵杆。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:504
#, fuzzy
msgid ""
"Firstly, we convert the axis values into :ref:`Vector2 <class_Vector2>` "
"variables, so we can process them. We invert the X axis, so moving the "
"trackpad/joystick left will move the player left."
msgstr ""
"首先，我们将轴值转换为 :ref:`Vector2 <class_Vector2>` 变量，以便我们可以处理"
"它们。 我们将X轴反转，因此向左移动触控板/操纵杆将使游戏角色向左移动。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:507
msgid ""
"Depending on your VR controller and OS, you may need to change the code so "
"it gets the proper axis values!"
msgstr "根据您的VR控制器和操作系统，您可能需要更改代码，以便获得正确的轴值！"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:509
#, fuzzy
msgid ""
"Next, we account for dead zones on both the trackpad and the joystick. The "
"code for doing this is adapted from the link below, and I would highly "
"recommend looking at it."
msgstr ""
"接下来，我们会在触控板和操纵杆上考虑死区。 执行此操作的代码改编自以下链接，我"
"强烈建议您查看它。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:511
#, fuzzy
msgid ""
"You can find a great article explaining joystick dead zones `on Third Helix "
"<http://www.third-helix.com/2013/04/12/doing-thumbstick-dead-zones-right."
"html>`_."
msgstr ""
"您可以找到一篇很棒的文章解释操纵杆死区`这里 <http://www.third-helix."
"com/2013/04/12/doing-thumbstick-dead-zones-right.html>`_ 。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:513
msgid ""
"One thing to note is how large we are making the dead zones. The reason we "
"are using such large dead zones is so the player cannot move themselves "
"accidentally by placing their finger on the center of the touchpad/joystick, "
"which can make players experience motion sickness if they are not expecting "
"it."
msgstr ""
"需要注意的一点是我们制造死区有多大。 我们使用如此大的死区的原因是游戏角色不能"
"通过将他们的手指放在触摸板/操纵杆的中心而不小心移动自己，这可能会让游戏角色在"
"不期待它时遇到晕动病。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:516
msgid ""
"Next, we get the forward and right directional vectors from the VR camera. "
"We need these so we can move the player forward/backwards and right/left "
"based on where they are currently looking."
msgstr ""
"接下来，我们从VR摄像机获得前向和右向方向向量。 我们需要这些，所以我们可以根据"
"他们当前所在的位置向前/向后和向右/向左移动游戏角色。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:519
#, fuzzy
msgid ""
"Then, we calculate how much the player will be moving by adding both the "
"trackpad and the joystick vectors together and normalizing them."
msgstr ""
"然后我们通过将触控板和操纵杆向量一起添加并将它们标准化来计算游戏角色将移动多"
"少。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:521
msgid ""
"Next, we calculate how far the player will go forwards/backwards and right/"
"left by multiplying the VR camera's directional vectors by the combined "
"trackpad/joystick vector."
msgstr ""
"接下来，我们通过将VR摄像机的方向向量乘以组合的触控板/操纵杆向量来计算游戏角色"
"前进/后退和右/左的距离。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:523
#, fuzzy
msgid ""
"We then remove movement on the Y axis so the player cannot fly/fall by "
"moving using the trackpad/joystick."
msgstr ""
"然后我们移除Y轴上的移动，这样游戏角色就不能通过使用触控板/操纵杆移动来飞行/跌"
"落。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:525
msgid ""
"And finally, we move the player if there is any movement forwards/backwards "
"or right/left. If we are moving the player, we set ``directional_movement`` "
"accordingly."
msgstr ""
"最后，如果向前/向后或向右/向左移动，我们会移动游戏角色。 如果我们移动游戏角"
"色，我们相应地设置 ``directional_movement`` 。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:529
msgid "Now, let's look at ``button_pressed``."
msgstr "现在，让我们看看 ``button_pressed`` 。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:531
#, fuzzy
msgid ""
"If the button pressed is button 15, which for the Windows Mixed Reality "
"controllers is the trigger button, we will interact with the held object "
"assuming the controller is holding one, and if the player is not holding an "
"object, we will try to start teleporting."
msgstr ""
"如果按下的按钮是按钮15，对于Windows混合现实控制器是触发按钮，我们将与保持的对"
"象交互，假设控制器持有一个，如果游戏角色没有持有对象，我们将尝试开始传送。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:534
#, fuzzy
msgid ""
"If the controller is holding an object, and the held object has a method/"
"function called ``interact``, we call the ``interact`` function on the held "
"object."
msgstr ""
"如果控制器持有一个对象，并且持有的对象有一个名为 ``interact`` 的方法/函数，我"
"们在被保持的对象上调用 ``interact`` 函数。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:537
#, fuzzy
msgid ""
"If the controller is not holding an object, we then check to make sure the "
"teleportation mesh is not visible. This check ensures the player cannot "
"teleport with both hands/controllers at the same time. If the teleportation "
"mesh is not visible, we set ``teleport_button_down`` to ``true``, make "
"``teleport_mesh`` visible, and make the teleportation raycast visible. This "
"makes it where the teleportation mesh will follow the :ref:`Raycast "
"<class_Raycast>` coming from the pointer finger of the hand."
msgstr ""
"如果控制器没有拿着物体，我们检查以确保隐形传送网格不可见。 此检查确保游戏角色"
"不能同时传送不能用双手/控制器传送。 如果远程传送网格不可见，我们将 "
"``teleport_button_down`` 设置为 ``true`` ，使 ``teleport_mesh`` 可见，并使远"
"距传送光线投射可见。 这使得远程传送网格将遵循 :ref:`Raycast <class_Raycast>` "
"来自手的指针。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:542
#, fuzzy
msgid ""
"If the button pressed is button 2, which, for the Windows Mixed Reality "
"controllers, is the grab/grip button, we will grab/throw an object."
msgstr ""
"如果按下的按钮是按钮2，对于Windows混合现实控制器是抓取/抓握按钮，我们将抓取/"
"抛出一个对象。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:544
#, fuzzy
msgid ""
"Firstly, we make sure the player is not trying to teleport, as we do not "
"want the player to be able to grab something while in the middle of trying "
"to teleport."
msgstr ""
"首先，我们确保游戏角色不会尝试传送，因为我们不希望游戏角色在尝试传送的过程中"
"能够抓住某些东西。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:546
#, fuzzy
msgid ""
"Then, we check to see whether the controller is already holding a object or "
"not."
msgstr "然后我们检查控制器是否已经持有一个对象。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:548
#, fuzzy
msgid ""
"If the controller is not holding an object, we check to see which grab mode "
"the player is using."
msgstr "如果控制器没有拿着物体，我们会检查游戏角色正在使用哪种抓取模式。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:550
#, fuzzy
msgid ""
"If the player is using the ``AREA`` grab mode, we then get all the bodies "
"overlapping the grab :ref:`Area <class_Area>`. We go through all the bodies "
"in the grab :ref:`Area <class_Area>` and see if there is a :ref:`RigidBody "
"<class_RigidBody>`. We also check to make sure any :ref:`RigidBody "
"<class_RigidBody>` nodes in the :ref:`Area <class_Area>` do not have a "
"variable called ``NO_PICKUP``, since we do not want to be able to pick up "
"nodes with that variable."
msgstr ""
"如果游戏角色正在使用 ``AREA`` 抓取模式，那么我们将获得所有与grab重叠的实体 :"
"ref:`Area <class_Area>`。 我们遍历了grab中的所有实体 :ref:`Area "
"<class_Area>` 并查看是否有 :ref:`RigidBody <class_RigidBody>`。 我们还检查以"
"确定 :ref:`RigidBody <class_RigidBody>` 节点 :ref:`Area <class_Area>` 没有名"
"为 ``NO_PICKUP`` 的变量，因为我们不希望能够选择 具有该变量的节点。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:554
msgid ""
"Assuming there is a :ref:`RigidBody <class_RigidBody>` node inside the grab :"
"ref:`Area <class_Area>` that does not have a variable called ``NO_PICKUP``, "
"we assign it to ``rigid_body`` for additional processing."
msgstr ""
"假设在:grab :ref:`Area <class_Area>` 里面有一个 :ref:`RigidBody "
"<class_RigidBody>` 节点，它没有一个名为 ``NO_PICKUP`` 的变量，我们将它分配给 "
"``rigid_body`` 以获得额外的处理。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:557
#, fuzzy
msgid ""
"If the player is using the ``RAYCAST`` grab mode, we first force the :ref:"
"`Raycast <class_Raycast>` to update. We then check to see whether the :ref:"
"`Raycast <class_Raycast>` is colliding with something."
msgstr ""
"如果游戏角色正在使用 ``RAYCAST`` 抓取模式，我们首先强制 :ref:`Raycast "
"<class_Raycast>` 进行更新。 然后我们检查 :ref:`Raycast <class_Raycast>` 是否"
"与某些东西发生碰撞。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:560
#, fuzzy
msgid ""
"If the :ref:`Raycast <class_Raycast>` is colliding with something, we then "
"check to see if what it is colliding with is a :ref:`RigidBody "
"<class_RigidBody>`, and that it does not have a variable called "
"``NO_PICKUP``. If the :ref:`Raycast <class_Raycast>` is colliding with a :"
"ref:`RigidBody <class_RigidBody>`, and it does not have a variable called "
"``NO_PICKUP``, we assign it to ``rigid_body`` for additional processing."
msgstr ""
"如果 :ref:`Raycast <class_Raycast>` 与某些内容发生冲突，我们检查是否发生冲突"
"的是 :ref:`RigidBody <class_RigidBody>`，并且它没有一个名为 ``NO_PICKUP的变量"
"`` 。 如果 :ref:`Raycast <class_Raycast>` 与 :ref:`RigidBody "
"<class_RigidBody>` 冲突，并且它没有一个名为 ``NO_PICKUP`` 的变量，我们将它分"
"配给 ``rigid_body`` 以获得额外的处理。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:564
#, fuzzy
msgid ""
"If ``rigid_body`` is not ``null``, meaning we found a :ref:`RigidBody "
"<class_RigidBody>` in the grab :ref:`Area <class_Area>`, we assign "
"``held_object`` to it. Then we store the now held :ref:`RigidBody "
"<class_RigidBody>`'s information in ``held_object_data``. We are storing "
"the :ref:`RigidBody <class_RigidBody>` mode, layer, and mask so later, when "
"we drop it, we can reset all those variables back to what they were before "
"we picked up the :ref:`RigidBody <class_RigidBody>`."
msgstr ""
"如果 ``rigid_body`` 不是 ``null`` ，意味着我们在grab :ref:`Area "
"<class_Area>` 中找到了一个 :ref:`RigidBody <class_RigidBody>`，我们给它分配"
"了 ``held_object`` 。 然后我们在 ``held_object_data`` 中存储现在持有的 :ref:"
"`RigidBody <class_RigidBody>的信息。 我们正在存储 :ref:`RigidBody "
"<class_RigidBody>` 模式，图层和掩码，所以稍后当我们删除它时，我们可以将所有这"
"些变量重置回原来的状态 :ref:`RigidBody <class_RigidBody>`。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:568
msgid ""
"We then set the held object's :ref:`RigidBody <class_RigidBody>` mode to "
"``MODE_STATIC`` and set the collision layer and mask to 0 so it cannot "
"collide with any other physic bodies."
msgstr ""
"然后我们将保持对象的 :ref:`RigidBody <class_RigidBody>` 模式设置为 "
"``MODE_STATIC`` 并将碰撞层和掩码设置为0，这样它就不会与任何其他物理机构发生碰"
"撞。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:571
msgid ""
"We make the hand mesh invisible so it does not get in the way of the object "
"we are holding (and also because I did not feel like animating the hand). We "
"also make the grab :ref:`Raycast <class_Raycast>` invisible so the mesh used "
"for showing the :ref:`Raycast <class_Raycast>` is no longer visible."
msgstr ""
"我们使手网不可见，因此它不会妨碍我们持有的对象(也因为我不喜欢动画手)。 我们也"
"使得 :ref:`Raycast <class_Raycast>` 看不见，因此用于显示 :ref:`Raycast "
"<class_Raycast>` 的网格不再可见。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:574
msgid ""
"If the :ref:`RigidBody <class_RigidBody>` we picked up has the ``picked_up`` "
"method/function, we call it. If the :ref:`RigidBody <class_RigidBody>` we "
"picked up has a variable called ``controller``, we set it to this controller."
msgstr ""
"如果我们选择的 :ref:`RigidBody <class_RigidBody>` 有 ``picked_up`` 方法/函"
"数，我们称之为。 如果 :ref:`RigidBody <class_RigidBody>` 我们选择了一个名为 "
"``controller`` 的变量，我们将它设置为该控制器。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:577
#, fuzzy
msgid ""
"If the controller is not holding an object, and the button pressed is 2, we "
"want to drop/throw the held object."
msgstr ""
"如果控制器没有持有一个对象，并且按下的按钮是2，我们想要删除/抛出被保持的对"
"象。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:579
#, fuzzy
msgid ""
"Firstly, we set the held :ref:`RigidBody <class_RigidBody>`'s mode, layer, "
"and mask back to what they were when we picked the object up. We then apply "
"an impulse to the held object, using the controller's velocity as the force."
msgstr ""
"首先，我们将hold :ref:`RigidBody <class_RigidBody>的模式，图层和蒙版设置回我"
"们拾取对象时的状态。 然后，我们使用控制器的速度作为力，对保持的对象施加脉冲。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:582
#, fuzzy
msgid ""
"If the previously held :ref:`RigidBody <class_RigidBody>` has a function "
"called ``dropped``, we call it. If the :ref:`RigidBody <class_RigidBody>` "
"has a variable called ``controller``, we set it to ``null``."
msgstr ""
"如果以前持有的 :ref:`RigidBody <class_RigidBody>` 有一个名为 ``dropped`` 的函"
"数，我们称之为。 如果 :ref:`RigidBody <class_RigidBody>` 有一个名为 "
"``controller`` 的变量，我们将它设置为 ``null`` 。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:585
#, fuzzy
msgid ""
"Then, we set ``held_object`` to ``null``, since we are no longer holding any "
"objects, and we make the hand mesh visible again."
msgstr ""
"然后我们将 ``held_object`` 设置为 ``null`` ，因为我们不再持有任何对象，我们再"
"次使手网可见。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:587
msgid ""
"If we are using the ``RAYCAST`` grab mode, we make the :ref:`Raycast "
"<class_Raycast>` visible so we can see the mesh used for showing the grab :"
"ref:`Raycast <class_Raycast>`."
msgstr ""
"如果我们使用 ``RAYCAST`` 抓取模式，我们将 :ref:`Raycast <class_Raycast>` 显示"
"为可见，这样我们就可以看到用于显示抓取的网格 :ref:`Raycast <class_Raycast>`。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:589
#, fuzzy
msgid ""
"Finally, regardless of whether we are grabbing an object or releasing it, we "
"play the sound loaded into ``AudioStreamPlayer3D``, which is a pick-up/drop "
"noise."
msgstr ""
"最后，无论我们是抓取对象还是释放它，我们都会播放加载到“AudioStreamPlayer3D”中"
"的声音，这是一种拾取/丢弃噪声。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:591
#, fuzzy
msgid ""
"The last thing we are doing in ``button_pressed`` is checking to see if the "
"button pressed is 1, which, for the Windows Mixed Reality controllers, is "
"the menu button."
msgstr ""
"我们在 ``button_pressed`` 中做的最后一件事是检查按下的按钮是否为1，对于"
"Windows Mixed Reality控制器是菜单按钮。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:593
msgid ""
"If the menu button is pressed, we change grab modes, and set the visibility "
"of the grab :ref:`Raycast <class_Raycast>` so it is only visible when using "
"``RAYCAST`` as the grab mode."
msgstr ""
"如果按下菜单按钮，我们更改抓取模式，并设置抓取的可见性 :ref:`Raycast "
"<class_Raycast>` 所以只有在使用 ``RAYCAST`` 作为抓取模式时才能看到它。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:597
msgid "Let's look at ``button_released`` next."
msgstr "我们接下来看看 ``button_released`` 。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:599
msgid ""
"If the button released is button 15, the trigger, then we potentially want "
"to teleport."
msgstr "如果释放的按钮是按钮15，触发器，那么我们可能想要传送。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:601
#, fuzzy
msgid ""
"Firstly, we check to see whether ``teleport_button_down`` is ``true``. If it "
"is, that means the player is intending to teleport, while if it is "
"``false``, the player has released the trigger while holding an object."
msgstr ""
"首先，我们检查 ``teleport_button_down`` 是否为 ``true`` 。 如果是，那意味着游"
"戏角色打算传送，而如果它是“假”，游戏角色只需在拿着一个物体时释放扳机。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:604
msgid ""
"We then check to see if this controller has a teleport position, and we "
"check to make sure the teleport mesh is visible."
msgstr "然后我们检查该控制器是否具有传送位置，我们检查以确保传送网格可见。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:606
msgid ""
"If both of those conditions are ``true``, we then calculate the offset the :"
"ref:`ARVRCamera <class_ARVRCamera>` has from the :ref:`ARVROrigin "
"<class_ARVROrigin>`. We do this because of how :ref:`ARVRCamera "
"<class_ARVRCamera>` and :ref:`ARVROrigin <class_ARVROrigin>` work with room-"
"scale tracking."
msgstr ""
"如果这两个条件都是 ``true`` ，那么我们计算偏移 :ref:`ARVRCamera "
"<class_ARVRCamera>` 来自 :ref:`ARVROrigin <class_ARVROrigin>`。 我们这样做是"
"因为 :ref:`ARVRCamera <class_ARVRCamera>` 和 :ref:`ARVROrigin "
"<class_ARVROrigin>` 使用房间尺度跟踪。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:609
#, fuzzy
msgid ""
"Because we want to teleport the player in their current position to the "
"teleport position, and remember, because of room-scale tracking, their "
"current position can be offset from the origin, we have to figure out that "
"offset so when we teleport, we can remove it so that player's current "
"position is teleported to the teleport position."
msgstr ""
"因为我们想将当前位置的游戏角色传送到传送位置，并且因为房间尺度跟踪而记住它们"
"的当前位置可能偏离原点，我们必须弄清楚偏移，所以当我们传送时我们可以删除它 该"
"球员的当前位置被传送到传送位置。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:612
msgid ""
"We set the Y value of the camera_offset to zero because we do not want to "
"account for offsets in the player's height."
msgstr ""
"我们将camera_offset的Y值设置为零，因为我们不想考虑游戏角色身高的偏移量。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:614
#, fuzzy
msgid ""
"Then, we teleport the :ref:`ARVROrigin <class_ARVROrigin>` to the teleport "
"position, applying the camera offset."
msgstr ""
"然后我们将 :ref:`ARVROrigin <class_ARVROrigin>` 传送到传送位置，应用相机偏"
"移。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:616
#, fuzzy
msgid ""
"Regardless of whether we teleported or not, we reset all the teleport-"
"related variables so the controller has to get new ones before teleporting "
"again."
msgstr ""
"无论我们是否传送，我们都会重置所有与传送相关的变量，以便控制器必须在再次传送"
"之前获得新的变量。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:620
msgid ""
"Finally, let's look at ``sleep_area_entered`` and ``sleep_area_exited``."
msgstr "最后，让我们看一下 ``sleep_area_entered`` 和``sleep_area_exited``。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:622
#, fuzzy
msgid ""
"When a body enters or exists the sleep area, we check whether it has a "
"variable called ``can_sleep``. If it does, we then set it to ``false`` and "
"wake the body if it has entered the sleep area, while if it has exited, we "
"set it to ``true`` so the :ref:`RigidBody <class_RigidBody>` nodes can sleep "
"(which can decrease CPU usage)."
msgstr ""
"当物体进入或存在睡眠区域时，我们检查它是否有一个名为“can_sleep”的变量。 如果"
"确实如此，我们将其设置为“false”并在物体进入睡眠区域时唤醒物体，如果已经退出，"
"我们将其设置为“真实”，以便 :ref:`RigidBody <class_RigidBody> `节点可以睡眠(可"
"以降低CPU使用率)。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:627
#, fuzzy
msgid ""
"Okay, whew! That was a lot of code! Add the same script, ``VR_Controller."
"gd`` to the other controller so both controllers have the same script."
msgstr ""
"好的，p！ 那是很多代码！ 将相同的脚本 ``VR_Controller.gd`` 添加到另一个控制"
"器，以便两个控制器具有相同的脚本。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:629
msgid ""
"Now go ahead and try the game again, and you should find you can teleport "
"around by pressing the touch pad, and can grab and throw objects using the "
"grab/grip buttons."
msgstr ""
"现在再继续尝试游戏，您会发现您可以通过按下触摸板来传送，并且可以使用抓握/抓握"
"按钮抓住并扔掉物体。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:632
msgid ""
"Now, you may want to try moving using the trackpads and/or joysticks, but "
"**it may make you motion sick!**"
msgstr ""
"现在，您可能想尝试使用触控板和/或操纵杆移动，但**它可能会让您运动生病！**"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:634
msgid ""
"One of the main reasons this can make you feel motion sick is because your "
"vision tells you that you are moving, while your body is not moving. This "
"conflict of signals makes the body feel sick, so let's fix it!"
msgstr ""
"这可能让您感到晕车的主要原因之一是因为您的视力告诉您，您的物体不动，您正在移"
"动。 这种信号冲突使物体感到恶心，所以让我们解决它！"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:638
msgid "Reducing motion sickness"
msgstr "减少晕动病"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:640
msgid ""
"There are plenty of ways to reduce motion sickness in VR, and there is no "
"one perfect way to reduce motion sickness. See `this page on the Oculus "
"Developer Center <https://developer.oculus.com/design/latest/concepts/bp-"
"locomotion/>`_ for more information on how to implement locomotion and "
"reducing motion sickness."
msgstr ""
"有很多方法可以减少VR中的晕动病，并且没有一种方法可以减少晕动病。 有关如何实施"
"运动和减少晕动病的更多信息，请参阅Oculus开发人员中心的 `这个页面 <https://"
"developer.oculus.com/design/latest/concepts/bp-locomotion/>`_ 。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:644
msgid ""
"To help reduce motion sickness while moving, we are going to add a vignette "
"effect that will only be visible while the player moves."
msgstr ""
"为了帮助减少移动时的晕车，我们将添加一个只有在游戏角色移动时才能看到的晕影效"
"果。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:646
msgid ""
"Open up ``Movement_Vignette.tscn``, which you can find in the ``Scenes`` "
"folder. Notice how it is just a :ref:`ColorRect <class_ColorRect>` node with "
"a custom shader. Feel free to look at the custom shader if you want, it is "
"just a slightly modified version of the vignette shader you can find in the "
"Godot demo repository."
msgstr ""
"打开 ``Movement_Vignette.tscn`` ，您可以在 ``Scenes`` 文件夹中找到它。 注意它"
"只是一个 :ref:`ColorRect <class_ColorRect>` 带有自定义着色器的节点。 如果需"
"要，可以随意查看自定义着色器，它只是您可以在Godot演示库中找到的晕影着色器的略"
"微修改版本。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:649
msgid ""
"With ``Movement_Vignette`` selected, make a new script called "
"``Movement_Vignette.gd``. Add the following code to ``Movement_Vignette.gd``:"
msgstr ""
"选择 ``Movement_Vignette`` 后，创建一个名为 ``Movement_Vignette.gd`` 的新脚"
"本。 将以下代码添加到``Movement_Vignette.gd``:"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:686
#, fuzzy
msgid ""
"Because this script is fairly brief, let's quickly go over what it does."
msgstr "因为这个脚本非常简单，所以让我们快速回顾它的作用。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:688
msgid ""
"In ``_ready``, we wait for four frames. We do this to ensure the VR "
"interface is ready and going."
msgstr "在 ``_ready`` 中，我们等待四帧。 我们这样做是为了确保VR界面准备就绪。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:690
msgid ""
"Next, we get the current VR interface, and resize the :ref:`ColorRect "
"<class_ColorRect>` node's size and position so that it covers the entire "
"view in VR."
msgstr ""
"接下来，我们获取当前的VR界面，并调整 :ref:`ColorRect <class_ColorRect>` 节点"
"的大小和位置，以便它覆盖VR中的整个视图。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:692
#, fuzzy
msgid ""
"Then, we get the left and right controllers, assigning them to "
"``controller_one`` and ``controller_two``."
msgstr ""
"然后我们得到左右控制器，将它们分配给 ``controller_one`` 和"
"``controller_two``。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:694
msgid "We then make the vignette invisible by default."
msgstr "然后，我们默认情况下使小插图不可见。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:696
msgid ""
"In ``_process``, we check to see if either of the controllers are moving the "
"player by checking ``directional_movement``. If either controller is moving "
"the player, we make the vignette visible, while if neither controller is "
"moving the player, we make the vignette invisible."
msgstr ""
"在 ``_process`` 中，我们通过检查 ``directional_movement`` 来检查其中一个控制"
"器是否正在移动游戏角色。 如果任一控制器正在移动游戏角色，我们使小插图可见，而"
"如果两个控制器都没有移动游戏角色，我们使小插图不可见。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:701
msgid ""
"With that done, go ahead and try moving around with the joystick and/or the "
"trackpad. You should find it is much less motion sickness-inducing than "
"before!"
msgstr ""
"完成后，继续尝试使用操纵杆和/或触控板。 您应该会发现它比以前少了晕动病！"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:703
msgid ""
"Let's add some special :ref:`RigidBody <class_RigidBody>` nodes we can "
"interact with next."
msgstr ""
"让我们添加一些特殊的 :ref:`RigidBody <class_RigidBody>` 我们可以与下一个交互"
"的节点。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:706
msgid "Adding destroyable targets"
msgstr "添加可销毁的目标"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:708
#, fuzzy
msgid ""
"Firstly, let's start by making some targets we will destroy in various ways "
"with various special :ref:`RigidBody <class_RigidBody>` nodes."
msgstr ""
"首先，让我们从制作一些目标开始，我们将以各种不同的方式销毁各种不同的特殊目"
"标 :ref:`RigidBody <class_RigidBody>` 节点。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:710
msgid ""
"Open up ``Sphere_Target.tscn``, which you can find in the ``Scenes`` folder. "
"``Sphere.tscn`` is just a :ref:`StaticBody <class_StaticBody>` with a :ref:"
"`CollisionShape <class_CollisionShape>`, a mesh, and a audio player."
msgstr ""
"打开 ``Sphere_Target.tscn`` ，您可以在 ``Scenes`` 文件夹中找到它。 ``Sphere."
"tscn``只是一个 :ref:`StaticBody <class_StaticBody>` 带有 :ref:"
"`CollisionShape <class_CollisionShape>`，一个网格和一个音频播放器。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:713
msgid ""
"Select the ``Sphere_Target`` root node, the :ref:`StaticBody "
"<class_StaticBody>` node, and make a new script called ``Sphere_Target.gd``. "
"Add the following to ``Sphere_Target.gd``:"
msgstr ""
"选择 ``Sphere_Target`` 根节点， :ref:`StaticBody <class_StaticBody>` 节点，并"
"创建一个名为 ``Sphere_Target.gd`` 的新脚本。 将以下内容添加到``Sphere_Target."
"gd``:"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:760
msgid "Let's go over how this script works, starting with the class variables."
msgstr "让我们来看看这个脚本的工作原理，从类变量开始。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:762
#, fuzzy
msgid ""
"``destroyed``: A variable to track whether this target is destroyed or not."
msgstr "``destroyed``:一个变量，用于跟踪此目标是否被销毁。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:763
msgid ""
"``destroyed_timer``: A variable to track how long the target has been "
"destroyed."
msgstr "``destroyed_timer``:一个跟踪目标被摧毁多久的变量。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:764
msgid ""
"``DESTROY_WAIT_TIME``: A constant to tell the sphere target how long to wait "
"before destroying/deleting itself."
msgstr ""
"``DESTROY_WAIT_TIME``:一个常数，用于告诉球体目标在销毁/删除自身之前需要等待多"
"长时间。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:765
msgid "``health``: The amount of health the target has."
msgstr "``health``:目标所具有的健康量。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:766
msgid ""
"``RIGID_BODY_TARGET``: The target broken into several smaller :ref:"
"`RigidBody <class_RigidBody>` nodes."
msgstr ""
"``RIGID_BODY_TARGET``:目标分成几个较小的 :ref:`RigidBody <class_RigidBody>` "
"节点。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:770
#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:912
msgid "Let's go over ``_ready``."
msgstr "让我们回顾一下 ``_ready`` 。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:772
msgid ""
"All we are doing in ``_ready`` is setting ``_physics_process`` to ``false``. "
"This is because we will only use ``_physics_process`` for destroying the "
"target, so we do not want to call it until the target is broken."
msgstr ""
"我们在 ``_ready`` 中所做的就是将 ``_physics_process`` 设置为 ``false`` 。 这"
"是因为我们只使用 ``_physics_process`` 来销毁目标，所以我们不想在目标被破坏之"
"前调用它。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:777
msgid "Next, let's go over ``_physics_process``."
msgstr "接下来，让我们回顾一下 ``_physics_process`` 。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:779
#, fuzzy
msgid ""
"Firstly, we add time to ``destroyed_timer``. Then we check to see whether "
"enough time has passed and we can destroy the target. If enough time has "
"passed, we free/destroy the target using ``queue_free``."
msgstr ""
"首先，我们为 ``destroyed_timer`` 增加时间。 然后我们检查是否已经过了足够的时"
"间，我们可以摧毁目标。 如果已经过了足够的时间，我们使用 ``queue_free`` 释放/"
"销毁目标。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:784
msgid "Finally, let's go over ``damage``."
msgstr "最后，让我们回顾一下 ``damage`` 。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:786
#, fuzzy
msgid ""
"Firstly, we check to make sure the target has not already been destroyed."
msgstr "首先，我们检查以确保目标尚未被销毁。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:788
msgid ""
"Then, we remove however much damage the target has taken from the target's "
"health."
msgstr "然后，我们移除了目标从目标生命值中获得的大量伤害。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:790
msgid ""
"If the target has zero or less health, then it has taken enough damage to "
"break."
msgstr "如果目标的生命值为零或更低，则它已经受到足够的破坏。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:792
#, fuzzy
msgid ""
"Firstly, we disable the collision shape and make the whole target mesh "
"invisible. Next, we spawn/instance the :ref:`RigidBody <class_RigidBody>` "
"version of the target, and instance it at this target's position."
msgstr ""
"首先，我们禁用碰撞形状并使整个目标网格不可见。 接下来，我们生成/实例 :ref:"
"`RigidBody <class_RigidBody>` 目标版本，并在此目标位置实例化它。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:795
#, fuzzy
msgid ""
"Then, we set ``destroyed`` to ``true`` and start processing "
"``_physics_process``. Finally, we play a sound, and remove a sphere from "
"``Game.gd`` by calling ``remove_sphere``."
msgstr ""
"然后我们将 ``destroyed`` 设置为 ``true`` 并开始处理 ``_physics_process`` 。 "
"最后，我们播放声音，并通过调用“remove_sphere”来从“Game.gd”中删除一个球体。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:800
msgid ""
"Now, you may have noticed we are calling a function in ``Game.gd`` we have "
"not made yet, so let's fix that!"
msgstr ""
"现在，您可能已经注意到我们正在调用我们尚未制作的“Game.gd”中的函数，所以让我们"
"解决这个问题！"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:802
#, fuzzy
msgid ""
"Firstly, open up ``Game.gd`` and add the following additional class "
"variables:"
msgstr "首先，打开 ``Game.gd`` 并添加以下附加类变量:"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:810
msgid "``spheres_left``: The amount of sphere targets left in the game world."
msgstr "``spheres_left``:游戏世界中留下的球体目标数量。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:811
msgid "``sphere_ui``: A reference to the sphere UI. We will use this later!"
msgstr "``sphere_ui``:对球体UI的引用。 我们稍后会用到这个！"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:813
msgid ""
"Next, we need to add the ``remove_sphere`` function. Add the following to "
"``Game.gd``:"
msgstr ""
"接下来，我们需要添加 ``remove_sphere`` 函数。 将以下内容添加到``Game.gd``:"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:824
#, fuzzy
msgid "What this function does is it subtracts one from ``spheres_left``."
msgstr "这个函数的作用是从 ``spheres_left`` 中删除一个。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:826
#, fuzzy
msgid ""
"Then, it checks to see whether ``sphere_ui`` is not null, and if it is not, "
"then it calls its ``update_ui`` function, passing in the amount of spheres "
"left. We'll add the UI code later in this part."
msgstr ""
"然后它检查 ``sphere_ui`` 是否为空，如果不是，则调用它的 ``update_ui`` 函数，"
"传入球的左边数量。 我们将在本部分后面添加UI代码。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:829
msgid "Now that we have destroyable targets, we need a way to destroy them!"
msgstr "既然我们有可销毁的目标，我们需要一种方法来摧毁它们！"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:832
msgid "Adding a pistol"
msgstr "加一把手枪"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:834
#, fuzzy
msgid ""
"Okay, let's add a pistol. Open up ``Pistol.tscn``, which you will find in "
"the ``Scenes`` folder."
msgstr ""
"好的，让我们添加一把简单的手枪。 打开 ``Pistol.tscn`` ，您可以在 ``Scenes`` "
"文件夹中找到它。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:836
#, fuzzy
msgid ""
"There are a few things to note here. The first thing to note is how "
"everything is rotated. This is to make the pistol rotate correctly when the "
"player grabs it. The other thing to notice is how there is a laser sight "
"mesh, and a flash mesh; both of these do what you'd expect: act as a laser "
"pointer and muzzle flash, respectively."
msgstr ""
"这里有几点需要注意。 首先要注意的是如何旋转一切。 这是为了让游戏角色在抓住手"
"枪时正确旋转。 另外需要注意的是激光瞄准网和闪光网是如何做到的，它们都可以达到"
"您的期望:充当激光指针并分别充当枪口闪光灯。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:839
msgid ""
"The other thing to notice is how there is a :ref:`Raycast <class_Raycast>` "
"node at the end of the pistol. This is what we will be using to calculate "
"where the bullets impact."
msgstr ""
"另一件需要注意的事情是手枪末端有一个 :ref:`Raycast <class_Raycast>` 节点。 这"
"是我们将用于计算子弹影响的位置。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:841
msgid ""
"Now that we have looked at the scene, let's write the code. Select the "
"``Pistol`` root node, the :ref:`RigidBody <class_RigidBody>` node, and make "
"a new script called ``Pistol.gd``. Add the following code to ``Pistol.gd``:"
msgstr ""
"现在我们已经查看了场景，让我们编写代码。 选择 ``Pistol`` 根节点， :ref:"
"`RigidBody <class_RigidBody>` 节点，并创建一个名为 ``Pistol.gd`` 的新脚本。 "
"将以下代码添加到``Pistol.gd``:"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:903
msgid "``flash_mesh``: The mesh used to make the muzzle flash."
msgstr "``flash_mesh``:用于使枪口闪光的网格。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:904
msgid "``FLASH_TIME``: The length of time the muzzle flash is visible."
msgstr "``FLASH_TIME``:枪口闪光可见的时间长度。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:905
msgid ""
"``flash_timer``: A variable to track how long the muzzle flash has been "
"visible."
msgstr "``flash_timer``:一个跟踪枪口闪光可见时间的变量。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:906
msgid "``laser_sight_mesh``: A long rectangular mesh used for the laser sight."
msgstr "``laser_sight_mesh``:用于激光瞄准器的长矩形网格。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:907
msgid "``raycast``: The raycast node used for the pistol firing."
msgstr "``raycast``:用于手枪射击的射线播放节点。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:908
msgid "``BULLET_DAMAGE``: The amount of damage a single bullet does."
msgstr "``BULLET_DAMAGE``:单个子弹造成的伤害量。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:914
msgid ""
"All we are doing here is getting the nodes and assigning them to the proper "
"variables. We also make sure the flash and laser sight meshes are invisible."
msgstr ""
"我们在这里所做的就是获取节点并将它们分配给适当的变量。 我们还确保闪光灯和激光"
"瞄准网不可见。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:919
msgid "Next, let's look at ``_physics_process``."
msgstr "接下来，让我们看看`_physics_process``。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:921
#, fuzzy
msgid ""
"Firstly, we check to see if the flash is visible. We do this by checking to "
"see if ``flash_timer`` is more than zero. This is because ``flash_timer`` "
"will be an inverted timer, a timer that counts down instead of counting up."
msgstr ""
"首先，我们检查闪光灯是否可见。 我们通过检查 ``flash_timer`` 是否大于零来做到"
"这一点。 这是因为 ``flash_timer`` 将是一个倒置计时器，一个计时器倒计时而不是"
"计数。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:924
#, fuzzy
msgid ""
"If ``flash_timer`` is more than zero, we subtract ``delta`` from it and "
"check to see whether it is equal to zero or less. If it is, we make the "
"flash mesh invisible."
msgstr ""
"如果 ``flash_timer`` 大于零，我们从中删除 ``delta`` 并检查它是否等于零或更"
"小。 如果是，我们使闪光网不可见。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:927
#, fuzzy
msgid ""
"This makes it where the flash mesh becomes invisible after ``FLASH_TIME`` "
"many seconds have gone by."
msgstr "这使得闪存网格在“FLASH_TIME”经过许多秒后变得不可见。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:931
#, fuzzy
msgid ""
"Now, let's look at ``interact``, which is called when the trigger button on "
"the VR controller is pressed and the pistol is being held."
msgstr ""
"现在让我们看一下 ``interact`` ，当按下VR控制器上的触发按钮并握住手枪时调用"
"它。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:933
#, fuzzy
msgid ""
"Firstly, we check to see if the flash timer is less than or equal to zero. "
"This check makes it where we cannot fire when the flash is visible, limiting "
"how often the pistol can fire."
msgstr ""
"首先，我们检查闪光定时器是否小于或等于零。 当闪光灯可见时，这个检查使我们无法"
"开火，限制了手枪射击的频率。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:936
msgid ""
"If we can fire, we reset ``flash_timer`` by setting it to ``FLASH_TIME``, "
"and we make the flash mesh visible."
msgstr ""
"如果我们可以触发，我们通过将它设置为“FLASH_TIME”来重置 ``flash_timer`` ，并且"
"我们使flash网格可见。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:938
msgid ""
"We then update the :ref:`Raycast <class_Raycast>` and check to see if it is "
"colliding with anything."
msgstr ""
"然后我们更新 :ref:`Raycast <class_Raycast>` 并检查它是否与任何东西发生碰撞。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:940
#, fuzzy
msgid ""
"If the :ref:`Raycast <class_Raycast>` is colliding with something, we get "
"the collider. We check to see if the collider has the ``damage`` function, "
"and if it does, we call it. If it does not, we then check to see if the "
"collider has the ``apply_impulse`` function, and if it does, we call it "
"after calculating the direction from the :ref:`Raycast <class_Raycast>` to "
"the collider."
msgstr ""
"如果 :ref:`Raycast <class_Raycast>` 与某些东西发生碰撞，我们就会得到对撞机。 "
"我们检查对撞机是否有“损坏”功能，如果有，我们称之为。 如果没有，我们检查对撞机"
"是否具有 ``apply_impulse`` 函数，如果有，我们在计算从 :ref:`Raycast "
"<class_Raycast>` 到对撞机的方向后调用它。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:944
msgid ""
"Finally, regardless of whether the pistol hit something or not, we play the "
"pistol firing sound."
msgstr "最后，无论手枪是否击中，我们都会发出手枪发出的声音。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:948
#, fuzzy
msgid ""
"Finally, let's look at ``picked_up`` and ``dropped``, which are called when "
"the pistol is picked up and dropped, respectively."
msgstr ""
"最后，让我们看一下 ``picked_up`` 和``dropped``，它们分别在拾取和放下手枪时被"
"调用。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:950
msgid ""
"All we are doing in these functions is making the laser pointer visible when "
"the pistol is picked up, and making it invisible when the pistol is dropped."
msgstr ""
"我们在这些功能中所做的就是在拿起手枪时使激光指示器可见，并在手枪掉落时使其不"
"可见。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:956
msgid ""
"With that done, go ahead and give the game a try! If you climb up the stairs "
"and grab the pistols, you should be able to fire at the spheres and they "
"will break!"
msgstr ""
"完成后，继续尝试游戏吧！ 如果您爬上楼梯并抓住手枪，您应该能够在球体上射击并且"
"它们会破裂！"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:959
msgid "Adding a shotgun"
msgstr "添加霰弹枪"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:961
#, fuzzy
msgid ""
"Let's add a different type of weapon :ref:`RigidBody <class_RigidBody>`: a "
"shotgun. This is fairly straightforward, as almost everything is the same as "
"the pistol."
msgstr ""
"让我们添加一种不同类型的射击 :ref:`RigidBody <class_RigidBody>`:霰弹枪。 这很"
"简单，几乎所有东西都和手枪一样。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:963
msgid ""
"Open up ``Shotgun.tscn``, which you can find in ``Scenes``. Notice how "
"everything is more or less the same, but instead of a single :ref:`Raycast "
"<class_Raycast>`, there are five, and there is no laser pointer. This is "
"because a shotgun generally fires in a cone shape, and so we are going to "
"emulate that by having several :ref:`Raycast <class_Raycast>` nodes, all "
"rotated randomly in a cone shape, and I removed the laser pointer so the "
"player has to aim without knowing for sure where the shotgun is pointing."
msgstr ""
"打开 ``Shotgun.tscn`` ，您可以在 ``Scenes`` 找到它。 注意一切都或多或少相同，"
"但不是一个 :ref:`Raycast <class_Raycast>`，有五个，没有激光指针。 这是因为霰"
"弹枪通常以锥形形状发射，因此我们将通过几个 :ref:`Raycast <class_Raycast>` 节"
"点模拟它们，所有节点都以锥形随机旋转，然后我移除了激光指示器 游戏角色必须瞄准"
"而不确定霰弹枪指向的位置。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:968
msgid ""
"Alright, select the ``Shotgun`` root node, the :ref:`RigidBody "
"<class_RigidBody>` and make a new script called ``Shotgun.gd``. Add the "
"following to ``Shotgun.gd``:"
msgstr ""
"好吧，选择 ``Shotgun`` 根节点， :ref:`RigidBody <class_RigidBody>` 并创建一个"
"名为 ``Shotgun.gd`` 的新脚本。 将以下内容添加到``Shotgun.gd``:"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1027
msgid ""
"You may have noticed this is almost exactly the same as the pistol, and "
"indeed it is, so let's only go over what has changed."
msgstr ""
"您可能已经注意到这几乎与手枪完全一样，事实上它也是如此，所以让我们只看看已经"
"改变的东西。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1029
msgid ""
"``raycasts``: The node that holds all of the five :ref:`Raycast "
"<class_Raycast>` nodes used for the shotgun's firing."
msgstr ""
"``raycasts``:包含所有五个节点的节点 :ref:`Raycast <class_Raycast>` 用于霰弹枪"
"射击的节点。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1031
msgid ""
"In ``_ready``, we get the ``Raycasts`` node, instead of just a single :ref:"
"`Raycast <class_Raycast>`."
msgstr ""
"在 ``_ready`` 中，我们得到 ``Raycasts`` 节点，而不只是一个 :ref:`Raycast "
"<class_Raycast>`。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1033
#, fuzzy
msgid ""
"The only other change, besides there being nothing in ``picked_up`` and "
"``dropped``, is in ``interact``."
msgstr ""
"除了在 ``picked_up`` 和``dropped``中没有任何内容之外，唯一的另一个变化是 "
"``interact`` 。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1035
#, fuzzy
msgid ""
"Now we go through each :ref:`Raycast <class_Raycast>` in ``raycasts``. We "
"then rotate it on the X and Z axes, making within a 10 to ``-10`` cone. From "
"there, we process each :ref:`Raycast <class_Raycast>` like we did the "
"single :ref:`Raycast <class_Raycast>` in the pistol, nothing changed at all, "
"we are just doing it five times, once for each :ref:`Raycast "
"<class_Raycast>` in ``raycasts``."
msgstr ""
"现在我们通过每个 :ref:``Raycast <class_Raycast>` 在 ``raycasts`` 中。 然后我"
"们在X轴和Z轴上旋转它，在10到“-10”锥形范围内。 从那里开始，我们处理每个 :ref:"
"`Raycast <class_Raycast>` 就像我们做的那样 :ref:`Raycast <class_Raycast>` 在"
"手枪中，没有任何改变，我们只是做了五次，每次一次 :ref:``raycasts`` 中的"
"`Raycast <class_Raycast>` 。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1041
msgid ""
"Now you can find and fire the shotgun too! The shotgun is located around the "
"back behind one of the walls (not in the building though!)."
msgstr ""
"现在您也可以找到并发射霰弹枪！ 霰弹枪位于其中一个墙后面的后面(虽然不在建筑物"
"中！)。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1044
msgid "Adding a bomb"
msgstr "添加炸弹"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1046
msgid ""
"While both of those are well and good, let's add something we can throw next "
"— a bomb!"
msgstr "虽然这两个都很好，但我们可以添加一些我们可以抛出的东西 - 炸弹！"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1048
msgid "Open up ``Bomb.tscn``, which you will find in the ``Scenes`` folder."
msgstr "打开 ``Bomb.tscn`` ，您可以在 ``Scenes`` 文件夹中找到它。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1050
msgid ""
"First, notice how there is a rather large :ref:`Area <class_Area>` node. "
"This is the explosion radius for the bomb. Anything within this :ref:`Area "
"<class_Area>` will be effected by the explosion when the bomb explodes."
msgstr ""
"首先，注意有一个相当大的 :ref:`Area <class_Area>` 节点。 这是炸弹的爆炸半"
"径。 其中的任何内容 :ref:`Area <class_Area>` 将在炸弹爆炸时受到爆炸的影响。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1053
msgid ""
"The other thing to note is how there are two sets of :ref:`Particles "
"<class_Particles>`: one for smoke coming out of the fuse, and another for "
"the explosion itself. Feel free to take a look at the :ref:`Particles "
"<class_Particles>` nodes if you want!"
msgstr ""
"另外需要注意的是如何有两组 :ref:`Particles <class_Particles>`:一个用于从保险"
"丝中出来的烟雾，另一个用于爆炸本身。 如果需要，请随意查看 :ref:`Particles "
"<class_Particles>` 节点！"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1056
#, fuzzy
msgid ""
"The only thing to notice is how long the explosion :ref:`Particles "
"<class_Particles>` node will last, their lifetime, which is 0.75 seconds. We "
"need to know this so we can time the removal of the bomb with the end of the "
"explosion :ref:`Particles <class_Particles>`."
msgstr ""
"唯一需要注意的是他的爆炸时间 :ref:`Particles <class_Particles>` 节点将持续，"
"它们的生命周期为0.75秒。 我们需要知道这一点，所以我们可以在爆炸结束时抽出炸弹"
"的时间 :ref:`Particles <class_Particles>`。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1059
msgid ""
"Alright, now let's write the code for the bomb. Select the ``Bomb`` :ref:"
"`RigidBody <class_RigidBody>` node and make a new script called ``Bomb.gd``. "
"Add the following code to ``Bomb.gd``:"
msgstr ""
"好的，现在让我们写下炸弹的代码。 选择``Bomb`` :ref:`RigidBody "
"<class_RigidBody>` 节点并创建一个名为 ``Bomb.gd`` 的新脚本。 将以下代码添加到"
"``Bomb.gd``:"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1143
msgid ""
"Let's go through what this script does, starting with the class variables:"
msgstr "让我们来看看这个脚本的作用，从类变量开始:"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1145
msgid ""
"``bomb_mesh``: The :ref:`MeshInstance <class_MeshInstance>` used for the "
"bomb mesh."
msgstr ""
"``bomb_mesh``:用于炸弹网格的 :ref:`MeshInstance <class_MeshInstance>` 。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1146
#, fuzzy
msgid "``FUSE_TIME``: The length of time for which the fuse burns."
msgstr "``FUSE_TIME``:保险丝燃烧的时间长度。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1147
msgid ""
"``fuse_timer``: A variable for tracking how long the fuse has been burning."
msgstr "``fuse_timer``:用于跟踪保险丝燃烧时间的变量。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1148
msgid ""
"``explosion_area``: The :ref:`Area <class_Area>` node used for detecting "
"what nodes are inside the explosion."
msgstr ""
"``explosion_area``: :ref:`Area <class_Area>` 节点，用于检测爆炸内的节点。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1149
msgid "``EXPLOSION_DAMAGE``: The amount of damage the explosion does."
msgstr "``EXPLOSION_DAMAGE``:爆炸造成的伤害量。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1150
msgid ""
"``EXPLOSION_TIME``: The length of time the explosion :ref:`Particles "
"<class_Particles>` take (you can calculate this number by multiplying the "
"particles ``lifetime`` by its ``speed scale``)"
msgstr ""
"``EXPLOSION_TIME``:爆炸的时间长度 :ref:`Particles <class_Particles>` take(您"
"可以通过将粒子 ``lifetime`` 乘以它的``speed scale``来计算这个数字)"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1151
msgid ""
"``explosion_timer``: A variable for tracking how long the explosion has "
"lasted."
msgstr "``explosion_timer``:用于跟踪爆炸持续时间的变量。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1152
msgid "``explode``: A boolean for tracking whether the bomb has exploded."
msgstr "``explode``:用于跟踪炸弹是否爆炸的布尔值。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1153
msgid "``fuse_particles``: The fuse :ref:`Particles <class_Particles>` node."
msgstr "``fuse_particles``:保险丝 :ref:`Particles <class_Particles>` 节点。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1154
msgid ""
"``explosion_particles``: The explosion :ref:`Particles <class_Particles>` "
"node."
msgstr "``explosion_particles``:爆炸 :ref:`Particles <class_Particles>` node。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1155
msgid ""
"``controller``: The controller that is currently holding the bomb, if there "
"is one. This is set by the controller, so we do not need to check anything "
"outside of checking if it is ``null``."
msgstr ""
"``controller``:当前持有炸弹的控制器，如果有的话。 这是由控制器设置的，所以除"
"了检查是否为“null”之外，我们不需要检查任何内容。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1159
msgid "Let's go through ``_ready``."
msgstr "让我们来看看 ``_ready`` 。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1161
#, fuzzy
msgid ""
"Firstly, we get all the nodes and assign them to the proper variables for "
"later use."
msgstr "首先，我们获取所有节点并将它们分配给适当的变量供以后使用。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1163
msgid ""
"Then, we make sure ``_physics_process`` is not going to be called. We do "
"this since we will be using ``_physics_process`` only for the fuse and for "
"destroying the bomb, so we do not want to trigger that early, we only want "
"the fuse to start when the player interacts while holding a bomb."
msgstr ""
"然后，我们确保不会调用 ``_physics_process`` 。 我们这样做是因为我们只使用 "
"``_physics_process`` 作为保险丝和销毁炸弹，所以我们不想早点触发，我们只想让游"
"戏角色在拿着炸弹时进行交互时启动保险丝。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1168
msgid "Now, let's look at ``_physics_process``."
msgstr "现在，让我们看看`_physics_process``。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1170
#, fuzzy
msgid ""
"Firstly we check to see whether ``fuse_timer`` is less than ``FUSE_TIME``. "
"If ``fuse_timer`` is less than ``FUSE_TIME``, then the bomb must be burning "
"down the fuse."
msgstr ""
"首先，我们检查 ``fuse_timer`` 是否小于 ``FUSE_TIME`` 。 如果 ``fuse_timer`` "
"小于 ``FUSE_TIME`` ，那么炸弹必须烧掉保险丝。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1172
#, fuzzy
msgid ""
"We then add time to ``fuse_timer``, and check to see whether the bomb has "
"waited long enough and has burned through the entire fuse."
msgstr ""
"然后我们将时间添加到 ``fuse_timer`` ，并检查炸弹是否已经等待足够长的时间并烧"
"掉整个保险丝。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1174
msgid ""
"If the bomb has waited long enough, then we need to explode the bomb. We do "
"this first by stopping the smoke :ref:`Particles <class_Particles>` from "
"emitting, and making the explosion :ref:`Particles <class_Particles>` emit. "
"We also hide the bomb mesh so it is no longer visible."
msgstr ""
"如果炸弹已经等了足够长的时间，那么我们需要爆炸炸弹。 我们首先停止冒烟 :ref:"
"`Particles <class_Particles>` 来自发射，然后进行爆炸 :ref:`Particles "
"<class_Particles>` emit。 我们还隐藏了炸弹网，使其不再可见。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1177
msgid ""
"Next, we make the set the collision layer and mask to zero, and set the :ref:"
"`RigidBody <class_RigidBody>` mode to static. This makes it where the now "
"exploded bomb cannot interact with the physics world, and so it will stay in "
"place."
msgstr ""
"接下来，我们将碰撞层和掩码设置为零，并将 :ref:`RigidBody <class_RigidBody>` "
"模式设置为static。 这使得它现在爆炸的炸弹无法与物理世界相互作用，因此它将保持"
"原位。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1180
#, fuzzy
msgid ""
"Then, we go through everything inside the explosion :ref:`Area "
"<class_Area>`. We make sure the bodies inside the explosion :ref:`Area "
"<class_Area>` are not the bomb itself, since we do not want to explode the "
"bomb with itself. We then check to see whether the bodies have the "
"``damage`` method/function, and if it does, we call that, while if it does "
"not, we check to see if it has the ``apply_impulse`` method/function, and "
"call that instead."
msgstr ""
"然后我们浏览爆炸内的所有内容 :ref:`Area <class_Area>`。 我们确保爆炸内部的物"
"体 :ref:`Area <class_Area>` 不是炸弹本身，因为我们不想用它自己爆炸炸弹。 然后"
"我们检查一下是否有 ``damage`` 方法/函数，如果是，我们称之为，如果不是，我们检"
"查它是否有 ``apply_impulse`` 方法/函数，并且 打电话给那个。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1184
#, fuzzy
msgid ""
"Then, we set ``explode`` to true since the bomb has exploded, and we play a "
"sound."
msgstr "然后我们将 ``explode`` 设置为true，因为炸弹已爆炸，我们发出声音。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1186
msgid ""
"Next, we check to see if the bomb has exploded, as we need to wait until the "
"explosion :ref:`Particles <class_Particles>` are done."
msgstr ""
"接下来，我们检查炸弹是否爆炸，因为我们需要等到爆炸 :ref:`Particles "
"<class_Particles>` 完成。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1188
msgid ""
"If the bomb has exploded, we add time to ``explosion_timer``. We then check "
"to see if the explosion :ref:`Particles <class_Particles>` are done. If they "
"are, we set the explosion :ref:`Area <class_Area>`'s monitoring property to "
"``false`` to ensure we do not get any bugs in the debugger, we make the "
"controller drop the bomb if it is holding onto it, we make the grab :ref:"
"`Raycast <class_Raycast>` visible if the grab mode is ``RAYCAST``, and we "
"free/destroy the bomb using ``queue_free``."
msgstr ""
"如果炸弹爆炸了，我们就加时间 ``explosion_timer`` 。 然后我们检查是否爆炸 :"
"ref:`Particles <class_Particles>` 完成。 如果它们是，我们设置爆炸 :ref:`Area "
"<class_Area>` 的监视属性为 ``false`` 以确保我们不会在调试器中得到任何错误，我"
"们让控制器丢弃炸弹如果它持有 在它上面，我们制作了抓取 :ref:`Raycast "
"<class_Raycast>` 如果抓取模式是 ``RAYCAST`` 可见，我们使用 ``queue_free`` 释"
"放/销毁炸弹。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1194
msgid "Finally, let's look at ``interact``."
msgstr "最后，让我们看一下 ``interact`` 。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1196
msgid ""
"All we are doing here is making it where ``_physics_process`` will be "
"called, which will start the fuse. We also make the fuse :ref:`Particles "
"<class_Particles>` start emitting, so smoke comes out the top of the bomb."
msgstr ""
"我们在这里所做的只是调用 ``_physics_process`` ，这将启动保险丝。 我们还制作了"
"保险丝 :ref:`Particles <class_Particles>` 开始发射，所以烟雾从炸弹顶部出来。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1201
#, fuzzy
msgid ""
"With that done, the bombs are ready to go! You can find them in the orange "
"building. Because of how we are calculating velocity, it is easiest to throw "
"bombs in a trusting-like motion as opposed to a more natural throwing like "
"motion. The smooth curve of a throwing-like motion is harder to track, and "
"the because of how we are tracking velocity, it does not always work."
msgstr ""
"完成后，炸弹准备好了！ 您可以在橙色建筑中找到它们。 由于我们如何计算速度，最"
"容易投掷类似信任的运动中的炸弹，而不是像运动那样更自然的投掷。 投掷式运动的平"
"滑曲线更难以跟踪，并且由于我们跟踪速度的方式并不总是有效。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1206
msgid "Adding a sword"
msgstr "加一把剑"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1208
msgid "Finally, let's add a sword so we can slice through things!"
msgstr "最后，让我们添加一把剑，这样我们就可以切入一些东西！"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1210
msgid "Open up ``Sword.tscn``, which you will find in ``Scenes``."
msgstr "打开 ``Sword.tscn`` ，您会在 ``Scenes`` 中找到它。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1212
msgid ""
"There is not a whole lot to note here, but there is just one thing, and that "
"is how the length of the blade of the sword is broken into several small :"
"ref:`Area <class_Area>` nodes. This is because we need to roughly know where "
"on the blade the sword collided, and this is the easiest (and only) way I "
"could figure out how to do this."
msgstr ""
"这里没有太多值得注意的，但只有一件事，那就是刀剑的长度被分成几个小的 :ref:"
"`Area <class_Area>` 节点。 这是因为我们需要粗略地知道剑碰撞的刀片在哪里，这是"
"我能弄清楚如何做到这一点的最简单(也是唯一的)方法。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1215
#, fuzzy
msgid ""
"If you know how to find the point where an :ref:`Area <class_Area>` and a :"
"ref:`CollisionObject <class_CollisionObject>` meet, please let me know and/"
"or make a PR on the Godot documentation! This method of using several small :"
"ref:`Area <class_Area>` nodes works okay, but it is not ideal."
msgstr ""
"如果您知道如何找到一个点 :ref:`Area <class_Area>` 和a :ref:`CollisionObject "
"<class_CollisionObject>` 见面，请告诉我和/或在Godot文档上做一个PR！ 这个使用"
"几个小的方法 :ref:`Area <class_Area>` 节点工作正常，但它并不理想。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1218
msgid ""
"Other than that, there really is not much of note, so let's write the code. "
"Select the ``Sword`` root node, the :ref:`RigidBody <class_RigidBody>` and "
"make a new script called ``Sword.gd``. Add the following code to ``Sword."
"gd``:"
msgstr ""
"除此之外，确实没有多少注意事项，所以让我们编写代码。 选择 ``Sword`` 根节"
"点， :ref:`RigidBody <class_RigidBody>` 并创建一个名为 ``Sword.gd`` 的新脚"
"本。 将以下代码添加到``Sword.gd``:"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1283
msgid ""
"Let's go over what this script does, starting with the two class variables:"
msgstr "让我们回顾一下这个脚本的作用，从两个类变量开始:"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1285
msgid "``SWORD_DAMAGE``: The amount of damage a single sword slice does."
msgstr "``SWORD_DAMAGE``:单个剑片所造成的伤害量。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1286
#, fuzzy
msgid ""
"``controller``: The controller that is holding the sword, if there is one. "
"This is set by the controller, so we do not need to set it here, in ``Sword."
"gd``."
msgstr ""
"``controller``:拿着剑的控制器，如果有的话。 这是由控制器设置的，所以我们不需"
"要在 ``Sword.gd`` 中设置它。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1290
msgid "Let's go over ``_ready`` next."
msgstr "让我们接下来回顾一下 ``_ready`` 。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1292
#, fuzzy
msgid ""
"All we are doing here is connecting each of the :ref:`Area <class_Area>` "
"nodes ``body_entered`` signal to the ``body_entered_sword`` function, "
"passing in an additional argument, which will be the number of the damage :"
"ref:`Area <class_Area>`, so we can figure out where on the sword the body "
"collided."
msgstr ""
"我们在这里所做的就是将每个 :ref:`Area <class_Area>` nodes ``body_entered`` 信"
"号连接到 ``body_entered_sword`` 函数，传入一个额外的参数，它将是损坏的数量:"
"ref :`Area <class_Area>`，所以我们可以弄清楚物体碰撞的剑在哪里。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1297
msgid "Now let's go over ``body_entered_sword``."
msgstr "现在让我们回顾一下 ``body_entered_sword`` 。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1299
#, fuzzy
msgid ""
"Firstly, we make sure the body the sword has collided with is not itself."
msgstr "首先，我们确保剑与之碰撞的物体本身并不存在。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1301
msgid ""
"Then we figure out which part of the sword the body collided with, using the "
"passed-in number."
msgstr "然后我们使用传入的数字找出物体碰撞的剑的哪一部分。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1303
#, fuzzy
msgid ""
"Next, we check to see whether the body the sword collided with has the "
"``damage`` function, and if it does, we call it and play a sound."
msgstr ""
"接下来，我们检查剑与剑相撞的物体是否具有“伤害”功能，如果有，我们称之为并发出"
"声音。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1305
#, fuzzy
msgid ""
"If it does not have the damage function, we then check to see whether it has "
"the ``apply_impulse`` function. If it does, we then calculate the direction "
"from the sword part the body collided with to the body. We then check to see "
"whether the sword is being held or not."
msgstr ""
"如果它没有损坏功能，我们检查它是否具有 ``apply_impulse`` 功能。 如果是这样，"
"我们然后计算从物体碰撞的剑部分到物体的方向。 然后我们检查剑是否被关押。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1308
msgid ""
"If the sword is not being held, we use the :ref:`RigidBody "
"<class_RigidBody>`'s velocity as the force in ``apply_impulse``, while if "
"the sword is being held, we use the controller's velocity as the force in "
"the impulse."
msgstr ""
"如果没有持剑，我们使用 :ref:`RigidBody <class_RigidBody>的速度作"
"为“apply_impulse”的力量，而如果持剑，我们使用控制器的速度作为力量 冲动。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1311
msgid "Finally, we play a sound."
msgstr "最后，我们发出声音。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1317
msgid ""
"With that done, you can now slice through the targets! You can find the "
"sword in the corner in between the shotgun and the pistol."
msgstr "完成后，您现在可以切入目标了！ 您可以在霰弹枪和手枪之间的角落找到剑。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1320
msgid "Updating the target UI"
msgstr "更新目标UI"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1322
msgid "Okay, let's update the UI as the sphere targets are destroyed."
msgstr "好吧，让我们在球体目标被破坏时更新UI。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1324
#, fuzzy
msgid ""
"Open up ``Game.tscn`` and then expand the ``GUI`` :ref:`MeshInstance "
"<class_MeshInstance>`. From there, expand the ``GUI`` :ref:`Viewport "
"<class_Viewport>` node and then select the ``Base_Control`` node. Add a new "
"script called ``Base_Control``, and add the following:"
msgstr ""
"打开 ``Game.tscn`` 然后展开``GUI`` :ref:`MeshInstance "
"<class_MeshInstance>`。 从那里，展开``GUI`` :ref:`Viewport <class_Viewport>` "
"节点，然后选择 ``base_control`` 节点。 添加一个名为 ``Base_Control`` 的新脚"
"本，并添加以下内容:"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1345
#, fuzzy
msgid ""
"First, in ``_ready``, we get the :ref:`Label <class_Label>` that shows how "
"many spheres are left and assign it to the ``sphere_count_label`` class "
"variable. Next, we get ``Game.gd`` by using ``get_tree().root`` and assign "
"``sphere_ui`` to this script."
msgstr ""
"首先，在 ``_ready`` 中，我们得到 :ref:`Label <class_Label>` ，显示剩下多少个"
"球体并将其分配给 ``sphere_count_label`` 类变量。 接下来，我们使用 "
"``get_tree().root`` 获得 ``Game.gd`` 并将 ``sphere_ui`` 分配给该脚本。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1348
#, fuzzy
msgid ""
"In ``update_ui``, we change the sphere :ref:`Label <class_Label>`'s text. If "
"there is at least one sphere remaining, we change the text to show how many "
"spheres are still left in the world. If there are no more spheres remaining, "
"we change the text and congratulate the player."
msgstr ""
"在 ``update_ui`` 中，我们改变了球体 :ref:`Label <class_Label>的文本。 如果剩"
"下至少一个球体，我们会更改文本以显示世界上还剩下多少球体。 如果没有更多的球"
"体，我们会更改文字并祝贺游戏角色。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1352
msgid "Adding the final special RigidBody"
msgstr "添加最终的特殊RigidBody"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1354
msgid ""
"Finally, before we finish this tutorial, let's add a way to reset the game "
"while in VR."
msgstr "最后，在我们完成本教程之前，让我们添加一种在VR中重置游戏的方法。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1356
msgid ""
"Open up ``Reset_Box.tscn``, which you will find in ``Scenes``. Select the "
"``Reset_Box`` :ref:`RigidBody <class_RigidBody>` node and make a new script "
"called ``Reset_Box.gd``. Add the following code to ``Reset_Box.gd``:"
msgstr ""
"打开 ``Reset_Box.tscn`` ，您会在 ``Scenes`` 中找到它。 选择``Reset_Box`` :"
"ref:`RigidBody <class_RigidBody>` 节点并创建一个名为 ``Reset_Box.gd`` 的新脚"
"本。 将以下代码添加到``Reset_Box.gd``:"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1396
#, fuzzy
msgid "Let's go over what this does."
msgstr "我们来看看这个脚本的功能。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1398
#, fuzzy
msgid ""
"First, we get the starting global :ref:`Transform <class_Transform>` in "
"``_ready``, and assign it to ``start_transform``. We will use this to reset "
"the position of the reset box every so often."
msgstr ""
"首先，我们在 ``_ready`` 中得到起始全局 :ref:`Transform <class_Transform>` ，"
"并将其赋值给 ``start_transform`` 。 我们将使用它来经常重置复位盒的位置。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1400
msgid ""
"In ``_physics_process``, we check to see if enough time has passed to reset. "
"If it has, we reset the box's :ref:`Transform <class_Transform>` and then "
"reset the timer."
msgstr ""
"在 ``_physics_process`` 中，我们检查是否有足够的时间重置。 如果有，我们重置框"
"的 :ref:`Transform <class_Transform>` 然后重置计时器。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1402
msgid ""
"If the player interacts while holding the reset box, we reset the scene by "
"calling ``get_tree().change_scene`` and passing in the path to the current "
"scene. This resets/restarts the scene completely."
msgstr ""
"如果游戏角色在按住重置框时进行交互，我们通过调用“get_tree()。change_scene``并"
"将路径传递到当前场景来重置场景。 这会完全重置/重新启动场景。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1405
msgid ""
"When the reset box is dropped, we reset the :ref:`Transform "
"<class_Transform>` and timer."
msgstr ""
"当重置框被删除时，我们重置 :ref:`Transform <class_Transform>` 和计时器。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1409
#, fuzzy
msgid ""
"With that done, when you grab and interact with the reset box, the entire "
"scene will reset/restart and you can destroy all the targets again!"
msgstr ""
"完成后，当您抓住并与重置框交互时，整个场景将重置/重新启动，您可以再次销毁所有"
"目标！"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1416
#, fuzzy
msgid "Whew! That was a lot of work. Now you have a VR project!"
msgstr "唷！ 这是很多工作。 现在您有一个相当简单的VR项目！"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1420
msgid ""
"You can download the finished project for this part here: :download:"
"`VR_Starter_Tutorial_Complete.zip <files/VR_Starter_Tutorial_Complete.zip>`"
msgstr ""
"您可以在此处下载此部分的已完成项目: :download:`VR_Starter_Tutorial_Complete."
"zip <files / VR_Starter_Tutorial_Complete.zip>`"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1422
#, fuzzy
msgid ""
"This will hopefully serve as an introduction to making fully-featured VR "
"games in Godot! The code written here can be expanded to make puzzle games, "
"action games, story-based games, and more!"
msgstr ""
"这有望成为在Godot制作功能齐全的VR游戏的介绍！ 这里编写的代码可以扩展为制作益"
"智游戏，动作游戏，基于故事的游戏等等！"

#: ../../docs/tutorials/plugins/editor/index.rst:2
msgid "Editor plugins"
msgstr "编辑器插件"

#: ../../docs/tutorials/plugins/editor/making_plugins.rst:4
msgid "Making plugins"
msgstr "制作插件"

#: ../../docs/tutorials/plugins/editor/making_plugins.rst:7
msgid "About plugins"
msgstr "关于插件"

#: ../../docs/tutorials/plugins/editor/making_plugins.rst:9
#, fuzzy
msgid ""
"A plugin is a great way to extend the editor with useful tools. It can be "
"made entirely with GDScript and standard scenes, without even reloading the "
"editor. Unlike modules, you don't need to create C++ code nor recompile the "
"engine. While this makes plugins less powerful, there are still many things "
"you can do with them. Note that a plugin is similar to any scene you can "
"already make, except it is created using a script to add functionality."
msgstr ""
"插件是用来扩展编辑器功能的好东西。它完全可以靠GDScript和多个标准场景来制作，"
"甚至不用重启编辑器。不像模块，您用不着C++也用不着重新编译引擎。尽管说这样做插"
"件可能比起做模块能搞的功能没那么多，但也能做很多有趣的东西。嘛，插件和您做好"
"的那些场景很像，只是它使用脚本来添加些功能。"

#: ../../docs/tutorials/plugins/editor/making_plugins.rst:16
msgid ""
"This tutorial will guide you through the creation of two simple plugins so "
"you can understand how they work and be able to develop your own. The first "
"will be a custom node that you can add to any scene in the project and the "
"other will be a custom dock added to the editor."
msgstr ""
"这个教程会教您写两个简单的插件来帮助您理解插件如何运作和如何写插件。首先是一"
"个可以往任何场景添加的自定义节点，其次呢，是个可以往编辑器里添加的自定义面"
"板。"

#: ../../docs/tutorials/plugins/editor/making_plugins.rst:22
msgid "Creating a plugin"
msgstr "创建一个插件"

#: ../../docs/tutorials/plugins/editor/making_plugins.rst:24
#, fuzzy
msgid ""
"Before starting, create a new empty project wherever you want. This will "
"serve as a base to develop and test the plugins."
msgstr ""
"在开始前先谁便找个地方创建个空项目。这个空项目是制作和测试我们插件的基础。"

#: ../../docs/tutorials/plugins/editor/making_plugins.rst:27
msgid ""
"The first thing you need to do is to create a new plugin the editor can "
"understand as such. You need two files for that: ``plugin.cfg`` for the "
"configuration and a custom GDScript with the functionality."
msgstr ""
"您要做的第一件事情就是创建个编辑器能理解的新插件。为此您需要创建两个文件:用于"
"配置的 ``plugin.cfg`` 和带着自定义功能的GDScript。"

#: ../../docs/tutorials/plugins/editor/making_plugins.rst:31
msgid ""
"Plugins have a standard path like ``addons/plugin_name`` inside the project "
"folder. For this example, create a folder ``my_custom_node`` inside "
"``addons``. You should end up with a directory structure like this:"
msgstr ""
"插件在项目文件夹中有一个标准路径，像 ``addons / plugin_name`` 。 对于此示例，"
"在 ``addons`` 中创建一个名为 ``my_custom_node`` 文件夹。 您最终应该得到这样的"
"目录结构:"

#: ../../docs/tutorials/plugins/editor/making_plugins.rst:37
msgid ""
"Now, open the script editor, click the **File** menu, choose **New "
"TextFile**, then navigate to the plugin folder and name the file ``plugin."
"cfg``. Add the following structure to ``plugin.cfg``::"
msgstr ""
"现在，打开脚本编辑器，单击 **File** 菜单，选择 **New TextFile** ，然后导航到"
"插件文件夹并命名文件 ``plugin.cfg`` 。 将以下结构添加到 ``plugin.cfg``::"

#: ../../docs/tutorials/plugins/editor/making_plugins.rst:49
msgid ""
"This is a simple INI file with metadata about your plugin. You need to set "
"the name and description so people can understand what it does. Don't forget "
"to add your own name so you can be properly credited. Add a version number "
"so people can see if they have an outdated version; if you are unsure on how "
"to come up with the version number, check out `Semantic Versioning <https://"
"semver.org/>`_. Finally, set the main script file to load when your plugin "
"is active."
msgstr ""
"这是一个简单的INI文件，其中包含有关插件的元数据。 您需要设置名称和描述，以便"
"人们可以理解它的作用。 不要忘记添加自己的名字，以便您可以正确记入。 添加版本"
"号，以便人们可以看到他们是否有过时的版本; 如果您不确定如何提供版本号，请查看 "
"`语义版本控制 <https://semver.org/>`_ 。 最后，设置主插件文件在插件处于活动状"
"态时加载。"

#: ../../docs/tutorials/plugins/editor/making_plugins.rst:57
msgid "The script file"
msgstr "脚本文件"

#: ../../docs/tutorials/plugins/editor/making_plugins.rst:59
msgid ""
"Open the script editor (F3) and create a new GDScript file called "
"``custom_node.gd`` inside the ``my_custom_node`` folder. This script is "
"special and it has two requirements: it must be a ``tool`` script and it has "
"to inherit from :ref:`class_EditorPlugin`."
msgstr ""
"打开脚本编辑器(F3)并在 ``my_custom_node`` 文件夹中创建一个名为 ``custom_node."
"gd`` 的新GDScript文件。 这个脚本是特殊的，它有两个要求:它必须是一个 ``tool`` "
"脚本，它必须继承自 :ref:`class_EditorPlugin`。"

#: ../../docs/tutorials/plugins/editor/making_plugins.rst:64
#, fuzzy
msgid ""
"It's important to deal with initialization and clean-up of resources. A good "
"practice is to use the virtual function :ref:`_enter_tree() "
"<class_Node_method__enter_tree>` to initialize your plugin and :ref:"
"`_exit_tree() <class_Node_method__exit_tree>` to clean it up. You can delete "
"the default GDScript template from your file and replace it with the "
"following structure:"
msgstr ""
"处理资源的初始化和清理很重要。 一个好的做法是使用虚函数 :ref:"
"`_enter_tree()<class_Node_method__enter_tree>` 来初始化您的插件，并且 :ref:"
"`_exit_tree()<class_Node_method__exit_tree>` 来清理它。 您可以从文件中删除默"
"认的GDScript模板，并将其替换为以下结构:"

#: ../../docs/tutorials/plugins/editor/making_plugins.rst:85
msgid "This is a good template to use when creating new plugins."
msgstr "这是创建新插件时使用的好模板。"

#: ../../docs/tutorials/plugins/editor/making_plugins.rst:88
msgid "A custom node"
msgstr "自定义节点"

#: ../../docs/tutorials/plugins/editor/making_plugins.rst:90
msgid ""
"Sometimes you want a certain behavior in many nodes, such as a custom scene "
"or control that can be reused. Instancing is helpful in a lot of cases, but "
"sometimes it can be cumbersome, especially if you're using it in many "
"projects. A good solution to this is to make a plugin that adds a node with "
"a custom behavior."
msgstr ""
"有时您希望在许多节点中存在某种行为，例如可以重复使用的自定义场景或控件。 实例"
"化在很多情况下都很有用，但有时它会很麻烦，特别是如果您在许多项目中使用它。 一"
"个很好的解决方案是创建一个插件，添加一个具有自定义行为的节点。"

#: ../../docs/tutorials/plugins/editor/making_plugins.rst:96
#, fuzzy
msgid ""
"To create a new node type, you can use the function :ref:`add_custom_type() "
"<class_EditorPlugin_method_add_custom_type>` from the :ref:"
"`class_EditorPlugin` class. This function can add new types to the editor "
"(nodes or resources). However, before you can create the type, you need a "
"script that will act as the logic for the type. While that script doesn't "
"have to use the ``tool`` keyword, it can be added so the script runs in the "
"editor."
msgstr ""
"要创建新的节点类型，可以使用来自 :ref:`class_EditorPlugin` 类的 :ref:"
"`add_custom_type() <class_EditorPlugin_method_add_custom_type>` 函数。 此函数"
"可以向编辑器(节点或资源)添加新类型。 但是，在创建类型之前，需要一个脚本作为该"
"类型的逻辑。 虽然该脚本不必使用 ``tool`` 关键字，但可以添加它以便脚本在编辑器"
"中运行。"

#: ../../docs/tutorials/plugins/editor/making_plugins.rst:103
msgid ""
"For this tutorial, we'll create a simple button that prints a message when "
"clicked. For that, we'll need a simple script that extends from :ref:"
"`class_Button`. It could also extend :ref:`class_BaseButton` if you prefer::"
msgstr ""
"在本教程中，我们将创建一个简单的按钮，在单击时打印一条消息。 为此，我们需要一"
"个拓展自 :ref:`class_Button` 的简单脚本。 如果您喜欢，它还可以扩展 :ref:"
"`class_BaseButton` ::"

#: ../../docs/tutorials/plugins/editor/making_plugins.rst:117
msgid ""
"That's it for our basic button. You can save this as ``button.gd`` inside "
"the plugin folder. You'll also need a 16×16 icon to show in the scene tree. "
"If you don't have one, you can grab the default one from the engine and save "
"it in your `addons/my_custom_node` folder as `icon.png`, or use the default "
"Godot logo (`preload(\"res://icon.png\")`). You can also use SVG icons if "
"desired."
msgstr ""
"这是我们的基本按钮。 您可以将其保存为插件文件夹中的 ``button.gd`` 。 您还需要"
"一个16×16图标才能在场景树中显示。 如果您没有，可以从引擎中获取默认值，并将其"
"作为 `icon.png` 保存在 `addons / my_custom_node` 文件夹中，或使用默认的Godot"
"徽标 (`preload(\"res://icon.png\")`)。 如果需要，您还可以使用SVG图标。"

#: ../../docs/tutorials/plugins/editor/making_plugins.rst:125
msgid ""
"Now, we need to add it as a custom type so it shows on the **Create New "
"Node** dialog. For that, change the ``custom_node.gd`` script to the "
"following::"
msgstr ""
"现在，我们需要将其添加为自定义类型，以便在 **创建新节点** 对话框中显示。 为"
"此，将 ``custom_node.gd`` 脚本更改为::"

#: ../../docs/tutorials/plugins/editor/making_plugins.rst:141
msgid ""
"With that done, the plugin should already be available in the plugin list in "
"the **Project Settings**, so activate it as explained in `Checking the "
"results`_."
msgstr ""
"完成后，插件应该已经在 **项目设置** 的插件列表中可用，因此请按照 `Checking "
"the results`_ 中的说明激活它。"

#: ../../docs/tutorials/plugins/editor/making_plugins.rst:144
msgid "Then try it out by adding your new node:"
msgstr "然后通过添加新节点来尝试:"

#: ../../docs/tutorials/plugins/editor/making_plugins.rst:148
#, fuzzy
msgid ""
"When you add the node, you can see that it already has the script you "
"created attached to it. Set a text to the button, save and run the scene. "
"When you click the button, you can see some text in the console:"
msgstr ""
"添加节点时，您可以看到它已经创建了附加到它的脚本。 将文本设置为按钮，保存并运"
"行场景。 单击该按钮时，您可以在控制台中看到一些文本:"

#: ../../docs/tutorials/plugins/editor/making_plugins.rst:155
msgid "A custom dock"
msgstr "自定义窗口"

#: ../../docs/tutorials/plugins/editor/making_plugins.rst:157
msgid ""
"Sometimes, you need to extend the editor and add tools that are always "
"available. An easy way to do it is to add a new dock with a plugin. Docks "
"are just scenes based on Control, so they are created in a way similar to "
"usual GUI scenes."
msgstr ""
"有时，您需要扩展编辑器并添加始终可用的工具。 一种简单的方法是添加一个带插件的"
"新扩展面板。 Docks只是基于Control的场景，因此它们的创建方式与通常的GUI场景类"
"似。"

#: ../../docs/tutorials/plugins/editor/making_plugins.rst:161
msgid ""
"Creating a custom dock is done just like a custom node. Create a new "
"``plugin.cfg`` file in the ``addons/my_custom_dock`` folder, then add the "
"following content to it::"
msgstr ""
"创建自定义停靠就像自定义节点一样。 在 ``addons / my_custom_dock`` 文件夹中创"
"建一个新的 ``plugin.cfg`` 文件，然后将以下内容添加到其中::"

#: ../../docs/tutorials/plugins/editor/making_plugins.rst:173
msgid ""
"Then create the script ``custom_dock.gd`` in the same folder. Fill it with "
"the :ref:`template we've seen before <doc_making_plugins_template_code>` to "
"get a good start."
msgstr ""
"然后在同一文件夹中创建脚本 ``custom_dock.gd`` 。 使用 :ref:`template we've "
"seen before <doc_making_plugins_template_code>` 填充它以获得良好的开端。"

#: ../../docs/tutorials/plugins/editor/making_plugins.rst:177
msgid ""
"Since we're trying to add a new custom dock, we need to create the contents "
"of the dock. This is nothing more than a standard Godot scene: just create a "
"new scene in the editor then edit it."
msgstr ""
"由于我们正在尝试添加新的自定义窗口，因此我们需要创建窗口的内容。 这只不过是一"
"个标准的Godot场景:只需在编辑器中创建一个新场景然后编辑它。"

#: ../../docs/tutorials/plugins/editor/making_plugins.rst:181
msgid ""
"For an editor dock, the root node **must** be a :ref:`Control "
"<class_Control>` or one of its child classes. For this tutorial, you can "
"create a single button. The name of the root node will also be the name that "
"appears on the dock tab, so be sure to give it a short and descriptive name. "
"Also, don't forget to add some text to your button."
msgstr ""
"对于编辑器停靠站，根节点 **必须是** :ref:`Control <class_Control>` 或其子类之"
"一。 在本教程中，您可以创建一个按钮。 根节点的名称也将是面板对话框中显示的名"
"称，因此请务必为其指定一个简短的描述性名称。 另外，不要忘记在按钮上添加一些文"
"字。"

#: ../../docs/tutorials/plugins/editor/making_plugins.rst:189
#, fuzzy
msgid ""
"Save this scene as ``my_dock.tscn``. Now, we need to grab the scene we "
"created then add it as a dock in the editor. For this, you can rely on the "
"function :ref:`add_control_to_dock() "
"<class_EditorPlugin_method_add_control_to_dock>` from the :ref:`EditorPlugin "
"<class_EditorPlugin>` class."
msgstr ""
"将此场景另存为 ``my_dock.tscn``。 现在，我们需要抓住刚创建的场景，然后将其添"
"加为编辑器中的停靠点。 为此，您可以依赖来自 :ref:`EditorPlugin "
"<class_EditorPlugin>` 类的函数 :ref:`add_control_to_dock() "
"<class_EditorPlugin_method_add_control_to_dock>` 。"

#: ../../docs/tutorials/plugins/editor/making_plugins.rst:194
msgid ""
"You need to select a dock position and define the control to add (which is "
"the scene you just created). Don't forget to **remove the dock** when the "
"plugin is deactivated. The script could look like this::"
msgstr ""
"您需要选择停靠位置并定义要添加的控件(这是您刚刚创建的场景)。 插件取消激活时，"
"不要忘记 **移除窗口** 。 该脚本看起来像这样::"

#: ../../docs/tutorials/plugins/editor/making_plugins.rst:221
#, fuzzy
msgid ""
"Note that, while the dock will initially appear at its specified position, "
"the user can freely change its position and save the resulting layout."
msgstr ""
"请注意，虽然扩展面板最初将显示在其指定位置，但用户可以自由更改其位置并保存生"
"成的布局。"

#: ../../docs/tutorials/plugins/editor/making_plugins.rst:225
msgid "Checking the results"
msgstr "检查结果"

#: ../../docs/tutorials/plugins/editor/making_plugins.rst:227
msgid ""
"It's now time to check the results of your work. Open the **Project "
"Settings** and click on the **Plugins** tab. Your plugin should be the only "
"one on the list. If it is not showing, click on the **Update** button in the "
"top-right corner."
msgstr ""
"现在是检查工作结果的时候了。 打开 **项目设置** ，然后单击 **插件** 选项卡。 "
"您的插件应该是列表中唯一的插件。 如果未显示，请单击右上角的 **更新** 按钮。"

#: ../../docs/tutorials/plugins/editor/making_plugins.rst:234
msgid ""
"You can see the plugin is inactive on the **Status** column; click on the "
"status to select **Active**. The dock should become visible before you even "
"close the settings window. You should now have a custom dock:"
msgstr ""
"您可以在 **Status** 列中看到该插件处于非激活状态; 点击状态选择 **Active** 。 "
"在您关闭设置窗口之前，该扩展窗口应该可见。 您现在应该看到一个自定义窗口:"

#: ../../docs/tutorials/plugins/editor/making_plugins.rst:241
msgid "Going beyond"
msgstr "举一反三"

#: ../../docs/tutorials/plugins/editor/making_plugins.rst:243
msgid ""
"Now that you've learned how to make basic plugins, you can extend the editor "
"in several ways. Lots of functionality can be added to the editor with "
"GDScript; it is a powerful way to create specialized editors without having "
"to delve into C++ modules."
msgstr ""
"现在您已经学会了如何制作基本插件，您可以通过多种方式扩展编辑器。 可以使用"
"GDScript将许多功能添加到编辑器中; 它是一种创建专业编辑器的强大方法，无需深入"
"研究C++模块。"

#: ../../docs/tutorials/plugins/editor/making_plugins.rst:248
msgid ""
"You can make your own plugins to help yourself and share them in the `Asset "
"Library <https://godotengine.org/asset-library/>`_ so that people can "
"benefit from your work."
msgstr ""
"您可以制作自己的插件来帮助自己或在 `资源馆 <https://godotengine.org/asset-"
"library/>`_ 中分享它们，以便人们可以从您的工作中受益。"

#: ../../docs/tutorials/plugins/editor/making_main_screen_plugins.rst:4
#, fuzzy
msgid "Making main screen plugins"
msgstr "制作插件"

#: ../../docs/tutorials/plugins/editor/making_main_screen_plugins.rst:7
#, fuzzy
msgid "What this tutorial covers"
msgstr "观看教程"

#: ../../docs/tutorials/plugins/editor/making_main_screen_plugins.rst:9
msgid ""
"As seen in the :ref:`doc_making_plugins` page, making a basic plugin that "
"extends the editor is fairly easy. This plugin mechanism also allows you to "
"create new UIs in the central part of the editor, similarly to the basic 2D, "
"3D, Script and AssetLib views. Such editor plugins are referred as \"Main "
"screen plugins\"."
msgstr ""

#: ../../docs/tutorials/plugins/editor/making_main_screen_plugins.rst:15
msgid ""
"This tutorial leads you through the creation of a basic main screen plugin. "
"With this plugin example, we want to demonstrate:"
msgstr ""

#: ../../docs/tutorials/plugins/editor/making_main_screen_plugins.rst:18
#, fuzzy
msgid "Creating a main screen plugin"
msgstr "创建一个简单的插件"

#: ../../docs/tutorials/plugins/editor/making_main_screen_plugins.rst:19
msgid ""
"Linking the main screen to another plugin GUI element (such as a Tab panel, "
"similar to the Inspector tab)"
msgstr ""

#: ../../docs/tutorials/plugins/editor/making_main_screen_plugins.rst:22
msgid ""
"For the sake of simplicity, the two GUI elements of our main screen plugin "
"will both consist in a Label and a Button. Pressing one element's button "
"will display some text on the other's label node."
msgstr ""

#: ../../docs/tutorials/plugins/editor/making_main_screen_plugins.rst:27
#, fuzzy
msgid "Initializing the plugin"
msgstr "初始化网络"

#: ../../docs/tutorials/plugins/editor/making_main_screen_plugins.rst:29
msgid ""
"The plugin itself is a Godot project. It is best to set its contents in an "
"``addons/my_plugin_name/`` structure. The only files that lie in the root "
"folder are the project.godot file, and the project icon."
msgstr ""

#: ../../docs/tutorials/plugins/editor/making_main_screen_plugins.rst:33
msgid ""
"In the ``addons/my_plugin_name/`` folder, we create the ``plugin.cfg`` file "
"as described in the :ref:`doc_making_plugins` page."
msgstr ""

#: ../../docs/tutorials/plugins/editor/making_main_screen_plugins.rst:45
msgid ""
"We also initialize the file targeted by the ``script=`` property of the ``."
"cfg`` file. In our example, ``main_screen_plugin.gd``."
msgstr ""

#: ../../docs/tutorials/plugins/editor/making_main_screen_plugins.rst:68
msgid ""
"The important part in this script is the ``has_main_screen()`` function, "
"which is overloaded so it returns true. This function is automatically "
"called by the editor on plugin activation, to tell it that this plugin adds "
"a new center view to the editor. For now, we'll leave this script as-is and "
"we'll come back to it later."
msgstr ""

#: ../../docs/tutorials/plugins/editor/making_main_screen_plugins.rst:77
msgid ""
"The ``main_screen_plugin.gd`` file will be responsible for each of our "
"plugin's UI element instantiation, and it will also manage the communication "
"between them."
msgstr ""

#: ../../docs/tutorials/plugins/editor/making_main_screen_plugins.rst:80
msgid ""
"As a matter of fact, we wish to design each UI element in their own scene. "
"Different scenes are not aware of each other unless they are both children "
"of a parent scene, yet they will then require ``get_node(\"../brother\")`` "
"accessors. Such practice is more likely to produce errors at runtime, "
"especially if these scenes do not share the same parent node. This is why, "
"they should only be allowed to access their children."
msgstr ""

#: ../../docs/tutorials/plugins/editor/making_main_screen_plugins.rst:87
msgid ""
"So, in order to communicate information to another scene, the best design is "
"to define signals. If a user action in a UI scene #1 has to trigger "
"something in another UI scene #2, then this user action has to emit a signal "
"from scene #1, and scene #2 will be connected to that signal. Since all of "
"our UI scenes will be instanced by ``main_screen_plugin.gd`` script, this "
"one script will also connect each of them to the required signals."
msgstr ""

#: ../../docs/tutorials/plugins/editor/making_main_screen_plugins.rst:94
msgid ""
"If the ``main_screen_plugin.gd`` instantiates the UI scenes, won't they be "
"brothers nodes then?"
msgstr ""

#: ../../docs/tutorials/plugins/editor/making_main_screen_plugins.rst:97
msgid ""
"Not necessarily: this script may add all UI scenes as children of the same "
"node of the editor's scene tree - but maybe it won't. And the "
"``main_screen_plugin.gd`` script will *not* be the parent node of any "
"instantiated scene because it is a script, not a node! This script will only "
"hold references to instantiated scenes."
msgstr ""

#: ../../docs/tutorials/plugins/editor/making_main_screen_plugins.rst:104
#, fuzzy
msgid "Main screen scene"
msgstr "主场景"

#: ../../docs/tutorials/plugins/editor/making_main_screen_plugins.rst:106
msgid ""
"Create a new scene with a ``Panel`` root node. Select this root node and, in "
"the viewport, click the ``Layout`` menu and select ``Full Rect``. The panel "
"now uses all the space available in the viewport. Now, let's add a new "
"script on the root node. Name it ``main_panel.gd``."
msgstr ""

#: ../../docs/tutorials/plugins/editor/making_main_screen_plugins.rst:111
msgid ""
"We then add 2 children to this Panel node: first a ``Button`` node. Place it "
"anywhere on the Panel."
msgstr ""

#: ../../docs/tutorials/plugins/editor/making_main_screen_plugins.rst:114
msgid ""
"Now we need to define a behaviour when this button is pressed. This is "
"covered by the :ref:`Handling a signal <doc_scripting_handling_a_signal>` "
"page, so this part will not be described in details in this tutorial. Select "
"the Button node and click the ``Node`` side dock. Select the ``pressed()`` "
"signal and click the ``Connect`` button (you can also double-click the "
"``pressed()`` signal instead). In the window that opened, select the Panel "
"node (we will centralize all behaviors in its attached script). Keep the "
"default function name, make sure that the ``Make function`` toggle is ON and "
"hit ``Connect``. This creates an ``on_Button_pressed()`` function in the "
"``main_panel.gd`` script, that will be called every time the button is "
"pressed."
msgstr ""

#: ../../docs/tutorials/plugins/editor/making_main_screen_plugins.rst:126
msgid ""
"As the button gets pressed, we want the side-panel's ``Label`` node to show "
"a specific text. As explained above, we cannot directly access the target "
"scene, so we'll emit a signal instead. The ``main_screen_plugin.gd`` script "
"will then connect this signal to the target scene. Let's continue in the "
"``main_panel.gd`` script:"
msgstr ""

#: ../../docs/tutorials/plugins/editor/making_main_screen_plugins.rst:142
msgid ""
"In the same way, this main scene's Label node has to show a value when it "
"receives a specific signal. Let's create a new "
"``_on_side_button_pressed(text_to_show)`` function for this purpose:"
msgstr ""

#: ../../docs/tutorials/plugins/editor/making_main_screen_plugins.rst:151
msgid ""
"We are done for the main screen panel. Save the scene as ``main_panel.tscn``."
msgstr ""

#: ../../docs/tutorials/plugins/editor/making_main_screen_plugins.rst:154
#, fuzzy
msgid "Tabbed panel scene"
msgstr "准备场景"

#: ../../docs/tutorials/plugins/editor/making_main_screen_plugins.rst:156
msgid ""
"The tabbed panel scene is almost identical to the main panel scene. You can "
"either duplicate the ``main_panel.tscn`` file and name the new file "
"``side_panel.tscn``, or re-create it from a new scene by following the "
"previous section again. However, you will have to create a new script and "
"attach it to the Panel root node. Save it as ``side_panel.gd``. Its content "
"is slightly different, as the signal emitted and the target function have "
"different names. Here is the script's full content:"
msgstr ""

#: ../../docs/tutorials/plugins/editor/making_main_screen_plugins.rst:178
msgid "Connecting the two scenes in the plugin script"
msgstr ""

#: ../../docs/tutorials/plugins/editor/making_main_screen_plugins.rst:180
msgid ""
"We now need to update the ``main_screen_plugin.gd`` script so the plugin "
"instances our 2 GUI scenes and places them at the right places in the "
"editor. Here is the full ``main.gd``:"
msgstr ""

#: ../../docs/tutorials/plugins/editor/making_main_screen_plugins.rst:229
msgid ""
"A couple of specific lines were added. First, we defined the constants that "
"contain our 2 GUI packed scenes (``MainPanel`` and ``SidePanel``). We will "
"use these resources to instance both scenes."
msgstr ""

#: ../../docs/tutorials/plugins/editor/making_main_screen_plugins.rst:233
msgid ""
"The ``_enter_tree()`` function is called before ``_ready()``. This is where "
"we actually instance the 2 GUI scenes, and add them as children of specific "
"parts of the editor. The side panel case is similar to the example shown in :"
"ref:`doc_making_plugins` page: we add the scene in an editor dock. We "
"specified it will be placed in the left-side dock, upper-left tab."
msgstr ""

#: ../../docs/tutorials/plugins/editor/making_main_screen_plugins.rst:239
msgid ""
"``EditorPlugin`` class does not provide any function to add an element in "
"the main viewport. We thus have to use the ``get_editor_interface()."
"get_editor_viewport()`` to obtain this viewport and add our main panel "
"instance as a child to it. We call the ``make_visible(false)`` function to "
"hide the main panel so it is not directly shown when first activating the "
"plugin."
msgstr ""

#: ../../docs/tutorials/plugins/editor/making_main_screen_plugins.rst:246
msgid ""
"The ``_exit_tree()`` is pretty straightforward. It is automatically called "
"when the plugin is deactivated. It is then important to ``queue_free()`` the "
"elements previously instanced to preserve memory. If you don't, the elements "
"will effectively be invisible in the editor, but they will remain present in "
"the memory. Multiple de-activations/re-activations will then increase memory "
"usage without any way to free it, which is not good."
msgstr ""

#: ../../docs/tutorials/plugins/editor/making_main_screen_plugins.rst:253
msgid ""
"Finally the ``make_visible()`` function is overridden to hide or show the "
"main panel as needed. This function is automatically called by the editor "
"when the user clicks on another main viewport button such as 2D, 3D or "
"Script."
msgstr ""

#: ../../docs/tutorials/plugins/editor/making_main_screen_plugins.rst:258
#, fuzzy
msgid "Try the plugin"
msgstr "试试这个插件"

#: ../../docs/tutorials/plugins/editor/making_main_screen_plugins.rst:260
msgid ""
"Activate the plugin in the Project Settings. You'll observe a new button "
"next to 2D, 3D, Script above the main viewport. You'll also notice a new tab "
"in the left dock. Try to click the buttons in both side and main panels: "
"events are emitted and caught by the corresponding target scene to change "
"the Label caption inside it."
msgstr ""

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:4
msgid "Import plugins"
msgstr "导入插件"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:9
msgid ""
"An import plugin is a special type of editor tool that allows custom "
"resources to be imported by Godot and be treated as first-class resources. "
"The editor itself comes bundled with a lot of import plugins to handle the "
"common resources like PNG images, Collada and glTF models, OGG Vorbis "
"sounds, and many more."
msgstr ""
"导入插件是一种特殊类型的编辑器工具，它允许Godot导入自定义资源并将其视为一级资"
"源。 编辑器本身捆绑了许多导入插件来处理常见资源，如PNG图像，Collada和glTF模"
"型，OGG Vorbis声音等等。"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:14
msgid ""
"This tutorial will show you how to create a simple import plugin to load a "
"custom text file as a material resource. This text file will contain three "
"numeric values separated by comma, which represents the three channels of a "
"color, and the resulting color will be used as the albedo (main color) of "
"the imported material."
msgstr ""
"本教程将向您展示如何创建一个简单的导入插件，以将自定义文本文件作为材质资源加"
"载。 此文本文件将包含由逗号分隔的三个数值，它表示颜色的三个通道，并且生成的颜"
"色将用作导入材质的反照率(主颜色)。"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:20
msgid ""
"This tutorial assumes you already know how to make generic plugins. If in "
"doubt, refer to the :ref:`doc_making_plugins` page. This also assumes you "
"are acquainted with Godot's import system."
msgstr ""
"本教程假设您已经知道如何制作通用插件。 如有疑问，请参阅 :ref:"
"`doc_making_plugins` 页面。 这也假设您熟悉Godot的导入系统。"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:24
msgid ""
"The sample file to import contains only a line representing the pure blue "
"color (zero red, zero green, and full blue):"
msgstr "要导入的示例文件仅包含表示纯蓝色(零红色，零绿色和全蓝色)的线条:"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:32
msgid "Configuration"
msgstr "配置"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:34
msgid ""
"First we need a generic plugin that will handle the initialization and "
"destruction of our import plugin. Let's add the ``plugin.cfg`` file first:"
msgstr ""
"首先，我们需要一个通用插件来处理导入插件的初始化和销毁。 让我们先添加 "
"``plugin.cfg`` 文件:"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:47
msgid ""
"Then we need the ``material_import.gd`` file to add and remove the import "
"plugin when needed:"
msgstr "然后我们需要 ``material_import.gd`` 文件来在需要时添加和删除导入插件:"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:66
#, fuzzy
msgid ""
"When this plugin is activated, it will create a new instance of the import "
"plugin (which we'll soon make) and add it to the editor using the :ref:"
"`add_import_plugin() <class_EditorPlugin_method_add_import_plugin>` method. "
"We store a reference to it in a class member ``import_plugin`` so we can "
"refer to it later when removing it. The :ref:`remove_import_plugin() "
"<class_EditorPlugin_method_remove_import_plugin>` method is called when the "
"plugin is deactivated to clean up the memory and let the editor know the "
"import plugin isn't available anymore."
msgstr ""
"当这个插件被激活时，它将创建一个导入插件的新实例(我们将很快制作)并使用 :ref:"
"`add_import_plugin() <class_EditorPlugin_method_add_import_plugin>` 方法将其"
"添加到编辑器中。 我们在类成员 ``import_plugin`` 中存储对它的引用，所以我们可"
"以在以后删除它时引用它。 插件停用后，调用 :ref:`remove_import_plugin() "
"<class_EditorPlugin_method_remove_import_plugin>` 方法清理内存，让编辑器知道"
"导入插件不再可用。"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:75
msgid ""
"Note that the import plugin is a reference type  so it doesn't need to be "
"explicitly released from the memory with the ``free()`` function. It will be "
"released automatically by the engine when it goes out of scope."
msgstr ""
"请注意，import插件是一个引用类型，因此不需要使用 ``free()`` 函数从内存中显式"
"释放它。 它会在超出范围时由引擎自动释放。"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:80
msgid "The EditorImportPlugin class"
msgstr "EditorImportPlugin类"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:82
#, fuzzy
msgid ""
"The main character of the show is the :ref:`EditorImportPlugin class "
"<class_EditorImportPlugin>`. It is responsible to implement the methods that "
"are called by Godot when it needs to know how to deal with files."
msgstr ""
"本次展示的主角是 :ref:`EditorImportPlugin class "
"<class_EditorImportPlugin>`。 当需要知道如何处理文件时，它负责实现Godot调用的"
"方法。"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:87
msgid "Let's begin to code our plugin, one method at time:"
msgstr "让我们开始编写我们的插件，一个方法:"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:98
#, fuzzy
msgid ""
"The first method is the :ref:"
"`get_importer_name()<class_EditorImportPlugin_method_get_importer_name>`. "
"This is a unique name to your plugin that is used by Godot to know which "
"import was used in a certain file. When the files needs to be reimported, "
"the editor will know which plugin to call."
msgstr ""
"第一种方法是 :ref:"
"`get_importer_name()<class_EditorImportPlugin_method_get_importer_name>`。 这"
"是您的插件的唯一名称，Godot使用该名称来了解在某个文件中使用了哪个导入。 当需"
"要重新导入文件时，编辑器将知道要调用哪个插件。"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:109
#, fuzzy
msgid ""
"The :ref:"
"`get_visible_name()<class_EditorImportPlugin_method_get_visible_name>` "
"method is responsible to inform the name of the type it imports and will be "
"shown to the user in the Import dock."
msgstr ""
":ref:`get_visible_name()<class_EditorImportPlugin_method_get_visible_name>` "
"方法负责通知它导入的类型的名称，并将在Import 面板中显示给用户。"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:113
msgid ""
"You should choose this name as a continuation to \"Import as\". Eg. *"
"\"Import as Silly Material\"*. Yes, this one is a bit silly, but you "
"certainly can come up with a descriptive name for your plugin."
msgstr ""
"您应该选择此名称作为“导入为”的延续。 例如。 *“以傻瓜材质进口”*。 是的，这个有"
"点傻，但您肯定可以为您的插件找到一个描述性的名字。"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:122
#, fuzzy
msgid ""
"Godot's import system detects file types by their extension. In the :ref:"
"`get_recognized_extensions()<class_EditorImportPlugin_method_get_recognized_extensions>` "
"method you return an array of strings to represent each extension that this "
"plugin can understand. If an extension is recognized by more than one "
"plugin, the user can select which one to use when importing the files."
msgstr ""
"Godot的导入系统通过扩展来检测文件类型。 在 :ref:"
"`get_recognized_extensions()<class_EditorImportPlugin_method_get_recognized_extensions>` "
"方法中，您返回一个字符串数组来表示此插件可以理解的每个扩展名。 如果扩展程序被"
"多个插件识别，则用户可以选择导入文件时使用的插件。"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:128
msgid ""
"Common extensions like ``.json`` and ``.txt`` might be used by many plugins. "
"Also, there could be files in the project that are just data for the game "
"and should not be imported. You have to be careful when importing to "
"validate the data. Never expect the file to be well-formed."
msgstr ""
"许多插件可能会使用像 ``.json`` 和 ``.txt`` 这样的常见扩展。 此外，项目中可能"
"存在仅作为游戏数据的文件，不应导入。 导入时必须小心以验证数据。 永远不要指望"
"文件格式正确。"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:138
msgid ""
"The imported files are saved in the ``.import`` folder at the project's "
"root. Their extension should match the type of resource you are importing, "
"but since Godot can't tell what you'll use (because there might be multiple "
"valid extensions for the same resource), you need to inform what will be the "
"used in the import."
msgstr ""
"导入的文件保存在项目根目录的 ``.import`` 文件夹中。 它们的扩展名应该与您导入"
"的资源类型相匹配，但由于Godot无法告诉您将使用的内容(因为同一资源可能有多个有"
"效扩展名)，您需要告知导入中使用的内容。"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:144
msgid ""
"Since we're importing a Material, we'll use the special extension for such "
"resource types. If you are importing a scene, you can use ``scn``. Generic "
"resources can use the ``res`` extension. However, this is not enforced in "
"any way by the engine."
msgstr ""
"由于我们正在导入材质，因此我们将对此类资源类型使用特殊扩展。 如果要导入场景，"
"可以使用 ``scn`` 。 通用资源可以使用 ``res`` 扩展名。 但是，引擎不会以任何方"
"式强制执行此操作。"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:154
msgid ""
"The imported resource has a specific type, so the editor can know which "
"property slot it belongs to. This allows drag and drop from the FileSystem "
"dock to a property in the Inspector."
msgstr ""
"导入的资源具有特定类型，因此编辑器可以知道它属于哪个属性槽。 这允许从"
"FileSystem停靠点拖放到Inspector中的属性。"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:158
msgid ""
"In our case it's a :ref:`class_SpatialMaterial`, which can be applied to 3D "
"objects."
msgstr "在我们的示例中，它是 :ref:`class_SpatialMaterial`，可以应用于3D对象。"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:161
msgid ""
"If you need to import different types from the same extension, you have to "
"create multiple import plugins. You can abstract the import code on another "
"file to avoid duplication in this regard."
msgstr ""
"如果需要从同一扩展中导入不同类型，则必须创建多个导入插件。 您可以在另一个文件"
"上抽象导入代码，以避免在这方面出现重复。"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:166
msgid "Options and presets"
msgstr "选项和预设"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:168
msgid ""
"Your plugin can provide different options to allow the user to control how "
"the resource will be imported. If a set of selected options is common, you "
"can also create different presets to make it easier for the user. The "
"following image shows how the options will appear in the editor:"
msgstr ""
"您的插件可以提供不同的选项，以允许用户控制资源的导入方式。 如果一组选定的选项"
"很常见，您还可以创建不同的预设以使用户更容易。 下图显示了选项在编辑器中的显示"
"方式:"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:175
msgid ""
"Since there might be many presets and they are identified with a number, "
"it's a good practice to use an enum so you can refer to them using names."
msgstr ""
"由于可能有许多预设并且它们用数字标识，因此使用枚举是一个很好的做法，因此您可"
"以使用名称来引用它们。"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:187
msgid ""
"Now that the enum is defined, let's keep looking at the methods of an import "
"plugin:"
msgstr "既然定义了枚举，让我们继续看一下导入插件的方法:"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:195
#, fuzzy
msgid ""
"The :ref:`get_preset_count() "
"<class_EditorImportPlugin_method_get_preset_count>` method returns the "
"amount of presets that this plugins defines. We only have one preset now, "
"but we can make this method future-proof by returning the size of our "
"``Presets`` enumeration."
msgstr ""
":ref:`get_preset_count() <class_EditorImportPlugin_method_get_preset_count>` "
"方法返回此插件定义的预设量。 我们现在只有一个预设，但我们可以通过返回 "
"``Presets`` 枚举的大小来使这个方法面向未来。"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:210
#, fuzzy
msgid ""
"Here we have the :ref:`get_preset_name() "
"<class_EditorImportPlugin_method_get_preset_name>` method, which gives names "
"to the presets as they will be presented to the user, so be sure to use "
"short and clear names."
msgstr ""
"这里我们有 :ref:`get_preset_name() "
"<class_EditorImportPlugin_method_get_preset_name>` 方法，它为预设提供名称，因"
"为它们将呈现给用户，因此请务必使用简短明了的名称。"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:215
msgid ""
"We can use the ``match`` statement here to make the code more structured. "
"This way it's easy to add new presets in the future. We use the catch all "
"pattern to return something too. Although Godot won't ask for presets beyond "
"the preset count you defined, it's always better to be on the safe side."
msgstr ""
"我们可以在这里使用 ``match`` 语句来使代码更加结构化。 这样，将来很容易添加新"
"的预设。 我们使用catch all模式来返回一些东西。 虽然Godot不会要求超出您定义的"
"预设计数的预设，但最好是安全起见。"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:220
msgid ""
"If you have only one preset you could simply return its name directly, but "
"if you do this you have to be careful when you add more presets."
msgstr ""
"如果您只有一个预设，则可以直接返回其名称，但如果您这样做，则在添加更多预设时"
"必须小心。"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:235
#, fuzzy
msgid ""
"This is the method which defines the available options. :ref:"
"`get_import_options() <class_EditorImportPlugin_method_get_import_options>` "
"returns an array of dictionaries, and each dictionary contains a few keys "
"that are checked to customize the option as its shown to the user. The "
"following table shows the possible keys:"
msgstr ""
"这是定义可用选项的方法。 :ref:`get_import_options() "
"<class_EditorImportPlugin_method_get_import_options>` 返回一个字典数组，每个"
"字典包含一些键，这些键被检查以自定义向用户显示的选项。 下表显示了可能的键:"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:242
msgid "Key"
msgstr "键"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:244
msgid "``name``"
msgstr "``name``"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:244
msgid ""
"The name of the option. When showed, underscores become spaces and first "
"letters are capitalized."
msgstr "选项的名称。 显示时，下划线变为空格，首字母大写。"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:246
msgid "``default_value``"
msgstr "``default_value``"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:246
msgid "Any"
msgstr "任何类型"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:246
msgid "The default value of the option for this preset."
msgstr "此预设的选项的默认值。"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:248
msgid "``property_hint``"
msgstr "``property_hint``"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:248
#: ../../docs/tutorials/plugins/editor/import_plugins.rst:252
msgid "Enum value"
msgstr "枚举值"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:248
#, fuzzy
msgid ""
"One of the :ref:`PropertyHint <enum_@GlobalScope_PropertyHint>` values to "
"use as hint."
msgstr ""
"其中一个 :ref:`PropertyHint <enum_ @ GlobalScope_PropertyHint>` 值用作提示。"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:250
msgid "``hint_string``"
msgstr "``hint_string``"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:250
msgid ""
"The hint text of the property. The same as you'd add in the ``export`` "
"statement in GDScript."
msgstr "属性的提示文本。 与您在GDScript中的 ``export`` 语句中添加相同。"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:252
msgid "``usage``"
msgstr "``usage``"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:252
#, fuzzy
msgid ""
"One of the :ref:`PropertyUsageFlags <enum_@GlobalScope_PropertyUsageFlags>` "
"values to define the usage."
msgstr "属性的提示文本。与您在GDScript中的 ``export`` 语句中添加相同。"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:255
msgid ""
"The ``name`` and ``default_value`` keys are **mandatory**, the rest are "
"optional."
msgstr "``name``和``default_value``键是 **强制** ，其余是可选的。"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:257
msgid ""
"Note that the ``get_import_options`` method receives the preset number, so "
"you can configure the options for each different preset (especially the "
"default value). In this example we use the ``match`` statement, but if you "
"have lots of options and the presets only change the value you may want to "
"create the array of options first and then change it based on the preset."
msgstr ""
"请注意， ``get_import_options`` 方法接收预设编号，因此您可以为每个不同的预设"
"(尤其是默认值)配置选项。 在这个示例中，我们使用 ``match`` 语句，但是如果您有"
"很多选项并且预设只改变了您可能想要首先创建选项数组的值，然后根据预设更改它。"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:263
msgid ""
"The ``get_import_options`` method is called even if you don't define presets "
"(by making ``get_preset_count`` return zero). You have to return an array "
"even it's empty, otherwise you can get errors."
msgstr ""
"即使您没有定义预设(通过使 ``get_preset_count`` 返回零)，也会调用 "
"``get_import_options`` 方法。 您必须返回一个数组，即使它是空的，否则您可能会"
"得到错误。"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:273
#, fuzzy
msgid ""
"For the :ref:`get_option_visibility() "
"<class_EditorImportPlugin_method_get_option_visibility>` method, we simply "
"return ``true`` because all of our options (i.e. the single one we defined) "
"are visible all the time."
msgstr ""
"对于 :ref:`get_option_visibility() "
"<class_EditorImportPlugin_method_get_option_visibility>` 方法，我们只返回 "
"``true`` 因为我们所有的选项(即我们定义的单个选项)始终可见。"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:278
msgid ""
"If you need to make certain option visible only if another is set with a "
"certain value, you can add the logic in this method."
msgstr ""
"如果只有在使用某个值设置了另一个选项时才需要使某个选项可见，则可以在此方法中"
"添加逻辑。"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:282
msgid "The ``import`` method"
msgstr "``import`` 方法"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:284
#, fuzzy
msgid ""
"The heavy part of the process, responsible for the converting the files into "
"resources, is covered by the :ref:`import() "
"<class_EditorImportPlugin_method_import>` method. Our sample code is a bit "
"long, so let's split in a few parts:"
msgstr ""
"负责将文件转换为资源的过程的重要部分包括 :ref:`import() "
"<class_EditorImportPlugin_method_import>` 方法。 我们的示例代码有点长，所以让"
"我们分几部分:"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:300
#, fuzzy
msgid ""
"The first part of our import method opens and reads the source file. We use "
"the :ref:`File <class_File>` class to do that, passing the ``source_file`` "
"parameter which is provided by the editor."
msgstr ""
"导入方法的第一部分打开并读取源文件。 我们使用 :ref:`File <class_File>` 类来"
"做，传递编辑器提供的 ``source_file`` 参数。"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:304
msgid ""
"If there's an error when opening the file, we return it to let the editor "
"know that the import wasn't successful."
msgstr "如果打开文件时出错，我们将其返回以让编辑器知道导入不成功。"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:319
msgid ""
"This code takes the line of the file it read before and splits it in pieces "
"that are separated by a comma. If there are more or less than the three "
"values, it considers the file invalid and reports an error."
msgstr ""
"此代码获取之前读取的文件行，并将其拆分为以逗号分隔的片段。 如果有多于或少于三"
"个值，则认为该文件无效并报告错误。"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:323
#, fuzzy
msgid ""
"Then it creates a new :ref:`Color <class_Color>` variable and sets its "
"values according to the input file. If the ``use_red_anyway`` option is "
"enabled, then it sets the color as a pure red instead."
msgstr ""
"然后它创建一个新的 :ref:`Color <class_Color>` 变量并根据输入文件设置其值。 如"
"果启用了 ``use_red_anyway`` 选项，则会将颜色设置为纯红色。"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:332
#, fuzzy
msgid ""
"This part makes a new :ref:`SpatialMaterial <class_SpatialMaterial>` that is "
"the imported resource. We create a new instance of it and then set its "
"albedo color as the value we got before."
msgstr ""
"这部分创建了一个新的 :ref:`SpatialMaterial <class_SpatialMaterial>` 这是导入"
"的资源。 我们创建它的新实例，然后将其反照率颜色设置为我们之前获得的值。"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:340
#, fuzzy
msgid ""
"This is the last part and quite an important one, because here we save the "
"made resource to the disk. The path of the saved file is generated and "
"informed by the editor via the ``save_path`` parameter. Note that this comes "
"**without** the extension, so we add it using :ref:`string formatting "
"<doc_gdscript_printf>`. For this we call the ``get_save_extension`` method "
"that we defined earlier, so we can be sure that they won't get out of sync."
msgstr ""
"这是最后一部分也是非常重要的部分，因为在这里我们将生成的资源保存到磁盘。 编辑"
"器通过 ``save_path`` 参数生成并通知保存文件的路径。 请注意，这是 **没有** 扩"
"展名，所以我们使用 :ref:`string formatting <doc_gdscript_printf>` 添加它。 为"
"此，我们调用前面定义的 ``get_save_extension`` 方法，因此我们可以确保它们不会"
"失去同步。"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:347
#, fuzzy
msgid ""
"We also return the result from the :ref:`ResourceSaver.save() "
"<class_ResourceSaver_method_save>` method, so if there's an error in this "
"step, the editor will know about it."
msgstr ""
"我们还从 :ref:`ResourceSaver.save() <class_ResourceSaver_method_save>` 方法返"
"回结果，因此如果在此步骤中出现错误，编辑器将会知道它。"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:352
msgid "Platform variants and generated files"
msgstr "平台变体和生成的文件"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:354
msgid ""
"You may have noticed that our plugin ignored two arguments of the ``import`` "
"method. Those are *return arguments* (hence the ``r`` at the beginning of "
"their name), which means that the editor will read from them after calling "
"your import method. Both of them are arrays that you can fill with "
"information."
msgstr ""
"您可能已经注意到我们的插件忽略了 ``import`` 方法的两个参数。 那些是* return "
"arguments *(因此在它们名称的开头是 ``r`` )，这意味着编辑器会在调用您的import"
"方法之后读取它们。 它们都是可以填充信息的数组。"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:359
#, fuzzy
msgid ""
"The ``r_platform_variants`` argument is used if you need to import the "
"resource differently depending on the target platform. While it's called "
"*platform* variants, it is based on the presence of :ref:`feature tags "
"<doc_feature_tags>`, so even the same platform can have multiple variants "
"depending on the setup."
msgstr ""
"如果您需要根据目标平台以不同方式导入资源，则使用 ``r_platform_variants`` 参"
"数。 虽然它被称为* platform * variants，但它基于以下内容 :ref:`feature tags "
"<doc_feature_tags>`，因此即使是相同的平台也可以有多种变体，具体取决于设置。"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:364
msgid ""
"To import a platform variant, you need to save it with the feature tag "
"before the extension, and then push the tag to the ``r_platform_variants`` "
"array so the editor can know that you did."
msgstr ""
"要导入平台变体，需要在扩展名之前使用feature标记保存它，然后将标记推送到 "
"``r_platform_variants`` 数组，以便编辑可以知道您做了。"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:368
msgid ""
"For an example, let's say we save a different material for mobile platform. "
"We would need to do something like the following:"
msgstr ""
"举个示例，假设我们为移动平台保存了不同的资料。 我们需要做类似以下的事情:"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:376
msgid ""
"The ``r_gen_files`` argument is meant for extra files that are generated "
"during your import process and need to be kept. The editor will look at it "
"to understand the dependencies and make sure the extra file is not "
"inadvertently deleted."
msgstr ""
"``r_gen_files``参数用于在导入过程中生成并需要保留的额外文件。 编辑器将查看它"
"以了解依赖关系并确保不会无意中删除额外文件。"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:381
msgid ""
"This is also an array and should be filled with full paths of the files you "
"save. As an example, let's create another material for the next pass and "
"save it in a different file:"
msgstr ""
"这也是一个数组，应该填充您保存的文件的完整路径。 例如，让我们为下一个传递创建"
"另一个材质并将其保存在不同的文件中:"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:397
msgid "Trying the plugin"
msgstr "试试这个插件"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:399
msgid ""
"This has been theoretical, but now that the import plugin is done, let's "
"test it. Make sure you created the sample file (with the contents described "
"in the introduction section) and save it as ``test.mtxt``. Then activate the "
"plugin in the Project Settings."
msgstr ""
"这是理论上的，但是现在导入插件已经完成了，让我们来测试一下。 确保您创建了示例"
"文件(包含介绍部分中描述的内容)并将其另存为 ``test.mtxt`` 。 然后在“项目设"
"置”中激活插件。"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:404
msgid ""
"If everything goes well, the import plugin is added to the editor and the "
"file system is scanned, making the custom resource appear on the FileSystem "
"dock. If you select it and focus the Import dock, you can see the only "
"option to select there."
msgstr ""
"如果一切顺利，导入插件将添加到编辑器中并扫描文件系统，使自定义资源显示在"
"FileSystem基座上。 如果选择它并聚焦导入面板，则可以看到选择该选项的唯一选项。"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:409
msgid ""
"Create a MeshInstance node in the scene, and for its Mesh property set up a "
"new SphereMesh. Unfold the Material section in the Inspector and then drag "
"the file from the FileSystem dock to the material property. The object will "
"update in the viewport with the blue color of the imported material."
msgstr ""
"在场景中创建一个MeshInstance节点，并为其Mesh属性设置一个新的SphereMesh。 在属"
"性面板中展开“材质”部分，然后将文件从“文件系统”面板拖动到材质属性。 对象将在视"
"区中使用导入材质的蓝色进行更新。"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:416
msgid ""
"Go to Import dock, enable the \"Use Red Anyway\" option, and click on "
"\"Reimport\". This will update the imported material and should "
"automatically update the view showing the red color instead."
msgstr ""
"转到导入面板，启用“使用红色反正”选项，然后单击“重新导入”。 这将更新导入的材"
"质，并应自动更新显示红色的视图。"

#: ../../docs/tutorials/plugins/editor/import_plugins.rst:420
msgid ""
"And that's it! Your first import plugin is done! Now get creative and make "
"plugins for your own beloved formats. This can be quite useful to write your "
"data in a custom format and then use it in Godot as if they were native "
"resources. This shows how the import system is powerful and extendable."
msgstr ""
"就是这样！ 您的第一个导入插件已经完成！ 现在获得创意并为您自己心爱的格式制作"
"插件。 这对于以自定义格式编写数据然后在Godot中使用它就像它们是本机资源一样非"
"常有用。 这显示了导入系统如何强大和可扩展。"

#: ../../docs/tutorials/plugins/editor/spatial_gizmos.rst:4
#, fuzzy
msgid "Spatial gizmo plugins"
msgstr "制作插件"

#: ../../docs/tutorials/plugins/editor/spatial_gizmos.rst:9
msgid ""
"Spatial gizmo plugins are used by the editor and custom plugins to define "
"the gizmos attached to any kind of Spatial node."
msgstr ""

#: ../../docs/tutorials/plugins/editor/spatial_gizmos.rst:12
msgid ""
"This tutorial will show you the two main approaches to defining your own "
"custom gizmos. The first option works well for simple gizmos and creates "
"less clutter in your plugin structure, while the second one will let you "
"store some per-gizmo data."
msgstr ""

#: ../../docs/tutorials/plugins/editor/spatial_gizmos.rst:16
#, fuzzy
msgid ""
"This tutorial assumes you already know how to make generic plugins. If in "
"doubt, refer to the :ref:`doc_making_plugins` page."
msgstr ""
"本教程假设您已经知道如何制作通用插件。 如有疑问，请参阅 :ref:"
"`doc_making_plugins` 页面。 这也假设您熟悉Godot的导入系统。"

#: ../../docs/tutorials/plugins/editor/spatial_gizmos.rst:20
#, fuzzy
msgid "The EditorSpatialGizmoPlugin"
msgstr "EditorImportPlugin类"

#: ../../docs/tutorials/plugins/editor/spatial_gizmos.rst:22
msgid ""
"Regardless of the approach we choose, we will need to create a new :ref:"
"`EditorSpatialGizmoPlugin <class_EditorSpatialGizmoPlugin>`. This will allow "
"us to set a name for the new gizmo type and define other behaviors such as "
"whether the gizmo can be hidden or not."
msgstr ""

#: ../../docs/tutorials/plugins/editor/spatial_gizmos.rst:27
msgid "This would be a basic setup:"
msgstr ""

#: ../../docs/tutorials/plugins/editor/spatial_gizmos.rst:57
msgid ""
"For simple gizmos, just inheriting :ref:`EditorSpatialGizmoPlugin "
"<class_EditorSpatialGizmoPlugin>` is enough. If you want to store some per-"
"gizmo data or you are porting a Godot 3.0 gizmo to 3.1+, you should go with "
"the second approach."
msgstr ""

#: ../../docs/tutorials/plugins/editor/spatial_gizmos.rst:63
#, fuzzy
msgid "Simple approach"
msgstr "简单购买"

#: ../../docs/tutorials/plugins/editor/spatial_gizmos.rst:65
msgid ""
"The first step is to, in our custom gizmo plugin, override the :ref:"
"`has_gizmo()<class_EditorSpatialGizmoPlugin_method_has_gizmo>` method so "
"that it returns ``true`` when the spatial parameter is of our target type."
msgstr ""

#: ../../docs/tutorials/plugins/editor/spatial_gizmos.rst:76
msgid ""
"Then we can override methods like :ref:"
"`redraw()<class_EditorSpatialGizmoPlugin_method_redraw>` or all the handle "
"related ones."
msgstr ""

#: ../../docs/tutorials/plugins/editor/spatial_gizmos.rst:107
msgid ""
"Note that we created a material in the `_init` method, and retrieved it in "
"the `redraw` method using :ref:"
"`get_material()<class_EditorSpatialGizmoPlugin_method_get_material>`. This "
"method retrieves one of the material's variants depending on the state of "
"the gizmo (selected and/or editable)."
msgstr ""

#: ../../docs/tutorials/plugins/editor/spatial_gizmos.rst:112
#, fuzzy
msgid "So the final plugin would look somewhat like this:"
msgstr "您最后的场景应该是这样的。"

#: ../../docs/tutorials/plugins/editor/spatial_gizmos.rst:148
msgid ""
"Note that we just added some handles in the redraw method, but we still need "
"to implement the rest of handle-related callbacks in :ref:"
"`EditorSpatialGizmoPlugin <class_EditorSpatialGizmoPlugin>` to get properly "
"working handles."
msgstr ""

#: ../../docs/tutorials/plugins/editor/spatial_gizmos.rst:153
#, fuzzy
msgid "Alternative approach"
msgstr "或者，您可以运行"

#: ../../docs/tutorials/plugins/editor/spatial_gizmos.rst:155
msgid ""
"In some cases we want to provide our own implementation of :ref:"
"`EditorSpatialGizmo<class_EditorSpatialGizmo>`, maybe because we want to "
"have some state stored in each gizmo or because we are porting an old gizmo "
"plugin and we don't want to go through the rewriting process."
msgstr ""

#: ../../docs/tutorials/plugins/editor/spatial_gizmos.rst:159
msgid ""
"In these cases all we need to do is, in our new gizmo plugin, override :ref:"
"`create_gizmo()<class_EditorSpatialGizmoPlugin_method_create_gizmo>`, so it "
"returns our custom gizmo implementation for the Spatial nodes we want to "
"target."
msgstr ""

#: ../../docs/tutorials/plugins/editor/spatial_gizmos.rst:181
msgid ""
"This way all the gizmo logic and drawing methods can be implemented in a new "
"clas extending :ref:`EditorSpatialGizmo<class_EditorSpatialGizmo>`, like so:"
msgstr ""

#: ../../docs/tutorials/plugins/editor/spatial_gizmos.rst:217
msgid ""
"Note that we just added some handles in the redraw method, but we still need "
"to implement the rest of handle-related callbacks in :ref:"
"`EditorSpatialGizmo<class_EditorSpatialGizmo>` to get properly working "
"handles."
msgstr ""

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:4
msgid "GDNative C example"
msgstr "GDNative C示例"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:8
msgid ""
"This tutorial will introduce you to the bare minimum required to create "
"GDNative modules. This should be your starting point into the world of "
"GDNative, understanding the contents of this tutorial will help you in "
"understanding all that is to come after this."
msgstr ""
"本教程将向您介绍创建GDNative模块所需的最低要求。 这应该是您进入GDNative世界的"
"起点，了解本教程的内容将有助于您理解此后的所有内容。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:10
msgid ""
"Before we begin, you can download the source code to the example object "
"we'll be describing here by following this link: https://github.com/"
"GodotNativeTools/GDNative-demos/tree/master/c/SimpleDemo"
msgstr ""
"在开始之前，您可以通过以下链接将源代码下载到我们将在此处描述的示例对象: "
"https://github.com/GodotNativeTools/GDNative-demos/tree/master/c/SimpleDemo"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:13
msgid ""
"This example project also contains a SConstruct file that makes compiling a "
"little easier but in this tutorial we'll be doing things by hand."
msgstr ""
"此示例项目还包含一个SConstruct文件，使编译更容易，但在本教程中，我们将手动执"
"行操作。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:15
msgid ""
":ref:`GDNative <class_GDNative>` can be used to create several types of "
"additions to Godot, from PluginScript to ARVR interfaces. In this tutorial "
"we are going to look at creating a :ref:`NativeScript <class_NativeScript>` "
"module. NativeScript allows you to write logic in C or C++ in similar "
"fashion as you would write a GDScript file. We'll be creating the C "
"equivalent of this GDScript:"
msgstr ""
":ref:`GDNative <class_GDNative>` 可用于创建Godot的几种类型的添加，从"
"PluginScript到ARVR接口。 在本教程中，我们将介绍如何创建 :ref:`NativeScript "
"<class_NativeScript>` 模块。 NativeScript允许您以与编写GDScript文件类似的方式"
"在C或C++中编写逻辑。 我们将创建此GDScript的C等价物:"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:29
msgid ""
"We'll be writing separate tutorials on the other types of GDNative modules "
"and explain what each of them is for as we go through them."
msgstr ""
"我们将在其他类型的GDNative模块上编写单独的教程，并在我们完成它们时解释它们的"
"用途。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:32
msgid "Prerequisites"
msgstr "先决条件"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:33
msgid "Before we start you'll need a few things."
msgstr "在我们开始之前，您需要一些东西。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:35
msgid "A Godot 3.0 executable"
msgstr "Godot 3.0可执行文件"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:36
msgid "A C compiler"
msgstr "一个C编译器"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:37
msgid ""
"A copy of this repository: https://github.com/GodotNativeTools/godot_headers"
msgstr "此存储库的副本:https://github.com/GodotNativeTools/godot_headers"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:39
msgid ""
"The first two pretty much speak for themselves. On Linux, you'll likely have "
"a C compiler, on macOS, it's easiest to install Xcode from the Mac App Store "
"and, on Windows, we've tested this with both MSVC 2015 and 2017."
msgstr ""
"前两个几乎可以说明一切。 在Linux上，您可能有一个C编译器，在macOS上，最容易从"
"Mac App Store安装Xcode，而在Windows上，我们已经用MSVC 2015和2017测试了它。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:41
msgid ""
"For number 3, we suggest that you create a folder somewhere that you use to "
"store your code, open up a terminal and CD into that folder. Then execute:"
msgstr ""
"对于3号，我们建议您在某处创建一个用于存储代码的文件夹，打开终端并将CD打开到该"
"文件夹中。 然后执行:"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:47
msgid "This will download the required files into that folder."
msgstr "这会将所需文件下载到该文件夹中。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:49
msgid ""
"On this repository you will now find different branches. As Godot evolves, "
"so does GDNative. With the exception of one breaking change in ARVR between "
"3.0 and 3.1, GDNative modules build for older versions of Godot will work "
"with newer versions of Godot but not the other way around."
msgstr ""
"在此存储库中，您将找到不同的分支。 随着Godot的进化，GDNative也是如此。 除了"
"ARVR在3.0和3.1之间的一次重大变化之外，为旧版本的Godot构建的GDNative模块将与较"
"新版本的Godot一起使用，但不是相反。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:51
msgid ""
"The master branch of the ``godot_headers`` repository is kept in line with "
"the master branch of Godot and thus contains the GDNative class and "
"structure definitions that will work with the latest Godot master."
msgstr ""
"“godot_headers”库的主分支与Godot的主分支保持一致，因此包含GDNative类和结构定"
"义，可与最新的Godot主机一起使用。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:53
msgid ""
"The 3.0 branch of the ``godot_headers`` repository contains the GDNative "
"class and structure definitions that will work with Godot 3.0. You can clone "
"this branch by executing:"
msgstr ""
"``godot_headers``存储库的3.0分支包含可与Godot 3.0一起使用的GDNative类和结构定"
"义。 您可以通过执行以下命令克隆此分支:"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:59
msgid ""
"If you are building Godot from source with your own changes that impact "
"GDNative, you can find the updated class and structure definition in "
"``<godotsource>/modules/gdnative/include``"
msgstr ""
"如果您使用您自己的影响GDNative的更改从源代码构建Godot，您可以在"
"``<godotsource> / modules / gdnative / include`中找到更新的类和结构定义"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:62
msgid "Our C source"
msgstr "我们的C源"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:63
msgid ""
"Let's start by writing our main code. Ideally, we want to end up with a file "
"structure that looks something like this:"
msgstr ""
"让我们从编写主代码开始。 理想情况下，我们希望最终得到一个类似于下面的文件结"
"构:"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:81
msgid ""
"Open up Godot and create a new project called simple. This will create the "
"simple folder and project.godot file. Then manually create a bin and src "
"subfolder in this folder."
msgstr ""
"打开Godot并创建一个名为simple的新项目。 这将创建简单的文件夹和project.godot文"
"件。 然后在此文件夹中手动创建bin和src子文件夹。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:83
msgid ""
"We're going to start by having a look at what our simple.c file contains. "
"Now, for our example here we're making a single C source file without a "
"header to keep things simple. Once you start writing bigger projects it is "
"advisable you break your project up into multiple files. That however falls "
"outside of the scope of this tutorial."
msgstr ""
"我们首先看一下simple.c文件包含的内容。 现在，对于我们的示例，我们在制作一个没"
"有标题的单个C源文件，以保持简单。 一旦开始编写更大的项目，建议您将项目分解为"
"多个文件。 但是，这超出了本教程的范围。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:85
msgid ""
"We'll be looking at the source code bit by bit so all the parts below should "
"all be put together into one big file. I'll explain each section as we add "
"it."
msgstr ""
"我们将逐位查看源代码，因此下面的所有部分都应该放在一个大文件中。 我会在添加它"
"时解释每个部分。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:87
msgid ""
"The below code includes our header files that we need and then defines two "
"pointers to two different structs. GDNative supports a large collection for "
"functions for calling back into the main Godot executable. In order for your "
"module to have access to these functions, GDNative provides your application "
"with a struct containing pointers to all these functions."
msgstr ""
"下面的代码包含我们需要的头文件，然后定义两个指向两个不同结构的指针。 GDNative"
"支持大型集合，用于回调主Godot可执行文件的函数。 为了让您的模块能够访问这些函"
"数，GDNative为您的应用程序提供了一个包含指向所有这些函数的指针的结构。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:90
msgid ""
"To keep this implementation modular and easily extendable, the core "
"functions are available directly through the \"core\" API struct, but "
"additional functions have their own \"GDNative structs\" that are accessible "
"through extensions."
msgstr ""
"为了保持这种实现模块化和易于扩展，核心功能可直接通过“核心”API结构提供，但其他"
"功能有自己的“GDNative结构”，可通过扩展访问。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:92
msgid ""
"In our example, we access one of these extension to gain access to the "
"functions specifically needed for NativeScript."
msgstr ""
"在我们的示例中，我们访问其中一个扩展，以获取对NativeScript特别需要的函数的访"
"问权限。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:104
msgid ""
"A NativeScript behaves like any other script in Godot. Because the "
"NativeScript API is rather low level, it requires the library to specify "
"many things more verbosely than other scripting systems, such as GDScript. "
"When a NativeScript instance gets created, a library-given constructor gets "
"called. When that instance gets destroyed, the given destructor will be "
"executed."
msgstr ""
"NativeScript的行为与Godot中的任何其他脚本一样。 由于NativeScript API的级别相"
"当低，因此它需要库比其他脚本系统(如GDScript)更详细地指定许多内容。 创建"
"NativeScript实例时，将调用库给定的构造函数。 当该实例被销毁时，将执行给定的析"
"构函数。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:106
msgid ""
"These are forward declarations for the functions we'll be implementing for "
"our object. A constructor and destructor is needed. Additionally, the object "
"will have a single method called get_data."
msgstr ""
"这些是我们将为对象实现的函数的前向声明。 需要构造函数和析构函数。 此外，该对"
"象将有一个名为get_data的方法。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:115
msgid ""
"Next up is the first of the entry points Godot will call when our dynamic "
"library is loaded. These methods are all prefixed with Godot (you can change "
"this later on) followed by their name. ``gdnative_init`` is a function that "
"initialises our dynamic library. Godot will give it a pointer to a structure "
"that contains various bits of information we may find useful amongst which "
"the pointers to our API structures."
msgstr ""
"接下来是Godot在加载动态库时会调用的第一个入口点。 这些方法都以Godot为前缀(您"
"可以稍后更改)，然后是其名称。 ``gdnative_init``是一个初始化动态库的函数。 "
"Godot会给它一个指向结构的指针，该结构包含我们可能会发现有用的各种信息，其中指"
"向我们的API结构的指针。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:117
msgid ""
"For any additional API structures we need to loop through our extensions "
"array and check the type of extension."
msgstr "对于任何其他API结构，我们需要遍历扩展数组并检查扩展的类型。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:135
msgid ""
"Next up is ``gdnative_terminate`` which is called before the library is "
"unloaded. Godot will unload the library when no object uses it anymore. "
"Here, you can do any cleanup you may need to do. For our example, we're "
"simply going to clear our API pointers."
msgstr ""
"接下来是 ``gdnative_terminate`` ，在卸载库之前调用它。 当没有任何对象使用它"
"时，Godot将卸载库。 在这里，您可以进行任何需要清理的清理工作。 对于我们的示"
"例，我们只是要清除我们的API指针。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:144
msgid ""
"Finally we have ``nativescript_init`` which is the most important function "
"we'll need today. This function will be called by Godot as part of loading a "
"GDNative library and communicates back to Godot what objects we make "
"available to Godot."
msgstr ""
"最后我们有 ``nativescript_init`` 这是我们今天需要的最重要的功能。 Godot会调用"
"此函数作为加载GDNative库的一部分，并向Godot传达我们向Godot提供的对象。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:146
msgid ""
"We first tell Godot which classes are implemented by calling "
"``nativescript_register_class``. The first parameter here is the handle "
"pointer given to us. The second is the name of our object class. The third "
"is the type of object in Godot that we 'inherit' from, this is not true "
"inheritance but it's close enough. Finally, our fourth and fifth parameters "
"are descriptions for our constructor and destructor."
msgstr ""
"我们首先通过调用 ``nativescript_register_class`` 告诉Godot实现了哪些类。 这里"
"的第一个参数是给我们的句柄指针。 第二个是对象类的名称。 第三个是Godot中我"
"们“继承”的对象类型，这不是真正的继承，但它足够接近。 最后，我们的第四个和第五"
"个参数是我们的构造函数和析构函数的描述。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:148
msgid ""
"We then tell Godot about our methods (well our one method in this case), by "
"calling ``nativescript_register_method`` for each method of our class. In "
"our case, that is just ``get_data``. Our first parameter is yet again our "
"handle pointer. The second is again the name of the object class we're "
"registering. The third is the name of our function as it will be known to "
"GDScript. The fourth is our attributes setting. The fifth and final "
"parameter is a description of which function to call when the method gets "
"called."
msgstr ""
"然后我们通过为我们类的每个方法调用 ``nativescript_register_method`` 来告诉"
"Godot我们的方法(在这种情况下我们的方法)。 在我们的示例中，那只是 "
"``get_data`` 。 我们的第一个参数又是我们的句柄指针。 第二个是我们正在注册的对"
"象类的名称。 第三个是我们函数的名称，因为它将为GDScript所知。 第四是我们的属"
"性设置。 第五个也是最后一个参数是调用方法时要调用的函数的描述。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:150
msgid ""
"The descriptions contain the function pointers to the functions themselves. "
"The other two fields in these structs are for specifying per-method "
"userdata. The value in the ``method_data`` field will be passed on every "
"function call as the ``p_method_data`` argument. This is useful to reuse one "
"function for different methods on possibly multiple different script-"
"classes. If the ``method_data`` value is a pointer to memory that needs to "
"be freed, the ``free_func`` field can contain a pointer to a function that "
"will free that memory. That free function gets called when the script itself "
"(not instance!) gets unloaded (so usually at library-unload time)."
msgstr ""
"描述包含函数本身的函数指针。 这些结构中的其他两个字段用于指定每个方法的"
"userdata。 ``method_data``字段中的值将作为``p_method_data``参数在每次函数调用"
"时传递。 这对于可能在多个不同脚本类上的不同方法重用一个函数很有用。 如果 "
"``method_data`` 值是一个指向需要释放的内存的指针，那么 ``free_func`` 字段可以"
"包含一个指向一个释放该内存的函数的指针。 当脚本本身(不是实例！)被卸载时(通常"
"在库卸载时)，调用该自由函数。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:173
msgid ""
"Now, it's time to start working on the functions of our object. First, we "
"define a structure that we use to store the member data of an instance of "
"our GDNative class."
msgstr ""
"现在，是时候开始处理我们对象的功能了。 首先，我们定义一个结构，用于存储"
"GDNative类实例的成员数据。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:181
msgid ""
"And then, we define our constructor. All we do in our constructor is "
"allocate memory for our structure and fill it with some data. Note that we "
"use Godot's memory functions so the memory gets tracked and then return the "
"pointer to our new structure. This pointer will act as our instance "
"identifier in case multiple objects are instantiated."
msgstr ""
"然后，我们定义我们的构造函数。 我们在构造函数中所做的就是为结构分配内存并用一"
"些数据填充它。 请注意，我们使用Godot的内存函数，以便跟踪内存，然后将指针返回"
"到我们的新结构。 如果实例化多个对象，则此指针将充当我们的实例标识符。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:183
msgid ""
"This pointer will be passed to any of our functions related to our object as "
"a parameter called ``p_user_data``, and can both be used to identify our "
"instance and to access its member data."
msgstr ""
"该指针将作为名为 ``p_user_data`` 的参数传递给与我们的对象相关的任何函数，并且"
"可以用于标识我们的实例并访问其成员数据。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:194
msgid ""
"Our destructor is called when Godot is done with our object and we free our "
"instances' member data."
msgstr "当Godot完成我们的对象时，我们会调用析构函数，并释放实例的成员数据。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:202
msgid ""
"And finally, we implement our get_data function. Data is always sent and "
"returned as variants so in order to return our data, which is a string, we "
"first need to convert our C string to a Godot string object, and then copy "
"that string object into the variant we are returning."
msgstr ""
"最后，我们实现了get_data函数。 数据总是作为变体发送和返回，所以为了返回我们的"
"数据，这是一个字符串，我们首先需要将我们的C字符串转换为Godot字符串对象，然后"
"将该字符串对象复制到我们返回的变量中。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:204
msgid ""
"Strings are heap-allocated in Godot, so they have a destructor which frees "
"the memory. Destructors are named ``godot_TYPENAME_destroy``. When a Variant "
"gets created with a String, it references the String. That means that the "
"original String can be \"destroyed\" to decrease the ref-count. If that does "
"not happen the String memory will leak since the ref-count will never be "
"zero and the memory never deallocated. The returned variant gets "
"automatically destroyed by Godot."
msgstr ""
"字符串在Godot中进行堆分配，因此它们具有释放内存的析构函数。 析构函数名为 "
"``godot_TYPENAME_destroy`` 。 使用String创建Variant时，它会引用String。 这意"
"味着可以“销毁”原始字符串以减少引用计数。 如果没有发生这种情况，String内存将泄"
"漏，因为ref-count永远不会为零，并且内存永远不会被释放。 返回的变体会被Godot自"
"动销毁。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:206
msgid ""
"(In more complex operations it can be confusing the keep track of which "
"value needs to be deallocated and which does not. As a general rule: call "
"godot_XXX_destroy when a C++ destructor would be called instead. The String "
"destructor would be called in C++ after the Variant was created, so the same "
"is necessary in C)"
msgstr ""
"(在更复杂的操作中，可能会混淆跟踪哪个值需要被释放，哪些不需要。一般来说:当调"
"用C++析构函数时调用godot_XXX_destroy。字符串析构函数将在C++之后调用 Variant已"
"创建，因此在C)中也是如此"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:208
msgid "The variant we return is destroyed automatically by Godot."
msgstr "我们返回的变体由Godot自动销毁。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:226
msgid "And that is the whole source code of our module."
msgstr "这就是我们模块的完整源代码。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:228
msgid ""
"If you add a blank .gdignore file to the src folder, Godot will not try to "
"import the compiler-generated temporary files."
msgstr ""
"如果将空白.gdignore文件添加到src文件夹，Godot将不会尝试导入编译器生成的临时文"
"件。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:232
msgid ""
"We now need to compile our source code. As mentioned our example project on "
"GitHub contains a Scons configuration that does all the hard work for you "
"but for our tutorial here we are going to call the compilers directly."
msgstr ""
"我们现在需要编译我们的源代码。 如上所述，我们在GitHub上的示例项目包含一个"
"Scons配置，它可以为您完成所有艰苦的工作，但是对于我们的教程，我们将直接调用编"
"译器。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:234
msgid ""
"Assuming you are sticking to the folder structure suggested above it is best "
"to CD into the src subfolder in a terminal session and execute the commands "
"from there. Make sure to create the bin folder before you proceed."
msgstr ""
"假设您坚持上面建议的文件夹结构，最好将CD放入终端会话中的src子文件夹并从那里执"
"行命令。 确保在继续之前创建bin文件夹。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:236
msgid "On Linux:"
msgstr "在Linux上:"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:243
msgid "On macOS:"
msgstr "在macOS上:"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:250
msgid "On Windows:"
msgstr "在Windows上:"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:257
msgid ""
"on the Windows build you also end up with a libsimple.lib library. This is a "
"library that you can compile into a project to provide access to the DLL. We "
"get it as a bonus and we do not need it :) When exporting your game for "
"release this file will be ignored."
msgstr ""
"在Windows构建中，您最终还会得到一个libsimple.lib库。 这是一个可以编译到项目中"
"以提供对DLL的访问的库。 我们得到它作为奖励，我们不需要它:)当导出您的游戏发布"
"时，这个文件将被忽略。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:260
msgid "Creating our GDNLIB file"
msgstr "创建我们的DGNLIB文件"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:261
msgid ""
"With our module compiled we now need to create a gdnlib file for our module "
"which we place alongside our dynamic libraries. This file tells Godot what "
"dynamic libraries are part of our module and need to be loaded per platform. "
"At the time of writing this tutorial work is still being done on making this "
"configurable from within Godot so for now grab your favourite text editor, "
"create a file called libsimple.gdnlib and add the following into this file:"
msgstr ""
"编译完模块后，我们现在需要为我们的模块创建一个gdnlib文件，我们将它们与动态库"
"放在一起。 这个文件告诉Godot什么动态库是我们模块的一部分，需要按平台加载。 在"
"撰写本教程时，仍然需要完成从Godot中进行配置的工作，现在抓住您喜欢的文本编辑"
"器，创建一个名为libsimple.gdnlib的文件，并将以下内容添加到此文件中:"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:283
msgid "This file contains 3 sections."
msgstr "该文件包含3个部分。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:285
msgid ""
"The **general** section contains some info that tells Godot how to use our "
"module."
msgstr "** general **部分包含一些信息，告诉Godot如何使用我们的模块。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:287
msgid ""
"If singleton is true our library is automatically loaded and a function "
"called godot_singleton_init is called. We'll leave that for another tutorial."
msgstr ""
"如果singleton为true，则自动加载库并调用名为godot_singleton_init的函数。 我们"
"将把它留给另一个教程。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:289
msgid ""
"If load_once is true our library is loaded only once and each individual "
"script that uses our library will use the same data. Any variable you define "
"globally will be accessible from any instance of your object you create. If "
"load_once is false a new copy of the library is loaded into memory each time "
"a script access the library."
msgstr ""
"如果load_once为true，则我们的库只加载一次，并且使用我们库的每个单独脚本将使用"
"相同的数据。 您可以从您创建的对象的任何实例访问您全局定义的任何变量。 如果"
"load_once为false，则每次脚本访问库时，都会将新的库副本加载到内存中。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:291
msgid ""
"The symbol_prefix is a prefix for our core functions. So the Godot in "
"godot_nativescript_init for instance. If you use multiple GDnative libraries "
"that you wish to statically link you'll have to use different prefixes. This "
"again is a subject to dive into deeper in a separate tutorial, it is only "
"needed at this time for deployment to iOS as this platform does not like "
"dynamic libraries."
msgstr ""
"symbol_prefix是我们核心功能的前缀。 所以Godot在godot_nativescript_init中就是"
"这样。 如果您使用多个想要静态链接的GDnative库，则必须使用不同的前缀。 这又是"
"一个深入了解单独教程的主题，此时只需要部署到iOS，因为这个平台不喜欢动态库。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:293
msgid ""
"The **entry** section tells us for each platform and feature combination "
"which dynamic library has to be loaded. This also informs the exporter which "
"files need to be exported when exporting to a specific platform."
msgstr ""
"**条目**部分告诉我们每个平台和功能组合必须加载哪个动态库。 这还会通知导出器在"
"导出到特定平台时需要导出哪些文件。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:295
msgid ""
"The **dependencies** section tells Godot what other files need to be "
"exported for each platform in order for our library to work. Say that your "
"GDNative module uses another DLL to implement functionality from a 3rd party "
"library, this is where you list that DLL."
msgstr ""
"** dependencies **部分告诉Godot每个平台需要导出哪些其他文件才能使我们的库工"
"作。 假设您的GDNative模块使用另一个DLL来实现第三方库的功能，这是您列出该DLL的"
"位置。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:298
msgid "Putting it all together"
msgstr "把它们放在一起"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:299
msgid ""
"Now that we should have a working GDNative library it is time to fire up "
"Godot and use it. Open up the sample project if you haven't left it open "
"after creating the project all the way at the beginning of this tutorial."
msgstr ""
"现在我们应该有一个有效的GDNative库，现在是时候启动Godot并使用它了。 如果在本"
"教程开始时一直创建项目后没有将其打开，请打开示例项目。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:302
msgid "Creating our GDNS file"
msgstr "创建我们的GDNS文件"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:303
msgid ""
"With our GDNLIB file we've told Godot how to load our library, now we need "
"to tell it about our \"Simple\" object class. This we do by creating a GDNS "
"resource file."
msgstr ""
"通过我们的GDNLIB文件，我们告诉Godot如何加载我们的库，现在我们需要告诉它我们"
"的“简单”对象类。 我们这样做是通过创建GDNS资源文件。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:305
msgid "Start by clicking the create resource button in the Inspector:"
msgstr "首先单击属性面板中的创建资源按钮:"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:309
msgid "And select NativeScript:"
msgstr "并选择NativeScript:"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:313
msgid ""
"Press Create, now the inspector will show a few fields we need to enter. In "
"Class Name we enter \"SIMPLE\" which is the object class name we used in our "
"C source when calling godot_nativescript_register_class. We also need to "
"select our GDNLIB file by clicking on Library and selecting Load:"
msgstr ""
"按Create，现在属性面板将显示我们需要输入的几个字段。 在Class Name中，我们输"
"入“SIMPLE”，这是我们在调用godot_nativescript_register_class时在C源代码中使用"
"的对象类名。 我们还需要通过单击Library并选择Load来选择我们的GDNLIB文件:"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:317
msgid "Finally click on the save icon and save this as bin/simple.gdns:"
msgstr "最后点击保存图标并将其另存为bin / simple.gdns:"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:321
msgid ""
"Now it's time to build our scene. Add a control node to your scene as your "
"root and call it main. Then add a button and a label as subnodes. Place them "
"somewhere nice on screen and give your button a name."
msgstr ""
"现在是时候建立我们的场景了。 将一个控制节点作为根添加到场景中并将其命名为"
"main。 然后添加一个按钮和一个标签作为子节点。 将它们放在屏幕上的好地方，并为"
"您的按钮命名。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:325
msgid "Select the control node and create a script for the control node:"
msgstr "选择控制节点并为控制节点创建脚本:"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:329
msgid "Next link up the pressed signal on the button to your script:"
msgstr "接下来将按钮上的按下信号链接到您的脚本:"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:333
msgid "Don't forget to save your scene, call it main.tscn."
msgstr "不要忘记保存您的场景，称之为main.tscn。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:335
msgid "Now we can implement our main.gd code:"
msgstr "现在我们可以实现main.gd代码:"

#: ../../docs/tutorials/plugins/gdnative/gdnative-c-example.rst:347
msgid ""
"After all that, our project should work. The first time you run it Godot "
"will ask you what your main scene is and you select your main.tscn file and "
"presto:"
msgstr ""
"毕竟，我们的项目应该有效。 第一次运行时，Godot将询问您的主要场景是什么，然后"
"选择main.tscn文件并预先输入:"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:4
msgid "GDNative C++ example"
msgstr "GDNative C++示例"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:9
msgid ""
"This tutorial builds on top of the information given in the :ref:`GDNative C "
"example <doc_gdnative_c_example>`, so we highly recommend you read that "
"first."
msgstr ""
"本教程建立在 :ref:`GDNative C example <doc_gdnative_c_example>` 中给出的信息"
"之上，因此我们强烈建议您先阅读。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:13
msgid ""
"The C++ bindings for GDNative are built on top of the NativeScript GDNative "
"API and provide a nicer way to \"extend\" nodes in Godot using C++. This is "
"equivalent to writing scripts in GDScript, but in C++ instead."
msgstr ""
"GDNative的C++绑定构建在NativeScript GDNative API之上，并提供了一种使用C++在"
"Godot中“扩展”节点的更好方法。 这相当于在GDScript中编写脚本，而是在C++中编写脚"
"本。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:18
msgid ""
"Godot 3.1 saw the introduction of the NativeScript 1.1 additions that "
"enabled the GDNative team to build a nicer C++ bindings library. These "
"changes have now been merged into the master branch and will be the way we "
"go forward. If you want to write a C++ GDNative plugin that also supports "
"Godot 3.0 you will need to use the 3.0 branch and the NativeScript 1.0 "
"syntax. We'll be showing them side by side in this writeup."
msgstr ""
"Godot 3.1看到了NativeScript 1.1新增功能的引入，使GDNative团队能够构建更好的C+"
"+绑定库。 这些变化现已合并到主分支中，并将成为我们前进的方式。 如果您想编写一"
"个也支持Godot 3.0的C++ GDNative插件，您需要使用3.0分支和NativeScript 1.0语"
"法。 我们将在这篇文章中并排展示它们。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:26
msgid ""
"You can download the full example we'll be creating in this tutorial `on "
"GitHub <https://github.com/BastiaanOlij/gdnative_cpp_example>`_."
msgstr ""
"您可以在 `GitHub <https://github.com/BastiaanOlij/gdnative_cpp_example>`_ 上"
"下载我们将在本教程中创建的完整示例。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:30
msgid "Setting up the project"
msgstr "设置项目"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:32
msgid "There are a few prerequisites you'll need:"
msgstr "您需要一些先决条件:"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:34
msgid "a Godot 3.x executable,"
msgstr "Godot 3.x可执行文件，"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:35
msgid "a C++ compiler,"
msgstr "一个C++编译器，"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:36
msgid "SCons as a build tool,"
msgstr "SCons作为构建工具，"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:37
msgid ""
"a copy of the `godot-cpp repository <https://github.com/GodotNativeTools/"
"godot-cpp>`_."
msgstr ""
"`godot-cpp repository <https://github.com/GodotNativeTools/godot-cpp>`_ 的副"
"本。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:39
msgid ""
"See also :ref:`Compiling <toc-devel-compiling>` as the build tools are "
"identical to the ones you need to compile Godot from source."
msgstr ""
"另请参阅 :ref:`编译 <toc-devel-compiling>` 因为构建工具与从源代码编译Godot所"
"需的构建工具相同。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:42
#, fuzzy
msgid ""
"You can download these repositories from GitHub or let Git do the work for "
"you. Note that these repositories now have different branches for different "
"versions of Godot. GDNative modules written for an earlier version of Godot "
"will work in newer versions (with the exception of one breaking change in "
"ARVR interfaces between 3.0 and 3.1) but not vice versa so make sure you "
"download the correct branch. Also note that the version of Godot you use to "
"generate the ``api.json`` with becomes your minimum version."
msgstr ""
"您可以从GitHub下载这些存储库，或让Git为您完成工作。 请注意，这些存储库现在对"
"于不同版本的Godot具有不同的分支。 为早期版本的Godot编写的GDNative模块将在较新"
"版本中运行(除了3.0和3.1之间的ARVR接口的一次重大更改)，但反之亦然，因此请确保"
"下载正确的分支。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:52
msgid ""
"If you are versioning your project using Git, it is a good idea to add them "
"as Git submodules:"
msgstr "如果您使用Git对项目进行版本控制，最好将它们添加为Git子模块:"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:74
msgid ""
"If you decide to just download the repositories or clone them into your "
"project folder, make sure to keep the folder layout identical to the one "
"described here, as much of the code we'll be showcasing here assumes the "
"project follows this layout."
msgstr ""
"如果您决定只下载存储库或将它们克隆到项目文件夹中，请确保文件夹布局与此处描述"
"的相同，因为我们将在此处展示的代码假定项目遵循此布局。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:79
msgid "Do make sure you clone recursive to pull in both repositories:"
msgstr "确保克隆递归以拉入两个存储库:"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:94
msgid ""
"``godot-cpp`` now includes ``godot_headers`` as a nested submodule, if "
"you've manually downloaded them please make sure to place ``godot_headers`` "
"inside of the ``godot-cpp`` folder."
msgstr ""
"``godot-cpp``现在包含``godot_headers``作为嵌套子模块，如果您手动下载它们，请"
"确保将 ``godot_headers`` 放在 ``godot-cpp`` 文件夹中。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:96
msgid ""
"You don't have to do it this way but we've found it easiest to manage. If "
"you decide to just download the repositories or just clone them into your "
"folder, make sure to keep the folder layout the same as we've setup here as "
"much of the code we'll be showcasing here assumes the project has this "
"layout."
msgstr ""
"您不必这样做，但我们发现它最容易管理。 如果您决定只下载存储库或只是将它们克隆"
"到您的文件夹中，请确保文件夹布局与我们在此处设置的相同，因为我们将在此处展示"
"的代码假定项目具有此布局。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:98
msgid ""
"If you cloned the example from the link specified in the introduction, the "
"submodules are not automatically initialized. You will need to execute the "
"following commands:"
msgstr ""
"如果从介绍中指定的链接克隆示例，子模块不会自动初始化。 您需要执行以下命令:"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:107
msgid "This will clone these two repositories into your project folder."
msgstr "这会将这两个存储库克隆到您的项目文件夹中。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:110
msgid "Building the C++ bindings"
msgstr "构建C++绑定"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:112
msgid ""
"Now that we've downloaded our prerequisites, it is time to build the C++ "
"bindings."
msgstr "现在我们已经下载了我们的先决条件，现在是构建C++绑定的时候了。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:115
msgid ""
"The repository contains a copy of the metadata for the current Godot "
"release, but if you need to build these bindings for a newer version of "
"Godot, simply call the Godot executable:"
msgstr ""
"存储库包含当前Godot版本的元数据副本，但如果您需要为较新版本的Godot构建这些绑"
"定，只需调用Godot可执行文件:"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:123
msgid ""
"Place the resulting ``api.json`` file in the project folder and add "
"``use_custom_api_file=yes custom_api_file=../api.json`` to the scons command "
"below."
msgstr ""
"将生成的 ``api.json`` 文件放在项目文件夹中，并将``use_custom_api_file = yes "
"custom_api_file = .. / api.json``添加到下面的scons命令中。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:125
msgid ""
"To generate and compile the bindings, use this command (replacing "
"``<platform>`` with ``windows``, ``x11`` or ``osx`` depending on your OS):"
msgstr ""
"要生成和编译绑定，请使用此命令(根据您的操作系统将 ``<platform>`` 替换为 "
"``windows`` ，``x11``或``osx``):"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:134
msgid ""
"This step will take a while. When it is completed, you should have static "
"libraries that can be compiled into your project stored in ``godot-cpp/bin/"
"``."
msgstr ""
"这一步将需要一段时间。 完成后，您应该有一个静态库，可以编译到您的项目中，存储"
"在``godot-cpp / bin /``中。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:137
msgid ""
"At some point in the future, compiled binaries will be available, making "
"this step optional."
msgstr "在将来的某个时刻，已编译的二进制文件将可用，使此步骤可选。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:140
msgid ""
"You may need to add ``bits=64`` to the command on Windows. We're still "
"working on better auto detection."
msgstr ""
"您可能需要在Windows上的命令中添加 ``bits=64`` 。 我们仍在努力进行更好的自动检"
"测。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:143
msgid "Creating a simple plugin"
msgstr "创建一个简单的插件"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:145
msgid ""
"Now it's time to build an actual plugin. We'll start by creating an empty "
"Godot project in which we'll place a few files."
msgstr ""
"现在是构建实际插件的时候了。 我们首先创建一个空的Godot项目，我们将在其中放置"
"一些文件。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:148
msgid ""
"Open Godot and create a new project. For this example, we will place it in a "
"folder called ``demo`` inside our GDNative module's folder structure."
msgstr ""
"打开Godot并创建一个新项目。 对于这个示例，我们将它放在我们的GDNative模块的文"
"件夹结构中名为 ``demo`` 的文件夹中。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:151
msgid ""
"In our demo project, we'll create a scene containing a Node called \"Main\" "
"and we'll save it as ``main.tscn``. We'll come back to that later."
msgstr ""
"在我们的演示项目中，我们将创建一个包含名为“Main”的节点的场景，我们将其保存为 "
"``main.tscn`` 。 我们稍后再回过头来看看。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:154
msgid ""
"Back in the top-level GDNative module folder, we're also going to create a "
"subfolder called ``src`` in which we'll place our source files."
msgstr ""
"回到顶级GDNative模块文件夹，我们还将创建一个名为 ``src`` 的子文件夹，我们将在"
"其中放置源文件。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:157
msgid ""
"You should now have ``demo``, ``godot-cpp``, ``godot_headers``, and ``src`` "
"directories in your GDNative module."
msgstr ""
"您现在应该在您的GDNative模块中有 ``demo`` ，``godot-cpp``， "
"``godot_headers`` 和``src``目录。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:160
msgid ""
"In the ``src`` folder, we'll start with creating our header file for the "
"GDNative node we'll be creating. We will name it ``gdexample.h``:"
msgstr ""
"在 ``src`` 文件夹中，我们将首先为我们将要创建的GDNative节点创建头文件。 我们"
"将它命名为``gdexample.h``:"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:224
msgid ""
"There are a few things of note to the above. We're including ``Godot.hpp`` "
"which contains all our basic definitions. After that, we include ``Sprite."
"hpp`` which contains bindings to the Sprite class. We'll be extending this "
"class in our module."
msgstr ""
"以上有一些注意事项。 我们包括 ``Godot.hpp`` ，其中包含我们所有的基本定义。 之"
"后，我们包含 ``Sprite.hpp`` ，它包含对Sprite类的绑定。 我们将在我们的模块中扩"
"展这个类。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:229
msgid ""
"We're using the namespace ``godot``, since everything in GDNative is defined "
"within this namespace."
msgstr ""
"我们使用命名空间 ``godot`` ，因为GDNative中的所有内容都在此命名空间中定义。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:232
msgid ""
"Then we have our class definition, which inherits from our Sprite through a "
"container class. We'll see a few side effects of this later on. The "
"``GODOT_CLASS`` macro sets up a few internal things for us."
msgstr ""
"然后我们有了我们的类定义，它通过容器类从我们的Sprite继承。 我们稍后会看到一些"
"副作用。 这也是NativeScript 1.1中将要改进的主要部分。 ``GODOT_CLASS`` 宏为我"
"们设置了一些内部事物。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:236
msgid "After that, we declare a single member variable called ``time_passed``."
msgstr "之后，我们声明一个名为 ``time_passed`` 的成员变量。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:238
msgid ""
"In the next block we're defining our methods, we obviously have our "
"constructor and destructor defined, but there are two other functions that "
"will likely look familiar to some, and one new method."
msgstr ""
"在下一个块中我们定义了我们的方法，我们显然已经定义了构造函数和析构函数，但是"
"还有其他两个函数可能看起来很熟悉。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:242
msgid ""
"The first is ``_register_methods``, which is a static function that Godot "
"will call to find out which methods can be called on our NativeScript and "
"which properties it exposes. The second is our ``_process`` function, which "
"will work exactly the same as the ``_process`` function you're used to in "
"GDScript. The third is our ``_init`` function which is called after Godot "
"has properly set up our object. It has to exist even if you don't place any "
"code in it."
msgstr ""
"第一个是 ``_register_methods`` ，这是一个静态函数，Godot将调用它来找出可以在"
"我们的NativeScript上调用哪些方法以及它暴露的属性。 第二个是我们的 "
"``_process`` 函数，它与您在GDScript中习惯的 ``_process`` 函数完全相同。 第三"
"个是我们的 ``_init`` 函数，它是在Godot正确设置我们的对象之后调用的。 即使您没"
"有在其中放置任何代码，它也必须存在。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:251
msgid "Let's implement our functions by creating our ``gdexample.cpp`` file:"
msgstr "所以，让我们通过创建 ``gdexample.cpp`` 文件来实现我们的函数:"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:311
msgid ""
"This one should be straightforward. We're implementing each method of our "
"class that we defined in our header file. Note that the ``register_method`` "
"call **must** expose the ``_process`` method, otherwise Godot will not be "
"able to use it. However, we do not have to tell Godot about our constructor, "
"destructor and ``_init`` functions."
msgstr ""
"这个应该是直截了当的。 我们正在实现我们在头文件中定义的每个类的方法。 注意 "
"``register_method`` 调用 **必须** 公开 ``_process`` 方法，否则Godot将无法使用"
"它。 但是，我们不必告诉Godot我们的构造函数，析构函数和 ``_init`` 函数。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:317
msgid ""
"The other method of note is our ``_process`` function, which simply keeps "
"track of how much time has passed and calculates a new position for our "
"sprite using a simple sine and cosine function. What stands out is calling "
"``owner->set_position`` to call one of the build in methods of our Sprite. "
"This is because our class is a container class; ``owner`` points to the "
"actual Sprite node our script relates to. In the upcoming NativeScript 1.1, "
"``set_position`` can be called directly on our class."
msgstr ""
"另一种注意方法是我们的 ``_process`` 函数，它只是跟踪已经过了多少时间，并使用"
"简单的正弦和余弦函数计算我们的精灵的新位置。 突出的是调用``owner-> "
"set_position``来调用我们的Sprite的一个内置方法。 这是因为我们的类是一个容器"
"类; ``owner``指向我们脚本所涉及的实际Sprite节点。 在即将发布的NativeScript "
"1.1中，可以在我们的类上直接调用 ``set_position`` 。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:326
msgid ""
"There is one more C++ file we need; we'll name it ``gdlibrary.cpp``. Our "
"GDNative plugin can contain multiple NativeScripts, each with their own "
"header and source file like we've implemented ``GDExample`` up above. What "
"we need now is a small bit of code that tells Godot about all the "
"NativeScripts in our GDNative plugin."
msgstr ""
"还有一个我们需要的C++文件; 我们将它命名为 ``gdlibrary.cpp`` 。 我们的GDNative"
"插件可以包含多个NativeScripts，每个都有自己的头文件和源文件，就像我们在上面实"
"现了 ``GDExample`` 一样。 我们现在需要的是一小段代码，告诉Godot我们的GDNative"
"插件中的所有NativeScripts。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:350
msgid ""
"Note that we are not using the ``godot`` namespace here, since the three "
"functions implemented here need to be defined without a namespace."
msgstr ""
"请注意，我们这里没有使用 ``godot`` 命名空间，因为这里实现的三个函数需要在没有"
"命名空间的情况下定义。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:353
msgid ""
"The ``godot_gdnative_init`` and ``godot_gdnative_terminate`` functions get "
"called respectively when Godot loads our plugin and when it unloads it. All "
"we're doing here is parse through the functions in our bindings module to "
"initialize them, but you might have to set up more things depending on your "
"needs."
msgstr ""
"当Godot加载我们的插件并卸载它时，分别调用 ``godot_gdnative_init`` 和"
"``godot_gdnative_terminate``函数。 我们在这里所做的只是解析我们的绑定模块中的"
"函数来初始化它们，但您可能需要根据需要设置更多内容。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:359
msgid ""
"The important function is the third function called "
"``godot_nativescript_init``. We first call a function in our bindings "
"library that does its usual stuff. After that, we call the function "
"``register_class`` for each of our classes in our library."
msgstr ""
"重要的功能是第三个函数叫做`godot_nativescript_init``。 我们首先在我们的绑定库"
"中调用一个函数来执行它常用的东西。 之后，我们为库中的每个类调用函数 "
"``register_class`` 。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:365
msgid "Compiling the plugin"
msgstr "编译插件"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:367
msgid ""
"We cannot easily write by hand a ``SConstruct`` file that SCons would use "
"for building. For the purpose of this example, just use :download:`this "
"hardcoded SConstruct file <files/cpp_example/SConstruct>` we've prepared. "
"We'll cover a more customizable, detailed example on how to use these build "
"files in a subsequent tutorial."
msgstr ""
"我们不能轻易地手工编写SCons用于构建的 ``SConstruct`` 文件。 出于这个示例的目"
"的，只需使用:download:`这个硬编码的SConstruct文件<files / cpp_example / "
"SConstruct>` 我们已经准备好了。 我们将在后续教程中介绍如何使用这些构建文件的"
"更可定制的详细示例。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:373
#, fuzzy
msgid ""
"This ``SConstruct`` file was written to be used with the latest ``godot-"
"cpp`` master, you may need to make small changes using it with older "
"versions or refer to the ``SConstruct`` file in the Godot 3.0 documentation."
msgstr ""
"这个 ``SConstruct`` 文件被编写为与最新的godot-cpp主机一起使用，您可能需要使用"
"旧版本进行小的更改，或者参考Godot 3.0文档中的 ``SConstruct`` 文件。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:378
msgid ""
"Once you've downloaded the ``SConstruct`` file, place it in your GDNative "
"module folder besides ``godot-cpp``, ``godot_headers`` and ``demo``, then "
"run:"
msgstr ""
"一旦您下载了 ``SConstruct`` 文件，除了 ``godot-cpp`` ，``godot_headers``和"
"``demo``之外，把它放在您的GDNative模块文件夹中，然后运行:"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:386
msgid "You should now be able to find the module in ``demo/bin/<platform>``."
msgstr "您现在应该能够在``demo / bin / <platform>``中找到该模块。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:390
msgid ""
"Here, we've compiled both godot-cpp and our gdexample library as debug "
"builds. For optimized builds, you should compile them using the "
"``target=release`` switch."
msgstr ""
"在这里，我们编译了godot-cpp和我们的gdexample库作为调试版本。 对于优化的构建，"
"您应该使用``target = release``开关编译它们。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:395
msgid "Using the GDNative module"
msgstr "使用GDNative模块"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:397
msgid ""
"Before we jump back into Godot, we need to create two more files in ``demo/"
"bin/``. Both can be created using the Godot editor, but it may be faster to "
"create them directly."
msgstr ""
"在我们跳回Godot之前，我们需要在``demo / bin /``中再创建两个文件。 两者都可以"
"使用Godot编辑器创建，但直接创建它们可能会更快。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:401
msgid ""
"The first one is a file that lets Godot know what dynamic libraries should "
"be loaded for each platform and is called ``gdexample.gdnlib``."
msgstr ""
"第一个是一个文件，让Godot知道应该为每个平台加载什么动态库，并称为 "
"``gdexample.gdnlib`` 。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:425
msgid ""
"This file contains a ``general`` section that controls how the module is "
"loaded. It also contains a prefix section which should be left on ``godot_`` "
"for now. If you change this, you'll need to rename various functions that "
"are used as entry points. This was added for the iPhone platform because it "
"doesn't allow dynamic libraries to be deployed, yet GDNative modules are "
"linked statically."
msgstr ""
"该文件包含一个“general”部分，用于控制模块的加载方式。 它还包含一个前缀部分，"
"现在应该留在 ``godot_`` 。 如果更改此设置，则需要重命名用作入口点的各种函"
"数。 这是为iPhone平台添加的，因为它不允许部署动态库，但GDNative模块是静态链接"
"的。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:432
msgid ""
"The ``entry`` section is the important bit: it tells Godot the location of "
"the dynamic library in the project's filesystem for each supported platform. "
"It will also result in *just* that file being exported when you export the "
"project, which means the data pack won't contain libraries that are "
"incompatible with the target platform."
msgstr ""
"``entry``部分是重要的一点:它告诉Godot每个支持平台的项目文件系统中动态库的位"
"置。 导出项目时，它也会导致* just *导出文件，这意味着数据包不会包含与目标平台"
"不兼容的库。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:438
msgid ""
"Finally, the ``dependencies`` section allows you to name additional dynamic "
"libraries that should be included as well. This is important when your "
"GDNative plugin implements someone else's library and requires you to supply "
"a third-party dynamic library with your project."
msgstr ""
"最后， ``dependencies`` 部分允许您命名应包含的其他动态库。 当您的GDNative插件"
"实现其他人的库并要求您为项目提供第三方动态库时，这一点非常重要。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:443
msgid ""
"If you double click on the ``gdexample.gdnlib`` file within Godot, you'll "
"see there are far more options to set:"
msgstr ""
"如果您双击Godot中的 ``gdexample.gdnlib`` 文件，您会看到还有更多的选项要设置:"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:448
msgid ""
"The second file we need to create is a file used by each NativeScript we've "
"added to our plugin. We'll name it ``gdexample.gdns`` for our gdexample "
"NativeScript."
msgstr ""
"我们需要创建的第二个文件是我们添加到插件中的每个NativeScript使用的文件。 我们"
"将它命名为 ``gdexample.gdns`` 用于我们的gdexample NativeScript。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:465
msgid ""
"This is a standard Godot resource; you could just create it directly in your "
"scene, but saving it to a file makes it much easier to reuse it in other "
"places. This resource points to our gdnlib file, so that Godot can know "
"which dynamic library contains our NativeScript. It also defines the "
"``class_name`` which identifies the NativeScript in our plugin we want to "
"use."
msgstr ""
"这是标准的Godot资源; 您可以直接在场景中创建它，但将其保存到文件可以更容易地在"
"其他地方重用它。 这个资源指向我们的gdnlib文件，因此Godot可以知道哪个动态库包"
"含我们的NativeScript。 它还定义了 ``class_name`` ，它标识了我们想要使用的插件"
"中的NativeScript。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:472
msgid ""
"Time to jump back into Godot. We load up the main scene we created way back "
"in the beginning and now add a Sprite to our scene:"
msgstr ""
"是时候跳回Godot了。 我们在开始时加载我们创建的主场景，现在为场景添加一个"
"Sprite:"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:477
msgid ""
"We're going to assign the Godot logo to this sprite as our texture, disable "
"the ``centered`` property and drag our ``gdexample.gdns`` file onto the "
"``script`` property of the sprite:"
msgstr ""
"我们要将Godot徽标指定给这个精灵作为我们的纹理，禁用 ``centered`` 属性并将我们"
"的 ``gdexample.gdns`` 文件拖到精灵的 ``script`` 属性中:"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:483
msgid "We're finally ready to run the project:"
msgstr "我们终于准备好运行这个项目了:"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:488
msgid "Adding properties"
msgstr "添加属性"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:490
msgid ""
"GDScript allows you to add properties to your script using the ``export`` "
"keyword. In GDNative you have to register the properties and there are two "
"ways of doing this. You can either bind directly to a member or use a setter "
"and getter function."
msgstr ""
"GDScript允许您使用 ``export`` 关键字向脚本添加属性。 在GDNative中，您必须注册"
"属性，有两种方法可以执行此操作。 您可以直接绑定到成员，也可以使用setter和"
"getter函数。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:496
msgid ""
"There is a third option, just like in GDScript you can directly implement "
"the ``_get_property_list``, ``_get`` and ``_set`` methods of an object but "
"that goes far beyond the scope of this tutorial."
msgstr ""
"还有第三种选择，就像在GDScript中一样，您可以直接实现一个对象的 "
"``_get_property_list`` ， ``_get`` 和 ``_set`` 方法，但这远远超出了本教程的范"
"围。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:500
msgid ""
"We'll examine both starting with the direct bind. Lets add a property that "
"allows us to control the amplitude of our wave."
msgstr ""
"我们将从直接绑定开始检查两者。 让我们添加一个允许我们控制波浪幅度的属性。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:503
msgid ""
"In our ``gdexample.h`` file we simply need to add a member variable like so:"
msgstr "在我们的 ``gdexample.h`` 文件中，我们只需添加一个成员变量，如下所示:"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:513
msgid ""
"In our ``gdexample.cpp`` file we need to make a number of changes, we will "
"only show the methods we end up changing, don't remove the lines we're "
"omitting:"
msgstr ""
"在我们的 ``gdexample.cpp`` 文件中，我们需要进行一些更改，我们只会显示我们最终"
"更改的方法，不要删除我们省略的行:"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:565
msgid ""
"Once you compile the module with these changes in place you will see that a "
"property has been added to our interface. You can now change this property "
"and when you run your project, you will see that our Godot icon travels "
"along a larger figure."
msgstr ""
"一旦您使用这些更改编译模块，您将看到已将属性添加到我们的界面。 您现在可以更改"
"此属性，当您运行项目时，您将看到我们的Godot图标沿着更大的数字移动。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:571
msgid ""
"The ``reloadable`` property in the ``gdexample.gdnlib`` file must be set to "
"``true`` for the Godot editor to automatically pick up the newly added "
"property."
msgstr ""

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:574
msgid ""
"However, this setting should be used with care especially when tool classes "
"are used, as the editor might hold objects then that have script instances "
"attached to them that are managed by a GDNative library."
msgstr ""

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:577
msgid ""
"Lets do the same but for the speed of our animation and use a setter and "
"getter function. Our ``gdexample.h`` header file again only needs a few more "
"lines of code:"
msgstr ""
"让我们做同样的事情但是为了我们动画的速度并使用setter和getter函数。 我们的 "
"``gdexample.h`` 头文件再次只需要几行代码:"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:591
msgid ""
"This requires a few more changes to our ``gdexample.cpp`` file, again we're "
"only showing the methods that have changed so don't remove anything we're "
"omitting:"
msgstr ""
"这需要对我们的 ``gdexample.cpp`` 文件进行一些更改，同样我们只显示已更改的方"
"法，所以不要删除我们忽略的任何内容:"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:663
msgid ""
"Now when the project is compiled we'll see another property called speed. "
"Changing its value will make the animation go faster or slower."
msgstr ""
"现在，当编译项目时，我们将看到另一个名为speed的属性。 更改其值将使动画更快或"
"更慢。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:666
msgid ""
"For this example there is no obvious advantage of using a setter and getter. "
"It is just more code to write. For a simple example as this there may be a "
"good reason for a setter if you want to react on the variable being changed "
"but in many cases just binding the variable will be enough."
msgstr ""
"对于这个示例，使用setter和getter没有明显的优势。 这只是更多的代码编写。 对于"
"一个简单的示例，如果您想对改变的变量做出反应，那么设置器可能有充分的理由，但"
"在很多情况下只需绑定变量就足够了。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:671
msgid ""
"Getters and setters become far more useful in more complex scenarios where "
"you need to make additional choices based on the state of your object."
msgstr ""
"在需要根据对象状态做出其他选择的更复杂场景中，getter和setter变得更加有用。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:677
msgid ""
"For simplicity we've left out the optional parameters in the "
"register_property<class, type> method call. These parameters are "
"``rpc_mode``, ``usage``, ``hint`` and ``hint_string``. These can be used to "
"further configure how properties are displayed and set on the Godot side."
msgstr ""
"为简单起见，我们在register_property <class，type>方法调用中省略了可选参数。 "
"这些参数是 ``rpc_mode`` ， ``usage`` ， ``hint`` 和 ``hint_string`` 。 这些可"
"用于进一步配置属性在Godot方面的显示和设置方式。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:683
msgid ""
"Modern C++ compilers are able to infer the class and variable type and allow "
"you to omit the ``<GDExample, float>`` part of our ``register_property`` "
"method. we've had mixed experiences with this however."
msgstr ""
"现代C++编译器能够推断出类和变量类型，并允许您省略 ``register_property`` 方法"
"的 ``<GDExample，float>`` 部分。 然而，我们对此有过不同的经历。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:691
msgid ""
"Last but not least, signals fully work in GDNative as well. Having your "
"module react to a signal given out by another object requires you to call "
"``connect`` on that object. We can't think of a good example for our "
"wobbling Godot icon, we would need to showcase a far more complete example."
msgstr ""
"最后但同样重要的是，信号也完全适用于GDNative。 让模块对另一个对象发出的信号作"
"出反应，需要在该对象上调用 ``connect`` 。 我们想不出一个摆动Godot图标的好示"
"例，我们需要展示一个更完整的示例。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:697
msgid "This however is the required syntax:"
msgstr "但这是必需的语法:"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:708
msgid ""
"Note that you can only call ``my_method`` if you've previously registered it "
"in your ``_register_methods`` method."
msgstr ""
"请注意，如果您之前在 ``_register_methods`` 方法中注册了它，则只能调用 "
"``my_method`` 。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:711
msgid ""
"Having your object sending out signals is far more common. For our wobbling "
"Godot icon we'll do something silly just to show how it works. We're going "
"to emit a signal every time a second has passed and pass the new location "
"along."
msgstr ""
"让对象发出信号更为常见。 对于我们摇摆不定的Godot图标，我们会做一些愚蠢的事情"
"来展示它是如何工作的。 每过一秒钟我们就会发出一个信号并传递新的位置。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:716
msgid ""
"In our ``gdexample.h`` header file we just need to define a new member "
"``time_emit``:"
msgstr ""
"在我们的 ``gdexample.h`` 头文件中，我们只需要定义一个新成员 ``time_emit`` :"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:726
msgid ""
"The changes in ``gdexample.cpp`` are a bit more elaborate this time. First "
"you'll need to set ``time_emit = 0.0;`` in either our ``_init`` method or in "
"our constructor. But the other two needed changes we'll look at one by one."
msgstr ""
"这次 ``gdexample.cpp`` 的变化有点复杂。 首先，您需要在我们的 ``_init`` 方法或"
"我们的构造函数中设置``time_emit = 0.0;``。 但另外两个需要改变，我们将逐一看"
"待。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:730
msgid ""
"In our ``_register_methods`` method we need to declare our signal and we do "
"this as follows:"
msgstr ""
"在我们的 ``_register_methods`` 方法中，我们需要声明我们的信号，我们按如下方式"
"执行:"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:757
msgid ""
"Here we see a nice improvement in the latest version of godot-cpp where our "
"``register_signal`` method can be a single call first taking the signals "
"name, then having pairs of values specificying the parameter name and type "
"of each parameter we'll send along with this signal."
msgstr ""
"在这里我们看到了最新版本的godot-cpp的一个很好的改进，其中我们的 "
"``register_signal`` 方法可以是一个单独的调用，首先取信号名称，然后有一对值来"
"指定参数名称和每个参数的类型我们将 发送此信号。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:762
msgid ""
"For NativeScript 1.0 we first build a dictionary in which we tell Godot "
"about the types of arguments we will pass to our signal, and then register "
"it."
msgstr ""
"对于NativeScript 1.0，我们首先构建一个字典，在其中我们告诉Godot我们将传递给信"
"号的参数类型，然后注册它。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:765
msgid "Next we'll need to change our ``_process`` method:"
msgstr "接下来我们需要更改 ``_process`` 方法:"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:811
msgid ""
"After a second has passed we emit our signal and reset our counter. Again in "
"the new version of godot-cpp we can add our parameter values directly to "
"``emit_signal``. In NativeScript 1.0 We first build an array of values and "
"then call ``emit_signal``."
msgstr ""
"经过一秒钟后，我们发出信号并重置我们的计数器。再次在新版本的godot-cpp中，我们"
"可以将参数值直接添加到 ``emit_signal`` 。在NativeScript 1.0中我们首先构建一个"
"值数组，然后调用 ``emit_signal`` 。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:817
msgid ""
"Once compiled we can go into Godot and select our sprite node. On our "
"``Node`` tab we find our new signal and link it up by pressing connect. "
"We've added a script on our main node and implemented our signal like this:"
msgstr ""
"编译完成后，我们可以进入Godot并选择我们的精灵节点。在我们的 ``Node`` 选项卡"
"上，我们找到了我们的新信号并通过按连接将其链接起来。我们在主节点上添加了一个"
"脚本并实现了这样的信号:"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:828
msgid "Every second we simply output our position to the console."
msgstr "每一秒我们只需将我们的位置输出到控制台。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:832
#, fuzzy
msgid "NativeScript 1.1 vs NativeScript 1.0"
msgstr "NativeScript 1.1 与 NativeScript 1.0"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:834
msgid ""
"So far in our example above there doesn't seem to be a lot of difference "
"between the old and new syntax. The class is defined slightly differently "
"and we no longer use the ``owner`` member to call methods on the Godot side "
"of our object. A lot of the improvements are hidden under the hood."
msgstr ""
"到目前为止，在上面的示例中，旧语法和新语法之间似乎没有太大区别。该类的定义略"
"有不同，我们不再使用 ``owner`` 成员来调用对象Godot一侧的方法。很多改进都隐藏"
"在引擎盖下。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:839
msgid ""
"This example only deals with simple variables and simple methods. Especially "
"once you start passing references to other objects or when you start calling "
"methods that require more complex parameters, NativeScript 1.1 does start to "
"show its benefits."
msgstr ""
"此示例仅处理简单变量和简单方法。特别是一旦开始传递对其他对象的引用，或者当您"
"开始调用需要更复杂参数的方法时，NativeScript 1.1确实开始显示它的好处。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:845
msgid "Next steps"
msgstr "下一步"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:847
msgid ""
"The above is only a simple example, but we hope it shows you the basics. You "
"can build upon this example to create full-fledged scripts to control nodes "
"in Godot using C++."
msgstr ""
"以上只是一个简单的示例，但我们希望它向您展示基础知识。 您可以在此示例的基础上"
"构建完整的脚本，以使用C++控制Godot中的节点。"

#: ../../docs/tutorials/plugins/gdnative/gdnative-cpp-example.rst:851
msgid ""
"You should be able to edit and recompile the plugin while the Godot editor "
"remains open; just rerun the project after the library has finished building."
msgstr ""
"在Godot编辑器保持打开状态时，您应该能够编辑和重新编译插件; 在库完成构建后重新"
"运行项目。"

#: ../../docs/tutorials/platform/android_in_app_purchases.rst:4
msgid "Android in-app purchases"
msgstr "Android应用内购买"

#: ../../docs/tutorials/platform/android_in_app_purchases.rst:8
msgid ""
"Godot engine has integrated GooglePaymentsV3 module with which we can "
"implement in-app purchases in our game."
msgstr "Godot引擎集成了GooglePaymentsV3模块，我们可以在游戏中实现应用内购买。"

#: ../../docs/tutorials/platform/android_in_app_purchases.rst:10
msgid ""
"The Godot engine demo project repository has an android-iap example project. "
"It includes a gdscript interface for android IAP."
msgstr ""
"Godot引擎演示项目存储库有一个名为android-iap示例项目。 它包括一个用于android "
"IAP的gdscript接口。"

#: ../../docs/tutorials/platform/android_in_app_purchases.rst:12
msgid ""
"Check the repository here https://github.com/godotengine/godot-demo-projects"
msgstr "在这里检查存储库 https://github.com/godotengine/godot-demo-projects"

#: ../../docs/tutorials/platform/android_in_app_purchases.rst:14
msgid "Find the iap.gd script in"
msgstr "找到iap.gd脚本"

#: ../../docs/tutorials/platform/android_in_app_purchases.rst:21
msgid ""
"Add it to the Autoload list and name it as IAP so that we can reference it "
"anywhere in the game."
msgstr ""
"将其添加到自动加载列表并将其命名为IAP，以便我们可以在游戏中的任何位置引用它。"

#: ../../docs/tutorials/platform/android_in_app_purchases.rst:24
msgid "Getting the product details"
msgstr "获取产品详细信息"

#: ../../docs/tutorials/platform/android_in_app_purchases.rst:26
msgid ""
"When starting our game, we will need to get the item details from Google "
"such as the product price, description and localized price string etc."
msgstr ""
"在开始游戏时，我们需要从Google获取商品详情，例如产品价格，描述和本地化价格字"
"符串等。"

#: ../../docs/tutorials/platform/android_in_app_purchases.rst:42
msgid ""
"We can use the IAP details to display the title, price and/or description on "
"our shop scene."
msgstr "在我们的商店场景中， 我们可以使用IAP详细信息显示标题，价格和描述。"

#: ../../docs/tutorials/platform/android_in_app_purchases.rst:45
msgid "Check if user purchased an item"
msgstr "检查用户是否购买了商品"

#: ../../docs/tutorials/platform/android_in_app_purchases.rst:47
msgid ""
"When starting our game, we can check if the user has purchased any product. "
"YOU SHOULD DO THIS ONLY AFTER 2/3 SECONDS AFTER YOUR GAME IS LOADED. If we "
"do this as the first thing when the game is launched, IAP might not be "
"initialized and our game will crash on start."
msgstr ""
"在开始游戏时，我们可以检查用户是否购买了任何产品。 您应该在您的游戏加载后的"
"2/3秒之后再做这件事。 如果我们在游戏启动时首先执行此操作，IAP可能无法初始化，"
"我们的游戏将在启动时崩溃。"

#: ../../docs/tutorials/platform/android_in_app_purchases.rst:60
msgid ""
"Google IAP policy says the game should restore the user's purchases if the "
"user replaces their phone or reinstalls the same app. We can use the above "
"code to check what products the user has purchased and we can make our game "
"respond accordingly."
msgstr ""
"Google IAP政策规定，如果用户更换手机或重新安装相同的应用，游戏应恢复用户的购"
"买。 我们可以使用上面的代码来检查用户购买了哪些产品，从而让我们的游戏做出相应"
"的响应。"

#: ../../docs/tutorials/platform/android_in_app_purchases.rst:63
msgid "Simple Purchase"
msgstr "简单购买"

#: ../../docs/tutorials/platform/android_in_app_purchases.rst:65
msgid "We can put this purchase logic on a product's buy button."
msgstr "我们可以将此购买逻辑放在产品的购买按钮上。"

#: ../../docs/tutorials/platform/android_in_app_purchases.rst:80
msgid ""
"We can also implement other signals for the purchase flow and improve the "
"user experience as you needed."
msgstr "我们还可以为购买流程实施其他信号，并根据需要改善用户体验。"

#: ../../docs/tutorials/platform/android_in_app_purchases.rst:82
msgid "``purchase_fail`` - When the purchase is failed due to any reason"
msgstr "``purchase_fail`` - 当购买因任何原因失败时"

#: ../../docs/tutorials/platform/android_in_app_purchases.rst:84
msgid "``purchase_cancel`` - When the user cancels the purchase"
msgstr "``purchase_cancel`` - 当用户取消购买时"

#: ../../docs/tutorials/platform/android_in_app_purchases.rst:86
msgid "``purchase_owned`` - When the user already bought the product earlier"
msgstr "``purchase_owned`` - 用户之前已经购买过该产品"

#: ../../docs/tutorials/platform/android_in_app_purchases.rst:90
msgid "Consumables and Non-Consumables"
msgstr "消耗品和非消耗品"

#: ../../docs/tutorials/platform/android_in_app_purchases.rst:92
msgid ""
"There are two types of products - consumables and non-consumables. "
"**Consumables** are purchased and used, for eg: healing potions which can be "
"purchased again and again. **Non-consumables** are one time purchases, for "
"eg: Level packs."
msgstr ""
"有两种类型的产品 - 消耗品和非消耗品。 **消耗品** 被购买和消耗，例如:可以多次"
"购买的治疗药水。 **非消耗品** 是一次性购买，例如:等级包。"

#: ../../docs/tutorials/platform/android_in_app_purchases.rst:96
msgid ""
"Google doesn't have this separation in their dashboard. If our product is a "
"consumable, and if a user has purchased it, it will not be available for "
"purchase until it is consumed. So we should call the consume method for our "
"consumables and don't call consume for your non-consumables."
msgstr ""
"Google在其信息中心中没有这种划分。 如果我们的产品是消耗品，并且如果用户购买了"
"它，则在消费之前将无法购买。 因此，我们应该为消耗品调用消费方法，不要为非消耗"
"品调用消费。"

#: ../../docs/tutorials/platform/android_in_app_purchases.rst:106
msgid ""
"If our game has only consumables, we don't have to do this. We can set it to "
"consume the item automatically after a purchase."
msgstr ""
"如果我们的游戏只有消耗品，我们不必这样做。 我们可以将其设置为在购买后自动消耗"
"该物品。"

#: ../../docs/tutorials/platform/android_in_app_purchases.rst:112
msgid "If our game has only non-consumables, we can"
msgstr "如果我们的游戏只有非消耗品，我们可以"

#: ../../docs/tutorials/platform/android_in_app_purchases.rst:118
msgid "We should set the auto consume value only once when the game starts."
msgstr "在游戏开始时， 我们应该只设置一次自动消耗值。"

#: ../../docs/tutorials/platform/android_in_app_purchases.rst:121
msgid "Testing"
msgstr "测试"

#: ../../docs/tutorials/platform/android_in_app_purchases.rst:123
msgid ""
"If we add a gmail id as a tester in Google dashboard, that tester can "
"purchase items and they will not be charged. Another way to test IAP is "
"using redeem codes generated by us for our game because the purchase flow is "
"the same."
msgstr ""
"如果我们在Google信息中心中添加gmail ID作为测试人员，则该测试人员可以购买商"
"品，但不会向他们收费。 另一种测试IAP的方法是使用我们为游戏生成的兑换代码，因"
"为购买流程是相同的。"

#: ../../docs/tutorials/platform/android_in_app_purchases.rst:125
msgid ""
"Third way of testing is in development side. If we put the product ids as "
"shown below, we will get a static fixed response according to the product "
"id. This is a quick way of testing things before going to the dashboard."
msgstr ""
"第三种测试方法是开发侧。 如果我们按如下所示放置产品ID，我们将根据产品ID获得静"
"态固定响应。 这是在进入仪表板之前测试事物的快速方法。"

#: ../../docs/tutorials/platform/android_in_app_purchases.rst:127
msgid "android.test.purchased"
msgstr "android.test.purchased"

#: ../../docs/tutorials/platform/android_in_app_purchases.rst:128
msgid "android.test.canceled"
msgstr "android.test.canceled"

#: ../../docs/tutorials/platform/android_in_app_purchases.rst:129
msgid "android.test.refunded"
msgstr "android.test.refunded"

#: ../../docs/tutorials/platform/android_in_app_purchases.rst:130
msgid "android.test.item_unavailable"
msgstr "android.test.item_unavailable"

#: ../../docs/tutorials/platform/services_for_ios.rst:6
msgid ""
"At the moment, there are two iOS APIs partially implemented, GameCenter and "
"Storekit. Both use the same model of asynchronous calls explained below."
msgstr ""
"目前，有两个部分实现的iOS API，GameCenter和Storekit。 两者都使用下面解释的相"
"同模型的异步调用。"

#: ../../docs/tutorials/platform/services_for_ios.rst:11
msgid "Asynchronous methods"
msgstr "异步方法"

#: ../../docs/tutorials/platform/services_for_ios.rst:13
msgid ""
"When requesting an asynchronous operation, the method will look like this:"
msgstr "请求异步操作时，方法如下所示:"

#: ../../docs/tutorials/platform/services_for_ios.rst:20
msgid ""
"The parameter will usually be a Dictionary, with the information necessary "
"to make the request, and the call will have two phases. First, the method "
"will immediately return an Error value. If the Error is not 'OK', the call "
"operation is completed, with an error probably caused locally (no internet "
"connection, API incorrectly configured, etc). If the error value is 'OK', a "
"response event will be produced and added to the 'pending events' queue. "
"Example:"
msgstr ""
"参数通常是一个字典，包含发出请求所需的信息，并且调用将有两个阶段。 首先，该方"
"法将立即返回Error值。 如果错误不是“OK”，则调用操作完成，可能在本地引起错误(没"
"有Internet连接，API配置不正确等)。 如果错误值为“OK”，则会生成响应事件并将其添"
"加到“挂起事件”队列中。 例:"

#: ../../docs/tutorials/platform/services_for_ios.rst:47
msgid ""
"Remember that when a call returns OK, the API will *always* produce an event "
"through the pending_event interface, even if it's an error, or a network "
"timeout, etc. You should be able to, for example, safely block the interface "
"waiting for a reply from the server. If any of the APIs don't behave this "
"way it should be treated as a bug."
msgstr ""
"请记住，当一个调用返回OK时，API将 *始终* 通过pending_event接口产生一个事件，"
"即使它是一个错误，或网络超时等。您应该能够，例如，安全地阻止等待的接口 来自服"
"务器的回复。 如果任何API不以这种方式运行，则应将其视为错误。"

#: ../../docs/tutorials/platform/services_for_ios.rst:53
msgid "The pending event interface consists of two methods:"
msgstr "挂起事件接口包含两个方法:"

#: ../../docs/tutorials/platform/services_for_ios.rst:55
msgid ""
"``get_pending_event_count()`` Returns the number of pending events on the "
"queue."
msgstr "``get_pending_event_count()``返回队列中挂起事件的数量。"

#: ../../docs/tutorials/platform/services_for_ios.rst:58
msgid ""
"``Variant pop_pending_event()`` Pops the first event from the queue and "
"returns it."
msgstr "``Variant pop_pending_event()``弹出队列中的第一个事件并返回它。"

#: ../../docs/tutorials/platform/services_for_ios.rst:62
msgid "Store Kit"
msgstr "商店套件"

#: ../../docs/tutorials/platform/services_for_ios.rst:64
msgid "Implemented in platform/iphone/in_app_store.mm"
msgstr "在platform / iphone / in_app_store.mm中实现"

#: ../../docs/tutorials/platform/services_for_ios.rst:66
msgid ""
"The Store Kit API is accessible through the \"InAppStore\" singleton (will "
"always be available from gdscript). It is initialized automatically. It has "
"three methods for purchasing:"
msgstr ""
"Store Kit API可通过“InAppStore”单例访问(始终可从gdscript获得)。 它会自动初始"
"化。 它有三种购买方式:"

#: ../../docs/tutorials/platform/services_for_ios.rst:70
msgid "``Error purchase(Variant p_params);``"
msgstr "``Error purchase(Variant p_params);``"

#: ../../docs/tutorials/platform/services_for_ios.rst:71
msgid "``Error request_product_info(Variant p_params);``"
msgstr "``Error request_product_info(Variant p_params);``"

#: ../../docs/tutorials/platform/services_for_ios.rst:72
msgid "``Error restore_purchases();``"
msgstr "``Error restore_purchases();``"

#: ../../docs/tutorials/platform/services_for_ios.rst:74
msgid "and the pending_event interface"
msgstr "和pending_event接口"

#: ../../docs/tutorials/platform/services_for_ios.rst:82
msgid "purchase"
msgstr "采购"

#: ../../docs/tutorials/platform/services_for_ios.rst:84
msgid "Purchases a product id through the Store Kit API."
msgstr "通过Store Kit API购买产品ID。"

#: ../../docs/tutorials/platform/services_for_ios.rst:89
msgid ""
"Takes a Dictionary as a parameter, with one field, ``product_id``, a string "
"with your product id. Example:"
msgstr ""
"将Dictionary作为参数，使用一个字段 ``product_id`` ，一个包含产品ID的字符串。 "
"例:"

#: ../../docs/tutorials/platform/services_for_ios.rst:97
#: ../../docs/tutorials/platform/services_for_ios.rst:137
#: ../../docs/tutorials/platform/services_for_ios.rst:161
#: ../../docs/tutorials/platform/services_for_ios.rst:210
#: ../../docs/tutorials/platform/services_for_ios.rst:257
#: ../../docs/tutorials/platform/services_for_ios.rst:286
#: ../../docs/tutorials/platform/services_for_ios.rst:316
#: ../../docs/tutorials/platform/services_for_ios.rst:348
#: ../../docs/tutorials/platform/services_for_ios.rst:405
msgid "Response event"
msgstr "响应事件"

#: ../../docs/tutorials/platform/services_for_ios.rst:99
#: ../../docs/tutorials/platform/services_for_ios.rst:139
#: ../../docs/tutorials/platform/services_for_ios.rst:212
#: ../../docs/tutorials/platform/services_for_ios.rst:259
#: ../../docs/tutorials/platform/services_for_ios.rst:288
#: ../../docs/tutorials/platform/services_for_ios.rst:318
#: ../../docs/tutorials/platform/services_for_ios.rst:350
#: ../../docs/tutorials/platform/services_for_ios.rst:407
msgid "The response event will be a dictionary with the following fields:"
msgstr "响应事件将是包含以下字段的字典:"

#: ../../docs/tutorials/platform/services_for_ios.rst:101
#: ../../docs/tutorials/platform/services_for_ios.rst:214
#: ../../docs/tutorials/platform/services_for_ios.rst:261
#: ../../docs/tutorials/platform/services_for_ios.rst:290
#: ../../docs/tutorials/platform/services_for_ios.rst:320
#: ../../docs/tutorials/platform/services_for_ios.rst:352
msgid "On error:"
msgstr "出错:"

#: ../../docs/tutorials/platform/services_for_ios.rst:111
#: ../../docs/tutorials/platform/services_for_ios.rst:225
#: ../../docs/tutorials/platform/services_for_ios.rst:271
#: ../../docs/tutorials/platform/services_for_ios.rst:300
#: ../../docs/tutorials/platform/services_for_ios.rst:330
#: ../../docs/tutorials/platform/services_for_ios.rst:362
msgid "On success:"
msgstr "成功时:"

#: ../../docs/tutorials/platform/services_for_ios.rst:122
msgid "request_product_info"
msgstr "request_product_info"

#: ../../docs/tutorials/platform/services_for_ios.rst:124
msgid "Requests the product info on a list of product IDs."
msgstr "在产品ID列表中请求产品信息。"

#: ../../docs/tutorials/platform/services_for_ios.rst:129
msgid ""
"Takes a Dictionary as a parameter, with one field, ``product_ids``, a string "
"array with a list of product ids. Example:"
msgstr ""
"将Dictionary作为参数，使用一个字段 ``product_ids`` ，一个带有产品ID列表的字符"
"串数组。 例:"

#: ../../docs/tutorials/platform/services_for_ios.rst:155
msgid "restore_purchases"
msgstr "restore_purchases"

#: ../../docs/tutorials/platform/services_for_ios.rst:157
msgid ""
"Restores previously made purchases on user's account. This will create "
"response events for each previously purchased product id."
msgstr ""
"恢复以前在用户帐户上进行的购买。 这将为每个先前购买的产品ID创建响应事件。"

#: ../../docs/tutorials/platform/services_for_ios.rst:163
msgid "The response events will be dictionaries with the following fields:"
msgstr "响应事件将是包含以下字段的字典:"

#: ../../docs/tutorials/platform/services_for_ios.rst:174
msgid "Game Center"
msgstr "游戏中心"

#: ../../docs/tutorials/platform/services_for_ios.rst:176
msgid "Implemented in platform/iphone/game_center.mm"
msgstr "在platform / iphone / game_center.mm中实现"

#: ../../docs/tutorials/platform/services_for_ios.rst:178
msgid ""
"The Game Center API is available through the \"GameCenter\" singleton. It "
"has 6 methods:"
msgstr "Game Center API可通过“GameCenter”单例获得。 它有6种方法:"

#: ../../docs/tutorials/platform/services_for_ios.rst:181
msgid "``Error post_score(Variant p_score);``"
msgstr "``Error post_score(Variant p_score);``"

#: ../../docs/tutorials/platform/services_for_ios.rst:182
msgid "``Erroraward_achievement(Variant p_params);``"
msgstr "``Erroraward_achievement(Variant p_params);``"

#: ../../docs/tutorials/platform/services_for_ios.rst:183
msgid "``Error reset_achievements();``"
msgstr "``Error reset_achievements();``"

#: ../../docs/tutorials/platform/services_for_ios.rst:184
msgid "``Error request_achievements();``"
msgstr "``Error request_achievements();``"

#: ../../docs/tutorials/platform/services_for_ios.rst:185
msgid "``Error request_achievement_descriptions();``"
msgstr "``Error request_achievement_descriptions();``"

#: ../../docs/tutorials/platform/services_for_ios.rst:186
msgid "``Error show_game_center(Variant p_params);``"
msgstr "``Error show_game_center(Variant p_params);``"

#: ../../docs/tutorials/platform/services_for_ios.rst:188
msgid "plus the standard pending event interface."
msgstr "加上标准的待处理事件接口。"

#: ../../docs/tutorials/platform/services_for_ios.rst:191
msgid "post_score"
msgstr "post_score"

#: ../../docs/tutorials/platform/services_for_ios.rst:193
msgid "Posts a score to a Game Center leaderboard."
msgstr "将分数发布到游戏中心排行榜。"

#: ../../docs/tutorials/platform/services_for_ios.rst:198
#: ../../docs/tutorials/platform/services_for_ios.rst:387
msgid "Takes a Dictionary as a parameter, with two fields:"
msgstr "将Dictionary作为参数，包含两个字段:"

#: ../../docs/tutorials/platform/services_for_ios.rst:200
msgid "``score`` a float number"
msgstr "``得分``浮点数"

#: ../../docs/tutorials/platform/services_for_ios.rst:201
msgid "``category`` a string with the category name"
msgstr "``category``一个带有类别名称的字符串"

#: ../../docs/tutorials/platform/services_for_ios.rst:235
msgid "award_achievement"
msgstr "award_achievement"

#: ../../docs/tutorials/platform/services_for_ios.rst:237
msgid "Modifies the progress of a Game Center achievement."
msgstr "修改游戏中心成就的进度。"

#: ../../docs/tutorials/platform/services_for_ios.rst:242
msgid "Takes a Dictionary as a parameter, with 3 fields:"
msgstr "将Dictionary作为参数，包含3个字段:"

#: ../../docs/tutorials/platform/services_for_ios.rst:244
msgid "``name`` (string) the achievement name"
msgstr "``name``(字符串)成就名称"

#: ../../docs/tutorials/platform/services_for_ios.rst:245
msgid ""
"``progress`` (float) the achievement progress from 0.0 to 100.0 (passed to "
"``GKAchievement::percentComplete``)"
msgstr ""
"``progress``(浮动)成就进度从0.0到100.0(传递给``GKAchievement :: "
"percentComplete``)"

#: ../../docs/tutorials/platform/services_for_ios.rst:247
msgid ""
"``show_completion_banner`` (bool) whether Game Center should display an "
"achievement banner at the top of the screen"
msgstr "``show_completion_banner``(bool)游戏中心是否应该在屏幕顶部显示成就横幅"

#: ../../docs/tutorials/platform/services_for_ios.rst:281
msgid "reset_achievements"
msgstr "reset_achievements"

#: ../../docs/tutorials/platform/services_for_ios.rst:283
msgid "Clears all Game Center achievements. The function takes no parameters."
msgstr "清除所有Game Center成就。 该函数不带参数。"

#: ../../docs/tutorials/platform/services_for_ios.rst:310
msgid "request_achievements"
msgstr "request_achievements"

#: ../../docs/tutorials/platform/services_for_ios.rst:312
msgid ""
"Request all the Game Center achievements the player has made progress on. "
"The function takes no parameters."
msgstr "请求游戏角色取得进步的所有游戏中心成就。 该函数不带参数。"

#: ../../docs/tutorials/platform/services_for_ios.rst:342
msgid "request_achievement_descriptions"
msgstr "request_achievement_descriptions"

#: ../../docs/tutorials/platform/services_for_ios.rst:344
msgid ""
"Request the descriptions of all existing Game Center achievements regardless "
"of progress. The function takes no parameters."
msgstr "无论进度如何，都要求描述所有现有的Game Center成就。 该函数不带参数。"

#: ../../docs/tutorials/platform/services_for_ios.rst:379
msgid "show_game_center"
msgstr "show_game_center"

#: ../../docs/tutorials/platform/services_for_ios.rst:381
msgid ""
"Displays the built in Game Center overlay showing leaderboards, "
"achievements, and challenges."
msgstr "显示内置的游戏中心叠加层，显示排行榜，成就和挑战。"

#: ../../docs/tutorials/platform/services_for_ios.rst:389
msgid ""
"``view`` (string) (optional) the name of the view to present. Accepts "
"\"default\", \"leaderboards\", \"achievements\", or \"challenges\". Defaults "
"to \"default\"."
msgstr ""
"``view``(string)(可选)要呈现的视图的名称。 接受“默认”，“排行榜”，“成就”或“挑"
"战”。 默认为“默认”。"

#: ../../docs/tutorials/platform/services_for_ios.rst:392
msgid ""
"``leaderboard_name`` (string) (optional) the name of the leaderboard to "
"present. Only used when \"view\" is \"leaderboards\" (or \"default\" is "
"configured to show leaderboards). If not specified, Game Center will display "
"the aggregate leaderboard."
msgstr ""
"``leaderboard_name``(字符串)(可选)要显示的排行榜的名称。 仅在“视图”为“排行"
"榜”(或“默认”配置为显示排行榜)时使用。 如果未指定，Game Center将显示聚合排行"
"榜。"

#: ../../docs/tutorials/platform/services_for_ios.rst:397
msgid "Examples:"
msgstr "示例:"

#: ../../docs/tutorials/platform/services_for_ios.rst:409
msgid "On close:"
msgstr "关闭时:"

#: ../../docs/tutorials/platform/services_for_ios.rst:419
msgid "Multi-platform games"
msgstr "多平台游戏"

#: ../../docs/tutorials/platform/services_for_ios.rst:421
msgid ""
"When working on a multi-platform game, you won't always have the \"GameCenter"
"\" singleton available (for example when running on PC or Android). Because "
"the gdscript compiler looks up the singletons at compile time, you can't "
"just query the singletons to see and use what you need inside a conditional "
"block, you need to also define them as valid identifiers (local variable or "
"class member). This is an example of how to work around this in a class:"
msgstr ""
"在开发多平台游戏时，您不会总是使用“GameCenter”单例(例如在PC或Android上运行"
"时)。 因为gdscript编译器在编译时查找单例，所以不能只查询单例以查看和使用条件"
"块中需要的内容，还需要将它们定义为有效标识符(局部变量或类成员)。 这是一个如何"
"在类中解决此问题的示例:"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:4
msgid "Customizing the Web export HTML page"
msgstr "自定义Web导出HTML页面"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:6
msgid ""
"Rather than the default HTML page that comes with the export templates, it "
"is also possible to use a custom HTML page. This allows drastic "
"customization of the final web presentation and behavior. The path to the "
"custom HTML page is specified in the export options as ``Html/Custom Html "
"Shell``."
msgstr ""
"除了导出模板附带的默认HTML页面之外，还可以使用自定义HTML页面。 这允许对最终的"
"Web表示和行为进行大量定制。 自定义HTML页面的路径在导出选项中指定为 ``Html/"
"Custom Html Shell`` 。"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:11
#, fuzzy
msgid ""
"The default HTML page is available in the Godot Engine repository at `/misc/"
"dist/html/full-size.html <https://github.com/godotengine/godot/blob/master/"
"misc/dist/html/full-size.html>`__. Some simple use-cases where customizing "
"the default page is useful include:"
msgstr ""
"Godot Engine存储库中提供了默认的HTML页面 `/mist/dist/html/default.html "
"<https://github.com/godotengine/godot/blob/master/misc/dist/html/default."
"html>`_ 。 一些简单的用例，其中自定义默认页面很有用包括:"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:15
msgid "Loading files from a different directory"
msgstr "从其他目录加载文件"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:16
msgid "Loading a ``.zip`` file instead of a ``.pck`` file as main pack"
msgstr "加载 ``.zip`` 文件而不是 ``.pck`` 文件作为主包"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:17
msgid "Loading engine files from a different directory than the main pack file"
msgstr "从主包文件以外的目录中加载引擎文件"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:18
msgid ""
"Adding a click-to-play button so games can be started in full-screen mode"
msgstr ""

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:19
msgid ""
"Loading some extra files before the engine starts, so they are available in "
"the file system later"
msgstr "在引擎启动之前加载一些额外的文件，以便稍后在文件系统中可用"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:21
msgid ""
"Passing custom \"command line\" arguments, e.g. ``-s`` to start a MainLoop "
"script"
msgstr "传递自定义“命令行”参数，例如 ``-s`` 启动MainLoop脚本"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:23
#, fuzzy
msgid ""
"Another sample HTML page is available at `/misc/dist/html/fixed-size.html "
"<https://github.com/godotengine/godot/blob/master/misc/dist/html/fixed-size."
"html>`__. This page uses a fixed size canvas with an output widget below. "
"However, the F12 browser console should be preferred as it can display "
"additional information, such as WebGL errors."
msgstr ""
"Godot Engine存储库中提供了默认的HTML页面 `/mist/dist/html/default.html "
"<https://github.com/godotengine/godot/blob/master/misc/dist/html/default."
"html>`_ 。 一些简单的用例，其中自定义默认页面很有用包括:"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:29
msgid "Placeholder substitution"
msgstr "占位符替换"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:31
msgid ""
"When exporting the game, several placeholders in the HTML page are replaced "
"with values depending on the export:"
msgstr "导出游戏时，HTML页面中的多个占位符将替换为值，具体取决于导出:"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:35
msgid "Placeholder"
msgstr "占位符"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:35
#, fuzzy
msgid "Substituted by"
msgstr "替代"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:37
msgid "``$GODOT_BASENAME``"
msgstr "``$GODOT_BASENAME``"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:37
msgid ""
"Basename of exported files without suffixes, e.g. ``game`` when exporting "
"``game.html``"
msgstr "没有后缀的导出文件的基本名称，例如 ``game`` 在导出 ``game.html`` 时"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:40
msgid "``$GODOT_DEBUG_ENABLED``"
msgstr "``$GODOT_DEBUG_ENABLED``"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:40
msgid "``true`` if debugging, ``false`` otherwise"
msgstr "如果调试就是 ``true`` ，否则是 ``false``"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:42
msgid "``$GODOT_HEAD_INCLUDE``"
msgstr "``$GODOT_HEAD_INCLUDE``"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:42
msgid ""
"Custom string to include just before the end of the HTML ``<head>`` element"
msgstr "自定义字符串，包含在HTML `` <head>`` 元素的结尾之前"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:46
msgid ""
"The HTML file must evaluate the JavaScript file ``$GODOT_BASENAME.js``. This "
"file defines a global ``Engine`` object used to start the engine, :ref:`see "
"below <doc_javascript_engine_object>` for details."
msgstr ""
"HTML文件必须评估JavaScript文件 ``$ GODOT_BASENAME.js`` 。 这个文件定义了一个"
"用于启动引擎的全局 ``Engine`` 对象，参见 :ref:`see below "
"<doc_javascript_engine_object>` 了解详细信息。"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:50
msgid ""
"The boot splash image is exported as ``$GODOT_BASENAME.png`` and can be used "
"e.g. in ``<img />`` elements."
msgstr ""
"引导启动图像被导出为 ``$ GODOT_BASENAME.png`` 并且可以用于例如 在 ``<img /"
">`` 元素中。"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:53
msgid ""
"``$GODOT_DEBUG_ENABLED`` can be useful to optionally display e.g. an output "
"console or other debug tools."
msgstr ""
"``$ GODOT_DEBUG_ENABLED`` 可用于可选地显示，例如 输出控制台或其他调试工具。"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:56
msgid ""
"``$GODOT_HEAD_INCLUDE`` is replaced with the string specified by the export "
"option ``Html/Head Include``."
msgstr ""
"``$GODOT_HEAD_INCLUDE`` 被导出选项 ``Html / Head Include`` 指定的字符串替换。"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:62
msgid "The ``Engine`` object"
msgstr "``Engine`` 对象"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:64
msgid ""
"The JavaScript global object ``Engine`` is defined by ``$GODOT_BASENAME.js`` "
"and serves as an interface to the engine start-up process."
msgstr ""
"JavaScript全局对象 ``Engine`` 由 ``$GODOT_BASENAME.js`` 定义，并作为引擎启动"
"过程的接口。"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:67
#, fuzzy
msgid ""
"The API is based on and requires basic understanding of `Promises <https://"
"developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises>`__."
msgstr ""
"遵循 `同源政策 <https://developer.mozilla.org/en-US/docs/Web/Security/Same-"
"origin_policy>`_"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:69
#, fuzzy
msgid "The object itself has only the following methods:"
msgstr "Mob场景将会使用如下节点:"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:73
#, fuzzy
msgid "Load the engine from the passed base path."
msgstr "从传递的基本路径加载引擎。"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:0
#, fuzzy
msgid "Arguments"
msgstr "调整"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:75
msgid "Base path of the engine to load."
msgstr ""

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:0
#, fuzzy
msgid "Returns"
msgstr "Return"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:76
#, fuzzy
msgid "Promise which resolves once the engine is loaded."
msgstr "返回一旦加载引擎就解析的承诺。"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:80
msgid "Unload the engine to free memory."
msgstr ""

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:82
#, fuzzy
msgid ""
"This is called automatically once the engine is started unless explicitly "
"disabled using :js:func:`engine.setUnloadAfterInit`."
msgstr ""
"卸载模块以释放内存。 除非明确禁用，否则在实例化模块后会自动调用此方法。"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:87
msgid "Check whether WebGL is available."
msgstr ""

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:89
msgid "The major WebGL version to check for. Defaults to 1 for *WebGL 1.0*."
msgstr ""

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:92
#, fuzzy
msgid ""
"``true`` if the given major version of WebGL is available, ``false`` "
"otherwise."
msgstr ""
"如果给定的主要版本的WebGL可用，则返回 ``true`` ，否则返回 ``false`` 。 对于"
"WebGL 1.0，默认为 ``1`` 。"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:98
msgid ""
"When loading the engine, the filename extension of the WebAssembly module is "
"assumed to be ``wasm``. This function allows usage of an alternate extension."
msgstr ""

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:108
msgid ""
"This is useful for outdated hosts that only accept uploads of files with "
"certain filename extensions."
msgstr ""

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:111
msgid "Filename extension without preceding dot."
msgstr ""

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:115
msgid ""
"Depending on the host, using an alternate filename extension can prevent "
"some start-up optimizations. This occurs when the file is delivered with a "
"MIME-type other than :mimetype:`application/wasm`."
msgstr ""

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:120
msgid "Starting an ``Engine`` instance"
msgstr "启动 ``Engine`` 实例"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:122
msgid ":js:class:`Engine` also acts a class:"
msgstr ""

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:126
msgid "An instance of the engine that can be started, usually a game."
msgstr ""

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:128
msgid "Instantiate the class using the ``new`` operator:"
msgstr ""

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:134
msgid ""
"This yields an :js:class:`Engine` instance, referred to as ``engine`` with a "
"lower-case ``e`` from here."
msgstr ""

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:137
#, fuzzy
msgid ""
"To start such an instance, the global ``Engine`` object must be loaded, then "
"the ``engine`` instance must be initialized and finally started."
msgstr ""
"这个 ``Engine`` 实例，在这里被称为 ``engine`` ，带有小写的 ``e`` ，是引擎的可"
"启动实例，通常是游戏。 要启动这样的实例，必须加载全局 ``Engine`` 对象，然后必"
"须初始化并启动 ``engine`` 实例。"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:142
msgid ""
"Initialize the instance. The instance can then be started with one of the "
"``start`` functions, usually :js:func:`engine.startGame`."
msgstr ""

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:145
msgid ""
"The base path to the engine, same as in :js:func:`Engine.load`. Must be "
"passed only if the engine hasn't been loaded yet."
msgstr ""

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:149
#, fuzzy
msgid "Promise that resolves once the engine is loaded and initialized."
msgstr "返回一旦加载引擎就解析的承诺。"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:153
#, fuzzy
msgid ""
"Load a file so it is available in the file system once the instance runs. "
"Must be called **before** starting the instance."
msgstr ""
"这会加载一个文件，以便在启动实例后在文件系统中可用。 必须在 **启动实例之前调"
"用** 。"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:156
#, fuzzy
msgid ""
"If type is string, the file will be loaded from that path.  If type is "
"``ArrayBuffer`` or a view on one, the buffer will used as the content of the "
"file."
msgstr ""
"如果 ``file`` 是一个字符串，那么该文件将从该URL加载。 如果 ``file`` 是一个 "
"``ArrayBuffer`` 或一个视图，缓冲区将用作文件的内容。"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:157
msgid "If type is string, the file will be loaded from that path."
msgstr ""

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:159
#, fuzzy
msgid ""
"If type is ``ArrayBuffer`` or a view on one, the buffer will used as the "
"content of the file."
msgstr ""
"如果 ``file`` 是一个字符串，那么该文件将从该URL加载。 如果 ``file`` 是一个 "
"``ArrayBuffer`` 或一个视图，缓冲区将用作文件的内容。"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:162
#, fuzzy
msgid ""
"Path by which the file will be available. Mandatory if ``file`` is not a "
"string. If not passed, the path is derived from the URL of the loaded file."
msgstr ""
"如果 ``path`` 是一个字符串，它指定文件可用的路径。 如果 ``file`` 不是字符串，"
"这是必需的。 否则，路径是从加载的文件的URL派生的。"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:167
#, fuzzy
msgid "Promise that resolves once the file is preloaded."
msgstr "返回一个预先加载文件后解析的promise。"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:171
#, fuzzy
msgid ""
"Starts the instance of the engine, using the passed strings as command line "
"arguments. This allows great control over how the engine is started, but "
"usually the other methods starting with ``engine.start`` are simpler and "
"should be used instead."
msgstr ""
"启动引擎实例，将传递的字符串作为参数传递给 ``main()`` 函数。 这样可以很好地控"
"制引擎的使用方式，但通常名称以 ``engine.start`` 开头的其他方法更易于使用。"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:176
msgid ""
"If the instance has not yet been initialized with :js:func:`engine.init`, it "
"will be."
msgstr ""

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:179
msgid "The engine must be loaded beforehand."
msgstr ""

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:181
msgid ""
"Requires that the engine has been loaded, and that a canvas can be found on "
"the page."
msgstr ""

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:184
#, fuzzy
msgid "Command line arguments."
msgstr "添加命令行目标(Command Line Target):"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:186
#, fuzzy
msgid "Promise that resolves once the engine started."
msgstr "返回引擎启动后解析的承诺。"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:190
msgid ""
"Initializes the engine if not yet initialized and starts the game with the "
"main pack loaded from the passed URL."
msgstr ""

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:193
msgid ""
"If the engine isn't loaded yet, the base path of the passed URL will be used "
"to load the engine."
msgstr "如果尚未加载引擎，则将使用传递的URL的基本路径来加载引擎。"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:196
msgid ""
"This function ignores overrides of filenames and their extensions to start "
"only the main pack passed as argument."
msgstr ""

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:199
msgid ""
"Path to the main pack to start. Also used as base path to load the engine if "
"not loaded already."
msgstr ""

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:203
#, fuzzy
msgid "Promise that resolves once the game started."
msgstr "返回游戏开始后解析的承诺。"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:206
msgid "Configuring start-up behaviour"
msgstr "配置启动行为"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:208
msgid ""
"Beside starting the engine, other methods of the engine instance allow "
"configuring the behavior:"
msgstr "除启动引擎外，引擎实例的其他方法还允许配置行为:"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:213
msgid ""
"Specify whether the Engine will be unloaded automatically after the instance "
"is initialized."
msgstr ""

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:216
#, fuzzy
msgid ""
"This frees browser memory by unloading files that are no longer needed once "
"the instance is initialized. However, if more instances of the engine will "
"be started, the Engine will have to be loaded again."
msgstr ""
"设置是否在初始化实例后自动卸载Engine。 这通过卸载初始化实例后不再需要的文件来"
"释放浏览器内存。 但是，如果将启动更多引擎实例，则必须再次加载引擎。"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:220
#: ../../docs/tutorials/platform/customizing_html5_shell.rst:239
msgid "Enabled by default."
msgstr ""

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:222
#, fuzzy
msgid ""
"``true`` if the engine shall be unloaded after initializing, ``false`` "
"otherwise."
msgstr "如果调试就是 ``true`` ，否则是 ``false``"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:228
msgid "Specify a canvas to use."
msgstr ""

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:230
#, fuzzy
msgid "By default, the first canvas element on the page is used for rendering."
msgstr ""
"默认情况下，页面上的第一个canvas元素用于呈现。 通过调用此方法，可以指定另一个"
"画布。"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:232
msgid "The canvas to use."
msgstr ""

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:236
#, fuzzy
msgid ""
"Specifies whether the canvas will be resized to the width and height "
"specified in the project settings on start."
msgstr ""
"设置是否将画布调整为启动时项目设置中指定的宽度和高度。 默认为 ``true`` 。"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:241
#, fuzzy
msgid "``true`` if the canvas shall be resized on start, ``false`` otherwise."
msgstr "如果调试就是 ``true`` ，否则是 ``false``"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:246
msgid ""
"By default, the engine will try to guess the locale to use from the "
"JavaScript environment. It is usually preferable to use a server-side user-"
"specified locale, or at least use the locale requested in the HTTP ``Accept-"
"Language`` header. This method allows specifying such a custom locale string."
msgstr ""
"默认情况下，引擎将尝试从JavaScript环境猜测要使用的语言环境。通常最好使用服务"
"器端用户指定的区域设置，或者至少使用HTTP ``Accept-Language`` header中请求的区"
"域设置。该方法允许指定这样的自定义区域设置字符串。"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:252
#, fuzzy
msgid "For example, with PHP:"
msgstr "例如:"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:258
#, fuzzy
msgid "Locale."
msgstr "区域"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:261
msgid "List of :ref:`locales <doc_locales>`."
msgstr ""

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:265
msgid "Specify the virtual filename of the executable."
msgstr ""

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:267
msgid ""
"A real executable file doesn't exist for the HTML5 platform. However, a "
"virtual filename is stored by the engine for compatibility with other "
"platforms."
msgstr ""

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:271
#, fuzzy
msgid ""
"By default, the base name of the loaded engine files is used. This method "
"allows specifying another name."
msgstr ""
"默认情况下，已加载的引擎文件的基本名称用于可执行文件名。 此方法允许指定其他名"
"称。"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:274
msgid ""
"This affects the output of :ref:`OS.get_executable_path() "
"<class_OS_method_get_executable_path>` and the automatically started main "
"pack, :file:`{ExecutableName}.pck`."
msgstr ""

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:277
msgid "Executable name."
msgstr ""

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:280
msgid "Customizing the presentation"
msgstr "自定义演示文稿"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:282
msgid "The following methods are used to implement the presentation:"
msgstr "以下方法用于实现演示:"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:286
msgid "Set the callback for displaying download progress."
msgstr ""

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:288
msgid ""
"Callback called once per frame with two number arguments: bytes loaded so "
"far, and total bytes to load."
msgstr ""

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:299
msgid "If the total is 0, it couldn't be calculated. Possible reasons include:"
msgstr "如果总数为0，则无法计算。 可能的原因包括:"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:302
msgid "Files are delivered with server-side chunked compression"
msgstr "文件随服务器端分块压缩一起提供"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:303
msgid "Files are delivered with server-side compression on Chromium"
msgstr "文件在Chromium上通过服务器端压缩提供"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:304
msgid ""
"Not all file downloads have started yet (usually on servers without multi-"
"threading)"
msgstr "并非所有文件下载都已开始(通常在没有多线程的服务器上)"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:308
msgid ""
"For ease of use, the callback is only called once per frame, so that usage "
"of ``requestAnimationFrame()`` is not necessary."
msgstr ""

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:313
msgid "Specify the standard output stream callback."
msgstr ""

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:315
#: ../../docs/tutorials/platform/customizing_html5_shell.rst:334
msgid "Callback function called with one argument, the string to print."
msgstr ""

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:325
#: ../../docs/tutorials/platform/customizing_html5_shell.rst:344
#, fuzzy
msgid ""
"This method should usually only be used in debug pages. The ``"
"$GODOT_DEBUG_ENABLED`` placeholder can be used to check for this."
msgstr ""
"这些方法通常只应在调试页面中使用。 可以使用 ``$GODOT_DEBUG_ENABLED`` 占位符来"
"检查这一点。"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:328
#, fuzzy
msgid "By default, ``console.log()`` is used."
msgstr "默认情况下，分别使用 ``console.log()`` 和 ``console.warn()`` 。"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:332
msgid "Specify the standard error stream callback."
msgstr ""

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:347
#, fuzzy
msgid "By default, ``console.warn()`` is used."
msgstr "默认情况下，分别使用 ``console.log()`` 和 ``console.warn()`` 。"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:350
msgid "Accessing the Emscripten ``Module``"
msgstr "访问Emscripten ``Module``"

#: ../../docs/tutorials/platform/customizing_html5_shell.rst:352
msgid ""
"If you know what you're doing, you can access the runtime environment "
"(Emscripten's ``Module``) as ``engine.rtenv``. Check the official Emscripten "
"documentation for information on how to use it: https://kripken.github.io/"
"emscripten-site/docs/api_reference/module.html"
msgstr ""
"如果您知道您在做什么，您可以访问运行时环境(Emscripten的 ``Module`` )作为 "
"``engine.rtenv`` 。 查看官方Emscripten文档以获取有关如何使用它的信息:https://"
"kripken.github.io/emscripten-site/docs/api_reference/module.html"

#: ../../docs/tutorials/platform/consoles.rst:4
msgid "Console support in Godot"
msgstr "Godot支持的游戏机"

#: ../../docs/tutorials/platform/consoles.rst:7
msgid "Official support"
msgstr "官方支持"

#: ../../docs/tutorials/platform/consoles.rst:9
msgid ""
"Godot currently does not officially support consoles (except the Xbox One "
"using UWP)."
msgstr "Godot目前不正式支持游戏机(除了使用UWP的Xbox One)。"

#: ../../docs/tutorials/platform/consoles.rst:12
msgid "The reasons for this are:"
msgstr "原因是:"

#: ../../docs/tutorials/platform/consoles.rst:14
msgid ""
"To develop for consoles, one must be licensed as a company. As an open "
"source project, Godot does not have such a legal figure."
msgstr ""
"要为游戏机开发游戏，必须获得公司许可。 作为一个开源项目，Godot没有这样的法律"
"人士。"

#: ../../docs/tutorials/platform/consoles.rst:16
msgid ""
"Console SDKs are secret and covered by non-disclosure agreements. Even if we "
"could get access to them, we could not publish the platform-specific code "
"under an open source license."
msgstr ""
"游戏机的SDK是保密的，并由保密协议保护。 即使我们可以访问它们，我们也无法在开"
"源许可下发布特定平台的代码。"

#: ../../docs/tutorials/platform/consoles.rst:19
msgid ""
"Consoles require specialized hardware to develop for, so regular individuals "
"can't create games for them anyway."
msgstr ""
"游戏机的游戏开发需要专门的硬件，因此普通人无论如何也无法为游戏机创建游戏。"

#: ../../docs/tutorials/platform/consoles.rst:22
msgid ""
"However, it is still possible to port your games to consoles thanks to "
"services provided by third-party companies."
msgstr "但是，基于第三方公司提供的服务，仍然可以将游戏移植到游戏机中。"

#: ../../docs/tutorials/platform/consoles.rst:26
msgid "Third-party support"
msgstr "第三方支持"

#: ../../docs/tutorials/platform/consoles.rst:28
msgid ""
"Console ports of Godot are offered by third-party companies (which have "
"ported Godot on their own). These companies also offer publishing of your "
"games to various consoles."
msgstr ""
"Godot的游戏机端口由第三方公司提供(它们自己移植了Godot)。 这些公司还提供各种游"
"戏机的游戏发布。"

#: ../../docs/tutorials/platform/consoles.rst:32
msgid "Following is the list of providers:"
msgstr "以下是提供者列表:"

#: ../../docs/tutorials/platform/consoles.rst:34
msgid ""
"`Lone Wolf Technology <http://www.lonewolftechnology.com/>`_ offers Switch, "
"PS4 and Xbox One porting and publishing of Godot games."
msgstr ""
"`Lone Wolf Technology <http://www.lonewolftechnology.com/>`_ 提供Switch，PS4"
"和Xbox One的Godot游戏移植和发布。"

#: ../../docs/tutorials/threads/thread_safe_apis.rst:4
msgid "Thread safe APIs"
msgstr "线程安全的API"

#: ../../docs/tutorials/threads/thread_safe_apis.rst:9
#, fuzzy
msgid ""
"Threads are used to balance processing power across CPUs and cores. Godot "
"supports multithreading, but not in the whole engine."
msgstr ""
"使用线程是一种平衡进程的常用方法, 它可将工作分散到各个CPU和核心中。 Godot支持"
"多线程，但不是在整个引擎中。"

#: ../../docs/tutorials/threads/thread_safe_apis.rst:12
#, fuzzy
msgid ""
"Below is a list of ways multithreading can be used in different areas of "
"Godot."
msgstr "下面是Godot的相关领域列表以及它们如何与线程一起使用的介绍。"

#: ../../docs/tutorials/threads/thread_safe_apis.rst:17
msgid ""
":ref:`Global Scope<class_@GlobalScope>` singletons are all thread safe. "
"Accessing servers from threads is supported (for VisualServer and Physics "
"servers, ensure threaded or thread safe operation is enabled in the project "
"settings!)."
msgstr ""
":ref:`Global Scope<class_@GlobalScope>` 单例都是线程安全的。 支持从线程访问服"
"务器(对于VisualServer和Physics服务器，确保在项目设置中启用了线程安全操作！)。"

#: ../../docs/tutorials/threads/thread_safe_apis.rst:19
msgid ""
"This makes them ideal for code that creates dozens of thousands of instances "
"in servers and controls them from threads. Of course, it requires a bit more "
"code, as this is used directly and not within the scene tree."
msgstr ""
"这使它们成为在服务器中创建数十万个实例并从线程控制它们的代码的理想选择。 当"
"然，还需要更多的代码, 因为这是直接使用的而不是嵌入场景树中使用 。"

#: ../../docs/tutorials/threads/thread_safe_apis.rst:24
msgid ""
"Interacting with the active scene tree is **NOT** thread safe. Make sure to "
"use mutexes when sending data between threads. If you want to call functions "
"from a thread, the *call_deferred* function may be used:"
msgstr ""
"与激活的场景树交互 **不是** 线程安全的。 确保在线程之间发送数据时使用互斥"
"锁。 如果要从线程调用函数，可以使用 *call_deferred* 函数:"

#: ../../docs/tutorials/threads/thread_safe_apis.rst:33
msgid ""
"However, creating scene chunks (nodes in tree arrangement) outside the "
"active tree is fine. This way, parts of a scene can be built or instantiated "
"in a thread, then added in the main thread:"
msgstr ""
"但是，可以在激活的场景树外创建场景块(以树形式排列的节点)。 这样，可以在线程中"
"构建或实例化部分场景，然后将其添加到主线程中:"

#: ../../docs/tutorials/threads/thread_safe_apis.rst:42
msgid ""
"Still, this is only really useful if you have **one** thread loading data. "
"Attempting to load or create scene chunks from multiple threads may work, "
"but you risk resources (which are only loaded once in Godot) tweaked by the "
"multiple threads, resulting in unexpected behaviors or crashes."
msgstr ""

#: ../../docs/tutorials/threads/thread_safe_apis.rst:47
msgid ""
"Only use more than one thread to generate scene data if you *really* know "
"what you are doing and you are sure that a single resource is not being used "
"or set in multiple ones. Otherwise, you are safer just using the servers API "
"(which is fully thread-safe) directly and not touching scene or resources."
msgstr ""

#: ../../docs/tutorials/threads/thread_safe_apis.rst:55
msgid "GDScript arrays, dictionaries"
msgstr "GDScript数组，字典"

#: ../../docs/tutorials/threads/thread_safe_apis.rst:57
msgid ""
"In GDScript, reading and writing elements from multiple threads is ok, but "
"anything that changes the container size (resizing, adding or removing "
"elements) requires locking a mutex."
msgstr ""
"在GDScript中，可以从多个线程读取和写入元素，但是任何改变容器大小(调整大小，添"
"加或删除元素)的操作都需要锁定互斥。"

#: ../../docs/tutorials/threads/thread_safe_apis.rst:62
msgid ""
"Modifying a unique resource from multiple threads is not supported, but "
"loading them on threads or handling a reference is perfectly supported. "
"Scenes, textures, meshes, etc. Can be loaded and manipulated on threads, "
"then added to the active scene in the main thread."
msgstr ""
"不支持从多个线程修改唯一资源，但完全支持在线程上加载它们或处理引用。 场景，纹"
"理，网格等可以在线程上加载和操作，然后添加到主线程中的活动场景中。"

#: ../../docs/tutorials/content/making_trees.rst:4
msgid "Making trees"
msgstr "制作树"

#: ../../docs/tutorials/content/making_trees.rst:6
msgid ""
"This is a short tutorial on how to make trees and other types of vegetation "
"from scratch."
msgstr "这是一个关于如何从头开始制作树和其他类型植被的小教程。"

#: ../../docs/tutorials/content/making_trees.rst:8
msgid ""
"The aim is to not focus on the modelling techniques (there are plenty of "
"tutorials about that), but how to make them look good in Godot."
msgstr ""
"我们的目标不是专注于建模技术(关于这方面有很多教程)，而是如何让它们在Godot中看"
"起来更好。"

#: ../../docs/tutorials/content/making_trees.rst:13
msgid "Start with a tree"
msgstr "从一棵树开始"

#: ../../docs/tutorials/content/making_trees.rst:15
msgid "I took this tree from SketchFab:"
msgstr "我从SketchFab上取了这棵树:"

#: ../../docs/tutorials/content/making_trees.rst:19
msgid "https://sketchfab.com/models/ea5e6ed7f9d6445ba69589d503e8cebf"
msgstr "https://sketchfab.com/models/ea5e6ed7f9d6445ba69589d503e8cebf"

#: ../../docs/tutorials/content/making_trees.rst:21
msgid "and opened it in Blender."
msgstr "然后用Blender打开。"

#: ../../docs/tutorials/content/making_trees.rst:24
msgid "Paint with vertex colors"
msgstr "用顶点颜色绘制"

#: ../../docs/tutorials/content/making_trees.rst:26
msgid ""
"The first thing you may want to do is to use the vertex colors to paint how "
"much the tree will sway when there is wind. Just use the vertex color "
"painting tool of your favorite 3D modelling program and paint something like "
"this:"
msgstr ""
"您可能要做的第一件事就是用顶点的颜色来描绘当有风的时候树会摇摆多少。只需使用"
"您最喜欢的三维建模程序的顶点着色工具，并绘制如下:"

#: ../../docs/tutorials/content/making_trees.rst:30
msgid ""
"This is a bit exaggerated, but the idea is that color indicates how much "
"sway affects every part of the tree. This scale here represents it better:"
msgstr ""
"这有点夸张，但这个想法是，颜色表明了多少摇摆影响树的每个部分。这个比例尺更能"
"说明问题:"

#: ../../docs/tutorials/content/making_trees.rst:35
msgid "Write a custom shader for the leaves"
msgstr "为叶子写一个自定义着色器"

#: ../../docs/tutorials/content/making_trees.rst:37
msgid "This is a simple example of a shader for leaves:"
msgstr "这是一个简单的树叶着色器的示例:"

#: ../../docs/tutorials/content/making_trees.rst:44
msgid ""
"This is a spatial shader. There is no front/back culling (so leaves can be "
"seen from both sides), and alpha prepass is used, so there are less depth "
"arctifacts that result from using transparency (and leaves cast shadow). "
"Finally, for the sway effect, world coordinates are recommended, so the tree "
"can be duplicated, moved, etc. and it will still work together with other "
"trees."
msgstr ""
"这是一个空间着色器。没有前/后剔除(因此可以从两侧看到叶节点)，并且使用了alpha "
"prepass，因此使用透明(和叶节点投射阴影)产生的深度弧值更少。最后，对于摇摆效"
"果，推荐world坐标，这样树就可以复制、移动等，并且仍然可以与其他树一起工作。"

#: ../../docs/tutorials/content/making_trees.rst:51
msgid ""
"Here, the texture is read, as well as a transmission color, which is used to "
"add some back-lighting to the leaves, simulating subsurface scattering."
msgstr ""
"在这里，纹理和透射颜色被读取，透射颜色被用来给叶子添加一些背光，模拟地下散"
"射。"

#: ../../docs/tutorials/content/making_trees.rst:67
msgid ""
"This is the code to create the sway of the leaves. It's basic (just uses a "
"sinewave multiplying by the time and axis position, but works well). Notice "
"that the strength is multiplied by the color. Every axis uses a different "
"small near 1.0 multiplication factor so axes don't appear in sync."
msgstr ""
"这是创建叶子摆动的代码。它是基本的(只是使用正弦波乘以时间和轴的位置，但工作得"
"很好)。注意，强度乘以颜色。每个轴使用不同的小的接近1.0的乘法系数，所以轴不同"
"步出现。"

#: ../../docs/tutorials/content/making_trees.rst:70
msgid "Finally all that is left is the fragment shader:"
msgstr "最后剩下的就是片段着色器:"

#: ../../docs/tutorials/content/making_trees.rst:83
msgid "And this is pretty much it."
msgstr "差不多就是这样。"

#: ../../docs/tutorials/content/making_trees.rst:85
msgid ""
"The trunk shader is similar, except it does not write to the alpha channel "
"(thus no alpha prepass is needed) and does not require transmission to work. "
"Both shaders can be improved by adding normal mapping, AO and other maps."
msgstr ""
"主干着色器是类似的，除了它不写到alpha通道(因此不需要alpha前置)和不需要传输工"
"作。这两个着色器都可以通过添加法线映射、AO和其他映射来改进。"

#: ../../docs/tutorials/content/making_trees.rst:88
msgid "Improving the shader"
msgstr "改进着色器"

#: ../../docs/tutorials/content/making_trees.rst:90
msgid ""
"There are many more resources on how to do this that you can read. Now that "
"you know the basics, a recommended read is the chapter from GPU Gems3 about "
"how Crysis does this (focus mostly on the sway code, as many other "
"techniques shown there are obsolete):"
msgstr ""
"还有更多的资源可以做到这一点，您可以阅读。现在您已经了解了基础知识，建议阅读"
"GPU Gems3中关于Crysis如何做到这一点的章节(主要关注摇摆代码，因为许多其他技术"
"都已经过时了):"

#: ../../docs/tutorials/content/making_trees.rst:93
msgid "https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch16.html"
msgstr "https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch16.html"

#: ../../docs/tutorials/misc/jitter_stutter.rst:4
msgid "Fixing jitter and stutter"
msgstr ""

#: ../../docs/tutorials/misc/jitter_stutter.rst:7
msgid "What are jitter and stutter?"
msgstr ""

#: ../../docs/tutorials/misc/jitter_stutter.rst:9
msgid ""
"*Jitter* and *stutter* are two different alterations to visible motion of "
"objects on screen that may affect a game, even when running at full speed. "
"These effects are mostly visible in games where the world moves at a "
"constant speed in a fixed direction, like runners or platformers."
msgstr ""

#: ../../docs/tutorials/misc/jitter_stutter.rst:14
#, fuzzy
msgid "Distinguishing between them"
msgstr "完成重生系统"

#: ../../docs/tutorials/misc/jitter_stutter.rst:16
msgid ""
"A game running at a normal framerate without exhibiting any effect will "
"appear smooth:"
msgstr ""

#: ../../docs/tutorials/misc/jitter_stutter.rst:20
msgid "A game exhibiting *jitter* will shake constantly in a very subtle way:"
msgstr ""

#: ../../docs/tutorials/misc/jitter_stutter.rst:24
msgid ""
"Finally, a game exhibiting *stutter* will appear smooth, but appear to "
"*stop* or *roll back a frame* every few seconds:"
msgstr ""

#: ../../docs/tutorials/misc/jitter_stutter.rst:30
msgid "Jitter"
msgstr ""

#: ../../docs/tutorials/misc/jitter_stutter.rst:32
msgid ""
"There can be many causes of jitter, the most typical one happens when the "
"game *physics frequency* (usually 60 Hz) runs at a different resolution than "
"the monitor refresh rate. Check whether your monitor refresh rate is "
"different from 60 Hz."
msgstr ""

#: ../../docs/tutorials/misc/jitter_stutter.rst:35
msgid ""
"This is generally not a problem, given that refresh rates higher than 60 Hz "
"are barely visible to the human eye, and starting with Godot 3.1, a frame "
"timer was introduced that tries to synchronize with refresh as best as "
"possible."
msgstr ""

#: ../../docs/tutorials/misc/jitter_stutter.rst:38
msgid ""
"Sometimes only some objects appear to jitter (character or background). This "
"happens when they are processed in different time sources (one is processed "
"in the physics step while another is processed in the idle step). Godot 3.1 "
"does some improvements to this, from allowing kinematic bodies to be "
"animated in the regular _process loop, to further fixes in the frame timer."
msgstr ""

#: ../../docs/tutorials/misc/jitter_stutter.rst:44
msgid "Stutter"
msgstr ""

#: ../../docs/tutorials/misc/jitter_stutter.rst:46
msgid ""
"Stutter may happen due to two different reasons. The first, and most obvious "
"one, is the game not being able to keep full framerate performance. Solving "
"this is game specific and will require optimization."
msgstr ""

#: ../../docs/tutorials/misc/jitter_stutter.rst:49
msgid ""
"The second is more complicated, because it is often not associated to the "
"engine or game but the underlying operating system. Here is some information "
"regarding stutter on different OSs."
msgstr ""

#: ../../docs/tutorials/misc/jitter_stutter.rst:55
msgid ""
"Windows is known to cause stutter in windowed games. This mostly depends on "
"the hardware installed, drivers version and processes running in parallel (e."
"g. having many browser tabs open may cause stutter in a running game). To "
"avoid this, starting with 3.1, Godot raises the game priority to \"Above "
"Normal\". This helps considerably but may not completely eliminate stutter."
msgstr ""

#: ../../docs/tutorials/misc/jitter_stutter.rst:60
msgid ""
"Eliminating this completely requires giving your game full privileges to "
"become \"time critical\", which is not advised. Some games may do it, but it "
"is advised to learn to live with this problem, as it is common for Windows "
"games and most users won't play games windowed (games that are played in a "
"window, e.g. puzzle games, will usaully not exhibit this problem anyway)."
msgstr ""

#: ../../docs/tutorials/misc/jitter_stutter.rst:64
msgid ""
"For fullscreen, Windows gives special priority to the game so stutter is no "
"longer visible and very rare. This is how most games are played."
msgstr ""

#: ../../docs/tutorials/misc/jitter_stutter.rst:68
msgid "Linux (X11)"
msgstr ""

#: ../../docs/tutorials/misc/jitter_stutter.rst:70
msgid ""
"Stutter may be visible on Desktop Linux, but this is usually associated with "
"different video drivers and compositors. Nouveau drivers often exhibit this, "
"while AMD or NVidia proprietary don't. Some compositors may also trigger "
"this problem (e.g. KWin), so it is advised to try using a different one to "
"rule it out as the cause."
msgstr ""

#: ../../docs/tutorials/misc/jitter_stutter.rst:74
msgid ""
"There is no workaround for driver or compositor stuttering other than "
"reporting it as an issue to the driver or compositor developers."
msgstr ""

#: ../../docs/tutorials/misc/jitter_stutter.rst:80
msgid ""
"Generally, macOS is stutter-free, although recently some bugs were reported "
"when running on fullscreen (this is a macOS bug). If you have a machine "
"exhibiting this behavior, please let us know."
msgstr ""

#: ../../docs/tutorials/misc/jitter_stutter.rst:86
msgid ""
"Generally, Android is stutter and jitter-free because the running activity "
"gets all the priority. That said, there may be problematic devices (older "
"Kindle Fire is known to be one). If you see this problem on Android, please "
"let us know."
msgstr ""

#: ../../docs/tutorials/misc/jitter_stutter.rst:92
msgid ""
"iOS devices are generally stutter-free, but older devices running newer "
"versions of the operating system may exhibit problems. This is generally "
"unavoidable."
msgstr ""

#: ../../docs/tutorials/misc/jitter_stutter.rst:96
msgid "Reporting stutter or jitter problems"
msgstr ""

#: ../../docs/tutorials/misc/jitter_stutter.rst:98
msgid ""
"If you are reporting a stutter or jitter problem (opening an issue) not "
"caused by any of the above reasons, please specify very clearly all the "
"information possible about device, operating system, driver versions, etc. "
"This may help to better troubleshoot it."
msgstr ""

#: ../../docs/tutorials/misc/jitter_stutter.rst:101
msgid ""
"Also make sure to use the correct term (jitter or stutter) based on the "
"exhibited behavior. This will help understand your issue much faster. "
"Provide a project that can be used to reproduce the issue, and if possible a "
"screen capture demonstrating the bug."
msgstr ""

#: ../../docs/tutorials/misc/handling_quit_requests.rst:4
msgid "Handling quit requests"
msgstr "处理退出请求"

#: ../../docs/tutorials/misc/handling_quit_requests.rst:7
msgid "Quitting"
msgstr "退出"

#: ../../docs/tutorials/misc/handling_quit_requests.rst:9
msgid ""
"Most platforms have the option to request the application to quit. On "
"desktops, this is usually done with the \"x\" icon on the window titlebar. "
"On Android, the back button is used to quit when on the main screen (and to "
"go back otherwise)."
msgstr ""
"大多数平台都可以选择请求退出应用程序。 在桌面系统中，通常使用窗口标题栏上"
"的“x”图标来完成。 在Android上，当在主屏幕上时，后退按钮用于退出(否则返回)。"

#: ../../docs/tutorials/misc/handling_quit_requests.rst:15
msgid "Handling the notification"
msgstr "处理通知"

#: ../../docs/tutorials/misc/handling_quit_requests.rst:17
msgid ""
"The :ref:`MainLoop <class_MainLoop>` has a special notification that is sent "
"to all nodes when quit is requested: MainLoop.NOTIFICATION_WM_QUIT."
msgstr ""
":ref:`MainLoop <class_MainLoop>` 有一个特殊通知，在请求退出时将发送到所有节"
"点 : MainLoop.NOTIFICATION_WM_QUIT。"

#: ../../docs/tutorials/misc/handling_quit_requests.rst:21
msgid "Handling it is done as follows (on any node):"
msgstr "在任何节点上，可以像下面这样处理这个通知:"

#: ../../docs/tutorials/misc/handling_quit_requests.rst:38
msgid ""
"When developing mobile apps, quitting is not desired unless the user is on "
"the main screen, so the behavior can be changed."
msgstr ""
"在开发移动应用程序时，除非用户在主屏幕上，否则不需要退出，因此处理方式有变"
"化。"

#: ../../docs/tutorials/misc/handling_quit_requests.rst:41
msgid ""
"It is important to note that by default, Godot apps have the built-in "
"behavior to quit when quit is requested, this can be changed:"
msgstr ""
"值得注意的是，默认情况下，在请求退出时，Godot应用程序具有退出的内置行为，可以"
"更改为:"

#: ../../docs/tutorials/misc/pausing_games.rst:4
msgid "Pausing games"
msgstr "暂停游戏"

#: ../../docs/tutorials/misc/pausing_games.rst:7
msgid "Pause?"
msgstr "暂停？"

#: ../../docs/tutorials/misc/pausing_games.rst:9
msgid ""
"In most games it is desirable to, at some point, interrupt the game to do "
"something else, such as taking a break or changing options. However this is "
"not as simple as it seems. The game might be stopped, but it might be "
"desirable that some menus and animations continue working."
msgstr ""
"在大多数游戏中，希望在某些时候中断游戏以做其他事情，例如休息或改变选项。 然"
"而，这并不像看起来那么简单。 游戏可能会停止，但可能需要一些菜单和动画继续工"
"作。"

#: ../../docs/tutorials/misc/pausing_games.rst:15
msgid ""
"Implementing a fine-grained control for what can be paused (and what can "
"not) is a lot of work, so a simple framework for pausing is provided in "
"Godot."
msgstr ""
"对可暂停(以及不可暂停)的内容实现细节控制需要大量工作，因此Godot提供了一个简单"
"的暂停框架。"

#: ../../docs/tutorials/misc/pausing_games.rst:20
msgid "How pausing works"
msgstr "如何暂停工作"

#: ../../docs/tutorials/misc/pausing_games.rst:22
#, fuzzy
msgid ""
"To set pause mode, the pause state must be set. This is done by assigning "
"``true`` to the :ref:`SceneTree.paused <class_SceneTree_property_paused>` "
"property:"
msgstr ""
"要设置暂停模式，必须设置暂停状态。 这是通过为 :ref:`SceneTree.paused "
"<class_SceneTree_property_paused>` 成员变量赋予“true”值来完成的:"

#: ../../docs/tutorials/misc/pausing_games.rst:34
msgid "Doing so will have the following behavior:"
msgstr "这样做会产生以下行为:"

#: ../../docs/tutorials/misc/pausing_games.rst:36
msgid "2D and 3D physics will be stopped."
msgstr "2D和3D物理将被停止。"

#: ../../docs/tutorials/misc/pausing_games.rst:37
#, fuzzy
msgid ""
"``_process`` and ``_physics_process`` will not be called anymore in nodes."
msgstr "将不再在节点中调用_process和_physics_process。"

#: ../../docs/tutorials/misc/pausing_games.rst:38
#, fuzzy
msgid "``_input`` and ``_input_event`` will not be called anymore either."
msgstr "_input和_input_event也不再被调用。"

#: ../../docs/tutorials/misc/pausing_games.rst:40
msgid ""
"This effectively stops the whole game. Calling this function from a script, "
"by default, will result in an unrecoverable state (nothing will work "
"anymore!)."
msgstr ""
"这有效地阻止了整个游戏。 默认情况下，从脚本调用此函数将导致不可恢复的状态(游"
"戏永久暂停！)。"

#: ../../docs/tutorials/misc/pausing_games.rst:45
msgid "White-listing nodes"
msgstr "白名单节点"

#: ../../docs/tutorials/misc/pausing_games.rst:47
msgid ""
"Before enabling pause, make sure that nodes that must keep working during "
"pause are white-listed. This is done by editing the \"Pause Mode\" property "
"in a node:"
msgstr ""
"在启用暂停之前，请确保在暂停期间必须继续工作的节点已列入白名单。 这是通过编辑"
"节点中的“暂停模式”属性来完成的:"

#: ../../docs/tutorials/misc/pausing_games.rst:53
msgid ""
"By default all nodes have this property in the \"Inherit\" state. This "
"means, that they will only process (or not) depending on what this same "
"property is set on the parent node. If the parent is set to \"Inherit\" , "
"then the grandparent will be checked and so on. Ultimately, if a state can't "
"be found in any of the grandparents, the pause state in SceneTree is used. "
"This means that, by default, when the game is paused every node will be "
"paused."
msgstr ""
"默认情况下，所有节点的此属性都是“继承”状态。 这意味着，它们只会处理(或不处"
"理)，具体取决于父节点上设置的相同属性。 如果父项设置为“继承”，则将检查祖父"
"项，依此类推。 最终，如果在任何祖父中找不到状态，则使用SceneTree中的暂停状"
"态。 这意味着，默认情况下，当游戏暂停时，每个节点都将暂停。"

#: ../../docs/tutorials/misc/pausing_games.rst:61
msgid "So the three possible states for a node are:"
msgstr "节点的三种可能状态有:"

#: ../../docs/tutorials/misc/pausing_games.rst:63
msgid ""
"**Inherit**: Process depending on the state of the parent, grandparent, etc. "
"The first parent that has a non-Inherit state."
msgstr ""
"**继承** : 进程取决于父，祖父节点等的状态。具有非继承状态的第一个父节点。"

#: ../../docs/tutorials/misc/pausing_games.rst:65
msgid ""
"**Stop**: Stop the node no matter what (and children in Inherit mode). When "
"paused this node will not process."
msgstr ""
"**停止** : 无论什么情况下，停止节点(以及继承模式下的子节点)。 当暂停时，此节"
"点将不会被放入进程。"

#: ../../docs/tutorials/misc/pausing_games.rst:67
msgid ""
"**Process**: Process the node no matter what (and children in Inherit mode). "
"Paused or not this node will process."
msgstr ""
"**进程** : 无论什么情况下, 处理节点(以及继承模式下的子节点)。 无论暂停或不暂"
"停, 此节点仍会在进程中。"

#: ../../docs/tutorials/misc/pausing_games.rst:73
msgid ""
"An example of this is creating a popup or panel with controls inside, and "
"set its pause mode to \"Process\" then hide it:"
msgstr ""
"一个示例是创建一个带有控件的弹出窗口或面板，并将其暂停模式设置为“进程”然后隐"
"藏它:"

#: ../../docs/tutorials/misc/pausing_games.rst:78
msgid ""
"Just by setting the root of the pause popup to \"Process\", all children and "
"grandchildren will inherit that state. This way, this branch of the scene "
"tree will continue working when paused."
msgstr ""
"只需设置暂停弹出窗口的根节点项为“进程”，所有子孙都将继承该状态。 这样，场景树"
"的这个分支将在暂停时继续工作。"

#: ../../docs/tutorials/misc/pausing_games.rst:82
msgid ""
"Finally, make it so when a pause button is pressed (any button will do), "
"enable the pause and show the pause screen."
msgstr "最后，当按下暂停按钮(任何按钮都可以)时，启用暂停并显示暂停屏幕。"

#: ../../docs/tutorials/misc/pausing_games.rst:100
msgid "To remove the pause, do the opposite when the pause screen is closed:"
msgstr "要删除暂停，请在暂停屏幕关闭时执行相反操作:"

#: ../../docs/tutorials/misc/pausing_games.rst:118
msgid "And that should be all!"
msgstr "就是这样，喵！"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:4
msgid "Binary serialization API"
msgstr "二进制序列化API"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:9
msgid ""
"Godot has a simple serialization API based on Variant. It's used for "
"converting data types to an array of bytes efficiently. This API is used in "
"the functions ``get_var`` and ``store_var`` of :ref:`class_File` as well as "
"the packet APIs for :ref:`class_PacketPeer`. This format is not used for "
"binary scenes and resources."
msgstr ""
"Godot有一个基于变量的简单序列化API。 它被用于高效地将数据类型转换为字节数"
"组。 这个API用在 :ref:`class_File` 的函数 ``get_var`` 和 ``store_var`` 中 以"
"及 :ref:`class_PacketPeer` 的包API中。 此格式不用于二进制场景和资源。"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:16
msgid "Packet specification"
msgstr "包规范"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:18
msgid ""
"The packet is designed to be always padded to 4 bytes. All values are little "
"endian encoded. All packets have a 4 byte header representing an integer, "
"specifying the type of data:"
msgstr ""
"数据包被设计成4个字节的填充。 所有值都是小端编码。 所有数据包都有一个4字节的"
"头，表示成一个指定数据类型的整数:"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:23
msgid "Value"
msgstr "值"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:25
msgid "0"
msgstr "0"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:27
#: ../../docs/tutorials/misc/binary_serialization_api.rst:387
msgid "1"
msgstr "1"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:29
msgid "integer"
msgstr "integer"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:35
msgid "vector2"
msgstr "vector2"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:37
msgid "rect2"
msgstr "rect2"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:39
msgid "vector3"
msgstr "vector3"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:41
msgid "transform2d"
msgstr "transform2d"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:43
msgid "plane"
msgstr "plane"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:45
msgid "quat"
msgstr "quat"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:47
msgid "aabb"
msgstr "aabb"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:49
#: ../../docs/tutorials/misc/binary_serialization_api.rst:149
#: ../../docs/tutorials/misc/binary_serialization_api.rst:164
#: ../../docs/tutorials/misc/binary_serialization_api.rst:177
#: ../../docs/tutorials/misc/binary_serialization_api.rst:196
#: ../../docs/tutorials/misc/binary_serialization_api.rst:211
#: ../../docs/tutorials/misc/binary_serialization_api.rst:226
#: ../../docs/tutorials/misc/binary_serialization_api.rst:245
#: ../../docs/tutorials/misc/binary_serialization_api.rst:270
#: ../../docs/tutorials/misc/binary_serialization_api.rst:301
msgid "12"
msgstr "12"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:49
msgid "basis"
msgstr "basis"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:51
msgid "13"
msgstr "13"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:51
msgid "transform"
msgstr "transform"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:53
msgid "14"
msgstr "14"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:53
msgid "color"
msgstr "color"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:55
msgid "15"
msgstr "15"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:55
msgid "node path"
msgstr "node path"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:57
#: ../../docs/tutorials/misc/binary_serialization_api.rst:151
#: ../../docs/tutorials/misc/binary_serialization_api.rst:179
#: ../../docs/tutorials/misc/binary_serialization_api.rst:198
#: ../../docs/tutorials/misc/binary_serialization_api.rst:213
#: ../../docs/tutorials/misc/binary_serialization_api.rst:228
#: ../../docs/tutorials/misc/binary_serialization_api.rst:247
#: ../../docs/tutorials/misc/binary_serialization_api.rst:272
#: ../../docs/tutorials/misc/binary_serialization_api.rst:303
msgid "16"
msgstr "16"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:57
msgid "rid"
msgstr "rid"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:59
msgid "17"
msgstr "17"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:59
msgid "object"
msgstr "object"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:61
msgid "18"
msgstr "18"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:61
msgid "dictionary"
msgstr "dictionary"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:63
msgid "19"
msgstr "19"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:63
msgid "array"
msgstr "array"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:65
#: ../../docs/tutorials/misc/binary_serialization_api.rst:181
#: ../../docs/tutorials/misc/binary_serialization_api.rst:230
#: ../../docs/tutorials/misc/binary_serialization_api.rst:249
#: ../../docs/tutorials/misc/binary_serialization_api.rst:274
msgid "20"
msgstr "20"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:65
msgid "raw array"
msgstr "raw array"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:67
msgid "21"
msgstr "21"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:67
msgid "int array"
msgstr "int array"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:69
msgid "22"
msgstr "22"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:69
msgid "real array"
msgstr "real array"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:71
msgid "23"
msgstr "23"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:71
msgid "string array"
msgstr "string array"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:73
#: ../../docs/tutorials/misc/binary_serialization_api.rst:183
#: ../../docs/tutorials/misc/binary_serialization_api.rst:232
#: ../../docs/tutorials/misc/binary_serialization_api.rst:251
#: ../../docs/tutorials/misc/binary_serialization_api.rst:276
msgid "24"
msgstr "24"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:73
msgid "vector2 array"
msgstr "vector2 array"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:75
msgid "25"
msgstr "25"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:75
msgid "vector3 array"
msgstr "vector3 array"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:77
msgid "26"
msgstr "26"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:77
msgid "color array"
msgstr "color array"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:79
msgid "27"
msgstr "27"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:79
msgid "max"
msgstr "max"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:82
msgid ""
"Following this is the actual packet contents, which varies for each type of "
"packet:"
msgstr "以下是实际的数据包内容，每种类型的数据包都有所不同:"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:86
msgid "0: null"
msgstr "0: null"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:89
msgid "1: :ref:`bool<class_bool>`"
msgstr "1: :ref:`bool<class_bool>`"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:92
#: ../../docs/tutorials/misc/binary_serialization_api.rst:101
#: ../../docs/tutorials/misc/binary_serialization_api.rst:110
#: ../../docs/tutorials/misc/binary_serialization_api.rst:119
#: ../../docs/tutorials/misc/binary_serialization_api.rst:132
#: ../../docs/tutorials/misc/binary_serialization_api.rst:143
#: ../../docs/tutorials/misc/binary_serialization_api.rst:158
#: ../../docs/tutorials/misc/binary_serialization_api.rst:171
#: ../../docs/tutorials/misc/binary_serialization_api.rst:190
#: ../../docs/tutorials/misc/binary_serialization_api.rst:205
#: ../../docs/tutorials/misc/binary_serialization_api.rst:220
#: ../../docs/tutorials/misc/binary_serialization_api.rst:239
#: ../../docs/tutorials/misc/binary_serialization_api.rst:264
#: ../../docs/tutorials/misc/binary_serialization_api.rst:295
#: ../../docs/tutorials/misc/binary_serialization_api.rst:310
#: ../../docs/tutorials/misc/binary_serialization_api.rst:319
#: ../../docs/tutorials/misc/binary_serialization_api.rst:330
#: ../../docs/tutorials/misc/binary_serialization_api.rst:340
#: ../../docs/tutorials/misc/binary_serialization_api.rst:359
#: ../../docs/tutorials/misc/binary_serialization_api.rst:371
#: ../../docs/tutorials/misc/binary_serialization_api.rst:383
#: ../../docs/tutorials/misc/binary_serialization_api.rst:396
#: ../../docs/tutorials/misc/binary_serialization_api.rst:407
#: ../../docs/tutorials/misc/binary_serialization_api.rst:418
#: ../../docs/tutorials/misc/binary_serialization_api.rst:426
#: ../../docs/tutorials/misc/binary_serialization_api.rst:439
#: ../../docs/tutorials/misc/binary_serialization_api.rst:452
#: ../../docs/tutorials/misc/binary_serialization_api.rst:467
msgid "Offset"
msgstr "偏移量"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:92
#: ../../docs/tutorials/misc/binary_serialization_api.rst:101
#: ../../docs/tutorials/misc/binary_serialization_api.rst:110
#: ../../docs/tutorials/misc/binary_serialization_api.rst:119
#: ../../docs/tutorials/misc/binary_serialization_api.rst:132
#: ../../docs/tutorials/misc/binary_serialization_api.rst:143
#: ../../docs/tutorials/misc/binary_serialization_api.rst:158
#: ../../docs/tutorials/misc/binary_serialization_api.rst:171
#: ../../docs/tutorials/misc/binary_serialization_api.rst:190
#: ../../docs/tutorials/misc/binary_serialization_api.rst:205
#: ../../docs/tutorials/misc/binary_serialization_api.rst:220
#: ../../docs/tutorials/misc/binary_serialization_api.rst:239
#: ../../docs/tutorials/misc/binary_serialization_api.rst:264
#: ../../docs/tutorials/misc/binary_serialization_api.rst:295
#: ../../docs/tutorials/misc/binary_serialization_api.rst:310
#: ../../docs/tutorials/misc/binary_serialization_api.rst:319
#: ../../docs/tutorials/misc/binary_serialization_api.rst:330
#: ../../docs/tutorials/misc/binary_serialization_api.rst:340
#: ../../docs/tutorials/misc/binary_serialization_api.rst:359
#: ../../docs/tutorials/misc/binary_serialization_api.rst:371
#: ../../docs/tutorials/misc/binary_serialization_api.rst:383
#: ../../docs/tutorials/misc/binary_serialization_api.rst:396
#: ../../docs/tutorials/misc/binary_serialization_api.rst:407
#: ../../docs/tutorials/misc/binary_serialization_api.rst:418
#: ../../docs/tutorials/misc/binary_serialization_api.rst:426
#: ../../docs/tutorials/misc/binary_serialization_api.rst:439
#: ../../docs/tutorials/misc/binary_serialization_api.rst:452
#: ../../docs/tutorials/misc/binary_serialization_api.rst:467
msgid "Len"
msgstr "长度"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:94
msgid "0 for False, 1 for True"
msgstr "0 代表 False, 1 代表 True"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:98
msgid "2: :ref:`int<class_int>`"
msgstr "2: :ref:`int<class_int>`"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:103
msgid "Signed, 32-Bit Integer"
msgstr "有符号，32位整数"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:107
msgid "3: :ref:`float<class_float>`/real"
msgstr "3: :ref:`float<class_float>`/real"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:112
#: ../../docs/tutorials/misc/binary_serialization_api.rst:134
#: ../../docs/tutorials/misc/binary_serialization_api.rst:136
#: ../../docs/tutorials/misc/binary_serialization_api.rst:145
#: ../../docs/tutorials/misc/binary_serialization_api.rst:147
#: ../../docs/tutorials/misc/binary_serialization_api.rst:149
#: ../../docs/tutorials/misc/binary_serialization_api.rst:151
#: ../../docs/tutorials/misc/binary_serialization_api.rst:160
#: ../../docs/tutorials/misc/binary_serialization_api.rst:162
#: ../../docs/tutorials/misc/binary_serialization_api.rst:164
#: ../../docs/tutorials/misc/binary_serialization_api.rst:173
#: ../../docs/tutorials/misc/binary_serialization_api.rst:175
#: ../../docs/tutorials/misc/binary_serialization_api.rst:177
#: ../../docs/tutorials/misc/binary_serialization_api.rst:179
#: ../../docs/tutorials/misc/binary_serialization_api.rst:181
#: ../../docs/tutorials/misc/binary_serialization_api.rst:183
#: ../../docs/tutorials/misc/binary_serialization_api.rst:192
#: ../../docs/tutorials/misc/binary_serialization_api.rst:194
#: ../../docs/tutorials/misc/binary_serialization_api.rst:196
#: ../../docs/tutorials/misc/binary_serialization_api.rst:198
#: ../../docs/tutorials/misc/binary_serialization_api.rst:207
#: ../../docs/tutorials/misc/binary_serialization_api.rst:209
#: ../../docs/tutorials/misc/binary_serialization_api.rst:211
#: ../../docs/tutorials/misc/binary_serialization_api.rst:213
#: ../../docs/tutorials/misc/binary_serialization_api.rst:222
#: ../../docs/tutorials/misc/binary_serialization_api.rst:224
#: ../../docs/tutorials/misc/binary_serialization_api.rst:226
#: ../../docs/tutorials/misc/binary_serialization_api.rst:228
#: ../../docs/tutorials/misc/binary_serialization_api.rst:230
#: ../../docs/tutorials/misc/binary_serialization_api.rst:232
#: ../../docs/tutorials/misc/binary_serialization_api.rst:241
#: ../../docs/tutorials/misc/binary_serialization_api.rst:243
#: ../../docs/tutorials/misc/binary_serialization_api.rst:245
#: ../../docs/tutorials/misc/binary_serialization_api.rst:247
#: ../../docs/tutorials/misc/binary_serialization_api.rst:249
#: ../../docs/tutorials/misc/binary_serialization_api.rst:251
#: ../../docs/tutorials/misc/binary_serialization_api.rst:253
#: ../../docs/tutorials/misc/binary_serialization_api.rst:255
#: ../../docs/tutorials/misc/binary_serialization_api.rst:257
#: ../../docs/tutorials/misc/binary_serialization_api.rst:266
#: ../../docs/tutorials/misc/binary_serialization_api.rst:268
#: ../../docs/tutorials/misc/binary_serialization_api.rst:270
#: ../../docs/tutorials/misc/binary_serialization_api.rst:272
#: ../../docs/tutorials/misc/binary_serialization_api.rst:274
#: ../../docs/tutorials/misc/binary_serialization_api.rst:276
#: ../../docs/tutorials/misc/binary_serialization_api.rst:278
#: ../../docs/tutorials/misc/binary_serialization_api.rst:280
#: ../../docs/tutorials/misc/binary_serialization_api.rst:282
#: ../../docs/tutorials/misc/binary_serialization_api.rst:284
#: ../../docs/tutorials/misc/binary_serialization_api.rst:286
#: ../../docs/tutorials/misc/binary_serialization_api.rst:288
#: ../../docs/tutorials/misc/binary_serialization_api.rst:297
#: ../../docs/tutorials/misc/binary_serialization_api.rst:299
#: ../../docs/tutorials/misc/binary_serialization_api.rst:301
#: ../../docs/tutorials/misc/binary_serialization_api.rst:303
#: ../../docs/tutorials/misc/binary_serialization_api.rst:443
#: ../../docs/tutorials/misc/binary_serialization_api.rst:445
#: ../../docs/tutorials/misc/binary_serialization_api.rst:456
#: ../../docs/tutorials/misc/binary_serialization_api.rst:458
#: ../../docs/tutorials/misc/binary_serialization_api.rst:460
#: ../../docs/tutorials/misc/binary_serialization_api.rst:471
#: ../../docs/tutorials/misc/binary_serialization_api.rst:473
#: ../../docs/tutorials/misc/binary_serialization_api.rst:475
#: ../../docs/tutorials/misc/binary_serialization_api.rst:477
msgid "Float"
msgstr "Float"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:112
msgid "IEE 754 32-Bits Float"
msgstr "IEE 754格式的32位浮点数"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:116
msgid "4: :ref:`String<class_string>`"
msgstr "4: :ref:`String<class_string>`"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:121
msgid "String Length (in Bytes)"
msgstr "字符串长度 (字节)"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:123
#: ../../docs/tutorials/misc/binary_serialization_api.rst:321
#: ../../docs/tutorials/misc/binary_serialization_api.rst:344
#: ../../docs/tutorials/misc/binary_serialization_api.rst:430
msgid "X"
msgstr "X"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:123
#: ../../docs/tutorials/misc/binary_serialization_api.rst:321
#: ../../docs/tutorials/misc/binary_serialization_api.rst:344
#: ../../docs/tutorials/misc/binary_serialization_api.rst:430
msgid "Bytes"
msgstr "Bytes"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:123
#: ../../docs/tutorials/misc/binary_serialization_api.rst:321
#: ../../docs/tutorials/misc/binary_serialization_api.rst:344
#: ../../docs/tutorials/misc/binary_serialization_api.rst:430
msgid "UTF-8 Encoded String"
msgstr "UTF-8编码字符串"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:126
msgid "This field is padded to 4 bytes."
msgstr "该字段会被填充成4个字节。"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:129
msgid "5: :ref:`Vector2<class_vector2>`"
msgstr "5: :ref:`Vector2<class_vector2>`"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:134
#: ../../docs/tutorials/misc/binary_serialization_api.rst:145
#: ../../docs/tutorials/misc/binary_serialization_api.rst:160
#: ../../docs/tutorials/misc/binary_serialization_api.rst:222
#: ../../docs/tutorials/misc/binary_serialization_api.rst:443
#: ../../docs/tutorials/misc/binary_serialization_api.rst:456
msgid "X Coordinate"
msgstr "X 坐标"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:136
#: ../../docs/tutorials/misc/binary_serialization_api.rst:147
#: ../../docs/tutorials/misc/binary_serialization_api.rst:162
#: ../../docs/tutorials/misc/binary_serialization_api.rst:224
#: ../../docs/tutorials/misc/binary_serialization_api.rst:445
#: ../../docs/tutorials/misc/binary_serialization_api.rst:458
msgid "Y Coordinate"
msgstr "Y 坐标"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:140
msgid "6: :ref:`Rect2<class_rect2>`"
msgstr "6: :ref:`Rect2<class_rect2>`"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:149
#: ../../docs/tutorials/misc/binary_serialization_api.rst:228
msgid "X Size"
msgstr "X大小"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:151
#: ../../docs/tutorials/misc/binary_serialization_api.rst:230
msgid "Y Size"
msgstr "Y大小"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:155
msgid "7: :ref:`Vector3<class_vector3>`"
msgstr "7: :ref:`Vector3<class_vector3>`"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:164
#: ../../docs/tutorials/misc/binary_serialization_api.rst:226
#: ../../docs/tutorials/misc/binary_serialization_api.rst:460
msgid "Z Coordinate"
msgstr "Z 坐标"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:168
msgid "8: :ref:`Transform2D<class_transform2d>`"
msgstr "8: :ref:`Transform2D<class_transform2d>`"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:173
#: ../../docs/tutorials/misc/binary_serialization_api.rst:241
#: ../../docs/tutorials/misc/binary_serialization_api.rst:266
msgid "[0][0]"
msgstr "[0][0]"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:175
#: ../../docs/tutorials/misc/binary_serialization_api.rst:243
#: ../../docs/tutorials/misc/binary_serialization_api.rst:268
msgid "[0][1]"
msgstr "[0][1]"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:177
#: ../../docs/tutorials/misc/binary_serialization_api.rst:247
#: ../../docs/tutorials/misc/binary_serialization_api.rst:272
msgid "[1][0]"
msgstr "[1][0]"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:179
#: ../../docs/tutorials/misc/binary_serialization_api.rst:249
#: ../../docs/tutorials/misc/binary_serialization_api.rst:274
msgid "[1][1]"
msgstr "[1][1]"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:181
#: ../../docs/tutorials/misc/binary_serialization_api.rst:253
#: ../../docs/tutorials/misc/binary_serialization_api.rst:278
msgid "[2][0]"
msgstr "[2][0]"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:183
#: ../../docs/tutorials/misc/binary_serialization_api.rst:255
#: ../../docs/tutorials/misc/binary_serialization_api.rst:280
msgid "[2][1]"
msgstr "[2][1]"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:187
msgid "9: :ref:`Plane<class_plane>`"
msgstr "9: :ref:`Plane<class_plane>`"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:192
msgid "Normal X"
msgstr "法线 X"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:194
msgid "Normal Y"
msgstr "法线 Y"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:196
msgid "Normal Z"
msgstr "法线 Z"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:198
msgid "Distance"
msgstr "距离"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:202
msgid "10: :ref:`Quat<class_quat>`"
msgstr "10: :ref:`Quat<class_quat>`"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:207
msgid "Imaginary X"
msgstr "虚数X"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:209
msgid "Imaginary Y"
msgstr "虚数Y"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:211
msgid "Imaginary Z"
msgstr "虚数Z"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:213
msgid "Real W"
msgstr "实数W"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:217
msgid "11: :ref:`AABB<class_aabb>`"
msgstr "11: :ref:`AABB<class_aabb>`"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:232
msgid "Z Size"
msgstr "Z大小"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:236
msgid "12: :ref:`Basis<class_basis>`"
msgstr "12: :ref:`Basis<class_basis>`"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:245
#: ../../docs/tutorials/misc/binary_serialization_api.rst:270
msgid "[0][2]"
msgstr "[0][2]"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:251
#: ../../docs/tutorials/misc/binary_serialization_api.rst:276
msgid "[1][2]"
msgstr "[1][2]"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:253
#: ../../docs/tutorials/misc/binary_serialization_api.rst:278
msgid "28"
msgstr "28"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:255
#: ../../docs/tutorials/misc/binary_serialization_api.rst:280
msgid "32"
msgstr "32"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:257
#: ../../docs/tutorials/misc/binary_serialization_api.rst:282
msgid "36"
msgstr "36"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:257
#: ../../docs/tutorials/misc/binary_serialization_api.rst:282
msgid "[2][2]"
msgstr "[2][2]"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:261
msgid "13: :ref:`Transform<class_transform>`"
msgstr "13: :ref:`Transform<class_transform>`"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:284
msgid "40"
msgstr "40"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:284
msgid "[3][0]"
msgstr "[3][0]"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:286
msgid "44"
msgstr "44"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:286
msgid "[3][1]"
msgstr "[3][1]"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:288
msgid "48"
msgstr "48"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:288
msgid "[3][2]"
msgstr "[3][2]"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:292
msgid "14: :ref:`Color<class_color>`"
msgstr "14: :ref:`Color<class_color>`"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:297
#: ../../docs/tutorials/misc/binary_serialization_api.rst:471
msgid "Red (0..1)"
msgstr "红色通道 (0..1)"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:299
#: ../../docs/tutorials/misc/binary_serialization_api.rst:473
msgid "Green (0..1)"
msgstr "绿色通道 (0..1)"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:301
#: ../../docs/tutorials/misc/binary_serialization_api.rst:475
msgid "Blue (0..1)"
msgstr "蓝色通道 (0..1)"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:303
#: ../../docs/tutorials/misc/binary_serialization_api.rst:477
msgid "Alpha (0..1)"
msgstr "透明通道 (0..1)"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:307
msgid "15: :ref:`NodePath<class_nodepath>`"
msgstr "15: :ref:`NodePath<class_nodepath>`"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:312
msgid ""
"String Length, or New Format (val&0x80000000!=0 and NameCount=val&0x7FFFFFFF)"
msgstr "字符串长度或新格式 (val&0x80000000!=0 和 NameCount=val&0x7FFFFFFF)"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:316
msgid "For old format:"
msgstr "对于旧格式:"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:324
msgid "Padded to 4 bytes."
msgstr "填充到4个字节。"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:327
msgid "For new format:"
msgstr "对于新格式:"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:332
msgid "Sub-Name Count"
msgstr "子名称计数"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:334
msgid "Flags (absolute: val&1 != 0 )"
msgstr "标志 (absolute: val&1 != 0 )"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:337
msgid "For each Name and Sub-Name"
msgstr "对于每个名称和子名称"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:342
#: ../../docs/tutorials/misc/binary_serialization_api.rst:428
msgid "X+0"
msgstr "X+0"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:342
#: ../../docs/tutorials/misc/binary_serialization_api.rst:428
msgid "String Length"
msgstr "字符串长度"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:344
#: ../../docs/tutorials/misc/binary_serialization_api.rst:430
msgid "X+4"
msgstr "X+4"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:347
msgid "Every name string is padded to 4 bytes."
msgstr "每个名称字符串都会填充到4个字节。"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:350
msgid "16: :ref:`RID<class_rid>` (unsupported)"
msgstr "16: :ref:`RID<class_rid>` (暂不支持)"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:353
msgid "17: :ref:`Object<class_object>` (unsupported)"
msgstr "17: :ref:`Object<class_object>` (暂不支持)"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:356
msgid "18: :ref:`Dictionary<class_dictionary>`"
msgstr "18: :ref:`Dictionary<class_dictionary>`"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:361
#: ../../docs/tutorials/misc/binary_serialization_api.rst:373
msgid "val&0x7FFFFFFF = elements, val&0x80000000 = shared (bool)"
msgstr "val&0x7FFFFFFF = elements, val&0x80000000 = shared (bool)"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:364
msgid ""
"Then what follows is, for amount of \"elements\", pairs of key and value, "
"one after the other, using this same format."
msgstr ""
"然后，对于“elements”的数量，使用相同的格式，一个接一个地使用密钥和值对。"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:368
msgid "19: :ref:`Array<class_array>`"
msgstr "19: :ref:`Array<class_array>`"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:376
msgid ""
"Then what follows is, for amount of \"elements\", values one after the "
"other, using this same format."
msgstr "然后，对于“elements”的数量，使用相同的格式一个接一个地输出值。"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:380
msgid "20: :ref:`PoolByteArray<class_poolbytearray>`"
msgstr "20: :ref:`PoolByteArray<class_poolbytearray>`"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:385
msgid "Array Length (Bytes)"
msgstr "数组长度(字节)"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:387
msgid "8..8+length"
msgstr "8..8+长度"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:387
msgid "Byte"
msgstr "Byte"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:387
msgid "Byte (0..255)"
msgstr "字节 (0..255)"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:390
msgid "The array data is padded to 4 bytes."
msgstr "数组数据填充为4个字节。"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:393
msgid "21: :ref:`PoolIntArray<class_poolintarray>`"
msgstr "21: :ref:`PoolIntArray<class_poolintarray>`"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:398
msgid "Array Length (Integers)"
msgstr "数组长度(整数)"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:400
#: ../../docs/tutorials/misc/binary_serialization_api.rst:411
msgid "8..8+length\\*4"
msgstr "8..8+长度\\*4"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:400
msgid "32 Bits Signed Integer"
msgstr "32位符号整数"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:404
msgid "22: :ref:`PoolRealArray<class_poolrealarray>`"
msgstr "22: :ref:`PoolRealArray<class_poolrealarray>`"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:409
msgid "Array Length (Floats)"
msgstr "数组长度(浮点数)"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:411
msgid "32 Bits IEE 754 Float"
msgstr "IEE 754格式的32位浮点数"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:415
msgid "23: :ref:`PoolStringArray<class_poolstringarray>`"
msgstr "23: :ref:`PoolStringArray<class_poolstringarray>`"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:420
msgid "Array Length (Strings)"
msgstr "数组长度(字符串)"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:423
msgid "For each String:"
msgstr "对于每个字符串:"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:433
msgid "Every string is padded to 4 bytes."
msgstr "每个字符串填充为4个字节。"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:436
msgid "24: :ref:`PoolVector2Array<class_poolvector2array>`"
msgstr "24: :ref:`PoolVector2Array<class_poolvector2array>`"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:441
#: ../../docs/tutorials/misc/binary_serialization_api.rst:454
#: ../../docs/tutorials/misc/binary_serialization_api.rst:469
msgid "Array Length"
msgstr "数组长度"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:443
msgid "8..8+length\\*8"
msgstr "8..8+长度\\*8"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:445
msgid "8..12+length\\*8"
msgstr "8..12+长度\\*8"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:449
msgid "25: :ref:`PoolVector3Array<class_poolvector3array>`"
msgstr "25: :ref:`PoolVector3Array<class_poolvector3array>`"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:456
msgid "8..8+length\\*12"
msgstr "8..8+长度\\*12"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:458
msgid "8..12+length\\*12"
msgstr "8..12+长度\\*12"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:460
msgid "8..16+length\\*12"
msgstr "8..16+长度\\*12"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:464
msgid "26: :ref:`PoolColorArray<class_poolcolorarray>`"
msgstr "26: :ref:`PoolColorArray<class_poolcolorarray>`"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:471
msgid "8..8+length\\*16"
msgstr "8..8+长度\\*16"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:473
msgid "8..12+length\\*16"
msgstr "8..12+长度\\*16"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:475
msgid "8..16+length\\*16"
msgstr "8..16+长度\\*16"

#: ../../docs/tutorials/misc/binary_serialization_api.rst:477
msgid "8..20+length\\*16"
msgstr "8..20+长度\\*16"

#: ../../docs/tutorials/misc/running_code_in_the_editor.rst:4
msgid "Running code in the editor"
msgstr "在编辑器中运行代码"

#: ../../docs/tutorials/misc/running_code_in_the_editor.rst:7
msgid "What is ``tool``?"
msgstr "``tool`` 是什么？"

#: ../../docs/tutorials/misc/running_code_in_the_editor.rst:9
msgid ""
"``tool`` is a powerful line of code that, when added at the top of your "
"script, makes it execute in the editor. You can also decide which parts of "
"the script execute in the editor, which in game, and which in both."
msgstr ""
"``tool`` 是一个强大的代码行，当添加到脚本的顶部时，它会在编辑器中执行。 您还"
"可以决定脚本的哪些部分在编辑器中执行，哪部分在游戏中执行，以及哪部分在两者中"
"均执行。"

#: ../../docs/tutorials/misc/running_code_in_the_editor.rst:11
msgid ""
"You can use it for doing many things, but it is mostly useful in level "
"design for visually presenting things that are hard to predict ourselves. "
"Here are some use cases:"
msgstr ""
"您可以使用它来做很多事情，它在层次设计中非常有用，可以直观地呈现难以预测的事"
"物。 以下是一些用例:"

#: ../../docs/tutorials/misc/running_code_in_the_editor.rst:13
msgid ""
"If you have a cannon that shoots cannonballs affected by physics (gravity), "
"you can draw cannonball's trajectory in the editor, making level design a "
"lot easier."
msgstr ""
"如果您有一门大炮发出受物理(重力)影响的炮弹，您可以在编辑器中绘制炮弹的轨迹，"
"使得关卡设计更容易。"

#: ../../docs/tutorials/misc/running_code_in_the_editor.rst:14
msgid ""
"If you have jumppads with varying jump heights, you can draw the maximum "
"jump height a player would reach if it jumped on one, also making level "
"design easier."
msgstr ""
"如果您有不同跳跃高度的跳线，您可以绘制游戏角色能跳过的最大跳跃高度，也可以让"
"关卡设计变得更容易。"

#: ../../docs/tutorials/misc/running_code_in_the_editor.rst:15
msgid ""
"If your player doesn't use a sprite, but draws itself using code, you can "
"make that drawing code execute in the editor to see your player."
msgstr ""
"如果您的游戏角色不使用精灵，却使用代码来绘制，您可以在编辑器中执行该绘图代码"
"以查看您的游戏角色。"

#: ../../docs/tutorials/misc/running_code_in_the_editor.rst:18
msgid "How to use it"
msgstr "如何使用它"

#: ../../docs/tutorials/misc/running_code_in_the_editor.rst:20
msgid ""
"To turn a script into a tool, add ``tool`` keyword at the top of your code."
msgstr "要将脚本转换为工具，请在代码顶部添加 ``tool`` 关键字。"

#: ../../docs/tutorials/misc/running_code_in_the_editor.rst:22
msgid ""
"To check if you are currently in the editor, use: ``Engine.editor_hint``."
msgstr "要检查您当前是否在编辑器中，请使用 : ``Engine.editor_hint``。"

#: ../../docs/tutorials/misc/running_code_in_the_editor.rst:24
msgid "For example, if you want to execute some code only in editor, use:"
msgstr "例如，如果只想在编辑器中执行某些代码，请使用:"

#: ../../docs/tutorials/misc/running_code_in_the_editor.rst:32
msgid ""
"On the other hand, if you want to execute code only in game, simply negate "
"previous expression:"
msgstr "另一方面，如果您只想在游戏中执行代码，只需否定先前的表达式:"

#: ../../docs/tutorials/misc/running_code_in_the_editor.rst:40
msgid ""
"Pieces of code that are not having any of the 2 conditions above will run "
"both in editor and in game."
msgstr "没有上述任何条件的代码片段将在编辑器和游戏中运行。"

#: ../../docs/tutorials/misc/running_code_in_the_editor.rst:42
msgid "Here is how a ``_process()`` function might look like for you:"
msgstr "以下是 ``_process()`` 函数的示例:"

#: ../../docs/tutorials/misc/running_code_in_the_editor.rst:56
msgid ""
"Modifications in editor are permanent. In our case, when we remove the "
"script, the node will keep its rotation direction. Be careful so that you "
"don't make unwanted modifications."
msgstr ""
"编辑器中的修改是永久性的。 在我们的示例中，当我们删除脚本时，节点将保持其旋转"
"方向。 请注意不要进行不必要的修改。"

#: ../../docs/tutorials/misc/running_code_in_the_editor.rst:59
msgid "Try it out"
msgstr "试试看"

#: ../../docs/tutorials/misc/running_code_in_the_editor.rst:61
msgid ""
"Add a ``Sprite`` node to your scene and set the texture to Godot icon. "
"Attach and open a script, and change it to this:"
msgstr ""
"在场景中添加一个 ``Sprite`` 节点，并将纹理设置为Godot图标。 添加并打开脚本，"
"并将其更改为:"

#: ../../docs/tutorials/misc/running_code_in_the_editor.rst:72
msgid ""
"Save the script and return to the editor. You should now see your object "
"rotate. If you run the game, it will also rotate."
msgstr ""
"保存脚本并返回编辑器。 现在您应该看到您的对象在旋转。 如果您运行游戏，它也会"
"旋转。"

#: ../../docs/tutorials/misc/running_code_in_the_editor.rst:76
msgid ""
"If you don't see the changes, reload the scene (close it and open it again)."
msgstr "如果您没有看到变化，请重新加载场景(关闭它并再次打开)。"

#: ../../docs/tutorials/misc/running_code_in_the_editor.rst:78
msgid ""
"Now let's choose which code runs when. Modify your ``_process()`` function "
"to look like this:"
msgstr "现在让我们选择何时运行代码。 将 ``_process()`` 函数修改为:"

#: ../../docs/tutorials/misc/running_code_in_the_editor.rst:89
msgid ""
"Save the script. Now the object will spin clockwise in the editor, but if "
"you run the game, it will spin counter-clockwise."
msgstr ""
"保存脚本。 现在，对象将在编辑器中顺时针旋转，但如果您运行游戏，它将逆时针旋"
"转。"

#: ../../docs/tutorials/misc/running_code_in_the_editor.rst:91
msgid ""
"Code from other nodes doesn't run in the editor. Your access to other nodes "
"is limited. You can access the tree and nodes, and their default properties, "
"but you can't access user variables. If you want to do so, other nodes have "
"to run in the editor too. AutoLoad nodes cannot be accessed in the editor at "
"all."
msgstr ""
"其他节点的代码不会在编辑器中运行。 您对其他节点的访问权限被限制了。 您可以访"
"问树和节点及其默认属性，但无法访问用户变量。 如果要这样做，其他节点也必须在编"
"辑器中运行。 AutoLoad节点时无法在编辑器中访问的。"

#: ../../docs/tutorials/misc/running_code_in_the_editor.rst:93
msgid ""
"Using ``tool`` improperly can yield many errors. It is advised to first "
"write the code how you want it, and only then add the ``tool`` keyword to "
"the top. Also make sure you divide your code into part that runs in editor "
"and part that runs in game. This way you can find your bug easier."
msgstr ""
"不正确地使用 ``tool`` 可能会产生许多错误。 建议首先按照您想要的方式编写代码，"
"然后只在顶部添加 ``tool`` 关键字。 还要确保将代码划分为在编辑器中运行的部分和"
"在游戏中运行的部分。 这样您就可以更轻松地找到您的错误。"

#: ../../docs/tutorials/misc/change_scenes_manually.rst:4
msgid "Change scenes manually"
msgstr "手动更改场景"

#: ../../docs/tutorials/misc/change_scenes_manually.rst:6
msgid ""
"Sometimes it helps to have more control over how one swaps scenes around. As "
"mentioned above, a :ref:`Viewport <class_Viewport>`'s child nodes will "
"render to the image it generates. This holds true even for nodes outside of "
"the \"current\" scene. Autoloads fall into this category, but so do scenes "
"which one instances and adds to the tree at runtime:"
msgstr ""
"有时候，有必要更好地控制如何交换场景。如上所述，一个 :ref:`Viewport "
"<class_Viewport>` 的子节点将呈现给它生成的图像。即使对于“当前”场景之外的节"
"点，这也适用。 Autoloads属于这一类，但是一个实例在运行时添加到树中的场景也是"
"如此:"

#: ../../docs/tutorials/misc/change_scenes_manually.rst:38
msgid ""
"To complete the cycle and swap out the new scene with the old one, "
"developers have a choice to make. Many strategies exist for removing a scene "
"from view of the :ref:`Viewport <class_Viewport>`. The tradeoffs involve "
"balancing operation speed and memory consumption as well as balancing data "
"access and integrity."
msgstr ""
"要完成循环并将旧场景替换为旧场景，开发人员可以选择制作。从视图中删除场景有很"
"多策略 :ref:`Viewport <class_Viewport>`。权衡涉及平衡操作速度和内存消耗以及平"
"衡数据访问和完整性。"

#: ../../docs/tutorials/misc/change_scenes_manually.rst:44
#, fuzzy
msgid ""
"**We can delete the existing scene.** :ref:`SceneTree.change_scene() "
"<class_SceneTree_method_change_scene>` and :ref:`SceneTree.change_scene_to() "
"<class_SceneTree_method_change_scene_to>` will delete the current scene "
"immediately. Developers can also delete the main scene though. Assuming the "
"root node's name is \"Main\", one could do ``get_node(\"/root/Main\")."
"free()`` to delete the whole scene."
msgstr ""
"1. **我们可以删除现有场景。** :ref:`SceneTree.change_scene / _to "
"<class_SceneTree_method_change_scene>` 将立即删除当前场景。开发人员也可以删除"
"主场景。假设根节点的名称是“Main”，可以执行 `get_node(\"/root/Main\").free()` "
"删除整个场景。"

#: ../../docs/tutorials/misc/change_scenes_manually.rst:51
msgid "Unloads memory."
msgstr "卸载内存。"

#: ../../docs/tutorials/misc/change_scenes_manually.rst:53
msgid "Pro: RAM is no longer dragging the dead weight."
msgstr "好处: RAM不再拖累自重。"

#: ../../docs/tutorials/misc/change_scenes_manually.rst:55
msgid ""
"Con: Returning to that scene is now more expensive since it must be loaded "
"back into memory again (takes time AND memory). Not a problem if returning "
"soon is unnecessary."
msgstr ""
"坏处:回到那个场景现在更加昂贵，因为它必须再次加载回内存(需要时间和内存)。如果"
"不久就回来是不必要的。"

#: ../../docs/tutorials/misc/change_scenes_manually.rst:59
msgid ""
"Con: No longer have access to that scene's data. Not a problem if using that "
"data soon is unnecessary."
msgstr "坏处:无法再访问该场景的数据。如果不久就使用这些数据就不成问题了。"

#: ../../docs/tutorials/misc/change_scenes_manually.rst:62
msgid ""
"Note: It can be useful to preserve the data in a soon-to-be-deleted scene by "
"re-attaching one or more of its nodes to a different scene, or even directly "
"to the :ref:`SceneTree <class_SceneTree>`."
msgstr ""
"注意:通过将一个或多个节点重新附加到不同的场景，甚至直接将其重新附加到 :ref:"
"`SceneTree <class_SceneTree>`，可以将数据保存在即将删除的场景中。"

#: ../../docs/tutorials/misc/change_scenes_manually.rst:66
msgid "Processing stops."
msgstr "处理停止。"

#: ../../docs/tutorials/misc/change_scenes_manually.rst:68
msgid ""
"Pro: No nodes means no process, physics process, or input handling. The CPU "
"is available to work on the new scene's contents."
msgstr ""
"好处:没有节点意味着没有进程，物理过程或输入处理。 CPU可用于处理新场景的内容。"

#: ../../docs/tutorials/misc/change_scenes_manually.rst:71
msgid ""
"Con: Those nodes' processing and input handling no longer operate. Not a "
"problem if using the updated data is unnecessary."
msgstr ""
"坏处:这些节点的处理和输入处理不再运行。如果不需要使用更新的数据，则不成问题。"

#: ../../docs/tutorials/misc/change_scenes_manually.rst:74
msgid ""
"**We can hide the existing scene.** By changing the visibility or collision "
"detection of the nodes, we can hide the entire node sub-tree from the "
"player's perspective."
msgstr ""
"**我们可以隐藏现有场景。**通过更改节点的可见性或碰撞检测，我们可以从游戏角色"
"的角度隐藏整个节点子树。"

#: ../../docs/tutorials/misc/change_scenes_manually.rst:78
msgid "Memory still exists."
msgstr "记忆仍然存在。"

#: ../../docs/tutorials/misc/change_scenes_manually.rst:80
msgid "Pro: One can still access the data if need be."
msgstr "好处:如果需要，仍然可以访问数据。"

#: ../../docs/tutorials/misc/change_scenes_manually.rst:82
msgid "Pro: There's no need to move any more nodes around to save data."
msgstr "好处:无需再移动任何节点来保存数据。"

#: ../../docs/tutorials/misc/change_scenes_manually.rst:84
msgid ""
"Con: More data is being kept in memory which will be become a problem on "
"memory-sensitive platforms like web or mobile."
msgstr ""
"坏处:更多数据被保存在内存中，这将成为对内存敏感平台(如Web或移动设备)的问题。"

#: ../../docs/tutorials/misc/change_scenes_manually.rst:87
msgid "Processing continues."
msgstr "处理继续。"

#: ../../docs/tutorials/misc/change_scenes_manually.rst:89
msgid ""
"Pro: Data continues to receive processing updates, so the scene will keep "
"updated any data within it that relies on delta time or frame data."
msgstr ""
"好处:数据继续接收处理更新，因此场景将不断更新其中依赖于增量时间或帧数据的任何"
"数据。"

#: ../../docs/tutorials/misc/change_scenes_manually.rst:93
msgid ""
"Pro: Nodes are still members of groups (since groups belong to the :ref:"
"`SceneTree <class_SceneTree>`)."
msgstr ""
"Pro：节点仍然是组的成员(因为组属于 :ref:`SceneTree <class_SceneTree>`)。"

#: ../../docs/tutorials/misc/change_scenes_manually.rst:96
msgid ""
"Con: The CPU's attention is now divided between both scenes. Too much load "
"could result in low frame rates. One should be sure to test performance as "
"they go to ensure the target platform can support the load they are giving "
"it."
msgstr ""
"坏处:现在CPU的注意力分散在两个场景之间。负载过大可能导致帧速率降低。应该确保"
"测试性能，以确保目标平台能够支持它们提供的负载。"

#: ../../docs/tutorials/misc/change_scenes_manually.rst:101
#, fuzzy
msgid ""
"**We can remove the existing scene from the tree.** Assign a variable to the "
"existing scene's root node. Then use :ref:`Node.remove_child(Node) "
"<class_Node_method_remove_child>` to detach the entire scene from the tree."
msgstr ""
"**我们可以从树中删除现有场景。**将变量分配给现有场景的根节点。然后使用 :ref:"
"`Node.remove_child(Node)<class_Node_method_remove_child>` 从树中分离整个场"
"景。"

#: ../../docs/tutorials/misc/change_scenes_manually.rst:106
msgid "Memory still exists (similar pros/cons as with hiding it from view)."
msgstr "记忆仍然存在(与从视图中隐藏它相似的优点/缺点)。"

#: ../../docs/tutorials/misc/change_scenes_manually.rst:108
msgid "Processing stops (similar pros/cons as with deleting it completely)."
msgstr "处理停止(类似于完全删除它的优点/缺点)。"

#: ../../docs/tutorials/misc/change_scenes_manually.rst:110
msgid ""
"Pro: This variation of \"hiding\" it is much easier to show/hide. Rather "
"than potentially keeping track of multiple changes to the scene, one must "
"only call the one method add/remove_child pair of methods. It is similar to "
"disabling game objects in other engines."
msgstr ""
"亲:这种“隐藏”的变化更容易显示/隐藏。人们必须只调用一个方法add / remove_child"
"方法，而不是潜在地跟踪场景的多个变化。它类似于在其他引擎中禁用游戏对象。"

#: ../../docs/tutorials/misc/change_scenes_manually.rst:115
msgid ""
"Con: Unlike with hiding it from view only, the data contained within the "
"scene will become stale if it relies on delta time, input, groups, or other "
"data that is derived from :ref:`SceneTree <class_SceneTree>` access."
msgstr ""
"坏处:与仅从视图中隐藏它不同，如果场景中包含的数据依赖于delta时间，输入，组或"
"其他派生自 :ref:`SceneTree <class_SceneTree>` access的数据，则它将变为陈旧。"

#: ../../docs/tutorials/misc/change_scenes_manually.rst:120
msgid ""
"There are also cases where one may wish to have many scenes present at the "
"same time. Perhaps one is adding their own singleton at runtime, or "
"preserving a a scene's data between scene changes (adding the scene to the "
"root node)."
msgstr ""
"在某些情况下，人们可能希望同时出现许多场景。也许一个是在运行时添加自己的单"
"例，或者在场景更改之间保留场景的数据(将场景添加到根节点)。"

#: ../../docs/tutorials/misc/change_scenes_manually.rst:133
msgid ""
"Perhaps instead they wish to display multiple scenes at the same time using "
"a :ref:`ViewportContainers <class_ViewportContainer>`. This is optimal in "
"cases where the intent is to render different content in different parts of "
"the screen. Minimaps and split-screen multiplayer are good examples."
msgstr ""
"也许他们希望使用 :ref:`ViewportContainers <class_ViewportContainer>` 同时显示"
"多个场景。在目的是在屏幕的不同部分呈现不同内容的情况下，这是最佳的。迷您地图"
"和分屏多人游戏就是很好的示例。"

#: ../../docs/tutorials/misc/change_scenes_manually.rst:138
msgid ""
"Each option will have cases where it is best appropriate, so one must "
"examine the effects of each and determine what path best fits their unique "
"situation."
msgstr ""
"每个选项都有最合适的情况，因此必须检查每个选项的效果并确定最适合其独特情况的"
"路径。"

#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:4
#, fuzzy
msgid "Differences between GLES2 and GLES3"
msgstr "C#和GDScript之间的一般差异"

#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:6
msgid ""
"This page documents the differences between GLES2 and GLES3 that are by "
"design and are not the result of bugs. There may be differences that are "
"unintentional, but they should be reported as bugs."
msgstr ""

#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:9
msgid ""
"\"GLES2\" and \"GLES3\" are the names used in Godot for the two OpenGL-based "
"rendering backends. In terms of graphics APIs, the GLES2 backend maps to "
"OpenGL 2.1 on desktop, OpenGL ES 2.0 on mobile and WebGL 1.0 on the web. The "
"GLES3 backend maps to OpenGL 3.3 on desktop, OpenGL ES 3.0 on mobile and "
"WebGL 2.0 on the web."
msgstr ""

#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:15
msgid "Particles"
msgstr "粒子"

#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:17
msgid ""
"GLES2 cannot use the :ref:`Particles <class_Particles>` or :ref:`Particles2D "
"<class_Particles2D>` nodes as they require advanced GPU features. Instead, "
"use :ref:`CPUParticles <class_CPUParticles>` or :ref:`CPUParticles2D "
"<class_CPUParticles2D>`, which provides a similar interface to a :ref:"
"`ParticlesMaterial <class_ParticlesMaterial>`."
msgstr ""

#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:22
msgid ""
"Particles and Particles2D can be converted to their CPU equivalent node with "
"the \"Convert to CPUParticles\" option in the editor."
msgstr ""

#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:26
#, fuzzy
msgid "``SCREEN_TEXTURE`` mip-maps"
msgstr "SCREEN_TEXTURE示例"

#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:28
msgid ""
"In GLES2, ``SCREEN_TEXTURE`` (accessed via a :ref:`ShaderMaterial "
"<class_ShaderMaterial>`) does not have computed mip-maps. So when accessing "
"at a different LOD, the texture will not appear blurry."
msgstr ""

#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:32
#, fuzzy
msgid "``DEPTH_TEXTURE``"
msgstr "DEPTH_TEXTURE"

#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:34
msgid ""
"While GLES2 supports ``DEPTH_TEXTURE`` in shaders, it may not work on some "
"old hardware (especially mobile)."
msgstr ""

#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:37
#, fuzzy
msgid "Color space"
msgstr "等宽字体"

#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:39
msgid ""
"GLES2 and GLES3 are in different color spaces. This means that colors will "
"appear slightly different between them  especially when lighting is used."
msgstr ""

#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:42
msgid ""
"If your game is going to use both GLES2 and GLES3, you can use an ``if`` "
"statement check and see if the output is in sRGB, using ``OUTPUT_IS_SRGB``. "
"``OUTPUT_IS_SRGB`` is ``true`` in GLES2 and ``false`` in GLES3."
msgstr ""

#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:47
#, fuzzy
msgid "HDR"
msgstr "HUD"

#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:49
msgid ""
"GLES is not capable of using High Dynamic Range (HDR) rendering features. If "
"HDR is set for your project, or for a given viewport, Godot will still user "
"Low Dynamic Range (LDR) which limits viewport values to the ``0-1`` range."
msgstr ""

#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:54
#, fuzzy
msgid "SpatialMaterial features"
msgstr "空间材质"

#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:56
msgid ""
"In GLES2, the following advanced rendering features in the :ref:"
"`SpatialMaterial <class_SpatialMaterial>` are missing:"
msgstr ""

#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:59
#, fuzzy
msgid "Subsurface scattering"
msgstr "次表面散射"

#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:62
#, fuzzy
msgid "Depth mapping"
msgstr "现场阴影贴图"

#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:64
msgid "When using SpatialMaterials they will not even appear in the editor."
msgstr ""

#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:66
msgid ""
"In custom :ref:`ShaderMaterials <class_ShaderMaterial>`, you can set values "
"for these features but they will be non-functional. For example, you will "
"still be able to set the ``SSS`` built-in (which normally adds subsurface "
"scattering) in your shader, but nothing will happen."
msgstr ""

#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:71
#, fuzzy
msgid "Environment features"
msgstr "环境变量"

#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:73
#, fuzzy
msgid ""
"In GLES2, the following features in the :ref:`Environment "
"<class_Environment>` are missing:"
msgstr "环境光 :ref:`Environment <class_Environment>`。"

#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:75
#, fuzzy
msgid "Auto exposure"
msgstr "自动曝光(HDR)"

#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:76
#, fuzzy
msgid "Tonemapping"
msgstr "品质图"

#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:77
#, fuzzy
msgid "Screen space reflections"
msgstr "屏幕空间反射(SSR)"

#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:78
#, fuzzy
msgid "Screen space ambient occlusion"
msgstr "屏幕空间环境遮挡(SSAO)"

#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:79
#, fuzzy
msgid "Depth of field"
msgstr "景深/远模糊"

#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:80
msgid "Glow (also known as bloom)"
msgstr ""

#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:81
#, fuzzy
msgid "Adjustment"
msgstr "调整"

#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:83
msgid "That means that in GLES2 environments you can only set:"
msgstr ""

#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:85
msgid "Sky (including procedural sky)"
msgstr ""

#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:86
#, fuzzy
msgid "Ambient light"
msgstr "环境光"

#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:90
#, fuzzy
msgid "GIProbes"
msgstr "GI探针"

#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:92
msgid ""
":ref:`GIProbes <class_GIProbe>` do not work in GLES2. Instead use :ref:"
"`Baked Lightmaps <class_BakedLightmap>`. For a description of how baked "
"lightmaps work see the :ref:`Baked Lightmaps tutorial <doc_baked_lightmaps>`."
msgstr ""

#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:96
#, fuzzy
msgid "Contact shadows"
msgstr "灯光和阴影"

#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:98
msgid ""
"The ``shadow_contact`` property of :ref:`Lights <class_Light>` is not "
"supported in GLES2 and so does nothing."
msgstr ""

#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:101
#, fuzzy
msgid "Light performance"
msgstr "性能"

#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:103
msgid ""
"In GLES2, performance scales poorly with several lights, as each light is "
"processed in a separate render pass (in opposition to GLES3 which is all "
"done in a single pass). Try to limit scenes to as few lights as possible in "
"order to achieve greatest performance."
msgstr ""

#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:110
msgid ""
"On mobile, GLES2 requires ETC texture compression, while GLES3 requires "
"ETC2. ETC2 is enabled by default, so if exporting to mobile using GLES2 make "
"sure to set the project setting ``rendering/vram_compression/import_etc`` "
"and then reimport textures."
msgstr ""

#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:115
#, fuzzy
msgid "Blend shapes"
msgstr "碰撞形状"

#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:117
msgid "Blend shapes are not supported in GLES2."
msgstr ""

#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:122
msgid ""
"GLES3 provides many built-in functions that GLES2 does not. Below is a list "
"of functions that are not available or are have limited support in GLES2."
msgstr ""

#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:125
#, fuzzy
msgid ""
"For a complete list of built-in GLSL functions see the :ref:`Shading "
"Language doc <doc_shading_language>`."
msgstr ""
"有关Godot着色语言的详细信息，请参阅 :ref:`Shading Language "
"<doc_shading_language>` 参考。"

#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:128
#: ../../docs/development/compiling/compiling_for_android.rst:9
msgid "Note"
msgstr "注意"

#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:174
#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:176
#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:178
#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:180
msgid "**bias** not available in vertex shader"
msgstr ""

#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:182
#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:184
msgid "Only available in vertex shader on some hardware"
msgstr ""

#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:186
#: ../../docs/tutorials/misc/gles2_gles3_differences.rst:188
#, fuzzy
msgid "Only available in vertex shader"
msgstr "我们像这样定义顶点着色器:"

#: ../../docs/tutorials/debug/index.rst:2
msgid "Debug"
msgstr "调试"

#: ../../docs/tutorials/debug/overview_of_debugging_tools.rst:4
msgid "Overview of debugging tools"
msgstr "调试工具概述"

#: ../../docs/tutorials/debug/overview_of_debugging_tools.rst:9
msgid ""
"When developing your game, you would want to test your game and debug when "
"problems occurred. Godot provides several debugging options and tools which "
"aid your debugging process."
msgstr ""
"在游戏开发过程中时常需要对游戏进行调试来解决我们遇到的问题。 Godot 提供了一些"
"调试选项和工具来帮助您进行调试工作。"

#: ../../docs/tutorials/debug/overview_of_debugging_tools.rst:12
msgid "Debug options"
msgstr "调试选项"

#: ../../docs/tutorials/debug/overview_of_debugging_tools.rst:14
msgid ""
"There are a few options that you can enable when running your game in the "
"editor which can help you in debugging your game. These options are located "
"in ``DEBUG`` in the main menus."
msgstr ""
"在编辑器中运行游戏时可以启用几个选项，以帮助您调试游戏。 这些选项位于主菜单中"
"的 调试(Debug) 中。"

#: ../../docs/tutorials/debug/overview_of_debugging_tools.rst:19
msgid "Here are the descriptions of the options:"
msgstr "下面是这些选项的说明:"

#: ../../docs/tutorials/debug/overview_of_debugging_tools.rst:22
msgid "Deploy with Remote Debug"
msgstr "使用远程调试部署"

#: ../../docs/tutorials/debug/overview_of_debugging_tools.rst:24
msgid ""
"When exporting and deploying, the resulting executable will attempt to "
"connect to the IP of your computer, in order to be debugged."
msgstr ""
"在导出和发布游戏的调试版本时，导出的可执行文件将尝试连接到您本机的IP进行进行"
"调试。"

#: ../../docs/tutorials/debug/overview_of_debugging_tools.rst:27
msgid "Small Deploy with Network FS"
msgstr "小型部署与网络文件系统"

#: ../../docs/tutorials/debug/overview_of_debugging_tools.rst:29
msgid ""
"Export or deploy will produce minimal executable. The filesystem will be "
"provided from the project by the editor over the network. On Android, deploy "
"will use the USB cable for faster performance. This option speeds up testing "
"for games with a large footprint."
msgstr ""
"导出时生成最小化的可执行文件。改可执行文件将通过本地网络连接编辑器来使用文件"
"系统； 在 Android 平台上，可以使用 USB 进行来提高传输效率。 这个选项能够加速"
"偏大型游戏的测试工作。"

#: ../../docs/tutorials/debug/overview_of_debugging_tools.rst:33
msgid "Visible Collision Shapes"
msgstr "可见碰撞区域"

#: ../../docs/tutorials/debug/overview_of_debugging_tools.rst:35
msgid ""
"Collision shapes and raycast nodes(for 2D and 3D) will be visible on the "
"running game."
msgstr "可以在运行游戏的时候看到碰撞区域和射线节点。"

#: ../../docs/tutorials/debug/overview_of_debugging_tools.rst:38
msgid "Visible Navigation"
msgstr "可见导航"

#: ../../docs/tutorials/debug/overview_of_debugging_tools.rst:40
msgid "Navigation meshes and polygons will be visible on the running game."
msgstr "可以在运行的游戏的时候看到导航网格和多边形。"

#: ../../docs/tutorials/debug/overview_of_debugging_tools.rst:43
msgid "Sync Scene Changes"
msgstr "同步场景修改"

#: ../../docs/tutorials/debug/overview_of_debugging_tools.rst:45
msgid ""
"Any changes made to the scene in the editor will be replicated in the "
"running game. When used remotely on a device, this is more efficient with "
"network filesystem."
msgstr ""
"在编辑器中对场景所做的任何更改都将在正在运行的游戏中出现。 当在设备上远程使用"
"时，这对网络文件系统更有效。"

#: ../../docs/tutorials/debug/overview_of_debugging_tools.rst:49
msgid "Sync Script Changes"
msgstr "同步脚本变更"

#: ../../docs/tutorials/debug/overview_of_debugging_tools.rst:51
msgid ""
"Any script that is saved will be reloaded on the running game. When used "
"remotely on a device, this is more efficient with network filesystem."
msgstr ""
"任何已修改并保存的脚本将在正在运行的游戏中重新加载。 当在设备上远程使用时，这"
"对网络文件系统更有效。"

#: ../../docs/tutorials/debug/overview_of_debugging_tools.rst:55
msgid "Debugging tools"
msgstr "调试工具"

#: ../../docs/tutorials/debug/overview_of_debugging_tools.rst:57
msgid ""
"The ``Debugger`` is the second option in the bottom panel. Click on it and a "
"new panel occurs."
msgstr ""
"``调试器 (Debugger)`` 按钮在底部面板中可以找到，点击后可以打开调试工具面板。"

#: ../../docs/tutorials/debug/overview_of_debugging_tools.rst:61
msgid "The ``Debugger`` provides certain tools under different tabs."
msgstr "调试工具中的各个切页提供了不同的的调试功能。"

#: ../../docs/tutorials/debug/overview_of_debugging_tools.rst:63
msgid "Here are some brief descriptions of the tools:"
msgstr "下面是对这些工具的一些简要说明:"

#: ../../docs/tutorials/debug/overview_of_debugging_tools.rst:66
msgid "Debugger"
msgstr "调试器"

#: ../../docs/tutorials/debug/overview_of_debugging_tools.rst:68
msgid "Monitor the game running process."
msgstr "显示正在运行的游戏进程。"

#: ../../docs/tutorials/debug/overview_of_debugging_tools.rst:71
msgid "Errors"
msgstr "错误"

#: ../../docs/tutorials/debug/overview_of_debugging_tools.rst:73
msgid "Print out errors when running the game."
msgstr "输出游戏运行时发生的错误信息。"

#: ../../docs/tutorials/debug/overview_of_debugging_tools.rst:76
msgid "Profiler"
msgstr "性能分析"

#: ../../docs/tutorials/debug/overview_of_debugging_tools.rst:78
msgid "Profiling the performance of the any function call in the running game."
msgstr "对正在运行中的游戏进行性能分析。"

#: ../../docs/tutorials/debug/overview_of_debugging_tools.rst:81
msgid "Monitors"
msgstr "显示"

#: ../../docs/tutorials/debug/overview_of_debugging_tools.rst:83
msgid ""
"Monitors the performance of the running game, such as the fps and physics "
"collisions."
msgstr "监视正在运行的游戏的运行状况，例如 FPS 和物理碰撞。"

#: ../../docs/tutorials/debug/overview_of_debugging_tools.rst:86
msgid "Video Mem"
msgstr "显存"

#: ../../docs/tutorials/debug/overview_of_debugging_tools.rst:88
msgid "Listing the video memory usage of the running game."
msgstr "列出运行中的游戏所有的现存占用列表。"

#: ../../docs/tutorials/debug/overview_of_debugging_tools.rst:91
msgid "Misc"
msgstr "其他"

#: ../../docs/tutorials/debug/overview_of_debugging_tools.rst:93
msgid "Miscellaneous options for debug."
msgstr "调试用的其他选项。"

#: ../../docs/tutorials/debug/overview_of_debugging_tools.rst:97
msgid "Remote in Scene dock"
msgstr "远程场景树"

#: ../../docs/tutorials/debug/overview_of_debugging_tools.rst:99
msgid ""
"When running your game, a bar will occur at the top of the ``Scene`` dock. "
"You can switch to ``Remote`` and inspect or change the nodes' parameters in "
"the running game."
msgstr ""
"在启动游戏后，``场景 (Scene)`` 停靠窗的顶部会出现一条切页栏，您可以切换到 ``"
"远程 (Remote) `` 然后检视运行中节点和他们属性的变化。"

#: ../../docs/tutorials/debug/overview_of_debugging_tools.rst:103
msgid ""
"Some editor settings related to debugging can be found inside the ``Editor "
"Settings``, under Network>Debug and Debugger sections."
msgstr ""
"一些与调试相关的编辑器设置可以在“编辑器设置”中找到，在“网络”>“调试和调试器”部"
"分下。"

#: ../../docs/development/compiling/getting_source.rst:4
msgid "Getting the source"
msgstr "获取源代码"

#: ../../docs/development/compiling/getting_source.rst:7
msgid "Downloading the Godot source code"
msgstr "下载 Godot 源代码"

#: ../../docs/development/compiling/getting_source.rst:9
msgid ""
"Before :ref:`getting into the SCons build system "
"<doc_introduction_to_the_buildsystem>` and compiling Godot, you need to "
"actually download the Godot source code."
msgstr ""
"在 :ref:`进入SCons构建系统 <doc_introduction_to_the_buildsystem>` 编译 Godot "
"之前，您需要将 Godot 的源代码下载到本地。"

#: ../../docs/development/compiling/getting_source.rst:12
msgid ""
"The source code is available on `GitHub <https://github.com/godotengine/"
"godot>`__ and while you can manually download it via the website, in general "
"you want to do it via the ``git`` version control system."
msgstr ""
"您可以从 `GitHub <https://github.com/godotengine/godot>`__ 页面中下载源代"
"码， 而通常情况下您可以通过``git`` 这个版本控制器来克隆我们的代码。"

#: ../../docs/development/compiling/getting_source.rst:16
msgid ""
"If you don't know much about ``git`` yet, there are a great number of "
"`tutorials <https://git-scm.com/book>`__ available on various websites."
msgstr ""
"如果您还不太了解 ``git`` ， 建议您通过这些`网络教程 <https://git-scm.com/"
"book>`__ 对它进行了解。"

#: ../../docs/development/compiling/getting_source.rst:19
msgid ""
"In general, you need to install ``git`` and/or one of the various GUI "
"clients."
msgstr "一般来说，这需要您安装 ``git`` 或者其他带有 ``git``的图形界面客户端。"

#: ../../docs/development/compiling/getting_source.rst:21
msgid ""
"Afterwards, to get the latest development version of the Godot source code "
"(the unstable ``master`` branch), you can use ``git clone``."
msgstr ""
"此外，您也可以通过 ``git clone`` 来获取到最新版本的 Godot 源代码 (非稳定版本 "
"``master`` 分支)。"

#: ../../docs/development/compiling/getting_source.rst:24
msgid ""
"If you are using the ``git`` command line client, this is done by entering "
"the following in a terminal:"
msgstr ""
"如果您能够使用 ``git`` 命令行的话，获取源代码这项工作可以在终端中执行下面的命"
"令来完成:"

#: ../../docs/development/compiling/getting_source.rst:31
msgid ""
"For any stable release, visit the `release page <https://github.com/"
"godotengine/godot/releases>`__ and click on the link for the release you "
"want. You can then download and extract the source from the download link on "
"the page."
msgstr ""
"要获取稳定版本的源代码，请访问 `源代码发布页面 <https://github.com/"
"godotengine/godot/releases>`__ ，您可以通过点击您想要的版本来下载源代码压缩"
"包。"

#: ../../docs/development/compiling/getting_source.rst:35
msgid ""
"There are also generally branches besides ``master`` for each major version."
msgstr "此外，您可以通过 ``git`` 在各个主要版本的分支间进行切换。"

#: ../../docs/development/compiling/getting_source.rst:37
msgid ""
"After downloading the Godot source code, you can :ref:`continue to compiling "
"Godot <doc_introduction_to_the_buildsystem>`."
msgstr ""
"获取到 Godot 的源代码之后，您就可以继续 :ref:`编译 Godot "
"<doc_introduction_to_the_buildsystem>` 了。"

#: ../../docs/development/compiling/introduction_to_the_buildsystem.rst:4
msgid "Introduction to the buildsystem"
msgstr "构建系统介绍"

#: ../../docs/development/compiling/introduction_to_the_buildsystem.rst:9
msgid "SCons"
msgstr "SCons"

#: ../../docs/development/compiling/introduction_to_the_buildsystem.rst:11
msgid ""
"Godot uses `SCons <https://www.scons.org/>`__ to build. We love it, we are "
"not changing it for anything else. We are not even sure other build systems "
"are up to the task of building Godot. We constantly get requests to move the "
"build system to CMake, or Visual Studio, but this is not going to happen. "
"There are many reasons why we have chosen SCons over other alternatives, for "
"example:"
msgstr ""
"Godot使用`SCons <https://www.scons.org/>`__来构建。 我们喜欢它，我们不会因为"
"其他任何事情而改变它。 我们甚至不确定其他构建系统是否能够完成构建Godot的任"
"务。 我们不断收到将构建系统移动到CMake或Visual Studio的请求，但这不会发生。 "
"我们选择SCons优于其他替代品的原因有很多，例如:"

#: ../../docs/development/compiling/introduction_to_the_buildsystem.rst:18
msgid ""
"Godot can be compiled for a dozen different platforms. All PC platforms, all "
"mobile platforms, many consoles, and many web-based platforms (such as HTML5 "
"and Chrome PNACL)."
msgstr ""
"Scons 能将 Godot 直接编译到各个平台上。它支持所有的 PC 平台， 所有的移动平"
"台， 很多主机平台，还有一些基于Web的平台(诸如HTML和Chrome家的PNACL)。"

#: ../../docs/development/compiling/introduction_to_the_buildsystem.rst:21
msgid ""
"Developers often need to compile for several of the platforms **at the same "
"time**, or even different targets of the same platform. They can't afford "
"reconfiguring and rebuilding the project each time. SCons can do this with "
"no sweat, without breaking the builds."
msgstr ""
"开发者们经常需要 **同时** 支持将代码编译到多个平台上，或者同一个平台的不同架"
"构上，这往往造成了各项重复的构建命令和重建项目操作。而 SCons 可以毫不费力地完"
"成这项工作，不会破坏任何平台的构建。"

#: ../../docs/development/compiling/introduction_to_the_buildsystem.rst:25
msgid ""
"SCons will *never* break a build no matter how many changes, configurations, "
"additions, removals etc. You have more chances to die struck by lightning "
"than needing to clean and rebuild in SCons."
msgstr ""
"不论对项目做出多少修改、配置、增加、删除之类的事情，Scons 都不会把构建(build)"
"搞坏。需要您用 Scons 进行清理和重新构建的几率比被雷劈死还要低。"

#: ../../docs/development/compiling/introduction_to_the_buildsystem.rst:28
msgid ""
"Godot build process is not simple. Several files are generated by code "
"(binders), others are parsed (shaders), and others need to offer "
"customization (plugins). This requires complex logic which is easier to "
"write in an actual programming language (like Python) rather than using a "
"mostly macro-based language only meant for building."
msgstr ""
"Godot 的构建过程比较复杂。 它需要处理一些生成的代码(编译二进制文件)；一些通过"
"解析其他文件生成的代码(例如着色器)；还有一些需要其他自定义的构建行为(如插件和"
"模块)。这种复杂的构建逻辑可以通过实际的编程语言(例如Python)来轻松解决，如果使"
"用基于宏的配置脚本将会非常麻烦。"

#: ../../docs/development/compiling/introduction_to_the_buildsystem.rst:33
msgid ""
"Godot build process makes heavy use of cross compiling tools. Each platform "
"has a specific detection process, and all these must be handled as specific "
"cases with special code written for each."
msgstr ""
"Godot 的构建过程大量使用交叉编译工具。 每个平台都有一些特定的检测过程，所有这"
"些都必须作为特殊情况处理，我们为每个平台编写了必不可少的构建代码。"

#: ../../docs/development/compiling/introduction_to_the_buildsystem.rst:37
msgid ""
"So, please try to keep an open mind and get at least a little familiar with "
"it if you are planning to build Godot yourself."
msgstr ""
"因此，如果您想要自己构建 Godot 的话，请持一个开放的态度，至少稍微熟悉一下这个"
"构建系统。"

#: ../../docs/development/compiling/introduction_to_the_buildsystem.rst:43
msgid ""
"Please refer to the documentation for :ref:`doc_compiling_for_android`, :ref:"
"`doc_compiling_for_ios`, :ref:`doc_compiling_for_osx`, :ref:"
"`doc_compiling_for_uwp`, :ref:`doc_compiling_for_web`, :ref:"
"`doc_compiling_for_windows` and :ref:`doc_compiling_for_x11`."
msgstr ""
"您可以参照平台相关的构建文档 :ref:`doc_compiling_for_android`, :ref:"
"`doc_compiling_for_ios`, :ref:`doc_compiling_for_osx`, :ref:"
"`doc_compiling_for_uwp`, :ref:`doc_compiling_for_web`, :ref:"
"`doc_compiling_for_windows` and :ref:`doc_compiling_for_x11`。"

#: ../../docs/development/compiling/introduction_to_the_buildsystem.rst:45
msgid ""
"Note that for **Windows/Visual Studio**, you need to use ``x86_x64 Cross "
"Tools Command Prompt for VS 2017`` or similar, depending on your install, "
"instead of the standard Windows command prompt to enter the commands below."
msgstr ""
"注意， 在**Windows/Visual Studio** 环境下，您要使用 ``x86_x64 Cross Tools "
"Command Prompt for VS 2017``  这类工具(具体命令视您安装的版本来定)， 而不能直"
"接使用通用的 Windows 命令提示符。"

#: ../../docs/development/compiling/introduction_to_the_buildsystem.rst:48
msgid "Platform selection"
msgstr "选择构建平台"

#: ../../docs/development/compiling/introduction_to_the_buildsystem.rst:50
msgid ""
"Godot's build system will begin by detecting the platforms it can build for. "
"If not detected, the platform will simply not appear on the list of "
"available platforms. The build requirements for each platform are described "
"in the rest of this tutorial section."
msgstr ""
"Godot 的构建系统会在启动时检测它在当前环境中可以执行构建的的平台。如果没有检"
"测到当当前环境不支持的平台，那么这个平台将不会显示在可构建的平台列表中。 本文"
"的的后续部分将介绍各个平台的构建要求。"

#: ../../docs/development/compiling/introduction_to_the_buildsystem.rst:55
msgid "SCons is invoked by just calling ``scons``."
msgstr "SCons 构建系统可通过调用 ``scons`` 命令来启动。"

#: ../../docs/development/compiling/introduction_to_the_buildsystem.rst:57
msgid ""
"However, this will do nothing except list the available platforms, for "
"example:"
msgstr "但是，除了列出可用的平台之外，这并不会执行任何构建任务。例如:"

#: ../../docs/development/compiling/introduction_to_the_buildsystem.rst:78
msgid ""
"To build for a platform (for example, x11), run with the ``platform=`` (or "
"just ``p=`` to make it short) argument:"
msgstr ""
"我们通过传递平台参数( 添加``platform=`` 或者缩写 ``p=`` )来让 Scons 执行对应"
"平台(例如 x11 )的构建任务:"

#: ../../docs/development/compiling/introduction_to_the_buildsystem.rst:85
msgid ""
"This will start the build process, which will take a while. If you want "
"scons to build faster, use the ``-j <cores>`` parameter to specify how many "
"cores will be used for the build. Or just leave it using one core, so you "
"can use your computer for something else :)"
msgstr ""
"这将开始 Godot 的构建进程，需要花一段时间才能完成。 如果您希望 Scons 的构建速"
"度更快，请使用 ``-j <cores>`` 参数指定构建任务要使用多少个CPU核心。 或者只是"
"让它使用一个核心，这样您可以继续使用您的电脑的做其他事情 :)"

#: ../../docs/development/compiling/introduction_to_the_buildsystem.rst:90
msgid "Example for using 4 cores:"
msgstr "例如启动 4 核进行构建:"

#: ../../docs/development/compiling/introduction_to_the_buildsystem.rst:97
msgid "Resulting binary"
msgstr "输出的程序"

#: ../../docs/development/compiling/introduction_to_the_buildsystem.rst:99
msgid ""
"The resulting binaries will be placed in the bin/ subdirectory, generally "
"with this naming convention:"
msgstr "构建所得到的二进制文件将被放置在 bin/ 子目录中，通常使用这种命名约定:"

#: ../../docs/development/compiling/introduction_to_the_buildsystem.rst:106
msgid "For the previous build attempt the result would look like this:"
msgstr "对于上面所说的构建任务，将输出下面这样的二进制文件:"

#: ../../docs/development/compiling/introduction_to_the_buildsystem.rst:113
msgid ""
"This means that the binary is for X11, is not optimized, has tools (the "
"whole editor) compiled in, and is meant for 64 bits."
msgstr ""
"文件名描述了这个二进制文件是 X11 平台的、它没有进行编译优化、它带有工具功能"
"(整个 Godot 编辑器)、并且它是针对64位架构进行构建的结果。"

#: ../../docs/development/compiling/introduction_to_the_buildsystem.rst:116
msgid "A Windows binary with the same configuration will look like this."
msgstr "同理，同样的构建配置在 Windows 上的构建文件是这样的。"

#: ../../docs/development/compiling/introduction_to_the_buildsystem.rst:123
msgid ""
"Just copy that binary to wherever you like, as it contains the project "
"manager, editor and all means to execute the game. However, it lacks the "
"data to export it to the different platforms. For that the export templates "
"are needed (which can be either downloaded from `godotengine.org <https://"
"godotengine.org/>`__, or you can build them yourself)."
msgstr ""
"现在您可以将该二进制文件复制到任何您喜欢的地方，它包含了项目管理器，游戏编辑"
"器和游戏播放器的所有功能(是不是很酷！)。仅缺少您在游戏开发过程中所需要导出游"
"戏到其他平台的导出模板(可以从`godotengine.org <https://godotengine.org/>`__下"
"载到，也可以自己构建它们)。"

#: ../../docs/development/compiling/introduction_to_the_buildsystem.rst:129
msgid ""
"Aside from that, there are a few standard options that can be set in all "
"build targets, and which will be explained below."
msgstr ""
"除此之外，可以在所有的构建目标中有几个标准选项可以进行设置，下面将对此进行说"
"明。"

#: ../../docs/development/compiling/introduction_to_the_buildsystem.rst:135
msgid ""
"Tools are enabled by default in all PC targets (Linux, Windows, macOS), "
"disabled for everything else. Disabling tools produces a binary that can run "
"projects but that does not include the editor or the project manager."
msgstr ""
"工具选项在所有PC平台(Linux, Windows, macOS)上默认启用，在其他平台上默认禁"
"用。 禁用工具选项后构建得到的二进制文件会更小，因为它不包括游戏编辑器和项目管"
"理器功能。"

#: ../../docs/development/compiling/introduction_to_the_buildsystem.rst:145
msgid "Target"
msgstr "构建目标 (target)"

#: ../../docs/development/compiling/introduction_to_the_buildsystem.rst:147
msgid "Target controls optimization and debug flags. Each mode means:"
msgstr "构建目标控制的是编译器的调试和优化选项， 它支持这些模式:"

#: ../../docs/development/compiling/introduction_to_the_buildsystem.rst:149
msgid ""
"**debug**: Build with C++ debugging symbols, runtime checks (performs checks "
"and reports error) and none to little optimization."
msgstr ""
"**debug**: 带有C++调试符号的构建，支持运行时检查(执行检查和错误报告)同时不进"
"行编译任何优化。"

#: ../../docs/development/compiling/introduction_to_the_buildsystem.rst:151
msgid ""
"**release_debug**: Build without C++ debugging symbols and optimization, but "
"keep the runtime checks (performs checks and reports errors). Official "
"binaries use this configuration."
msgstr ""
"**release_debug**: 不带C++调试符号和编译器优化，但保持运行时检查(执行检查和错"
"误报告)。 官方发布的二进制文件就是使用这种配置进行构建的。"

#: ../../docs/development/compiling/introduction_to_the_buildsystem.rst:154
msgid ""
"**release**: Build without symbols, with optimization and with little to no "
"runtime checks. This target can't be used together with tools=yes, as the "
"tools require some debug functionality and run-time checks to run."
msgstr ""
"**release**: 不带调试符号的构建，执行编译器优化，不支持有运行时检查。 该配置"
"不能与``tools = yes``一起使用，因为这些工具需要一些调试功能和运行时检查才能运"
"行。"

#: ../../docs/development/compiling/introduction_to_the_buildsystem.rst:163
msgid ""
"This flag appends the \".debug\" suffix (for debug), or \".tools\" (for "
"debug with tools enabled). When optimization is enabled (release) it appends "
"the \".opt\" suffix."
msgstr ""
"根据些选项的配置会在二进制文件名中附加 “.debug” 后缀(用于调试)或 “.tools”(用"
"于启用工具的调试)。 当启用优化(发布版)时，它会附加“.opt”后缀。"

#: ../../docs/development/compiling/introduction_to_the_buildsystem.rst:168
msgid "Bits"
msgstr "位 (bits)"

#: ../../docs/development/compiling/introduction_to_the_buildsystem.rst:170
msgid ""
"Bits is meant to control the CPU or OS version intended to run the binaries. "
"It is focused mostly on desktop platforms and ignored everywhere else."
msgstr ""
"位选项控制的是构建结果的二进制文件指出的CPU或操作系统的版本。它是针对桌面平台"
"的配置，在其他平台会被忽略掉。"

#: ../../docs/development/compiling/introduction_to_the_buildsystem.rst:174
msgid "**32**: Build binaries for 32 bits platform."
msgstr "**32**: 构建支持32位系统的二进制文件。"

#: ../../docs/development/compiling/introduction_to_the_buildsystem.rst:175
msgid "**64**: Build binaries for 64 bits platform."
msgstr "**64**:  构建支持64位系统的二进制文件。"

#: ../../docs/development/compiling/introduction_to_the_buildsystem.rst:176
msgid ""
"**default**: Build whatever the build system feels is best. On Linux this "
"depends on the host platform (if not cross compiling), on Mac it defaults to "
"64 bits and on Windows it defaults to 32 bits."
msgstr ""
"**default**: 让构建系统选择构建它认为最合适的二进制文件。在Linux上，这取决于"
"您所使用的系统(如果不是交叉编译的话)，在Mac上它默认为64位，在Windows上它默认"
"为32位。"

#: ../../docs/development/compiling/introduction_to_the_buildsystem.rst:184
msgid ""
"This flag appends \".32\" or \".64\" suffixes to resulting binaries when "
"relevant."
msgstr "这项配置会在构建结果的二进制文件名中添加  \".32\" 或  \".64\" 后缀。"

#: ../../docs/development/compiling/introduction_to_the_buildsystem.rst:188
msgid "Other build options"
msgstr "其他构建选项"

#: ../../docs/development/compiling/introduction_to_the_buildsystem.rst:190
msgid ""
"There are several other build options that you can use to configure the way "
"Godot should be built (compiler, debug options, etc.) as well as the "
"features to include/disable."
msgstr ""
"您还可以使用其他几个构建选项来配置Godot的构建方式(编译器，调试选项等)以及要包"
"含/禁用的功能。"

#: ../../docs/development/compiling/introduction_to_the_buildsystem.rst:194
msgid ""
"Check the output of ``scons --help`` for details about each option for the "
"version you are willing to compile."
msgstr "检查``scons --help``的输出，了解您愿意编译的版本的每个选项的详细信息。"

#: ../../docs/development/compiling/introduction_to_the_buildsystem.rst:200
msgid ""
"Official export templates are downloaded from the Godot Engine site: "
"`godotengine.org <https://godotengine.org/>`__. However, you might want to "
"build them yourself (in case you want newer ones, you are using custom "
"modules, or simply don't trust your own shadow)."
msgstr ""
"官方的导出模板可以从 `Godot 的官方网站 <https://godotengine.org/>`__ 下载"
"到。 此外，由于种种原因您可能想要自己构建您的导出模板(可能您想要构建未发布的"
"新版本、您要使用模块(modules)、您不信任我们编译的包是否安全)。"

#: ../../docs/development/compiling/introduction_to_the_buildsystem.rst:205
msgid ""
"If you download the official export templates package and unzip it, you will "
"notice that most are just optimized binaries or packages for each platform:"
msgstr ""
"如果您下载过官方的导出模板压缩包，解压后您会发现里面大多是各个平台通过编译优"
"化二进制文件或者对应平台的软件包:"

#: ../../docs/development/compiling/introduction_to_the_buildsystem.rst:228
msgid ""
"To create those yourself, just follow the instructions detailed for each "
"platform in this same tutorial section. Each platform explains how to create "
"its own template."
msgstr ""
"如要自己创建这些文件，只需按照该教程的各个平台的详细说明进行操作即可。 每个平"
"台的教程都有介绍如何创建导出模板。"

#: ../../docs/development/compiling/introduction_to_the_buildsystem.rst:232
msgid ""
"If you are developing for multiple platforms, macOS is definitely the most "
"convenient host platform for cross compilation, since you can cross-compile "
"for almost every target (except for UWP). Linux and Windows come in second "
"place, but Linux has the advantage of being the easier platform to set this "
"up."
msgstr ""
"如果您要进行夸平台开发， macOS 绝对是用于交叉编译最方便的平台了， 您可以在 "
"macOS 上交叉编译出除 UWP 之外的所有平台的二进制文件。 Linux 和 Windows 倒是也"
"可以进行交叉编译只是没那么轻松， 但 Linux 有一个很好的优点 —— 能够轻易地搭建"
"好交叉编译所需的环境。"

#: ../../docs/development/compiling/compiling_for_windows.rst:4
msgid "Compiling for Windows"
msgstr "为Windows平台编译"

#: ../../docs/development/compiling/compiling_for_windows.rst:11
msgid "For compiling under Windows, the following is required:"
msgstr "要在Windows下进行编译，需要以下内容:"

#: ../../docs/development/compiling/compiling_for_windows.rst:13
msgid ""
"Visual C++, `Visual Studio Community <https://www.visualstudio.com/vs/"
"community/>`__ (recommended), version 2013 (12.0) or later. **Make sure you "
"read Installing Visual Studio caveats below or you will have to run/download "
"the installer again.**"
msgstr ""
"Visual C++，`Visual Studio社区 <https://www.visualstudio.com/vs/community/"
">`__ (推荐)，版本2013(12.0)或更高版本。 **请确保阅读下面的安装Visual Studio警"
"告，或者您必须再次运行/下载安装程序。**"

#: ../../docs/development/compiling/compiling_for_windows.rst:18
msgid "`Python 2.7+ or Python 3.5+ <https://www.python.org/downloads/>`__."
msgstr "`Python 2.7+或Python 3.5+ <https://www.python.org/downloads/>`__。"

#: ../../docs/development/compiling/compiling_for_windows.rst:19
msgid ""
"`Pywin32 Python Extension <https://github.com/mhammond/pywin32>`__ for "
"parallel builds (which increase the build speed by a great factor)."
msgstr ""
"`Pywin32 Python Extension <https://github.com/mhammond/pywin32>`__用于并行构"
"建(它可以提高构建速度)。"

#: ../../docs/development/compiling/compiling_for_windows.rst:21
msgid "`SCons <https://www.scons.org>`__ build system."
msgstr "`SCons <https://www.scons.org>`__构建系统。"

#: ../../docs/development/compiling/compiling_for_windows.rst:23
#: ../../docs/development/compiling/compiling_for_x11.rst:27
#: ../../docs/development/compiling/compiling_for_osx.rst:19
#: ../../docs/development/compiling/compiling_for_android.rst:37
#: ../../docs/development/compiling/compiling_for_ios.rst:15
#: ../../docs/development/compiling/compiling_for_uwp.rst:20
#: ../../docs/development/compiling/compiling_for_web.rst:19
msgid ""
"For a general overview of SCons usage for Godot, see :ref:"
"`doc_introduction_to_the_buildsystem`."
msgstr ""
"有关Godot的SCons用法的一般概述，请参阅 :ref:"
"`doc_introduction_to_the_buildsystem`。"

#: ../../docs/development/compiling/compiling_for_windows.rst:27
msgid "Setting up SCons"
msgstr "设置SCons"

#: ../../docs/development/compiling/compiling_for_windows.rst:29
msgid ""
"Python adds the interpreter (python.exe) to the path. It usually installs in "
"``C:\\Python`` (or ``C:\\Python[Version]``). SCons installs inside the "
"Python install (typically in the ``Scripts`` folder) and provides a batch "
"file called ``scons.bat``. The location of this file can be added to the "
"path or it can simply be copied to ``C:\\Python`` together with the "
"interpreter executable."
msgstr ""
"Python将解释器(python.exe)添加到路径中。 它通常安装在``C:\\ Python``(或``C:"
"\\ Python [Version]``)中。 SCons安装在Python安装中(通常在``Scripts``文件夹"
"中)，并提供一个名为``scons.bat``的批处理文件。 可以将此文件的位置添加到路径"
"中，也可以将其与解释器可执行文件一起复制到“C:\\ Python”。"

#: ../../docs/development/compiling/compiling_for_windows.rst:36
msgid ""
"To check whether you have installed Python and SCons correctly, you can type "
"``python --version`` and ``scons --version`` into the Windows Command Prompt "
"(``cmd.exe``)."
msgstr ""
"要检查是否已正确安装Python和SCons，可以在Windows命令提示符(``cmd.exe``)中键入"
"``python --version``和``scons --version``。"

#: ../../docs/development/compiling/compiling_for_windows.rst:40
msgid ""
"If commands above do not work, make sure you add Python to your PATH "
"environment variable after installing it, and check again."
msgstr ""
"如果上面的命令不起作用，请确保在安装后将Python添加到PATH环境变量中，然后再次"
"检查。"

#: ../../docs/development/compiling/compiling_for_windows.rst:44
msgid "Setting up Pywin32"
msgstr "设置Pywin32"

#: ../../docs/development/compiling/compiling_for_windows.rst:46
msgid ""
"Pywin32 is required for parallel builds using multiple CPU cores. If SCons "
"is issuing a warning about Pywin32 after parsing SConstruct build "
"instructions, when beginning to build, you need to install it properly from "
"the correct installer executable for your Python version `located at Github. "
"<https://github.com/mhammond/pywin32/releases>`__"
msgstr ""
"使用多个CPU内核的并行构建需要Pywin32。 如果SCons在解析SConstruct构建指令后发"
"出有关Pywin32的警告，那么在开始构建时，您需要从位于Github的Python版本的正确安"
"装程序可执行文件中正确安装 `它。 <https://github.com/mhammond/pywin32/"
"releases>`__"

#: ../../docs/development/compiling/compiling_for_windows.rst:52
msgid ""
"For example, if you installed a 32-bit version of Python 2.7, you would want "
"to install the latest version of Pywin32 that is built for the mentioned "
"version of Python. That executable installer would be named ``pywin32-221."
"win32-py2.7.exe``."
msgstr ""
"例如，如果您安装了Python 2.7的32位版本，您可能希望安装为前面提到的Python版本"
"构建的最新版本Pywin32。该可执行安装程序将命名为' pywin32-221.win32-py2.7.exe "
"' '。"

#: ../../docs/development/compiling/compiling_for_windows.rst:56
msgid ""
"The ``amd64`` version of Pywin32 is for a 64-bit version of Python "
"``pywin32-221.win-amd64-py2.7.exe``. Change the ``py`` number to install for "
"your version of Python (check via ``python --version`` mentioned above)."
msgstr ""
"Pywin32的 ``amd64`` 版本适用于64位版本的Python ``pywin32-221.win-amd64-py2.7."
"exe`` 。 更改`py``数字以安装您的Python版本(通过上面提到的``python --version``"
"检查)。"

#: ../../docs/development/compiling/compiling_for_windows.rst:63
msgid "Installing Visual Studio caveats"
msgstr "安装Visual Studio警告"

#: ../../docs/development/compiling/compiling_for_windows.rst:65
msgid ""
"If installing Visual Studio 2015 or later, make sure to run **Custom** "
"installation, not **Typical** and select C++ as language there (and any "
"other things you might need). The installer does not install C++ by default. "
"C++ was the `only language made optional <https://blogs.msdn.microsoft.com/"
"vcblog/2015/07/24/setup-changes-in-visual-studio-2015-affecting-c-developers/"
">`__ in Visual Studio 2015."
msgstr ""
"如果安装Visual Studio 2015或更高版本，请确保运行** Custom **安装，而不是 **典"
"型** 并选择C++作为语言(以及您可能需要的任何其他内容)。 安装程序默认不安装C+"
"+。 C++是 `唯一的语言可选 <https://blogs.msdn.microsoft.com/"
"vcblog/2015/07/24/setup-changes-in-visual-studio-2015-affecting-c-developers/"
">`__ 在Visual Studio 2015中。"

#: ../../docs/development/compiling/compiling_for_windows.rst:71
msgid ""
"If you have already made the mistake of installing a **Typical**, "
"installation, rerun the executable installer you downloaded from internet, "
"it will give you a **Modify** Button option. Running the install from Add/"
"Remove programs will only give you the \"Repair\" option, which will do "
"nothing for your problem."
msgstr ""
"如果您已经错误地安装了 **典型** ，安装，重新运行从Internet下载的可执行安装程"
"序，它将为您提供 **修改** 按钮选项。 从“添加/删除程序”运行安装只会为您提供“修"
"复”选项，该选项对您的问题无效。"

#: ../../docs/development/compiling/compiling_for_windows.rst:77
msgid ""
"If you're using Express, make sure you get/have a version that can compile "
"for ***C++, Desktop***."
msgstr ""
"如果您正在使用Express，请确保您拥有可以为*** C++，Desktop ***编译的版本。"

#: ../../docs/development/compiling/compiling_for_windows.rst:81
msgid "Downloading Godot's source"
msgstr "下载Godot的来源"

#: ../../docs/development/compiling/compiling_for_windows.rst:83
msgid ""
"`Godot's <https://github.com/godotengine/godot>`__ source is hosted on "
"GitHub. Downloading it (cloning) via `Git <https://git-scm.com/>`__ is "
"recommended."
msgstr ""
"`Godot的 <https://github.com/godotengine/godot>`__来源托管在GitHub上。 建议通"
"过`Git <https://git-scm.com/>`__下载(克隆)。"

#: ../../docs/development/compiling/compiling_for_windows.rst:86
msgid ""
"The tutorial will presume from now on that you placed the source into ``C:"
"\\godot``."
msgstr "从现在开始，本教程将假设您将源放入``C:\\ godot``。"

#: ../../docs/development/compiling/compiling_for_windows.rst:92
msgid ""
"SCons will not be able out of the box to compile from the Windows Command "
"Prompt (``cmd.exe``) because SCons and Visual C++ compiler will not be able "
"to locate environment variables and executables they need for compilation."
msgstr ""
"从Windows命令提示符(``cmd.exe``)编译SCons将无法开箱即用，因为SCons和Visual C+"
"+编译器将无法找到编译所需的环境变量和可执行文件。"

#: ../../docs/development/compiling/compiling_for_windows.rst:97
msgid ""
"Therefore, you need to start a Visual Studio command prompt. It sets up "
"environment variables needed by SCons to locate the compiler. It should be "
"called similar to one of the below names (for your respective version of "
"Visual Studio):"
msgstr ""
"因此，您需要启动Visual Studio命令提示符。 它设置SCons定位编译器所需的环境变"
"量。 它应该被称为类似于以下名称之一(对于您的各自版本的Visual Studio):"

#: ../../docs/development/compiling/compiling_for_windows.rst:102
msgid "\"Developer Command Prompt for VS2013\""
msgstr "“VS2013的开发人员命令提示符”"

#: ../../docs/development/compiling/compiling_for_windows.rst:103
msgid "\"VS2013 x64 Native Tools Command Prompt\""
msgstr "“VS2013 x64 Native Tools命令提示符”"

#: ../../docs/development/compiling/compiling_for_windows.rst:104
msgid "\"VS2013 x86 Native Tools Command Prompt\""
msgstr "“VS2013 x86 Native Tools命令提示符”"

#: ../../docs/development/compiling/compiling_for_windows.rst:105
msgid "\"VS2013 x64 Cross Tools Command Prompt\""
msgstr "“VS2013 x64交叉工具命令提示”"

#: ../../docs/development/compiling/compiling_for_windows.rst:106
msgid "\"VS2013 x86 Cross Tools Command Prompt\""
msgstr "“VS2013 x86交叉工具命令提示”"

#: ../../docs/development/compiling/compiling_for_windows.rst:108
msgid ""
"You should be able to find at least the Developer Command Prompt for your "
"version of Visual Studio in your start menu."
msgstr ""
"您应该能够在开始菜单中找到至少适用于您的Visual Studio版本的开发人员命令提示"
"符。"

#: ../../docs/development/compiling/compiling_for_windows.rst:111
msgid ""
"However Visual Studio sometimes seems to not install some of the above "
"shortcuts, except the Developer Console at these locations that are "
"automatically searched by the start menu search option:"
msgstr ""
"但是Visual Studio有时似乎没有安装上述某些快捷方式，除了开发菜单搜索选项自动搜"
"索的这些位置的开发者控制台:"

#: ../../docs/development/compiling/compiling_for_windows.rst:121
msgid ""
"If you found the Developer Console, it will do for now to create a 32-bit "
"version of Godot, but if you want the 64-bit version, you might need to "
"setup the prompts manually for easy access."
msgstr ""
"如果您找到了Developer Console，它现在将创建一个32位版本的Godot，但如果您需要"
"64位版本，则可能需要手动设置提示以便于访问。"

#: ../../docs/development/compiling/compiling_for_windows.rst:125
msgid ""
"If you don't see some of the shortcuts, \"How the prompts actually work\" "
"section below will explain how to setup these prompts if you need them."
msgstr ""
"如果您没有看到某些快捷方式，“下面的提示如何实际工作”部分将说明如何在需要时设"
"置这些提示。"

#: ../../docs/development/compiling/compiling_for_windows.rst:129
msgid "About the Developer/Tools Command Prompts and the Visual C++ compiler"
msgstr "关于Developer / Tools命令提示符和Visual C++编译器"

#: ../../docs/development/compiling/compiling_for_windows.rst:131
msgid ""
"There is a few things you need to know about these consoles and the Visual C+"
"+ compiler."
msgstr "关于这些控制台和Visual C++编译器，您需要了解一些事项。"

#: ../../docs/development/compiling/compiling_for_windows.rst:134
msgid ""
"Your Visual Studio installation will ship with several Visual C++ compilers, "
"them being more or less identical, however each ``cl.exe`` (Visual C++ "
"compiler) will compile Godot for a different architecture (32-bit x86 or 64-"
"bit x86; the ARM compiler is not supported)."
msgstr ""
"您的Visual Studio安装将附带几个Visual C++编译器，它们或多或少相同，但每个 "
"``cl.exe`` (Visual C++编译器)将为不同的架构(32位x86或64位x86)编译Godot ;不支"
"持ARM编译器)。"

#: ../../docs/development/compiling/compiling_for_windows.rst:139
msgid ""
"The **Developer Command Prompt** will build a 32-bit version of Godot by "
"using the 32-bit Visual C++ compiler."
msgstr ""
"** Developer Command Prompt **将使用32位Visual C++编译器构建32位版本的Godot。"

#: ../../docs/development/compiling/compiling_for_windows.rst:142
msgid ""
"**Native Tools** Prompts (mentioned above) are used when you want the 32-bit "
"cl.exe to compile a 32-bit executable (x86 Native Tools Command Prompt). For "
"the 64-bit cl.exe, it will compile a 64-bit executable (x64 Native Tools "
"Command Prompt)."
msgstr ""
"**本机工具**当您希望32位cl.exe编译32位可执行文件(x86 Native Tools命令提示符)"
"时，将使用提示(如上所述)。 对于64位cl.exe，它将编译64位可执行文件(x64 Native "
"Tools命令提示符)。"

#: ../../docs/development/compiling/compiling_for_windows.rst:147
msgid ""
"The **Cross Tools** are used when your Windows is using one architecture (32-"
"bit, for example) and you need to compile to a different architecture (64-"
"bit). As you might be familiar, 32-bit Windows can not run 64-bit "
"executables, but you still might need to compile for them."
msgstr ""
"当您的Windows使用一种体系结构(例如32位)并且需要编译为不同的体系结构(64位)时，"
"将使用** Cross Tools **。 您可能已经熟悉，32位Windows无法运行64位可执行文件，"
"但您仍可能需要为它们进行编译。"

#: ../../docs/development/compiling/compiling_for_windows.rst:152
#: ../../docs/development/cpp/object_class.rst:134
msgid "For example:"
msgstr "例如:"

#: ../../docs/development/compiling/compiling_for_windows.rst:154
msgid ""
"\"VS2013 x64 Cross Tools Command Prompt\" will use a 32-bit cl.exe that will "
"compile a 64 bit application."
msgstr "“VS2013 x64交叉工具命令提示符”将使用将编译64位应用程序的32位cl.exe。"

#: ../../docs/development/compiling/compiling_for_windows.rst:157
msgid ""
"\"VS2013 x86 Cross Tools Command Prompt\" will use a 64-bit cl.exe that will "
"compile a 32-bit application. This one is useful if you are running a 32-bit "
"Windows."
msgstr ""
"“VS2013 x86交叉工具命令提示符”将使用将编译32位应用程序的64位cl.exe。 如果您运"
"行的是32位Windows，则此选项非常有用。"

#: ../../docs/development/compiling/compiling_for_windows.rst:161
msgid ""
"On a 64-bit Windows, you can run any of above prompts and compilers (``cl."
"exe`` executables) because 64-bit Windows can run any 32-bit application. 32-"
"bit Windows cannot run 64-bit executables, so the Visual Studio installer "
"won't even install shortcuts for some of these prompts."
msgstr ""
"在64位Windows上，您可以运行上述任何提示和编译器(``cl.exe``可执行文件)，因为64"
"位Windows可以运行任何32位应用程序。 32位Windows无法运行64位可执行文件，因此"
"Visual Studio安装程序甚至不会为某些提示安装快捷方式。"

#: ../../docs/development/compiling/compiling_for_windows.rst:167
msgid ""
"Note that you need to choose the **Developer Console** or the correct "
"**Tools Prompt** to build Godot for the correct architecture. Use only "
"Native Prompts if you are not sure yet what exactly Cross Compile Prompts do."
msgstr ""
"请注意，您需要选择** Developer Console **或正确的** Tools Prompt **来构建"
"Godot以获得正确的架构。 如果您还不确定Cross Compile Prompts究竟做了什么，请仅"
"使用Native Prempts。"

#: ../../docs/development/compiling/compiling_for_windows.rst:173
msgid "Running SCons"
msgstr "运行SCons"

#: ../../docs/development/compiling/compiling_for_windows.rst:175
msgid ""
"Once inside the **Developer Console/Tools Console Prompt**, go to the root "
"directory of the engine source code and type:"
msgstr ""
"进入** Developer Console / Tools Console Prompt **后，转到引擎源代码的根目录"
"并输入:"

#: ../../docs/development/compiling/compiling_for_windows.rst:182
msgid ""
"Tip: if you installed \"Pywin32 Python Extension\" you can append the -j "
"command to instruct SCons to run parallel builds like this:"
msgstr ""
"提示:如果您安装了“Pywin32 Python Extension”，您可以附加-j命令来指示SCons运行"
"这样的并行构建:"

#: ../../docs/development/compiling/compiling_for_windows.rst:189
msgid ""
"In general, it is OK to have at least as many threads compiling Godot as you "
"have cores in your CPU, if not one or two more. Feel free to add the -j "
"option to any SCons command you see below if you setup the \"Pywin32 Python "
"Extension\"."
msgstr ""
"一般情况下，如果不是一两个核心，那么至少可以在CPU中拥有与核心一样多的线程来编"
"译Godot。 如果您设置了“Pywin32 Python Extension”，请随意将-j选项添加到您在下"
"面看到的任何SCons命令中。"

#: ../../docs/development/compiling/compiling_for_windows.rst:194
msgid ""
"If all goes well, the resulting binary executable will be placed in ``C:"
"\\godot\\bin\\`` with the name of ``godot.windows.tools.32.exe`` or ``godot."
"windows.tools.64.exe``. SCons will automatically detect what compiler "
"architecture the environment (the prompt) is setup for and will build a "
"corresponding executable."
msgstr ""
"如果一切顺利，生成的二进制可执行文件将放在``C:\\ godot \\ bin \\``中，名称为"
"``godot.windows.tools.32.exe``或``godot.windows.tools。64.exe``。 SCons将自动"
"检测环境(提示)的设置编译器体系结构，并将构建相应的可执行文件。"

#: ../../docs/development/compiling/compiling_for_windows.rst:200
msgid ""
"This executable file contains the whole engine and runs without any "
"dependencies. Executing it will bring up the Project Manager."
msgstr ""
"此可执行文件包含整个引擎，并且运行时没有任何依赖性。 执行它将调出项目经理。"

#: ../../docs/development/compiling/compiling_for_windows.rst:203
#: ../../docs/development/compiling/compiling_for_x11.rst:111
msgid ""
"If you are compiling Godot for production use, then you can make the final "
"executable smaller and faster by adding the SCons option "
"``target=release_debug``."
msgstr ""
"如果您正在编译Godot用于生产用途，那么您可以通过添加SCons选项``target = "
"release_debug``来使最终的可执行文件更小更快。"

#: ../../docs/development/compiling/compiling_for_windows.rst:208
msgid "How the prompts actually work"
msgstr "提示如何实际工作"

#: ../../docs/development/compiling/compiling_for_windows.rst:210
msgid ""
"The Visual Studio command prompts are just shortcuts that call the standard "
"Command Prompt and have it run a batch file before giving  you control. The "
"batch file itself is called **vcvarsall.bat** and it sets up environment "
"variables, including the PATH variable, so that the correct version of the "
"compiler can be run. The Developer Command Prompt calls a different file "
"called **VsDevCmd.bat** but none of the other tools that this batch file "
"enables are needed by Godot/SCons."
msgstr ""
"Visual Studio命令提示只是调用标准命令提示符的快捷方式，并让它在您给予控制之前"
"运行批处理文件。 批处理文件本身称为** vcvarsall.bat **，它设置环境变量，包括"
"PATH变量，以便可以运行正确的编译器版本。 Developer Command Prompt调用另一个名"
"为** VsDevCmd.bat **的文件，但Godot / SCons不需要这个批处理文件启用的其他工"
"具。"

#: ../../docs/development/compiling/compiling_for_windows.rst:218
msgid ""
"Since you are probably using Visual Studio 2013 or 2015, if you need to "
"recreate them manually, use the below folders, or place them on the desktop/"
"taskbar:"
msgstr ""
"由于您可能正在使用Visual Studio 2013或2015，如果您需要手动重新创建它们，请使"
"用以下文件夹，或将它们放在桌面/任务栏上:"

#: ../../docs/development/compiling/compiling_for_windows.rst:227
msgid ""
"Start the creation of the shortcut by pressing the ``right mouse button/New/"
"Shortcut`` in an empty place in your desired location."
msgstr "在所需位置的空白处按“鼠标右键/新建/快捷方式”，开始创建快捷方式。"

#: ../../docs/development/compiling/compiling_for_windows.rst:230
msgid ""
"Then copy one of these commands below for the corresponding tool you need "
"into the \"Path\" and \"Name\" sections of the shortcut creation wizard, and "
"fix the path to the batch file if needed."
msgstr ""
"然后将以下这些命令之一复制到快捷方式创建向导的“路径”和“名称”部分中所需的相应"
"工具，并根据需要修复批处理文件的路径。"

#: ../../docs/development/compiling/compiling_for_windows.rst:234
msgid "Visual Studio 2013 is in the \"Microsoft Visual Studio 12.0\" folder."
msgstr "Visual Studio 2013位于“Microsoft Visual Studio 12.0”文件夹中。"

#: ../../docs/development/compiling/compiling_for_windows.rst:235
msgid "Visual Studio 2015 is in the \"Microsoft Visual Studio 14.0\" folder."
msgstr "Visual Studio 2015位于“Microsoft Visual Studio 14.0”文件夹中。"

#: ../../docs/development/compiling/compiling_for_windows.rst:236
msgid "etc."
msgstr "等等"

#: ../../docs/development/compiling/compiling_for_windows.rst:255
msgid ""
"After you create the shortcut, in the shortcut's properties, that you can "
"access by right clicking with your mouse on the shortcut itself, you can "
"choose the starting directory of the command prompt (\"Start in\" field)."
msgstr ""
"创建快捷方式后，在快捷方式的属性中，可以通过在快捷方式上单击鼠标右键来访问该"
"快捷方式，可以选择命令提示符的起始目录(“开始”字段)。"

#: ../../docs/development/compiling/compiling_for_windows.rst:260
msgid ""
"Some of these shortcuts (namely the 64-bit compilers) seem to not be "
"available in the Express edition of Visual Studio or Visual C++. Before "
"recreating the commands, make sure that ``cl.exe`` executables are present "
"in one of these locations, they are the actual compilers for the "
"architecture you want to build from the command prompt."
msgstr ""
"其中一些快捷方式(即64位编译器)似乎在Visual Studio或Visual C++的Express版本中"
"不可用。 在重新创建命令之前，请确保其中一个位置中存在“cl.exe”可执行文件，它们"
"是您要从命令提示符构建的体系结构的实际编译器。"

#: ../../docs/development/compiling/compiling_for_windows.rst:281
msgid ""
"In case you are wondering what these prompt shortcuts do, they call ``cmd."
"exe`` with the ``\\k`` option and have it run a Batch file."
msgstr ""
"如果您想知道这些提示快捷方式的作用，他们会使用``\\ k``选项调用``cmd.exe``并让"
"它运行批处理文件。"

#: ../../docs/development/compiling/compiling_for_windows.rst:293
msgid "How to run an automated build of Godot"
msgstr "如何运行Godot的自动构建"

#: ../../docs/development/compiling/compiling_for_windows.rst:295
msgid ""
"If you just need to run the compilation process via a Batch file or directly "
"in the Windows Command Prompt you need to use the following command:"
msgstr ""
"如果只需要通过批处理文件或直接在Windows命令提示符下运行编译过程，则需要使用以"
"下命令:"

#: ../../docs/development/compiling/compiling_for_windows.rst:303
msgid "with one of the following parameters:"
msgstr "使用以下参数之一:"

#: ../../docs/development/compiling/compiling_for_windows.rst:305
msgid "x86 (32-bit cl.exe to compile for the 32-bit architecture)"
msgstr "x86(32位cl.exe编译为32位架构)"

#: ../../docs/development/compiling/compiling_for_windows.rst:306
msgid "amd64 (64-bit cl.exe to compile for the 64-bit architecture)"
msgstr "amd64(为64位架构编译的64位cl.exe)"

#: ../../docs/development/compiling/compiling_for_windows.rst:307
msgid "x86_amd64 (32-bit cl.exe to compile for the 64-bit architecture)"
msgstr "x86_amd64(为64位架构编译的32位cl.exe)"

#: ../../docs/development/compiling/compiling_for_windows.rst:308
msgid "amd64_x86 (64-bit cl.exe to compile for the 32-bit architecture)"
msgstr "amd64_x86(为32位架构编译的64位cl.exe)"

#: ../../docs/development/compiling/compiling_for_windows.rst:310
msgid "and after that one, you can run SCons:"
msgstr "在那之后，您可以运行SCons:"

#: ../../docs/development/compiling/compiling_for_windows.rst:316
msgid "or you can run them together:"
msgstr "或者您可以一起运行它们:"

#: ../../docs/development/compiling/compiling_for_windows.rst:327
msgid "Development in Visual Studio or other IDEs"
msgstr "在Visual Studio或其他IDE中进行开发"

#: ../../docs/development/compiling/compiling_for_windows.rst:329
msgid ""
"For most projects, using only scripting is enough but when development in C+"
"+ is needed, for creating modules or extending the engine, working with an "
"IDE is usually desirable."
msgstr ""
"对于大多数项目，只使用脚本就足够了，但是当需要C++开发时，为了创建模块或扩展引"
"擎，通常需要使用IDE。"

#: ../../docs/development/compiling/compiling_for_windows.rst:333
msgid ""
"You can create a Visual Studio solution via SCons by running SCons with the "
"``vsproj=yes`` parameter, like this:"
msgstr ""
"您可以通过使用``vsproj = yes``参数运行SCons来创建Visual Studio解决方案，如下"
"所示:"

#: ../../docs/development/compiling/compiling_for_windows.rst:340
msgid ""
"You will be able to open Godot's source in a Visual Studio solution now, and "
"able to build Godot via the Visual Studio **Build** button. However, make "
"sure that you have installed Pywin32 so that parallel (-j) builds work "
"properly."
msgstr ""
"您现在可以在Visual Studio解决方案中打开Godot的源代码，并能够通过Visual "
"Studio ** Build **按钮构建Godot。 但是，请确保已安装Pywin32，以便并行(-j)构建"
"正常工作。"

#: ../../docs/development/compiling/compiling_for_windows.rst:345
msgid ""
"If you need to edit the compilation commands, they are located in \"Godot\" "
"project settings, NMAKE sheet. SCons is called at the end of the commands. "
"If you make a mistake, copy the command from one of the other build "
"configurations (debug, release_debug, release) or architectures (Win32/x64). "
"They are equivalent."
msgstr ""
"如果需要编辑编译命令，它们位于“Godot”项目设置，NMAKE表中。 在命令结束时调用"
"SCons。 如果出错，请从其他构建配置(debug，release_debug，release)或体系结构"
"(Win32 / x64)中复制命令。 它们是等价的。"

#: ../../docs/development/compiling/compiling_for_windows.rst:352
msgid "Cross-compiling for Windows from other operating systems"
msgstr "从其他操作系统交叉编译Windows"

#: ../../docs/development/compiling/compiling_for_windows.rst:354
msgid ""
"If you are a Linux or macOS user, you need to install `MinGW-w64 <https://"
"mingw-w64.org/doku.php>`_, which typically comes in 32-bit and 64-bit "
"variants. The package names may differ based on your distro, here are some "
"known ones:"
msgstr ""
"如果您是Linux或macOS用户，则需要安装`MinGW-w64 <https://mingw-w64.org/doku."
"php>`_ ，它通常包含32位和64位变体。 包名称可能因您的发行版而异，以下是一些已"
"知的发行版:"

#: ../../docs/development/compiling/compiling_for_windows.rst:359
#: ../../docs/development/compiling/compiling_for_x11.rst:33
msgid "**Arch**"
msgstr "**Arch**"

#: ../../docs/development/compiling/compiling_for_windows.rst:363
#: ../../docs/development/compiling/compiling_for_x11.rst:37
msgid "**Debian** / **Ubuntu**"
msgstr "**Debian** / **Ubuntu**"

#: ../../docs/development/compiling/compiling_for_windows.rst:367
#: ../../docs/development/compiling/compiling_for_x11.rst:43
msgid "**Fedora**"
msgstr "**Fedora**"

#: ../../docs/development/compiling/compiling_for_windows.rst:371
msgid "**macOS**"
msgstr "**macOS**"

#: ../../docs/development/compiling/compiling_for_windows.rst:375
#: ../../docs/development/compiling/compiling_for_x11.rst:60
msgid "**Mageia**"
msgstr "**Mageia**"

#: ../../docs/development/compiling/compiling_for_windows.rst:380
msgid ""
"Before allowing you to attempt the compilation, SCons will check for the "
"following binaries in your ``$PATH``:"
msgstr "在允许您尝试编译之前，SCons将在您的``$ PATH``中检查以下二进制文件:"

#: ../../docs/development/compiling/compiling_for_windows.rst:388
msgid ""
"If the binaries are not located in the ``$PATH`` (e.g. ``/usr/bin``), you "
"can define the following environment variables to give a hint to the build "
"system:"
msgstr ""
"如果二进制文件不在``$ PATH``中(例如``/ usr / bin``)，您可以定义以下环境变量来"
"给构建系统一个提示:"

#: ../../docs/development/compiling/compiling_for_windows.rst:397
msgid ""
"To make sure you are doing things correctly, executing the following in the "
"shell should result in a working compiler (the version output may differ "
"based on your system):"
msgstr ""
"为了确保您正确地执行操作，在shell中执行以下操作应该会生成一个正常工作的编译器"
"(版本输出可能因您的系统而异):"

#: ../../docs/development/compiling/compiling_for_windows.rst:407
#: ../../docs/development/compiling/compiling_for_android.rst:181
#: ../../docs/development/cpp/creating_android_modules.rst:335
msgid "Troubleshooting"
msgstr "故障排除"

#: ../../docs/development/compiling/compiling_for_windows.rst:409
msgid ""
"Cross-compiling from some versions of Ubuntu may lead to `this bug <https://"
"github.com/godotengine/godot/issues/9258>`_, due to a default configuration "
"lacking support for POSIX threading."
msgstr ""
"某些版本的Ubuntu的交叉编译可能会导致 `此错误 <https://github.com/godotengine/"
"godot/issues/9258>`_ ，因为默认配置缺乏对POSIX线程的支持。"

#: ../../docs/development/compiling/compiling_for_windows.rst:412
msgid ""
"You can change that configuration following those instructions, for 32-bit:"
msgstr "您可以按照这些说明更改该配置，对于32位:"

#: ../../docs/development/compiling/compiling_for_windows.rst:422
msgid "And for 64-bit:"
msgstr "而对于64位:"

#: ../../docs/development/compiling/compiling_for_windows.rst:432
msgid "Creating Windows export templates"
msgstr "创建Windows导出模板"

#: ../../docs/development/compiling/compiling_for_windows.rst:434
msgid ""
"Windows export templates are created by compiling Godot as release, with the "
"following flags:"
msgstr "Windows导出模板是通过将Godot编译为release来创建的，具有以下标志:"

#: ../../docs/development/compiling/compiling_for_windows.rst:437
msgid "(using Mingw32 command prompt, using the bits parameter)"
msgstr "(使用Mingw32命令提示符，使用bits参数)"

#: ../../docs/development/compiling/compiling_for_windows.rst:444
msgid "(using Mingw-w64 command prompt, using the bits parameter)"
msgstr "(使用Mingw-w64命令提示符，使用bits参数)"

#: ../../docs/development/compiling/compiling_for_windows.rst:451
msgid ""
"(using the Visual Studio command prompts for the correct architecture, "
"notice the lack of bits parameter)"
msgstr "(使用Visual Studio命令提示正确的体系结构，注意缺少bits参数)"

#: ../../docs/development/compiling/compiling_for_windows.rst:459
msgid "If you plan on replacing the standard templates, copy these to:"
msgstr "如果您打算更换标准模板，请将这些模板复制到:"

#: ../../docs/development/compiling/compiling_for_windows.rst:465
msgid "With the following names:"
msgstr "使用以下名称:"

#: ../../docs/development/compiling/compiling_for_windows.rst:474
#: ../../docs/development/compiling/compiling_for_x11.rst:153
msgid ""
"However, if you are writing your custom modules or custom C++ code, you "
"might instead want to configure your binaries as custom export templates "
"here:"
msgstr ""
"此外，如果您正在开发自定义模块或修改引擎的其他 C++ 代码，则可以在此处将您编译"
"好的二进制文件配置为自定义导出模板:"

#: ../../docs/development/compiling/compiling_for_windows.rst:480
msgid ""
"You don't even need to copy them, you can just reference the resulting files "
"in the ``bin\\`` directory of your Godot source folder, so the next time you "
"build you automatically have the custom templates referenced."
msgstr ""
"您甚至不需要复制它们，您只需要在Godot源文件夹的``bin \\``目录中引用结果文件，"
"这样您下次构建时就会自动引用自定义模板。"

#: ../../docs/development/compiling/compiling_for_x11.rst:4
msgid "Compiling for X11 (Linux, \\*BSD)"
msgstr "为X11平台编译(Linux、 *BSD操作系统)"

#: ../../docs/development/compiling/compiling_for_x11.rst:11
#: ../../docs/development/compiling/compiling_for_osx.rst:11
msgid ""
"For compiling under Linux or other Unix variants, the following is required:"
msgstr ""
"要在 Linux 或者其他类 Unix 操作系统上编译 Godot , 您需要准备以下软件和开源库:"

#: ../../docs/development/compiling/compiling_for_x11.rst:14
msgid "GCC or Clang"
msgstr "GCC 或者 Clang 编译器"

#: ../../docs/development/compiling/compiling_for_x11.rst:15
msgid "Python 2.7+ (Python 3 only supported as of SCons 3.0)"
msgstr "Python 2.7 或更高版本(Python 3的话需要安装 Scons 3.0以上版本)"

#: ../../docs/development/compiling/compiling_for_x11.rst:16
#: ../../docs/development/compiling/compiling_for_osx.rst:15
msgid "SCons build system"
msgstr "Scons 构建系统"

#: ../../docs/development/compiling/compiling_for_x11.rst:17
msgid "pkg-config (used to detect the dependencies below)"
msgstr "pkg-config (用于检测下面这些依赖库)"

#: ../../docs/development/compiling/compiling_for_x11.rst:18
msgid "X11, Xcursor, Xinerama, Xi and XRandR development libraries"
msgstr "X11 、Xcursor 、 Xinerama 、 Xi 、XRandR 这些 X11 平台的开发依赖库"

#: ../../docs/development/compiling/compiling_for_x11.rst:19
msgid "MesaGL development libraries"
msgstr "MesaGL开发库"

#: ../../docs/development/compiling/compiling_for_x11.rst:20
msgid "ALSA development libraries"
msgstr "ALSA开发库"

#: ../../docs/development/compiling/compiling_for_x11.rst:21
msgid "PulseAudio development libraries (for sound support)"
msgstr "PulseAudio 开发依赖库(用于音效支持)"

#: ../../docs/development/compiling/compiling_for_x11.rst:22
msgid "Freetype (for the editor)"
msgstr "Freetype (编辑器需要)"

#: ../../docs/development/compiling/compiling_for_x11.rst:23
msgid "OpenSSL (for HTTPS and TLS)"
msgstr "OpenSSL (用于 HTTPS 和 TLS 功能的实现)"

#: ../../docs/development/compiling/compiling_for_x11.rst:24
msgid "*Optional* - libudev (build with ``udev=yes``)"
msgstr "*可选* - libudev(使用``udev = yes``构建)"

#: ../../docs/development/compiling/compiling_for_x11.rst:25
#: ../../docs/development/compiling/compiling_for_osx.rst:17
msgid "*Optional* - yasm (for WebM SIMD optimizations)"
msgstr "*可选* - yasm(用于WebM SIMD优化)"

#: ../../docs/development/compiling/compiling_for_x11.rst:31
msgid "Distro-specific oneliners"
msgstr "各个发型版的安装指令"

#: ../../docs/development/compiling/compiling_for_x11.rst:49
msgid "**FreeBSD**"
msgstr "**FreeBSD**"

#: ../../docs/development/compiling/compiling_for_x11.rst:54
msgid "**Gentoo**"
msgstr "**Gentoo**"

#: ../../docs/development/compiling/compiling_for_x11.rst:66
msgid "**OpenBSD**"
msgstr "**OpenBSD**"

#: ../../docs/development/compiling/compiling_for_x11.rst:70
msgid "**openSUSE**"
msgstr "**openSUSE**"

#: ../../docs/development/compiling/compiling_for_x11.rst:76
msgid "**Solus**"
msgstr "**Solus**"

#: ../../docs/development/compiling/compiling_for_x11.rst:85
#: ../../docs/development/compiling/compiling_for_osx.rst:25
msgid ""
"Start a terminal, go to the root dir of the engine source code and type:"
msgstr "启动终端，然后进入引擎源代码的根目录。键入下面的指令:"

#: ../../docs/development/compiling/compiling_for_x11.rst:91
msgid ""
"A good rule of thumb for the ``-j`` (*jobs*) flag, is to have at least as "
"many threads compiling Godot as you have cores in your CPU, if not one or "
"two more. Feel free to add the ``-j`` option to any SCons command you see "
"below."
msgstr ""
"`-j``(* jobs *)标志的一个好的经验法则是，至少有多少线程编译Godot，就像您的CPU"
"中有核心一样，如果不是一两个。 随意将 ``-j`` 选项添加到您在下面看到的任何"
"SCons命令。"

#: ../../docs/development/compiling/compiling_for_x11.rst:95
#: ../../docs/development/compiling/compiling_for_osx.rst:31
msgid ""
"If all goes well, the resulting binary executable will be placed in the \"bin"
"\" subdirectory. This executable file contains the whole engine and runs "
"without any dependencies. Executing it will bring up the project manager."
msgstr ""
"如果一切顺利，编译结果将存放在 ``bin`` 目录下。 这个可执行文件包含了整个引"
"擎，无需任何依赖项。 执行它将会启动项目管理器。"

#: ../../docs/development/compiling/compiling_for_x11.rst:102
msgid "If you wish to compile using Clang rather than GCC, use this command:"
msgstr "如果您希望使用 Clang 而不是 GCC 编译器， 可以使用这个命令:"

#: ../../docs/development/compiling/compiling_for_x11.rst:108
msgid ""
"Using Clang appears to be a requirement for OpenBSD, otherwise fonts would "
"not build."
msgstr ""
"在 OpenBSD 平台上必须使用 Clang，否则在构建字体相关的依赖时会遇到一些麻烦。"

#: ../../docs/development/compiling/compiling_for_x11.rst:116
#: ../../docs/development/compiling/compiling_for_web.rst:23
msgid "Building export templates"
msgstr "构建导出模板"

#: ../../docs/development/compiling/compiling_for_x11.rst:118
msgid ""
"To build X11 (Linux, \\*BSD) export templates, run the build system with the "
"following parameters:"
msgstr ""
"要构建 X11 (Linux，\\*BSD)平台的导出模板， 执行构建系统时需要带上这些参数:"

#: ../../docs/development/compiling/compiling_for_x11.rst:121
msgid "(32 bits)"
msgstr "( 32 位 )"

#: ../../docs/development/compiling/compiling_for_x11.rst:128
msgid "(64 bits)"
msgstr "( 64 位 )"

#: ../../docs/development/compiling/compiling_for_x11.rst:135
msgid ""
"Note that cross compiling for the opposite bits (64/32) as your host "
"platform is not always straight-forward and might need a chroot environment."
msgstr ""
"请注意，跨CPU位数( 64/32)编译不总是这样直截了当，这可能还需要您通过 "
"``chroot`` 切换编译环境。"

#: ../../docs/development/compiling/compiling_for_x11.rst:138
msgid ""
"To create standard export templates, the resulting files must be copied to:"
msgstr "要创建导出模板，需要您手动把编译出来的二进制文件拷贝到这里:"

#: ../../docs/development/compiling/compiling_for_x11.rst:144
msgid ""
"and named like this (even for \\*BSD which is seen as \"Linux X11\" by "
"Godot):"
msgstr ""
"并且还需要将文件命名成这样(在 Godot 中， \\*BSD 平台也被视为 \"Linux X11\"):"

#: ../../docs/development/compiling/compiling_for_x11.rst:159
msgid ""
"You don't even need to copy them, you can just reference the resulting files "
"in the bin/ directory of your Godot source folder, so the next time you "
"build you automatically have the custom templates referenced."
msgstr ""
"这样，您就您不必拷贝他们了。您可以直接把自定义模板的可执行文件指向您在 bin/ "
"下面构建好的二进制文件， 下一次您再修改引擎就不需要做任何配置了。"

#: ../../docs/development/compiling/compiling_for_osx.rst:4
msgid "Compiling for macOS"
msgstr "为macOS平台编译"

#: ../../docs/development/compiling/compiling_for_osx.rst:14
msgid "Python 2.7+ or Python 3.5+"
msgstr "Python 2.7+或Python 3.5+"

#: ../../docs/development/compiling/compiling_for_osx.rst:16
msgid "Xcode (or the more lightweight Command Line Tools for Xcode)"
msgstr "或者更轻量的Command Line Tools for Xcode"

#: ../../docs/development/compiling/compiling_for_osx.rst:36
msgid ""
"To create an .app like in the official builds, you need to use the template "
"located in ``misc/dist/osx_tools.app``. Typically, for a \".64\" optimised "
"binary built with `scons p=osx target=release_debug`:"
msgstr ""
"如果想创建和官方编译的.app一样的程序，您可以通过位于``misc/dist/osx_tools."
"app``的模版来做。像这样一个为“.64”优化的二进制程序的构建(scons p=osx "
"target=release_debug)，通常这么做:"

#: ../../docs/development/compiling/compiling_for_osx.rst:48
msgid "Compiling for 32 and 64-bit"
msgstr "同时为32位和64位编译"

#: ../../docs/development/compiling/compiling_for_osx.rst:50
msgid ""
"All macOS versions after 10.6 are 64-bit exclusive, so the executable will "
"be a \".64\" file by default for most users. If you would like to compile a "
"\".fat\" executable which contains both 32 and 64-bit code, you can do so by "
"specifying the bits in the scons command like so:"
msgstr ""
"10.6之后的所有macOS版本都是64位独占的，因此对于大多数用户来说，可执行文件默认"
"为“.64”的。如果要编译同时包含32位和64位代码的“.fat”可执行文件，可以通过在"
"scons命令中指定位设定来实现，如下所示:"

#: ../../docs/development/compiling/compiling_for_osx.rst:60
msgid "Cross-compiling"
msgstr "交叉编译"

#: ../../docs/development/compiling/compiling_for_osx.rst:62
msgid ""
"It is possible to compile for macOS in a Linux environment (and maybe also "
"in Windows with Cygwin). For that you will need `OSXCross <https://github."
"com/tpoechtrager/osxcross>`__ to be able to use macOS as target. First, "
"follow the instructions to install it:"
msgstr ""
"可以在Linux环境中编译macOS(也可能在带有Cygwin的Windows中)。 为此，您需要"
"`OSXCross <https://github.com/tpoechtrager/osxcross>`__才能使用macOS作为目"
"标。 首先，按照说明安装它:"

#: ../../docs/development/compiling/compiling_for_osx.rst:67
msgid ""
"Clone the `OSXCross repository <https://github.com/tpoechtrager/osxcross>` "
"somewhere on your machine (or download a zip file and extract it somewhere), "
"e.g.:"
msgstr ""
"在您机器的某个地方克隆 `OSXCross存储库 <https://github.com/tpoechtrager/"
"osxcross>` (或下载一个zip文件并将其解压缩到某处)，例如:"

#: ../../docs/development/compiling/compiling_for_osx.rst:75
msgid ""
"Follow the instructions to package the SDK: https://github.com/tpoechtrager/"
"osxcross#packaging-the-sdk"
msgstr ""
"按照说明打包SDK:https://github.com/tpoechtrager/osxcross#packaging-the-sdk"

#: ../../docs/development/compiling/compiling_for_osx.rst:77
msgid ""
"Follow the instructions to install OSXCross: https://github.com/tpoechtrager/"
"osxcross#installation"
msgstr ""
"按照说明安装OSXCross:https://github.com/tpoechtrager/osxcross#installation"

#: ../../docs/development/compiling/compiling_for_osx.rst:80
msgid ""
"After that, you will need to define the ``OSXCROSS_ROOT`` as the path to the "
"OSXCross installation (the same place where you cloned the repository/"
"extracted the zip), e.g.:"
msgstr ""
"之后，您需要将 ``OSXCROSS_ROOT`` 定义为OSXCross安装的路径(您克隆存储库/提取"
"zip的位置)，例如:"

#: ../../docs/development/compiling/compiling_for_osx.rst:88
msgid "Now you can compile with SCons like you normally would:"
msgstr "现在您可以像通常那样使用SCons进行编译:"

#: ../../docs/development/compiling/compiling_for_osx.rst:94
msgid ""
"If you have an OSXCross SDK version different from the one expected by the "
"SCons buildsystem, you can specify a custom one with the ``osxcross_sdk`` "
"argument:"
msgstr ""
"如果您的OSXCross SDK版本与SCons构建系统所期望的版本不同，您可以使用 "
"``osxcross_sdk`` 参数指定自定义版本:"

#: ../../docs/development/compiling/compiling_for_android.rst:4
msgid "Compiling for Android"
msgstr "为Android平台编译"

#: ../../docs/development/compiling/compiling_for_android.rst:11
msgid ""
"In most cases, using the built-in deployer and export templates is good "
"enough. Compiling the Android APK manually is mostly useful for custom "
"builds or custom packages for the deployer."
msgstr ""
"对于大多数情况，使用内置部署程序和导出模板就足够了。 手动编译Android APK对于"
"部署者的自定义构建或自定义程序包非常有用。"

#: ../../docs/development/compiling/compiling_for_android.rst:15
msgid ""
"Also, you still need to follow the steps mentioned in the :ref:"
"`doc_exporting_for_android` tutorial before attempting to build a custom "
"export template."
msgstr ""
"此外，在尝试自定义导出模板之前，您仍需要执行 :ref:"
"`doc_exporting_for_android` 教程中提到的所有步骤。"

#: ../../docs/development/compiling/compiling_for_android.rst:22
msgid "For compiling under Windows, Linux or macOS, the following is required:"
msgstr "要在Windows，Linux或macOS下进行编译，需要以下内容:"

#: ../../docs/development/compiling/compiling_for_android.rst:24
msgid "`Python 2.7+ or Python 3.5+ <https://www.python.org/downloads/>`_"
msgstr "`Python 2.7+或Python 3.5+ <https://www.python.org/downloads/>`__"

#: ../../docs/development/compiling/compiling_for_android.rst:25
msgid "`SCons <https://scons.org/pages/download.html>`_ build system"
msgstr "`SCons <https://www.scons.org>`__构建系统"

#: ../../docs/development/compiling/compiling_for_android.rst:26
msgid ""
"`Android SDK <https://developer.android.com/studio/#command-tools>`_ "
"(command-line tools are sufficient)"
msgstr "Android SDK: https://developer.android.com/studio/"

#: ../../docs/development/compiling/compiling_for_android.rst:28
msgid ""
"Required SDK components will be automatically installed by Gradle (except "
"the NDK)"
msgstr "Gradle将自动安装所需的SDK组件(NDK除外)"

#: ../../docs/development/compiling/compiling_for_android.rst:30
msgid ""
"`Android NDK <https://developer.android.com/ndk/downloads/>`_ r17 or later"
msgstr "Android SDK: https://developer.android.com/studio/"

#: ../../docs/development/compiling/compiling_for_android.rst:31
msgid "Gradle (will be downloaded and installed automatically if missing)"
msgstr "Gradle(如果遗失，将自动下载并安装)"

#: ../../docs/development/compiling/compiling_for_android.rst:32
msgid "JDK 8 (either OpenJDK or Oracle JDK)"
msgstr "安装OpenJDK或Oracle JDK"

#: ../../docs/development/compiling/compiling_for_android.rst:34
msgid "JDK 9 or later are not currently supported"
msgstr "目前不支持JDK 9或更高版本"

#: ../../docs/development/compiling/compiling_for_android.rst:35
msgid ""
"You can download a build from `ojdkbuild <https://github.com/ojdkbuild/"
"ojdkbuild>`_"
msgstr ""
"您可以从 `ojdkbuild <https://github.com/ojdkbuild/ojdkbuild>`_ 下载一个版本"

#: ../../docs/development/compiling/compiling_for_android.rst:41
msgid "Setting up the buildsystem"
msgstr "设置构建系统"

#: ../../docs/development/compiling/compiling_for_android.rst:43
msgid ""
"Set the environment variable ``ANDROID_HOME`` to point to the Android SDK. "
"If you downloaded the Android command-line tools, this would be the folder "
"where you extracted the contents of the ZIP archive. Later on, ``gradlew`` "
"will install necessary SDK components in this folder. However, you need to "
"accept the SDK component licenses before they can be downloaded by Gradle. "
"This can be done by running the following command from the root of the SDK "
"directory, then answering all the prompts with ``y``:"
msgstr ""
"将环境变量 ``ANDROID_HOME`` 设置为指向Android SDK。如果您下载了Android命令行"
"工具，那么这将是您解压缩ZIP存档内容的文件夹。稍后， ``gradlew`` 将在此文件夹"
"中安装必要的SDK组件。但是，您需要接受SDK组件许可证才能通过Gradle下载。这可以"
"通过从SDK目录的根目录运行以下命令，然后用 ``y`` 回答所有提示来完成:"

#: ../../docs/development/compiling/compiling_for_android.rst:57
msgid ""
"Set the environment variable ``ANDROID_NDK_ROOT`` to point to the Android "
"NDK. You also might need to set the variable ``ANDROID_NDK_HOME`` to the "
"same path, especially if you are using custom Android modules, since some "
"Gradle plugins rely on the NDK and use this variable to determine its "
"location."
msgstr ""

#: ../../docs/development/compiling/compiling_for_android.rst:63
msgid ""
"To set those environment variables on Windows, press **Windows + R**, type "
"\"control system\", then click on **Advanced system settings** in the left "
"pane, then click on **Environment variables** on the window that appears."
msgstr ""
"要在Windows上设置这些环境变量，请按Windows + R，键入“control system”，然后单"
"击左窗格中的 **高级系统设置** ，然后在出现的窗口中单击 **环境变量** 。"

#: ../../docs/development/compiling/compiling_for_android.rst:68
msgid ""
"To set those environment variables on Linux or macOS, use ``export "
"ANDROID_HOME=/path/to/android-sdk`` and ``export ANDROID_NDK_ROOT=/path/to/"
"android-ndk`` where ``/path/to/android-sdk`` and ``/path/to/android-ndk`` "
"point to the root of the SDK and NDK directories."
msgstr ""
"要在Unix上设置这些环境变量(例如Linux，macOS)，请使用``export ANDROID_HOME "
"= / path / to / android-sdk``和``export ANDROID_NDK_ROOT = / path / to / "
"android-ndk``。 / path / to / android-sdk和/ path / to / android-ndk是"
"Android SDK和Android NDK放置在PC上的路径。"

#: ../../docs/development/compiling/compiling_for_android.rst:75
msgid "Building the export templates"
msgstr "构建导出模板"

#: ../../docs/development/compiling/compiling_for_android.rst:77
msgid ""
"Godot needs two export templates for Android: the optimized \"release\" "
"template (``android_release.apk``) and the debug template (``android_debug."
"apk``). As Google will require all APKs to include ARMv8 (64-bit) libraries "
"starting from August 2019, the commands below will build an APK containing "
"both ARMv7 and ARMv8 libraries."
msgstr ""
"Godot需要两个Android导出模板：优化的“发布”模板(``android_release.apk``)和调试"
"模板(``android_debug.apk``)。 由于Google将要求所有APK包含从2019年8月开始的"
"ARMv8(64位)库，因此以下命令将构建包含ARMv7和ARMv8库的APK。"

#: ../../docs/development/compiling/compiling_for_android.rst:83
msgid ""
"Compiling the standard export templates is done by calling SCons with the "
"following arguments:"
msgstr "Windows导出模板是通过将Godot编译为release来创建的，具有以下标志:"

#: ../../docs/development/compiling/compiling_for_android.rst:86
msgid ""
"Release template (used when exporting with **Debugging Enabled** unchecked)"
msgstr "发布模板(导出时使用“Debugging Enabled”OFF)"

#: ../../docs/development/compiling/compiling_for_android.rst:99
msgid "The resulting APK will be located at ``bin/android_release.apk``."
msgstr "生成的APK将位于``bin / android_release.apk``。"

#: ../../docs/development/compiling/compiling_for_android.rst:101
msgid "Debug template (used when exporting with **Debugging Enabled** checked)"
msgstr "调试模板(导出时使用“Debugging Enabled”ON)"

#: ../../docs/development/compiling/compiling_for_android.rst:114
msgid "The resulting APK will be located at ``bin/android_debug.apk``."
msgstr "生成的APK将位于``bin / android_debug.apk``。"

#: ../../docs/development/compiling/compiling_for_android.rst:117
msgid "Adding support for x86 devices"
msgstr "添加对x86设备的支持"

#: ../../docs/development/compiling/compiling_for_android.rst:119
msgid ""
"If you also want to include support for x86 devices, run the SCons command a "
"third time with the ``android_arch=x86`` argument before building the APK "
"with Gradle. For example, for the release template:"
msgstr ""
"如果您还想包含对x86设备的支持，请在使用Gradle构建APK之前再次使用"
"``android_arch = x86``参数运行scons命令。 例如，对于发布模板:"

#: ../../docs/development/compiling/compiling_for_android.rst:135
msgid ""
"This will create a fat binary that works on all platforms. The final APK "
"size of exported projects will depend on the platforms you choose to support "
"when exporting; in other words, unused platforms will be removed from the "
"APK."
msgstr ""
"这将创建一个适用于所有平台的胖二进制文件。导出项目的最终APK大小取决于您在导出"
"时选择支持的平台;换句话说，未使用的平台将从APK中删除。"

#: ../../docs/development/compiling/compiling_for_android.rst:141
msgid "Using the export templates"
msgstr "使用导出模板"

#: ../../docs/development/compiling/compiling_for_android.rst:143
msgid ""
"Godot needs release and debug APKs that were compiled against the same "
"version/commit as the editor. If you are using official binaries for the "
"editor, make sure to install the matching export templates, or build your "
"own from the same version."
msgstr ""
"作为Android的导出模板，Godot需要发布和调试根据与编辑器相同的版本/提交编译的"
"APK。 如果您使用官方二进制文件作为编辑器，请确保安装匹配的导出模板，或者从同"
"一版本构建自己的模板。"

#: ../../docs/development/compiling/compiling_for_android.rst:148
msgid ""
"When exporting your game, Godot opens the APK, changes a few things inside "
"and adds your files."
msgstr "导出游戏时，Godot会打开APK，更改内部的一些内容并添加您的文件。"

#: ../../docs/development/compiling/compiling_for_android.rst:152
msgid "Installing the templates"
msgstr "安装模板"

#: ../../docs/development/compiling/compiling_for_android.rst:154
msgid ""
"The newly-compiled templates (``android_debug.apk`` and ``android_release."
"apk``) must be copied to Godot's templates folder with their respective "
"names. The templates folder can be located in:"
msgstr ""
"必须将新编译的模板(android_debug.apk和android_release.apk)复制到Godot的模板文"
"件夹及其各自的名称。 templates文件夹可以位于:"

#: ../../docs/development/compiling/compiling_for_android.rst:158
msgid "Windows: ``%APPDATA%\\Godot\\templates\\<version>\\``"
msgstr "Windows: ``%APPDATA%\\Godot\\templates\\<version>\\``"

#: ../../docs/development/compiling/compiling_for_android.rst:159
msgid "Linux: ``$HOME/.local/share/godot/templates/<version>/``"
msgstr "Linux: ``$HOME/.local/share/godot/templates/<version>/``"

#: ../../docs/development/compiling/compiling_for_android.rst:160
msgid "macOS: ``$HOME/Library/Application Support/Godot/templates/<version>/``"
msgstr ""
"macOS: ``$HOME/Library/Application Support/Godot/templates/<version>/``"

#: ../../docs/development/compiling/compiling_for_android.rst:162
msgid ""
"``<version>`` is of the form ``major.minor[.patch].status`` using values "
"from ``version.py`` in your Godot source repository (e.g. ``3.0.5.stable`` "
"or ``3.1.dev``). You also need to write this same version string to a "
"``version.txt`` file located next to your export templates."
msgstr ""
"``[version]``的格式为``major.minor [.patch] .status``，使用Godot源代码库中 "
"``version.py`` 的值(例如``3.0.5.stable`` 或 ``3.1.dev`` )。 您还需要将相同的"
"版本字符串写入导出模板旁边的 ``version.txt`` 文件。"

#: ../../docs/development/compiling/compiling_for_android.rst:169
msgid ""
"However, if you are writing your custom modules or custom C++ code, you "
"might instead want to configure your APKs as custom export templates here:"
msgstr ""
"但是，如果您正在编写自定义模块或自定义C++代码，则可能需要将APK配置为自定义导"
"出模板:"

#: ../../docs/development/compiling/compiling_for_android.rst:175
msgid ""
"You don't even need to copy them, you can just reference the resulting file "
"in the ``bin\\`` directory of your Godot source folder, so that the next "
"time you build you will automatically have the custom templates referenced."
msgstr ""
"您甚至不需要复制它们，您可以在Godot源文件夹的``bin \\``目录中引用生成的文件，"
"这样下次构建时您将自动引用自定义模板。"

#: ../../docs/development/compiling/compiling_for_android.rst:184
msgid "Application not installed"
msgstr "应用程序未安装"

#: ../../docs/development/compiling/compiling_for_android.rst:186
msgid ""
"Android might complain the application is not correctly installed. If so:"
msgstr "Android可能会抱怨应用程序未正确安装。 如果是，请检查以下内容:"

#: ../../docs/development/compiling/compiling_for_android.rst:189
msgid "Check that the debug keystore is properly generated."
msgstr "检查是否正确生成了调试密钥库。"

#: ../../docs/development/compiling/compiling_for_android.rst:190
msgid "Check that the jarsigner executable is from JDK 8."
msgstr "检查jarsigner是否来自JDK8。"

#: ../../docs/development/compiling/compiling_for_android.rst:192
msgid ""
"If it still fails, open a command line and run `logcat <https://developer."
"android.com/studio/command-line/logcat>`_:"
msgstr ""
"如果仍然失败，请打开命令行并运行 `logcat <https://developer.android.com/"
"studio/command-line/logcat>`_ :"

#: ../../docs/development/compiling/compiling_for_android.rst:198
msgid ""
"Then check the output while the application is installed; the error message "
"should be presented there. Seek assistance if you can't figure it out."
msgstr "并在安装应用程序时检查输出。 应该在那里提出失败的原因。"

#: ../../docs/development/compiling/compiling_for_android.rst:203
msgid "Application exits immediately"
msgstr "申请立即退出"

#: ../../docs/development/compiling/compiling_for_android.rst:205
msgid ""
"If the application runs but exits immediately, this might be due to one of "
"the following reasons:"
msgstr "如果应用程序运行但立即退出，则可能是以下原因之一:"

#: ../../docs/development/compiling/compiling_for_android.rst:208
msgid ""
"Make sure to use export templates that match your editor version; if you use "
"a new Godot version, you *have* to update the templates too."
msgstr ""
"确保使用与编辑器版本匹配的导出模板; 如果您使用新的Godot版本，您* *也可以*更新"
"模板。"

#: ../../docs/development/compiling/compiling_for_android.rst:210
msgid ""
"``libgodot_android.so`` is not in ``libs/<android_arch>/`` where "
"``<android_arch>`` is the device's architecture."
msgstr ""
"``libgodot_android.so``不在``libs / <android_arch> /``中` ``<android_arch>`` "
"是设备的架构。"

#: ../../docs/development/compiling/compiling_for_android.rst:212
msgid ""
"The device's architecture does not match the exported one(s). Make sure your "
"templates were built for that device's architecture, and that the export "
"settings included support for that architecture."
msgstr ""
"设备的体系结构与导出的体系结构不匹配。确保您的模板是为该设备的体系结构构建"
"的，并且导出设置包括对该体系结构的支持。"

#: ../../docs/development/compiling/compiling_for_android.rst:216
msgid "In any case, ``adb logcat`` should also show the cause of the error."
msgstr "无论如何，``adb logcat``也应该显示错误的原因。"

#: ../../docs/development/compiling/compiling_for_ios.rst:4
msgid "Compiling for iOS"
msgstr "为iOS平台编译"

#: ../../docs/development/compiling/compiling_for_ios.rst:11
msgid ""
"SCons (you can get it from macports, you should be able to run ``scons`` in "
"a terminal when installed)"
msgstr ""
"SCons(您可以从macports获得它，您应该能够在安装时在终端中运行 ``scons`` )"

#: ../../docs/development/compiling/compiling_for_ios.rst:13
#, fuzzy
msgid ""
"Xcode 10.0 (or later) with the iOS (10.0) SDK and the command line tools."
msgstr "Xcode与iOS SDK和命令行工具。"

#: ../../docs/development/compiling/compiling_for_ios.rst:21
msgid "Open a Terminal, go to the root dir of the engine source code and type:"
msgstr "打开终端，转到引擎源代码的根目录并键入:"

#: ../../docs/development/compiling/compiling_for_ios.rst:27
msgid "for a debug build, or:"
msgstr "用于调试版本，或:"

#: ../../docs/development/compiling/compiling_for_ios.rst:33
msgid ""
"for a release build (check ``platform/iphone/detect.py`` for the compiler "
"flags used for each configuration)."
msgstr ""
"对于发布版本(检查``platform / iphone / detect.py``以获取用于每个配置的编译器"
"标志)。"

#: ../../docs/development/compiling/compiling_for_ios.rst:36
msgid "Alternatively, you can run"
msgstr "或者，您可以运行"

#: ../../docs/development/compiling/compiling_for_ios.rst:42
msgid "for a Simulator executable."
msgstr "用于模拟器可执行文件。"

#: ../../docs/development/compiling/compiling_for_ios.rst:44
#, fuzzy
msgid ""
"For recent devices, Apple requires 64-bit versions of application binaries "
"when you are uploading to the Apple Store. The best way to provide these is "
"to create a bundle in which there are both 32-bit and 64-bit binaries, so "
"every device will be able to run the game."
msgstr ""
"此外，由于Apple在上传到iStore时需要64位版本的应用程序二进制文件。 提供这些的"
"最好方法是创建一个包含32位和64位二进制文件的包，这样每个设备都可以运行游戏。 "
"它可以分三步完成，首先编译32位版本，然后编译64位版本，然后使用 ``lipo`` 将它"
"们捆绑成一个胖二进制文件，所有这些步骤都可以使用以下命令执行:"

#: ../../docs/development/compiling/compiling_for_ios.rst:47
msgid ""
"It can be done in three steps: first compile the 32-bit version, then "
"compile the 64-bit version and then use ``lipo`` to bundle them into one "
"\"universal\" binary. All those steps can be performed with following "
"commands:"
msgstr ""

#: ../../docs/development/compiling/compiling_for_ios.rst:56
msgid ""
"If you also want to provide a simulator build (reduces the chance of any "
"linker errors with dependencies), you'll need to build and lipo the "
"``x86_64`` architecture as well."
msgstr ""

#: ../../docs/development/compiling/compiling_for_ios.rst:66
msgid "Run"
msgstr "运行"

#: ../../docs/development/compiling/compiling_for_ios.rst:68
msgid ""
"To run on a device or simulator, follow these instructions: :ref:"
"`doc_exporting_for_ios`."
msgstr ""
"要在设备或模拟器上运行，请按照以下说明操作: :ref:`doc_exporting_for_ios`。"

#: ../../docs/development/compiling/compiling_for_ios.rst:71
msgid ""
"Replace or add your executable to the Xcode project, and change the "
"\"executable name\" property on Info.plist accordingly if you use an "
"alternative build."
msgstr ""
"将您的可执行文件替换或添加到Xcode项目，如果您使用替代版本，则相应地更改Info."
"plist上的“可执行文件名称”属性。"

#: ../../docs/development/compiling/cross-compiling_for_ios_on_linux.rst:4
msgid "Cross-compiling for iOS on Linux"
msgstr "在Linux平台上为iOS做交叉编译"

#: ../../docs/development/compiling/cross-compiling_for_ios_on_linux.rst:8
msgid ""
"The procedure for this is somewhat complex and requires a lot of steps, but "
"once you have the environment properly configured it will be easy to compile "
"Godot for iOS anytime you want."
msgstr ""
"这个过程有点复杂，需要很多步骤，但是一旦您正确配置了环境，就可以随时随地编译"
"Godot for iOS。"

#: ../../docs/development/compiling/cross-compiling_for_ios_on_linux.rst:13
msgid "Disclaimer"
msgstr "放弃"

#: ../../docs/development/compiling/cross-compiling_for_ios_on_linux.rst:15
msgid ""
"While it is possible to compile for iOS on a Linux environment, Apple is "
"very restrictive about the tools to be used (especially hardware-wise), "
"allowing pretty much only their products to be used for development. So this "
"is **not official**. However, a `statement from Apple in 2010 <http://www."
"apple.com/pr/library/2010/09/09Statement-by-Apple-on-App-Store-Review-"
"Guidelines.html>`__ says they relaxed some of the `App Store review "
"guidelines <https://developer.apple.com/app-store/review/guidelines/>`__ to "
"allow any tool to be used, as long as the resulting binary does not download "
"any code, which means it should be OK to use the procedure described here "
"and cross-compiling the binary."
msgstr ""
"虽然可以在Linux环境中为iOS编译，但Apple对使用的工具(特别是硬件方面)非常严格，"
"几乎只允许他们的产品用于开发。 所以这不是官方**。 然而，2010年苹果公司的 `声"
"明 <http://www.apple.com/pr/library/2010/09/09Statement-by-Apple-on-App-"
"Store-Review-Guidelines.html>`__表示放宽了一些 `App Store评论指南 <https://"
"developer.apple.com/app-store/review/guidelines/>`__以允许使用任何工具，只要"
"生成的二进制文件不下载任何代码 ，这意味着可以使用此处描述的过程并交叉编译二进"
"制文件。"

#: ../../docs/development/compiling/cross-compiling_for_ios_on_linux.rst:29
msgid ""
"`XCode with the iOS SDK <https://developer.apple.com/xcode/download>`__ (a "
"dmg image)"
msgstr ""
"`带iOS SDK的XCode <https://developer.apple.com/xcode/download>`__(dmg图片)"

#: ../../docs/development/compiling/cross-compiling_for_ios_on_linux.rst:31
msgid ""
"`Clang >= 3.5 <http://clang.llvm.org>`__ for your development machine "
"installed and in the ``PATH``. It has to be version >= 3.5 to target "
"``arm64`` architecture."
msgstr ""
"`clang> = 3.5 <http://clang.llvm.org>`__用于安装的开发机器和 ``PATH`` 。 它必"
"须是版本> = 3.5才能瞄准 ``arm64`` 架构。"

#: ../../docs/development/compiling/cross-compiling_for_ios_on_linux.rst:34
msgid ""
"`Fuse <https://github.com/libfuse/libfuse>`__ for mounting and umounting the "
"dmg image."
msgstr "`Fuse <https://github.com/libfuse/libfuse>`__用于安装和卸载dmg映像。"

#: ../../docs/development/compiling/cross-compiling_for_ios_on_linux.rst:36
msgid ""
"`darling-dmg <https://github.com/darlinghq/darling-dmg>`__, which needs to "
"be built from source. The procedure for that is explained below."
msgstr ""
"`darling-dmg <https://github.com/darlinghq/darling-dmg>`__，需要从源码构建。 "
"其程序解释如下。"

#: ../../docs/development/compiling/cross-compiling_for_ios_on_linux.rst:40
msgid ""
"For building darling-dmg, you'll need the development packages of the "
"following libraries: fuse, icu, openssl, zlib, bzip2."
msgstr ""
"要构建darling-dmg，您需要以下库的开发包:fuse，icu，openssl，zlib，bzip2。"

#: ../../docs/development/compiling/cross-compiling_for_ios_on_linux.rst:43
msgid ""
"`cctools-port <https://github.com/tpoechtrager/cctools-port>`__ for the "
"needed build tools. The procedure for building is quite peculiar and is "
"described below."
msgstr ""
"`cctools-port <https://github.com/tpoechtrager/cctools-port>`__用于所需的构建"
"工具。 建造程序非常奇特，如下所述。"

#: ../../docs/development/compiling/cross-compiling_for_ios_on_linux.rst:47
msgid "This also has some extra dependencies: automake, autogen, libtool."
msgstr "这也有一些额外的依赖:automake，autogen，libtool。"

#: ../../docs/development/compiling/cross-compiling_for_ios_on_linux.rst:50
msgid "Configuring the environment"
msgstr "配置环境"

#: ../../docs/development/compiling/cross-compiling_for_ios_on_linux.rst:53
msgid "darling-dmg"
msgstr "亲爱的-DMG"

#: ../../docs/development/compiling/cross-compiling_for_ios_on_linux.rst:55
msgid "Clone the repository on your machine:"
msgstr "克隆计算机上的存储库:"

#: ../../docs/development/compiling/cross-compiling_for_ios_on_linux.rst:61
msgid "Build it:"
msgstr "建立它:"

#: ../../docs/development/compiling/cross-compiling_for_ios_on_linux.rst:73
msgid "Preparing the SDK"
msgstr "准备SDK"

#: ../../docs/development/compiling/cross-compiling_for_ios_on_linux.rst:75
msgid "Mount the XCode image:"
msgstr "挂载XCode图像:"

#: ../../docs/development/compiling/cross-compiling_for_ios_on_linux.rst:84
msgid "Extract the iOS SDK:"
msgstr "解压缩iOS SDK:"

#: ../../docs/development/compiling/cross-compiling_for_ios_on_linux.rst:93
msgid "Pack the SDK:"
msgstr "打包SDK:"

#: ../../docs/development/compiling/cross-compiling_for_ios_on_linux.rst:101
msgid "Toolchain"
msgstr "工具链"

#: ../../docs/development/compiling/cross-compiling_for_ios_on_linux.rst:103
msgid "Build cctools:"
msgstr "构建cctools:"

#: ../../docs/development/compiling/cross-compiling_for_ios_on_linux.rst:111
msgid ""
"Copy the tools to a nicer place. Note that the SCons scripts for building "
"will look under ``usr/bin`` inside the directory you provide for the "
"toolchain binaries, so you must copy to such subdirectory, akin to the "
"following commands:"
msgstr ""
"将工具复制到更好的位置。 请注意，用于构建的SCons脚本将在您为工具链二进制文件"
"提供的目录中的“usr / bin”下查看，因此您必须复制到此类子目录，类似于以下命令:"

#: ../../docs/development/compiling/cross-compiling_for_ios_on_linux.rst:121
msgid ""
"Now you should have the iOS toolchain binaries in ``/home/user/iostoolchain/"
"usr/bin``."
msgstr ""
"现在您应该在``/ home / user / iostoolchain / usr / bin``中拥有iOS工具链二进制"
"文件。"

#: ../../docs/development/compiling/cross-compiling_for_ios_on_linux.rst:125
msgid "Compiling Godot for iPhone"
msgstr "为iPhone编译Godot"

#: ../../docs/development/compiling/cross-compiling_for_ios_on_linux.rst:127
msgid ""
"Once you've done the above steps, you should keep two things in your "
"environment: the built toolchain and the iPhoneOS SDK directory. Those can "
"stay anywhere you want since you have to provide their paths to the SCons "
"build command."
msgstr ""
"完成上述步骤后，您应该在您的环境中保留两件事:构建的工具链和iPhoneOS SDK目"
"录。 这些可以留在您想要的任何地方，因为您必须提供他们的路径到SCons构建命令。"

#: ../../docs/development/compiling/cross-compiling_for_ios_on_linux.rst:132
msgid ""
"For the iPhone platform to be detected, you need the ``OSXCROSS_IOS`` "
"environment variable defined to anything."
msgstr "要检测iPhone平台，您需要为任何事物定义 ``OSXCROSS_IOS`` 环境变量。"

#: ../../docs/development/compiling/cross-compiling_for_ios_on_linux.rst:139
msgid ""
"Now you can compile for iPhone using SCons like the standard Godot way, with "
"some additional arguments to provide the correct paths:"
msgstr ""
"现在您可以使用像标准Godot方式的SCons编译iPhone，并提供一些额外的参数来提供正"
"确的路径:"

#: ../../docs/development/compiling/cross-compiling_for_ios_on_linux.rst:148
msgid "Producing fat binaries"
msgstr "制作胖二进制文件"

#: ../../docs/development/compiling/cross-compiling_for_ios_on_linux.rst:150
msgid ""
"Apple requires a fat binary with both architectures (``armv7`` and "
"``arm64``) in a single file. To do this, use the ``arm-apple-darwin11-lipo`` "
"executable. The following example assumes you are in the root Godot source "
"directory:"
msgstr ""
"Apple需要一个胖二进制文件，两个架构(``armv7``和``arm64``)在一个文件中。 为"
"此，请使用 ``arm-apple-darwin11-lipo`` 可执行文件。 以下示例假定您位于根Godot"
"源目录中:"

#: ../../docs/development/compiling/cross-compiling_for_ios_on_linux.rst:159
msgid ""
"Then you will have an iOS fat binary in ``bin/godot.iphone.opt.debug.fat``."
msgstr ""
"然后您将在``bin / godot.iphone.opt.debug.fat``中拥有一个iOS胖二进制文件。"

#: ../../docs/development/compiling/compiling_for_uwp.rst:4
msgid "Compiling for Universal Windows Platform"
msgstr "为UWP平台(Universal Windows Platform)编译"

#: ../../docs/development/compiling/compiling_for_uwp.rst:11
msgid "SCons (see :ref:`doc_compiling_for_windows` for more details)."
msgstr "SCons(有关详细信息，请参阅 :ref:`doc_compiling_for_windows`)。"

#: ../../docs/development/compiling/compiling_for_uwp.rst:12
msgid ""
"Visual Studio 2015 Update 2. It may work with earlier versions. See :ref:"
"`doc_compiling_for_windows` about the caveats of installing it and the "
"various prompts."
msgstr ""
"Visual Studio 2015 Update 2.它可能适用于早期版本。 请参阅 :ref:"
"`doc_compiling_for_windows`，了解安装它的注意事项和各种提示。"

#: ../../docs/development/compiling/compiling_for_uwp.rst:15
msgid "Windows 10 SDK (can be selected in Visual Studio installation)."
msgstr "Windows 10 SDK(可在Visual Studio安装中选择)。"

#: ../../docs/development/compiling/compiling_for_uwp.rst:16
msgid ""
"`ANGLE source <https://github.com/Microsoft/angle>`__. Use the ``ms_master`` "
"(default) branch. Keep it in a path without spaces to avoid problems."
msgstr ""
"`ANGLE source <https://github.com/Microsoft/angle>`__。 使用 ``ms_master`` "
"(默认)分支。 将其保存在没有空格的路径中以避免出现问题。"

#: ../../docs/development/compiling/compiling_for_uwp.rst:26
msgid ""
"You need to open a proper Visual Studio prompt for the target architecture "
"you want to build. Check :ref:`doc_compiling_for_windows` to see how these "
"prompts work."
msgstr ""
"您需要为要构建的目标体系结构打开正确的Visual Studio提示符。 检查 :ref:"
"`doc_compiling_for_windows`以查看这些提示是如何工作的。"

#: ../../docs/development/compiling/compiling_for_uwp.rst:30
msgid ""
"There are three target architectures for UWP: x86 (32-bits), x64 (64-bits) "
"and ARM (32-bits). For the latter, you can run ``vcvarsall.bat`` with "
"``x86_arm`` or ``amd64_arm`` as argument to set the environment."
msgstr ""
"UWP有三种目标体系结构:x86(32位)，x64(64位)和ARM(32位)。 对于后者，您可以使用 "
"``x86_arm`` 或``amd64_arm``作为参数运行``vcvarsall.bat``来设置环境。"

#: ../../docs/development/compiling/compiling_for_uwp.rst:34
msgid ""
"Set the ``ANGLE_SRC_PATH`` to the directory where you downloaded the ANGLE "
"source code. The build process will also build ANGLE to produce the required "
"DLLs for the selected architecture."
msgstr ""
"将 ``ANGLE_SRC_PATH`` 设置为您下载ANGLE源代码的目录。 构建过程还将构建ANGLE以"
"生成所选体系结构所需的DLL。"

#: ../../docs/development/compiling/compiling_for_uwp.rst:38
msgid ""
"Once you're set, run the SCons command similarly to the other platforms::"
msgstr "设置完成后，与其他平台类似地运行SCons命令::"

#: ../../docs/development/compiling/compiling_for_uwp.rst:43
msgid "Creating UWP export templates"
msgstr "创建UWP导出模板"

#: ../../docs/development/compiling/compiling_for_uwp.rst:45
msgid ""
"To export using the editor you need to properly build package the templates. "
"You need all three architectures with ``debug`` and ``release`` templates to "
"be able to export."
msgstr ""
"要使用编辑器导出，您需要正确构建包模板。 您需要使用 ``debug`` 和``release``模"
"板的所有三种架构才能导出。"

#: ../../docs/development/compiling/compiling_for_uwp.rst:49
msgid ""
"Open the command prompt for one architecture and run SCons twice (once for "
"each target)::"
msgstr ""
"Open the command prompt for one architecture and run SCons twice (once for "
"each target)::"

#: ../../docs/development/compiling/compiling_for_uwp.rst:55
msgid "Repeat for the other architectures."
msgstr "重复其他架构。"

#: ../../docs/development/compiling/compiling_for_uwp.rst:57
msgid ""
"In the end your ``bin`` folder will have the ``.exe`` binaries with a name "
"like ``godot.uwp.opt.debug.32.x86.exe`` (with variations for each target/"
"arch)."
msgstr ""
"最后您的 ``bin`` 文件夹将有 ``.exe`` 二进制文件，其名称类似于 ``godot.uwp."
"opt.debug.32.x86.exe`` (每个目标/拱的变体)。"

#: ../../docs/development/compiling/compiling_for_uwp.rst:61
msgid ""
"Copy one of these to ``misc/dist/uwp_template`` inside the Godot source "
"folder and rename the binary to ``godot.uwp.exe``. From the ANGLE source, "
"under ``winrt/10/src/Release_%arch%`` (where ``%arch%`` can be ``Win32``, "
"``x64`` or ``ARM``), get the ``libEGL.dll`` and the ``libGLESv2.dll``, "
"putting them along with the executable."
msgstr ""
"将其中一个复制到Godot源文件夹中的``misc / dist / uwp_template``，并将二进制文"
"件重命名为 ``godot.uwp.exe`` 。 从ANGLE源代码，在``winrt / 10 / src / "
"Release_％arch％``(``％arch％``可以是``Win32``， ``x64`` 或``ARM``)下， 获取 "
"``libEGL.dll`` 和``libGLESv2.dll``，将它们与可执行文件放在一起。"

#: ../../docs/development/compiling/compiling_for_uwp.rst:67
msgid ""
"Add the files in the ``uwp_template`` folder to a ZIP. Rename the resulting "
"Zip according to the target/architecture of the template::"
msgstr ""
"将 ``uwp_template`` 文件夹中的文件添加到ZIP中。 根据模板的目标/体系结构重命名"
"生成的Zip ::"

#: ../../docs/development/compiling/compiling_for_uwp.rst:77
msgid ""
"Move those templates to the ``[versionstring]\\templates`` folder in Godot "
"settings path, where `versionstring` is the version of Godot you have "
"compiled the export templates for - e.g. `3.0.alpha` for the alpha version "
"of Godot 3. If you don't want to replace the templates, you can set the "
"\"Custom Package\" property in the export window."
msgstr ""
"将这些模板移动到Godot设置路径中的``[versionstring] \\ templates``文件夹，其中"
"`versionstring`是您编译导出模板的Godot版本 - 例如 对于Godot 3的alpha版"
"本，“3.0.alpha”。如果您不想替换模板，可以在导出窗口中设置“自定义包”属性。"

#: ../../docs/development/compiling/compiling_for_uwp.rst:84
msgid "Running UWP apps with Visual Studio"
msgstr "使用Visual Studio运行UWP应用程序"

#: ../../docs/development/compiling/compiling_for_uwp.rst:86
msgid ""
"If you want to debug the UWP port or simply run your apps without packaging "
"and signing, you can deploy and launch them using Visual Studio. It might be "
"the easiest way if you are testing on a device such as a Windows Phone or an "
"Xbox One."
msgstr ""
"如果要调试UWP端口或只是在没有打包和签名的情况下运行应用程序，可以使用Visual "
"Studio部署和启动它们。 如果您在Windows Phone或Xbox One等设备上进行测试，这可"
"能是最简单的方法。"

#: ../../docs/development/compiling/compiling_for_uwp.rst:91
msgid ""
"Within the ANGLE source folder, open ``templates`` and double-click the "
"``install.bat`` script file. This will install the Visual Studio project "
"templates for ANGLE apps."
msgstr ""
"在ANGLE源文件夹中，打开 ``templates`` 并双击 ``install.bat`` 脚本文件。 这将"
"为ANGLE应用程序安装Visual Studio项目模板。"

#: ../../docs/development/compiling/compiling_for_uwp.rst:95
msgid ""
"If you have not built Godot yet, open the ``winrt/10/src/angle.sln`` "
"solution from the ANGLE source and build it to Release/Win32 target. You may "
"also need to build it for ARM if you plan to run on a device. You can also "
"use MSBuild if you're comfortable with the command line."
msgstr ""
"如果还没有构建Godot，请从ANGLE源打开``winrt / 10 / src / angle.sln``解决方案"
"并将其构建到Release / Win32目标。 如果您计划在设备上运行，则可能还需要为ARM构"
"建它。 如果您对命令行感到满意，也可以使用MSBuild。"

#: ../../docs/development/compiling/compiling_for_uwp.rst:100
msgid ""
"Create a new Windows App project using the \"App for OpenGL ES (Windows "
"Universal)\" project template, which can be found under the ``Visual C++/"
"Windows/Universal`` category."
msgstr ""
"使用“App for OpenGL ES(Windows Universal)”项目模板创建一个新的Windows应用程序"
"项目，该模板位于“Visual C++ / Windows / Universal”类别下。"

#: ../../docs/development/compiling/compiling_for_uwp.rst:104
msgid ""
"This is a base project with the ANGLE dependencies already set up. However, "
"by default it picks the debug version of the DLLs which usually have poor "
"performance. So in the \"Binaries\" filter, click in each of the DLLs there "
"and in the \"Properties\" window and change the relative path from "
"``Debug_Win32`` to ``Release_Win32`` (or ``Release_ARM`` for devices)."
msgstr ""
"这是一个已经设置了ANGLE依赖项的基础项目。 但是，默认情况下，它会选择通常性能"
"较差的DLL的调试版本。 因此，在“二进制”过滤器中，单击其中的每个DLL并在“属性”窗"
"口中，将相对路径从“Debug_Win32”更改为“Release_Win32”(或设备"
"的“Release_ARM``”)。"

#: ../../docs/development/compiling/compiling_for_uwp.rst:110
msgid ""
"In the same \"Binaries\" filter, select \"Add > Existing Item\" and point to "
"the Godot executable for UWP you have. In the \"Properties\" window, set "
"\"Content\" to ``True`` so it's included in the project."
msgstr ""
"在相同的“二进制”过滤器中，选择“添加>现有项”并指向您拥有的UWP的Godot可执行文"
"件。 在“属性”窗口中，将“内容”设置为“真”，以便它包含在项目中。"

#: ../../docs/development/compiling/compiling_for_uwp.rst:114
msgid ""
"Right-click the ``Package.appxmanifest`` file and select \"Open With... > "
"XML (Text) Editor\". In the ``Package/Applications/Application`` element, "
"replace the ``Executable`` attribute from ``$targetnametoken$.exe`` to "
"``godot.uwp.exe`` (or whatever your Godot executable is called). Also change "
"the ``EntryPoint`` attribute to ``GodotUWP.App``. This will ensure that the "
"Godot executable is correctly called when the app starts."
msgstr ""
"右键单击 ``Package.appxmanifest`` 文件并选择“Open With ...> "
"XML(Text)Editor”。 在``Package / Applications / Application``元素中，将``$ "
"targetnametoken $ .exe``中的``Executable``属性替换为``godot.uwp.exe``(或者调"
"用您的Godot可执行文件)。 同时将 ``EntryPoint`` 属性更改为 ``GodotUWP."
"App`` 。 这将确保在应用程序启动时正确调用Godot可执行文件。"

#: ../../docs/development/compiling/compiling_for_uwp.rst:121
msgid ""
"Create a folder (*not* a filter) called ``game`` in your Visual Studio "
"project folder and there you can put either a ``data.pck`` file or your "
"Godot project files. After that, make sure to include it all with the \"Add "
"> Existing Item\" command and set their \"Content\" property to ``True`` so "
"they're copied to the app."
msgstr ""
"在Visual Studio项目文件夹中创建一个名为 ``game`` 的文件夹(* not * a filter)，"
"您可以在其中放置 ``data.pck`` 文件或Godot项目文件。 之后，请确保使用“添加>现"
"有项目”命令将其全部包含在内，并将其“内容”属性设置为“True”，以便将它们复制到应"
"用程序中。"

#: ../../docs/development/compiling/compiling_for_uwp.rst:127
msgid ""
"To ease the workflow, you can open the \"Solution Properties\" and in the "
"\"Configuration\" section untick the \"Build\" option for the app. You still "
"have to build it at least once to generate some needed files, you can do so "
"by right-clicking the project (*not* the solution) in the \"Solution Explorer"
"\" and selecting \"Build\"."
msgstr ""
"为了简化工作流程，您可以打开“解决方案属性”，然后在“配置”部分中取消选中应用程"
"序的“构建”选项。 您仍然必须至少构建一次以生成一些所需的文件，您可以通过右键单"
"击“解决方案资源管理器”中的项目(*不是解决方案)并选择“构建”来实现。"

#: ../../docs/development/compiling/compiling_for_uwp.rst:133
msgid ""
"Now you can just run the project and your app should open. You can use also "
"the \"Start Without Debugging\" from the \"Debug\" menu (Ctrl+F5) to make it "
"launch faster."
msgstr ""
"现在您可以运行该项目，您的应用程序应该打开。 您也可以使用“Debug”菜单中"
"的“Start Without Debugging”(Ctrl + F5)来使其更快启动。"

#: ../../docs/development/compiling/compiling_for_web.rst:4
msgid "Compiling for the Web"
msgstr "为Web平台编译"

#: ../../docs/development/compiling/compiling_for_web.rst:11
msgid "To compile export templates for the Web, the following is required:"
msgstr "要编译Web的导出模板，需要以下内容:"

#: ../../docs/development/compiling/compiling_for_web.rst:13
#, fuzzy
msgid ""
"`Emscripten 1.38.22+ <http://kripken.github.io/emscripten-site>`__: If the "
"version available per package manager is not recent enough, the best "
"alternative is to install using the `Emscripten SDK <http://kripken.github."
"io/emscripten-site/docs/getting_started/downloads.html>`__"
msgstr ""
"`Emscripten 1.37.9+ <http://kripken.github.io/emscripten-site>`__:如果每个包"
"管理器的可用版本不够新，最好的选择是使用`Emscripten SDK <http://kripken."
"github.io/emscripten-site/docs/getting_started/downloads.html>`__"

#: ../../docs/development/compiling/compiling_for_web.rst:16
msgid "`Python 2.7+ or Python 3.5+ <https://www.python.org/>`__"
msgstr "`Python 2.7+或Python 3.5+ <https://www.python.org/>`__"

#: ../../docs/development/compiling/compiling_for_web.rst:17
msgid "`SCons <https://www.scons.org>`__ build system"
msgstr "`SCons <https://www.scons.org>`__构建系统"

#: ../../docs/development/compiling/compiling_for_web.rst:25
msgid ""
"Before starting, confirm that the Emscripten configuration file exists and "
"specifies all settings correctly. This file is available as ``~/."
"emscripten`` on UNIX-like systems and ``%USERPROFILE%\\.emscripten`` on "
"Windows. It's usually written by the Emscripten SDK, e.g. when invoking "
"``emsdk activate latest``, or by your package manager. It's also created "
"when starting Emscripten's ``emcc`` program if the file doesn't exist."
msgstr ""
"在开始之前，请确认Emscripten配置文件存在并正确指定所有设置。 这个文件在类UNIX"
"系统上可用作``〜/ .emscripten``，在Windows上可用``％USERPROFILE％\\。"
"emscripten``。 它通常由Emscripten SDK编写，例如 当调用``emsdk activate "
"latest``时，或者由您的包管理器调用。 如果文件不存在，它也会在启动Emscripten的"
"``emcc``程序时创建。"

#: ../../docs/development/compiling/compiling_for_web.rst:32
msgid ""
"On Windows, make sure to escape backslashes of paths within the Emscripten "
"configuration file as double backslashes ``\\\\`` or use Unix-style paths "
"with a single forward slash ``/``."
msgstr ""

#: ../../docs/development/compiling/compiling_for_web.rst:36
msgid ""
"Open a terminal and navigate to the root directory of the engine source "
"code. Then instruct SCons to build the JavaScript platform. Specify "
"``target`` as either ``release`` for a release build or ``release_debug`` "
"for a debug build::"
msgstr ""
"打开终端并导航到引擎源代码的根目录。 然后指示SCons构建JavaScript平台。 将 "
"``target`` 指定为发布版本的 ``release`` 或调试版本的``release_debug`` ::"

#: ../../docs/development/compiling/compiling_for_web.rst:43
msgid ""
"By default, the :ref:`JavaScript singleton <doc_javascript_eval>` will be "
"built into the engine. Since ``eval()`` calls can be a security concern, the "
"``javascript_eval`` option can be used to build without the singleton::"
msgstr ""
"默认情况下，引用内置 :ref:`JavaScript singleton <doc_javascript_eval>` 。 由"
"于 ``eval()`` 调用可能是一个安全问题， ``javascript_eval`` 选项可用于构建而不"
"需要单例::"

#: ../../docs/development/compiling/compiling_for_web.rst:50
msgid ""
"The engine will now be compiled to WebAssembly by Emscripten. Once finished, "
"the resulting file will be placed in the ``bin`` subdirectory. Its name is "
"``godot.javascript.opt.zip`` for release or ``godot.javascript.opt.debug."
"zip`` for debug."
msgstr ""
"现在，引擎将由Emscripten编译为WebAssembly。 完成后，生成的文件将放在 ``bin`` "
"子目录中。 它的名字是``godot.javascript.opt.zip`` for release或``godot."
"javascript.opt.debug.zip`` for debug。"

#: ../../docs/development/compiling/compiling_for_web.rst:55
msgid ""
"Finally, rename the zip archive to ``webassembly_release.zip`` for the "
"release template::"
msgstr "最后，将zip存档重命名为 ``webassembly_release.zip`` 以获取发布模板::"

#: ../../docs/development/compiling/compiling_for_web.rst:60
msgid "And ``webassembly_debug.zip`` for the debug template::"
msgstr "调试模板的``webassembly_debug.zip`` ::"

#: ../../docs/development/compiling/compiling_for_web.rst:65
msgid "Building per asm.js translation or LLVM backend"
msgstr "根据asm.js转换或LLVM后端构建"

#: ../../docs/development/compiling/compiling_for_web.rst:67
msgid ""
"WebAssembly can be compiled in two ways: The default is to first compile to "
"asm.js, a highly optimizable subset of JavaScript, using Emscripten's "
"*fastcomp* fork of LLVM. This code is then translated to WebAssembly using a "
"tool called ``asm2wasm``. Emscripten automatically takes care of both "
"processes, we simply run SCons."
msgstr ""
"WebAssembly可以用两种方式编译:默认是首先使用Emscripten的* fastcomp * LLVM分支"
"编译为asm.js，这是一个高度可优化的JavaScript子集。 然后使用名为 ``asm2wasm`` "
"的工具将此代码转换为WebAssembly。 Emscripten会自动处理这两个进程，我们只需运"
"行SCons。"

#: ../../docs/development/compiling/compiling_for_web.rst:73
msgid ""
"The other method uses LLVM's WebAssembly backend. This backend is available "
"starting with LLVM 8 or in development builds. Emscripten manages this "
"process as well, so we just invoke SCons."
msgstr ""

#: ../../docs/development/compiling/compiling_for_web.rst:77
#, fuzzy
msgid ""
"In order to choose one of the two methods, the ``LLVM_ROOT`` variable in the "
"Emscripten configuration file is used. If it points to a directory "
"containing binaries of Emscripten's *fastcomp* fork of clang, ``asm2wasm`` "
"is used. This is the default in a normal Emscripten installation. Otherwise, "
"LLVM binaries built with the WebAssembly backend will be expected and the "
"LLVM's WebAssembly backend is used."
msgstr ""
"为了选择两种方法中的一种，使用Emscripten配置文件中的``LLVM_ROOT``变量。 如果"
"它指向包含Emscripten的* fastcomp * fork of clang的二进制文件的目录，则使用"
"``asm2wasm``。 这是正常Emscripten安装中的默认设置。 否则，将使用使用"
"WebAssembly后端构建的LLVM二进制文件，并使用“s2wasm``。 在Windows上，确保将此"
"文件中的反斜杠转义为双反斜杠``\\\\``或使用带有单个正斜杠`/``的Unix风格路径。"

#: ../../docs/development/compiling/compiling_with_mono.rst:4
msgid "Compiling with Mono"
msgstr "携带Mono模块编译"

#: ../../docs/development/compiling/compiling_with_mono.rst:11
msgid "Mono 5.12.0 or greater"
msgstr "Mono 5.12.0及以上版本"

#: ../../docs/development/compiling/compiling_with_mono.rst:12
msgid "MSBuild"
msgstr "MSBuild"

#: ../../docs/development/compiling/compiling_with_mono.rst:13
#: ../../docs/development/compiling/compiling_with_mono.rst:15
msgid "NuGet"
msgstr "NuGet"

#: ../../docs/development/compiling/compiling_with_mono.rst:14
msgid "pkg-config"
msgstr "pkg-config"

#: ../../docs/development/compiling/compiling_with_mono.rst:17
msgid ""
"You may need to import necessary certificates for NuGet to perform HTTPS "
"requests. You can do this with the following command (on Windows, you can "
"run it from the Mono command line prompt):"
msgstr ""
"您可能需要为NuGet导入必要的证书才能执行HTTPS请求。 您可以使用以下命令执行此操"
"作(在Windows上，您可以从Mono命令行提示符运行它):"

#: ../../docs/development/compiling/compiling_with_mono.rst:24
msgid "Environment variables"
msgstr "环境变量"

#: ../../docs/development/compiling/compiling_with_mono.rst:26
msgid ""
"By default, SCons will try to find Mono in the Windows Registry on Windows "
"or via ``pkg-config`` on other platforms. You can specify a different "
"installation directory by using the following environment variables for the "
"respective ``bits`` option: ``MONO32_PREFIX`` and ``MONO64_PREFIX``."
msgstr ""
"默然情况下 Scons 会尝试在 Windows 注册表中查找Mono， 在非 Windows 平台上会使"
"用 ``pkg-config`` 进行查找。 您可以通过设置下面的环境变量来指定您安装在其他地"
"方的 mono 安装目录， 根据系统位数不同，这些环境变量分别是 ``MONO32_PREFIX`` "
"和 ``MONO64_PREFIX``。"

#: ../../docs/development/compiling/compiling_with_mono.rst:28
msgid ""
"The specified directory must contain the subdirectories ``bin``, "
"``include``, and ``lib``."
msgstr ""
"您所指定的文件夹必须包含 ``bin``、 ``include``、 ``lib`` 这几个子目录。"

#: ../../docs/development/compiling/compiling_with_mono.rst:31
msgid "Enable the Mono module"
msgstr "启用 Mono 模块"

#: ../../docs/development/compiling/compiling_with_mono.rst:33
msgid ""
"By default, the mono module is disabled for builds. To enable it you can "
"pass the option ``module_mono_enabled=yes`` to your SCons command."
msgstr ""
"默认情况下 mono 模块是禁用的。您可以通过传递 ``module_mono_enabled=yes`` 参数"
"给 Scons 构建系统来启用它。"

#: ../../docs/development/compiling/compiling_with_mono.rst:36
msgid "Generate the glue"
msgstr "生成胶水代码"

#: ../../docs/development/compiling/compiling_with_mono.rst:38
msgid ""
"The glue sources are the wrapper functions that will be called by managed "
"methods. These source files must be generated before building your final "
"binaries. In order to generate them, first, you must build a temporary Godot "
"binary with the options ``tools=yes`` and ``mono_glue=no``:"
msgstr ""
"这些粘合代码用于封装 mono 所需要的一些功能。要生成这些代码，您需要首先通过 "
"``tools=yes`` 和 ``mono_glue=no`` 配置构建一遍 Godot:"

#: ../../docs/development/compiling/compiling_with_mono.rst:44
msgid ""
"After the build finishes, you need to run the compiled executable with the "
"parameter ``--generate-mono-glue`` followed by the path to an output "
"directory. This path must be ``modules/mono/glue`` in the Godot directory."
msgstr ""
"在您编译完成以后，您可以在命令行中执行您得到的可执行文件，并带上 ``--"
"generate-mono-glue`` 参数来生成胶水代码到您指定的目录。这里我们传入的路径是 "
"``modules/mono/glue``。"

#: ../../docs/development/compiling/compiling_with_mono.rst:50
msgid ""
"This command will tell Godot to generate the file ``modules/mono/glue/"
"mono_glue.gen.cpp``. Once this file is generated, you can build Godot for "
"all the desired targets without the need to repeat this process."
msgstr ""
"这个命令告诉 Godot 生成胶水代码到 *modules/mono/glue/mono_glue.gen.cpp* 文"
"件。 执行此步骤之后，您后面要再次构建就不需要重复进行这个操作了。"

#: ../../docs/development/compiling/compiling_with_mono.rst:53
msgid ""
"``<godot_binary>`` refers to the tools binary you compiled above with the "
"Mono module enabled. Its exact name will differ based on your system and "
"configuration, but should be of the form ``bin/godot.<platform>.tools.<bits>."
"mono``, e.g. ``bin/godot.x11.tools.64.mono`` or ``bin/godot.windows.tools.64."
"exe``. Be especially aware of the **.mono** suffix! If you compiled Godot "
"without Mono support previously, you might have similarly named binaries "
"without this suffix which can't be used to generate the Mono glue."
msgstr ""
"``<godot_binary>`` 指的是您在启用Mono模块时编译的工具二进制文件。 它的确切名"
"称将根据您的系统和配置而有所不同，但应该采用 ``bin/godot.<platform>.tools."
"<bits>.mono`` 的形式，例如 ``bin/godot.x11.tools.64.mono`` 或 ``bin/godot."
"windows.tools.64.exe`` 。 要特别注意 ** .mono ** 后缀！ 如果您之前没有Mono支"
"持编译过Godot，那么您可能有类似名称的二进制文件，但没有此后缀，不能用于生成"
"Mono粘合剂。"

#: ../../docs/development/compiling/compiling_with_mono.rst:58
#: ../../docs/development/cpp/custom_godot_servers.rst:506
msgid "Notes"
msgstr "注意"

#: ../../docs/development/compiling/compiling_with_mono.rst:59
msgid ""
"**Do not** build your final binaries with ``mono_glue=no``. This disables C# "
"scripting. This option must be used only for the temporary binary that will "
"generate the glue. Godot will print a warning at startup if it was built "
"without the glue sources."
msgstr ""
"**不要** 使用 ``mono_glue=no`` 配置来构建您的发布版 Godot。 此选项会禁用C#脚"
"本，它的构建结果是仅用于控制生成胶水代码的临时二进制文件。Godot 会在启动时打"
"印一条消息，提醒您这件事。"

#: ../../docs/development/compiling/compiling_with_mono.rst:60
msgid ""
"The glue sources must be regenerated every time the ClassDB bindings "
"changes. That is, for example, when a new method is added to ClassDB or one "
"of the parameter of such a method changes. Godot will print an error at "
"startup if there is an API mismatch between ClassDB and the glue sources."
msgstr ""
"胶水代码在每次 ClassDB 的API有变动时都要重新生成。 如果有API和生成的胶水代码"
"不匹配， Godot 将在启动时在控制台输出错误信息。"

#: ../../docs/development/compiling/compiling_with_mono.rst:63
msgid "Rebuild with Mono glue"
msgstr "用Mono胶重建"

#: ../../docs/development/compiling/compiling_with_mono.rst:65
msgid ""
"Once you have generated the Mono glue, you can build the final binary with "
"``mono_glue=yes``. It's the default value for ``mono_glue`` so you can also "
"omit it. You can build the Mono-enabled editor:"
msgstr ""
"一旦您生成了Mono胶水，就可以使用 ``mono_glue = yes`` 构建最终的二进制文件。 "
"这是 ``mono_glue`` 的默认值，所以您也可以省略它。 您可以构建启用Mono的编辑器:"

#: ../../docs/development/compiling/compiling_with_mono.rst:72
msgid "And Mono-enabled export templates:"
msgstr "启用Mono的导出模板:"

#: ../../docs/development/compiling/compiling_with_mono.rst:78
msgid ""
"If everything went well, apart from the normal output SCons should have "
"created the following files in the ``bin`` directory:"
msgstr "如果一切顺利，除了正常输出外，SCons应该在 ``bin`` 目录中创建以下文件:"

#: ../../docs/development/compiling/compiling_with_mono.rst:80
msgid ""
"If you're not static linking the Mono runtime, the build script will place "
"the Mono runtime shared library next to the Godot binary."
msgstr ""
"如果您不是静态链接Mono运行时，则构建脚本会将Mono运行时共享库放在Godot二进制文"
"件旁边。"

#: ../../docs/development/compiling/compiling_with_mono.rst:81
msgid ""
"Unlike \"classical\" Godot builds, when building with the mono module "
"enabled a data directory will be created both for the editor and for export "
"templates. This directory is important for proper functioning and must be "
"distributed together with Godot. More details about this directory in :ref:"
"`Data directory<compiling_with_mono_data_directory>`."
msgstr ""
"与“经典”Godot构建不同，在启用mono模块的情况下构建时，将为编辑器和导出模板创建"
"数据目录。 该目录对于正常运行很重要，必须与Godot一起分发。 有关此目录的更多详"
"细信息，请参见 :ref:`Data directory<compiling_with_mono_data_directory>` 。"

#: ../../docs/development/compiling/compiling_with_mono.rst:87
msgid "Example (Windows)"
msgstr "示例(Windows)"

#: ../../docs/development/compiling/compiling_with_mono.rst:103
msgid "Example (X11)"
msgstr "示例 (x11)"

#: ../../docs/development/compiling/compiling_with_mono.rst:121
msgid "Data directory"
msgstr "数据目录"

#: ../../docs/development/compiling/compiling_with_mono.rst:123
msgid ""
"The data directory is a dependency for Godot binaries built with the mono "
"module enabled. It contains files that are important for the correct "
"functioning of Godot. It must be distributed next to the Godot executable."
msgstr ""
"数据目录是在启用单声道模块的情况下构建的Godot二进制文件的依赖项。 它包含对"
"Godot正确运行很重要的文件。 它必须分布在Godot可执行文件旁边。"

#: ../../docs/development/compiling/compiling_with_mono.rst:128
msgid ""
"The name of the data directory for a export template differs based on the "
"configuration it was built with. The format is ``data.mono.<platform>.<bits>."
"<target>``, e.g. ``data.mono.x11.32.debug`` or ``data.mono.windows.64."
"release``."
msgstr ""
"导出模板的数据目录的名称根据其构建的配置而有所不同。 格式为 ``data.mono."
"<platform>.<bits>.<target>`` ，例如 ``data.mono.x11.32.debug`` 或 ``data."
"mono.windows.64.release`` 。"

#: ../../docs/development/compiling/compiling_with_mono.rst:130
msgid ""
"In the case of export templates the data directory only contains Mono "
"framework assemblies and configuration files, as well as some shared library "
"dependencies like ``MonoPosixHelper``."
msgstr ""
"对于导出模板，数据目录仅包含Mono框架程序集和配置文件，以及一些共享库依赖项，"
"如  ``MonoPosixHelper`` 。"

#: ../../docs/development/compiling/compiling_with_mono.rst:132
msgid ""
"This directory must be placed with its original name next to the Godot "
"export templates. When exporting a project, Godot will also copy this "
"directory with the game executable but the name will be changed to "
"``data_<APPNAME>``, where ``<APPNAME>`` is the application name as specified "
"in the project setting ``application/config/name``."
msgstr ""
"必须在Godot导出模板旁边放置此目录，用其原始名称。 导出项目时，Godot还会将此目"
"录与游戏可执行文件一起复制，但名称将更改为 ``data_<APPNAME>`` ，其中 "
"``<APPNAME>`` 是项目设置中指定的应用程序名称 ``application/config/name`` 。"

#: ../../docs/development/compiling/compiling_with_mono.rst:134
msgid ""
"In the case of macOS, where the export template is compressed as a zip file, "
"the contents of the data directory can be placed in the following locations "
"inside the zip:"
msgstr ""
"对于macOS，导出模板被压缩为zip文件，数据目录的内容可以放在zip中的以下位置:"

#: ../../docs/development/compiling/compiling_with_mono.rst:137
#: ../../docs/development/compiling/compiling_with_mono.rst:196
msgid "``bin/data.mono.<platform>.<bits>.<target>/Mono/lib``"
msgstr "``bin/data.mono.<platform>.<bits>.<target>/Mono/lib``"

#: ../../docs/development/compiling/compiling_with_mono.rst:137
msgid "``/osx_template.app/Contents/Frameworks/GodotSharp/Mono/lib``"
msgstr "``/osx_template.app/Contents/Frameworks/GodotSharp/Mono/lib``"

#: ../../docs/development/compiling/compiling_with_mono.rst:139
#: ../../docs/development/compiling/compiling_with_mono.rst:198
msgid "``bin/data.mono.<platform>.<bits>.<target>/Mono/etc``"
msgstr "``bin/data.mono.<platform>.<bits>.<target>/Mono/etc``"

#: ../../docs/development/compiling/compiling_with_mono.rst:139
msgid "``/osx_template.app/Contents/Resources/GodotSharp/Mono/etc``"
msgstr "``/osx_template.app/Contents/Resources/GodotSharp/Mono/etc``"

#: ../../docs/development/compiling/compiling_with_mono.rst:145
msgid ""
"The name of the data directory for the Godot editor will always be "
"``GodotSharp``. The main structure of this directory has the following "
"subdirectories:"
msgstr ""
"Godot编辑器的数据目录名称将始终为“GodotSharp”。 该目录的主要结构具有以下子目"
"录:"

#: ../../docs/development/compiling/compiling_with_mono.rst:147
msgid "``Api`` (optional)"
msgstr "``Api``(可选)"

#: ../../docs/development/compiling/compiling_with_mono.rst:148
msgid "``Mono`` (optional)"
msgstr "``Mono``(可选)"

#: ../../docs/development/compiling/compiling_with_mono.rst:149
msgid "``Tools`` (required)"
msgstr "``工具``(必填)"

#: ../../docs/development/compiling/compiling_with_mono.rst:151
msgid ""
"The ``Tools`` subdirectory contains tools required by the editor, like the "
"``GodotSharpTools`` assembly."
msgstr "``Tools``子目录包含编辑器所需的工具，如 ``GodotSharpTools`` 程序集。"

#: ../../docs/development/compiling/compiling_with_mono.rst:153
msgid ""
"The ``Mono`` subdirectory is optional. It can be used to bundle the Mono "
"framework assemblies and configuration files with the Godot editor, as well "
"as some shared library dependencies like ``MonoPosixHelper``. This is "
"important to avoid issues that might arise when the installed Mono version "
"in the user's system may not be the same as the one the Godot editor was "
"built with. You can make SCons copy these files to this subdirectory by "
"passing the option ``copy_mono_root=yes`` when building the editor."
msgstr ""
"``Mono``子目录是可选的。 它可以用于将Mono框架程序集和配置文件与Godot编辑器捆"
"绑在一起，以及一些共享库依赖项，如 ``MonoPosixHelper`` 。 这对于避免在用户系"
"统中安装的Mono版本可能与构建Godot编辑器的版本不同时可能出现的问题非常重要。 "
"您可以通过在构建编辑器时传递“copy_mono_root = yes`”选项，让SCons将这些文件复"
"制到此子目录中。"

#: ../../docs/development/compiling/compiling_with_mono.rst:155
msgid ""
"The ``Api`` directory is also optional. Godot API assemblies are not bundled "
"with the editor by default. Instead the Godot editor will generate and build "
"them on the user's machine the first time they are required. This can be "
"avoided by generating and building them manually and placing them in this "
"subdirectory. If the editor can find them there, it will avoid the step of "
"generating and building them again."
msgstr ""
"``Api``目录也是可选的。 默认情况下，Godot API程序集不与编辑器捆绑在一起。 相"
"反，Godot编辑器将在第一次需要时在用户的机器上生成和构建它们。 这可以通过手动"
"生成和构建它们并将它们放在此子目录中来避免。 如果编辑器可以在那里找到它们，它"
"将避免再次生成和构建它们的步骤。"

#: ../../docs/development/compiling/compiling_with_mono.rst:157
msgid ""
"The following is an example script for building and copying the Godot API "
"assemblies:"
msgstr "以下是用于构建和复制Godot API程序集的示例脚本:"

#: ../../docs/development/compiling/compiling_with_mono.rst:188
msgid ""
"The script assumes it's being executed from the directory where SConstruct "
"is located. ``<godot_binary>`` refers to the tools binary compiled with the "
"Mono module enabled."
msgstr ""
"该脚本假定它是从SConstruct所在的目录执行的。 ``<godot_binary>``指的是在启用"
"Mono模块的情况下编译的工具二进制文件。"

#: ../../docs/development/compiling/compiling_with_mono.rst:191
msgid ""
"In the case of macOS, if the Godot editor is distributed as a bundle, the "
"contents of the data directory may be placed in the following locations:"
msgstr ""
"对于macOS，如果Godot编辑器作为包分发，则数据目录的内容可以放在以下位置:"

#: ../../docs/development/compiling/compiling_with_mono.rst:194
msgid "``bin/data.mono.<platform>.<bits>.<target>/Api``"
msgstr "``bin/data.mono.<platform>.<bits>.<target>/Api``"

#: ../../docs/development/compiling/compiling_with_mono.rst:194
msgid "``<bundle_name>.app/Contents/Frameworks/GodotSharp/Api``"
msgstr "``<bundle_name>.app/Contents/Frameworks/GodotSharp/Api``"

#: ../../docs/development/compiling/compiling_with_mono.rst:196
msgid "``<bundle_name>.app/Contents/Frameworks/GodotSharp/Mono/lib``"
msgstr "``<bundle_name>.app/Contents/Frameworks/GodotSharp/Mono/lib``"

#: ../../docs/development/compiling/compiling_with_mono.rst:198
msgid "``<bundle_name>.app/Contents/Resources/GodotSharp/Mono/etc``"
msgstr "``<bundle_name>.app/Contents/Resources/GodotSharp/Mono/etc``"

#: ../../docs/development/compiling/compiling_with_mono.rst:200
msgid "``bin/data.mono.<platform>.<bits>.<target>/Tools``"
msgstr "``bin/data.mono.<platform>.<bits>.<target>/Tools``"

#: ../../docs/development/compiling/compiling_with_mono.rst:200
msgid "``<bundle_name>.app/Contents/Frameworks/GodotSharp/Tools``"
msgstr "``<bundle_name>.app/Contents/Frameworks/GodotSharp/Tools``"

#: ../../docs/development/compiling/compiling_with_mono.rst:204
msgid "Command-line options"
msgstr "命令行选项"

#: ../../docs/development/compiling/compiling_with_mono.rst:206
msgid ""
"The following is the list of command-line options available when building "
"with the mono module:"
msgstr "以下是使用mono模块构建时可用的命令行选项列表:"

#: ../../docs/development/compiling/compiling_with_mono.rst:208
msgid ""
"**module_mono_enabled**: Build Godot with the mono module enabled ( yes | "
"**no** )"
msgstr "**module_mono_enabled**:在启用单声道模块的情况下构建Godot(是| **否**)"

#: ../../docs/development/compiling/compiling_with_mono.rst:210
msgid ""
"**mono_glue**: Whether to include the glue source files in the build and "
"define `MONO_GLUE_DISABLED` as a preprocessor macro ( **yes** | no )"
msgstr ""
"**mono_glue**: 是否在构建中包含glue源文件并将 `MONO_GLUE_DISABLED` 定义为预处"
"理器宏(**是** | 否)"

#: ../../docs/development/compiling/compiling_with_mono.rst:212
msgid ""
"**xbuild_fallback**: Whether to fallback to xbuild if MSBuild is not "
"available ( yes | **no** )"
msgstr "**xbuild_fallback**: 如果MSBuild不可用，是否回退到xbuild(是| **否** )"

#: ../../docs/development/compiling/compiling_with_mono.rst:214
msgid ""
"**mono_static**: Whether to link the mono runtime statically ( yes | **no** )"
msgstr "**mono_static**: 是否静态链接单声道运行时(是| **否**)"

#: ../../docs/development/compiling/compiling_with_mono.rst:216
msgid ""
"**copy_mono_root**: Whether to copy the Mono framework assemblies and "
"configuration files required by the Godot editor ( yes | **no** )"
msgstr ""
"**copy_mono_root**:是否复制Godot编辑器所需的Mono框架程序集和配置文件(是| **否"
"**)"

#: ../../docs/development/compiling/optimizing_for_size.rst:4
msgid "Optimizing a build for size"
msgstr "优化大小的构建"

#: ../../docs/development/compiling/optimizing_for_size.rst:9
msgid "Rationale"
msgstr "合理"

#: ../../docs/development/compiling/optimizing_for_size.rst:11
msgid ""
"Sometimes, it is desired to optimize a build for size rather than speed. "
"This means not compiling unused functions from the engine, as well as using "
"specific compiler flags to aid on decreasing build size. Common situations "
"include creating builds for mobile and Web platforms."
msgstr ""
"有时，需要针对大小而不是速度来优化构建。 这意味着不从引擎编译未使用的函数，也"
"不使用特定的编译器标志来帮助减少构建大小。 常见情况包括为移动和Web平台创建构"
"建。"

#: ../../docs/development/compiling/optimizing_for_size.rst:16
msgid ""
"This tutorial aims to give an overview on different methods to create a "
"smaller binary. Before continuing, it is recommended to read the previous "
"tutorials on compiling Godot for each platform."
msgstr ""
"本教程旨在概述创建较小二进制文件的不同方法。 在继续之前，建议阅读以前关于为每"
"个平台编译Godot的教程。"

#: ../../docs/development/compiling/optimizing_for_size.rst:21
msgid "Disabling 3D"
msgstr "禁用3D"

#: ../../docs/development/compiling/optimizing_for_size.rst:23
msgid ""
"For 2D games, having the whole 3D engine available usually makes no sense. "
"Because of this, there is a build flag to disable it:"
msgstr ""
"对于2D游戏，拥有整个3D引擎通常没有任何意义。 因此，有一个构建标志来禁用它:"

#: ../../docs/development/compiling/optimizing_for_size.rst:29
msgid ""
"Tools must be disabled in order to use this flag, as the editor is not "
"designed to operate without 3D support. Without it, the binary size can be "
"reduced by about 15%."
msgstr ""
"必须禁用工具才能使用此标志，因为编辑器不能在没有3D支持的情况下运行。 没有它，"
"二进制大小可以减少大约15％。"

#: ../../docs/development/compiling/optimizing_for_size.rst:34
msgid "Disabling advanced GUI nodes"
msgstr "禁用高级GUI节点"

#: ../../docs/development/compiling/optimizing_for_size.rst:36
msgid ""
"Most small games don't require complex GUI controls such as Tree, ItemList, "
"TextEditor or GraphEdit. They can be disabled using a build flag:"
msgstr ""
"大多数小游戏不需要复杂的GUI控件，如Tree，ItemList，TextEditor或GraphEdit。 可"
"以使用构建标志禁用它们:"

#: ../../docs/development/compiling/optimizing_for_size.rst:44
msgid "Disabling unwanted modules"
msgstr "禁用不需要的模块"

#: ../../docs/development/compiling/optimizing_for_size.rst:46
msgid ""
"A lot of Godot's functions are offered as modules. You can see a list of "
"modules with the following command:"
msgstr "很多Godot的功能都作为模块提供。 您可以使用以下命令查看模块列表:"

#: ../../docs/development/compiling/optimizing_for_size.rst:53
msgid ""
"The list of modules that can be disabled will appear, together with all "
"build options. If you are working on a simple 2D game, you could disable a "
"lot of them:"
msgstr ""
"将显示可以禁用的模块列表以及所有构建选项。 如果您正在开发一个简单的2D游戏，您"
"可以禁用它们中的很多:"

#: ../../docs/development/compiling/optimizing_for_size.rst:62
msgid "Optimizing for size instead of speed"
msgstr "优化大小而不是速度"

#: ../../docs/development/compiling/optimizing_for_size.rst:64
msgid ""
"Godot 3.1 onwards allows to compile using size optimizations. To enable "
"this, just set the ``optimize`` flag to ``size``:"
msgstr ""
"Godot 3.1以后允许使用大小优化进行编译。 要启用它，只需将 ``optimize`` 标志设"
"置为``size``:"

#: ../../docs/development/compiling/optimizing_for_size.rst:71
msgid "Some platforms such as WebAssembly already use this mode by default."
msgstr "某些平台(如WebAssembly)默认情况下已使用此模式。"

#: ../../docs/development/compiling/optimizing_for_size.rst:74
msgid "Compiling with link-time optimization"
msgstr "连接时间优化编译"

#: ../../docs/development/compiling/optimizing_for_size.rst:76
msgid ""
"Enabling link-time optimization produces more efficient binaries, both in "
"terms of performance and file size. It works by eliminating duplicate "
"template functions and unused code. It can currently be used with the GCC "
"and MSVC compilers:"
msgstr ""
"在性能和文件大小方面，启用链接时优化可以生成更高效的二进制文件。 它通过消除重"
"复的模板函数和未使用的代码来工作 它目前可以与GCC和MSVC编译器一起使用:"

#: ../../docs/development/compiling/optimizing_for_size.rst:85
msgid ""
"Linking becomes much slower with this option, so it should be used only for "
"release builds."
msgstr "使用此选项，链接变得慢得多，因此它应该仅用于发布版本。"

#: ../../docs/development/compiling/optimizing_for_size.rst:89
msgid "Stripping binaries"
msgstr "剥离二进制文件"

#: ../../docs/development/compiling/optimizing_for_size.rst:91
msgid ""
"If you build from source, remember to strip debug symbols from binaries:"
msgstr "如果从源代码构建，请记住从二进制文件中剥离调试符号:"

#: ../../docs/development/compiling/optimizing_for_size.rst:98
msgid "Using UPX to compress binaries"
msgstr "使用UPX压缩二进制文件"

#: ../../docs/development/compiling/optimizing_for_size.rst:100
msgid ""
"If you are targeting desktop platforms, the `UPX <https://upx.github.io/>`_ "
"compressor can be used. This can reduce binary size considerably."
msgstr ""
"如果您的目标是桌面平台，可以使用 `UPX <https://upx.github.io/>`_ 压缩器。 这"
"可以大大减少二进制大小。"

#: ../../docs/development/compiling/optimizing_for_size.rst:104
msgid ""
"However, keep in mind that some antivirus programs may detect UPX-packed "
"binaries as a virus. Therefore, if you are releasing a commercial game, make "
"sure to sign your binaries or use a platform that will distribute them."
msgstr ""
"但是，请记住，某些防病毒程序可能会将UPX打包的二进制文件检测为病毒。 因此，如"
"果您要发布商业游戏，请务必签署您的二进制文件或使用将分发它们的平台。"

#: ../../docs/development/compiling/compiling_with_script_encryption_key.rst:6
#, fuzzy
msgid "Compiling with script encryption key"
msgstr "连接时间优化编译"

#: ../../docs/development/compiling/compiling_with_script_encryption_key.rst:8
msgid ""
"The export dialog gives you the option to encrypt your scripts with an "
"256bit AES key, when releasing your game. This will make sure your scripts "
"are not stored in plain text and can not easily be ripped by some script "
"kiddie. Of course the key needs to be stored in the binary, but if it's "
"compiled, optimized and without symbols, it would take some effort to find "
"it."
msgstr ""

#: ../../docs/development/compiling/compiling_with_script_encryption_key.rst:14
msgid ""
"For this to work, you need to build the export templates from source, with "
"that same key."
msgstr ""

#: ../../docs/development/compiling/compiling_with_script_encryption_key.rst:18
#, fuzzy
msgid "Step by step (Linux)"
msgstr "入门教程"

#: ../../docs/development/compiling/compiling_with_script_encryption_key.rst:20
msgid ""
"Generate a 256bit AES key in HEX. You can use the aes-256-cbc variant from "
"`this service <https://asecuritysite.com/encryption/keygen>`_."
msgstr ""

#: ../../docs/development/compiling/compiling_with_script_encryption_key.rst:23
msgid "Alternatively, you can generate it yourself by using OpenSSL:"
msgstr ""

#: ../../docs/development/compiling/compiling_with_script_encryption_key.rst:29
#, fuzzy
msgid "This should output the following to ``godot.gdkey`` file:"
msgstr "将以下内容添加到``Globals.gd``:"

#: ../../docs/development/compiling/compiling_with_script_encryption_key.rst:37
msgid ""
"You can generate the key without redirecting the output to a file, but that "
"way you can minimize the risk of exposing the key."
msgstr ""

#: ../../docs/development/compiling/compiling_with_script_encryption_key.rst:41
msgid ""
"Set this key as environment variable in the console that you will use to "
"compile Godot, like this:"
msgstr ""

#: ../../docs/development/compiling/compiling_with_script_encryption_key.rst:49
msgid ""
"Compile Godot export templates and set them as custom export templates in "
"the export preset options."
msgstr ""

#: ../../docs/development/compiling/compiling_with_script_encryption_key.rst:52
msgid "Set the encryption key in the ``Script`` tab of the export preset:"
msgstr ""

#: ../../docs/development/compiling/compiling_with_script_encryption_key.rst:56
msgid "Export the project. The game should run with encrypted scripts now."
msgstr ""

#: ../../docs/development/compiling/compiling_with_script_encryption_key.rst:59
msgid "Possible Errors"
msgstr ""

#: ../../docs/development/compiling/compiling_with_script_encryption_key.rst:61
msgid ""
"If you get an error like below, it means the key wasn't properly included in "
"your Godot build. Godot is encrypting the scripts during export, but can't "
"read them at runtime."
msgstr ""

#: ../../docs/development/cpp/introduction_to_godot_development.rst:4
msgid "Introduction to Godot development"
msgstr "Godot 引擎开发介绍"

#: ../../docs/development/cpp/introduction_to_godot_development.rst:6
msgid ""
"This page is meant to introduce the global organization of Godot Engine's "
"source code, and give useful tips for extending/fixing the engine on the C++ "
"side."
msgstr ""
"本文旨在介绍 Godot 引擎的整体源代码的组织架构，以方便您在 C++ 端对引擎进行扩"
"展/修复。"

#: ../../docs/development/cpp/introduction_to_godot_development.rst:11
msgid "Architecture diagram"
msgstr "架构图"

#: ../../docs/development/cpp/introduction_to_godot_development.rst:13
msgid ""
"The following diagram describes the architecture used by Godot, from the "
"core components down to the abstracted drivers, via the scene structure and "
"the servers."
msgstr ""
"下图描述了 Godot 使用的架构，展示了从核心组件到抽象驱动的架构、场景结构和服务"
"服务结构。"

#: ../../docs/development/cpp/introduction_to_godot_development.rst:20
msgid "Debugging the editor with gdb"
msgstr "使用 gdb 调试编辑器"

#: ../../docs/development/cpp/introduction_to_godot_development.rst:22
msgid ""
"If you are writing or correcting bugs affecting Godot Engine's editor, "
"remember that the binary will by default run the project manager first, and "
"then only run the editor in another process once you've selected a project. "
"To launch a project directly, you need to run the editor by passing the ``-"
"e`` argument to Godot Engine's binary from within your project's folder. "
"Typically:"
msgstr ""
"如果您想修正 Godot 引擎的 bug 您在调试时需要注意，从您编译好的二进制文件启动 "
"Godot 引擎的编辑器，这将会启动项目管理器。当您在项目管理器中选择打开的项目"
"后，编辑器是从另一个进程启动的。 要直接通过编辑器启动您的项目，您需要在您的项"
"目目录下执行编辑器的时候传递 ``-e`` 参数。 通常是这样:"

#: ../../docs/development/cpp/introduction_to_godot_development.rst:35
msgid "Or:"
msgstr "或者:"

#: ../../docs/development/cpp/configuring_an_ide.rst:4
msgid "Configuring an IDE"
msgstr "配置集成开发环境(IDE)"

#: ../../docs/development/cpp/configuring_an_ide.rst:6
msgid ""
"We assume that you already `cloned <https://github.com/godotengine/godot>`_ "
"and :ref:`compiled <toc-devel-compiling>` Godot."
msgstr ""
"假设您已经能够 `克隆 <https://github.com/godotengine/godot>`_ 并 :ref:`编译 "
"<toc-devel-compiling>` Godot 了。"

#: ../../docs/development/cpp/configuring_an_ide.rst:9
msgid ""
"You can easily develop Godot with any text editor and by invoking ``scons`` "
"on the command line, but if you want to work with an IDE (Integrated "
"Development Environment), here are setup instructions for some popular ones:"
msgstr ""
"您可以使用任何文本编辑器和在命令行上调用 ``scons`` 轻松开发Godot，但是如果您"
"想使用IDE(集成开发环境)，这里有一些流行的设置说明:"

#: ../../docs/development/cpp/configuring_an_ide.rst:13
msgid ""
":ref:`Qt Creator <doc_configuring_an_ide_qtcreator>` (all desktop platforms)"
msgstr ":ref:`Qt Creator <doc_configuring_an_ide_qtcreator>` (所有桌面平台)"

#: ../../docs/development/cpp/configuring_an_ide.rst:14
msgid ""
":ref:`Kdevelop <doc_configuring_an_ide_kdevelop>` (all desktop platforms)"
msgstr ":ref:`Kdevelop <doc_configuring_an_ide_kdevelop>` (所有桌面平台)"

#: ../../docs/development/cpp/configuring_an_ide.rst:15
msgid ":ref:`Xcode <doc_configuring_an_ide_xcode>` (macOS)"
msgstr ":ref:`Xcode <doc_configuring_an_ide_xcode>` (macOS)"

#: ../../docs/development/cpp/configuring_an_ide.rst:16
msgid ":ref:`Visual Studio <doc_compiling_for_windows_install_vs>` (Windows)"
msgstr ":ref:`Visual Studio <doc_compiling_for_windows_install_vs>` (Windows)"

#: ../../docs/development/cpp/configuring_an_ide.rst:17
msgid ""
":ref:`Visual Studio Code<doc_configuring_an_ide_vscode>` (all desktop "
"platforms)"
msgstr ""
":ref:`Visual Studio Code <doc_configuring_an_ide_vscode>` (所有桌面平台)"

#: ../../docs/development/cpp/configuring_an_ide.rst:19
msgid ""
"It is possible to use other IDEs, but their setup is not documented yet."
msgstr "可以使用其他IDE，但尚未记录其设置。"

#: ../../docs/development/cpp/configuring_an_ide.rst:24
msgid "Qt Creator"
msgstr "Qt Creator"

#: ../../docs/development/cpp/configuring_an_ide.rst:27
msgid "Importing the project"
msgstr "导入项目"

#: ../../docs/development/cpp/configuring_an_ide.rst:29
msgid "Choose *New Project* -> *Import Project* -> *Import Existing Project*."
msgstr ""
"选择 *新建项目 (New Project)* -> *导入项目 (Import Project)* -> *导入现有项"
"目 (Import Existing Project)*。"

#: ../../docs/development/cpp/configuring_an_ide.rst:33
msgid "Set the path to your Godot root directory and enter the project name."
msgstr "把项目目录设置为 Godot 源码的根目录， 并输入项目名称。"

#: ../../docs/development/cpp/configuring_an_ide.rst:37
msgid ""
"Here you can choose which folders and files will be visible to the project. "
"C/C++ files are added automatically. Potentially useful additions: \\*.py "
"for buildsystem files, \\*.java for Android development, \\*.mm for macOS. "
"Click \"Next\"."
msgstr ""
"这里您可以选择哪些文件和文件夹可以在项目中可见。 C/C++文件默认自动添加为可"
"见， 此外有用的文件还有: 用于构建系统的 \\*.py 文件、 用于 Android 开发的 "
"\\*.java 文件、用于macOS的 \\*.mm 文件。 点击 “下一步 (Next)”。"

#: ../../docs/development/cpp/configuring_an_ide.rst:43
msgid "Click *Finish*."
msgstr "点击 *完成 (Finish)*。"

#: ../../docs/development/cpp/configuring_an_ide.rst:44
msgid ""
"Add a line containing ``.`` to *project_name.includes* to get working code "
"completion."
msgstr ""
"在 *项目名.includes* 文件中添加新行 ``.`` 让QtCreator能够正确解析引擎代码。"

#: ../../docs/development/cpp/configuring_an_ide.rst:49
msgid "Build and run"
msgstr "构建和运行"

#: ../../docs/development/cpp/configuring_an_ide.rst:51
msgid "Build configuration:"
msgstr "构建配置:"

#: ../../docs/development/cpp/configuring_an_ide.rst:53
msgid "Click on *Projects* and open the *Build* tab."
msgstr "点击 *项目 (Projects)* 并打开 *构建(Build)* 切页。"

#: ../../docs/development/cpp/configuring_an_ide.rst:54
msgid "Delete the pre-defined ``make`` build step."
msgstr "删除预先定义的 ``make`` 构建步骤。"

#: ../../docs/development/cpp/configuring_an_ide.rst:58
msgid "Click *Add Build Step* -> *Custom Process Step*."
msgstr ""
"点击 *添加构建步骤 (Add Build Step)* -> *自定义构建步骤 (Custom Process "
"Step)*。"

#: ../../docs/development/cpp/configuring_an_ide.rst:62
msgid ""
"Type ``scons`` in the *Command* field. If it fails with 'Could not start "
"process \"scons\"', it can mean that ``scons`` is not in your ``PATH`` "
"environment variable, so you may have to use the full path to the SCons "
"binary."
msgstr ""
"在* Command *字段中输入 ``scons`` 。 如果它失败并且“无法启动进程”scons“'，则"
"可能意味着 ``scons`` 不在您的 ``PATH`` 环境变量中，因此您可能必须使用SCons二"
"进制文件的完整路径。"

#: ../../docs/development/cpp/configuring_an_ide.rst:65
msgid ""
"Fill the *Arguments* field with your compilation options. (e.g.: ``p=x11 "
"target=debug -j 4``)"
msgstr ""
"在 *参数(Arguments)* 栏填入您的构建选项。(例如: ``p=x11 target=debug -j 4``)"

#: ../../docs/development/cpp/configuring_an_ide.rst:69
msgid "Run configuration:"
msgstr "运行配置:"

#: ../../docs/development/cpp/configuring_an_ide.rst:71
msgid "Open the *Run* tab."
msgstr "打开 *运行(Run)* 切页。"

#: ../../docs/development/cpp/configuring_an_ide.rst:72
msgid ""
"Point the *Executable* to your compiled Godot binary (e.g: ``%{buildDir}/bin/"
"godot.x11.opt.tools.64``)"
msgstr ""
"将* Executable *指向编译的Godot二进制文件(例如:``％{buildDir} / bin / godot."
"x11.opt.tools.64``)"

#: ../../docs/development/cpp/configuring_an_ide.rst:73
msgid ""
"If you want to run a specific game or project, point *Working directory* to "
"the game directory."
msgstr ""
"如果您想启动指定的游戏或项目， 可以把 *工作目录(Working directory)* 设为您游"
"戏项目的目录。"

#: ../../docs/development/cpp/configuring_an_ide.rst:74
msgid ""
"If you want to run the editor, add ``-e`` to the *Command line arguments* "
"field."
msgstr ""
"如果您想调试编辑器， 可以在 *命令行参数(Command line arguments)* 栏中填入 ``-"
"e`` 。"

#: ../../docs/development/cpp/configuring_an_ide.rst:79
#, fuzzy
msgid "Updating sources after pulling latest commits"
msgstr "在提取最新提交后更新源"

#: ../../docs/development/cpp/configuring_an_ide.rst:81
msgid ""
"As a developer you usually want to frequently pull the latest commits from "
"the upstream git repository or a specific fork etc. However this brings a "
"little problem with it: as the development continues, source files (and "
"folders) are added or removed. These changes needs to be reflected in your "
"project files for Qt Creator too, so you continue to have a nice experience "
"coding in it. A simple way to check these things, is to right click at your "
"root folder in the \"Projects View\" and click on \"Edit files...\""
msgstr ""
"作为开发人员，您通常希望经常从上游git存储库或特定的fork等提取最新的提交。但是"
"这会带来一点问题:随着开发的继续，添加或删除源文件(和文件夹)。 这些更改也需要"
"反映在Qt Creator的项目文件中，因此您可以继续在其中进行编码。 检查这些内容的一"
"种简单方法是右键单击“项目视图”中的根文件夹，然后单击“编辑文件...”"

#: ../../docs/development/cpp/configuring_an_ide.rst:91
msgid ""
"Now a new dialog should appear that is similar in functionality to the one "
"in the third step of the \"Importing the project\" section. Here now you can "
"check whether you want to add/remove specific files and/or folders. You can "
"chose by clicking with your mouse or just simply by clicking the \"Apply "
"Filter\" button. A simple click on \"Ok\" and you're ready to continue your "
"work."
msgstr ""
"现在应该出现一个新的对话框，其功能类似于“导入项目”部分的第三步中的对话框。 现"
"在，您可以检查是否要添加/删除特定文件和/或文件夹。 您可以通过单击鼠标或单"
"击“应用过滤器”按钮进行选择。 只需单击“确定”，即可继续工作。"

#: ../../docs/development/cpp/configuring_an_ide.rst:99
msgid "Code style configuration"
msgstr "代码样式配置"

#: ../../docs/development/cpp/configuring_an_ide.rst:101
msgid ""
"Developers must follow the project's :ref:`code style "
"<doc_code_style_guidelines>` and IDE should help them to do it. By default, "
"Qt Creator does use spaces for indentation which is incorrect for Godot "
"project. You can change this behavior by changing the \"Code Style\" in "
"*Options* -> *C++*."
msgstr ""
"开发人员必须遵循以下项目 :ref:`code style <doc_code_style_guidelines>` ，IDE"
"应该帮助他们做到这一点。 默认情况下，Qt Creator确实使用空格进行缩进，这对于"
"Godot项目是不正确的。 您可以通过更改* Options *  -> * C++ *中的“Code Style”来"
"更改此行为。"

#: ../../docs/development/cpp/configuring_an_ide.rst:108
msgid ""
"Click on *Edit* to change the current settings, then click on *Copy Built-in "
"Code Style* button to set a new code style. Set a name for it (e.g. Godot) "
"and change the Tab policy to be *Tabs Only*."
msgstr ""
"单击 *编辑* 以更改当前设置，然后单击 *复制内置代码样式* 按钮以设置新的代码样"
"式。 为它设置一个名称(例如Godot)并将Tab策略更改为* Tabs Only *。"

#: ../../docs/development/cpp/configuring_an_ide.rst:117
msgid "KDevelop"
msgstr "KDevelop"

#: ../../docs/development/cpp/configuring_an_ide.rst:119
msgid ""
"`KDevelop <https://www.kdevelop.org>`_ is a free, open source IDE for all "
"desktop platforms."
msgstr ""
"`KDevelop <https://www.kdevelop.org>`_ 是一个适用于所有桌面平台的免费开源"
"IDE。"

#: ../../docs/development/cpp/configuring_an_ide.rst:121
msgid ""
"You can find a video tutorial `here <https://www.youtube.com/watch?"
"v=yNVoWQi9TJA>`_. Or you may follow this text version tutorial."
msgstr ""
"您可以在 `这儿 <https://www.youtube.com/watch?v=yNVoWQi9TJA>`_ 找到视频教程。"
"当然，您也可以只是跟着后面的教程做。"

#: ../../docs/development/cpp/configuring_an_ide.rst:124
msgid "Start by opening KDevelop and choosing \"open project\"."
msgstr "首先打开KDevelop并选择“开放项目”。"

#: ../../docs/development/cpp/configuring_an_ide.rst:128
msgid "Choose the directory where you cloned Godot."
msgstr "选择您克隆好的 Godot 源代码的目录。"

#: ../../docs/development/cpp/configuring_an_ide.rst:130
msgid ""
"On the next screen, choose \"Custom Build System\" for the *Project manager*."
msgstr "在下一个屏幕上，为 *项目经理* 选择“自定义构建系统”。"

#: ../../docs/development/cpp/configuring_an_ide.rst:134
msgid "Now that the project has been imported, open the project configuration."
msgstr "这样，我们的项目就成功导入到 Kdevelop 了， 现在打开项目配置。"

#: ../../docs/development/cpp/configuring_an_ide.rst:138
msgid "Add the following includes/imports:"
msgstr "添加下面这些头文件(导入)目录:"

#: ../../docs/development/cpp/configuring_an_ide.rst:151
msgid "Apply the changes."
msgstr "应用更改。"

#: ../../docs/development/cpp/configuring_an_ide.rst:153
msgid ""
"Switch to the \"Custom Build System\" tab. Add a build configuration and "
"keep the build directory blank. Enable build tools and add ``scons`` as the "
"executable then add ``platform=x11 target=debug`` (``platform=osx`` if "
"you're on macOS) as the arguments."
msgstr ""
"切换到“自定义构建系统”选项卡。 添加构建配置并将构建目录保留为空。 启用构建工"
"具并添加 ``scons`` 作为可执行文件，然后添加``platform = x11 target = "
"debug``(如果您在macOS上，``platform = osx``)作为参数。"

#: ../../docs/development/cpp/configuring_an_ide.rst:160
msgid ""
"Next we need to tell KDevelop where to find the binary. From the \"Run\" "
"menu, choose \"Configure Launches\"."
msgstr ""
"接下来我们需要告诉KDevelop在哪里找到二进制文件。 从“运行”菜单中，选择“配置启"
"动”。"

#: ../../docs/development/cpp/configuring_an_ide.rst:165
msgid ""
"Click \"Add\" if no launcher exists. Then add the path to your executable in "
"the executable section. Your executable should be located in the ``bin/`` "
"sub-directory and should be named something like ``godot.x11.tools.64`` (the "
"name could be different depending on your platform and depending on your "
"build options)."
msgstr ""
"如果没有启动器，请单击“添加”。 然后在可执行部分中添加可执行文件的路径。 您的"
"可执行文件应该位于``bin /``子目录中，应该命名为 ``godot.x11.tools.64`` (根据"
"您的平台和您的构建选项，名称可能会有所不同)。"

#: ../../docs/development/cpp/configuring_an_ide.rst:173
msgid "That's it! Now you should be good to go :)"
msgstr "好了，现在您可以启程了 :)"

#: ../../docs/development/cpp/configuring_an_ide.rst:179
msgid "Xcode"
msgstr "Xcode"

#: ../../docs/development/cpp/configuring_an_ide.rst:184
msgid "Create an Xcode external build project anywhere"
msgstr "使用 Xcode 在任意位置创建一个外部构建项目(external build project )"

#: ../../docs/development/cpp/configuring_an_ide.rst:188
msgid "Set the *Build tool* to the path to scons"
msgstr "把 *构建工具(Build tool)* 设为 scons"

#: ../../docs/development/cpp/configuring_an_ide.rst:190
msgid "Modify Build Target's Xcode Info Tab:"
msgstr "修改构建目标的 Xcode 信息切页:"

#: ../../docs/development/cpp/configuring_an_ide.rst:192
msgid ""
"Set *Arguments* to something like: platform=osx tools=yes bits=64 "
"target=debug"
msgstr ""
"设置 *构建参数(Arguments)* 为类似这样: ``platform=osx tools=yes bits=64 "
"target=debug``"

#: ../../docs/development/cpp/configuring_an_ide.rst:193
msgid ""
"Set *Directory* to the path to Godot's source folder. Keep it blank if "
"project is already there."
msgstr ""
"把*目录(Directory)* 设置为 Godot 源代码的目录，如果您的项目就在这个目录下可以"
"留空。"

#: ../../docs/development/cpp/configuring_an_ide.rst:194
msgid "You may uncheck *Pass build settings in environment*"
msgstr "您可以取消勾选  *Pass build settings in environment*"

#: ../../docs/development/cpp/configuring_an_ide.rst:198
msgid "Add a Command Line Target:"
msgstr "添加命令行目标(Command Line Target):"

#: ../../docs/development/cpp/configuring_an_ide.rst:200
msgid ""
"Go to Xcode File > New > Target... and add a new Xcode command line target"
msgstr "前往 Xcode File > New > Target... 添加新的命令行目标"

#: ../../docs/development/cpp/configuring_an_ide.rst:206
msgid "Name it something so you know not to compile with this target"
msgstr "给它取一个比较合适的编译目标的名字"

#: ../../docs/development/cpp/configuring_an_ide.rst:207
msgid "e.g. ``GodotXcodeIndex``"
msgstr "例如: ``GodotXcodeIndex``"

#: ../../docs/development/cpp/configuring_an_ide.rst:208
msgid ""
"Goto the newly created target's *Build Settings* tab and search for *Header "
"Search Paths*"
msgstr ""
"前往新创建目标(target) 的 *Build Settings* 切页， 搜索 *Header Search Paths*"

#: ../../docs/development/cpp/configuring_an_ide.rst:209
msgid "Set *Header Search Paths* to an absolute path to Godot's source folder"
msgstr "设置 *Header Search Paths*  为您的 Godot 源代码目录的绝对路径"

#: ../../docs/development/cpp/configuring_an_ide.rst:210
msgid "Make it recursive by adding two \\*'s to the end of the path"
msgstr "添加两个 \\* 表示递归查找源码目录下的文件"

#: ../../docs/development/cpp/configuring_an_ide.rst:211
msgid "e.g. ``/Users/me/repos/godot-source/\\**``"
msgstr "如 ``/Users/me/repos/godot-source/\\**``"

#: ../../docs/development/cpp/configuring_an_ide.rst:213
msgid "Add Godot Source to the Project:"
msgstr "把 Godot 源码添加到项目:"

#: ../../docs/development/cpp/configuring_an_ide.rst:215
msgid "Drag and drop Godot source into project file browser."
msgstr "将Godot源拖放到项目文件浏览器中。"

#: ../../docs/development/cpp/configuring_an_ide.rst:216
msgid "Uncheck *Create External Build System*"
msgstr "取消勾选 *Create External Build System*"

#: ../../docs/development/cpp/configuring_an_ide.rst:220
msgid "Click Next"
msgstr "点击 Next"

#: ../../docs/development/cpp/configuring_an_ide.rst:221
msgid "Select *create groups*"
msgstr "选择 *create groups*"

#: ../../docs/development/cpp/configuring_an_ide.rst:225
msgid "Check off only your command line target in the *Add to targets* section"
msgstr "在 * Add to targets * 中只选择添加到我们建立的命令行目标"

#: ../../docs/development/cpp/configuring_an_ide.rst:226
msgid "Click finish. Xcode will now index the files."
msgstr "点击 Finish。 Xcode将会开始索引文件。"

#: ../../docs/development/cpp/configuring_an_ide.rst:227
msgid "Grab a cup of coffee... Maybe make something to eat, too"
msgstr "喝一杯咖啡...或者先吃点其他的东西等待一下"

#: ../../docs/development/cpp/configuring_an_ide.rst:228
msgid ""
"You should have jump to definition, auto completion, and full syntax "
"highlighting when it is done."
msgstr "完成之后，您就可以使用代码跳转、自动补全、语法高亮等功能了。"

#: ../../docs/development/cpp/configuring_an_ide.rst:231
#, fuzzy
msgid "Scheme setup"
msgstr "设置 Scheme"

#: ../../docs/development/cpp/configuring_an_ide.rst:233
msgid "Edit Build Scheme of External Build Target:"
msgstr "编辑外部构建目标的构建方案:"

#: ../../docs/development/cpp/configuring_an_ide.rst:235
msgid "Open scheme editor of external build target"
msgstr "从外部构建目标中打开 scheme  编辑器"

#: ../../docs/development/cpp/configuring_an_ide.rst:236
msgid "Expand the *Build* menu"
msgstr "展开 *Build* 菜单"

#: ../../docs/development/cpp/configuring_an_ide.rst:237
msgid "Goto *Post Actions*"
msgstr "前往 *Post Actions*"

#: ../../docs/development/cpp/configuring_an_ide.rst:238
msgid ""
"Add a new script run action, select your project in ``Provide build settings "
"from`` as this allows you to use ``${PROJECT_DIR}`` variable."
msgstr ""
"添加新的脚本动作， 在 ``Provide build settings from``  中选择您项目， 这样您"
"就可以使用 ``${PROJECT_DIR}`` 变量了。"

#: ../../docs/development/cpp/configuring_an_ide.rst:242
msgid "Write a script that gives the binary a name that Xcode will recognize"
msgstr "编写一段脚本让Xcode能够认识我们构建的的二进制文件"

#: ../../docs/development/cpp/configuring_an_ide.rst:243
msgid ""
"e.g. ``ln -f ${PROJECT_DIR}/godot/bin/godot.osx.tools.64 ${PROJECT_DIR}/"
"godot/bin/godot``"
msgstr ""
"如 ``ln -f ${PROJECT_DIR}/godot/bin/godot.osx.tools.64 ${PROJECT_DIR}/godot/"
"bin/godot``"

#: ../../docs/development/cpp/configuring_an_ide.rst:244
msgid "Build the external build target"
msgstr "构建外部构建目标"

#: ../../docs/development/cpp/configuring_an_ide.rst:246
msgid "Edit Run Scheme of External Build Target:"
msgstr "编辑您的构建外部构建目标的运行方案:"

#: ../../docs/development/cpp/configuring_an_ide.rst:248
msgid "Open the scheme editor again"
msgstr "再次打开 scheme  编辑器"

#: ../../docs/development/cpp/configuring_an_ide.rst:249
msgid "Click Run"
msgstr "点击运行"

#: ../../docs/development/cpp/configuring_an_ide.rst:253
msgid ""
"Set the *Executable* to the file you linked in your post build action script"
msgstr "设置 *Executable* 为您编写的构建动作脚本"

#: ../../docs/development/cpp/configuring_an_ide.rst:254
msgid "Check *Debug executable* if it isn't already"
msgstr "勾选 *Debug executable*"

#: ../../docs/development/cpp/configuring_an_ide.rst:255
msgid ""
"You can go to *Arguments* tab and add an -e and a -path to a project to "
"debug the editor not the project selection screen"
msgstr ""
"您可以前往 *Arguments*  切页然后添加 ``-e`` 和 ``-path`` 到您的项目，来调试编"
"辑器"

#: ../../docs/development/cpp/configuring_an_ide.rst:258
msgid "Test it:"
msgstr "测试:"

#: ../../docs/development/cpp/configuring_an_ide.rst:260
msgid "Set a breakpoint in platform/osx/godot_main_osx.mm"
msgstr "在 platform/osx/godot_main_osx.mm 文件中设置一个断点"

#: ../../docs/development/cpp/configuring_an_ide.rst:261
msgid "It should break at the point!"
msgstr "这应该能够触发您下的断点！"

#: ../../docs/development/cpp/configuring_an_ide.rst:269
msgid ""
"Ensure that C/C++ extension is installed. You can find instructions in `docs "
"<https://code.visualstudio.com/docs/languages/cpp>`_."
msgstr ""
"确保已安装C / C++扩展。 您可以在`docs <https://code.visualstudio.com/docs/"
"languages/cpp>`_ 中找到相关说明。"

#: ../../docs/development/cpp/configuring_an_ide.rst:271
msgid "Now open cloned godot folder in VS Code (File > Open Folder...)"
msgstr "现在在VS Code中打开克隆的godot文件夹(文件>打开文件夹...)"

#: ../../docs/development/cpp/configuring_an_ide.rst:273
msgid ""
"In order to build the project, we need configurations files: *launch.json* "
"and *tasks.json*. To create them:"
msgstr ""
"为了构建项目，我们需要配置文件:* launch.json *和* tasks.json *。 要创建它们:"

#: ../../docs/development/cpp/configuring_an_ide.rst:276
msgid "Open Debug view (Ctrl + Shift + D) and select cogwheel with orange dot:"
msgstr "打开Debug视图(Ctrl + Shift + D)并选择带橙色点的齿轮:"

#: ../../docs/development/cpp/configuring_an_ide.rst:280
msgid ""
"Select *C++ (GDB/LLDB)* (it might be slightly differently called on macOS or "
"Windows)"
msgstr "选择* C++(GDB / LLDB)*(在macOS或Windows上可能略有不同)"

#: ../../docs/development/cpp/configuring_an_ide.rst:282
msgid "Update *launch.json* to match:"
msgstr "更新* launch.json *以匹配:"

#: ../../docs/development/cpp/configuring_an_ide.rst:286
msgid ""
"(Note that *godot.x11.tools.64* in \"program\" value might be differently "
"called on macOS or Windows)"
msgstr ""
"(注意，“program”值中的* godot.x11.tools.64 *可能在macOS或Windows上被不同地调"
"用)"

#: ../../docs/development/cpp/configuring_an_ide.rst:288
msgid ""
"Create *tasks.json* by starting Debug process (F5). VS Code will show dialog "
"with *Configure Task* button. Tap it and select *Create tasks.json file from "
"template*, then select *Others*"
msgstr ""
"通过启动调试过程(F5)创建* tasks.json *。 VS Code将显示带有* Configure Task *"
"按钮的对话框。 点击它并从模板*中选择*创建tasks.json文件，然后选择*其他*"

#: ../../docs/development/cpp/configuring_an_ide.rst:290
msgid "Update *tasks.json* to match:"
msgstr "更新* tasks.json *以匹配:"

#: ../../docs/development/cpp/configuring_an_ide.rst:294
msgid "(Note that *platform=x11* will be different for macOX and Windows)"
msgstr "(注意* platform = x11 *对于macOX和Windows会有所不同)"

#: ../../docs/development/cpp/configuring_an_ide.rst:296
msgid "You can now start Debug process again to test that everything works."
msgstr "您现在可以再次启动调试过程以测试一切正常。"

#: ../../docs/development/cpp/configuring_an_ide.rst:298
#, fuzzy
msgid ""
"If the build phase fails, check console for hints. On Linux it's most likely "
"that some dependencies are missing. Check :ref:`Compiling for X11 (Linux, "
"\\*BSD) <doc_compiling_for_x11>`"
msgstr ""
"如果构建阶段失败，请检查控制台是否有提示。 在Linux上，很可能缺少某些依赖项。 "
"检查 :ref:`编译X11(Linux，\\ * BSD)<doc_compiling_for_x11>`"

#: ../../docs/development/cpp/core_types.rst:4
msgid "Core types"
msgstr "核心类型"

#: ../../docs/development/cpp/core_types.rst:6
msgid ""
"Godot has a rich set of classes and templates that compose its core, and "
"everything is built upon them."
msgstr "Godot有丰富的用来撰写它的核心的类和模板集，所有的东西都基于它们构建。"

#: ../../docs/development/cpp/core_types.rst:9
msgid ""
"This reference will try to list them in order for their better understanding."
msgstr "这份参考将试着按顺序列出它们，使之更容易被理解。"

#: ../../docs/development/cpp/core_types.rst:13
msgid "Definitions"
msgstr "定义"

#: ../../docs/development/cpp/core_types.rst:15
msgid ""
"Godot uses the standard C98 datatypes, such as ``uint8_t``, ``uint32_t``, "
"``int64_t``, etc. which are nowadays supported by every compiler. "
"Reinventing the wheel for those is not fun, as it makes code more difficult "
"to read."
msgstr ""
"Godot使用标准的C98数据类型，例如 ``uint8_t`` ，``uint32_t``， ``int64_t`` "
"等，现在每个编译器都支持这些数据类型。 为那些重新发明轮子并不好玩，因为它使代"
"码更难以阅读。"

#: ../../docs/development/cpp/core_types.rst:20
msgid ""
"In general, care is not taken to use the most efficient datatype for a given "
"task unless using large structures or arrays. ``int`` is used through most "
"of the code unless necessary. This is done because nowadays every device has "
"at least a 32 bits bus and can do such operations in one cycle. It makes "
"code more readable too."
msgstr ""
"通常，除非使用大型结构或数组，否则不要小心使用给定任务的最有效数据类型。 除非"
"必要，否则 ``int`` 用于大多数代码。 这样做是因为现在每个设备至少具有32位总线"
"并且可以在一个周期中执行这样的操作。 它使代码更具可读性。"

#: ../../docs/development/cpp/core_types.rst:26
msgid ""
"For files or memory sizes, ``size_t`` is used, which is warranted to be 64 "
"bits."
msgstr "对于文件或内存大小，使用 ``size_t`` ，保证为64位。"

#: ../../docs/development/cpp/core_types.rst:29
msgid ""
"For Unicode characters, CharType instead of wchar_t is used, because many "
"architectures have 4 bytes long wchar_t, where 2 bytes might be desired. "
"However, by default, this has not been forced and CharType maps directly to "
"wchar_t."
msgstr ""
"对于Unicode字符，使用CharType而不是wchar_t，因为许多体系结构具有4个字节长的"
"wchar_t，其中可能需要2个字节。 但是，默认情况下，这不会被强制，CharType会直接"
"映射到wchar_t。"

#: ../../docs/development/cpp/core_types.rst:35
#: ../../docs/development/cpp/core_types.rst:132
#: ../../docs/development/cpp/core_types.rst:166
#: ../../docs/development/cpp/core_types.rst:182
#: ../../docs/development/cpp/core_types.rst:198
#: ../../docs/development/cpp/core_types.rst:209
#: ../../docs/development/cpp/core_types.rst:220
#: ../../docs/development/cpp/core_types.rst:233
#: ../../docs/development/cpp/variant_class.rst:38
#: ../../docs/development/cpp/variant_class.rst:57
#: ../../docs/development/cpp/object_class.rst:31
#: ../../docs/development/cpp/object_class.rst:89
#: ../../docs/development/cpp/object_class.rst:251
#: ../../docs/development/cpp/object_class.rst:267
#: ../../docs/development/cpp/object_class.rst:288
#: ../../docs/development/cpp/object_class.rst:307
#: ../../docs/development/cpp/custom_audiostreams.rst:23
#: ../../docs/development/cpp/custom_audiostreams.rst:117
#: ../../docs/development/cpp/custom_audiostreams.rst:348
#: ../../docs/development/cpp/custom_godot_servers.rst:475
msgid "References:"
msgstr "参阅资料:"

#: ../../docs/development/cpp/core_types.rst:37
msgid ""
"`core/typedefs.h <https://github.com/godotengine/godot/blob/master/core/"
"typedefs.h>`__"
msgstr ""
"`core / typedefs.h <https://github.com/godotengine/godot/blob/master/core/"
"typedefs.h>`__"

#: ../../docs/development/cpp/core_types.rst:40
msgid "Memory model"
msgstr "内存模型"

#: ../../docs/development/cpp/core_types.rst:42
msgid ""
"PC is a wonderful architecture. Computers often have gigabytes of RAM, "
"terabytes of storage and gigahertz of CPU, and when an application needs "
"more resources the OS will swap out the inactive ones. Other architectures "
"(like mobile or consoles) are in general more limited."
msgstr ""
"PC有一个很棒的架构。计算机通常具有数十亿字节的RAM，数TB的存储空间，和千兆赫兹"
"的处理器，当应用程序需要更多资源时，操作系统将交换出不活动的资源。其他架构(如"
"移动设备或游戏主机)在这方面通常有很多限制。"

#: ../../docs/development/cpp/core_types.rst:47
msgid ""
"The most common memory model is the heap, where an application will request "
"a region of memory, and the underlying OS will try to fit it somewhere and "
"return it. This often works best and is flexible, but over time and with "
"abuse, this can lead to segmentation."
msgstr ""
"最常见的内存模型是堆，应用程序会从中请求一块内存区域，底层操作系统会试着从某"
"处找到一块这样的内存并返回它。这通常运作得很好不会出岔子，但随着时间的推移或"
"者被滥用，也可能导致堆被切分得乱七八糟。"

#: ../../docs/development/cpp/core_types.rst:52
msgid ""
"Segmentation slowly creates holes that are too small for most common "
"allocations, so that memory is wasted. There is a lot of literature about "
"heap and segmentation, so this topic will not be developed further here. "
"Modern operating systems use paged memory, which helps mitigate the problem "
"of segmentation but doesn't solve it."
msgstr ""
"随着更多的常规分配，这样的切分会慢慢创建出许多过小的内存空洞，从而使内存被浪"
"费掉。关于堆和切分的文献有很多，所以这个就不做展开讨论。现代操作系统使用了分"
"页内存，这有助于缓解切分问题，但也不是说能完全解决问题。"

#: ../../docs/development/cpp/core_types.rst:58
msgid ""
"However, in many studies and tests, it is shown that given enough memory, if "
"the maximum allocation size is below a given threshold in proportion to the "
"maximum heap size and proportion of memory intended to be unused, "
"segmentation will not be a problem over time as it will remain constant. In "
"other words, leave 10-20% of your memory free and perform all small "
"allocations and you are fine."
msgstr ""
"然而，许多的研究和测试显示出，在给出足够内存的情况下，如果实际最大分配大小，"
"与堆的最大大小比较，所占比例低于一个阈值，或者说内存中还有一定比例未使用内存"
"时，堆被切分这件事就不会随着时间的推移成为问题。换句话说，留出10-20％的内存空"
"间，再执行小额内存分配，您也没事。"

#: ../../docs/development/cpp/core_types.rst:65
msgid ""
"Godot ensures that all objects that can be allocated dynamically are small "
"(less than a few kb at most). But what happens if an allocation is too large "
"(like an image or mesh geometry or large array)? In this case Godot has the "
"option to use a dynamic memory pool. This memory needs to be locked to be "
"accessed, and if an allocation runs out of memory, the pool will be "
"rearranged and compacted on demand. Depending on the need of the game, the "
"programmer can configure the dynamic memory pool size."
msgstr ""
"Godot确保所有的可动态分配的对象都很小(最多不到几kb)。但是如果出现很大的分配"
"(像图像、网格几何数据或大数组)，会怎样呢？在这种情况下，Godot可以选择使用动态"
"内存池。内存会被锁定以进行访问操作；如果内存不足，则内存池会根据需要进行重新"
"排列和压缩。根据游戏的需要，程序员可以配置动态内存池的大小。"

#: ../../docs/development/cpp/core_types.rst:74
msgid "Allocating memory"
msgstr "内存分配"

#: ../../docs/development/cpp/core_types.rst:76
msgid ""
"Godot has many tools for tracking memory usage in a game, especially during "
"debug. Because of this, the regular C and C++ library calls should not be "
"used. Instead, a few other ones are provided."
msgstr ""
"Godot有许多工具可用于跟踪游戏中的内存使用情况，尤其是在调试期间。因此，不应使"
"用常规的C和C++库调用。相反，Godot提供了一些其它的供您使用。"

#: ../../docs/development/cpp/core_types.rst:80
msgid "For C-style allocation, Godot provides a few macros:"
msgstr "Godot提供了一些宏可以用来处理C风格的内存分配:"

#: ../../docs/development/cpp/core_types.rst:88
msgid ""
"These are equivalent to the usual malloc, realloc, free of the standard C "
"library."
msgstr "这些等同于通常的malloc，realloc，不含标准C库。"

#: ../../docs/development/cpp/core_types.rst:91
msgid "For C++-style allocation, special macros are provided:"
msgstr "这些宏可以用来处理C++风格的内存分配:"

#: ../../docs/development/cpp/core_types.rst:101
msgid "which are equivalent to new, delete, new[] and delete[]."
msgstr "他们对应了new，delete，new[]和delete[]。"

#: ../../docs/development/cpp/core_types.rst:103
msgid ""
"memnew/memdelete also use a little C++ magic and notify Objects right after "
"they are created, and right before they are deleted."
msgstr ""
"memnew/memdelete也使用一点C++的小技巧，在创建或删除对象之后，会立即通知对象"
"池。"

#: ../../docs/development/cpp/core_types.rst:106
msgid ""
"For dynamic memory, the PoolVector<> template is provided. PoolVector is a "
"standard vector class, and is very similar to vector in the C++ standard "
"library. To create a PoolVector buffer, use this:"
msgstr ""
"对于动态内存，提供了PoolVector <>模板。 PoolVector是一个标准的向量类，与C++标"
"准库中的vector非常相似。 要创建PoolVector缓冲区，请使用以下命令:"

#: ../../docs/development/cpp/core_types.rst:114
msgid ""
"PoolVector can be accessed using the [] operator and a few helpers exist for "
"this:"
msgstr "可以使用[]运算符访问PoolVector，并且存在一些帮助:"

#: ../../docs/development/cpp/core_types.rst:126
msgid ""
"These operations allow fast read/write from PoolVectors and keep it locked "
"until they go out of scope. However, PoolVectors should be used for small, "
"dynamic memory operations, as read() and write() are too slow for a large "
"amount of accesses."
msgstr ""
"这些操作允许从PoolVectors快速读/写并保持锁定直到它们超出范围。 但是，"
"PoolVectors应该用于小型动态内存操作，因为read()和write()对于大量访问来说太慢"
"了。"

#: ../../docs/development/cpp/core_types.rst:134
msgid ""
"`core/os/memory.h <https://github.com/godotengine/godot/blob/master/core/os/"
"memory.h>`__"
msgstr ""
"`core/os/memory.h <https://github.com/godotengine/godot/blob/master/core/os/"
"memory.h>`__"

#: ../../docs/development/cpp/core_types.rst:135
#, fuzzy
msgid ""
"`core/pool_vector.h <https://github.com/godotengine/godot/blob/master/core/"
"pool_vector.cpp>`__"
msgstr ""
"`core/vector.h <https://github.com/godotengine/godot/blob/master/core/vector."
"h>`__"

#: ../../docs/development/cpp/core_types.rst:138
msgid "Containers"
msgstr "容器"

#: ../../docs/development/cpp/core_types.rst:140
msgid "Godot provides also a set of common containers:"
msgstr "Godot 还提供了一系列通用的容器:"

#: ../../docs/development/cpp/core_types.rst:142
msgid "Vector"
msgstr "Vector"

#: ../../docs/development/cpp/core_types.rst:143
msgid "List"
msgstr "List"

#: ../../docs/development/cpp/core_types.rst:144
msgid "Set"
msgstr "Set"

#: ../../docs/development/cpp/core_types.rst:145
msgid "Map"
msgstr "Map"

#: ../../docs/development/cpp/core_types.rst:147
msgid ""
"They are simple and aim to be as minimal as possible, as templates in C++ "
"are often inlined and make the binary size much fatter, both in debug "
"symbols and code. List, Set and Map can be iterated using pointers, like "
"this:"
msgstr ""
"它们很简单，旨在尽可能小，因为C++中的模板经常被内联，并且在调试符号和代码中使"
"二进制大小更加丰富。 可以使用指针迭代List，Set和Map，如下所示:"

#: ../../docs/development/cpp/core_types.rst:158
msgid "The Vector<> class also has a few nice features:"
msgstr "使用Vector<> 类有这些好处:"

#: ../../docs/development/cpp/core_types.rst:160
msgid ""
"It does copy on write, so making copies of it is cheap as long as they are "
"not modified."
msgstr "它在写入时复制，因此只要它们没有被修改，就无需制作它的副本。"

#: ../../docs/development/cpp/core_types.rst:162
msgid ""
"It supports multi-threading, by using atomic operations on the reference "
"counter."
msgstr "它通过在引用计数器上使用原子操作来支持多线程。"

#: ../../docs/development/cpp/core_types.rst:168
msgid ""
"`core/vector.h <https://github.com/godotengine/godot/blob/master/core/vector."
"h>`__"
msgstr ""
"`core/vector.h <https://github.com/godotengine/godot/blob/master/core/vector."
"h>`__"

#: ../../docs/development/cpp/core_types.rst:169
msgid ""
"`core/list.h <https://github.com/godotengine/godot/blob/master/core/list."
"h>`__"
msgstr ""
"`core/list.h <https://github.com/godotengine/godot/blob/master/core/list."
"h>`__"

#: ../../docs/development/cpp/core_types.rst:170
msgid ""
"`core/set.h <https://github.com/godotengine/godot/blob/master/core/set.h>`__"
msgstr ""
"`core/set.h <https://github.com/godotengine/godot/blob/master/core/set.h>`__"

#: ../../docs/development/cpp/core_types.rst:171
msgid ""
"`core/map.h <https://github.com/godotengine/godot/blob/master/core/map.h>`__"
msgstr ""
"`core/map.h <https://github.com/godotengine/godot/blob/master/core/map.h>`__"

#: ../../docs/development/cpp/core_types.rst:176
msgid ""
"Godot also provides a String class. This class has a huge amount of "
"features, full Unicode support in all the functions (like case operations) "
"and utf8 parsing/extracting, as well as helpers for conversion and "
"visualization."
msgstr ""
"Godot 还提供了一个字符串类 String。 这个类有丰富的功能，支持 Unicode 字符"
"集。 还提供了一些通用的辅助功能(utf8 解析等)。"

#: ../../docs/development/cpp/core_types.rst:184
msgid ""
"`core/ustring.h <https://github.com/godotengine/godot/blob/master/core/"
"ustring.h>`__"
msgstr ""
"`core/ustring.h <https://github.com/godotengine/godot/blob/master/core/"
"ustring.h>`__"

#: ../../docs/development/cpp/core_types.rst:187
msgid "StringName"
msgstr "字符串名称"

#: ../../docs/development/cpp/core_types.rst:189
msgid ""
"StringNames are like a String, but they are unique. Creating a StringName "
"from a string results in a unique internal pointer for all equal strings. "
"StringNames are useful for using strings as identifier, as comparing them is "
"basically comparing a pointer."
msgstr ""
"字符串名称和字符串类似，不同的是它们是唯一的。使用同一个字符串创建的字符串名"
"称对象内部指向同一指针。 字符串名称在使用字符处作为标识符时会很有用，因为比较"
"它们的性能和比较两个指针接近。"

#: ../../docs/development/cpp/core_types.rst:194
msgid ""
"Creation of a StringName (especially a new one) is slow, but comparison is "
"fast."
msgstr "创建一个字符串名称(尤其是新的) 是慢的， 但比较它们是快的。"

#: ../../docs/development/cpp/core_types.rst:200
#, fuzzy
msgid ""
"`core/string_name.h <https://github.com/godotengine/godot/blob/master/core/"
"string_name.h>`__"
msgstr ""
"`core/string_db.h <https://github.com/godotengine/godot/blob/master/core/"
"string_db.h>`__"

#: ../../docs/development/cpp/core_types.rst:203
msgid "Math types"
msgstr "数学类型"

#: ../../docs/development/cpp/core_types.rst:205
msgid ""
"There are several linear math types available in the core/math directory."
msgstr "在core/math目录中，有几种线性代数常用的类型。"

#: ../../docs/development/cpp/core_types.rst:211
msgid ""
"`core/math <https://github.com/godotengine/godot/tree/master/core/math>`__"
msgstr ""
"`core/math <https://github.com/godotengine/godot/tree/master/core/math>`__"

#: ../../docs/development/cpp/core_types.rst:214
#: ../../docs/development/file_formats/tscn.rst:128
msgid "NodePath"
msgstr "节点路径"

#: ../../docs/development/cpp/core_types.rst:216
msgid ""
"This is a special datatype used for storing paths in a scene tree and "
"referencing them fast."
msgstr "这是一种特殊的数据类型，用于在场景树中存储路径并快速引用它们。"

#: ../../docs/development/cpp/core_types.rst:222
msgid ""
"`core/node_path.h <https://github.com/godotengine/godot/blob/master/core/"
"node_path.h>`__"
msgstr ""
"`core/node_path.h <https://github.com/godotengine/godot/blob/master/core/"
"node_path.h>`__"

#: ../../docs/development/cpp/core_types.rst:225
msgid "RID"
msgstr "RID"

#: ../../docs/development/cpp/core_types.rst:227
msgid ""
"RIDs are resource IDs. Servers use these to reference data stored in them. "
"RIDs are opaque, meaning that the data they reference can't be accessed "
"directly. RIDs are unique, even for different types of referenced data."
msgstr ""
"RID是资源ID。服务器使用这些来引用存储在其中的数据。RID是不透明的，这意味着它"
"们引用的数据不能直接访问。RID是唯一的，甚至对于不同类型的引用数据也是如此。"

#: ../../docs/development/cpp/core_types.rst:235
#: ../../docs/development/cpp/custom_godot_servers.rst:319
msgid ""
"`core/rid.h <https://github.com/godotengine/godot/blob/master/core/rid.h>`__"
msgstr ""
"`core/rid.h <https://github.com/godotengine/godot/blob/master/core/rid.h>`__"

#: ../../docs/development/cpp/variant_class.rst:4
msgid "Variant class"
msgstr "变量类"

#: ../../docs/development/cpp/variant_class.rst:9
msgid ""
"Variant is the most important datatype of Godot, it's the most important "
"class in the engine. A Variant takes up only 20 bytes and can store almost "
"any engine datatype inside of it. Variants are rarely used to hold "
"information for long periods of time, instead they are used mainly for "
"communication, editing, serialization and generally moving data around."
msgstr ""
"Variant 是 Godot引 擎中最重要的数据类型，也是引擎中最重要的类。 一个 Variant "
"对象值占用 20 个字节内存，但它能够存储引擎中几乎所有的数据类型。 Variant 很少"
"用于长时间保存信息，而主要用于通信，编辑，序列化 和移动数据。"

#: ../../docs/development/cpp/variant_class.rst:16
msgid "A Variant can:"
msgstr "一个变种可以:"

#: ../../docs/development/cpp/variant_class.rst:18
msgid "Store almost any datatype"
msgstr "存储任意类型的数据"

#: ../../docs/development/cpp/variant_class.rst:19
msgid ""
"Perform operations between many variants (GDScript uses Variant as its "
"atomic/native datatype)."
msgstr ""
"在多个 Variant 对象间执行操作符运算 (GDScript 使用 Variant 作为原生最基础的数"
"据类型)。"

#: ../../docs/development/cpp/variant_class.rst:21
msgid "Be hashed, so it can be compared quickly to other variants"
msgstr "经过哈希处理，因此它能够与其他 Variant 对象进行快速比较"

#: ../../docs/development/cpp/variant_class.rst:22
msgid "Be used to convert safely between datatypes"
msgstr "用于在数据类型之间安全地转换"

#: ../../docs/development/cpp/variant_class.rst:23
msgid ""
"Be used to abstract calling methods and their arguments (Godot exports all "
"its functions through variants)"
msgstr "用于抽象调用方法及其参数(Godot通过变体导出其所有函数)"

#: ../../docs/development/cpp/variant_class.rst:25
msgid "Be used to defer calls or move data between threads."
msgstr "用于推迟调用或在线程之间交换数据。"

#: ../../docs/development/cpp/variant_class.rst:26
msgid "Be serialized as binary and stored to disk, or transferred via network."
msgstr "支持序列化为二进制格式，能被存储到磁盘或通过网络进行传输。"

#: ../../docs/development/cpp/variant_class.rst:28
msgid ""
"Be serialized to text and use it for printing values and editable settings."
msgstr "能被序列化为文本，用于输出值和编辑配置。"

#: ../../docs/development/cpp/variant_class.rst:30
msgid "Work as an exported property, so the editor can edit it universally."
msgstr "作为导出的属性， 这样编辑器能够使用统一的方式进行修改值。"

#: ../../docs/development/cpp/variant_class.rst:31
msgid "Be used for dictionaries, arrays, parsers, etc."
msgstr "能被用于字典、数组、解析器等等常用工具中。"

#: ../../docs/development/cpp/variant_class.rst:33
msgid ""
"Basically, thanks to the Variant class, writing Godot itself was a much, "
"much easier task, as it allows for highly dynamic constructs not common of C+"
"+ with little effort. Become a friend of Variant today."
msgstr ""
"基本上归功于Variant类，编写 Godot 本身变成了一件更加轻松的工作，因为它允许使"
"用 C++ 中不常见的高度动态构造，并只需要写很少的代码。 今天就和 Variant 成为朋"
"友吧。"

#: ../../docs/development/cpp/variant_class.rst:40
msgid ""
"`core/variant.h <https://github.com/godotengine/godot/blob/master/core/"
"variant.h>`__"
msgstr ""
"`core/variant.h <https://github.com/godotengine/godot/blob/master/core/"
"variant.h>`__"

#: ../../docs/development/cpp/variant_class.rst:43
msgid "Containers: Dictionary and Array"
msgstr "容器: 字典(Dictionary) 和 数组(Array)"

#: ../../docs/development/cpp/variant_class.rst:45
msgid ""
"Both are implemented using variants. A Dictionary can match any datatype "
"used as key to any other datatype. An Array just holds an array of Variants. "
"Of course, a Variant can also hold a Dictionary and an Array inside, making "
"it even more flexible."
msgstr "他们都是使用 Variant 实现的。"

#: ../../docs/development/cpp/variant_class.rst:50
msgid ""
"Modifications to a container will modify all references to it. A Mutex "
"should be created to lock it if multi threaded access is desired."
msgstr ""
"对容器的修改将修改对它的所有引用。 如果需要多线程访问，应创建互斥锁以锁定它。"

#: ../../docs/development/cpp/variant_class.rst:54
msgid ""
"Copy-on-write (COW) mode support for containers was dropped with Godot 3.0."
msgstr "Godot 3.0 删除了对容器的写时拷贝(COW)模式支持。"

#: ../../docs/development/cpp/variant_class.rst:59
msgid ""
"`core/dictionary.h <https://github.com/godotengine/godot/blob/master/core/"
"dictionary.h>`__"
msgstr ""
"`core/dictionary.h <https://github.com/godotengine/godot/blob/master/core/"
"dictionary.h>`__"

#: ../../docs/development/cpp/variant_class.rst:60
msgid ""
"`core/array.h <https://github.com/godotengine/godot/blob/master/core/array."
"h>`__"
msgstr ""
"`core/array.h <https://github.com/godotengine/godot/blob/master/core/array."
"h>`__"

#: ../../docs/development/cpp/object_class.rst:4
msgid "Object class"
msgstr "对象类"

#: ../../docs/development/cpp/object_class.rst:7
msgid "General definition"
msgstr "一般定义"

#: ../../docs/development/cpp/object_class.rst:9
msgid ""
":ref:`Object <class_object>` is the base class for almost everything. Most "
"classes in Godot inherit directly or indirectly from it. Objects provide "
"reflection and editable properties, and declaring them is a matter of using "
"a single macro like this."
msgstr ""
":ref:`Object <class_object>` 几乎是所有东西的基类。 Godot中的大多数类都直接或"
"间接地从它继承。 对象提供反射和可编辑属性，并声明它们是使用像这样的单个宏。"

#: ../../docs/development/cpp/object_class.rst:21
msgid "This makes Objects gain a lot of functionality, like for example"
msgstr "这使得Objects获得了很多功能，例如"

#: ../../docs/development/cpp/object_class.rst:33
msgid ""
"`core/object.h <https://github.com/godotengine/godot/blob/master/core/object."
"h>`__"
msgstr ""
"`core/object.h <https://github.com/godotengine/godot/blob/master/core/object."
"h>`__"

#: ../../docs/development/cpp/object_class.rst:36
msgid "Registering an Object"
msgstr "注册对象"

#: ../../docs/development/cpp/object_class.rst:38
msgid ""
"ClassDB is a static class that holds the entire list of registered classes "
"that inherit from Object, as well as dynamic bindings to all their methods "
"properties and integer constants."
msgstr ""
"ClassDB是一个静态类，它包含从Object继承的已注册类的完整列表，以及对其所有方法"
"属性和整数常量的动态绑定。"

#: ../../docs/development/cpp/object_class.rst:42
msgid "Classes are registered by calling:"
msgstr "通过调用来注册类:"

#: ../../docs/development/cpp/object_class.rst:48
msgid ""
"Registering it will allow the class to be instanced by scripts, code, or "
"creating them again when deserializing."
msgstr "注册它将允许通过脚本，代码实例化类，或在反序列化时再次创建它们。"

#: ../../docs/development/cpp/object_class.rst:51
msgid "Registering as virtual is the same but it can't be instanced."
msgstr "注册为虚拟是相同的，但它不能实例化。"

#: ../../docs/development/cpp/object_class.rst:57
msgid ""
"Object-derived classes can override the static function ``static void "
"_bind_methods()``. When one class is registered, this static function is "
"called to register all the object methods, properties, constants, etc. It's "
"only called once. If an Object derived class is instanced but has not been "
"registered, it will be registered as virtual automatically."
msgstr ""
"对象派生类可以覆盖静态函数``static void _bind_methods()``。 当一个类被注册"
"时，调用这个静态函数来注册所有对象方法，属性，常量等。它只被调用一次。 如果"
"Object派生类已实例但尚未注册，则它将自动注册为虚拟。"

#: ../../docs/development/cpp/object_class.rst:64
msgid ""
"Inside ``_bind_methods``, there are a couple of things that can be done. "
"Registering functions is one:"
msgstr "在 ``_bind_methods`` 里面，有几件事可以做。 注册功能是一个:"

#: ../../docs/development/cpp/object_class.rst:71
msgid "Default values for arguments can be passed in reverse order:"
msgstr "参数的默认值可以按相反的顺序传递:"

#: ../../docs/development/cpp/object_class.rst:77
msgid ""
"``D_METHOD`` is a macro that converts \"methodname\" to a StringName for "
"more efficiency. Argument names are used for introspection, but when "
"compiling on release, the macro ignores them, so the strings are unused and "
"optimized away."
msgstr ""
"``D_METHOD``是一个宏，它将“methodname”转换为StringName以提高效率。 参数名称用"
"于内省，但在发布时进行编译时，宏会忽略它们，因此字符串未使用并优化掉。"

#: ../../docs/development/cpp/object_class.rst:82
msgid "Check ``_bind_methods`` of Control or Object for more examples."
msgstr "有关更多示例，请查看Control或Object的 ``_bind_methods`` 。"

#: ../../docs/development/cpp/object_class.rst:84
msgid ""
"If just adding modules and functionality that is not expected to be "
"documented as thoroughly, the ``D_METHOD()`` macro can safely be ignored and "
"a string passing the name can be passed for brevity."
msgstr ""
"如果只是添加不希望被彻底记录的模块和功能，可以安全地忽略 ``D_METHOD()`` 宏，"
"并且为了简洁起见，可以传递传递名称的字符串。"

#: ../../docs/development/cpp/object_class.rst:91
msgid ""
"`core/class_db.h <https://github.com/godotengine/godot/blob/master/core/"
"class_db.h>`__"
msgstr ""
"`core/class_db.h <https://github.com/godotengine/godot/blob/master/core/"
"class_db.h>`__"

#: ../../docs/development/cpp/object_class.rst:96
msgid "Classes often have enums such as:"
msgstr "类通常有枚举，例如:"

#: ../../docs/development/cpp/object_class.rst:105
msgid ""
"For these to work when binding to methods, the enum must be declared "
"convertible to int, for this a macro is provided:"
msgstr ""
"为了使这些在绑定到方法时起作用，必须将枚举声明为可转换为int，为此提供了一个"
"宏:"

#: ../../docs/development/cpp/object_class.rst:112
msgid "The constants can also be bound inside ``_bind_methods``, by using:"
msgstr "常量也可以绑定在 ``_bind_methods`` 中，使用:"

#: ../../docs/development/cpp/object_class.rst:120
msgid "Properties (set/get)"
msgstr "属性(设置/获取)"

#: ../../docs/development/cpp/object_class.rst:122
msgid "Objects export properties, properties are useful for the following:"
msgstr "对象导出属性，属性对以下内容很有用:"

#: ../../docs/development/cpp/object_class.rst:124
msgid "Serializing and deserializing the object."
msgstr "序列化和反序列化对象。"

#: ../../docs/development/cpp/object_class.rst:125
msgid "Creating a list of editable values for the Object derived class."
msgstr "为Object派生类创建可编辑值列表。"

#: ../../docs/development/cpp/object_class.rst:127
msgid ""
"Properties are usually defined by the PropertyInfo() class. Usually "
"constructed as:"
msgstr "属性通常由PropertyInfo()类定义。 通常构造为:"

#: ../../docs/development/cpp/object_class.rst:140
msgid ""
"This is an integer property, named \"amount\", hint is a range, range goes "
"from 0 to 49 in steps of 1 (integers). It is only usable for the editor "
"(edit value visually) but won't be serialized."
msgstr ""
"这是一个整数属性，名为“amount”，提示是一个范围，范围从0到49，步长为1(整数)。 "
"它仅适用于编辑器(可视化编辑值)，但不会被序列化。"

#: ../../docs/development/cpp/object_class.rst:144
msgid "Another example:"
msgstr "另一个示例:"

#: ../../docs/development/cpp/object_class.rst:150
msgid ""
"This is a string property, can take any string but the editor will only "
"allow the defined hint ones. Since no usage flags were specified, the "
"default ones are PROPERTY_USAGE_STORAGE and PROPERTY_USAGE_EDITOR."
msgstr ""
"这是一个字符串属性，可以接受任何字符串，但编辑器只允许定义的提示字符串。 由于"
"未指定使用标志，因此默认值为PROPERTY_USAGE_STORAGE和PROPERTY_USAGE_EDITOR。"

#: ../../docs/development/cpp/object_class.rst:154
msgid ""
"There are plenty of hints and usage flags available in object.h, give them a "
"check."
msgstr "object.h中有很多提示和用法标志，给他们一张支票。"

#: ../../docs/development/cpp/object_class.rst:157
msgid ""
"Properties can also work like C# properties and be accessed from script "
"using indexing, but this usage is generally discouraged, as using functions "
"is preferred for legibility. Many properties are also bound with categories, "
"such as \"animation/frame\" which also make indexing impossible unless using "
"operator []."
msgstr ""
"属性也可以像C#属性一样工作，并且可以使用索引从脚本访问，但通常不鼓励这种用"
"法，因为使用函数是易读性的首选。 许多属性也与类别绑定，例如“动画/帧”，除非使"
"用operator []，否则也无法建立索引。"

#: ../../docs/development/cpp/object_class.rst:163
msgid ""
"From ``_bind_methods()``, properties can be created and bound as long as set/"
"get functions exist. Example:"
msgstr ""
"从 ``_bind_methods()`` 开始，只要存在set / get函数，就可以创建和绑定属性。 "
"例:"

#: ../../docs/development/cpp/object_class.rst:170
msgid "This creates the property using the setter and the getter."
msgstr "这将使用setter和getter创建属性。"

#: ../../docs/development/cpp/object_class.rst:173
msgid "Binding properties using ``_set``/``_get``/``_get_property_list``"
msgstr "使用``_set`` /``_get`` /``_get_property_list`绑定属性"

#: ../../docs/development/cpp/object_class.rst:175
msgid ""
"An additional method of creating properties exists when more flexibility is "
"desired (i.e. adding or removing properties on context)."
msgstr ""
"当需要更大的灵活性时(即在上下文中添加或删除属性)，存在另一种创建属性的方法。"

#: ../../docs/development/cpp/object_class.rst:178
msgid ""
"The following functions can be overridden in an Object derived class, they "
"are NOT virtual, DO NOT make them virtual, they are called for every "
"override and the previous ones are not invalidated (multilevel call)."
msgstr ""
"可以在Object派生类中重写以下函数，它们不是虚拟的，不要将它们设置为虚拟，它们"
"会在每次覆盖时调用，而前一个函数不会失效(多级调用)。"

#: ../../docs/development/cpp/object_class.rst:189
msgid ""
"This is also a little less efficient since ``p_property`` must be compared "
"against the desired names in serial order."
msgstr "这也有点效率低，因为必须将 ``p_property`` 与所需的名称按顺序进行比较。"

#: ../../docs/development/cpp/object_class.rst:193
msgid "Dynamic casting"
msgstr "动态铸造"

#: ../../docs/development/cpp/object_class.rst:195
msgid ""
"Godot provides dynamic casting between Object-derived classes, for example:"
msgstr "Godot在Object派生类之间提供动态转换，例如:"

#: ../../docs/development/cpp/object_class.rst:205
msgid ""
"If cast fails, NULL is returned. This system uses RTTI, but it also works "
"fine (although a bit slower) when RTTI is disabled. This is useful on "
"platforms where a small binary size is ideal, such as HTML5 or consoles "
"(with low memory footprint)."
msgstr ""
"如果强制转换失败，则返回NULL。 这个系统使用RTTI，但是当RTTI被禁用时它也可以正"
"常工作(虽然有点慢)。 这在小型二进制大小理想的平台上非常有用，例如HTML5或控制"
"台(内存占用少)。"

#: ../../docs/development/cpp/object_class.rst:213
msgid ""
"Objects can have a set of signals defined (similar to Delegates in other "
"languages). Connecting to them is rather easy:"
msgstr "对象可以定义一组信号(类似于其他语言的代理)。 连接它们很容易:"

#: ../../docs/development/cpp/object_class.rst:222
msgid ""
"The method ``_node_entered_tree`` must be registered to the class using "
"``ClassDB::register_method`` (explained before)."
msgstr ""
"必须使用``ClassDB :: register_method``(之前解释过)将方法"
"``_node_entered_tree``注册到类中。"

#: ../../docs/development/cpp/object_class.rst:225
msgid ""
"Adding signals to a class is done in ``_bind_methods``, using the "
"``ADD_SIGNAL`` macro, for example:"
msgstr "使用 ``ADD_SIGNAL`` 宏在 ``_bind_methods`` 中添加信号到类中，例如:"

#: ../../docs/development/cpp/object_class.rst:235
msgid ""
":ref:`Reference <class_reference>` inherits from Object and holds a "
"reference count. It is the base for reference counted object types. "
"Declaring them must be done using Ref<> template. For example:"
msgstr ""
":ref:`Reference <class_reference>` 继承自Object并保存引用计数。 它是引用计数"
"对象类型的基础。 必须使用Ref <>模板来声明它们。 例如:"

#: ../../docs/development/cpp/object_class.rst:247
msgid ""
"``myref`` is reference counted. It will be freed when no more Ref<> "
"templates point to it."
msgstr "``myref``是引用计数。 当没有更多Ref <>模板指向它时，它将被释放。"

#: ../../docs/development/cpp/object_class.rst:253
msgid ""
"`core/reference.h <https://github.com/godotengine/godot/blob/master/core/"
"reference.h>`__"
msgstr ""
"`core/reference.h <https://github.com/godotengine/godot/blob/master/core/"
"reference.h>`__"

#: ../../docs/development/cpp/object_class.rst:256
msgid "Resources:"
msgstr "资源:"

#: ../../docs/development/cpp/object_class.rst:258
msgid ""
":ref:`Resource <class_resource>` inherits from Reference, so all resources "
"are reference counted. Resources can optionally contain a path, which "
"reference a file on disk. This can be set with ``resource.set_path(path)``. "
"This is normally done by the resource loader though. No two different "
"resources can have the same path, attempt to do so will result in an error."
msgstr ""
":ref:`Resource <class_resource>` 继承自Reference，因此所有资源都被引用计数。 "
"资源可以选择包含引用磁盘上文件的路径。 这可以用 ``resource.set_path(path)`` "
"设置。 这通常由资源加载器完成。 没有两个不同的资源可以具有相同的路径，尝试这"
"样做会导致错误。"

#: ../../docs/development/cpp/object_class.rst:264
msgid "Resources without a path are fine too."
msgstr "没有路径的资源也很好。"

#: ../../docs/development/cpp/object_class.rst:269
msgid ""
"`core/resource.h <https://github.com/godotengine/godot/blob/master/core/"
"resource.h>`__"
msgstr ""
"`core/resource.h <https://github.com/godotengine/godot/blob/master/core/"
"resource.h>`__"

#: ../../docs/development/cpp/object_class.rst:272
msgid "Resource loading"
msgstr "资源加载"

#: ../../docs/development/cpp/object_class.rst:274
msgid "Resources can be loaded with the ResourceLoader API, like this:"
msgstr "可以使用ResourceLoader API加载资源，如下所示:"

#: ../../docs/development/cpp/object_class.rst:280
msgid ""
"If a reference to that resource has been loaded previously and is in memory, "
"the resource loader will return that reference. This means that there can be "
"only one resource loaded from a file referenced on disk at the same time."
msgstr ""
"如果先前已加载对该资源的引用并且该内容在内存中，则资源加载器将返回该引用。 这"
"意味着只能从磁盘上引用的文件同时加载一个资源。"

#: ../../docs/development/cpp/object_class.rst:285
msgid "resourceinteractiveloader (TODO)"
msgstr "resourceinteractiveloader(TODO)"

#: ../../docs/development/cpp/object_class.rst:290
msgid ""
"`core/io/resource_loader.h <https://github.com/godotengine/godot/blob/master/"
"core/io/resource_loader.h>`__"
msgstr ""
"`core/io/resource_loader.h <https://github.com/godotengine/godot/blob/master/"
"core/io/resource_loader.h>`__"

#: ../../docs/development/cpp/object_class.rst:293
msgid "Resource saving"
msgstr "资源保存"

#: ../../docs/development/cpp/object_class.rst:295
msgid "Saving a resource can be done with the resource saver API:"
msgstr "可以使用资源保护程序API保存资源:"

#: ../../docs/development/cpp/object_class.rst:301
msgid ""
"Instance will be saved. Sub resources that have a path to a file will be "
"saved as a reference to that resource. Sub resources without a path will be "
"bundled with the saved resource and assigned sub-IDs, like \"res://"
"someresource.res::1\". This also helps to cache them when loaded."
msgstr ""
"实例将被保存。 具有文件路径的子资源将保存为对该资源的引用。 没有路径的子资源"
"将与保存的资源和分配的子ID捆绑在一起，例如“res://someresource.res :: 1”。 这"
"也有助于在加载时缓存它们。"

#: ../../docs/development/cpp/object_class.rst:309
msgid ""
"`core/io/resource_saver.h <https://github.com/godotengine/godot/blob/master/"
"core/io/resource_saver.h>`__"
msgstr ""
"`core/io/resource_saver.h <https://github.com/godotengine/godot/blob/master/"
"core/io/resource_saver.h>`__"

#: ../../docs/development/cpp/inheritance_class_tree.rst:2
msgid "Inheritance class tree"
msgstr "继承类树"

#: ../../docs/development/cpp/inheritance_class_tree.rst:5
msgid "Object"
msgstr "Object"

#: ../../docs/development/cpp/inheritance_class_tree.rst:15
msgid "Control"
msgstr "Control"

#: ../../docs/development/cpp/inheritance_class_tree.rst:20
msgid "Node2D"
msgstr "Node2D"

#: ../../docs/development/cpp/inheritance_class_tree.rst:25
msgid "Spatial"
msgstr "空间的"

#: ../../docs/development/cpp/inheritance_class_tree.rst:29
msgid "Source files: :download:`class_tree.zip <files/class_tree.zip>`."
msgstr "源文件: :download:`class_tree.zip <files / class_tree.zip>`。"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:4
msgid "Custom modules in C++"
msgstr "C++ 模块"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:7
#: ../../docs/development/cpp/binding_to_external_libraries.rst:7
msgid "Modules"
msgstr "模块 (Modules)"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:9
msgid ""
"Godot allows extending the engine in a modular way. New modules can be "
"created and then enabled/disabled. This allows for adding new engine "
"functionality at every level without modifying the core, which can be split "
"for use and reuse in different modules."
msgstr ""
"Godot 允许通过模块化的方式对引擎进行扩展。 您可以创建新的模块，然后启用/禁用"
"它。 这允许在我们在各个级别为引擎添加新功能而无需修改引擎现的核心代码，各个模"
"块这可以拆分不同功能的便于现有代码复用。"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:14
msgid ""
"Modules are located in the ``modules/`` subdirectory of the build system. By "
"default, many different modules exist, such as GDScript (which, yes, is not "
"part of the base engine), the Mono runtime, a regular expressions module, "
"and others. As many new modules as desired can be created and combined, and "
"the SCons build system will take care of it transparently."
msgstr ""
"模块放在构建系统的 ``modules/`` 子目录下。 默认情况下这里已经存在多个不同的模"
"块如: GDScript 模块(没错，它不是引擎的核心部分，只是一个模块)、Mono 运行时模"
"块、 正则表达式模块、等等。即使我们不断创建和组合许多新模块，SCons 构建系统仍"
"能透明、轻松地处理它。"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:22
#: ../../docs/development/cpp/custom_resource_format_loaders.rst:24
#: ../../docs/development/cpp/custom_audiostreams.rst:29
#: ../../docs/development/cpp/custom_godot_servers.rst:26
msgid "What for?"
msgstr "用于做什么？"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:24
msgid ""
"While it's recommended that most of a game is written in scripting (as it is "
"an enormous time saver), it's perfectly possible to use C++ instead. Adding C"
"++ modules can be useful in the following scenarios:"
msgstr ""
"尽管我们建议使用脚本编写游戏的大部分代码(因为这能够节省大量的时间)，但使用 C+"
"+ 进行开发也是完全可能的。 我们推荐在以下情况下添加 C++ 模块:"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:28
msgid "Binding an external library to Godot (like PhysX, FMOD, etc)."
msgstr "绑定第三方库给 Godot 使用 (如 PhysX, FMOD 这类)。"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:29
msgid "Optimize critical parts of a game."
msgstr "优化游戏的核心部分。"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:30
msgid "Adding new functionality to the engine and/or editor."
msgstr "为引擎或编辑器添加新功能。"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:31
msgid "Porting an existing game."
msgstr "移植现有的游戏项目。"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:32
msgid "Write a whole, new game in C++ because you can't live without C++."
msgstr "使用 C++ 编写全部代码，因为您离不开 C++。"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:35
msgid "Creating a new module"
msgstr "创新新模块"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:37
msgid ""
"Before creating a module, make sure to download the source code of Godot and "
"manage to compile it. There are tutorials in the documentation for this."
msgstr ""
"在创建模块之前，请确认您能够下载并顺利编译 Godot 的源代码，您可以在本站找到相"
"关的文档。"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:40
msgid ""
"To create a new module, the first step is creating a directory inside "
"``modules/``. If you want to maintain the module separately, you can "
"checkout a different VCS into modules and use it."
msgstr ""
"要创建一个新模块，首先我们要在 ``modules/`` 文件夹下创建一个新目录。 如果需要"
"分开维护模块，则可以在 版本控制器(VCS) 中检出并使用新的分支。"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:44
msgid ""
"The example module will be called \"summator\", and is placed inside the "
"Godot source tree (``C:\\godot`` refers to wherever the Godot sources are "
"located):"
msgstr ""
"我们把这里的示例模块叫做 “summator”，并放置在 Godot 源代码目录中( 这里的 “C:"
"\\ godot” 指代Godot源所在的地方):"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:55
msgid "Inside we will create a simple summator class:"
msgstr "然后我们在里面创建一个简单的 summator  类:"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:83
msgid "And then the cpp file."
msgstr "这是该类的 cpp 文件。"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:117
msgid ""
"Then, the new class needs to be registered somehow, so two more files need "
"to be created:"
msgstr "为了把这个类注册给引擎使用，我们还需要创建另外两个文件:"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:125
#: ../../docs/development/cpp/binding_to_external_libraries.rst:76
msgid "With the following contents:"
msgstr "并填入下面的内容:"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:153
msgid ""
"Next, we need to create a ``SCsub`` file so the build system compiles this "
"module:"
msgstr "接下来我们要创建一个 ``SCsub`` 文件告诉构建系统如何编译这个模块:"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:163
msgid ""
"With multiple sources, you can also add each file individually to a Python "
"string list:"
msgstr ""
"如果您又多个源文件，您可以将要进行编译的源文件添加到一个 Python 的字符串数组"
"中:"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:171
msgid ""
"This allows for powerful possibilities using Python to construct the file "
"list using loops and logic statements. Look at some of the other modules "
"that ship with Godot by default for examples."
msgstr ""
"这允许使用Python使用循环和逻辑语句构造文件列表的强大可能性。 默认情况下，请查"
"看Godot附带的其他一些模块。"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:175
#: ../../docs/development/cpp/binding_to_external_libraries.rst:155
msgid ""
"To add include directories for the compiler to look at you can append it to "
"the environment's paths:"
msgstr "要添加头文件包含目录，您可以在构建环境中追加路径:"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:183
#: ../../docs/development/cpp/binding_to_external_libraries.rst:166
msgid ""
"If you want to add custom compiler flags when building your module, you need "
"to clone `env` first, so it won't add those flags to whole Godot build "
"(which can cause errors). Example `SCsub` with custom flags:"
msgstr ""
"如果您希望为您的模块添加自定义编译选项， 您可以克隆全局的构建环境 `env` ， 这"
"样您的构建选项就不会污染构建系统的其他部分了(污染全局构建环境玩玩会给您造成麻"
"烦)。 这里是一个使用了自定义编译选项的 `SCsub` 文件:"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:196
msgid ""
"And finally, the configuration file for the module, this is a simple python "
"script that must be named ``config.py``:"
msgstr ""
"最后还有一个叫作 ``config.py`` 的配置文件 , 这是一个简单的 python 脚本:"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:209
msgid ""
"The module is asked if it's ok to build for the specific platform (in this "
"case, True means it will build for every platform)."
msgstr ""
"询问该模块是否可以在特定平台上进行构建(在这里，True 表示能在所有平台上构建)。"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:212
msgid ""
"And that's it. Hope it was not too complex! Your module should look like "
"this:"
msgstr "希望它不是太复杂，您的模块应该是这样的:"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:224
msgid ""
"You can then zip it and share the module with everyone else. When building "
"for every platform (instructions in the previous sections), your module will "
"be included."
msgstr ""
"您现在可以压缩并与其他人分享这个模块了， 在所有平台上编译后您的模块都将被包含"
"在内。"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:229
#: ../../docs/development/cpp/binding_to_external_libraries.rst:197
#: ../../docs/development/cpp/creating_android_modules.rst:303
msgid "Using the module"
msgstr "使用模块"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:231
#: ../../docs/development/cpp/binding_to_external_libraries.rst:199
msgid "You can now use your newly created module from any script:"
msgstr "您现在可以在任何脚本中使用新创建的模块:"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:242
msgid "And the output will be ``60``."
msgstr "并且得到正确的输出 ``60``。"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:244
msgid ""
"The previous Summator example is great for small, custom modules, but what "
"if you want to use a larger, external library?  Refer to :ref:"
"`doc_binding_to_external_libraries` for details about binding to external "
"libraries."
msgstr ""
"之前的Summator示例非常适合小型自定义模块，但如果您想使用更大的外部库，该怎么"
"办？ 有关绑定到外部库的详细信息，请参阅 :ref:"
"`doc_binding_to_external_libraries`。"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:250
msgid "Improving the build system for development"
msgstr "完善模块开发的建设系统"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:252
msgid ""
"So far we defined a clean and simple SCsub that allows us to add the sources "
"of our new module as part of the Godot binary."
msgstr ""
"至此，我们定义了一个简洁的 SCsub 来允许我们向 Godot 的可执行文件通过模块添加"
"源代码。"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:255
msgid ""
"This static approach is fine when we want to build a release version of our "
"game given we want all the modules in a single binary."
msgstr ""
"这种静态链接构建机制对于构建发布版的二进制文件很好用，因为我们可以把所有模块"
"都编译进我们的可执行文件中。"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:258
#, fuzzy
msgid ""
"However the trade-off is every single change means a full recompilation of "
"the game. Even if SCons is able to detect and recompile only the file that "
"have changed, finding such files and eventually linking the final binary is "
"a long and costly part."
msgstr ""
"然而，他的缺点是每次对模块进行修改您都需要重新编译并链接整个引擎。即使 Scons "
"能够检测到只需要重新编译一小部分文件， 执行这种链接操作会耗费不少时间。"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:263
msgid ""
"The solution to avoid such a cost is to build our own module as a shared "
"library that will be dynamically loaded when starting our game's binary."
msgstr ""
"我们可以通过将模块构建为动态链接库的方式来避免这些链接上的时间浪费， 这样我们"
"只需要在启动可执行文件时加载模块的动态库就可以了。"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:295
msgid ""
"Once compiled, we should end up with a ``bin`` directory containing both the "
"``godot*`` binary and our ``libsummator*.so``. However given the .so is not "
"in a standard directory (like ``/usr/lib``), we have to help our binary find "
"it during runtime with the ``LD_LIBRARY_PATH`` environ variable:"
msgstr ""
"编译完成后，在 ``bin`` 目录下可以找到 ``godot*`` 可执行文件和 我们的模块库 "
"``libsummator*.so``。 但是这个动态库并没有位于通用目录下(如 ``/usr/lib``), 我"
"们需要帮助可执行文件在运行时找到它:"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:305
msgid ""
"**note**: Pay attention you have to ``export`` the environ variable "
"otherwise you won't be able to play you project from within the editor."
msgstr ""
"**注意**: 请确保您有 ``export`` 这个环境变量， 否则您将无法从编辑器中启动您的"
"游戏。"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:308
msgid ""
"On top of that, it would be nice to be able to select whether to compile our "
"module as shared library (for development) or as a part of the Godot binary "
"(for release). To do that we can define a custom flag to be passed to SCons "
"using the `ARGUMENT` command:"
msgstr ""
"最重要的是，能够选择是将我们的模块编译为共享库(用于开发)还是作为Godot二进制文"
"件(用于发布)的一部分进行编译将是很好的。 为此，我们可以使用`ARGUMENT`命令定义"
"要传递给SCons的自定义标志:"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:338
msgid ""
"Now by default ``scons`` command will build our module as part of godot's "
"binary and as a shared library when passing ``summator_shared=yes``."
msgstr ""
"现在 Scons 默认会把我们的模块构建到 Godot 的二进制文件中， 如果在构建时传递配"
"置参数 ``summator_shared=yes`` 的话， 将把模块构建成动态链接库。"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:341
msgid ""
"Finally you can even speedup build further by explicitly specifying your "
"shared module as target in the scons command:"
msgstr ""
"最后，您可以通过在 scons 命令中明确指定动态构建模块为的输出目标文件来进一步加"
"速构建:"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:349
msgid "Writing custom documentation"
msgstr "为模块编写文档"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:351
msgid ""
"Writing documentation may seem like a boring task, but it is highly "
"recommended to document your newly created module in order to make it easier "
"for users to benefit from it. Not to mention that the code you've written "
"one year ago may become indistinguishable from the code that was written by "
"someone else, so be kind to your future self!"
msgstr ""
"编写文档看起来可能是一项无聊的任务，但仍然强烈建议您为新创建的模块编写文档，"
"以便使用这个模块的其他人从中受益。 更不用说，您一年后可能与无法区分它与其他人"
"写的代码，所以对未来的您自己好一点吧！"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:357
msgid "There are several steps in order to setup custom docs for the module:"
msgstr "要为模块创建文档需要执行下面的这些操作:"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:359
msgid ""
"Make a new directory in the root of the module. The directory name can be "
"anything, but we'll be using the ``doc_classes`` name throughout this "
"section."
msgstr ""
"在您模块的根目录下创建一个文件夹，名称您可以根据自己的喜好命名。 官方通用使用"
"的是 ``doc_classes`` 这个文件夹。"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:362
msgid "Append the following code snippet to ``config.py``:"
msgstr "在您的 ``config.py`` 脚本中添加下面的代码片段:"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:374
msgid ""
"The ``get_doc_classes()`` method is necessary for the build system to know "
"which documentation classes of the module must be merged, since the module "
"may contain several classes. Replace ``ClassName`` with the name of the "
"class you want to write documentation for. If you need docs for more than "
"one class, append those as well."
msgstr ""
"``get_doc_classes()`` 方法是必不可少的，因为我们往往需要在模块中定义多个类，"
"它用来告诉构建系统要合并哪些类的文档到文档系统中。 把 ``ClassName` 替换成您要"
"编写文档的类名， 如果您要编写多个类的文档， 可以在这个列表中添加其他类名。"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:380
msgid ""
"The ``get_doc_path()`` method is used by the build system to determine the "
"location of the docs. In our case, they will be located in the "
"``doc_classes`` directory."
msgstr ""
"``get_doc_path()`` 方法用于告诉构建系统去哪里查找我们的文档。 在这个示例中， "
"我们返回 ``doc_classes`` 目录。"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:384
msgid "Run command:"
msgstr "运行命令:"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:390
msgid ""
"This will dump the engine API reference to the given ``<path>`` in XML "
"format. Notice that you'll need to configure your ``PATH`` to locate Godot's "
"executable, and make sure that you have write access rights. If not, you "
"might encounter an error similar to the following:"
msgstr ""
"这个命令会把引擎的所有API结构输出到 ``<path>`` 目录下， 以 XML 格式保存在改目"
"录的多个文件内。 请注意您需要确保您编译好的 Godot 二进制文件对您给定的目录有"
"写入权限， 否则将会出现类似的错误:"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:400
msgid "Get generated doc file from ``godot/doc/classes/ClassName.xml``"
msgstr "找到生成的 ``godot/doc/classes/ClassName.xml`` 文件"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:402
msgid ""
"Copy this file to ``doc_classes``, optionally edit it, then compile the "
"engine."
msgstr ""
"将它剪切到我们模块的 ``doc_classes`` 目录下， 然后编辑它， 再重新编译引擎。"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:404
msgid ""
"The build system will fetch the documentation files from the ``doc_classes`` "
"directory and merge them with the base types. Once the compilation process "
"is finished, the docs will become accessible within the engine's built-in "
"documentation system."
msgstr ""
"构建系统在编译文档时会从 ``doc_classes`` 目录中合并我们编写的文档。 构建完成"
"后，我们就可以在引擎内置的文档系统中找到我们编写的文档了。"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:408
msgid ""
"In order to keep documentation up-to-date, all you'll have to do is simply "
"modify one of the ``ClassName.xml`` files and recompile the engine from now "
"on."
msgstr ""
"为了保持文档的更新， 每次您修改 ``ClassName.xml`` 这类文档文件后您都需要重新"
"编译引擎。"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:412
msgid "Summing up"
msgstr "总结"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:414
msgid "Remember to:"
msgstr "记得:"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:416
msgid "use ``GDCLASS`` macro for inheritance, so Godot can wrap it"
msgstr ""
"使用 ``GDCLASS`` 来声明继承关系， 这样 Godot 能对它进行一些内部封装工作"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:417
msgid ""
"use ``_bind_methods`` to bind your functions to scripting, and to allow them "
"to work as callbacks for signals."
msgstr ""
"使用  ``_bind_methods``  将您的函数绑定给脚本使用， 同时让他们支持回调和信号"
"等。"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:420
msgid ""
"But this is not all, depending what you do, you will be greeted with some "
"(hopefully positive) surprises."
msgstr "但这不是全部，取决于您做什么，您会受到一些(希望是积极的)惊喜。"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:423
msgid ""
"If you inherit from :ref:`class_Node` (or any derived node type, such as "
"Sprite), your new class will appear in the editor, in the inheritance tree "
"in the \"Add Node\" dialog."
msgstr ""
"如果您继承了 :ref:`class_Node` (或者诸如 Sprite 之类的其他Node的派生类)， 您"
"创建的类将会在添加节点对话框中的节点继承树中出现。"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:426
msgid ""
"If you inherit from :ref:`class_Resource`, it will appear in the resource "
"list, and all the exposed properties can be serialized when saved/loaded."
msgstr ""
"如果您的类继承自 :ref:`class_Resource`, 它会在资源列表中出现。它的所有导出的"
"属性都能够被序列化，支持保存和加载。"

#: ../../docs/development/cpp/custom_modules_in_cpp.rst:429
msgid ""
"By this same logic, you can extend the Editor and almost any area of the "
"engine."
msgstr "照同样的逻辑，您也可以扩展编辑器或者对引擎的其他领域进行扩展。"

#: ../../docs/development/cpp/binding_to_external_libraries.rst:4
msgid "Binding to external libraries"
msgstr "绑定到外部库"

#: ../../docs/development/cpp/binding_to_external_libraries.rst:9
msgid ""
"The Summator example in :ref:`doc_custom_modules_in_c++` is great for small, "
"custom modules, but what if you want to use a larger, external library? "
"Let's look at an example using Festival, a speech synthesis (text-to-speech) "
"library written in C++."
msgstr ""
"Summator中的示例 :ref:`doc_custom_modules_in_c ++`非常适合小型自定义模块，但"
"如果您想使用更大的外部库，该怎么办？ 让我们看一个使用Festival的示例，这是一个"
"用C++编写的语音合成(文本到语音)库。"

#: ../../docs/development/cpp/binding_to_external_libraries.rst:14
msgid ""
"To bind to an external library, set up a module directory similar to the "
"Summator example:"
msgstr "要绑定到外部库，请设置类似于Summator示例的模块目录:"

#: ../../docs/development/cpp/binding_to_external_libraries.rst:20
msgid "Next, you will create a header file with a simple TTS class:"
msgstr "接下来，您将使用简单的TTS类创建头文件:"

#: ../../docs/development/cpp/binding_to_external_libraries.rst:44
msgid "And then you'll add the cpp file."
msgstr "然后您将添加cpp文件。"

#: ../../docs/development/cpp/binding_to_external_libraries.rst:68
msgid ""
"Just as before, the new class needs to be registered somehow, so two more "
"files need to be created:"
msgstr "和以前一样，新类需要以某种方式注册，因此需要创建另外两个文件:"

#: ../../docs/development/cpp/binding_to_external_libraries.rst:104
msgid ""
"Next, you need to create a ``SCsub`` file so the build system compiles this "
"module:"
msgstr "接下来，您需要创建一个 ``SCsub`` 文件，以便构建系统编译此模块:"

#: ../../docs/development/cpp/binding_to_external_libraries.rst:115
msgid ""
"You'll need to install the external library on your machine to get the .a "
"library files.  See the library's official documentation for specific "
"instructions on how to do this for your operation system.  We've included "
"the installation commands for Linux below, for reference."
msgstr ""
"您需要在计算机上安装外部库才能获取.a库文件。 有关如何为您的操作系统执行此操作"
"的具体说明，请参阅库的官方文档。 我们在下面提供了适用于Linux的安装命令，以供"
"参考。"

#: ../../docs/development/cpp/binding_to_external_libraries.rst:126
msgid ""
"**Important:** The voices that Festival uses (and any other potential "
"external/3rd-party resource) all have varying licenses and terms of use; "
"some (if not most) of them may be be problematic with Godot, even if the "
"Festival Library itself is MIT License compatible. Please be sure to check "
"the licenses and terms of use."
msgstr ""
"**重要:** Festival使用的声音(以及任何其他潜在的外部/第三方资源)都有不同的许可"
"和使用条款; 即使节日图书馆本身与MIT许可证兼容，其中一些(如果不是大多数)可能与"
"Godot有问题。 请务必查看许可证和使用条款。"

#: ../../docs/development/cpp/binding_to_external_libraries.rst:131
msgid ""
"The external library will also need to be installed inside your module to "
"make the source files accessible to the compiler, while also keeping the "
"module code self-contained.  The festival and speech_tools libraries can be "
"installed from the modules/tts/ directory via git using the following "
"commands:"
msgstr ""
"外部库也需要安装在模块内部，以使编译器可以访问源文件，同时保持模块代码自包"
"含。 可以使用以下命令通过git从modules / tts /目录安装festival和speech_tools"
"库:"

#: ../../docs/development/cpp/binding_to_external_libraries.rst:141
msgid ""
"If you don't want the external repository source files committed to your "
"repository, you can link to them instead by adding them as submodules (from "
"within the modules/tts/ directory), as seen below:"
msgstr ""
"如果您不希望将外部存储库源文件提交到您的存储库，您可以通过将它们添加为子模块"
"(从modules / tts /目录中)链接到它们，如下所示:"

#: ../../docs/development/cpp/binding_to_external_libraries.rst:150
msgid ""
"**Important:** Please note that Git submodules are not used in the Godot "
"repository.  If you are developing a module to be merged into the main Godot "
"repository, you should not use submodules.  If your module doesn't get "
"merged in, you can always try to implement the external library as a "
"GDNative C++ plugin."
msgstr ""
"**重要说明:** 请注意，Godot存储库中不使用Git子模块。 如果要开发要合并到主"
"Godot存储库的模块，则不应使用子模块。 如果您的模块没有合并，您可以始终尝试将"
"外部库实现为GDNative C++插件。"

#: ../../docs/development/cpp/binding_to_external_libraries.rst:179
msgid "The final module should look like this:"
msgstr "最终模块应如下所示:"

#: ../../docs/development/cpp/binding_to_external_libraries.rst:208
msgid "And the output will be ``is_spoken: True`` if the text is spoken."
msgstr "如果说出文本，输出将是 ``is_spoken:True`` 。"

#: ../../docs/development/cpp/custom_resource_format_loaders.rst:4
msgid "Custom resource format loaders"
msgstr "自定义资源格式加载器"

#: ../../docs/development/cpp/custom_resource_format_loaders.rst:9
msgid ""
"ResourceFormatLoader is a factory interface for loading file assets. "
"Resources are primary containers. When load is called on the same file path "
"again, the previous loaded Resource will be referenced. Naturally, loaded "
"resources must be stateless."
msgstr ""
"``ResourceFormatLoader`` 是一个用来加载游戏资源的工厂接口。 资源是原始数据容"
"器，当重复加载同一路基的资源文件时，将引用先前加载的资源。 这要求加载的资源必"
"须是无状态的。"

#: ../../docs/development/cpp/custom_resource_format_loaders.rst:14
msgid ""
"This guide assumes the reader knows how to create C++ modules and Godot data "
"types. If not, refer to this guide :ref:`doc_custom_modules_in_c++`."
msgstr ""
"本指南假设读者知道如何创建C++模块和Godot数据类型。 如果没有，请参考本指南 :"
"ref:`doc_custom_modules_in_c ++`。"

#: ../../docs/development/cpp/custom_resource_format_loaders.rst:20
msgid ":ref:`ResourceLoader<class_resourceloader>`"
msgstr ":ref:`ResourceLoader<class_resourceloader>`"

#: ../../docs/development/cpp/custom_resource_format_loaders.rst:21
msgid ""
"`core/io/resource_loader.cpp <https://github.com/godotengine/godot/blob/"
"master/core/io/resource_loader.cpp#L258>`__"
msgstr ""
"`core/io/resource_loader.cpp <https://github.com/godotengine/godot/blob/"
"master/core/io/resource_loader.cpp#L258>`__"

#: ../../docs/development/cpp/custom_resource_format_loaders.rst:26
msgid "Adding new support for many file formats"
msgstr "添加各种新的资源文件格式支持"

#: ../../docs/development/cpp/custom_resource_format_loaders.rst:27
msgid "Audio formats"
msgstr "音效格式"

#: ../../docs/development/cpp/custom_resource_format_loaders.rst:28
msgid "Video formats"
msgstr "视频格式"

#: ../../docs/development/cpp/custom_resource_format_loaders.rst:29
msgid "Machine learning models"
msgstr "机器学习模型"

#: ../../docs/development/cpp/custom_resource_format_loaders.rst:32
msgid "What not?"
msgstr "不能用于做什么？"

#: ../../docs/development/cpp/custom_resource_format_loaders.rst:34
msgid "Raster images"
msgstr "栅格图像"

#: ../../docs/development/cpp/custom_resource_format_loaders.rst:36
msgid "ImageFormatLoader should be used to load images."
msgstr "我们使用 ImageFormatLoader 来加载图片。"

#: ../../docs/development/cpp/custom_resource_format_loaders.rst:41
msgid ""
"`core/io/image_loader.h <https://github.com/godotengine/godot/blob/master/"
"core/io/image_loader.h>`__"
msgstr ""
"`core/io/image_loader.h <https://github.com/godotengine/godot/blob/master/"
"core/io/image_loader.h>`__"

#: ../../docs/development/cpp/custom_resource_format_loaders.rst:45
msgid "Creating a ResourceFormatLoader"
msgstr "创建一个 ResourceFormatLoader"

#: ../../docs/development/cpp/custom_resource_format_loaders.rst:47
msgid ""
"Each file format consist of a data container and a ``ResourceFormatLoader``."
msgstr ""
"每一种文件格式对应着一种数据的容器(Resource)和一个 ``ResourceFormatLoader``。"

#: ../../docs/development/cpp/custom_resource_format_loaders.rst:49
msgid ""
"ResourceFormatLoaders are usually simple classes which return all the "
"necessary metadata for supporting new extensions in Godot. The class must "
"the return the format name and the extension string."
msgstr ""
"ResourceFormatLoaders 通常是一个个简单的类，它返回所有必要的元数据以支持 "
"Godot 中的新扩展。 该类必须返回格式名称和扩展名。"

#: ../../docs/development/cpp/custom_resource_format_loaders.rst:53
msgid ""
"In addition, ResourceFormatLoaders must convert file paths into resources "
"with the ``load`` function. To load a resource, ``load`` must read and "
"handle data serialization."
msgstr ""
"此外，ResourceFormatLoaders 必须使用 ``load`` 函数将文件路径转换为资源"
"( Resource )。 要加载资源，``load`` 必须能够读取和处理序列化的资源数据。"

#: ../../docs/development/cpp/custom_resource_format_loaders.rst:110
msgid "Creating custom data types"
msgstr "创建自定义数据类型"

#: ../../docs/development/cpp/custom_resource_format_loaders.rst:112
msgid ""
"Godot may not have a proper substitute within its :ref:`doc_core_types` or "
"managed resources. Godot needs a new registered data type to understand "
"additional binary formats such as machine learning models."
msgstr ""
"在 Godot 的 :ref:`doc_core_types` 或现有的资源类型中可能没有适当的替代品。 这"
"时您需要一种新的注册数据类型来支持更多的二进制格式，例如机器学习模型。"

#: ../../docs/development/cpp/custom_resource_format_loaders.rst:116
msgid "Here is an example of how to create a custom datatype"
msgstr "这里有一个创建自定义数据类型的示例"

#: ../../docs/development/cpp/custom_resource_format_loaders.rst:174
msgid "Considerations"
msgstr "注意事项"

#: ../../docs/development/cpp/custom_resource_format_loaders.rst:176
msgid ""
"Some libraries may not define certain common routines such as IO handling. "
"Therefore, Godot call translations are required."
msgstr "某些库可能无法定义某些常见例程，例如IO处理。 因此，需要Godot调用翻译。"

#: ../../docs/development/cpp/custom_resource_format_loaders.rst:179
msgid ""
"For example, here is the code for translating ``FileAccess`` calls into "
"``std::istream``."
msgstr "这里有一段将 ``FileAccess`` 调用翻译成 ``std::istream`` 的示例。"

#: ../../docs/development/cpp/custom_resource_format_loaders.rst:215
msgid "`istream <http://www.cplusplus.com/reference/istream/istream/>`__"
msgstr "`istream <http://www.cplusplus.com/reference/istream/istream/>`__"

#: ../../docs/development/cpp/custom_resource_format_loaders.rst:216
msgid ""
"`streambuf <http://www.cplusplus.com/reference/streambuf/streambuf/?"
"kw=streambuf>`__"
msgstr ""
"`streambuf <http://www.cplusplus.com/reference/streambuf/streambuf/?"
"kw=streambuf>`__"

#: ../../docs/development/cpp/custom_resource_format_loaders.rst:217
msgid ""
"`core/io/fileaccess.h <https://github.com/godotengine/godot/blob/master/core/"
"os/file_access.h>`__"
msgstr ""
"`core/io/fileaccess.h <https://github.com/godotengine/godot/blob/master/core/"
"os/file_access.h>`__"

#: ../../docs/development/cpp/custom_resource_format_loaders.rst:220
msgid "Registering the new file format"
msgstr "注册新的文件格式"

#: ../../docs/development/cpp/custom_resource_format_loaders.rst:222
msgid ""
"Godot registers ``ResourcesFormatLoader`` with a ``ResourceLoader`` handler. "
"The handler selects the proper loader automatically when ``load`` is called."
msgstr ""
"Godot 用 ``ResourceLoader`` 句柄注册 ``ResourcesFormatLoader``。 当调用 "
"``load`` 时，会自动选择合适的句柄进行加载。"

#: ../../docs/development/cpp/custom_resource_format_loaders.rst:249
msgid ""
"`core/io/resource_loader.cpp <https://github.com/godotengine/godot/blob/"
"master/core/io/resource_loader.cpp#L280>`__"
msgstr ""
"`core/io/resource_loader.cpp <https://github.com/godotengine/godot/blob/"
"master/core/io/resource_loader.cpp#L280>`__"

#: ../../docs/development/cpp/custom_resource_format_loaders.rst:252
msgid "Loading it on GDScript"
msgstr "在 GDScript 中加载"

#: ../../docs/development/cpp/custom_audiostreams.rst:4
msgid "Custom AudioStreams"
msgstr "自定义音频流"

#: ../../docs/development/cpp/custom_audiostreams.rst:9
msgid ""
"AudioStream is the base class of all audio emitting objects. "
"AudioStreamPlayer binds onto an AudioStream to emit PCM data into an "
"AudioServer which manages audio drivers."
msgstr ""
"AudioStream是所有音频发射对象的基类。 AudioStreamPlayer绑定到AudioStream以将"
"PCM数据发送到管理音频驱动程序的AudioServer。"

#: ../../docs/development/cpp/custom_audiostreams.rst:13
msgid ""
"All audio resources require two audio based classes: AudioStream and "
"AudioStreamPlayback. As a data container, AudioStream contains the resource "
"and exposes itself to GDScript. AudioStream references its own internal "
"custom AudioStreamPlayback which translates AudioStream into PCM data."
msgstr ""
"所有音频资源都需要两个基于音频的类:AudioStream和AudioStreamPlayback。 作为数"
"据容器，AudioStream包含资源并将其自身暴露给GDScript。 AudioStream引用自己的内"
"部自定义AudioStreamPlayback，它将AudioStream转换为PCM数据。"

#: ../../docs/development/cpp/custom_audiostreams.rst:19
msgid ""
"This guide assumes the reader knows how to create C++ modules. If not, refer "
"to this guide :ref:`doc_custom_modules_in_c++`."
msgstr ""
"本指南假设读者知道如何创建C++模块。 如果没有，请参考本指南 :ref:"
"`doc_custom_modules_in_c ++`。"

#: ../../docs/development/cpp/custom_audiostreams.rst:25
#: ../../docs/development/cpp/custom_audiostreams.rst:119
#: ../../docs/development/cpp/custom_audiostreams.rst:350
msgid ""
"`servers/audio/audio_stream.h <https://github.com/godotengine/godot/blob/"
"master/servers/audio/audio_stream.h>`__"
msgstr ""
"`servers/audio/audio_stream.h <https://github.com/godotengine/godot/blob/"
"master/servers/audio/audio_stream.h>`__"

#: ../../docs/development/cpp/custom_audiostreams.rst:26
#: ../../docs/development/cpp/custom_audiostreams.rst:351
msgid ""
"`scene/audio/audioplayer.cpp <https://github.com/godotengine/godot/blob/"
"master/scene/audio/audio_player.cpp>`__"
msgstr ""
"`scene/audio/audioplayer.cpp <https://github.com/godotengine/godot/blob/"
"master/scene/audio/audio_player.cpp>`__"

#: ../../docs/development/cpp/custom_audiostreams.rst:31
msgid "Binding external libraries (like Wwise, FMOD, etc)."
msgstr "绑定外部库(如Wwise，FMOD等)。"

#: ../../docs/development/cpp/custom_audiostreams.rst:32
msgid "Adding custom audio queues"
msgstr "添加自定义音频队列"

#: ../../docs/development/cpp/custom_audiostreams.rst:33
msgid "Adding support for more audio formats"
msgstr "添加对更多音频格式的支持"

#: ../../docs/development/cpp/custom_audiostreams.rst:36
msgid "Create an AudioStream"
msgstr "创建一个AudioStream"

#: ../../docs/development/cpp/custom_audiostreams.rst:38
msgid ""
"An AudioStream consists of three components: data container, stream name, "
"and an AudioStreamPlayback friend class generator. Audio data can be loaded "
"in a number of ways such as with an internal counter for a tone generator, "
"internal/external buffer, or a file reference."
msgstr ""
"AudioStream由三个组件组成:数据容器，流名称和AudioStreamPlayback友元类生成"
"器。 音频数据可以通过多种方式加载，例如使用音调发生器的内部计数器，内部/外部"
"缓冲区或文件参考。"

#: ../../docs/development/cpp/custom_audiostreams.rst:43
msgid ""
"Some AudioStreams need to be stateless such as objects loaded from "
"ResourceLoader. ResourceLoader loads once and references the same object "
"regardless how many times ``load`` is called on a specific resource. "
"Therefore, playback state must be self contained in AudioStreamPlayback."
msgstr ""
"某些AudioStream需要是无状态的，例如从ResourceLoader加载的对象。 "
"ResourceLoader加载一次并引用同一个对象，无论在特定资源上调用 ``load`` 多少"
"次。 因此，播放状态必须自包含在AudioStreamPlayback中。"

#: ../../docs/development/cpp/custom_audiostreams.rst:123
msgid "Create an AudioStreamPlayback"
msgstr "创建一个AudioStreamPlayback"

#: ../../docs/development/cpp/custom_audiostreams.rst:125
msgid ""
"AudioStreamPlayer uses ``mix`` callback to obtain PCM data. The callback "
"must match sample rate and fill the buffer."
msgstr ""
"AudioStreamPlayer使用 ``mix`` 回调来获取PCM数据。 回调必须与采样率匹配并填充"
"缓冲区。"

#: ../../docs/development/cpp/custom_audiostreams.rst:127
msgid ""
"Since AudioStreamPlayback is controlled by the audio thread, i/o and dynamic "
"memory allocation are forbidden."
msgstr ""
"由于AudioStreamPlayback由音频线程控制，因此禁止进行i / o和动态内存分配。"

#: ../../docs/development/cpp/custom_audiostreams.rst:232
msgid "Resampling"
msgstr "重采样"

#: ../../docs/development/cpp/custom_audiostreams.rst:234
msgid ""
"Godot’s AudioServer currently uses 44100 Hz sample rate. When other sample "
"rates are needed such as 48000, either provide one or use "
"AudioStreamPlaybackResampled. Godot provides cubic interpolation for audio "
"resampling."
msgstr ""
"Godot的AudioServer目前使用44100 Hz采样率。 当需要其他采样率(如48000)时，请提"
"供一个或使用AudioStreamPlaybackResampled。 Godot为音频重采样提供了立方插值。"

#: ../../docs/development/cpp/custom_audiostreams.rst:238
msgid ""
"Instead of overloading ``mix``, AudioStreamPlaybackResampled uses "
"``_mix_internal`` to query AudioFrames and ``get_stream_sampling_rate`` to "
"query current mix rate."
msgstr ""
"AudioStreamPlaybackResampled不是重载 ``mix`` ，而是使用 ``_mix_internal`` 来"
"查询AudioFrames和 ``get_stream_sampling_rate`` 来查询当前的混合率。"

#: ../../docs/development/cpp/custom_audiostreams.rst:349
msgid ""
"`core/math/audio_frame.h <https://github.com/godotengine/godot/blob/master/"
"core/math/audio_frame.h>`__"
msgstr ""
"`core/math/audio_frame.h <https://github.com/godotengine/godot/blob/master/"
"core/math/audio_frame.h>`__"

#: ../../docs/development/cpp/custom_godot_servers.rst:4
msgid "Custom Godot servers"
msgstr "自定义Godot服务器"

#: ../../docs/development/cpp/custom_godot_servers.rst:9
msgid ""
"Godot implements multi-threading as servers. Servers are daemons which "
"manages data, processes, and pushes the result. Servers implement the "
"mediator pattern which interprets resource ID and process data for the "
"engine and other modules. In addition, the server claims ownership for its "
"RID allocations."
msgstr ""
"Godot将多线程实现为服务器。 服务器是守护进程，用于管理数据，进程和推送结果。 "
"服务器实现中介模式，该模式解释引擎和其他模块的资源ID和过程数据。 此外，服务器"
"声明其RID分配的所有权。"

#: ../../docs/development/cpp/custom_godot_servers.rst:15
msgid ""
"This guide assumes the reader knows how to create C++ modules and Godot data "
"types. If not, refer to :ref:`doc_custom_modules_in_c++`."
msgstr ""
"本指南假设读者知道如何创建C++模块和Godot数据类型。 如果没有，请参考 :ref:"
"`doc_custom_modules_in_c++`。"

#: ../../docs/development/cpp/custom_godot_servers.rst:21
msgid ""
"`Why does Godot use servers and RIDs? <https://godotengine.org/article/why-"
"does-godot-use-servers-and-rids>`__"
msgstr ""
"`Why does Godot use servers and RIDs? <https://godotengine.org/article/why-"
"does-godot-use-servers-and-rids>`__"

#: ../../docs/development/cpp/custom_godot_servers.rst:22
msgid "`Singleton pattern <https://en.wikipedia.org/wiki/Singleton_pattern>`__"
msgstr "`单例模式 <https://en.wikipedia.org/wiki/Singleton_pattern>`__"

#: ../../docs/development/cpp/custom_godot_servers.rst:23
msgid "`Mediator pattern <https://en.wikipedia.org/wiki/Mediator_pattern>`__"
msgstr "`Mediator 模式 <https://en.wikipedia.org/wiki/Mediator_pattern>`__"

#: ../../docs/development/cpp/custom_godot_servers.rst:28
msgid "Adding artificial intelligence."
msgstr "添加人工智能。"

#: ../../docs/development/cpp/custom_godot_servers.rst:29
msgid "Adding custom asynchronous threads."
msgstr "添加自定义异步线程。"

#: ../../docs/development/cpp/custom_godot_servers.rst:30
msgid "Adding support for a new input device."
msgstr "添加对新输入设备的支持。"

#: ../../docs/development/cpp/custom_godot_servers.rst:31
msgid "Adding writing threads."
msgstr "添加写线程。"

#: ../../docs/development/cpp/custom_godot_servers.rst:32
msgid "Adding a custom VoIP protocol."
msgstr "添加自定义VoIP协议。"

#: ../../docs/development/cpp/custom_godot_servers.rst:33
msgid "And more..."
msgstr "和更多..."

#: ../../docs/development/cpp/custom_godot_servers.rst:36
msgid "Creating a Godot server"
msgstr "创建Godot服务器"

#: ../../docs/development/cpp/custom_godot_servers.rst:38
msgid ""
"At minimum, a server must have a static instance, a sleep timer, a thread "
"loop, an initialization state and a cleanup procedure."
msgstr ""
"服务器必须至少具有静态实例，睡眠定时器，线程循环，初始化状态和清理过程。"

#: ../../docs/development/cpp/custom_godot_servers.rst:274
msgid "Custom managed resource data"
msgstr "自定义托管资源数据"

#: ../../docs/development/cpp/custom_godot_servers.rst:276
msgid ""
"Godot servers implement a mediator pattern. All data types inherit "
"``RID_Data``. ``RID_Owner<MyRID_Data>`` owns the object when ``make_rid`` is "
"called. During debug mode only, RID_Owner maintains a list of RIDs. In "
"practice, RIDs are similar to writing object-oriented C code."
msgstr ""
"Godot服务器实现了中介模式。 所有数据类型都继承 ``RID_Data`` 。 ```RID_Owner "
"<MyRID_Data>``在调用``make_rid``时拥有对象。 仅在调试模式期间，RID_Owner维护"
"RID列表。 实际上，RID类似于编写面向对象的C代码。"

#: ../../docs/development/cpp/custom_godot_servers.rst:318
msgid ":ref:`RID<class_rid>`"
msgstr ":ref:`RID<class_rid>`"

#: ../../docs/development/cpp/custom_godot_servers.rst:322
msgid "Registering the class in GDScript"
msgstr "在GDScript中注册课程"

#: ../../docs/development/cpp/custom_godot_servers.rst:324
msgid ""
"Servers are allocated in ``register_types.cpp``. The constructor sets the "
"static instance and ``init()`` creates the managed thread; "
"``unregister_types.cpp`` cleans up the server."
msgstr ""
"服务器分配在 ``register_types.cpp`` 中。 构造函数设置静态实例， ``init()`` 创"
"建托管线程; ``unregister_types.cpp``清理服务器。"

#: ../../docs/development/cpp/custom_godot_servers.rst:328
msgid ""
"Since a Godot server class creates an instance and binds it to a static "
"singleton, binding the class might not reference the correct instance. "
"Therefore, a dummy class must be created to reference the proper Godot "
"server."
msgstr ""
"由于Godot服务器类创建了一个实例并将其绑定到静态单例，因此绑定该类可能不会引用"
"正确的实例。 因此，必须创建一个虚拟类来引用正确的Godot服务器。"

#: ../../docs/development/cpp/custom_godot_servers.rst:332
msgid ""
"In ``register_server_types()``, ``Engine::get_singleton()->add_singleton`` "
"is used to register the dummy class in GDScript."
msgstr ""
"在 ``register_server_types()`` 中，``Engine :: get_singleton() -> "
"add_singleton``用于在GDScript中注册虚拟类。"

#: ../../docs/development/cpp/custom_godot_servers.rst:376
msgid ""
"`servers/register_server_types.cpp <https://github.com/godotengine/godot/"
"blob/master/servers/register_server_types.cpp>`__"
msgstr ""
"`servers/register_server_types.cpp <https://github.com/godotengine/godot/"
"blob/master/servers/register_server_types.cpp>`__"

#: ../../docs/development/cpp/custom_godot_servers.rst:379
msgid "Bind methods"
msgstr "绑定方法"

#: ../../docs/development/cpp/custom_godot_servers.rst:381
msgid ""
"The dummy class binds singleton methods to GDScript. In most cases, the "
"dummy class methods wraps around."
msgstr "虚拟类将单例方法绑定到GDScript。 在大多数情况下，虚拟类方法包含在内。"

#: ../../docs/development/cpp/custom_godot_servers.rst:389
msgid "Binding Signals"
msgstr "绑定信号"

#: ../../docs/development/cpp/custom_godot_servers.rst:391
msgid ""
"It is possible to emit signals to GDScript by calling the GDScript dummy "
"object."
msgstr "可以通过调用GDScript虚拟对象向GDScript发出信号。"

#: ../../docs/development/cpp/custom_godot_servers.rst:466
msgid "MessageQueue"
msgstr "MessageQueue"

#: ../../docs/development/cpp/custom_godot_servers.rst:468
msgid ""
"In order to send commands into SceneTree, MessageQueue is a thread-safe "
"buffer to queue set and call methods for other threads. To queue a command, "
"obtain the target object RID and use either ``push_call``, ``push_set``, or "
"``push_notification`` to execute the desired behavior. The queue will be "
"flushed whenever either ``SceneTree::idle`` or ``SceneTree::iteration`` is "
"executed."
msgstr ""
"为了将命令发送到SceneTree，MessageQueue是一个线程安全缓冲区，用于对其他线程进"
"行队列设置和调用方法。 要排队命令，获取目标对象RID并使用 ``push_call``, "
"``push_set``, 或 ``push_notification`` 来执行所需的行为。 只要执行 "
"``SceneTree :: idle`` 或 ``SceneTree :: iteration`` ，队列就会被刷新。"

#: ../../docs/development/cpp/custom_godot_servers.rst:477
msgid ""
"`core/message_queue.cpp <https://github.com/godotengine/godot/blob/master/"
"core/message_queue.cpp>`__"
msgstr ""
"`core/message_queue.cpp <https://github.com/godotengine/godot/blob/master/"
"core/message_queue.cpp>`__"

#: ../../docs/development/cpp/custom_godot_servers.rst:480
msgid "Summing it up"
msgstr "总结"

#: ../../docs/development/cpp/custom_godot_servers.rst:482
msgid "Here is the GDScript sample code:"
msgstr "这是GDScript示例代码:"

#: ../../docs/development/cpp/custom_godot_servers.rst:508
msgid ""
"The actual `Hilbert Hotel <https://en.wikipedia.org/wiki/Hilbert"
"%27s_paradox_of_the_Grand_Hotel>`__ is impossible."
msgstr ""
"实际的 `Hilbert Hotel <https://en.wikipedia.org/wiki/Hilbert"
"%27s_paradox_of_the_Grand_Hotel>`__ 是不可能的。"

#: ../../docs/development/cpp/custom_godot_servers.rst:509
msgid "Connecting signal example code is pretty hacky."
msgstr "连接信号的示例代码是很旁门左道的。"

#: ../../docs/development/cpp/creating_android_modules.rst:4
msgid "Creating Android modules"
msgstr "创建Android模块"

#: ../../docs/development/cpp/creating_android_modules.rst:9
msgid ""
"Making video games portable is all fine and dandy, until mobile gaming "
"monetization shows up."
msgstr "在移动游戏货币化出现之前，制作便携式视频游戏一切都很好。"

#: ../../docs/development/cpp/creating_android_modules.rst:12
msgid ""
"This area is complex, usually a mobile game that monetizes needs special "
"connections to a server for things like:"
msgstr ""
"这个区域很复杂，通常是一个移动游戏，货币化需要与服务器的特殊连接，例如:"

#: ../../docs/development/cpp/creating_android_modules.rst:15
msgid "Analytics"
msgstr "分析"

#: ../../docs/development/cpp/creating_android_modules.rst:16
msgid "In-app purchases"
msgstr "应用内购买"

#: ../../docs/development/cpp/creating_android_modules.rst:17
msgid "Receipt validation"
msgstr "收据验证"

#: ../../docs/development/cpp/creating_android_modules.rst:18
msgid "Install tracking"
msgstr "安装跟踪"

#: ../../docs/development/cpp/creating_android_modules.rst:19
msgid "Ads"
msgstr "广告"

#: ../../docs/development/cpp/creating_android_modules.rst:20
msgid "Video ads"
msgstr "视频广告"

#: ../../docs/development/cpp/creating_android_modules.rst:21
msgid "Cross-promotion"
msgstr "交叉推广"

#: ../../docs/development/cpp/creating_android_modules.rst:22
msgid "In-game soft & hard currencies"
msgstr "游戏中的软硬货币"

#: ../../docs/development/cpp/creating_android_modules.rst:23
msgid "Promo codes"
msgstr "促销代码"

#: ../../docs/development/cpp/creating_android_modules.rst:24
msgid "A/B testing"
msgstr "A / B测试"

#: ../../docs/development/cpp/creating_android_modules.rst:25
msgid "Login"
msgstr "登录"

#: ../../docs/development/cpp/creating_android_modules.rst:26
msgid "Cloud saves"
msgstr "云保存"

#: ../../docs/development/cpp/creating_android_modules.rst:27
msgid "Leaderboards and scores"
msgstr "排行榜和分数"

#: ../../docs/development/cpp/creating_android_modules.rst:28
msgid "User support & feedback"
msgstr "用户支持和反馈"

#: ../../docs/development/cpp/creating_android_modules.rst:29
msgid "Posting to Facebook, Twitter, etc."
msgstr "发布到Facebook，Twitter等。"

#: ../../docs/development/cpp/creating_android_modules.rst:30
msgid "Push notifications"
msgstr "推送通知"

#: ../../docs/development/cpp/creating_android_modules.rst:32
msgid ""
"On iOS, you can write a C++ module and take advantage of the C++/ObjC "
"intercommunication."
msgstr "在iOS上，您可以编写C++模块并利用C++ / ObjC互通。"

#: ../../docs/development/cpp/creating_android_modules.rst:35
msgid ""
"On Android, interfacing with C++ through JNI (Java Native Interface) isn't "
"as convenient."
msgstr "在Android上，通过JNI(Java Native Interface)与C++连接并不方便。"

#: ../../docs/development/cpp/creating_android_modules.rst:38
msgid "Maybe REST?"
msgstr "也许REST？"

#: ../../docs/development/cpp/creating_android_modules.rst:40
msgid ""
"Most of these APIs allow communication via REST/JSON APIs. Godot has great "
"support for HTTP, HTTPS and JSON, so consider this as an option that works "
"on every platform. Only write the code once and you are set to go."
msgstr ""
"大多数这些API允许通过REST / JSON API进行通信。 Godot非常支持HTTP，HTTPS和"
"JSON，因此请将其视为可在每个平台上运行的选项。 只编写一次代码，然后就可以了。"

#: ../../docs/development/cpp/creating_android_modules.rst:46
msgid "Android module"
msgstr "Android模块"

#: ../../docs/development/cpp/creating_android_modules.rst:48
msgid ""
"Writing an Android module is similar to :ref:`doc_custom_modules_in_c++`, "
"but needs a few more steps."
msgstr ""
"编写Android模块类似于 :ref:`doc_custom_modules_in_c ++`，但需要更多步骤。"

#: ../../docs/development/cpp/creating_android_modules.rst:51
msgid ""
"Make sure you are familiar with building your own :ref:`Android export "
"templates <doc_compiling_for_android>`, as well as creating :ref:"
"`doc_custom_modules_in_c++`."
msgstr ""
"确保您熟悉构建自己的 :ref:`Android export templates "
"<doc_compiling_for_android>`，以及创建 :ref:`doc_custom_modules_in_c ++`。"

#: ../../docs/development/cpp/creating_android_modules.rst:55
msgid "config.py"
msgstr "config.py"

#: ../../docs/development/cpp/creating_android_modules.rst:57
msgid ""
"In the config.py for the module, some extra functions are provided for "
"convenience. First, it's often wise to detect if Android is the target "
"platform being built for and only enable building in this case:"
msgstr ""
"在模块的config.py中，为方便起见，提供了一些额外的功能。 首先，检测Android是否"
"是正在构建的目标平台并且仅在此情况下启用构建通常是明智的:"

#: ../../docs/development/cpp/creating_android_modules.rst:66
msgid ""
"If more than one platform can be built (typical if implementing the module "
"also for iOS), check manually for Android in the configure functions for "
"Android (or other platform-specific) code:"
msgstr ""
"如果可以构建多个平台(例如，如果也为iOS实现模块)，请在Android(或其他特定于平"
"台)代码的配置功能中手动检查Android:"

#: ../../docs/development/cpp/creating_android_modules.rst:80
msgid "Java singleton"
msgstr "Java单例"

#: ../../docs/development/cpp/creating_android_modules.rst:82
msgid ""
"An Android module will usually have a singleton class that will load it, "
"this class inherits from ``Godot.SingletonBase``. Resource identifiers for "
"any additional resources you have provided for the module will be in the "
"``com.godot.game.R`` class, so you'll likely want to import it."
msgstr ""
"Android模块通常会有一个单独的类来加载它，这个类继承自 ``Godot."
"SingletonBase`` 。 您为该模块提供的任何其他资源的资源标识符将位于“com.godot."
"game.R”类中，因此您可能希望导入它。"

#: ../../docs/development/cpp/creating_android_modules.rst:87
msgid "A singleton object template follows:"
msgstr "单例对象模板如下:"

#: ../../docs/development/cpp/creating_android_modules.rst:153
msgid ""
"Calling back to Godot from Java is a little more difficult. The instance ID "
"of the script must be known first, this is obtained by calling "
"``get_instance_ID()`` on the script. This returns an integer that can be "
"passed to Java."
msgstr ""
"从Java回调Godot有点困难。 首先必须知道脚本的实例ID，这是通过在脚本上调用 "
"``get_instance_ID()`` 获得的。 这将返回一个可以传递给Java的整数。"

#: ../../docs/development/cpp/creating_android_modules.rst:158
msgid ""
"From Java, use the ``calldeferred`` function to communicate back with Godot. "
"Java will most likely run in a separate thread, so calls are deferred:"
msgstr ""
"从Java中，使用 ``calldeferred`` 函数与Godot进行通信。 Java很可能在一个单独的"
"线程中运行，因此调用是延迟的:"

#: ../../docs/development/cpp/creating_android_modules.rst:165
msgid ""
"Add this singleton to the build of the project by adding the following to "
"config.py:"
msgstr "通过将以下内容添加到config.py，将此单例添加到项目的构建中:"

#: ../../docs/development/cpp/creating_android_modules.rst:181
msgid "AndroidManifest"
msgstr "AndroidManifest"

#: ../../docs/development/cpp/creating_android_modules.rst:183
msgid ""
"Some SDKs need custom values in AndroidManifest.xml. Permissions can be "
"edited from the Godot exporter so there is no need to add those, but maybe "
"other functionalities are needed."
msgstr ""
"某些SDK需要AndroidManifest.xml中的自定义值。 可以从Godot导出器编辑权限，因此"
"无需添加权限，但可能需要其他功能。"

#: ../../docs/development/cpp/creating_android_modules.rst:187
msgid ""
"Create the custom chunk of android manifest and put it inside the module, "
"add it like this:"
msgstr "创建android清单的自定义块并将其放在模块中，像这样添加:"

#: ../../docs/development/cpp/creating_android_modules.rst:206
msgid ""
"In order to provide additional resources with your module you have to add "
"something like this:"
msgstr "为了向您的模块提供额外资源，您必须添加以下内容:"

#: ../../docs/development/cpp/creating_android_modules.rst:216
msgid ""
"Now you can refer to those resources by their id (``R.string.my_string``, "
"and the like) by importing the ``com.godot.game.R`` class in your Java code."
msgstr ""
"现在，您可以通过在Java代码中导入 ``com.godot.game.R`` 类，通过它们的id(``R."
"string.my_string``等)来引用这些资源。"

#: ../../docs/development/cpp/creating_android_modules.rst:220
msgid "Assets"
msgstr "资源"

#: ../../docs/development/cpp/creating_android_modules.rst:222
msgid ""
"Similarly, you can add any type of raw asset files to your app's asset "
"directory like this:"
msgstr ""
"同样，您可以将任何类型的原始资源文件添加到应用程序的资源目录中，如下所示:"

#: ../../docs/development/cpp/creating_android_modules.rst:231
msgid ""
"Assets don't have resource ids, but can be read with their file name as "
"streams of bytes with the help of the Android AssetManager class."
msgstr ""
"资源没有资源ID，但可以在Android AssetManager类的帮助下将其文件名作为字节流读"
"取。"

#: ../../docs/development/cpp/creating_android_modules.rst:235
msgid "SDK library"
msgstr "SDK库"

#: ../../docs/development/cpp/creating_android_modules.rst:237
msgid ""
"So, finally it's time to add the SDK library. The library can come in two "
"flavors, a JAR file or an Android project for ant. JAR is the easiest to "
"integrate, put it in the module directory and add it:"
msgstr ""
"所以，最后是时候添加SDK库了。 该库可以有两种版本，一种是JAR文件，另一种是针对"
"ant的Android项目。 JAR是最容易集成的，将它放在模块目录中并添加它:"

#: ../../docs/development/cpp/creating_android_modules.rst:257
msgid "SDK project"
msgstr "SDK项目"

#: ../../docs/development/cpp/creating_android_modules.rst:259
msgid ""
"When this is an Android project, things usually get more complex. Copy the "
"project folder inside the module directory and configure it:"
msgstr ""
"当这是一个Android项目时，事情通常会变得更加复杂。 复制模块目录中的项目文件夹"
"并进行配置:"

#: ../../docs/development/cpp/creating_android_modules.rst:266
msgid ""
"As of this writing, Godot uses minsdk 18 and target sdk 27. If this ever "
"changes, it should be reflected in the manifest template: `AndroidManifest."
"xml.template <https://github.com/godotengine/godot/blob/master/platform/"
"android/AndroidManifest.xml.template>`__"
msgstr ""
"在撰写本文时，Godot使用minsdk 18并定位sdk 27.如果这一点发生变化，它应该反映在"
"清单模板中: `AndroidManifest.xml.template <https://github.com/godotengine/"
"godot/blob/master/platform/android/AndroidManifest.xml.template>`__"

#: ../../docs/development/cpp/creating_android_modules.rst:270
msgid "Then, add the module folder to the project:"
msgstr "然后，将模块文件夹添加到项目中:"

#: ../../docs/development/cpp/creating_android_modules.rst:286
msgid "Building"
msgstr "建造"

#: ../../docs/development/cpp/creating_android_modules.rst:288
msgid ""
"As you probably modify the contents of the module, and modify your .java "
"inside the module, you need the module to be built with the rest of Godot, "
"so compile android normally."
msgstr ""
"由于您可能修改了模块的内容，并修改了模块中的.java，因此您需要使用Godot的其余"
"部分构建模块，因此请正常编译android。"

#: ../../docs/development/cpp/creating_android_modules.rst:296
msgid ""
"This will cause your module to be included, the .jar will be copied to the "
"java folder, the .java will be copied to the sources folder, etc. Each time "
"you modify the .java, scons must be called."
msgstr ""
"这将导致您的模块被包含，.jar将被复制到java文件夹，.java将被复制到sources文件"
"夹等。每次修改.java时，都必须调用scons。"

#: ../../docs/development/cpp/creating_android_modules.rst:300
msgid ""
"Afterwards, continue the steps for compiling android  :ref:"
"`doc_compiling_for_android`."
msgstr "然后，继续编译android :ref:`doc_compiling_for_android`的步骤。"

#: ../../docs/development/cpp/creating_android_modules.rst:305
msgid ""
"To use the module from GDScript, first enable the singleton by adding the "
"following line to project.godot:"
msgstr "要使用GDScript中的模块，首先通过向project.godot添加以下行来启用单例:"

#: ../../docs/development/cpp/creating_android_modules.rst:314
msgid ""
"More than one singleton module can be enabled by separating with commas:"
msgstr "通过逗号分隔可以启用多个单例模块:"

#: ../../docs/development/cpp/creating_android_modules.rst:322
msgid "Then request the singleton Java object from Globals like this:"
msgstr "然后从Globals请求单例Java对象，如下所示:"

#: ../../docs/development/cpp/creating_android_modules.rst:338
msgid "Godot crashes upon load"
msgstr "Godot在装载时坠毁"

#: ../../docs/development/cpp/creating_android_modules.rst:340
msgid "Check ``adb logcat`` for possible problems, then:"
msgstr "检查``adb logcat``是否存在可能的问题，然后:"

#: ../../docs/development/cpp/creating_android_modules.rst:342
msgid "Make sure libgodot_android.so is in the ``libs/armeabi`` folder"
msgstr "确保libgodot_android.so位于``libs / armeabi``文件夹中"

#: ../../docs/development/cpp/creating_android_modules.rst:343
msgid ""
"Check that the methods used in the Java singleton only use simple Java "
"datatypes, more complex ones are not supported."
msgstr ""
"检查Java单例中使用的方法是否仅使用简单的Java数据类型，不支持更复杂的数据类"
"型。"

#: ../../docs/development/cpp/creating_android_modules.rst:347
msgid "Future"
msgstr "未来"

#: ../../docs/development/cpp/creating_android_modules.rst:349
msgid ""
"Godot has an experimental Java API Wrapper that allows to use the entire "
"Java API from GDScript."
msgstr "Godot有一个实验性的Java API Wrapper，允许使用GDScript的整个Java API。"

#: ../../docs/development/cpp/creating_android_modules.rst:352
msgid "It's simple to use and it's used like this:"
msgstr "它使用起来很简单，就像这样:"

#: ../../docs/development/cpp/creating_android_modules.rst:358
msgid ""
"This is most likely not functional yet, if you want to test it and help us "
"make it work, contact us through the `developer mailing list <https://groups."
"google.com/forum/#!forum/godot-engine>`__."
msgstr ""
"这很可能尚未实现，如果您想测试它并帮助我们使其工作，请通过 `开发人员邮件列表 "
"<https://groups.google.com/forum/#!forum/godot-engine>`__ 与我们联系。"

#: ../../docs/development/file_formats/index.rst:2
msgid "Godot file formats"
msgstr "Godot文件格式"

#: ../../docs/development/file_formats/tscn.rst:2
msgid "TSCN file format"
msgstr "TSCN文件格式"

#: ../../docs/development/file_formats/tscn.rst:4
msgid ""
"A :code:`.tscn` File format is the \"Text SCeNe\" file format and represents "
"a single scene-tree inside Godot. TSCN files have the advantage of being "
"nearly human-readable and easy for version control systems to manage. During "
"import the TSCN files are compiled into binary :code:`.scn` files stored "
"inside the .import folder. This reduces the data size and speed up loading."
msgstr ""
":code:`.tscn` 文件格式是“Text SCeNe”文件格式，表示Godot内部的单个场景树。TSCN"
"文件的优点是人类可读的，并且版本控制系统易于管理。在导入期间，TSCN文件被编译"
"成二进制文件 :code:`.scn` 文件，存储在.import文件夹中。这减少了数据大小并加快"
"了加载速度。"

#: ../../docs/development/file_formats/tscn.rst:10
msgid ""
"The :code:`.escn` file format is identical to the TSCN file format, but is "
"used to indicate to Godot that the file has been exported from another "
"program and should not be edited by the user from within Godot."
msgstr ""
":code:`.escn` 文件格式与TSCN文件格式相同，但是用于向Godot指示从另一个程序导出"
"的文件，并且不应该由用户在Godot内编辑。"

#: ../../docs/development/file_formats/tscn.rst:14
msgid ""
"For those looking for a complete description, the parsing is handled in the "
"file `scene_format_text.cpp <https://github.com/godotengine/godot/blob/"
"master/scene/resources/scene_format_text.cpp>`_ in the class :code:"
"`ResourceFormatLoaderText`"
msgstr ""
"对于那些寻找完整描述的人来说，可在类 :code:`ResourceFormatLoaderText` 中的 "
"`scene_format_text.cpp <https://github.com/godotengine/godot/blob/master/"
"scene/resources/scene_format_text.cpp>`_ 文件中看到详细信息"

#: ../../docs/development/file_formats/tscn.rst:19
msgid "File structure"
msgstr "文件结构"

#: ../../docs/development/file_formats/tscn.rst:21
msgid "There are five main sections inside the TSCN File:"
msgstr "TSCN文件有五个主要部分:"

#: ../../docs/development/file_formats/tscn.rst:23
msgid "File Descriptor"
msgstr "文件描述符"

#: ../../docs/development/file_formats/tscn.rst:24
#: ../../docs/development/file_formats/tscn.rst:266
msgid "External resources"
msgstr "外部资源"

#: ../../docs/development/file_formats/tscn.rst:25
#: ../../docs/development/file_formats/tscn.rst:287
msgid "Internal resources"
msgstr "内部资源"

#: ../../docs/development/file_formats/tscn.rst:29
msgid ""
"The file descriptor looks like :code:`[gd_scene load_steps=1 format=2]` And "
"should be the first entry in the file. The load_steps parameter should (in "
"theory) be the number of resources within the file, though in practice its "
"value seems not to matter."
msgstr ""
"文件描述符看起来就像 :code:`[gd_scene load_steps=1 format=2]` 并且应该是文件"
"中的第一个条目。 load_steps参数应该(理论上)是文件中的资源数量，但实际上它的值"
"似乎并不重要。"

#: ../../docs/development/file_formats/tscn.rst:34
msgid ""
"These sections should appear in order, but it can be hard to distinguish "
"them. The only difference between them is the first element in the heading "
"for all of the items in the section. For example, the heading of all "
"external resources should start with :code:`[ext_resource .....]`"
msgstr ""
"这些部分应按顺序出现，但很难区分它们。 它们之间的唯一区别是标题中该部分中所有"
"项目的第一个元素。 例如，所有外部资源的标题应该以:code:`[ext_resource .....]`"
"开头"

#: ../../docs/development/file_formats/tscn.rst:41
msgid "Entries inside the file"
msgstr "文件中的条目"

#: ../../docs/development/file_formats/tscn.rst:43
msgid ""
"A heading looks like: :code:`[<resource_type> key=value key=value "
"key=value ...]` Where resource_type is one of:"
msgstr ""
"标题如下:: code:`[<resource_type> key = value key = value key = value ...]`其"
"中resource_type是以下之一:"

#: ../../docs/development/file_formats/tscn.rst:47
msgid "ext_resource"
msgstr "ext_resource"

#: ../../docs/development/file_formats/tscn.rst:48
msgid "sub_resource"
msgstr "sub_resource"

#: ../../docs/development/file_formats/tscn.rst:49
msgid "node"
msgstr "node"

#: ../../docs/development/file_formats/tscn.rst:50
msgid "connection"
msgstr "connection"

#: ../../docs/development/file_formats/tscn.rst:52
msgid ""
"Underneath every heading comes zero or more :code:`key = value` pairs. The "
"values can be complex datatypes such as arrays, transformations, colors, and "
"so on. For example, a spatial node looks like:"
msgstr ""
"在每个标题下面都是零或更多:代码:`key = value`对。 值可以是复杂的数据类型，例"
"如数组，转换，颜色等。 例如，空间节点如下所示:"

#: ../../docs/development/file_formats/tscn.rst:62
msgid "The scene tree"
msgstr "场景树"

#: ../../docs/development/file_formats/tscn.rst:64
msgid ""
"The scene tree is made up of... nodes! The heading of each node consists of "
"its name, parent and (most of the time) a type. For example :code:`[node "
"type=\"Camera\" name=\"PlayerCamera\" parent=\"Player/Head\"]`"
msgstr ""
"场景树由......节点组成！ 每个节点的标题由其名称，父级和(大多数时间)类型组"
"成。 例如:code:`[node type =“Camera”name =“PlayerCamera”parent =“Player / "
"Head”]`"

#: ../../docs/development/file_formats/tscn.rst:68
msgid "Other valid keywords include:"
msgstr "其他有效关键词包括:"

#: ../../docs/development/file_formats/tscn.rst:70
msgid "instance"
msgstr "实例"

#: ../../docs/development/file_formats/tscn.rst:71
msgid "instance_placeholder"
msgstr "实例化占位符"

#: ../../docs/development/file_formats/tscn.rst:72
msgid "owner"
msgstr "拥有者"

#: ../../docs/development/file_formats/tscn.rst:73
msgid "index (if two nodes have the same name)"
msgstr "索引(如果两个节点具有相同的名称)"

#: ../../docs/development/file_formats/tscn.rst:74
msgid "groups"
msgstr "组"

#: ../../docs/development/file_formats/tscn.rst:76
msgid ""
"The first node in the file should not have the :code:`parent=Path/To/Node` "
"entry in it's heading, and it is the scene root. All scene files should have "
"exactly one scene root. It it does not, Godot will fail to import the file. "
"The parent path of other nodes should be absolute, but without the scene "
"root's name. If it is a direct child of the scene root, it should be :code:`"
"\".\"`. Here is an example scene tree (but without any node content)."
msgstr ""
"文件中的第一个节点不应该在其标题中包含:code:`parent = Path / To / Node`条目，"
"它是场景根。 所有场景文件应该只有一个场景根。 它没有，Godot将无法导入文件。 "
"其他节点的父路径应该是绝对的，但没有场景根的名称。 如果它是场景根的直接子节"
"点，它应该是:code:`“。”`。 这是一个示例场景树(但没有任何节点内容)。"

#: ../../docs/development/file_formats/tscn.rst:90
msgid ""
"Similar to the internal resource, the document for each node is currently "
"incomplete. Fortunately it is easy to find out because you can simply save a "
"file with that node in it. Some example nodes are:"
msgstr ""
"与内部资源类似，每个节点的文档目前尚未完成。 幸运的是，很容易找到它，因为您只"
"需保存包含该节点的文件即可。 一些示例节点是:"

#: ../../docs/development/file_formats/tscn.rst:130
msgid ""
"A tree structure is not enough to represent the whole scene, Godot use a :"
"code:`NodePath(Path/To/Node)` structure to refer to another node or "
"attribute of the node anywhere in the scene tree. Some typical usages of "
"NodePath like mesh node use :code:`NodePath()` to point to its skeleton, "
"animation track use :code:`NodePath()` points to animated attribute in node."
msgstr ""
"树结构不足以表示整个场景，Godot使用a:code:`NodePath(Path / To / Node)`结构来"
"引用场景树中任何位置的节点的另一个节点或属性。 NodePath的一些典型用法就像网格"
"节点一样:代码:`NodePath()`指向它的骨架，动画轨道使用:代码:`NodePath()`指向节"
"点中的动画属性。"

#: ../../docs/development/file_formats/tscn.rst:155
msgid ""
"Skeleton node inherits Spatial node, besides that it may have a list of "
"bones described in key, value pair in the format :code:`bones/Id/"
"Attribute=Value`, attributes of bone consists of"
msgstr ""
"Skeleton节点继承Spatial节点，除了它可能有一个以key，value对描述的骨骼列表，格"
"式为:code:`bones / Id / Attribute = Value`，bone的属性由"

#: ../../docs/development/file_formats/tscn.rst:159
msgid "name"
msgstr "name"

#: ../../docs/development/file_formats/tscn.rst:160
msgid "parent"
msgstr "parent"

#: ../../docs/development/file_formats/tscn.rst:161
msgid "rest"
msgstr "rest"

#: ../../docs/development/file_formats/tscn.rst:162
msgid "pose"
msgstr "pose"

#: ../../docs/development/file_formats/tscn.rst:163
#: ../../docs/development/file_formats/tscn.rst:385
msgid "enabled"
msgstr "enabled"

#: ../../docs/development/file_formats/tscn.rst:164
msgid "bound_children"
msgstr "bound_children"

#: ../../docs/development/file_formats/tscn.rst:166
msgid ":code:`name` must put as the first attribute of each bone"
msgstr ":code:`name`必须作为每个骨骼的第一个属性"

#: ../../docs/development/file_formats/tscn.rst:168
msgid ""
":code:`parent` is the index of parent bone in the bone list, with parent "
"index, the bone list is built to a bone tree"
msgstr ""
":code:`parent`是骨骼列表中父骨骼的索引，带有父索引，骨骼列表构建到骨骼树"

#: ../../docs/development/file_formats/tscn.rst:171
msgid ":code:`rest` is the transform matrix of bone in rest position"
msgstr ":code:`rest`是休息位置骨骼的变换矩阵"

#: ../../docs/development/file_formats/tscn.rst:173
msgid ":code:`pose` is the pose matrix use :code:`rest` as basis"
msgstr ":code:`pose`是姿势矩阵用法:代码:`rest`作为基础"

#: ../../docs/development/file_formats/tscn.rst:175
msgid ""
":code:`bound_children` is a list of NodePath() points to BoneAttachments "
"belong to this bone"
msgstr ""
":code:`bound_children`是一个NodePath()的列表，指向BoneAttachments属于这个骨骼"

#: ../../docs/development/file_formats/tscn.rst:178
msgid "An example of a skeleton node with two bones:"
msgstr "具有两个骨骼的骨架节点的示例:"

#: ../../docs/development/file_formats/tscn.rst:198
msgid "BoneAttachment"
msgstr "BoneAttachment"

#: ../../docs/development/file_formats/tscn.rst:200
msgid ""
"BoneAttachment node is an intermediate node to describe some node being "
"parented to a single bone in Skeleton node. The BoneAttachment has a :code:"
"`bone_name=NameOfBone`, and the corresponding bone being the parent has the "
"BoneAttachment node in its :code:`bound_children` list."
msgstr ""
"BoneAttachment节点是一个中间节点，用于描述某个节点是Skeleton节点中单个骨骼的"
"父级。 BoneAttachment有一个:code:`bone_name = NameOfBone`，作为父对应的骨骼在"
"其:: code:`bound_children`列表中有BoneAttachment节点。"

#: ../../docs/development/file_formats/tscn.rst:205
msgid "An example of one MeshInstance parented to a bone in Skeleton:"
msgstr "一个MeshInstance的示例，它是Skeleton中一个骨骼的父级:"

#: ../../docs/development/file_formats/tscn.rst:229
msgid "AnimationPlayer"
msgstr "AnimationPlayer"

#: ../../docs/development/file_formats/tscn.rst:231
msgid ""
"AnimationPlayer works as an animation lib. it has animations listed in the "
"format :code:`anim/Name=SubResource(ResourceId)`, each refers to a Animation "
"internal resource. All the animation resources use the root node of "
"AnimationPlayer. The root node is stored as :code:`root_node=NodePath(Path/"
"To/Node)`."
msgstr ""
"AnimationPlayer用作动画库。 它有以下格式列出的动画:代码:`anim / Name = "
"SubResource(ResourceId)`，每个都引用一个动画内部资源。 所有动画资源都使用"
"AnimationPlayer的根节点。 根节点存储为:code:`root_node = NodePath(Path / "
"To / Node)`。"

#: ../../docs/development/file_formats/tscn.rst:251
msgid ""
"Resources are components that make up the nodes. For example, a MeshInstance "
"node will have an accompanying ArrayMesh resource. The ArrayMesh resource "
"may be either internal or external to the TSCN file."
msgstr ""
"资源是组成节点的组件。 例如，MeshInstance节点将具有附带的ArrayMesh资源。 "
"ArrayMesh资源可以是TSCN文件的内部或外部。"

#: ../../docs/development/file_formats/tscn.rst:255
msgid ""
"References to the resources are handled by id numbers in the resources "
"heading. External resources and internal resource are referred to with :code:"
"`ExtResource(id)` and :code:`SubResource(id)`. Because there have different "
"methods to refer to internal and external resource, you can have the same ID "
"for both an internal and external resource."
msgstr ""
"资源的引用由资源标题中的id号处理。 外部资源和内部资源用:代码:"
"`ExtResource(id)`和:code:`SubResource(id)`。 因为有不同的方法来引用内部和外部"
"资源，所以内部和外部资源都可以使用相同的ID。"

#: ../../docs/development/file_formats/tscn.rst:261
msgid ""
"For example, to refer to the resource :code:`[ext_resource id=3 type="
"\"PackedScene\" path=....]` you would use :code:`ExtResource(3)`"
msgstr ""
"例如，要引用资源:代码:`[ext_resource id = 3 type =“PackedScene”path = ....]`"
"您将使用:code:`ExtResource(3)`"

#: ../../docs/development/file_formats/tscn.rst:268
msgid ""
"External resources are links to resources not contained within the TSCN file "
"itself. An external resource consists of:"
msgstr "外部资源是指TSCN文件本身未包含的资源的链接。 外部资源包括:"

#: ../../docs/development/file_formats/tscn.rst:271
msgid "A path"
msgstr "一条路径"

#: ../../docs/development/file_formats/tscn.rst:272
msgid "A type"
msgstr "一种类型"

#: ../../docs/development/file_formats/tscn.rst:273
msgid "An ID"
msgstr "一个ID"

#: ../../docs/development/file_formats/tscn.rst:275
msgid ""
"Godot always generates absolute paths relative to the resource directory and "
"thus prefixed with :code:`res://`, but paths relative to the TSCN file's "
"location are also valid."
msgstr ""
"Godot总是生成相对于资源目录的绝对路径，因此前缀为:code:`res://`，但相对于TSCN"
"文件位置的路径也是有效的。"

#: ../../docs/development/file_formats/tscn.rst:279
msgid "Some example external resources are:"
msgstr "一些示例外部资源是:"

#: ../../docs/development/file_formats/tscn.rst:289
msgid ""
"A TSCN file can contain meshes, materials and other data, and these are "
"contained in the internal resources section of the file. The heading for an "
"internal resource looks similar to those of external resources, but does not "
"have a path. Internal resources also have :code:`key=value` pairs under each "
"heading. For example, a capsule collision shape looks like:"
msgstr ""
"TSCN文件可以包含网格，材质和其他数据，这些文件包含在文件的内部资源部分中。 内"
"部资源的标题看起来与外部资源的标题类似，但没有路径。 内部资源也有:代码:每个标"
"题下的`key = value`对。 例如，胶囊碰撞形状如下所示:"

#: ../../docs/development/file_formats/tscn.rst:302
msgid ""
"Some internal resource contain links to other internal resources (such as a "
"mesh having a material). In this case, the referring resource must appear "
"before the reference to it. Thus, in the internal resources section of the "
"file, order does matter."
msgstr ""
"某些内部资源包含指向其他内部资源的链接(例如具有材质的网格)。 在这种情况下，引"
"用资源必须出现在引用之前。 因此，在文件的内部资源部分，顺序确实很重要。"

#: ../../docs/development/file_formats/tscn.rst:307
msgid ""
"Unfortunately, documentation on the formats for these subresources is not "
"complete, and while some can be found through inspecting resources of saved "
"files, others can only be found by looking through Godot's source."
msgstr ""
"遗憾的是，关于这些子资源的格式的文档并不完整，虽然可以通过检查已保存文件的资"
"源找到一些，但其他文件只能通过查看Godot的来源找到。"

#: ../../docs/development/file_formats/tscn.rst:312
msgid "ArrayMesh"
msgstr "ArrayMesh"

#: ../../docs/development/file_formats/tscn.rst:314
msgid ""
"ArrayMesh consists of several surfaces, each in the format :code:`surface"
"\\Index={}`, each surface is a set of vertex and a material."
msgstr ""
"ArrayMesh由几个表面组成，每个表面的格式为:code:`surface \\ Index = {}`，每个"
"表面都是一组顶点和一个材质。"

#: ../../docs/development/file_formats/tscn.rst:317
msgid "TSCN support two format of surface,"
msgstr "TSCN支持两种格式的表面，"

#: ../../docs/development/file_formats/tscn.rst:319
msgid "for the old format, each surface has three essential keys:"
msgstr "对于旧格式，每个表面都有三个基本键:"

#: ../../docs/development/file_formats/tscn.rst:321
msgid "primitive"
msgstr "primitive"

#: ../../docs/development/file_formats/tscn.rst:322
msgid "arrays"
msgstr "arrays"

#: ../../docs/development/file_formats/tscn.rst:323
msgid "morph_arrays"
msgstr "morph_arrays"

#: ../../docs/development/file_formats/tscn.rst:325
msgid ""
":code:`primitive` is an enumerate variable, :code:`primitive=4` which is "
"PRIMITIVE_TRIANGLES is frequently used."
msgstr ""
":code:`primitive`是一个枚举变量，:code:`primitive = 4`，经常使用"
"PRIMITIVE_TRIANGLES。"

#: ../../docs/development/file_formats/tscn.rst:328
msgid ":code:`arrays` as the name suggests is an array of array, it contains:"
msgstr ":code:`arrays`顾名思义就是一个数组数组，它包含:"

#: ../../docs/development/file_formats/tscn.rst:330
msgid "An array of vertex position"
msgstr "顶点位置数组"

#: ../../docs/development/file_formats/tscn.rst:331
msgid "Tangents array"
msgstr "切线阵列"

#: ../../docs/development/file_formats/tscn.rst:332
msgid "Vertex color array"
msgstr "顶点颜色数组"

#: ../../docs/development/file_formats/tscn.rst:333
msgid "UV array 1"
msgstr "UV阵列1"

#: ../../docs/development/file_formats/tscn.rst:334
msgid "UV array 2"
msgstr "UV阵列2"

#: ../../docs/development/file_formats/tscn.rst:335
msgid "Bone index array"
msgstr "骨索引数组"

#: ../../docs/development/file_formats/tscn.rst:336
msgid "Bone weight array"
msgstr "骨重阵列"

#: ../../docs/development/file_formats/tscn.rst:337
msgid "Vertex index array"
msgstr "顶点索引数组"

#: ../../docs/development/file_formats/tscn.rst:339
msgid ""
":code:`morph_arrays` is an array of morph, each morph is exactly an :code:"
"`arrays` without vertex index array."
msgstr ""
":code:`morph_arrays`是一个变形数组，每个变形都是一个:code:`arrays`，没有顶点"
"索引数组。"

#: ../../docs/development/file_formats/tscn.rst:342
msgid "An example of ArrayMesh:"
msgstr "ArrayMesh的一个示例:"

#: ../../docs/development/file_formats/tscn.rst:367
msgid ""
"An animation resource consists of tracks. Besides, it has 'length', 'loop' "
"and 'step' applied to all the tracks."
msgstr ""
"动画资源由轨道组成。 此外，它还有'长度'，'循环'和'步骤'应用于所有轨道。"

#: ../../docs/development/file_formats/tscn.rst:370
msgid "length"
msgstr "length"

#: ../../docs/development/file_formats/tscn.rst:371
msgid "loop"
msgstr "loop"

#: ../../docs/development/file_formats/tscn.rst:372
msgid "step"
msgstr "step"

#: ../../docs/development/file_formats/tscn.rst:374
msgid ":code:`length` and :code:`step` are both time in seconds"
msgstr ":code:`length`和:code:`step`都是以秒为单位的时间"

#: ../../docs/development/file_formats/tscn.rst:376
msgid ""
"Each track is described by a list of (key, value) pairs in the format :code:"
"`tracks/Id/Attribute`, it includes:"
msgstr ""
"每个轨道由(键，值)对列表描述，格式为:code:`tracks / Id / Attribute`，它包括:"

#: ../../docs/development/file_formats/tscn.rst:379
msgid "type"
msgstr "type"

#: ../../docs/development/file_formats/tscn.rst:380
msgid "path"
msgstr "path"

#: ../../docs/development/file_formats/tscn.rst:381
msgid "interp"
msgstr "interp"

#: ../../docs/development/file_formats/tscn.rst:382
msgid "keys"
msgstr "keys"

#: ../../docs/development/file_formats/tscn.rst:383
msgid "loop_wrap"
msgstr "loop_wrap"

#: ../../docs/development/file_formats/tscn.rst:384
msgid "imported"
msgstr "imported"

#: ../../docs/development/file_formats/tscn.rst:387
msgid ""
"The :code:`type` must be put as the first attribute of each track. The value "
"of :code:`type` can be:"
msgstr ":code:`type`必须作为每个轨道的第一个属性。 值:code:`type`可以是:"

#: ../../docs/development/file_formats/tscn.rst:390
msgid "'transform'"
msgstr "'transform'"

#: ../../docs/development/file_formats/tscn.rst:391
msgid "'value'"
msgstr "'value'"

#: ../../docs/development/file_formats/tscn.rst:392
msgid "'method'"
msgstr "'method'"

#: ../../docs/development/file_formats/tscn.rst:394
msgid ""
"The :code:`path` has the format :code:`NodePath(Path/To/Node:Attribute)`. It "
"is the path from animation root node (property of AnimationPlayer) to the "
"animated node or attribute."
msgstr ""
":code:`path`的格式为:code:`NodePath(Path / To / Node:Attribute)`。 它是从动画"
"根节点(AnimationPlayer的属性)到动画节点或属性的路径。"

#: ../../docs/development/file_formats/tscn.rst:398
msgid ""
"The :code:`interp` is the method to interpolate frames from the keyframes. "
"it is a enum variable and can has value:"
msgstr ":code:`interp`是从关键帧插入帧的方法。 它是一个枚举变量，可以有价值:"

#: ../../docs/development/file_formats/tscn.rst:401
msgid "0 (constant)"
msgstr "0(常数)"

#: ../../docs/development/file_formats/tscn.rst:402
msgid "1 (linear)"
msgstr "1(线性)"

#: ../../docs/development/file_formats/tscn.rst:403
msgid "2 (cubic)"
msgstr "2(立方)"

#: ../../docs/development/file_formats/tscn.rst:405
msgid ""
"The :code:`keys` is the keyframes, it appears as a PoolRealArray() but have "
"different structure for track with different type"
msgstr ""
":code:`keys`是关键帧，它显示为PoolRealArray()但具有不同类型的轨道的不同结构"

#: ../../docs/development/file_formats/tscn.rst:408
msgid ""
"A transform track use every 12 real number in the :code:`keys` to describte "
"a keyframe. The first number is the timestamp, the second number is the "
"transition (default 1.0 in transform track), followed by a three number "
"translation vector, followed by four number rotation quaternion (x,y,z,w) "
"and finally a three number scale vector."
msgstr ""
"变换轨道使用:code:`keys`中的每12个实数来描述一个关键帧。 第一个数字是时间戳，"
"第二个数字是转换(转换轨道中默认为1.0)，后跟三个数字转换向量，后跟四个数字旋转"
"四元数(x，y，z，w)，最后是三个数字刻度 向量。"

#: ../../docs/community/contributing/index.rst:2
msgid "Contributing"
msgstr "贡献"

#: ../../docs/community/contributing/ways_to_contribute.rst:4
msgid "Ways to contribute"
msgstr "贡献的方式"

#: ../../docs/community/contributing/ways_to_contribute.rst:6
msgid ""
"Godot Engine is a non-profit, community-driven free and open source project. "
"Almost all (but our lead dev Juan, more on that below) developers are "
"working *pro bono* on their free time, out of personal interest and for the "
"love of creating a libre engine of exceptional quality."
msgstr ""
"Godot引擎是一个非盈利的、社区驱动的免费开源项目。几乎所有的开发人员(不仅包括"
"我们的首席开发人员Juan，下面还有更多人员)都在无偿地利用他们的空闲时间，出于个"
"人兴趣和对创建一个质量卓越的libre引擎的热爱。"

#: ../../docs/community/contributing/ways_to_contribute.rst:11
msgid ""
"This means that to thrive, Godot needs as many users as possible to get "
"involved by contributing to the engine. There are many ways to contribute to "
"such a big project, making it possible for everybody to bring something "
"positive to the engine, regardless of their skill set:"
msgstr ""
"这意味着，要想蓬勃发展，Godot需要尽可能多的用户参与进来，为引擎做出贡献。有许"
"多方法可以为这样一个大项目做出贡献，使每个人都能给引擎带来一些积极的东西，不"
"管他们的技能是什么:"

#: ../../docs/community/contributing/ways_to_contribute.rst:16
msgid ""
"**Be part of the community.** The best way to contribute to Godot and help "
"it become ever better is simply to use the engine and promote it by word-of-"
"mouth, in the credits or splash screen of your games, blog posts, tutorials, "
"videos, demos, gamedev or free software events, support on the Q&A, IRC, "
"forums, Discord, etc. Participate! Being a user and advocate helps spread "
"the word about our great engine, which has no marketing budget and can "
"therefore only rely on its community to become more mainstream."
msgstr ""
"**成为社区的一份子** 为Godot做出贡献并帮助它变得更好的最佳方式就是使用引擎,在"
"下面环境中提升它的口碑：您游戏的闪屏中、博客文章、教程、视频、演示、游戏开发"
"或自由软件事件中，在Q&A、IRC、论坛、Discord等处支持它。参与进来! 作为一个用户"
"和倡导者， 这有助于宣传我们伟大的引擎，它没有营销预算，因此只能依靠它的社区变"
"得更加主流。"

#: ../../docs/community/contributing/ways_to_contribute.rst:25
msgid ""
"**Make games.** It's no secret that, to convince new users and especially "
"the industry at large that Godot is a relevant market player, we need great "
"games made with Godot. We know that the engine has a lot of potential, both "
"for 2D and 3D games, but given its young age we still lack big releases that "
"will draw attention to Godot. So keep working on your awesome projects, each "
"new game increases our credibility on the gamedev market!"
msgstr ""
"**制作游戏** 众所周知，为了说服新用户，尤其是整个行业，Godot是一个相关的市场"
"参与者，我们需要使用Godot制作出色的游戏。 我们知道该引擎在2D和3D游戏方面具有"
"很大的潜力，但考虑到它的年龄，我们仍然缺乏能够引起人们对Godot的关注。 因此，"
"继续努力完成您的精彩项目，每个新游戏都会提高我们在游戏开发市场的可信度！"

#: ../../docs/community/contributing/ways_to_contribute.rst:32
msgid ""
"**Get involved in the engine's development.** This can be by contributing "
"code via pull requests, testing the development snapshots or directly the "
"git *master* branch, report bugs or suggest enhancements on the issue "
"tracker, improve the official documentation (both the class reference and "
"tutorials) and its translations. The following sections will cover each of "
"those \"direct\" ways of contributing to the engine."
msgstr ""
"**参与引擎的开发** 这可以通过拉请求提供代码、测试开发快照或直接通过git "
"*master* 分支、报告bug或建议对问题跟踪器的增强、改进官方文档(包括类参考和教"
"程)来实现LS及其翻译。以下各节将介绍这些对引擎有贡献的“直接”方法。"

#: ../../docs/community/contributing/ways_to_contribute.rst:40
msgid ""
"**Donate.** Godot is a non-profit project, but it can still benefit from "
"user donations for many things. Apart from usual expenses such as hosting "
"costs or promotion material on events, we also use donation money to acquire "
"hardware when necessary (e.g. we used donation money to buy a Macbook Pro to "
"implement Retina/HiDPI support and various other macOS-related features). "
"Most importantly, we also used donation money to hire core developers so "
"they can work full-time on the engine. Even with a low monthly wage, we need "
"a steady donation income to continue doing this, which has been very "
"beneficial to the project so far. So if you want to donate some money to the "
"project, check `our website <https://godotengine.org/donate>`_ for details."
msgstr ""
"**捐赠** Godot是一个非盈利项目，但它仍然可以从用户捐赠中受益从而做许多事情。 "
"除了通常的费用，如托管费用或活动宣传材料，我们还在必要时使用捐款钱购买硬件(例"
"如我们使用捐款购买Macbook Pro来实施Retina/HiDPI支持以及各种其他与MacOS相关的"
"功能)。 最重要的是，我们还使用捐款来聘请核心开发人员，以便他们可以全职地开发"
"引擎。 即使月工资很低，我们也需要稳定的捐款收入才能继续这样做，这对目前的项目"
"非常有利。 因此，如果您想向项目捐款，请查看 `我们的网站 <https://godotengine."
"org/donate>`_ 以了解详情。"

#: ../../docs/community/contributing/ways_to_contribute.rst:54
msgid "Contributing code"
msgstr "贡献代码"

#: ../../docs/community/contributing/ways_to_contribute.rst:56
msgid ""
"The possibility to study, use, modify and redistribute modifications of the "
"engine's source code are the fundamental rights that Godot's `MIT <https://"
"tldrlegal.com/license/mit-license>`_ license grants you, making it `free and "
"open source software <https://en.wikipedia.org/wiki/Free_and_open-"
"source_software>`_."
msgstr ""
"研究，使用，修改和重新分配引擎源代码修改的可能性是Godot的 `MIT <https://"
"tldrlegal.com/license/mit-license>`_ 许可授予您的基本权利，使其成为 `免费且开"
"源软件 <https://en.wikipedia.org/wiki/Free_and_open-source_software>`_ 。"

#: ../../docs/community/contributing/ways_to_contribute.rst:61
msgid ""
"As such, everyone is entitled to modify `Godot's source code <https://github."
"com/godotengine/godot>`_, and send those modifications back to the upstream "
"project in the form of a patch (a text file describing the changes in a "
"ready-to-apply manner) or - in the modern workflow that we use - via a so-"
"called \"pull request\" (PR), i.e. a proposal to directly merge one or more "
"git commits (patches) into the main development branch."
msgstr ""
"因此，每个人都有权修改 `Godot的源代码 <https://github.com/godotengine/"
"godot>`_ ，并以补丁的形式将这些修改发送回上游项目(描述更改的文本文件) 以我们"
"使用的现代工作流程 - 通过所谓的“拉取请求”(PR)，即直接将一个或多个git提交(补"
"丁)合并到主要开发中的提议 科。"

#: ../../docs/community/contributing/ways_to_contribute.rst:68
msgid "Contributing code changes upstream has two big advantages:"
msgstr "上游贡献代码更改有两大优势:"

#: ../../docs/community/contributing/ways_to_contribute.rst:70
msgid ""
"Your own code will be reviewed and improved by other developers, and will be "
"further maintained directly in the upstream project, so you won't have to "
"reapply your own changes every time you move to a newer version. On the "
"other hand it comes with a responsibility, as your changes have to be "
"generic enough to be beneficial to all users, and not just your project; so "
"in some cases it might still be relevant to keep your changes only for your "
"own project, if they are too specific."
msgstr ""
"您自己的代码将由其他开发人员审查和改进，并将在上游项目中进一步直接维护，因此"
"您不必在每次迁移到新版本时重新应用自己的更改。 另一方面，它有责任，因为您的更"
"改必须足够通用，以便对所有用户有益，而不仅仅是您的项目; 所以在某些情况下，如"
"果它们太具体，那么仅为您自己的项目保留更改可能仍然有用。"

#: ../../docs/community/contributing/ways_to_contribute.rst:78
msgid ""
"The whole community will benefit from your work, and other contributors will "
"behave the same way, contributing code that will be beneficial to you. At "
"the time of this writing, more than 300 developers have contributed code "
"changes to the engine!"
msgstr ""
"整个社区将从您的工作中受益，其他贡献者将以相同的方式行事，贡献对您有益的代"
"码。 在撰写本文时，已有超过300名开发人员对引擎进行了代码更改！"

#: ../../docs/community/contributing/ways_to_contribute.rst:83
msgid ""
"To ensure good collaboration and overall quality, the Godot developers "
"enforce some rules for code contributions, for example regarding the style "
"to use in the C++ code (indentation, brackets, etc.) or the git and PR "
"workflow."
msgstr ""
"为了确保良好的协作和整体质量，Godot开发人员对代码贡献实施了一些规则，例如关于"
"在C++代码中使用的样式(缩进，括号等)或git和PR工作流程。"

#: ../../docs/community/contributing/ways_to_contribute.rst:87
msgid ""
"A good place to start is by searching for issues tagged as `junior jobs "
"<https://github.com/godotengine/godot/issues?q=is%3Aissue+is%3Aopen+label%3A"
"%22junior+job%22>`_ (or `Hacktoberfest <https://github.com/godotengine/godot/"
"issues?utf8=%E2%9C%93&q=is%3Aissue+is%3Aopen+label%3AHacktoberfest+>`_ "
"during October) on GitHub."
msgstr ""
"一个好的起点是搜索Github中标记为 `junior jobs <https://github.com/"
"godotengine/godot/issues?q=is%3Aissue+is%3Aopen+label%3A%22junior+job%22>`_ "
"的问题 (或 `Hacktoberfest <https://github.com/godotengine/godot/issues?utf8="
"%E2%9C%93&q=is%3Aissue+is%3Aopen+label%3AHacktoberfest+>`_ during October)。"

#: ../../docs/community/contributing/ways_to_contribute.rst:89
msgid ""
"Technical details about the PR workflow are outlined in a specific section, :"
"ref:`doc_pr_workflow`."
msgstr "有关PR工作流程的技术细节在特定部分中概述， :ref:`doc_pr_workflow`。"

#: ../../docs/community/contributing/ways_to_contribute.rst:92
msgid ""
"Details about the code style guidelines and the ``clang-format`` tool used "
"to enforce them are outlined in :ref:`doc_code_style_guidelines`."
msgstr ""
"有关代码样式指南和用于强制执行它们的 ``clang-format`` 工具的详细信息，请参"
"见 :ref:`doc_code_style_guidelines` 。"

#: ../../docs/community/contributing/ways_to_contribute.rst:97
msgid "Testing and reporting issues"
msgstr "测试和报告问题"

#: ../../docs/community/contributing/ways_to_contribute.rst:99
msgid ""
"Another great way of contributing to the engine is to test development "
"releases or the development branch and to report issues. It is also helpful "
"to report issues discovered in stable releases, so that they can be fixed in "
"the development branch and in future maintenance releases."
msgstr ""
"对引擎做出贡献的另一个好方法是测试开发版本或开发分支并报告问题。报告在稳定版"
"本中发现的问题也很有帮助，这样就可以在开发分支和未来的维护版本中修复它们。"

#: ../../docs/community/contributing/ways_to_contribute.rst:105
msgid "Testing development versions"
msgstr "测试开发版本"

#: ../../docs/community/contributing/ways_to_contribute.rst:107
msgid "To help with the testing, you have several possibilities:"
msgstr "为了帮助进行测试，您有以下几种可能性:"

#: ../../docs/community/contributing/ways_to_contribute.rst:109
msgid ""
"Compile the engine from source yourself, following the instructions of the :"
"ref:`Compiling <toc-devel-compiling>` page for your platform."
msgstr ""
"根据您的平台的 :ref:`Compiling <toc-devel-compiling>` 页面的说明自己编译引"
"擎。"

#: ../../docs/community/contributing/ways_to_contribute.rst:112
msgid ""
"Test official pre-release binaries when they are announced (usually on the "
"blog and other community platforms), such as alpha, beta and release "
"candidate (RC) builds."
msgstr ""
"在宣布(通常在博客和其他社区平台上)时测试官方预发布二进制文件，例如alpha，beta"
"和候选版本(RC)。"

#: ../../docs/community/contributing/ways_to_contribute.rst:115
msgid ""
"Test \"trusted\" unofficial builds of the development branch; just ask "
"community members for reliable providers. Whenever possible, it's best to "
"use official binaries or to compile yourself though, to be sure about the "
"provenance of your binaries."
msgstr ""
"测试开发分支的“可信”非官方版本; 请向社区成员询问可靠的提供商。 只要有可能，最"
"好使用官方二进制文件或编译自己，以确保二进制文件的来源。"

#: ../../docs/community/contributing/ways_to_contribute.rst:120
msgid ""
"As mentioned previously, it is also helpful to keep your eyes peeled for "
"potential bugs that might still be present in the stable releases, "
"especially when using some niche features of the engine which might get less "
"testing by the developers."
msgstr ""
"如前所述，对于可能仍然存在于稳定版本中的潜在错误，请务必留意您的眼睛，特别是"
"在使用引擎的一些小众功能时，开发人员可能会减少测试。"

#: ../../docs/community/contributing/ways_to_contribute.rst:126
msgid "Filing an issue on GitHub"
msgstr "在GitHub上提交问题"

#: ../../docs/community/contributing/ways_to_contribute.rst:128
msgid ""
"Godot uses `GitHub's issue tracker <https://github.com/godotengine/godot/"
"issues>`_ for bug reports and enhancement suggestions. You will need a "
"GitHub account to be able to open a new issue there, and click on the \"New "
"issue\" button."
msgstr ""
"Godot使用 `GitHub的问题跟踪器 <https://github.com/godotengine/godot/"
"issues>`_ 来获取错误报告和增强建议。 您需要一个GitHub帐户才能在那里打开新问"
"题，然后单击“新问题”按钮。"

#: ../../docs/community/contributing/ways_to_contribute.rst:132
msgid ""
"When you report a bug, you should keep in mind that the process is similar "
"to an appointment with your doctor. You noticed *symptoms* that make you "
"think that something might be wrong (the engine crashes, some features don't "
"work as expected, etc.). It's the role of the bug triaging team and the "
"developers to then help make the diagnosis of the issue you met, so that the "
"actual cause of the bug can be identified and addressed."
msgstr ""
"当您报告错误时，您应该记住该过程类似于与您的医生预约。 您注意到 *症状* 会让您"
"认为某些内容可能有问题(引擎崩溃，某些功能无法正常工作等)。 这是错误分类团队和"
"开发人员的角色，然后帮助您对所遇到的问题进行诊断，以便识别和解决错误的实际原"
"因。"

#: ../../docs/community/contributing/ways_to_contribute.rst:139
msgid ""
"You should therefore always ask yourself: what is relevant information to "
"give so that other Godot contributors can understand the bug, identify it "
"and hopefully fix it. Here are some of the most important infos that you "
"should always provide:"
msgstr ""
"因此，您应该始终问自己:什么是相关信息，以便其他Godot贡献者可以理解错误，识别"
"它并希望修复它。 以下是您应该始终提供的一些最重要的信息:"

#: ../../docs/community/contributing/ways_to_contribute.rst:144
msgid ""
"**Operating system.** Sometimes bugs are system-specific, i.e. they happen "
"only on Windows, or only on Linux, etc. That's particularly relevant for all "
"bugs related to OS interfaces, such as file management, input, window "
"management, audio, etc."
msgstr ""
"**操作系统** 有时错误是系统特定的，即它们仅在Windows上发生，或仅在Linux上发"
"生。这对于与OS接口相关的所有错误尤其相关，例如文件管理，输入，窗口管理，音频 "
"等。"

#: ../../docs/community/contributing/ways_to_contribute.rst:149
msgid ""
"**Hardware.** Sometimes bugs are hardware-specific, i.e. they happen only on "
"certain processors, graphic cards, etc. If you are able to, it can be "
"helpful to include information on your hardware."
msgstr ""
"**硬件** 有时错误是特定于硬件的，即它们仅在某些处理器，图形卡等上发生。如果能"
"够，则在硬件上包含信息会很有帮助。"

#: ../../docs/community/contributing/ways_to_contribute.rst:153
msgid ""
"**Godot version.** This is a must have. Some issues might be relevant in the "
"current stable release, but fixed in the development branch, or the other "
"way around. You might also be using an obsolete version of Godot and "
"experiencing a known issue fixed in a later version, so knowing this from "
"the start helps to speed up the diagnosis."
msgstr ""
"**Godot版本** 这是必须的。 某些问题可能与当前稳定版本相关，但在开发分支中已修"
"复，或者相反。 您可能还使用过时版本的Godot并在更高版本中遇到已修复的已知问"
"题，因此从一开始就了解这一点有助于加快诊断速度。"

#: ../../docs/community/contributing/ways_to_contribute.rst:159
msgid ""
"**How to reproduce the bug.** In the majority of cases, bugs are "
"reproducible, i.e. it is possible to trigger them reliably by following some "
"steps. Please always describe those steps as clearly as possible, so that "
"everyone can try to reproduce the issue and confirm it. Ideally, make a demo "
"project that reproduces this issue out of the box, zip it and attach it to "
"the issue (you can do this by drag and drop). Even if you think that the "
"issue is trivial to reproduce, adding a minimal project that lets reproduce "
"it is a big added value. You have to keep in mind that there are thousands "
"of issues in the tracker, and developers can only dedicate little time to "
"each issue."
msgstr ""
"**如何重现错误** 在大多数情况下，错误是可重现的，即可以通过遵循一些步骤可靠地"
"触发它们。 请始终尽可能清楚地描述这些步骤，以便每个人都可以尝试重现问题并进行"
"确认。 理想情况下，制作一个演示项目，可以立即重现此问题，将其压缩并将其附加到"
"问题中(您可以通过拖放操作完成此操作)。 即使您认为重现问题很简单，添加一个可以"
"重现它的最小项目也是一个很大的附加价值。 您必须记住，跟踪器中存在数千个问题，"
"开发人员只能花费很少的时间来处理每个问题。"

#: ../../docs/community/contributing/ways_to_contribute.rst:170
msgid ""
"When you click the \"New issue\" button, you should be presented with a text "
"area prefilled with our issue template. Please try to follow it so that all "
"issues are consistent and provide the required information."
msgstr ""
"单击“新问题”按钮时，应向您显示预填充问题模板的文本区域。 请尝试遵循它，以便所"
"有问题保持一致并提供所需信息。"

#: ../../docs/community/contributing/ways_to_contribute.rst:175
msgid "Contributing to the documentation"
msgstr "贡献文档"

#: ../../docs/community/contributing/ways_to_contribute.rst:177
msgid ""
"There are two separate resources referred to as \"documentation\" in Godot:"
msgstr "在Godot中有两个独立的称为“文档”的资源:"

#: ../../docs/community/contributing/ways_to_contribute.rst:179
msgid ""
"**The class reference.** This is the documentation for the complete Godot "
"API as exposed to GDScript and the other scripting languages. It can be "
"consulted offline, directly in Godot's code editor, or online at :ref:`Godot "
"API <toc-class-ref>`. To contribute to the class reference, you have to edit "
"the `doc/base/classes.xml` in Godot's git repository, and make a pull "
"request. See :ref:`doc_updating_the_class_reference` for more details."
msgstr ""
"**类型参考** 这是暴露于GDScript和其他脚本语言的完整Godot API的文档。 它可以离"
"线查询，直接在Godot的代码编辑器中查询，或在线查询 :ref:`Godot API <toc-class-"
"ref>` 。 要为类型参考做出贡献，您必须在Godot的git存储库中编辑 `doc/base/"
"classes.xml` ，并提交请求。 有关详细信息，请参阅 :ref:"
"`doc_updating_the_class_reference` 。"

#: ../../docs/community/contributing/ways_to_contribute.rst:187
msgid ""
"**The tutorials and engine documentation and its translations.** This is the "
"part you are reading now, which is distributed in the HTML, PDF and EPUB "
"formats. Its contents are generated from plain text files in the "
"reStructured Text (rst) format, to which you can contribute via pull "
"requests on the `godot-docs <https://github.com/godotengine/godot-docs>`_ "
"GitHub repository. See :ref:`doc_documentation_guidelines` for more details."
msgstr ""
"**教程和引擎文档及其翻译** 这是您现在正在阅读的部分，它以HTML，PDF和EPUB格式"
"分发。 它的内容是以reStructured Text(rst)格式的纯文本文件生成的，您可以通过 "
"`godot-docs <https://github.com/godotengine/godot-docs>`_ GitHub存储库上的提"
"交请求来贡献它们。 有关详细信息，请参阅 :ref:"
"`doc_documentation_guidelines`  。"

#: ../../docs/community/contributing/pr_workflow.rst:4
msgid "Pull request workflow"
msgstr "提交您的PR流程"

#: ../../docs/community/contributing/pr_workflow.rst:8
msgid ""
"The so-called \"PR workflow\" used by Godot is common to many projects using "
"Git, and should be familiar to veteran free software contributors. The idea "
"is that only a small number (if any) commit directly to the *master* branch. "
"Instead, contributors *fork* the project (i.e. create a copy of it, which "
"they can modify as they wish), and then use the GitHub interface to request "
"a *pull* from one of their fork's branches to one branch of the original "
"(often named *upstream*) repository."
msgstr ""
"Godot使用的所谓“PR工作流程”对于许多使用Git的项目来说都很常见，对于资深自由软"
"件贡献者应该很熟悉。 这个想法是只有少数(如果有的话)直接提交给 *master* 分"
"支。 相反，贡献者 *fork* 项目(即创建它的副本，他们可以按照自己的意愿修改)，然"
"后使用GitHub接口从其fork的一个分支请求 *pull* 到原始的一个分支( 通常命名为 "
"*upstream* )存储库。"

#: ../../docs/community/contributing/pr_workflow.rst:16
msgid ""
"The resulting *pull request* (PR) can then be reviewed by other "
"contributors, which might approve it, reject it, or most often request that "
"modifications be done. Once approved, the PR can then be merged by one of "
"the core developers, and its commit(s) will become part of the target branch "
"(usually the *master* branch)."
msgstr ""
"然后，可以由其他贡献者审查生成的 *拉取请求* (PR)，其可能批准它，拒绝它，或者"
"最常请求进行修改。 一旦获得批准，PR就可以由其中一个核心开发人员合并，其提交将"
"成为目标分支(通常是 *master* 分支)的一部分。"

#: ../../docs/community/contributing/pr_workflow.rst:22
msgid ""
"We will go together through an example to show the typical workflow and "
"associated Git commands. But first, let's have a quick look at the "
"organisation of Godot's Git repository."
msgstr ""
"我们将通过一个示例一起展示典型的工作流程和相关的Git命令。 但首先，让我们快速"
"了解Godot的Git存储库的组织。"

#: ../../docs/community/contributing/pr_workflow.rst:27
msgid "Git source repository"
msgstr "Git源代码库"

#: ../../docs/community/contributing/pr_workflow.rst:29
msgid ""
"The `repository on GitHub <https://github.com/godotengine/godot>`_ is a `Git "
"<https://git-scm.com>`_ code repository together with an embedded issue "
"tracker and PR system."
msgstr ""
"GitHub上的 `存储库 <https://github.com/godotengine/godot>`_ 是一个 `Git  "
"<https://git-scm.com>`_ 代码库以及嵌入式问题跟踪器和PR系统。"

#: ../../docs/community/contributing/pr_workflow.rst:33
msgid ""
"If you are contributing to the documentation, its repository can be found "
"`here <https://github.com/godotengine/godot-docs>`_."
msgstr ""
"如果您正在为文档做出贡献，可以在这里找到它的 `存储库 <https://github.com/"
"godotengine/godot-docs>`_ 。"

#: ../../docs/community/contributing/pr_workflow.rst:36
msgid ""
"The Git version control system is the tool used to keep track of successive "
"edits to the source code - to contribute efficiently to Godot, learning the "
"basics of the Git command line is *highly* recommended. There exist some "
"graphical interfaces for Git, but they usually encourage users to take bad "
"habits regarding the Git and PR workflow, and we therefore recommend not to "
"use them. In particular, we advise not to use GitHub's online editor for "
"code contributions (although it's tolerated for small fixes or documentation "
"changes) as it enforces one commit per file and per modification, which "
"quickly leads to PRs with an unreadable Git history (especially after peer "
"review)."
msgstr ""
"Git版本控制系统是用于跟踪源代码的连续编辑的工具 - 有效地贡献给Godot，学习Git"
"命令行的基础是 *高度* 推荐。 Git存在一些图形界面，但它们通常鼓励用户对Git和PR"
"工作流程采取不良习惯，因此我们建议不要使用它们。 特别是，我们建议不要使用"
"GitHub的在线编辑器进行代码贡献(虽然它可以容忍小修补或文档更改)，因为它会对每"
"个文件和每次修改强制执行一次提交，这很快会导致PR具有不可读的Git历史记录(特别"
"是在对等之后) 评论)。"

#: ../../docs/community/contributing/pr_workflow.rst:46
msgid ""
"The first sections of Git's \"Book\" are a good introduction to the tool's "
"philosophy and the various commands you need to master in your daily "
"workflow. You can read them online on the `Git SCM <https://git-scm.com/book/"
"en/v2>`_ website."
msgstr ""
"Git的“书籍”的第一部分是对工具理念的良好介绍，以及您在日常工作流程中需要掌握的"
"各种命令。 您可以在`Git SCM <https://git-scm.com/book/en/v2>`_ 网站上在线阅"
"读。"

#: ../../docs/community/contributing/pr_workflow.rst:51
msgid "The branches on the Git repository are organized as follows:"
msgstr "Git存储库上的分支组织如下:"

#: ../../docs/community/contributing/pr_workflow.rst:53
msgid ""
"The ``master`` branch is where the development of the next major version "
"occurs. As a development branch, it can be unstable and is not meant for use "
"in production. This is where PRs should be done in priority."
msgstr ""
"``master`` 分支是下一个主要版本开发的地方。 作为开发分支，它可能不稳定，不适"
"合用于生产。 这是应该优先进行PR的地方。"

#: ../../docs/community/contributing/pr_workflow.rst:57
msgid ""
"The stable branches are named after their version, e.g. ``3.0`` and ``2.1``. "
"They are used to backport bugfixes and enhancements from the ``master`` "
"branch to the currently maintained stable release (e.g. 3.0.2 or 2.1.5). As "
"a rule of thumb, the last stable branch is maintained until the next major "
"version (e.g. the ``2.0`` branch was maintained until the release of Godot "
"2.1). If you want to make PRs against a maintained stable branch, you will "
"have to check if your changes are also relevant for the ``master`` branch."
msgstr ""
"稳定的分支以它们的版本命名，例如  ``3.0`` 和 ``2.1`` 。 它们用于从 "
"``master`` 分支向当前维护的稳定版本(例如3.0.2或2.1.5)反向错误修正和增强。 根"
"据经验，最后一个稳定分支一直保持到下一个主要版本(例如， ``2.0`` 分支一直保持"
"到Godot 2.1发布为止)。 如果您想针对维护的稳定分支制作PR，则必须检查您的更改是"
"否也与 ``master`` 分支相关。"

#: ../../docs/community/contributing/pr_workflow.rst:65
msgid ""
"There might be feature branches at time, usually meant to be merged into the "
"``master`` branch at some time."
msgstr "有时可能会有功能分支，通常意味着在某个时候合并到 ``master`` 分支。"

#: ../../docs/community/contributing/pr_workflow.rst:69
msgid "Forking and cloning"
msgstr "分叉和克隆"

#: ../../docs/community/contributing/pr_workflow.rst:71
msgid ""
"The first step is to *fork* the `godotengine/godot <https://github.com/"
"godotengine/godot>`_ repository on GitHub. To do so, you will need to have a "
"GitHub account and to be logged in. In the top right corner of the "
"repository's GitHub page, you should see the \"Fork\" button as shown below:"
msgstr ""
"第一步是在GitHub上 *分叉*  `godotengine/godot <https://github.com/"
"godotengine/godot>`_ 库。 为此，您需要拥有一个GitHub帐户并登录。在存储库的"
"GitHub页面的右上角，您应该看到“Fork”按钮，如下所示:"

#: ../../docs/community/contributing/pr_workflow.rst:78
msgid ""
"Click it, and after a while you should be redirected to your own fork of the "
"Godot repo, with your GitHub username as namespace:"
msgstr ""
"单击它，过一会儿您应该被重定向到您自己的Godot仓库的分支，您的GitHub用户名为命"
"名空间:"

#: ../../docs/community/contributing/pr_workflow.rst:83
msgid ""
"You can then *clone* your fork, i.e. create a local copy of the online "
"repository (in Git speak, the *origin remote*). If you haven't already, "
"download Git from `its website <https://git-scm.com>`_ if you're using "
"Windows or macOS, or install it through your package manager if you're using "
"Linux."
msgstr ""
"然后您可以 *克隆* 您的分叉，即创建在线存储库的本地副本(在Git中叫做 *origin "
"remote*)。 如果您还没有，请从 `其网站 <https://git-scm.com>`_ 下载Git，如果您"
"使用的是Windows或macOS，或者如果您使用的是Linux，请通过您的软件包管理器安装"
"它。"

#: ../../docs/community/contributing/pr_workflow.rst:88
msgid ""
"If you are on Windows, open Git Bash to type commands. macOS and Linux users "
"can use their respective terminals."
msgstr ""
"如果您使用的是Windows，请打开Git Bash键入命令。 macOS和Linux用户可以使用各自"
"的终端。"

#: ../../docs/community/contributing/pr_workflow.rst:91
msgid "To clone your fork from GitHub, use the following command:"
msgstr "要从GitHub克隆您的fork，请使用以下命令:"

#: ../../docs/community/contributing/pr_workflow.rst:97
msgid ""
"In our examples, the \"$\" character denotes the command line prompt on "
"typical UNIX shells. It is not part of the command and should not be typed."
msgstr ""
"在我们的示例中，“$”字符表示典型UNIX shell上的命令行提示符。 它不是命令的一部"
"分，不应该键入。"

#: ../../docs/community/contributing/pr_workflow.rst:101
msgid ""
"After a little while, you should have a ``godot`` directory in your current "
"working directory. Move into it using the ``cd`` command:"
msgstr ""
"过了一会儿，您当前的工作目录里应该有一个 ``godot`` 目录。 使用 ``cd`` 命令进"
"入它:"

#: ../../docs/community/contributing/pr_workflow.rst:108
msgid ""
"We will start by setting up a reference to the original repository that we "
"forked:"
msgstr "我们将首先设置对我们分叉的原始存储库的引用:"

#: ../../docs/community/contributing/pr_workflow.rst:115
msgid ""
"This will create a reference named ``upstream`` pointing to the original "
"godotengine/godot repository. This will be useful when you want to pull new "
"commits from its ``master`` branch to update your fork. You have another "
"``remote`` reference named ``origin``, which points to your fork."
msgstr ""
"这将创建一个名为 ``upstream`` 的引用，指向原始的godotengine / godot存储库。 "
"当您想从它的 ``master`` 分支中提取新的提交来更新您的fork时，这将非常有用。 您"
"有另一个名为 ``origin`` 的 ``remote`` 引用，它指向您的fork。"

#: ../../docs/community/contributing/pr_workflow.rst:120
msgid ""
"You only need to do the above steps once, as long as you keep that local "
"``godot`` folder (which you can move around if you want, the relevant "
"metadata is hidden in its ``.git`` subfolder)."
msgstr ""
"您只需要做一次上面的步骤，只要您保留当地的 ``godot`` 文件夹(您可以随意移动"
"它，相关的元数据隐藏在它的 ``.git`` 子文件夹中)。"

#: ../../docs/community/contributing/pr_workflow.rst:124
msgid ""
"*Branch it, pull it, code it, stage it, commit, push it, rebase it... "
"technologic.*"
msgstr "*分支，拉它，编码，分阶段，提交，推送，重新设计......技术。*"

#: ../../docs/community/contributing/pr_workflow.rst:127
msgid ""
"This bad take on Daft Punk's *Technologic* shows the general conception Git "
"beginners have of its workflow: lots of strange commands to learn by copy "
"and paste, hoping they will work as expected. And that's actually not a bad "
"way to learn, as long as you're curious and don't hesitate to question your "
"search engine when lost, so we will give you the basic commands to know when "
"working in Git."
msgstr ""
"这对Daft Punk的* Technologic *的不良看法显示了Git初学者对其工作流程的一般概"
"念:通过复制和粘贴学习许多奇怪的命令，希望它们能按预期工作。 这实际上并不是一"
"种糟糕的学习方式，只要您好奇并且在丢失时毫不犹豫地质疑您的搜索引擎，那么我们"
"将给您基本的命令来了解在Git中工作的时间。"

#: ../../docs/community/contributing/pr_workflow.rst:135
msgid ""
"In the following, we will assume that you want to implement a feature in "
"Godot's project manager, which is coded in the ``editor/project_manager."
"cpp`` file."
msgstr ""
"在下文中，我们假设您要在Godot的项目管理器中实现一个功能，该功能在``editor / "
"project_manager.cpp``文件中编码。"

#: ../../docs/community/contributing/pr_workflow.rst:140
msgid "Branching"
msgstr "分枝"

#: ../../docs/community/contributing/pr_workflow.rst:142
msgid ""
"By default, the ``git clone`` should have put you on the ``master`` branch "
"of your fork (``origin``). To start your own feature development, we will "
"create a feature branch:"
msgstr ""
"默认情况下，``git clone``应该让您进入fork的``master``分支(``origin``)。 要开"
"始自己的功能开发，我们将创建一个功能分支:"

#: ../../docs/community/contributing/pr_workflow.rst:154
msgid "This command is equivalent:"
msgstr "此命令是等效的:"

#: ../../docs/community/contributing/pr_workflow.rst:161
msgid "If you want to go back to the ``master`` branch, you'd use:"
msgstr "如果您想回到 ``master`` 分支，您会使用:"

#: ../../docs/community/contributing/pr_workflow.rst:167
msgid ""
"You can see which branch you are currently on with the ``git branch`` "
"command:"
msgstr "您可以使用``git branch``命令查看当前使用的分支:"

#: ../../docs/community/contributing/pr_workflow.rst:178
msgid "Updating your branch"
msgstr "更新您的分支"

#: ../../docs/community/contributing/pr_workflow.rst:180
msgid ""
"This would not be needed the first time (just after you forked the upstream "
"repository). However, the next time you want to work on something, you will "
"notice that your fork's ``master`` is several commits behind the upstream "
"``master`` branch: pull requests from other contributors would have been "
"merged in the meantime."
msgstr ""
"第一次(在您分叉上游存储库之后)不需要这样做。 但是，下次您想要处理某些事情时，"
"您会注意到您的fork的 ``master`` 是上游 ``master`` 分支后面的几个提交:其他贡献"
"者的提交请求同时被合并。"

#: ../../docs/community/contributing/pr_workflow.rst:186
msgid ""
"To ensure there won't be conflicts between the feature you develop and the "
"current upstream ``master`` branch, you will have to update your branch by "
"*pulling* the upstream branch."
msgstr ""
"为了确保您开发的功能与当前上游“master”分支之间不存在冲突，您必须通过 *拉* 上"
"游分支来更新分支。"

#: ../../docs/community/contributing/pr_workflow.rst:194
msgid ""
"However, if you had local commits, this method will create a so-called "
"\"merge commit\", and you will soon hear from fellow contributors that those "
"are not wanted in PRs. Then how to update the branch without creating a "
"merge commit? You will have to use the ``--rebase`` option, so that your "
"local commits are replayed on top of the updated upstream ``master`` branch. "
"It will effectively modify the Git history of your branch, but that is for "
"the greater good."
msgstr ""
"但是，如果您有本地提交，这个方法将创建一个所谓的“合并提交”，您很快就会听到其"
"他贡献者那些在PR中不需要的东西。 那么如何在不创建合并提交的情况下更新分支？ "
"您将不得不使用 ``--rebase`` 选项，以便在更新的上游 ``master`` 分支上重放您的"
"本地提交。 它将有效地修改您的分支的Git历史，但这是为了更好的。"

#: ../../docs/community/contributing/pr_workflow.rst:201
msgid "Therefore, the command that you should (almost) always use is:"
msgstr "因此，您(几乎)总是使用的命令是:"

#: ../../docs/community/contributing/pr_workflow.rst:208
msgid "Making changes"
msgstr "做出改变"

#: ../../docs/community/contributing/pr_workflow.rst:210
msgid ""
"You would then do your changes to our example's ``editor/project_manager."
"cpp`` file with your usual development environment (text editor, IDE, etc.)."
msgstr ""
"然后，您将使用常用的开发环境(文本编辑器，IDE等)对我们的示例``editor / "
"project_manager.cpp``文件进行更改。"

#: ../../docs/community/contributing/pr_workflow.rst:214
msgid ""
"By default, those changes are *unstaged*. The staging area is a layer "
"between your working directory (where you make your modifications) and the "
"local git repository (the commits and all the metadata in the ``.git`` "
"folder). To bring changes from the working directory to the Git repository, "
"you need to *stage* them with the ``git add`` command, and then to commit "
"them with the ``git commit`` command."
msgstr ""
"默认情况下，这些更改是* unstaged *。 暂存区域是您的工作目录(您进行修改的位置)"
"和本地git存储库(“.git”文件夹中的提交和所有元数据)之间的一个层。 要将工作目录"
"中的更改带到Git存储库，您需要使用``git add``命令对它们进行* stage *，然后使用"
"``git commit``命令提交它们。"

#: ../../docs/community/contributing/pr_workflow.rst:221
msgid ""
"There are various commands you should know to review your current work, "
"before staging it, while it is staged, and after it has been committed."
msgstr "您可以通过各种命令来查看当前的工作，在分段之前，在分阶段以及提交之后。"

#: ../../docs/community/contributing/pr_workflow.rst:224
msgid ""
"``git diff`` will show you the current unstaged changes, i.e. the "
"differences between your working directory and the staging area."
msgstr "``git diff`` 将显示当前未分级的更改，即工作目录和暂存区域之间的差异。"

#: ../../docs/community/contributing/pr_workflow.rst:226
msgid ""
"``git checkout -- <files>`` will undo the unstaged changes to the given "
"files."
msgstr "``git checkout - <files>`` 将撤消给定文件的未分级更改。"

#: ../../docs/community/contributing/pr_workflow.rst:228
msgid "``git add <files>`` will *stage* the changes on the listed files."
msgstr "``git add <files>`` 将 *列出* 列出的文件的更改。"

#: ../../docs/community/contributing/pr_workflow.rst:229
msgid ""
"``git diff --staged`` will show the current staged changes, i.e. the "
"differences between the staging area and the last commit."
msgstr ""
"``git diff --staged`` 将显示当前的阶段性更改，即暂存区域和上次提交之间的差"
"异。"

#: ../../docs/community/contributing/pr_workflow.rst:231
msgid "``git reset HEAD <files>`` will *unstage* changes to the listed files."
msgstr "``git reset HEAD <files>`` 将 *unstage* 更改为列出的文件。"

#: ../../docs/community/contributing/pr_workflow.rst:232
msgid ""
"``git status`` will show you what are the currently staged and unstaged "
"modifications."
msgstr "``git status`` 将显示当前暂存和未暂存的修改。"

#: ../../docs/community/contributing/pr_workflow.rst:234
msgid ""
"``git commit`` will commit the staged files. It will open a text editor (you "
"can define the one you want to use with the ``GIT_EDITOR`` environment "
"variable or the ``core.editor`` setting in your Git configuration) to let "
"you write a commit log. You can use ``git commit -m \"Cool commit log\"`` to "
"write the log directly."
msgstr ""
"``git commit`` 将提交暂存文件。 它将打开一个文本编辑器(您可以使用 "
"``GIT_EDITOR`` 环境变量或Git配置中的 ``core.editor`` 设置来定义要使用的编辑"
"器)，以便您编写提交日志。 您可以使用 ``git commit -m “Cool commit log”`` 直接"
"写日志。"

#: ../../docs/community/contributing/pr_workflow.rst:239
msgid ""
"``git log`` will show you the last commits of your current branch. If you "
"did local commits, they should be shown at the top."
msgstr ""
"``git log`` 将显示当前分支的最后提交。 如果您做了本地提交，它们应该显示在顶"
"部。"

#: ../../docs/community/contributing/pr_workflow.rst:241
msgid ""
"``git show`` will show you the changes of the last commit. You can also "
"specify a commit hash to see the changes for that commit."
msgstr ""
"``git show`` 将显示上次提交的更改。 您还可以指定提交哈希以查看该提交的更改。"

#: ../../docs/community/contributing/pr_workflow.rst:244
#, fuzzy
msgid ""
"That's a lot to memorize! Don't worry, just check this cheat sheet when you "
"need to make changes, and learn by doing."
msgstr ""
"记住这个很多！ 不用担心，只需在需要进行更改时查看此备忘单，并边做边学。"

#: ../../docs/community/contributing/pr_workflow.rst:247
msgid "Here's how the shell history could look like on our example:"
msgstr "以下是我们的示例中shell历史记录的外观:"

#: ../../docs/community/contributing/pr_workflow.rst:279
msgid ""
"With this, we should have two new commits in our ``better-project-manager`` "
"branch which were not in the ``master`` branch. They are still only local "
"though, the remote fork does not know about them, nor does the upstream repo."
msgstr ""
"有了这个，我们应该在 ``better-project-manager`` 分支中有两个新的提交，这些提"
"交不在 ``master`` 分支中。 它们仍然只是本地的，远程分支不知道它们，上游回购也"
"不知道。"

#: ../../docs/community/contributing/pr_workflow.rst:284
msgid "Pushing changes to a remote"
msgstr "将更改推送到远程"

#: ../../docs/community/contributing/pr_workflow.rst:286
msgid ""
"That's where ``git push`` will come into play. In Git, a commit is always "
"done in the local repository (unlike Subversion where a commit will modify "
"the remote repository directly). You need to *push* the new commits to a "
"remote branch to share them with the world. The syntax for this is:"
msgstr ""
"这就是 ``git push`` 将发挥作用的地方。 在Git中，提交总是在本地存储库中完成(与"
"Subversion不同，其中提交将直接修改远程存储库)。 您需要 *将* 新提交推送到远程"
"分支以与世界共享它们。 这个语法是:"

#: ../../docs/community/contributing/pr_workflow.rst:295
msgid ""
"The part about the remote branch can be omitted if you want it to have the "
"same name as the local branch, which is our case in this example, so we will "
"do:"
msgstr ""
"如果您希望它与本地分支具有相同的名称，则可以省略关于远程分支的部分，在本示例"
"中就是这种情况，因此我们将执行以下操作:"

#: ../../docs/community/contributing/pr_workflow.rst:303
msgid ""
"Git will ask you for your username and password, and the changes will be "
"sent to your remote. If you check the fork's page on GitHub, you should see "
"a new branch with your added commits."
msgstr ""
"Git会询问您的用户名和密码，更改将发送到您的遥控器。 如果您在GitHub上检查fork"
"的页面，您会看到一个带有您添加的提交的新分支。"

#: ../../docs/community/contributing/pr_workflow.rst:308
msgid "Issuing a pull request"
msgstr "发出拉取请求"

#: ../../docs/community/contributing/pr_workflow.rst:310
msgid ""
"When you load your fork's branch on GitHub, you should see a line saying *"
"\"This branch is 2 commits ahead of godotengine:master.\"* (and potentially "
"some commits behind, if your ``master`` branch was out of sync with the "
"upstream ``master`` branch."
msgstr ""
"当您在GitHub上加载fork的分支时，您应该看到一行说“这个分支是在godotengine:"
"master之前提交2次。”*(如果您的 ``master`` 分支不同步，可能会有一些提交。 上游"
"的 ``master`` 分支。"

#: ../../docs/community/contributing/pr_workflow.rst:317
msgid ""
"On that line, there is a \"Pull request\" link. Clicking it will open a form "
"that will let you issue a pull request on the godotengine/godot upstream "
"repository. It should show you your two commits, and state \"Able to merge"
"\". If not (e.g. it has way more commits, or says there are merge "
"conflicts), don't create the PR, something went wrong. Go to IRC and ask for "
"support :)"
msgstr ""
"在那一行，有一个“拉请求”链接。 单击它将打开一个表单，让您在godotengine / "
"godot上游存储库上发出拉取请求。 它应该显示您的两个提交，并声明“能够合并”。 如"
"果没有(例如，它有更多的提交，或说有合并冲突)，不要创建PR，出错了。 去IRC并寻"
"求支持:)"

#: ../../docs/community/contributing/pr_workflow.rst:323
msgid ""
"Use an explicit title for the PR and put the necessary details in the "
"comment area. You can drag and drop screenshots, GIFs or zipped projects if "
"relevant, to showcase what your work implements. Click \"Create a pull "
"request\", and tadaa!"
msgstr ""
"使用PR的明确标题并在评论区域中放置必要的详细信息。 您可以拖放屏幕截图，GIF或"
"压缩项目(如果相关)，以展示您的工作实施的内容。 点击“创建拉取请求”和tadaa！"

#: ../../docs/community/contributing/pr_workflow.rst:329
msgid "Modifying a pull request"
msgstr "修改拉取请求"

#: ../../docs/community/contributing/pr_workflow.rst:331
msgid ""
"While it is reviewed by other contributors, you will often need to make "
"changes to your yet-unmerged PR, either because contributors requested them, "
"or because you found issues yourself while testing."
msgstr ""
"虽然它是由其他贡献者审核的，但您经常需要对尚未合并的PR进行更改，或者是因为贡"
"献者要求他们，或者是因为您在测试时发现了自己的问题。"

#: ../../docs/community/contributing/pr_workflow.rst:335
msgid ""
"The good news is that you can modify a pull request simply by acting on the "
"branch you made the pull request from. You can e.g. make a new commit on "
"that branch, push it to your fork, and the PR will be updated automatically:"
msgstr ""
"好消息是您可以简单地通过对您发出拉取请求的分支进行操作来修改拉取请求。 您可"
"以，例如 在该分支上进行新的提交，将其推送到您的分支，PR将自动更新:"

#: ../../docs/community/contributing/pr_workflow.rst:350
msgid "That should do the trick, but..."
msgstr "这应该是诀窍，但......"

#: ../../docs/community/contributing/pr_workflow.rst:353
msgid "Mastering the PR workflow: the rebase"
msgstr "掌握PR工作流程:rebase"

#: ../../docs/community/contributing/pr_workflow.rst:355
msgid ""
"On the situation outlined above, your fellow contributors who are "
"particularly pedantic regarding the Git history might ask your to *rebase* "
"your branch to *squash* or *meld* the last two commits together (i.e. the "
"two related to the project manager), as the second commit basically fixes an "
"issue in the first one."
msgstr ""
"在上面提到的情况下，您的贡献者对于Git历史特别迂腐可能会要求您 *您的分支* 您的"
"分支*或者*合并*最后两个一起提交(即两个与项目经理有关)， 因为第二个提交基本上"
"解决了第一个问题。"

#: ../../docs/community/contributing/pr_workflow.rst:360
msgid ""
"Once the PR is merged, it is not relevant for a changelog reader that the PR "
"author made mistakes; instead, we want to keep only commits that bring from "
"one working state to another working state."
msgstr ""
"一旦公关合并，公关作者就会犯错误，与变更日志读者无关; 相反，我们希望只保留从"
"一个工作状态到另一个工作状态的提交。"

#: ../../docs/community/contributing/pr_workflow.rst:364
msgid ""
"To squash those two commits together, we will have to *rewrite history*. "
"Right, we have that power. You may read that it's a bad practice, and it's "
"true when it comes to branches of the upstream repo. But in your fork, you "
"can do whatever you want, and everything is allowed to get neat PRs :)"
msgstr ""
"要将这两个提交压缩在一起，我们将不得不 *重写历史记录* 。 对，我们有这种力"
"量。 您可能会读到这是一个不好的做法，当涉及到上游回购的分支时，它是真的。 但"
"是在您的分叉中，您可以做任何您想做的事情，并且一切都被允许得到整洁的PR :)"

#: ../../docs/community/contributing/pr_workflow.rst:369
msgid ""
"We will use the *interactive rebase* ``git rebase -i`` to do this. This "
"command takes a commit hash as argument, and will let you modify all commits "
"between that commit hash and the last one of the branch, the so-called "
"*HEAD*. In our example, we want to act on the last two commits, so we will "
"do:"
msgstr ""
"我们将使用* interactive rebase *``git rebase -i``来执行此操作。 此命令将提交"
"哈希作为参数，并允许您修改该提交哈希与分支的最后一个之间的所有提交，即所谓的"
"* HEAD *。 在我们的示例中，我们希望对最后两次提交采取行动，因此我们将执行以下"
"操作:"

#: ../../docs/community/contributing/pr_workflow.rst:380
msgid "This will open a text editor with:"
msgstr "这将打开一个文本编辑器:"

#: ../../docs/community/contributing/pr_workflow.rst:387
msgid ""
"The editor will also show instructions regarding how you can act on those "
"commits. In particular, it should tell you that \"pick\" means to use that "
"commit (do nothing), and that \"squash\" and \"fixup\" can be used to *meld* "
"the commit in its parent commit. The difference between \"squash\" and "
"\"fixup\" is that \"fixup\" will discard the commit log from the squashed "
"commit. In our example, we are not interested in keeping the log of the "
"\"Fix a typo\" commit, so we use:"
msgstr ""
"编辑器还将显示有关如何对这些提交采取行动的说明。 特别是，它应该告诉您“pick”意"
"味着使用该提交(什么都不做)，并且“squash”和“fixup”可以用于 *在其父提交中* 提交"
"*提交。 “squash”和“fixup”之间的区别在于“fixup”会从压缩的提交中丢弃提交日志。 "
"在我们的示例中，我们对保持“修复错字”提交的日志不感兴趣，因此我们使用:"

#: ../../docs/community/contributing/pr_workflow.rst:400
msgid ""
"Upon saving and quitting the editor, the rebase will occur. The second "
"commit will be melded into the first one, and ``git log`` and ``git show`` "
"should now confirm that you have only one commit with the changes from both "
"previous commits."
msgstr ""
"保存并退出编辑器后，将发生rebase。 第二个提交将被融合到第一个提交中，而``git "
"log``和``git show``现在应该确认您只有一个提交，其中包含来自两个先前提交的更"
"改。"

#: ../../docs/community/contributing/pr_workflow.rst:405
msgid ""
"You could have avoided this rebase by using ``git commit --amend`` when "
"fixing the typo. This command will write the staged changes directly into "
"the *last* commit (``HEAD``), instead of creating a new commit like we did "
"in this example. So it is equivalent to what we did with a new commit and "
"then a rebase to mark it as \"fixup\"."
msgstr ""
"您可以在修复拼写错误时使用``git commit --amend``来避免这种变形。 此命令将分阶"
"段更改直接写入* last * commit(``HEAD``)，而不是像我们在此示例中那样创建新提"
"交。 所以它等同于我们对新提交所做的事情，然后是一个将其标记为“fixup”的"
"rebase。"

#: ../../docs/community/contributing/pr_workflow.rst:411
msgid ""
"But! You rewrote the history, and now your local and remote branches have "
"diverged. Indeed, commit 1b4aad7 in the above example will have changed, and "
"therefore got a new commit hash. If you try to push to your remote branch, "
"it will raise an error:"
msgstr ""
"但！ 您重写了历史，现在您的本地和远程分支已经分道扬.. 实际上，上面示例中的提"
"交1b4aad7已经更改，因此获得了新的提交哈希。 如果您尝试推送到远程分支，则会引"
"发错误:"

#: ../../docs/community/contributing/pr_workflow.rst:425
msgid ""
"This is a sane behaviour, Git will not let you push changes that would "
"override remote content. But that's actually what we want to do here, so we "
"will have to *force* it:"
msgstr ""
"这是一个理智的行为，Git不会让您推送会覆盖远程内容的更改。 但这实际上是我们想"
"要做的，所以我们必须 *强制* 它:"

#: ../../docs/community/contributing/pr_workflow.rst:433
msgid ""
"And tadaa! Git will happily *replace* your remote branch with what you had "
"locally (so make sure that's what you wanted, using ``git log``). This will "
"also update the PR accordingly."
msgstr ""
"还有tadaa！ Git很乐意 *用您在本地拥有的东西替换* 您的远程分支(所以使用``git "
"log``确保您想要的东西)。 这也将相应地更新PR。"

#: ../../docs/community/contributing/pr_workflow.rst:438
msgid "Deleting a Git branch"
msgstr "删除Git分支"

#: ../../docs/community/contributing/pr_workflow.rst:440
msgid ""
"After your pull request gets merged, there's one last thing you should do: "
"delete your Git branch for the PR. There won't be issues if you don't delete "
"your branch, but it's good practice to do so. You'll need to do this twice, "
"once for the local branch and another for the remote branch on GitHub."
msgstr ""
"在您的提交请求合并之后，您应该做的最后一件事是:删除您的PR的Git分支。 如果不删"
"除分支，则不会出现问题，但最好这样做。 您需要两次执行此操作，一次用于本地分"
"支，另一次用于GitHub上的远程分支。"

#: ../../docs/community/contributing/pr_workflow.rst:445
msgid "To delete our better project manager branch locally, use this command:"
msgstr "要在本地删除更好的项目管理器分支，请使用以下命令:"

#: ../../docs/community/contributing/pr_workflow.rst:451
msgid ""
"Alternatively, if the branch hadn't been merged yet and we wanted to delete "
"it anyway, instead of ``-d`` you would use ``-D``."
msgstr ""
"或者，如果分支尚未合并，我们想要删除它，而不是 ``-d`` ，您会使用 ``-D`` 。"

#: ../../docs/community/contributing/pr_workflow.rst:454
msgid "Next, to delete the remote branch on GitHub use this command:"
msgstr "接下来，要删除GitHub上的远程分支，请使用以下命令:"

#: ../../docs/community/contributing/code_style_guidelines.rst:4
msgid "Code style guidelines"
msgstr "代码风格指南"

#: ../../docs/community/contributing/code_style_guidelines.rst:8
msgid ""
"When contributing to Godot's source code, you will be expected to follow the "
"style guidelines outlined below. Some of them are checked via the Continuous "
"Integration process and reviewers will ask you to fix potential issues, so "
"best setup your system as outlined below to ensure all your commits follow "
"the guidelines."
msgstr ""
"在贡献给Godot的源代码时，您需要遵循下面概述的样式指南。其中一些是通过持续集成"
"过程进行检查的，评审人员将要求您修复潜在的问题，因此最好按照下面概述的方式设"
"置系统，以确保所有提交都遵循指导原则。"

#: ../../docs/community/contributing/code_style_guidelines.rst:15
msgid "C++ and Objective-C"
msgstr "C++和Objective-C"

#: ../../docs/community/contributing/code_style_guidelines.rst:17
msgid ""
"There are no written guidelines, but the code style agreed upon by the "
"developers is enforced via the `clang-format <http://clang.llvm.org/docs/"
"ClangFormat.html>`__ code beautifier, which takes care for you of all our "
"conventions. To name a few:"
msgstr ""
"没有书面的指导方针，但是开发人员默认的代码风格是通过 `clang-format <http://"
"clang.llvm.org/docs/ClangFormat.html>`__ 代码美化器强制执行的，它可以满足我们"
"所有的约定。举几个示例:"

#: ../../docs/community/contributing/code_style_guidelines.rst:22
msgid ""
"Indentation and alignment are both tab based (respectively one and two tabs)"
msgstr "缩进和对齐都是基于标签的(分别是一个和两个标签)"

#: ../../docs/community/contributing/code_style_guidelines.rst:23
msgid "One space around math and assignments operators as well as after commas"
msgstr "数学和作业运算符以及逗号后面的一个空格"

#: ../../docs/community/contributing/code_style_guidelines.rst:24
msgid ""
"Pointer and reference operators are affixed to the variable identifier, not "
"to the type name"
msgstr "指针和引用运算符附加到变量标识符，而不是类型名称"

#: ../../docs/community/contributing/code_style_guidelines.rst:26
msgid "See further down regarding header includes"
msgstr "有关标题包括，请参见下文"

#: ../../docs/community/contributing/code_style_guidelines.rst:28
msgid ""
"The rules used by clang-format are outlined in the `.clang-format <https://"
"github.com/godotengine/godot/blob/master/.clang-format>`__ file of the Godot "
"repository."
msgstr ""
"clang格式使用的规则在Godot存储库的 `.clang-format <https://github.com/"
"godotengine/godot/blob/master/.clang-format>`__ 文件中列出。"

#: ../../docs/community/contributing/code_style_guidelines.rst:32
msgid ""
"As long as you ensure that your style matches the surrounding code and that "
"you not introducing trailing whitespace or space-based indentation, you "
"should be fine. If you plan to contribute regularly however, we strongly "
"advise that you setup clang-format locally to check and automatically fix "
"all your commits."
msgstr ""
"只要您确保您的样式与周围的代码匹配，并且您没有引入尾随空格或基于空格的缩进，"
"您应该没问题。 如果您计划定期投稿，我们强烈建议您在本地设置clang-format以检查"
"并自动修复所有提交。"

#: ../../docs/community/contributing/code_style_guidelines.rst:37
msgid ""
"Godot's code style should *not* be applied to thirdparty code, i.e. that is "
"included in Godot's source tree but was not written specifically for our "
"project. Such code usually come from different upstream projects with their "
"own style guides (or lack thereof), and don't want to introduce differences "
"that would make syncing with upstream repositories harder."
msgstr ""
"Godot的代码风格应该*不适用于第三方代码，即包含在Godot的源代码树中，但不是专门"
"为我们的项目编写的。 这样的代码通常来自不同的上游项目，具有自己的样式指南(或"
"缺少样式指南)，并且不希望引入会使上游存储库同步变得更难的差异。"

#: ../../docs/community/contributing/code_style_guidelines.rst:44
msgid ""
"Thirdparty code is usually included in the ``thirdparty/`` folder and can "
"thus easily be excluded from formatting scripts. For the rare cases where a "
"thirdparty code snippet needs to be included directly within a Godot file, "
"you can use ``/* clang-format off */`` and ``/* clang-format on */`` to tell "
"clang-format to ignore a chunk of code."
msgstr ""
"第三方代码通常包含在 ``thirdparty /`` 文件夹中，因此可以轻松地从格式化脚本中"
"排除。 对于需要将第三方代码段直接包含在Godot文件中的极少数情况，您可以使用 "
"``/* clang-format off  */`` 和 ``/* clang-format on */`` 来告诉clang-format忽"
"略一大块代码。"

#: ../../docs/community/contributing/code_style_guidelines.rst:52
msgid "Using clang-format locally"
msgstr "在本地使用clang格式"

#: ../../docs/community/contributing/code_style_guidelines.rst:54
msgid ""
"First of all, you will need to install clang-format. As of now, you need to "
"use **clang-format 6.x** to be compatible with Godot's format. Later "
"versions might be suitable, but previous versions had bugs that will cause "
"formatting changes to the current code base."
msgstr ""
"首先，您需要安装clang-format。 截至目前，您需要使用** clang-format 6.x **与"
"Godot的格式兼容。 更高版本可能是合适的，但以前的版本有错误，将导致格式更改当"
"前代码库。"

#: ../../docs/community/contributing/code_style_guidelines.rst:60
msgid "Installation"
msgstr "安装"

#: ../../docs/community/contributing/code_style_guidelines.rst:62
msgid "Here's how to install clang-format:"
msgstr "以下是如何安装clang-format:"

#: ../../docs/community/contributing/code_style_guidelines.rst:64
msgid ""
"Linux: It will usually be available out-of-the-box with the clang toolchain "
"packaged by your distribution. If your distro version is not the required "
"one, you can download a pre-compiled version from the `LLVM website <http://"
"releases.llvm.org/download.html>`__, or if you are on a Debian derivative, "
"use the `upstream repos <http://apt.llvm.org/>`__."
msgstr ""
"Linux:它通常可以通过您的发行版打包的clang工具链开箱即用。 如果您的发行版不是"
"必需的版本，您可以从 `LLVM网站 <http://releases.llvm.org/download.html>`__ 下"
"载预编译版本，或者如果您使用的是Debian衍生版本， 使用 `upstream repos "
"<http://apt.llvm.org/>`__。"

#: ../../docs/community/contributing/code_style_guidelines.rst:69
msgid ""
"macOS and Windows: You can download precompiled binaries from the `LLVM "
"website <http://releases.llvm.org/download.html>`__. You may need to add the "
"path to the binary's folder to your system's ``PATH`` environment variable "
"to be able to call ``clang-format`` out of the box."
msgstr ""
"macOS和Windows:您可以从 `LLVM网站 <http://releases.llvm.org/download."
"html>`__ 下载预编译的二进制文件。 您可能需要将二进制文件夹的路径添加到系统的 "
"``PATH`` 环境变量中，以便能够开箱即可调用 ``clang-format`` 。"

#: ../../docs/community/contributing/code_style_guidelines.rst:74
msgid ""
"You then have different possibilities to apply clang-format to your changes:"
msgstr "然后，您可以将clang-format应用于更改:"

#: ../../docs/community/contributing/code_style_guidelines.rst:77
msgid "Manual usage"
msgstr "手动使用"

#: ../../docs/community/contributing/code_style_guidelines.rst:79
msgid ""
"You can apply clang-format manually one or more files with the following "
"command:"
msgstr "您可以使用以下命令手动应用clang-format一个或多个文件:"

#: ../../docs/community/contributing/code_style_guidelines.rst:86
msgid ""
"``-i`` means that the changes should be written directly to the file (by "
"default clang-format would only output the fixed version to the terminal)."
msgstr ""
"``-i``表示更改应直接写入文件(默认情况下，clang-format只会将固定版本输出到终"
"端)。"

#: ../../docs/community/contributing/code_style_guidelines.rst:88
msgid ""
"The path can point to several files, either one after the other or using "
"wildcards like in a typical Unix shell. Be careful when globbing so that you "
"don't run clang-format on compiled objects (.o and .a files) that are in "
"Godot's tree. So better use ``core/*.{cpp,h}`` than ``core/*``."
msgstr ""
"该路径可以指向多个文件，可以是一个接一个，也可以使用通配符(如典型的Unix "
"shell)。 在globbing时要小心，这样就不会在Godot树中的编译对象(.o和.a文件)上运"
"行clang-format。 所以最好使用``core / *。{cpp，h}``而不是``core / *``。"

#: ../../docs/community/contributing/code_style_guidelines.rst:94
msgid "Pre-commit hook"
msgstr "预提交钩子"

#: ../../docs/community/contributing/code_style_guidelines.rst:96
msgid ""
"For ease of use, we provide a pre-commit hook for Git that will run clang-"
"format automatically on all your commits to check them, and let you apply "
"its changes in the final commit."
msgstr ""
"为了便于使用，我们为Git提供了一个预提交挂钩，它将在所有提交中自动运行clang-"
"format以检查它们，并允许您在最终提交中应用其更改。"

#: ../../docs/community/contributing/code_style_guidelines.rst:100
msgid ""
"This \"hook\" is a script which can be found in ``misc/hooks``, refer to "
"that folder's README.md for installation instructions."
msgstr ""
"这个“钩子”是一个可以在``misc / hooks``中找到的脚本，请参阅该文件夹的README.md"
"以获取安装说明。"

#: ../../docs/community/contributing/code_style_guidelines.rst:103
msgid ""
"If your clang-format is not in the ``PATH``, you may have to edit the ``pre-"
"commit-clang-format`` to point to the correct binary for it to work. The "
"hook was tested on Linux and macOS, but should also work in the Git Shell on "
"Windows."
msgstr ""
"如果您的clang格式不在 ``PATH`` 中，您可能需要编辑 ``pre-commit-clang-"
"format`` 来指向正确的二进制格式才能工作。 钩子在Linux和macOS上测试过，但也应"
"该在Windows上的Git Shell中运行。"

#: ../../docs/community/contributing/code_style_guidelines.rst:109
msgid "IDE plugin"
msgstr "IDE插件"

#: ../../docs/community/contributing/code_style_guidelines.rst:111
msgid ""
"Most IDEs or code editors have beautifier plugins that can be configured to "
"run clang-format automatically, for example each time you save a file."
msgstr ""
"大多数IDE或代码编辑器都有美化插件，可以配置为自动运行clang格式，例如每次保存"
"文件时。"

#: ../../docs/community/contributing/code_style_guidelines.rst:114
msgid "Here is a non-exhaustive list of beautifier plugins for some IDEs:"
msgstr "以下是某些IDE的美化插件的非详尽列表:"

#: ../../docs/community/contributing/code_style_guidelines.rst:116
msgid ""
"Qt Creator: `Beautifier plugin <http://doc.qt.io/qtcreator/creator-"
"beautifier.html>`__"
msgstr ""
"Qt Creator: `美化插件 <http://doc.qt.io/qtcreator/creator-beautifier.html>`__"

#: ../../docs/community/contributing/code_style_guidelines.rst:117
msgid ""
"Visual Studio Code: `Clang-Format <https://marketplace.visualstudio.com/"
"items?itemName=xaver.clang-format>`__"
msgstr ""
"Visual Studio Code: `Clang-格式 <https://marketplace.visualstudio.com/items?"
"itemName=xaver.clang-format>`__"

#: ../../docs/community/contributing/code_style_guidelines.rst:118
msgid ""
"Visual Studio: `ClangFormat <https://marketplace.visualstudio.com/items?"
"itemName=LLVMExtensions.ClangFormat>`__"
msgstr ""
"Visual Studio: `Clang格式 <https://marketplace.visualstudio.com/items?"
"itemName=LLVMExtensions.ClangFormat>`__"

#: ../../docs/community/contributing/code_style_guidelines.rst:119
msgid "vim: `vim-clang-format <https://github.com/rhysd/vim-clang-format>`__"
msgstr "vim: `vim-clang-格式 <https://github.com/rhysd/vim-clang-format>`__"

#: ../../docs/community/contributing/code_style_guidelines.rst:121
msgid "(Pull requests welcome to extend this list with tested plugins.)"
msgstr "(拉请求欢迎使用经过测试的插件扩展此列表。)"

#: ../../docs/community/contributing/code_style_guidelines.rst:124
msgid "Header includes"
msgstr "标题包括"

#: ../../docs/community/contributing/code_style_guidelines.rst:126
msgid ""
"When adding new C++ or Objective-C files or including new headers in "
"existing ones, the following rules should be followed:"
msgstr ""
"添加新的C++或Objective-C文件或在现有文件中包含新标头时，应遵循以下规则:"

#: ../../docs/community/contributing/code_style_guidelines.rst:129
msgid ""
"The first lines in the file should be Godot's copyright header and MIT "
"license, copy-pasted from another file. Make sure to adjust the filename."
msgstr ""
"文件中的第一行应该是Godot的版权标题和MIT许可证，从另一个文件复制粘贴。 确保调"
"整文件名。"

#: ../../docs/community/contributing/code_style_guidelines.rst:131
msgid ""
"In a ``.h`` header, include guards should be used with the form "
"``FILENAME_H``."
msgstr "在 ``.h`` 头文件中，include guard应该与 ``FILENAME_H`` 形式一起使用。"

#: ../../docs/community/contributing/code_style_guidelines.rst:134
msgid ""
"In a ``.cpp`` file (e.g. ``filename.cpp``), the first include should be the "
"one where the class is declared (e.g. ``#include \"filename.h\"``), followed "
"by an empty line for separation."
msgstr ""
"在 ``.cpp`` 文件中(例如 ``filename.cpp`` )，第一个include应该是声明类的那个"
"(例如 ``#include“filename.h”`` )，然后是 空行分离。"

#: ../../docs/community/contributing/code_style_guidelines.rst:137
msgid ""
"Then come headers from Godot's own code base, included in alphabetical order "
"(enforced by ``clang-format``) with paths relative to the root folder. Those "
"includes should be done with quotes, e.g. ``#include \"core/object.h\"``. "
"The block of Godot header includes should then be followed by an empty line "
"for separation."
msgstr ""
"然后来自Godot自己的代码库的标题，按字母顺序(由`clang-format``强制执行)包含相"
"对于根文件夹的路径。 这些包括应该用引号来完成，例如 ``#include“core / object."
"h”``。 然后应该在一个空行之后进行分离。"

#: ../../docs/community/contributing/code_style_guidelines.rst:142
msgid ""
"Finally, thirdparty headers (either from ``thirdparty`` or from the system's "
"include paths) come next and should be included with the < and > symbols, e."
"g. ``#include <png.h>``. The block of thirdparty headers should also be "
"followed by an empty line for separation."
msgstr ""
"最后，第三方标题(来自 ``thirdparty`` 或来自系统的包含路径)接下来应该包含在<和"
">符号中，例如 ``#include <png.h>``。 第三方标题块后面还应跟一个空行进行分隔。"

#: ../../docs/community/contributing/code_style_guidelines.rst:146
msgid ""
"Godot and thirdparty headers should be included in the file that requires "
"them, i.e. in the `.h` header if used in the declarative code or in the `."
"cpp` if used only in the imperative code."
msgstr ""
"Godot和第三方标题应该包含在需要它们的文件中，即如果在声明性代码中使用`.h`标"
"题，或者如果仅在命令式代码中使用则在`.cpp`中。"

#: ../../docs/community/contributing/code_style_guidelines.rst:238
msgid "Java"
msgstr "Java"

#: ../../docs/community/contributing/code_style_guidelines.rst:240
msgid ""
"Godot's Java code (mostly in ``platform/android``) is also enforced via "
"``clang-format``, so see the instructions above to set it up. Keep in mind "
"that this style guide only applies to code written and maintained by Godot, "
"not thirdparty code such as the ``java/src/com/google`` subfolder."
msgstr ""
"Godot的Java代码(主要在``platform / android``中)也通过``clang-format``强制执"
"行，因此请参阅上面的说明进行设置。 请记住，此样式指南仅适用于Godot编写和维护"
"的代码，而不适用于第三方代码，例如``java / src / com / google``子文件夹。"

#: ../../docs/community/contributing/code_style_guidelines.rst:246
msgid "Python"
msgstr "Python"

#: ../../docs/community/contributing/code_style_guidelines.rst:248
msgid ""
"Godot's SCons buildsystem is written in Python, and various scripts included "
"in the source tree are also using Python."
msgstr ""
"Godot的SCons构建系统是用Python编写的，源代码树中包含的各种脚本也使用Python。"

#: ../../docs/community/contributing/code_style_guidelines.rst:251
msgid ""
"For those, we follow the `PEP-8 style guide <https://www.python.org/dev/peps/"
"pep-0008/>`__, this is however not as strongly enforced as for the C++ code. "
"If you are so inclined, you can check and format your Python changes using "
"`autopep8 <https://pypi.org/project/autopep8/>`__."
msgstr ""
"对于那些，我们遵循 `PEP-8样式指南 <https://www.python.org/dev/peps/pep-0008/"
">`__ ，但这并不像C++代码那样强制执行。 如果您如此倾向，可以使用 `autopep8 "
"<https://pypi.org/project/autopep8/>`__ 来检查和格式化您的Python更改。"

#: ../../docs/community/contributing/bug_triage_guidelines.rst:4
msgid "Bug triage guidelines"
msgstr "错误分类指南"

#: ../../docs/community/contributing/bug_triage_guidelines.rst:6
msgid ""
"This page describes the typical workflow of the bug triage team aka bugsquad "
"when handling issues and pull requests on Godot's `GitHub <https://github."
"com/godotengine/godot>`_ repository. It is bound to evolve together with the "
"bugsquad, so do not hesitate to propose modifications to the following "
"guidelines."
msgstr ""
"本页面描述了bug分类团队即bugsquad在处理问题和从Godot的 `GitHub <https://"
"github.com/godotengine/godot>`_ 存储库上提取请求时的典型工作流程。它一定会与"
"bugsquad一起发展，所以不要犹豫对下面的指导方针提出修改。"

#: ../../docs/community/contributing/bug_triage_guidelines.rst:12
msgid "Issues management"
msgstr "问题管理"

#: ../../docs/community/contributing/bug_triage_guidelines.rst:14
msgid "GitHub proposes various features to manage issues:"
msgstr "GitHub提出了各种管理问题的功能:"

#: ../../docs/community/contributing/bug_triage_guidelines.rst:16
msgid "Set one or several labels from a predefined list"
msgstr "从预定义列表中设置一个或多个标签"

#: ../../docs/community/contributing/bug_triage_guidelines.rst:17
msgid "Set one milestone from a predefined list"
msgstr "从预定义列表中设置一个里程碑"

#: ../../docs/community/contributing/bug_triage_guidelines.rst:18
msgid "Keep track of the issue in the project dashboard"
msgstr "在项目仪表板中跟踪问题"

#: ../../docs/community/contributing/bug_triage_guidelines.rst:19
msgid ""
"Define one contributor as \"assignee\" among the Godot engine organization "
"members"
msgstr "在Godot引擎组织成员中定义一个贡献者作为“受托者”"

#: ../../docs/community/contributing/bug_triage_guidelines.rst:22
msgid ""
"As the Godot engine organization on GitHub currently has a restricted number "
"of contributors, we do not use assignees extensively for now. All "
"contributors are welcome to take on any issue, if relevant after mentioning "
"it on the issue ticket and/or discussing the best way to resolve it with "
"other developers."
msgstr ""
"由于GitHub上的Godot引擎组织目前的贡献者数量有限，我们暂时不会广泛使用受托"
"者。 欢迎所有贡献者在问题单上提及和/或讨论与其他开发人员解决问题的最佳方法"
"后，如果相关，可以处理任何问题。"

#: ../../docs/community/contributing/bug_triage_guidelines.rst:28
msgid "For the time being we do not use the project dashboard feature either."
msgstr "暂时我们也不使用项目仪表板功能。"

#: ../../docs/community/contributing/bug_triage_guidelines.rst:30
msgid ""
"As far as possible, we try to assign labels (and milestones, when relevant) "
"to both issues and pull requests."
msgstr "我们尽可能尝试为问题和拉取请求分配标签(和相关的里程碑)。"

#: ../../docs/community/contributing/bug_triage_guidelines.rst:34
msgid "Labels"
msgstr "标签"

#: ../../docs/community/contributing/bug_triage_guidelines.rst:36
msgid "The following labels are currently defined in the Godot repository:"
msgstr "目前在Godot存储库中定义了以下标签:"

#: ../../docs/community/contributing/bug_triage_guidelines.rst:38
msgid "**Categories:**"
msgstr "**分类:**"

#: ../../docs/community/contributing/bug_triage_guidelines.rst:40
msgid ""
"*Archived*: either a duplicate of another issue, or invalid. Such an issue "
"would also be closed."
msgstr "*Archived*:是另一个问题的副本，或无效。 这样的问题也将被关闭。"

#: ../../docs/community/contributing/bug_triage_guidelines.rst:42
msgid "*Bug*: describes something that is not working properly."
msgstr "*Bug*:描述无法正常工作的内容。"

#: ../../docs/community/contributing/bug_triage_guidelines.rst:43
msgid ""
"*Confirmed*: has been confirmed by at least one other contributor than the "
"bug reporter (typically for *Bug* reports). The purpose of this label is to "
"let developers know which issues are still reproducible when they want to "
"select what to work on. It is therefore a good practice to add in a comment "
"on what platform and what version or commit of Godot the issue could be "
"reproduced; if a developer looks at the issue one year later, the "
"*Confirmed* label may not be relevant anymore."
msgstr ""
"*Confirmed*: 已由至少一个其他贡献者确认，而不是错误报告者(通常用于* Bug *报"
"告)。 此标签的目的是让开发人员知道哪些问题在他们想要选择要处理的内容时仍然可"
"以重现。 因此，在一个评论中添加评论可以复制该问题的Godot是什么平台和什么版本"
"或提交是一个好的做法; 如果开发人员在一年后查看该问题，则* Confirmed *标签可能"
"不再相关。"

#: ../../docs/community/contributing/bug_triage_guidelines.rst:51
msgid ""
"*Discussion*: the issue is not consensual and needs further discussion to "
"define what exactly should be done to address the topic."
msgstr ""
"*Discussion*: 问题不是自愿的，需要进一步讨论，以确定应该采取什么措施来解决这"
"个问题。"

#: ../../docs/community/contributing/bug_triage_guidelines.rst:54
msgid ""
"*Documentation*: issue related to the documentation. Mainly to request "
"enhancements in the API documentation. Issues related to the ReadTheDocs "
"documentation should be filed on the `godot-docs <https://github.com/"
"godotengine/godot-docs>`_ repository."
msgstr ""
"*Documentation*: 与文档相关的问题。 主要是要求增强API文档。 与ReadTheDocs文档"
"相关的问题应该在 `godot-docs <https://github.com/godotengine/godot-docs>`_ 储"
"存库上提交。"

#: ../../docs/community/contributing/bug_triage_guidelines.rst:58
msgid ""
"*Enhancement*: describes a proposed enhancement to an existing functionality."
msgstr "*Enhancement*: 描述对现有功能的建议增强。"

#: ../../docs/community/contributing/bug_triage_guidelines.rst:60
msgid ""
"*Feature proposal*: describes a wish for a new feature to be implemented."
msgstr "*Feature proposal*: 描述了实现新功能的愿望。"

#: ../../docs/community/contributing/bug_triage_guidelines.rst:62
msgid ""
"*Junior job*: the issue is *assumed* to be an easy one to fix, which makes "
"it a great fit for junior contributors who need to become familiar with the "
"code base."
msgstr ""
"*Junior job*: *假设*是一个容易修复的问题，这使得它非常适合需要熟悉代码库的初"
"级贡献者。"

#: ../../docs/community/contributing/bug_triage_guidelines.rst:65
msgid "*Needs rebase*: the issue need a git rebase to be merged."
msgstr "*Needs rebase*: 该问题需要合并git rebase。"

#: ../../docs/community/contributing/bug_triage_guidelines.rst:66
msgid ""
"*Needs testing*: the issue/pull request could not be completely tested and "
"thus need further testing. This can mean that it needs to be tested on "
"different hardware/software configurations or even that the steps to "
"reproduce are not certain."
msgstr ""
"*Needs testing*: 问题/拉取请求无法完全测试，因此需要进一步测试。 这可能意味着"
"需要在不同的硬件/软件配置上进行测试，或者甚至需要重现的步骤不确定。"

#: ../../docs/community/contributing/bug_triage_guidelines.rst:70
msgid ""
"*PR welcome / hero wanted!*: Contributions for issues with these labels are "
"especially welcome. Note that this **doesn't** mean you can't work on issues "
"without these labels."
msgstr ""
"*PR welcome / hero wanted!*: 特别欢迎对这些标签的问题的贡献。 请注意，这 **并"
"不** 意味着您无法处理没有这些标签的问题。"

#: ../../docs/community/contributing/bug_triage_guidelines.rst:73
msgid ""
"*Tracker*: issue used to track other issues (like all issues related to the "
"plugin system)."
msgstr "*Tracker*: 用于跟踪其他问题的问题(例如与插件系统相关的所有问题)。"

#: ../../docs/community/contributing/bug_triage_guidelines.rst:75
msgid "*Usability*: issues that directly impact user usability."
msgstr "*Usability*: 直接影响用户可用性的问题。"

#: ../../docs/community/contributing/bug_triage_guidelines.rst:77
msgid ""
"The categories are used for general triage of the issues. They can be "
"combined in some way when relevant, e.g. an issue can be labelled "
"*Enhancement* and *Usability* at the same time if it's an issue to improve "
"usability. Or *Feature proposal* and *Discussion* if it's a non-consensual "
"feature request, or one that is not precise enough to be worked on."
msgstr ""
"这些类别用于问题的一般分类。 它们可以在相关时以某种方式组合，例如， 如果这是"
"一个提高可用性的问题，则可以同时将问题标记为 *Enhancement* 和 *Usability*。 "
"或者 *Feature proposal* 和 *Discussion* 如果它是非自愿的功能请求，或者不够精"
"确的功能请求。"

#: ../../docs/community/contributing/bug_triage_guidelines.rst:83
msgid "**Topics:**"
msgstr "**话题:**"

#: ../../docs/community/contributing/bug_triage_guidelines.rst:85
msgid "*Assetlib*: relates to issues with the asset library."
msgstr "*Assetlib*: 与资源馆的问题有关。"

#: ../../docs/community/contributing/bug_triage_guidelines.rst:86
msgid "*Audio*: relates to the audio features (low and high level)."
msgstr "*Audio*: 与音频功能(低级别和高级别)有关。"

#: ../../docs/community/contributing/bug_triage_guidelines.rst:87
msgid ""
"*Buildsystem*: relates to building issues, either linked to the SCons "
"buildsystem or to compiler peculiarities."
msgstr "*Buildsystem*: 与构建问题有关，可以链接到SCons构建系统或编译器特性。"

#: ../../docs/community/contributing/bug_triage_guidelines.rst:89
msgid ""
"*Core*: anything related to the core engine. It might be further split later "
"on as it's a pretty big topic."
msgstr ""
"*Core*: 与核心引擎相关的任何内容。 它可能会在以后进一步分裂，因为这是一个非常"
"大的话题。"

#: ../../docs/community/contributing/bug_triage_guidelines.rst:91
msgid "*Drivers*: relates to issues with the drivers used by the engine."
msgstr "*Drivers*: 与引擎使用的驱动程序有关。"

#: ../../docs/community/contributing/bug_triage_guidelines.rst:92
msgid "*Editor*: relates to issues in the editor (mainly UI)."
msgstr "*Editor*: 与编辑器中的问题(主要是UI)有关。"

#: ../../docs/community/contributing/bug_triage_guidelines.rst:93
msgid "*GDNative*: relates to the GDNative module."
msgstr "*GDNative*: 与GDNative模块有关。"

#: ../../docs/community/contributing/bug_triage_guidelines.rst:94
msgid "*GDScript*: relates to GDScript."
msgstr "*GDScript*: 与GDScript有关。"

#: ../../docs/community/contributing/bug_triage_guidelines.rst:95
msgid "*Mono*: relates to the C# / Mono bindings."
msgstr "*Mono*: 与C# / Mono绑定有关。"

#: ../../docs/community/contributing/bug_triage_guidelines.rst:96
msgid "*Network*: relates to networking."
msgstr "*Network*: 与网络有关。"

#: ../../docs/community/contributing/bug_triage_guidelines.rst:97
msgid "*Physics*: relates to the physics engine (2D/3D)."
msgstr "*Physics*: 与物理引擎(2D/3D)有关。"

#: ../../docs/community/contributing/bug_triage_guidelines.rst:98
msgid "*Plugin*: relates to problems encountered while writing plugins."
msgstr "*Plugin*: 与编写插件时遇到的问题有关。"

#: ../../docs/community/contributing/bug_triage_guidelines.rst:99
msgid "*Porting*: relates to some specific platforms."
msgstr "*Porting*: 与某些特定平台有关。"

#: ../../docs/community/contributing/bug_triage_guidelines.rst:100
msgid "*Rendering*: relates to the 2D and 3D rendering engines."
msgstr "*Rendering*: 与2D和3D渲染引擎相关。"

#: ../../docs/community/contributing/bug_triage_guidelines.rst:101
msgid "*VisualScript*: relates to issues with the visual scripting language."
msgstr "*VisualScript*: 与可视化脚本语言的问题有关。"

#: ../../docs/community/contributing/bug_triage_guidelines.rst:103
msgid ""
"Issues would typically correspond to only one topic, though it's not "
"unthinkable to see issues that fit two bills. The general idea is that there "
"will be specialized contributors teams behind all topics, so they can focus "
"on the issues labelled with their team's topic."
msgstr ""
"问题通常只对应一个主题，但看到符合两个法案的问题并不是不可想象的。 一般的想法"
"是，将有专门的贡献者团队支持所有主题，因此他们可以专注于标记为团队主题的问"
"题。"

#: ../../docs/community/contributing/bug_triage_guidelines.rst:108
msgid "**Platforms:**"
msgstr "**平台:**"

#: ../../docs/community/contributing/bug_triage_guidelines.rst:110
msgid "*Android*, *HTML5*, *iOS*, *Linux*, *macOS*, *Windows*, *UWP*"
msgstr "*Android*, *HTML5*, *iOS*, *Linux*, *macOS*, *Windows*, *UWP*"

#: ../../docs/community/contributing/bug_triage_guidelines.rst:112
msgid ""
"By default, it is assumed that a given issue applies to all platforms. If "
"one of the platform labels is used, it is then exclusive and the previous "
"assumption doesn't stand anymore (so if it's a bug on e.g. Android and Linux "
"exclusively, select those two platforms)."
msgstr ""
"默认情况下，假定给定的问题适用于所有平台。 如果使用其中一个平台标签，则它是独"
"占的，之前的假设不再适用(因此，如果它是例如Android和Linux上的错误，请选择这两"
"个平台)。"

#: ../../docs/community/contributing/bug_triage_guidelines.rst:118
msgid "Milestones"
msgstr "里程碑"

#: ../../docs/community/contributing/bug_triage_guidelines.rst:120
msgid ""
"`Milestones <https://github.com/godotengine/godot/milestones>`_ correspond "
"to planned future versions of Godot for which there is an existing roadmap. "
"Issues that fit in the said roadmap should be filed under the corresponding "
"milestone; if they don't correspond to any current roadmap, they should be "
"left without milestone. As a rule of thumb, an issue corresponds to a given "
"milestone if it concerns a feature that is new in the milestone, or a "
"critical bug that can't be accepted in any future stable release, or "
"anything that Juan wants to work on right now :)"
msgstr ""
"`里程碑 <https://github.com/godotengine/godot/milestones>`_ 对应计划的未来版"
"本的Godot，其中存在一个现有的路线图。 适用于上述路线图的问题应在相应的里程碑"
"下提交; 如果它们不符合任何当前的路线图，则应该没有里程碑。 根据经验，如果问题"
"涉及里程碑中的新功能，或者任何未来稳定版本中无法接受的关键错误，或者Juan想要"
"正确使用的任何内容，则问题对应于给定的里程碑 现在:)"

#: ../../docs/community/contributing/bug_triage_guidelines.rst:129
msgid ""
"Contributors are free to pick issues regardless of their assigned milestone; "
"if a fix is proposed for a bug that was not deemed urgent and thus without "
"milestone, it would likely still be very welcome."
msgstr ""
"无论指定的里程碑如何，贡献者都可以自由选择问题; 如果针对一个不被认为是紧急的"
"错误提出修复，因此没有里程碑，那么它可能仍然非常受欢迎。"

#: ../../docs/community/contributing/documentation_guidelines.rst:4
msgid "Documentation guidelines"
msgstr "文件指南"

#: ../../docs/community/contributing/documentation_guidelines.rst:6
msgid ""
"This page describes the rules to follow if you want to contribute to Godot "
"Engine by writing or reviewing documentation, or by translating existing "
"documentation. Also have a look at README of the `godot-docs GitHub "
"repository <https://github.com/godotengine/godot-docs>`_ and the `docs front "
"page <https://docs.godotengine.org>`_ on what steps to follow and how to "
"contact the docs team."
msgstr ""
"本页介绍了如果您想通过编写或查看文档或翻译现有文档来为Godot Engine做出贡献的"
"规则。 另请参阅 `godot-docs GitHub存储库 <https://github.com/godotengine/"
"godot-docs>`_ 的README和 `docs首页 <http://docs.godotengine.org>`_ 关于要遵循"
"的步骤以及如何联系文档团队。"

#: ../../docs/community/contributing/documentation_guidelines.rst:14
#: ../../docs/community/contributing/updating_the_class_reference.rst:17
msgid "How to contribute"
msgstr "如何贡献"

#: ../../docs/community/contributing/documentation_guidelines.rst:16
msgid ""
"Creating or modifying documentation pages is mainly done via the `godot-docs "
"GitHub repository <https://github.com/godotengine/godot-docs>`_. The HTML "
"(or PDF and EPUB) documentation is generated from the .rst files "
"(reStructuredText markup language) in that repository. Modifying those pages "
"in a pull request and getting it merged will trigger a rebuild of the online "
"documentation."
msgstr ""
"创建或修改文档页面主要通过 `godot-docs GitHub存储库 <https://github.com/"
"godotengine/godot-docs>`_ 来完成。 HTML(或PDF和EPUB)文档是从该存储库中的.rst"
"文件(reStructuredText标记语言)生成的。 在拉取请求中修改这些页面并将其合并将触"
"发重建在线文档。"

#: ../../docs/community/contributing/documentation_guidelines.rst:23
msgid ""
"For details on Git usage and the pull request workflow, please refer to the :"
"ref:`doc_pr_workflow` page. Most of what it describes regarding the main "
"godotengine/godot repository is also valid for the docs repository."
msgstr ""
"有关Git用法和拉取请求工作流程的详细信息，请参阅 :ref:`doc_pr_workflow` 页"
"面。 它描述的关于主godotengine / godot存储库的大部分内容，这对文档存储库也是"
"有效的。"

#: ../../docs/community/contributing/documentation_guidelines.rst:28
msgid ""
"The README.md file contains all the information you need to get you started, "
"please read it. In particular, it contains some tips and tricks and links to "
"reference documentation about the reStructuredText markup language."
msgstr ""
"README.md文件包含了入门所需的所有信息，请阅读它。 特别是，它包含一些提示和技"
"巧以及有关reStructuredText标记语言的参考文档的链接。"

#: ../../docs/community/contributing/documentation_guidelines.rst:32
msgid ""
"If you want to edit the **API reference**, please note that it should *not* "
"be done in the godot-docs repository. Instead, you should edit the ``doc/"
"classes/*`` XML files of Godot's main repository. These files are then later "
"used to generate the in-editor documentation as well as the API reference of "
"the online docs. Read more here: :ref:`doc_updating_the_class_reference`."
msgstr ""
"如果您想编辑 **API引用** ，请注意它不应该在godot-docs存储库中完成。 相反，您"
"应该编辑Godot的主存储库的 ``doc / classes / *`` 的XML文件。 然后，这些文件将"
"用于生成编辑器内文档以及在线文档的API参考。 在这里阅读更多 : :ref:"
"`doc_updating_the_class_reference`。"

#: ../../docs/community/contributing/documentation_guidelines.rst:40
msgid "What makes good documentation?"
msgstr "什么是良好的文档？"

#: ../../docs/community/contributing/documentation_guidelines.rst:42
msgid ""
"Documentation should be well written in plain English, using well-formed "
"sentences and various levels of sections and subsections. It should be clear "
"and objective. Also have a look at the :ref:`doc_docs_writing_guidelines`."
msgstr ""
"文档应该用简单的英语写成，使用格式良好的句子和各种级别的章节和小节。 它应该清"
"楚客观。 另请看 :ref:`doc_docs_writing_guidelines` 。"

#: ../../docs/community/contributing/documentation_guidelines.rst:46
msgid ""
"We differentiate tutorial pages from other documentation pages by these "
"definitions:"
msgstr "我们通过以下定义将教程页面与其他文档页面区分开来:"

#: ../../docs/community/contributing/documentation_guidelines.rst:49
msgid ""
"Tutorial: a page aiming at explaining how to use one or more concepts in the "
"editor or scripts in order to achieve a specific goal with a learning "
"purpose (e.g. \"Making a simple 2d Pong game\", \"Applying forces to an "
"object\")."
msgstr ""
"教程:旨在解释如何在编辑器或脚本中使用一个或多个概念以实现具有学习目的的特定目"
"标的页面(例如“制作简单的2d乒乓游戏”，“将力施加到对象”)。"

#: ../../docs/community/contributing/documentation_guidelines.rst:53
msgid ""
"Documentation: a page describing precisely one and only one concept at a "
"time, if possible exhaustively (e.g. the list of methods of the Sprite "
"class, or an overview of the input management in Godot)."
msgstr ""
"文档:一个页面，如果可能的话，一次只描述一个且只有一个概念(例如Sprite类的方法"
"列表，或者Godot中输入管理的概述)。"

#: ../../docs/community/contributing/documentation_guidelines.rst:57
msgid ""
"You are free to write the kind of documentation you wish, as long as you "
"respect the following rules (and the ones on the repo)."
msgstr ""
"只要您遵守以下规则(以及储存库中的规则)，您就可以自由地编写所需的文档类型。"

#: ../../docs/community/contributing/documentation_guidelines.rst:61
msgid "Titles"
msgstr "标题"

#: ../../docs/community/contributing/documentation_guidelines.rst:63
msgid "Always begin pages with their title and a Sphinx reference name:"
msgstr "始终以其标题和Sphinx参考名称开始页面:"

#: ../../docs/community/contributing/documentation_guidelines.rst:72
msgid ""
"The reference allows to link to this page using the ``:ref:`` format, e.g. "
"``:ref:`doc_insert_your_title_here``` would link to the above example page "
"(note the lack of leading underscore in the reference)."
msgstr ""
"引用允许使用 `` :ref:`` 格式链接到此页面，例如 `` :ref:"
"`doc_insert_your_title_here``` 将链接到上面的示例页面(注意引用中缺少前导下划"
"线)。"

#: ../../docs/community/contributing/documentation_guidelines.rst:76
msgid ""
"Also, avoid American CamelCase titles: title's first word should begin with "
"a capitalized letter, and every following word should not. Thus, this is a "
"good example:"
msgstr ""
"另外，避免使用美国CamelCase标题:标题的第一个单词应以大写字母开头，而后面的每"
"个单词都不应该。 因此，这是一个很好的示例:"

#: ../../docs/community/contributing/documentation_guidelines.rst:80
msgid "Insert your title here"
msgstr "Insert your title here"

#: ../../docs/community/contributing/documentation_guidelines.rst:82
msgid "And this is a bad example:"
msgstr "这是一个糟糕的示例:"

#: ../../docs/community/contributing/documentation_guidelines.rst:84
msgid "Insert Your Title Here"
msgstr "Insert Your Title Here"

#: ../../docs/community/contributing/documentation_guidelines.rst:86
msgid ""
"Only project, people and node class names should have capitalized first "
"letter."
msgstr "只有项目，人员和节点类名称应该首字母大写。"

#: ../../docs/community/contributing/documentation_guidelines.rst:90
msgid "Translating existing pages"
msgstr "翻译现有页面"

#: ../../docs/community/contributing/documentation_guidelines.rst:92
msgid ""
"You can help to translate the official Godot documentation on our `Hosted "
"Weblate <https://hosted.weblate.org/engage/godot-engine/>`_."
msgstr ""
"您可以帮助我们翻译或校对托管在 `Weblate <https://hosted.weblate.org/engage/"
"godot-engine/>`_ 上的官方Godot文档。"

#: ../../docs/community/contributing/documentation_guidelines.rst:99
msgid ""
"There also is the official `Godot I18N repository <https://github.com/"
"godotengine/godot-docs-l10n>`_. where you can see when the data was last "
"synced."
msgstr ""
"还有官方的 `Godot I18N存储库 <https://github.com/godotengine/godot-docs-"
"l10n>`_ 。 您可以在哪里查看数据上次同步的时间。"

#: ../../docs/community/contributing/documentation_guidelines.rst:104
msgid ""
"This documentation and every page it contains is published under the terms "
"of the `Creative Commons Attribution 3.0 license (CC-BY-3.0) <https://"
"tldrlegal.com/license/creative-commons-attribution-(cc)>`_, with attribution "
"to \"Juan Linietsky, Ariel Manzur and the Godot community\"."
msgstr ""
"本文档及其包含的每个页面均根据 `知识共享署名3.0许可证(CC-BY-3.0) <https://"
"tldrlegal.com/license/creative-commons-attribution-(cc)>`_ 的条款发布 ，归属"
"于“Juan Linietsky，Ariel Manzur和Godot社区”。"

#: ../../docs/community/contributing/documentation_guidelines.rst:107
msgid ""
"By contributing to the documentation on the GitHub repository, you agree "
"that your changes are distributed under this license."
msgstr "通过贡献GitHub存储库上的文档，您同意您的更改是根据此许可证分发的。"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:4
msgid "Docs writing guidelines"
msgstr "文档编写指南"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:6
msgid ""
"The Godot community is rich and international. Users come from all around "
"the world. Some of them are young, and many aren't native English speakers. "
"That's why we must all write using a clear and a common language. For the "
"class reference, the goal is to make it easy to read for everyone and "
"precise."
msgstr ""
"Godot社区富裕而国际化。 用户来自世界各地。 他们中的一些人很年轻，很多人不是母"
"语为英语的人。 这就是为什么我们都必须使用清晰和通用的语言写作。 对于类型参"
"考，目标是让每个人都能轻松阅读和精确。"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:12
msgid "In summary, always try to:"
msgstr "总之，总是尝试:"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:14
#: ../../docs/community/contributing/docs_writing_guidelines.rst:39
msgid "Use the direct voice"
msgstr "使用陈述句型"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:15
#: ../../docs/community/contributing/docs_writing_guidelines.rst:74
msgid "Use precise action verbs"
msgstr "使用精确的动作动词"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:16
#: ../../docs/community/contributing/docs_writing_guidelines.rst:96
msgid "Avoid verbs that end in -ing"
msgstr "避免以-ing结尾的动词"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:17
msgid "Remove unnecessary adverbs and adjectives."
msgstr "删除不必要的副词和形容词。"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:18
msgid ""
"Ban these 8 words: obvious, simple, basic, easy, actual, just, clear, and "
"however"
msgstr ""
"禁止这8个字:obvious, simple, basic, easy, actual, just, clear, and however"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:19
#: ../../docs/community/contributing/docs_writing_guidelines.rst:210
msgid "Use explicit references"
msgstr "使用显式引用"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:20
#: ../../docs/community/contributing/docs_writing_guidelines.rst:231
msgid "Use 's to show possession"
msgstr "用's表示所有权"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:21
msgid "Use the Oxford comma"
msgstr "使用牛津逗号"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:23
msgid "There are 3 rules to describe classes:"
msgstr "描述类有3个规则:"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:25
#: ../../docs/community/contributing/docs_writing_guidelines.rst:278
msgid "Give an overview of the node in the brief description"
msgstr "在简要说明中概述节点"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:26
#: ../../docs/community/contributing/docs_writing_guidelines.rst:307
msgid "Mention what methods return if it's useful"
msgstr "如果它有用，请提及返回哪些方法"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:27
#: ../../docs/community/contributing/docs_writing_guidelines.rst:332
msgid "Use \"if true\" to describe booleans"
msgstr "使用“if true”来描述布尔值"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:31
msgid ""
"A technical writer's job is to pack as much information as possible into the "
"smallest and clearest sentences possible. These guidelines will help you "
"work towards that goal."
msgstr ""
"技术作家的工作是将尽可能多的信息打包成尽可能最小和最清晰的句子。 这些指南将帮"
"助您实现这一目标。"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:36
msgid "7 rules for a clear english"
msgstr "清晰英语的7条规则"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:41
msgid ""
"Use the direct voice when possible. Take the classes, methods, and constants "
"you describe as the subject. It's natural to write using the passive voice, "
"but it's harder to read and produces longer sentences."
msgstr ""
"尽可能使用陈述句型。 将您描述的类，方法和常量作为主题。 使用被动语态编写是很"
"自然的，但它更难阅读并产生更长的句子。"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:47
msgid "Passive:"
msgstr "被动句:"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:53
msgid "Active:"
msgstr "主动句:"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:59
#: ../../docs/community/contributing/docs_writing_guidelines.rst:313
msgid "**Don't** use the passive voice:"
msgstr "**不要** 使用被动语态:"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:66
msgid "**Do** use the node's name as a noun:"
msgstr "**请** 使用节点的名称作为名词:"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:76
msgid ""
"Favor precise yet common verbs over generic ones like ``make``, ``set``, and "
"any expression you can replace with a single word."
msgstr ""
"赞成精确而常用的动词而非普通的动词，比如 ``make`` ， ``set`` ，以及任何可以用"
"单个单词替换的表达式。"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:79
msgid ""
"**Don't** repeat the method's name. It already states it sets the pivot "
"value to a new one:"
msgstr "**不要** 重复方法的名称。 它已经声明它将枢轴值设置为新值:"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:87
msgid ""
"**Do** explain what's the consequence of this \"set\": use precise verbs "
"like ``place``, ``position``, ``rotate``, ``fade``, etc."
msgstr ""
"**请** 解释这个“集合”的后果是什么:使用精确的动词，如 ``place`` ，"
"``position``， ``rotate`` ，``fade``等。"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:98
msgid ""
"The progressive forms describe continuous actions. E.g. \"is calling\", \"is "
"moving\"."
msgstr "渐进形式描述了连续行动。 例如。 “正在呼唤”，“正在移动”。"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:101
msgid "**Don't** use the progressive form for instant changes."
msgstr "**不要** 使用渐进形式进行即时更改。"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:108
msgid "**Do** use simple present, preterit or future."
msgstr "**请** 使用简单的礼物，preterit或将来。"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:115
msgid ""
"You may use the progressive tense to describe actions that are continuous in "
"time. Anything like animation or coroutines."
msgstr ""
"您可以使用渐进式时态来描述在时间上连续的动作。 任何像动画或协同程序的东西。"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:120
msgid ""
"Verbs can turn into adjectival nouns with -ing. This is not a conjugation, "
"so you may use them: ``the remaining movement``, ``the missing file``, etc."
msgstr ""
"动词可以变成带有-ing的形容词名词。 这不是一个共轭，所以您可以使用它们: ``剩余"
"的运动`` ，``缺少的文件``等等。"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:125
msgid "Remove unnecessary adverbs and adjectives"
msgstr "删除不必要的副词和形容词"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:127
msgid ""
"Write as few adjectives and adverbs as possible. Only use them if they add "
"key information to the description."
msgstr "写尽可能少的形容词和副词。 只有在将关键信息添加到描述中时才使用它们。"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:130
msgid ""
"**Don't** use redundant or meaningless adverbs. Words that lengthen the "
"documentation but don't add any information:"
msgstr "**不要** 使用冗余或无意义的副词。 延长文档但不添加任何信息的单词:"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:137
msgid "**Do** write short sentences in a simple, descriptive language:"
msgstr "*用* 一种简单的描述性语言写短句:"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:144
msgid "Ban these 8 words"
msgstr "禁止这8个字"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:146
msgid "**Don't** ever use these 8 banned words:"
msgstr "**不要** 使用这8个被禁止的词:"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:148
msgid "obvious"
msgstr "obvious"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:149
msgid "simple"
msgstr "simple"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:150
msgid "basic"
msgstr "basic"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:151
msgid "easy"
msgstr "easy"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:152
msgid "actual"
msgstr "actual"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:153
msgid "just"
msgstr "just"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:154
msgid "clear"
msgstr "clear"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:155
msgid "however (some uses)"
msgstr "however (some uses)"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:157
msgid ""
"Game creation and programming aren't simple, and nothing's easy to someone "
"learning to use the API for the first time. Other words in the list, like "
"``just`` or ``actual`` won't add any info to the sentence. Don't use "
"corresponding adverbs either: obviously, simply, basically, easily, "
"actually, clearly."
msgstr ""
"游戏创建和编程并不简单，对于第一次学习使用API的人来说，没有什么比这更容易"
"了。 列表中的其他单词，如 ``just`` 或``actual``，不会在句子中添加任何信息。 "
"也不要使用相应的副词:obviously, simply, basically, easily, actually, "
"clearly。"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:163
msgid ""
"**Don't** example. The banned words lengthen the description and take "
"attention away from the most important info:"
msgstr "**不要** 示例。 被禁止的单词会延长描述并将注意力从最重要的信息上移开:"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:171
msgid "**Do** remove them:"
msgstr "**请** 删除它们:"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:178
msgid ""
"\"Simple\" never helps. Remember, for other users, anything could be complex "
"or frustrate them. There's nothing like a good old *it's simple* to make you "
"cringe. Here's the old brief description, the first sentence on the Timer "
"node's page:"
msgstr ""
"“简单”永远不会有帮助。 请记住，对于其他用户来说，任何事情都可能很复杂或令人沮"
"丧。 没有什么比这更好的了 *它很简单* 让您畏缩。 这是旧的简要说明，即Timer节点"
"页面上的第一句话:"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:188
msgid "**Do** explain what the node does instead:"
msgstr "**请** 解释节点的作用:"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:195
msgid "**Don't** use \"basic\", it is too vague:"
msgstr "**不要** 使用“basic”，它太模糊了:"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:202
msgid "**Do** use the brief description to offer an overview of the node:"
msgstr "**请** 使用简要说明来概述节点:"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:212
msgid "Favor explicit references over implicit ones."
msgstr "支持隐式引用而不是隐式引用。"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:214
msgid ""
"**Don't** use words like \"the former\", \"the latter\", etc. They're not "
"the most common in English, and they require you to check the reference."
msgstr ""
"**不要** 使用“前者”，“后者”等词语。它们不是英语中最常见的词语，它们要求您查看"
"参考文献。"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:221
msgid "**Do** repeat words. They remove all ambiguity:"
msgstr "**做** 重复的话。 他们删除所有歧义:"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:227
msgid ""
"If you need to repeat the same variable name 3 or 4 times, you probably need "
"to rephrase your description."
msgstr "如果您需要重复相同的变量名3或4次，您可能需要重新描述您的描述。"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:233
msgid ""
"Avoid \"The milk **of** the cow\". It feels unnatural in English. Write "
"\"The cow's milk\" instead."
msgstr ""
"避免 \"The milk **of** the cow\"。 英语感觉不自然。 写一下\"The cow's milk"
"\" 。"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:236
msgid "**Don't** write \"of the X\":"
msgstr "**不要**写“X”:"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:242
msgid ""
"**Do** use ``'s``. It lets you put the main subject at the start of the "
"sentence, and keep it short:"
msgstr "**请**使用 ``'s`` 。 它允许您将主要主题放在句子的开头，并保持简短:"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:250
msgid "Use the Oxford comma to enumerate anything"
msgstr "使用牛津逗号枚举任何内容"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:252
msgid "From the Oxford dictionary:"
msgstr "来自牛津词典:"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:254
msgid ""
"The 'Oxford comma' is an optional comma before the word 'and' at the end of "
"a list: *We sell books, videos, and magazines.*"
msgstr ""
"“牛津逗号”是列表末尾“和”之前的可选逗号:*We sell books, videos, and magazines."
"*"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:257
msgid ""
"[...] Not all writers and publishers use it, but it can clarify the meaning "
"of a sentence when the items in a list are not single words: *These items "
"are available in black and white, red and yellow, and blue and green.*"
msgstr ""
"[...]并非所有作家和出版商都使用它，但当列表中的项目不是单个单词时，它可以澄清"
"句子的含义:*这些项目有黑色和白色，红色和黄色，以及蓝色和 绿色。*"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:260
msgid "**Don't** leave the last element of a list without a comma:"
msgstr "**不要**没有逗号留下列表的最后一个元素:"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:266
msgid ""
"**Do** add a comma before `and` or `or`, for the last element of a list with "
"more than two elements."
msgstr ""
"**对于包含两个以上元素的列表的最后一个元素，请在`和`或`或`之前添加逗号。"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:275
msgid "How to write methods and classes"
msgstr "如何编写方法和类"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:280
msgid ""
"The brief description is the reference's most important sentence. It's the "
"user's first contact with a node:"
msgstr "简要说明是参考文献中最重要的一句话。 这是用户与节点的第一次接触:"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:283
msgid "It's the only description in the \"Create New Node\" dialog."
msgstr "这是“创建新节点”对话框中的唯一描述。"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:284
msgid "It's at the top of every page in the reference"
msgstr "它位于参考中每个页面的顶部"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:286
msgid ""
"The brief description should explain the node's role and its functionality, "
"in up to 200 characters."
msgstr "简要说明应解释节点的角色及其功能，最多200个字符。"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:289
msgid "**Don't** write tiny and vague summaries:"
msgstr "**不要**写出微小而模糊的摘要:"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:296
msgid "**Do** give an overview of the node's functionality:"
msgstr "**请**概述节点的功能:"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:303
msgid ""
"Use the node's full description to provide more information, and a code "
"example, if possible."
msgstr "如果可能，请使用节点的完整描述来提供更多信息和代码示例。"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:309
msgid ""
"Some methods return important values. Describe them at the end of the "
"description, ideally on a new line. No need to mention the return values for "
"any method whose name starts with ``set`` or ``get``."
msgstr ""
"一些方法返回重要的值。 在描述的最后描述它们，理想情况是在新的一行。 无需提及"
"名称以 ``set`` 或``get``开头的任何方法的返回值。"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:320
msgid "**Do** always use \"Returns\"."
msgstr "**总是** 使用 \"Returns\"。"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:327
msgid ""
"Notice the exception to the \"direct voice\" rule: with the move method, an "
"external collider can influence the method and the body that calls ``move``. "
"In this case, you can use the passive voice."
msgstr ""
"注意“陈述句”规则的例外:使用移动方法，外部对撞机可以影响调用“移动”的方法和主"
"体。 在这种情况下，您可以使用被动语态。"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:334
msgid ""
"For boolean member variables, always use ``if true`` and/or ``if false``, to "
"stay explicit. ``Controls whether or not`` may be ambiguous and won't work "
"for every member variable."
msgstr ""
"对于布尔成员变量，总是使用``if true``和/或``if false``来保持显式。 ``控制是否"
"``可能不明确，不适用于每个成员变量。"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:338
#, fuzzy
msgid ""
"Also surround boolean values, variable names and methods with ``[code][/"
"code]``."
msgstr "还用[code][/code]包围布尔值，变量名和方法。"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:340
msgid "**Do** start with \"if true\":"
msgstr "**请以“if true”开头**:"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:349
#, fuzzy
msgid "Use ``[code]`` around arguments"
msgstr "在参数周围使用[code]"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:351
#, fuzzy
msgid ""
"In the class reference, always surround arguments with ``[code][/code]``. In "
"the documentation and in Godot, it will display like ``this``. When you edit "
"XML files in the Godot repository, replace existing arguments written like "
"'this' or \\`this\\` with ``[code]this[/code]``."
msgstr ""
"在类型参考中，始终使用[code][/code]包围参数。 在文档和Godot中，它将显示"
"为“this``。 在Godot存储库中编辑XML文件时，用[code]this[/code]替换现在的参数，"
"如'this'或\\`this \\`。"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:355
msgid "Common vocabulary to use in godot's docs"
msgstr "在Godot文档中使用的常用词汇"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:357
msgid ""
"The developers chose some specific words to refer to areas of the interface. "
"They're used in the sources, in the documentation, and you should always use "
"them instead of synonyms, so the users know what you're talking about."
msgstr ""
"开发人员选择了一些特定的单词来引用界面的区域。 它们在文档中的源代码中使用，您"
"应该始终使用它们而不是同义词，因此用户知道您在谈论什么。"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:365
msgid "Overview of the interface and common vocabulary"
msgstr "界面和常用词汇概述"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:367
msgid ""
"In the top left corner of the editor lie the ``main menus``. In the center, "
"the buttons change the ``workspace``. And together the buttons in the top "
"right are the ``playtest buttons``. The area in the center, that displays "
"the 2D or the 3D space, is the ``viewport``. At its top, you find a list of "
"``tools`` inside the ``toolbar``."
msgstr ""
"在编辑器的左上角是“主菜单”。 在中心，按钮改变了“工作区”。 右上角的按钮"
"是“playtest buttons”。 显示2D或3D空间的中心区域是“viewport”。 在它的顶部，您"
"会在 ``toolbar`` 中找到一个 ``tools`` 列表。"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:373
msgid ""
"The tabs or dockable panels on either side of the viewport are ``docks``. "
"You have the ``FileSystem dock``, the ``Scene dock`` that contains your "
"scene tree, the ``Import dock``, the ``Node dock``, and the ``Inspector`` or "
"``Inspector dock``. With the default layout you may call the tabbed docks "
"``tabs``: the ``Scene tab``, the ``Node tab``..."
msgstr ""
"视区两侧的标签或可停靠面板是“docks”。 您有``FileSystem dock``，``Scene "
"dock``，它包含您的场景树，``Import dock``，``node dock``，以及 ``Inspector`` "
"或``Inspectordock``。 使用默认布局，您可以调用选项卡式底座``tabs``:``Scene "
"tab``，``Node tab`` ..."

#: ../../docs/community/contributing/docs_writing_guidelines.rst:379
msgid ""
"The Animation, Debugger, etc. at the bottom of the viewport are ``panels``. "
"Together they make up the ``bottom panels``."
msgstr "视区底部的动画，调试器等是“面板”。 他们一起构成了“底板”。"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:382
msgid ""
"Foldable areas of the Inspector are ``sections``. The node's parent class "
"names, which you can't fold, are ``Classes`` e.g. the ``KinematicBody2D "
"class``. And individual lines with key-value pairs are ``properties``. E.g. "
"``position`` or ``modulate color`` are both ``properties``."
msgstr ""
"属性面板的可折叠区域是“部分”。 您无法折叠的节点的父类名称是“类”，例如 "
"``KinematicBody2D class``。 具有键值对的单独行是“属性”。 例如。 ``position``"
"或``modulate color``都是``properties``。"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:389
#, fuzzy
msgid "Image contribution guidelines"
msgstr "图片贡献指南"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:391
msgid ""
"A significant part of the documentation is images, and there are several "
"important guidelines to follow."
msgstr "文档的重要部分是图像，有几个重要的指导原则需要遵循。"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:394
msgid ""
"First, you should always be using the default editor theme and text when "
"taking screenshots."
msgstr "首先，在截屏时应始终使用默认编辑器主题和文本。"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:396
msgid ""
"For 3D screenshots use 4xMSAA, enable anisotropic filtering on the projects "
"textures, and set the anisotropic filter quality to 16x in Project Settings"
msgstr ""
"对于3D屏幕截图，使用4xMSAA，对项目纹理启用各向异性过滤，并在项目设置中将各向"
"异性过滤器质量设置为16x"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:399
msgid "Screenshot size should not exceed 1920x1080."
msgstr "屏幕截图大小不应超过1920x1080。"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:401
msgid ""
"When you need to highlight an area of the editor to show something, like a "
"button or option, use a 2 pixel thick outline without a bevel."
msgstr ""
"当您需要突出显示编辑器的某个区域以显示某些内容(如按钮或选项)时，请使用不带斜"
"角的2像素粗轮廓。"

#: ../../docs/community/contributing/docs_writing_guidelines.rst:404
msgid ""
"Before you add or replace any images in the documentation, they should be "
"run through a png compressor to save size. The built in lossless compressor "
"in programs like Krita or Photoshop should be done. However you should also "
"use a lossy one, such as `pngquant <https://pngquant.org/>`_ where almost no "
"image quality is lost during compression."
msgstr ""
"在添加或替换文档中的任何图像之前，应通过png压缩器运行它们以节省大小。 应该在"
"Krita或Photoshop等程序中内置无损压缩器。 但是您也应该使用有损的，例如"
"`pngquant <https://pngquant.org/>`_ ，在压缩过程中几乎不会丢失图像质量。"

#: ../../docs/community/contributing/updating_the_class_reference.rst:4
msgid "Contribute to the Class Reference"
msgstr "在类型参考中贡献"

#: ../../docs/community/contributing/updating_the_class_reference.rst:6
msgid ""
"Godot ships with many nodes and singletons to help you develop your games in "
"GDscript. Each is a class, documented in the :ref:`class reference <toc-"
"class-ref>`. This reference is essential for anyone learning the engine: it "
"is available both online and in the engine."
msgstr ""
"Godot提供了许多节点和单例来帮助您用GDscript开发游戏。每个都是一个类，记录在 :"
"ref:`class reference <toc-class-ref>` 。这个参考对于任何学习引擎的人来说都是"
"必不可少的:它既可以在线也可以在引擎中使用。"

#: ../../docs/community/contributing/updating_the_class_reference.rst:8
msgid ""
"But it's incomplete. Some methods, variables and signals lack descriptions. "
"Others changed with recent releases and need updates. The developers can't "
"write the entire reference on their own. Godot needs you, and all of us, to "
"contribute."
msgstr ""
"但这是不完整的。有些方法、变量和信号缺乏描述。其他版本随着最近发布的版本而改"
"变，需要更新。开发人员不能自己编写整个引用。Godot需要您和我们所有人做出贡献。"

#: ../../docs/community/contributing/updating_the_class_reference.rst:10
msgid ""
"**Important:** If you are planning to make larger changes or a more "
"substantial contribution, it is usually a good idea to create an issue (or a "
"comment in an existing one) to let others know so they don't start working "
"on the same thing too."
msgstr ""
"**重要:** 如果您打算做出更大的改变或更大的贡献，通常最好创建一个问题(或现有问"
"题中的注释)让其他人知道，这样他们就不会开始做同样的事情。"

#: ../../docs/community/contributing/updating_the_class_reference.rst:13
msgid ""
"This guide is available as a `Youtube video <https://www.youtube.com/watch?"
"v=mKKjOulm5XI>`_."
msgstr ""
"您可以在Youtube上观看这个指南的 `视频 <https://www.youtube.com/watch?"
"v=mKKjOulm5XI>`_ 。"

#: ../../docs/community/contributing/updating_the_class_reference.rst:19
msgid ""
"The class reference lies in the following XML files, in Godot's GitHub "
"repository: `doc/classes/ <https://github.com/godotengine/godot/tree/master/"
"doc/classes>`_."
msgstr ""
"类型参考位于Godot的GitHub存储库中的以下XML文件中:`doc/classes/ <https://"
"github.com/godotengine/godot/tree/master/doc/classes>`_ 。"

#: ../../docs/community/contributing/updating_the_class_reference.rst:21
msgid "There are 5 steps to update the class reference (full guide below):"
msgstr "有5个步骤来更新类型参考(接下来会谈到完整指南):"

#: ../../docs/community/contributing/updating_the_class_reference.rst:23
msgid "Fork `Godot's repository <https://github.com/godotengine/godot>`_"
msgstr "分叉 `Godot's repository <https://github.com/godotengine/godot>`_"

#: ../../docs/community/contributing/updating_the_class_reference.rst:24
msgid "Clone your fork on your computer"
msgstr "在电脑上克隆您的分叉"

#: ../../docs/community/contributing/updating_the_class_reference.rst:25
msgid "Edit the class file in ``doc/classes/`` to write documentation"
msgstr "在 ``doc/classes/`` 中编辑类文件以写入文档"

#: ../../docs/community/contributing/updating_the_class_reference.rst:26
msgid "Commit your changes and push them to your fork"
msgstr "提交您的更改并把它们推到您的分叉上"

#: ../../docs/community/contributing/updating_the_class_reference.rst:27
msgid "Make a pull request on the Godot repository"
msgstr "在Godot存储库上拉取请求"

#: ../../docs/community/contributing/updating_the_class_reference.rst:29
msgid ""
"Always use these XML files to edit the API reference. Do not edit the "
"generated .rst files :ref:`in the online documentation <toc-class-ref>`, "
"hosted in the `godot-docs <https://github.com/godotengine/godot-docs>`_ "
"repository."
msgstr ""
"总是使用这些XML文件来编辑API引用。不要编辑 :ref:`in the online documentation "
"<toc-class-ref>` 生成的.rst文件，它托管在 `godot-docs <https://github.com/"
"godotengine/godot-docs>`_ 存储库中。"

#: ../../docs/community/contributing/updating_the_class_reference.rst:32
msgid "Get started with GitHub"
msgstr "开始使用GitHub"

#: ../../docs/community/contributing/updating_the_class_reference.rst:34
msgid ""
"If you're new to git and GitHub, this guide will help you get started. "
"You'll learn to:"
msgstr "如果您是Git和Github的新手，这个指南会帮助您入门。您将学会:"

#: ../../docs/community/contributing/updating_the_class_reference.rst:36
msgid "Fork and clone Godot's repository"
msgstr "分叉和克隆Godot仓库"

#: ../../docs/community/contributing/updating_the_class_reference.rst:37
msgid "Keep your fork up to date with other contributors"
msgstr "让分叉与其他贡献者保持同步"

#: ../../docs/community/contributing/updating_the_class_reference.rst:38
msgid "Create a pull request so your improvements end in the official docs"
msgstr "创建拉取请求，以便您的改进在官方文档中结束"

#: ../../docs/community/contributing/updating_the_class_reference.rst:40
msgid ""
"If you're new to git, the version-control system Godot uses, go through "
"`GitHub's interactive guide <https://try.github.io/levels/1/challenges/1>`_. "
"You'll learn some essential vocabulary and get a sense for the tool."
msgstr ""
"如果您是got的新手，即Godot使用的版本控制系统，请阅读 `GitHub的交互式指南 "
"<https://try.github.io/levels/1/challenges/1>`_ 。 您将学习一些必要的词汇并了"
"解该工具。"

#: ../../docs/community/contributing/updating_the_class_reference.rst:43
msgid "Fork Godot"
msgstr "分叉Godot"

#: ../../docs/community/contributing/updating_the_class_reference.rst:45
msgid "Fork the Godot Engine into a GitHub repository of your own."
msgstr "将Godot Engine分成您自己的GitHub存储库。"

#: ../../docs/community/contributing/updating_the_class_reference.rst:47
msgid "Clone the repository on your computer:"
msgstr "克隆计算机上的存储库:"

#: ../../docs/community/contributing/updating_the_class_reference.rst:53
msgid ""
"Create a new branch to make your changes. It makes it a lot easier to sync "
"your improvements with other docs writers, and it's easier to cleanup your "
"repository clean if you have any issues with git."
msgstr ""
"创建一个新分支以进行更改。 它使您的改进与其他文档编写器同步变得容易得多，如果"
"您对git有任何问题，则更容易清理您的存储库。"

#: ../../docs/community/contributing/updating_the_class_reference.rst:59
msgid ""
"The new branch is the same as your master branch, until you start to write "
"API docs. In the ``doc/`` folder, you'll find the class reference."
msgstr ""
"在您开始编写API文档之前，新分支与主分支相同。 在``doc /``文件夹中，您将找到类"
"型参考。"

#: ../../docs/community/contributing/updating_the_class_reference.rst:62
msgid "How to keep your local clone up-to-date"
msgstr "如何使本地克隆保持最新状态"

#: ../../docs/community/contributing/updating_the_class_reference.rst:64
msgid ""
"Other writers contribute to Godot's documentation. Your local repository "
"will fall behind it, and you'll have to synchronize it. Especially if other "
"contributors update the class reference while you work on it."
msgstr ""
"其他作家为Godot的文档做出了贡献。 您的本地存储库将落后于它，您将不得不同步"
"它。 特别是如果其他贡献者在您处理它时更新类型参考。"

#: ../../docs/community/contributing/updating_the_class_reference.rst:66
msgid ""
"First add an ``upstream`` git *remote* to work with. Remotes are links to "
"online repositories you can download new files from."
msgstr ""
"首先添加一个``upstream`` git * remote *来使用。 遥控器是您可以从中下载新文件"
"的在线存储库的链接。"

#: ../../docs/community/contributing/updating_the_class_reference.rst:72
msgid "You can check the list of all remote servers with:"
msgstr "您可以使用以下命令检查所有远程服务器的列表:"

#: ../../docs/community/contributing/updating_the_class_reference.rst:78
msgid ""
"You should have two: ``origin``, your fork on github, that git adds by "
"default, and ``upstream``, that you just added:"
msgstr ""
"您应该有两个: ``origin`` ，您在github上的fork，默认情况下git添加，以及您刚添"
"加的``upstream``:"

#: ../../docs/community/contributing/updating_the_class_reference.rst:88
msgid ""
"Each time you want to sync your branch to the state of the upstream "
"repository, enter:"
msgstr "每次要将分支同步到上游存储库的状态时，请输入:"

#: ../../docs/community/contributing/updating_the_class_reference.rst:94
msgid ""
"This command will first ``fetch``, or download the latest version of the "
"Godot repository. Then, it will reapply your local changes on top."
msgstr ""
"此命令将首先“获取”，或下载最新版本的Godot存储库。 然后，它将重新应用您的本地"
"更改。"

#: ../../docs/community/contributing/updating_the_class_reference.rst:96
msgid ""
"If you made changes you don't want to keep in your local branch, use the "
"following commands instead:"
msgstr "如果您进行了更改，则不希望保留在本地分支中，请使用以下命令:"

#: ../../docs/community/contributing/updating_the_class_reference.rst:103
msgid ""
"**Warning:** The above command will reset your branch to the state of the "
"``upstream master`` branch. It will discard all local changes. Make sure to "
"only run this *before* you make important changes."
msgstr ""
"**警告:** 上述命令会将分支重置为“上游主站”分支的状态。 它将丢弃所有本地更"
"改。 确保在 *进行重要更改之前仅运行此* 。"

#: ../../docs/community/contributing/updating_the_class_reference.rst:105
msgid ""
"Another option is to delete the branch you're working on, synchronize the "
"master branch with the Godot repository, and create a brand new branch:"
msgstr ""
"另一个选择是删除您正在处理的分支，将主分支与Godot存储库同步，并创建一个全新的"
"分支:"

#: ../../docs/community/contributing/updating_the_class_reference.rst:114
msgid ""
"If you're feeling lost by now, come to our `IRC channels <http://webchat."
"freenode.net/?channels=#godotengine>`_ and ask for help. Experienced git "
"users will give you a hand."
msgstr ""
"如果您现在感到迷茫，请来我们的 `IRC频道 <http://webchat.freenode.net/?"
"channels=#godotengine>`_ 并寻求帮助。 经验丰富的git用户会帮助您。"

#: ../../docs/community/contributing/updating_the_class_reference.rst:117
msgid "Updating the documentation template"
msgstr "更新文档模板"

#: ../../docs/community/contributing/updating_the_class_reference.rst:119
msgid ""
"When classes are modified in the source code, the documentation template "
"might become outdated. To make sure that you are editing an up-to-date "
"version, you first need to compile Godot (you can follow the :ref:"
"`doc_introduction_to_the_buildsystem` page), and then run the following "
"command (assuming 64-bit Linux):"
msgstr ""
"在源代码中修改类时，文档模板可能会过时。 为了确保您正在编辑最新版本，首先需要"
"编译Godot(您可以按照 :ref:`doc_introduction_to_the_buildsystem`页面)，然后运"
"行以下命令(假设64位Linux):"

#: ../../docs/community/contributing/updating_the_class_reference.rst:125
msgid ""
"The xml files in doc/classes should then be up-to-date with current Godot "
"Engine features. You can then check what changed using the ``git diff`` "
"command. If there are changes to other classes than the one you are planning "
"to document, please commit those changes first before starting to edit the "
"template:"
msgstr ""
"然后，doc / classes中的xml文件应该与当前的Godot Engine功能保持同步。 然后，您"
"可以使用``git diff`` 命令检查更改的内容。 如果其他类的更改超出了您计划记录的"
"类，请在开始编辑模板之前先提交这些更改:"

#: ../../docs/community/contributing/updating_the_class_reference.rst:132
msgid "You are now ready to edit this file to add stuff."
msgstr "您现在可以编辑此文件以添加内容。"

#: ../../docs/community/contributing/updating_the_class_reference.rst:134
msgid ""
"**Note:** If this has been done recently by another contributor, you don't "
"forcefully need to go through these steps (unless you know that the class "
"you plan to edit *has* been modified recently)."
msgstr ""
"**注意:** 如果最近由其他撰稿人完成此操作，则您不必强行执行这些步骤(除非您知道"
"您计划编辑的班级*最近已被修改过)。"

#: ../../docs/community/contributing/updating_the_class_reference.rst:137
msgid "Push and request a pull of your changes"
msgstr "推送并请求提取您的更改"

#: ../../docs/community/contributing/updating_the_class_reference.rst:139
msgid ""
"Once your modifications are finished, push your changes on your GitHub "
"repository:"
msgstr "完成修改后，在GitHub存储库上推送您的更改:"

#: ../../docs/community/contributing/updating_the_class_reference.rst:148
msgid ""
"When it's done, you can ask for a Pull Request via the GitHub UI of your "
"Godot fork."
msgstr "完成后，您可以通过Godot前叉的GitHub UI请求拉取请求。"

#: ../../docs/community/contributing/updating_the_class_reference.rst:152
msgid ""
"Although you can edit files on GitHub, it's not recommended. As hundreds of "
"contributors work on Godot, the git history must stay clean. Each commit "
"should bundle all related improvements you make to the class reference, a "
"new feature, bug fixes... When you edit from GitHub, it will create a new "
"branch and a Pull Request every time you want to save it. If a few days pass "
"before your changes get a review, you won't be able to update to the latest "
"version of the repository cleanly. Also, it's harder to keep clean indents "
"from GitHub. And they're very important in the docs."
msgstr ""
"虽然您可以在GitHub上编辑文件，但不建议这样做。 由于数百名贡献者在Godot工作，"
"git历史必须保持清洁。 每个提交都应捆绑您对类型参考所做的所有相关改进，新功"
"能，错误修复......当您从GitHub进行编辑时，每次要保存时，它都会创建一个新分支"
"和一个Pull Request。 如果在您的更改得到审核之前几天过去了，您将无法干净地更新"
"到最新版本的存储库。 此外，从GitHub保持干净的缩进更难。 它们在文档中非常重"
"要。"

#: ../../docs/community/contributing/updating_the_class_reference.rst:154
msgid ""
"TL;DR: If you don't know what you're doing exactly, do not edit files from "
"GitHub."
msgstr "TL; DR:如果您不知道自己在做什么，请不要编辑GitHub中的文件。"

#: ../../docs/community/contributing/updating_the_class_reference.rst:157
msgid "How to edit class XML"
msgstr "如何编辑类XML"

#: ../../docs/community/contributing/updating_the_class_reference.rst:159
msgid ""
"Edit the file for your chosen class in ``doc/classes/`` to update the class "
"reference. The folder contains an XML file for each class. The XML lists the "
"constants and methods you'll find in the class reference. Godot generates "
"and updates the XML automatically."
msgstr ""
"在``doc / classes /``中编辑所选类的文件以更新类型参考。 该文件夹包含每个类的"
"XML文件。 XML列出了您在类型参考中找到的常量和方法。 Godot自动生成并更新XML。"

#: ../../docs/community/contributing/updating_the_class_reference.rst:161
msgid ""
"Edit it using your favourite text editor. If you use a code editor, make "
"sure that it doesn't change the indent style: tabs for the XML, and 4 spaces "
"inside BBcode-style blocks. More on that below."
msgstr ""
"使用您喜欢的文本编辑器编辑它。 如果使用代码编辑器，请确保它不会更改缩进样式:"
"XML的选项卡和BBcode样式块中的4个空格。 更多关于以下内容。"

#: ../../docs/community/contributing/updating_the_class_reference.rst:164
msgid "How to write the class reference"
msgstr "如何编写类型参考"

#: ../../docs/community/contributing/updating_the_class_reference.rst:166
msgid ""
"Each class has a brief and a long description. The brief description is "
"always at the top of the page, while the full description lies below the "
"list of methods, variables and constants. Methods, member variables, "
"constants and signals are in separate categories or XML nodes. For each, "
"learn how they work in Godot's source code, and fill their <description>."
msgstr ""
"每个班级都有简短的描述。 简要描述始终位于页面顶部，而完整描述位于方法，变量和"
"常量列表下方。 方法，成员变量，常量和信号在不同的类别或XML节点中。 对于每个"
"人，了解他们如何在Godot的源代码中工作，并填写他们的<description>。"

#: ../../docs/community/contributing/updating_the_class_reference.rst:168
msgid "Our job is to add the missing text between these marks:"
msgstr "我们的工作是在这些标记之间添加缺少的文本:"

#: ../../docs/community/contributing/updating_the_class_reference.rst:170
msgid "<description></description>"
msgstr "<description></description>"

#: ../../docs/community/contributing/updating_the_class_reference.rst:171
msgid "<brief_description></brief_description>"
msgstr "<brief_description></brief_description>"

#: ../../docs/community/contributing/updating_the_class_reference.rst:172
msgid "<constant></constant>"
msgstr "<constant></constant>"

#: ../../docs/community/contributing/updating_the_class_reference.rst:173
msgid "<method></method>"
msgstr "<method></method>"

#: ../../docs/community/contributing/updating_the_class_reference.rst:174
msgid "<member></member>"
msgstr "<member></member>"

#: ../../docs/community/contributing/updating_the_class_reference.rst:175
msgid "<signal></signal>"
msgstr "<signal></signal>"

#: ../../docs/community/contributing/updating_the_class_reference.rst:177
msgid ""
"Write in a clear and simple language. Always follow the :ref:`writing "
"guidelines <doc_docs_writing_guidelines>` to keep your descriptions short "
"and easy to read. **Do not leave empty lines** in the descriptions: each "
"line in the XML file will result in a new paragraph."
msgstr ""
"用清晰简单的语言书写。 始终遵循 :ref:`撰写指南<doc_docs_writing_guidelines>` "
"以使您的描述简短易读。 **不要在描述中留下空行**:XML文件中的每一行都将生成一个"
"新段落。"

#: ../../docs/community/contributing/updating_the_class_reference.rst:179
msgid "Here's how a class looks like in XML:"
msgstr "以下是XML中的类的外观:"

#: ../../docs/community/contributing/updating_the_class_reference.rst:218
msgid ""
"Use a code editor like Vim, Atom, Code, Notepad++ or anything similar to "
"edit the file quickly. Use the search function to find classes fast."
msgstr ""
"使用代码编辑器，如Vim，Atom，Code，Notepad ++或类似的东西，快速编辑文件。 使"
"用搜索功能快速查找类。"

#: ../../docs/community/contributing/updating_the_class_reference.rst:222
msgid "Improve formatting with BBcode style tags"
msgstr "使用BBcode样式标签改进格式"

#: ../../docs/community/contributing/updating_the_class_reference.rst:224
msgid ""
"Godot's class reference supports BBcode-like tags. They add nice formatting "
"to the text. Here's the list of available tags:"
msgstr ""
"Godot的类型参考支持类似BBcode的标记。 它们为文本添加了很好的格式。 这是可用标"
"签的列表:"

#: ../../docs/community/contributing/updating_the_class_reference.rst:227
msgid "Effect"
msgstr "效果"

#: ../../docs/community/contributing/updating_the_class_reference.rst:227
msgid "Result"
msgstr "结果"

#: ../../docs/community/contributing/updating_the_class_reference.rst:229
msgid "[Class]"
msgstr "[Class]"

#: ../../docs/community/contributing/updating_the_class_reference.rst:229
msgid "Link a class"
msgstr "链接到一个类"

#: ../../docs/community/contributing/updating_the_class_reference.rst:229
msgid "Move the [Sprite]."
msgstr "移动[Sprite]。"

#: ../../docs/community/contributing/updating_the_class_reference.rst:229
msgid "Move the :ref:`class_sprite`."
msgstr "移动 :ref:`class_sprite`。"

#: ../../docs/community/contributing/updating_the_class_reference.rst:231
msgid "[method methodname]"
msgstr "[method methodname]"

#: ../../docs/community/contributing/updating_the_class_reference.rst:231
msgid "Link to a method in this class"
msgstr "链接到此类中的方法"

#: ../../docs/community/contributing/updating_the_class_reference.rst:231
msgid "Call [method hide]."
msgstr "调用[method hide]。"

#: ../../docs/community/contributing/updating_the_class_reference.rst:231
#: ../../docs/community/contributing/updating_the_class_reference.rst:233
#, fuzzy
msgid "See :ref:`hide <class_spatial_method_hide>`."
msgstr "请参阅 :ref:`hide <class_spatial_method_hide>`。"

#: ../../docs/community/contributing/updating_the_class_reference.rst:233
msgid "[method Class.methodname]"
msgstr "[method Class.methodname]"

#: ../../docs/community/contributing/updating_the_class_reference.rst:233
msgid "Link to another class's method"
msgstr "链接到另一个类的方法"

#: ../../docs/community/contributing/updating_the_class_reference.rst:233
msgid "Call [method Spatial.hide]."
msgstr "调用[method Spatial.hide]。"

#: ../../docs/community/contributing/updating_the_class_reference.rst:235
msgid "[member membername]"
msgstr "[member membername]"

#: ../../docs/community/contributing/updating_the_class_reference.rst:235
msgid "Link to a member in this class"
msgstr "链接到这个类的成员"

#: ../../docs/community/contributing/updating_the_class_reference.rst:235
msgid "Get [member scale]."
msgstr "获取[member scale]。"

#: ../../docs/community/contributing/updating_the_class_reference.rst:235
#: ../../docs/community/contributing/updating_the_class_reference.rst:237
#, fuzzy
msgid "Get :ref:`scale <class_node2d_property_scale>`."
msgstr "获取 :ref:`scale <class_node2d_property_scale>`。"

#: ../../docs/community/contributing/updating_the_class_reference.rst:237
msgid "[member Class.membername]"
msgstr "[member Class.membername]"

#: ../../docs/community/contributing/updating_the_class_reference.rst:237
msgid "Link to another class's member"
msgstr "链接到另一个类的成员"

#: ../../docs/community/contributing/updating_the_class_reference.rst:237
msgid "Get [member Node2D.scale]."
msgstr "Get [member Node2D.scale]."

#: ../../docs/community/contributing/updating_the_class_reference.rst:239
msgid "[signal signalname]"
msgstr "[signal signalname]"

#: ../../docs/community/contributing/updating_the_class_reference.rst:239
msgid "Link to a signal in this class"
msgstr "链接到此类中的信号"

#: ../../docs/community/contributing/updating_the_class_reference.rst:239
msgid "Emit [signal renamed]."
msgstr "Emit [signal renamed]."

#: ../../docs/community/contributing/updating_the_class_reference.rst:239
#: ../../docs/community/contributing/updating_the_class_reference.rst:241
#, fuzzy
msgid "Emit :ref:`renamed <class_node_signal_renamed>`."
msgstr "发射 :ref:`renamed <class_node_signal_renamed>`."

#: ../../docs/community/contributing/updating_the_class_reference.rst:241
msgid "[signal Class.signalname]"
msgstr "[signal Class.signalname]"

#: ../../docs/community/contributing/updating_the_class_reference.rst:241
msgid "Link to another class's signal"
msgstr "链接到另一个类的信号"

#: ../../docs/community/contributing/updating_the_class_reference.rst:241
msgid "Emit [signal Node.renamed]."
msgstr "Emit [signal Node.renamed]."

#: ../../docs/community/contributing/updating_the_class_reference.rst:243
msgid "[b] [/b]"
msgstr "[b] [/b]"

#: ../../docs/community/contributing/updating_the_class_reference.rst:243
msgid "Bold"
msgstr "粗体"

#: ../../docs/community/contributing/updating_the_class_reference.rst:243
msgid "Some [b]bold[/b] text."
msgstr "一些[b]粗体[/b]文字。"

#: ../../docs/community/contributing/updating_the_class_reference.rst:243
msgid "Some **bold** text."
msgstr "一些 **粗体** 文字。"

#: ../../docs/community/contributing/updating_the_class_reference.rst:245
msgid "[i] [/i]"
msgstr "[i] [/i]"

#: ../../docs/community/contributing/updating_the_class_reference.rst:245
msgid "Italic"
msgstr "斜体"

#: ../../docs/community/contributing/updating_the_class_reference.rst:245
msgid "Some [i]italic[/i] text."
msgstr "一些[i]斜体[/i]文字。"

#: ../../docs/community/contributing/updating_the_class_reference.rst:245
msgid "Some *italic* text."
msgstr "一些 *斜体* 文字。"

#: ../../docs/community/contributing/updating_the_class_reference.rst:247
msgid "[code] [/code]"
msgstr "[code] [/code]"

#: ../../docs/community/contributing/updating_the_class_reference.rst:247
msgid "Monospace"
msgstr "等宽字体"

#: ../../docs/community/contributing/updating_the_class_reference.rst:247
msgid "Some [code]monospace[/code] text."
msgstr "一些[code]monospace[/code] 文本。"

#: ../../docs/community/contributing/updating_the_class_reference.rst:247
msgid "Some ``monospace`` text."
msgstr "一些 ``monospace`` 文本。"

#: ../../docs/community/contributing/updating_the_class_reference.rst:249
msgid "[codeblock] [/codeblock]"
msgstr "[codeblock] [/codeblock]"

#: ../../docs/community/contributing/updating_the_class_reference.rst:249
msgid "Multiline preformatted block"
msgstr "多行预格式化块"

#: ../../docs/community/contributing/updating_the_class_reference.rst:249
msgid "*See below.*"
msgstr "*见下文。*"

#: ../../docs/community/contributing/updating_the_class_reference.rst:252
#, fuzzy
msgid ""
"Use ``[codeblock]`` for pre-formatted code blocks. Inside ``[codeblock]``, "
"always use **four spaces** for indentation (the parser will delete tabs). "
"Example:"
msgstr ""
"对于预先格式化的代码块使用 ``[codeblock]`` 。 在 ``[codeblock]`` 里面，总是使"
"用空格来缩进(解析器会删除标签)。 例:"

#: ../../docs/community/contributing/updating_the_class_reference.rst:262
msgid "Will display as:"
msgstr "将显示为:"

#: ../../docs/community/contributing/updating_the_class_reference.rst:272
msgid "I don't know what this method does!"
msgstr "我不知道这个方法干什么用！"

#: ../../docs/community/contributing/updating_the_class_reference.rst:274
msgid ""
"No problem. Leave it behind, and list the methods you skipped when you "
"request a pull of your changes. Another writer will take care of it."
msgstr ""
"没问题。 将其留下，并列出您请求提取更改时跳过的方法。 别的写手会照顾它。"

#: ../../docs/community/contributing/updating_the_class_reference.rst:276
msgid ""
"You can still have a look at the methods' implementation in Godot's source "
"code on GitHub. Also, if you have doubts, feel free to ask on the `Q&A "
"website <https://godotengine.org/qa/>`__ and on IRC (freenode, #godotengine)."
msgstr ""
"您仍然可以在GitHub上查看Godot源代码中方法的实现。 此外，如果您有疑问，请随时"
"在 `问答网站 <https://godotengine.org/qa/>`__ 和IRC(freenode，＃godotengine)"
"上询问。"

#: ../../docs/community/contributing/updating_the_class_reference.rst:280
msgid "Localization"
msgstr "本地化"

#: ../../docs/community/contributing/updating_the_class_reference.rst:282
#, fuzzy
msgid ""
"The documentation can be translated in any language on `Hosted Weblate "
"<https://hosted.weblate.org/projects/godot-engine/godot-docs/>`__."
msgstr ""
"您可以帮助我们翻译或校对托管在 `Weblate <https://hosted.weblate.org/engage/"
"godot-engine/>`_ 上的官方Godot文档。"

#: ../../docs/community/contributing/updating_the_class_reference.rst:285
#, fuzzy
msgid ""
"Translated strings are synced manually by documentation maintainers in the "
"`godot-docs-l10n <https://github.com/godotengine/godot-docs-l10n>`__ "
"repository."
msgstr ""
"总是使用这些XML文件来编辑API引用。不要编辑 :ref:`in the online documentation "
"<toc-class-ref>` 生成的.rst文件，它托管在 `godot-docs <https://github.com/"
"godotengine/godot-docs>`_ 存储库中。"

#: ../../docs/community/contributing/updating_the_class_reference.rst:289
msgid ""
"Languages with a good level of completion have their own localized instances "
"of ReadTheDocs. Open an issue on the ``godot-docs-l10n`` repository if you "
"think that a new language is complete enough to get its own instance."
msgstr ""

#: ../../docs/community/channels.rst:4
#, fuzzy
msgid "Community channels"
msgstr "社区"

#: ../../docs/community/channels.rst:6
msgid ""
"So, where is the Godot community and where can you ask questions and get "
"help?"
msgstr "那么，Godot社区在哪里，您在哪里可以提问并获得帮助？"

#: ../../docs/community/channels.rst:8
msgid ""
"Note that some of these channels are run and moderated by members of the "
"Godot community or third parties."
msgstr "请注意，其中一些渠道由Godot社区或第三方成员运营和审核。"

#: ../../docs/community/channels.rst:10
msgid ""
"A brief overview over these channels is also available on the `website "
"<https://godotengine.org/community>`_."
msgstr ""
"有关这些渠道的简要概述也可在 `网站 <https://godotengine.org/community>`_ 上找"
"到。"

#: ../../docs/community/channels.rst:13
#, fuzzy
msgid "Q&A"
msgstr "Q & A"

#: ../../docs/community/channels.rst:15
msgid "`Official Godot Questions & Answers <https://godotengine.org/qa/>`_"
msgstr "`Godot官方问题与解答 <https://godotengine.org/qa/>`_"

#: ../../docs/community/channels.rst:18
msgid "IRC on Freenode"
msgstr "Freenode上的IRC"

#: ../../docs/community/channels.rst:20
msgid ""
"`General: #godotengine <http://webchat.freenode.net/?channels=#godotengine>`_"
msgstr ""
"`通用: #godotengine <http://webchat.freenode.net/?channels=#godotengine>`_"

#: ../../docs/community/channels.rst:21
msgid ""
"`Engine development: #godotengine-devel <http://webchat.freenode.net/?"
"channels=#godotengine-devel>`_"
msgstr ""
"`引擎开发: #godotengine-devel <http://webchat.freenode.net/?"
"channels=#godotengine-devel>`_"

#: ../../docs/community/channels.rst:22
msgid ""
"`Documentation: #godotengine-doc <http://webchat.freenode.net/?"
"channels=#godotengine-doc>`_"
msgstr ""
"`文档: #godotengine-doc <http://webchat.freenode.net/?channels=#godotengine-"
"doc>`_"

#: ../../docs/community/channels.rst:23
msgid ""
"`GDNative: #godotengine-gdnative <http://webchat.freenode.net/?"
"channels=#godotengine-gdnative>`_"
msgstr ""
"`GDNative: #godotengine-gdnative <http://webchat.freenode.net/?"
"channels=#godotengine-gdnative>`_"

#: ../../docs/community/channels.rst:24
msgid ""
"`Webseite/PR: #godotengine-atelier <http://webchat.freenode.net/?"
"channels=#godotengine-atelier>`_"
msgstr ""
"`Webseite/PR: #godotengine-atelier <http://webchat.freenode.net/?"
"channels=#godotengine-atelier>`_"

#: ../../docs/community/channels.rst:25
msgid "`IRC logs <https://godot.eska.me/irc-logs/>`_"
msgstr "`IRC日志 <https://godot.eska.me/irc-logs/>`_"

#: ../../docs/community/channels.rst:28
msgid "Other chats"
msgstr "其他聊天"

#: ../../docs/community/channels.rst:30
msgid ""
"`Matrix (IRC compatible) <https://matrix.to/#/#godotengine:matrix.org>`_"
msgstr "`Matrix (IRC兼容) <https://matrix.to/#/#godotengine:matrix.org>`_"

#: ../../docs/community/channels.rst:31
msgid "`Discord <https://discordapp.com/invite/zH7NUgz>`_"
msgstr "`Discord <https://discordapp.com/invite/zH7NUgz>`_"

#: ../../docs/community/channels.rst:34
msgid "Social networks"
msgstr "社交网络"

#: ../../docs/community/channels.rst:36
msgid "`GitHub <https://github.com/godotengine/>`_"
msgstr "`GitHub <https://github.com/godotengine/>`_"

#: ../../docs/community/channels.rst:37
msgid "`Facebook group <https://www.facebook.com/groups/godotengine/>`_"
msgstr "`Facebook组 <https://www.facebook.com/groups/godotengine/>`_"

#: ../../docs/community/channels.rst:38
msgid "`Twitter (also, #godotengine) <https://twitter.com/godotengine>`_"
msgstr "`Twitter (同样在 #godotengine) <https://twitter.com/godotengine>`_"

#: ../../docs/community/channels.rst:39
msgid "`Reddit <https://www.reddit.com/r/godot>`_"
msgstr "`Reddit <https://www.reddit.com/r/godot>`_"

#: ../../docs/community/channels.rst:40
msgid "`Youtube <https://www.youtube.com/c/GodotEngineOfficial>`_"
msgstr "`Youtube <https://www.youtube.com/c/GodotEngineOfficial>`_"

#: ../../docs/community/channels.rst:41
msgid "`Steam <https://steamcommunity.com/app/404790>`_"
msgstr "`Steam <https://steamcommunity.com/app/404790>`_"

#: ../../docs/community/channels.rst:44
msgid "Forum"
msgstr "论坛"

#: ../../docs/community/channels.rst:46
msgid "`Forum (godotdevelopers.org) <https://godotdevelopers.org/forum>`_"
msgstr "`论坛 (godotdevelopers.org) <https://godotdevelopers.org/forum>`_"

#: ../../docs/community/tutorials.rst:4
#, fuzzy
msgid "Tutorials and resources"
msgstr "节点和资源"

#: ../../docs/community/tutorials.rst:6
#, fuzzy
msgid ""
"This is a list of third-party tutorials and other resources created by the "
"community that may be of interest."
msgstr "这是一个由社区创建并且您可能感兴趣的第三方教程列表。"

#: ../../docs/community/tutorials.rst:10
msgid "Video tutorials"
msgstr "视频教程"

#: ../../docs/community/tutorials.rst:12
msgid ""
"`GDQuest <https://www.youtube.com/channel/UCxboW7x0jZqFdvMdCFKTMsQ/"
"playlists>`_"
msgstr ""
"`GDQuest <https://www.youtube.com/channel/UCxboW7x0jZqFdvMdCFKTMsQ/"
"playlists>`_"

#: ../../docs/community/tutorials.rst:13
msgid ""
"`KidsCanCode <https://www.youtube.com/channel/UCNaPQ5uLX5iIEHUCLmfAgKg/"
"playlists>`_"
msgstr ""
"`KidsCanCode <https://www.youtube.com/channel/UCNaPQ5uLX5iIEHUCLmfAgKg/"
"playlists>`_"

#: ../../docs/community/tutorials.rst:14
msgid ""
"`Game from Scratch: Godot 3 Tutorial Series <https://www.youtube.com/watch?"
"v=iDEcP8Mc-7s&list=PLS9MbmO_ssyDk79j9ewONxV88fD5e_o5d>`_"
msgstr ""
"`Game from Scratch: Godot 3 教程系列 <https://www.youtube.com/watch?"
"v=iDEcP8Mc-7s&list=PLS9MbmO_ssyDk79j9ewONxV88fD5e_o5d>`_"

#: ../../docs/community/tutorials.rst:15
msgid ""
"`HeartBeast <https://www.youtube.com/watch?v=wETY5_9kFtA&list=PL9FzW-"
"m48fn2jlBu_0DRh7PvAt-GULEmd>`_"
msgstr ""
"`HeartBeast <https://www.youtube.com/watch?v=wETY5_9kFtA&list=PL9FzW-"
"m48fn2jlBu_0DRh7PvAt-GULEmd>`_"

#: ../../docs/community/tutorials.rst:16
msgid "`Steincodes <https://www.youtube.com/c/steincodes/playlists>`_"
msgstr "`Steincodes <https://www.youtube.com/c/steincodes/playlists>`_"

#: ../../docs/community/tutorials.rst:19
#, fuzzy
msgid "Text tutorials"
msgstr "教程"

#: ../../docs/community/tutorials.rst:21
msgid ""
"`KidsCanCode: An ongoing tutorial series <http://kidscancode.org/blog/tags/"
"godot/>`_"
msgstr ""

#: ../../docs/community/tutorials.rst:26
msgid ""
"`awesome-godot: A curated list of resources by Calinou <https://github.com/"
"Calinou/awesome-godot>`_"
msgstr ""
"`awesome-godot:由Calinou提供的精选资源列表 <https://github.com/Calinou/"
"awesome-godot>`_"

#: ../../docs/community/tutorials.rst:27
msgid ""
"`Zeef Godot Engine: A curated directory of resources by Andre Schmitz "
"<https://godot-engine.zeef.com/andre.antonio.schmitz>`_"
msgstr ""
"`Zeef Godot Engine:由Andre Schmitz撰写的精选资源目录 <https://godot-engine."
"zeef.com/andre.antonio.schmitz>`_"

#~ msgid ""
#~ "The first step is to open \"Project Settings\" and find the *Handheld* "
#~ "section. Enable the *Emulate Touchscreen* option. This lets you treat "
#~ "mouse click events the same as touch events, so you can test the game on "
#~ "a computer without a touchscreen. Also, make sure to select \"portrait\" "
#~ "under *Orientation*."
#~ msgstr ""
#~ "第一步是打开”Project Settings\"并找到 “Display\" -> \"Window\" -> "
#~ "*Handheld* 部分。启用 *Emulate Touchscreen* 选项。这使得您可以将鼠标点击事"
#~ "件视为触摸事件，这样您就可以在没有触屏的电脑上测试游戏。另外，确保将 "
#~ "*Orientation* 下的 ”portrait\" 选中。"

#, fuzzy
#~ msgid ""
#~ "As mentioned in the comments above, we need to avoid the situation of "
#~ "deleting the current scene while it is still being used (i.e. its code is "
#~ "still running), so using :ref:`Object.call_deferred() "
#~ "<class_Object_method_call_deferred>` is required at this point. The "
#~ "result is that the second function will run at a later time when any code "
#~ "from the current scene has completed."
#~ msgstr ""
#~ "如上面的注释中所述, 我们需要避免在当前场景仍在使用时将其删除的情况 (即其代"
#~ "码仍在运行), 因此此时需要使用 :ref:`Object.call_deferred() "
#~ "<class_Object_method_call_deferred>` 。其结果是, 第二个函数将在以后当前场"
#~ "景中的任何代码完成后运行。"

#, fuzzy
#~ msgid ""
#~ "This tutorial aims to propose a simple workflow on how to organize "
#~ "projects. Since Godot allows the programmer to use the filesystem as they "
#~ "please, figuring out a way to organize projects when starting to use the "
#~ "engine can be a little challenging. Because of this, the tutorial "
#~ "describes a simple workflow, which should work as a starting point, "
#~ "regardless of whether it is used."
#~ msgstr ""
#~ "本教程旨在提出一个关于如何组织项目的简单工作流程。 既然Godot允许程序员随心"
#~ "所欲地使用文件系统，在开始使用引擎时想办法组织项目可能会有点困难。 因此，"
#~ "将描述一个简单的工作流程，您来决定使用与否，但应该将其作为一个起点。"

#~ msgid ""
#~ "Additionally, using version control can be challenging, so this "
#~ "proposition will include that too."
#~ msgstr "另外，使用版本控制可能很具挑战性，所以这个部分会谈到这一点。"

#~ msgid "Particles2D > Process Material > Material > drop-down menu > Edit:"
#~ msgstr "Particles2D>处理材质>材质>下拉菜单>编辑:"

#~ msgid "Our bed consists of 3 parts: the bed, the mattress, and a pillow."
#~ msgstr "我们的床由3部分组成:床，床垫和枕头。"

#~ msgid "The bed you built should look like this:"
#~ msgstr "您创建的床看起来应该是这个样子:"

#~ msgid "A lamp consists of 3 parts: the stand, the pole, and the lampshade."
#~ msgstr "灯由3个部分组成:支架，支柱和灯罩。"

#~ msgid "Timeline zoom level contro"
#~ msgstr "时间线缩放级别控制"

#~ msgid "Shadow Color of Light. **(not yet implemented)**"
#~ msgstr "光的阴影颜色。 **(尚未实现)**"

#, fuzzy
#~ msgid ""
#~ "First, set ``render_mode`` to ``skip_vertex_transform``, which removes "
#~ "the transformation from model space to view space. Godot handles the "
#~ "transformation from view space to clip space behind the scenes with the "
#~ "``PROJECTION_MATRIX`` even when ``skip_vertex_transform`` is set. Nullify "
#~ "the projection matrix by setting it to the `identity matrix <https://en."
#~ "wikipedia.org/wiki/Identity_matrix>`_. In Godot, this is done by passing "
#~ "a `1` to a ``mat4``."
#~ msgstr ""
#~ "首先，将 ``render_mode`` 设置为 ``skip_vertex_transform`` ，它将从模型空间"
#~ "转换为视图空间。即使设置了 ``skip_vertex_transform`` ，Godot也会使用 "
#~ "``PROJECTION_MATRIX`` 处理从视图空间到场景后剪辑空间的转换。通过将投影矩阵"
#~ "设置为“identity matrix <https://en.wikipedia.org/wiki/Identity_matrix>`_ "
#~ "来对其进行Nullify。在Godot中，这是通过将`1`传递给 ``mat4`` 来完成的。"

#~ msgid "Make the AABB as large as possible so it can always be seen"
#~ msgstr "使AABB尽可能大，以便始终可以看到"

#~ msgid ""
#~ "This tutorial series will show you how to make a simple VR game/project. "
#~ "The intent of this tutorial is to give you an idea on how to make VR "
#~ "games in Godot."
#~ msgstr ""
#~ "本系列教程将向您展示如何制作简单的VR游戏/项目。 本教程的目的是让您了解如何"
#~ "在Godot中制作VR游戏。"

#~ msgid "Let's go over what this script does quickly, as it is fairly simple."
#~ msgstr "让我们快速了解一下这个脚本的作用，因为它非常简单。"

#~ msgid "Let's go over what this does quickly, as it is also fairly simple."
#~ msgstr "让我们快速回顾一下这个问题，因为它也很简单。"

#~ msgid "Creating 3D content"
#~ msgstr "创建3D内容"

#~ msgid "Channels"
#~ msgstr "频道"

#~ msgid ""
#~ "This is a list of third-party resources created by the community that may "
#~ "be of interest."
#~ msgstr "这是一个社区创建的您可能感兴趣的第三方资源列表。"

#~ msgid ""
#~ "Create custom particle code, that responds to baked animations or force "
#~ "fields."
#~ msgstr "创建自定义粒子代码，响应烘焙动画或强制字段。"

#~ msgid "do"
#~ msgstr "do"

#, fuzzy
#~ msgid "Reserved for future implementation of ``do... while`` loops."
#~ msgstr "预留作日后实施do…while循环。"

#~ msgid "switch"
#~ msgstr "switch"

#, fuzzy
#~ msgid "Reserved for future implementation. See match_."
#~ msgstr "保留以备将来使用。"

#~ msgid "case"
#~ msgstr "case"

#~ msgid ""
#~ "Available under ``Godot.GD``. Some things were moved to their own "
#~ "classes, like Math and Random. See below."
#~ msgstr ""
#~ "在'' Godot.GD ''下可用。有些东西被转移到他们自己的类，比如Math和Random。详"
#~ "细见下文。"

#~ msgid "``ERR_*`` constants were moved to ``Godot.Error``."
#~ msgstr "``ERR_ *`` 常量被移到 ``Godot.Error`` 。"

#~ msgid "Random"
#~ msgstr "随机"

#~ msgid "get_origin()"
#~ msgstr "get_origin()"

#~ msgid "Origin"
#~ msgstr "原点"

#~ msgid "end"
#~ msgstr "end"

#~ msgid "End"
#~ msgstr "终点"

#~ msgid "object[]"
#~ msgstr "object[]"

#~ msgid "int[]"
#~ msgstr "int[]"

#~ msgid ""
#~ "In some exceptional cases, a raw array (``type[]``) may be required "
#~ "instead of a ``List``."
#~ msgstr ""
#~ "在某些特殊情况下，可能需要一个原始数组( ``type []`` )而不是 ``List`` 。"

#~ msgid ""
#~ "*This is temporary. Array is ref-counted, so it will need its own type "
#~ "that wraps the native side.*"
#~ msgstr "*这是暂时的。 数组被重新计数，因此它需要自己的包装本机端的类型。*"

#~ msgid ""
#~ "``preload``, ``assert`` and ``yield``, as they work in GDScript, are "
#~ "currently not available in C#."
#~ msgstr ""
#~ "因为它们在GDScript中工作的 ``preload`` ， ``assert`` 和 ``yield`` 目前在C#"
#~ "中不可用。"

#~ msgid "? TODO"
#~ msgstr "? TODO"

#~ msgid "load"
#~ msgstr "load"

#~ msgid "GD.load, which is the same as ResourceLoader.load"
#~ msgstr "GD.load与ResourceLoader.load相同"

#~ msgid ""
#~ "Export of Blender materials is currently very primitive. However, it is "
#~ "the focus of a current GSoC project"
#~ msgstr "Blender材质的导出目前非常原始。 但是，它是当前GSOC项目的重点"

#~ msgid ""
#~ "Materials are currently exported using their \"Blender Render\" settings. "
#~ "When Blender 2.8 is released, this will be removed and this part of the "
#~ "exporter will change."
#~ msgstr ""
#~ "材质当前使用“Blender Render”设置导出。 当Blender 2.8发布时，这将被删除，导"
#~ "出器的这一部分将会改变。"

#~ msgid "**1. Switch workspace to 'Dope Sheet'**"
#~ msgstr "**1. 将工作区切换为“摄影表”**"

#~ msgid "The stashed action, while not active, will still be exported."
#~ msgstr "隐藏的操作虽然不活动，但仍会导出。"

#~ msgid "**3. Check stashed actions in 'NLA Editor' [optional]**"
#~ msgstr "**3. 检查“NLA编辑器”中的隐藏操作[可选] **"

#~ msgid "Switch workspace to 'NLA Editor'."
#~ msgstr "将工作区切换为“NLA编辑器”。"

#~ msgid "Make sure all stashed actions are muted."
#~ msgstr "确保所有隐藏的操作都被静音。"

#~ msgid ""
#~ "`core/dvector.h <https://github.com/godotengine/godot/blob/master/core/"
#~ "dvector.h>`__"
#~ msgstr ""
#~ "`core/dvector.h <https://github.com/godotengine/godot/blob/master/core/"
#~ "dvector.h>`__"

#~ msgid ""
#~ "Download and install the `Mono <http://www.mono-project.com/download/>`_ "
#~ "SDK."
#~ msgstr "下载并安装 `Mono <http://www.mono-project.com/download/>`_ SDK。"

#~ msgid "If you are using Godot 3.0.2, you must use Mono 5.4."
#~ msgstr "如果您使用的是Godot 3.0.2，则必须使用Mono 5.4。"

#~ msgid "Godot 3.0.3+ requires Mono 5.12 on all platforms."
#~ msgstr "Godot 3.0.3+在所有平台上都需要Mono 5.12。"

#~ msgid ""
#~ "You also need MSBuild (at least version 15.0), which should come with the "
#~ "Mono installation."
#~ msgstr "您还需要MSBuild(至少版本15.0)，它应该随Mono安装一起提供。"

#~ msgid ""
#~ "For instructions on installing older versions of Mono on Linux, see `this "
#~ "page <http://www.mono-project.com/docs/getting-started/install/linux/"
#~ "#accessing-older-releases>`_. Older versions of Mono for macOS and "
#~ "Windows can be found `here <https://download.mono-project.com/archive/>`_."
#~ msgstr ""
#~ "有关在Linux上安装旧版Mono的说明，请参阅 `本页 <http://www.mono-project."
#~ "com/docs/getting-started/install/linux/#accessing-older-releases>`_ 。 用"
#~ "于macOS和Windows的旧版Mono可以在这里找到<https://download.mono-project."
#~ "com/archive/>`_ 。"

#~ msgid ""
#~ "Additionally, your Godot version must have Mono support enabled, so "
#~ "ensure you download the **Mono version** of Godot."
#~ msgstr ""
#~ "此外，您的Godot版本必须启用Mono支持，因此请确保您下载Godot的** Mono版本"
#~ "**。"

#~ msgid ""
#~ "If you are using Visual Studio Code, ensure you download and install the ."
#~ "NET tools extension. Without this, Godot will crash when trying to create "
#~ "a new C# project or edit a C# script."
#~ msgstr ""
#~ "如果您使用的是Visual Studio Code，请确保下载并安装.NET工具扩展。 如果没有"
#~ "这个，Godot会在尝试创建新的C#项目或编辑C#脚本时崩溃。"

#~ msgid ""
#~ "Attached C# scripts should refer to a class that has a class name that "
#~ "matches the file name and is unique within the project assembly (`#7402 "
#~ "comment <https://github.com/godotengine/godot/"
#~ "issues/7402#issuecomment-269910926>`_)"
#~ msgstr ""
#~ "附加的C#脚本应该引用一个类名，该类具有与文件名匹配的类，并且在项目程序集中"
#~ "是唯一的(`＃7402 comment <https://github.com/godotengine/godot/"
#~ "issues/7402#issuecomment-269910926>`_ )"

#~ msgid ""
#~ "It is often desired to send a notification that something happened in an "
#~ "instance. GDScript supports creation of built-in Godot signals. Declaring "
#~ "a signal in GDScript is easy using the `signal` keyword."
#~ msgstr ""
#~ "通常希望发送当实例中发生某事的通知。 GDScript支持创建内置的Godot信号。 使"
#~ "用 `signal` 关键字可以轻松地在GDScript中声明信号。"

#~ msgid ""
#~ "These signals can be connected in the editor or from code like regular "
#~ "signals. Take the instance of a class where the signal was declared and "
#~ "connect it to the method of another instance:"
#~ msgstr ""
#~ "这些信号可以在编辑器中连接，也可以像常规信号那样连接。 获取声明信号的类的"
#~ "实例，并将其连接到另一个实例的方法:"

#~ msgid ""
#~ "It is also possible to bind arguments to a signal that lacks them with "
#~ "your custom values:"
#~ msgstr "也可以将参数绑定到缺少自定义值的信号:"

#~ msgid ""
#~ "This is useful when a signal from many objects is connected to a single "
#~ "callback and the sender must be identified:"
#~ msgstr ""
#~ "当来自多个对象的信号被连接到一个回调且发送方必须被识别时，这是非常有用的:"

#~ msgid ""
#~ "Finally, emitting a custom signal is done by using the Object.emit_signal "
#~ "method:"
#~ msgstr "最后，通过使用 Object.emit_signal 方法来发送定制信号:"

#~ msgid "out vec3 **VERTEX**"
#~ msgstr "out vec3 **VERTEX**"

#~ msgid "out vec3 **NORMAL**"
#~ msgstr "out vec3 **NORMAL**"

#~ msgid "out vec2 **UV**"
#~ msgstr "out vec2 **UV**"

#~ msgid "out vec2 **UV2**"
#~ msgstr "out vec2 **UV2**"

#~ msgid "out vec4 **COLOR**"
#~ msgstr "out vec4 **COLOR**"

#~ msgid "out float **POINT_SIZE**"
#~ msgstr "out float **POINT_SIZE**"

#~ msgid "For the same reason, the full screen project setting is ignored."
#~ msgstr "出于同样的原因，将忽略全屏项目设置。"

#~ msgid "HTTPClient"
#~ msgstr "HTTPClient"

#~ msgid ""
#~ "The ``HTTPClient`` implementation for the HTML5 platform has several "
#~ "restrictions:"
#~ msgstr "HTML5平台的 ``HTTPClient`` 实现有几个限制:"

#~ msgid "Starting exported games from the local file system"
#~ msgstr "从本地文件系统启动导出的游戏"

#~ msgid ""
#~ "Turning on **Export with Debug** when exporting will, in addition to "
#~ "enabling various debug features of the engine, display a debug output "
#~ "below the canvas when using the default HTML page, displaying JavaScript "
#~ "and engine errors. You can also use the browser-integrated developer "
#~ "console, usually opened with the F12 key, which often shows more "
#~ "information, including WebGL errors."
#~ msgstr ""
#~ "在导出时启用 **导出和调试** 除了启用引擎的各种调试功能外，在使用默认HTML页"
#~ "面时显示画布下方的调试输出，显示JavaScript和引擎错误。 您还可以使用浏览器"
#~ "集成的开发人员控制台，通常使用F12键打开，这通常会显示更多信息，包括WebGL错"
#~ "误。"

#~ msgid "The object itself has only two methods, ``load()`` and ``unload()``."
#~ msgstr "对象本身只有两个方法， ``load()`` 和 ``unload()`` 。"

#~ msgid "``Engine.load(basePath)``"
#~ msgstr "``Engine.load(basePath)``"

#~ msgid "``Engine.unload()``"
#~ msgstr "``Engine.unload()``"

#~ msgid "``Engine.isWebGLAvailable(majorVersion = 1)``"
#~ msgstr "``Engine.isWebGLAvailable(majorVersion = 1)``"

#~ msgid ""
#~ "The more interesting interface is accessed by instantiating ``Engine`` "
#~ "using the ``new`` operator:"
#~ msgstr "通过使用 ``new`` 运算符实例化 ``Engine`` 来访问更有趣的接口:"

#~ msgid "``engine.init(basePath)``"
#~ msgstr "``engine.init(basePath)``"

#~ msgid ""
#~ "Initializes the instance. If the engine wasn't loaded yet, a base path "
#~ "must be passed from which the engine will be loaded."
#~ msgstr "初始化实例。 如果尚未加载引擎，则必须传递将从中加载引擎的基本路径。"

#~ msgid ""
#~ "Returns a promise that resolves once the engine is loaded and "
#~ "initialized. It can then be started with ``engine.startGame()``"
#~ msgstr ""
#~ "返回一旦加载并初始化引擎就解析的承诺。 然后可以用 ``engine.startGame()`` "
#~ "开始"

#~ msgid "``engine.preloadFile(file, path)``"
#~ msgstr "``engine.preloadFile(file, path)``"

#~ msgid "``engine.start(arg1, arg2, …)``"
#~ msgstr "``engine.start(arg1, arg2, …)``"

#~ msgid "``engine.startGame(mainPack)``"
#~ msgstr "``engine.startGame(mainPack)``"

#~ msgid ""
#~ "Starts the game with the main pack loaded from the passed URL string and "
#~ "starts the engine with it."
#~ msgstr "使用从传递的URL字符串加载的主包启动游戏，并使用它启动引擎。"

#~ msgid "``engine.setUnloadAfterInit(enabled)``"
#~ msgstr "``engine.setUnloadAfterInit(enabled)``"

#~ msgid "Defaults to ``true``."
#~ msgstr "默认为 ``true`` 。"

#~ msgid "``engine.setCanvas(canvasElem)``"
#~ msgstr "``engine.setCanvas(canvasElem)``"

#~ msgid "``engine.setCanvasResizedOnStart(enabled)``"
#~ msgstr "``engine.setCanvasResizedOnStart(enabled)``"

#~ msgid "``engine.setLocale(locale)``"
#~ msgstr "``engine.setLocale(locale)``"

#~ msgid "``engine.setExecutableName(execName)``"
#~ msgstr "``engine.setExecutableName(execName)``"

#~ msgid "``engine.setProgressFunc(func)``"
#~ msgstr "``engine.setProgressFunc(func)``"

#~ msgid ""
#~ "This method is used to display download progress. The passed callback "
#~ "function is called with two number arguments, the first argument "
#~ "specifies bytes loaded so far, the second argument specifies the total "
#~ "number of bytes to load."
#~ msgstr ""
#~ "此方法用于显示下载进度。 使用两个数字参数调用传递的回调函数，第一个参数指"
#~ "定到目前为止加载的字节，第二个参数指定要加载的总字节数。"

#~ msgid "``engine.setStdoutFunc(func)``, ``engine.setStderrFunc(func)``"
#~ msgstr "``engine.setStdoutFunc(func)``, ``engine.setStderrFunc(func)``"

#~ msgid ""
#~ "These methods allow implementing custom behavior for the ``stdout`` and "
#~ "``stderr`` streams. The functions passed in will be called with one "
#~ "string argument specifying the string to print."
#~ msgstr ""
#~ "这些方法允许实现 ``stdout`` 和 ``stderr`` 流的自定义行为。 传入的函数将使"
#~ "用一个字符串参数调用，该参数指定要打印的字符串。"

#~ msgid "Image to World transform."
#~ msgstr "图像到世界变换。"

#~ msgid "World to view transform."
#~ msgstr "世界观看变革。"

#~ msgid ""
#~ "The other method uses LLVM's WebAssembly backend. This backend is not yet "
#~ "available in release versions of LLVM, only in development builds built "
#~ "with ``LLVM_EXPERIMENTAL_TARGETS_TO_BUILD=WebAssembly``. Compiling with "
#~ "this backend outputs files in LLVM's ``.s`` format, which is translated "
#~ "into actual WebAssembly using a tool called ``s2wasm``. Emscripten "
#~ "manages these processes as well, so we just invoke SCons."
#~ msgstr ""
#~ "另一种方法使用LLVM的WebAssembly后端。 LLVM的发行版本中尚未提供此后端，仅在"
#~ "使用``LLVM_EXPERIMENTAL_TARGETS_TO_BUILD = WebAssembly``构建的开发版本"
#~ "中。 使用此后端进行编译以LLVM的 ``.s`` 格式输出文件，使用名为 ``s2wasm`` "
#~ "的工具将其转换为实际的WebAssembly。 Emscripten也管理这些进程，因此我们只调"
#~ "用SCons。"

#~ msgid ""
#~ "Don't scale the shape's outline! Only use the size handles (circled in "
#~ "red) to adjust the shape!"
#~ msgstr "请勿缩放该形状的外框！只要用大小控制柄(红圈)来调整形状！"

#~ msgid ""
#~ "Disabling the area's collision shape means it won't detect collisions. By "
#~ "turning it off, we make sure we don't trigger the ``hit`` signal more "
#~ "than once."
#~ msgstr ""
#~ "禁用区域碰撞形体意味着它不会检测碰撞，通过关闭它我们能够确保不会多次触发 "
#~ "``hit`` 信号。"

#~ msgid "``Layout``: \"Center Top\""
#~ msgstr "``布局``: \"中心 顶端\""

#~ msgid "``Margin``:"
#~ msgstr "``边界``:"

#~ msgid "Left: ``-25``"
#~ msgstr "左侧: ``-25``"

#~ msgid "Top: ``0``"
#~ msgstr "顶部: ``0``"

#~ msgid "Right: ``25``"
#~ msgstr "右侧: ``25``"

#~ msgid "Bottom: ``100``"
#~ msgstr "底部: ``100``"

#~ msgid "Left: ``-200``"
#~ msgstr "左侧: ``-200``"

#~ msgid "Top: ``-150``"
#~ msgstr "顶部: ``-150``"

#~ msgid "Right: ``200``"
#~ msgstr "右侧: ``200``"

#~ msgid "Bottom: ``0``"
#~ msgstr "底部: ``0``"

#~ msgid "Left: ``-100``"
#~ msgstr "左侧: ``-100``"

#~ msgid "Right: ``100``"
#~ msgstr "右侧: ``100``"

#~ msgid ""
#~ "For one last bit of visual appeal, let's add a trail effect to the "
#~ "player's movement. Choose your ``Player`` scene and add a :ref:"
#~ "`Particles2D <class_Particles2D>` node named ``Trail``."
#~ msgstr ""
#~ "让我们为player的移动添加一个跟踪效果来增添一些视觉吸引力。选择 ``Player`` "
#~ "场景并添加名为 ``Trail`` 的 :ref:`Particles2D <class_Particles2D>` 节点。"

#~ msgid ""
#~ "There are a large number of properties to choose from when configuring "
#~ "particles. Feel free to experiment and create different effects. For the "
#~ "effect in this example, use the following settings:"
#~ msgstr ""
#~ "在配置粒子时，有大量的属性可供选择。请随意尝试并创造不同的效果。对于本例中"
#~ "的效果，使用下面的设置:"

#~ msgid ""
#~ "You also need to create a ``Material`` by clicking on ``<null>`` and then "
#~ "\"New ParticlesMaterial\". The settings for that are below:"
#~ msgstr ""
#~ "您还需要通过点击 ``<null>`` 和 \"New ParticlesMaterial\" 来创建 "
#~ "``Material`` 。设置如下:"

#~ msgid ""
#~ "To make the gradient for the \"Color Ramp\" setting, we want a gradient "
#~ "taking the alpha (transparency) of the sprite from 0.5 (semi-transparent) "
#~ "to 0.0 (fully transparent)."
#~ msgstr ""
#~ "要使 \"Color Ramp\" 设置具有渐变效果，我们需要将sprite的alpha(透明度)设置"
#~ "为从0.5(半透明)到0.0(完全透明)。"

#~ msgid ""
#~ "Click \"New GradientTexture\", then under \"Gradient\", click \"New "
#~ "Gradient\". You'll see a window like this:"
#~ msgstr ""
#~ "点击 \"New GradientTexture\" ，然后在 \"gradient\" 下拉选项中选择 \"New "
#~ "Gradient\" 并点击。您会看到这样一个窗口:"

#~ msgid ""
#~ "The left and right boxes represent the start and end colors. Click on "
#~ "each and then click the large square on the right to choose the color. "
#~ "For the first color, set the ``A`` (alpha) value to around halfway. For "
#~ "the second, set it all the way to ``0``."
#~ msgstr ""
#~ "左边和右边的竖着的矩形方框表示开始和结束颜色。分别点击它们，然后点击右边的"
#~ "大方块来选择颜色。对于第一个颜色， 设置 ``A`` (alpha) 值为大约一半。对于第"
#~ "二个颜色，把所有值设置为0。"

#~ msgid ""
#~ "See :ref:`Particles2D <class_Particles2D>` for more details on using "
#~ "particle effects."
#~ msgstr ""
#~ "参考 :ref:`Particles2D <class_Particles2D>` 来了解使用粒子效果的更多细节。"

#~ msgid "|image7| |image14|"
#~ msgstr "|image7| |image14|"

#~ msgid ""
#~ "A more flexible alternative to prefabs you might know from Unity (and "
#~ "much more powerful given that instances can be nested)."
#~ msgstr ""
#~ "您可能从Unity中了解到，这是一个比prefabs更灵活的替代方案(而且更强大，因为"
#~ "实例可以嵌套)。"

#~ msgid "Release Password: Key password."
#~ msgstr "发布密码:密钥密码。"

#~ msgid ""
#~ "Managing drawing logic of a large amount of simple objects (in the "
#~ "hundreds of thousands). Using a thousand nodes is probably not nearly as "
#~ "efficient as drawing, but a thousand draw calls are cheap; take the "
#~ "\"Shower of Bullets\" demo as an example."
#~ msgstr ""
#~ "管理大量简单对象的绘图逻辑(数十万)。 尽管一千个绘制调用计算负担不大，但使"
#~ "用一千个节点可能不如绘图效率高。 可在“子弹阵雨”演示中验证。"

#~ msgid "Working with 3D skeletons"
#~ msgstr "使用3D骨骼"

#~ msgid ""
#~ "Godot 3D skeleton support is currently quite rudimentary. The :ref:"
#~ "`class_Skeleton` node and class were designed mainly to support importing "
#~ "skeletal animations as a set of transformation matrices."
#~ msgstr ""
#~ "Godot3D骨架支持目前相当简陋。 :ref:`class_Skeleton` 节点和类的设计主要是为"
#~ "了支持将骨架动画导入为一组转换矩阵。"

#~ msgid "Skeleton node"
#~ msgstr "骨架节点"

#, fuzzy
#~ msgid ""
#~ "The Skeleton node can be directly added anywhere you want on a scene. "
#~ "Usually the target mesh is a child of Skeleton, as it is easier to "
#~ "manipulate this way, since Transforms within a skeleton are relative to "
#~ "where the Skeleton is. But you can specify a Skeleton node in every "
#~ "MeshInstance."
#~ msgstr ""
#~ "Skeleton节点可以直接添加到场景中的任何位置。 通常目标网格是Skeleton的子节"
#~ "点，因为它更容易以这种方式操作，因为骨架内的变换是相对于Skeleton的位置。 "
#~ "但是您可以在每个MeshInstance中指定一个Skeleton节点。"

#, fuzzy
#~ msgid ""
#~ "Naturally, Skeleton is intended to deform meshes and consists of "
#~ "structures called \"bones\". Each \"bone\" is represented as a Transform, "
#~ "which is applied to a group of vertices within a mesh. You can directly "
#~ "control a group of vertices from Godot. For that please reference the :"
#~ "ref:`class_MeshDataTool` class and its method :ref:`set_vertex_bones() "
#~ "<class_MeshDataTool_method_set_vertex_bones>`."
#~ msgstr ""
#~ "当然，Skeleton旨在使网格变形，并由称为“骨骼”的结构组成。 每个“骨骼”都表示"
#~ "为一个变换，它应用于网格中的一组顶点。 您可以直接控制Godot的一组顶点。 为"
#~ "此请参考 :ref:`class_MeshDataTool` 类及其方法 :ref:`set_vertex_bones() "
#~ "<class_MeshDataTool_method_set_vertex_bones>`。"

#, fuzzy
#~ msgid ""
#~ "The \"bones\" are organized hierarchically. Every bone, except for the "
#~ "root bone(s), has a parent. Every bone also has an associated name you "
#~ "can use to refer to it (e.g. \"root\" or \"hand.L\", etc.). All bones are "
#~ "numbered, and these numbers are bone IDs. Bone parents are referred to by "
#~ "their numbered IDs."
#~ msgstr ""
#~ "“骨头”按层次组织。 除了根骨之外，每个骨骼都有一个父骨骼。 每个骨骼也有一个"
#~ "可用于引用它的关联名称(例如“root”或“hand.L”等)。 所有骨骼都有编号，这些数"
#~ "字是骨骼ID。 骨父母由他们的编号ID引用。"

#~ msgid ""
#~ "This scene is imported from Blender. It contains an arm mesh with 2 "
#~ "bones, upperarm and lowerarm, with the lowerarm bone parented to the "
#~ "upperarm."
#~ msgstr ""
#~ "此场景从Blender导入。 它包含一个手臂网，有2个骨头，上臂和下颌骨，下颌骨是"
#~ "上臂的父骨。"

#~ msgid "Skeleton class"
#~ msgstr "骨骼类"

#~ msgid ""
#~ "You can view Godots internal help for descriptions of all functions. "
#~ "Basically, all operations on bones are done using their numeric ID. You "
#~ "can convert from a name to a numeric ID and vice versa."
#~ msgstr ""
#~ "您可以查看Godots内部帮助以了解所有功能。 基本上，骨骼上的所有操作都是使用"
#~ "它们的数字ID完成的。 您可以从名称转换为数字ID，反之亦然。"

#~ msgid ""
#~ "**To find the number of bones in a skeleton we use the get_bone_count() "
#~ "function:**"
#~ msgstr "**要查找骨架中的骨骼数量，我们使用get_bone_count()函数:**"

#~ msgid "**To find the ID of a bone, use the find_bone() function:**"
#~ msgstr "**要查找骨骼的ID，请使用find_bone()函数:**"

#, fuzzy
#~ msgid ""
#~ "Now, we want to do something interesting with the ID, not just print it. "
#~ "Also, we might need additional information, finding bone parents to "
#~ "complete chains, etc. This is done with the get/set_bone\\_\\* functions."
#~ msgstr ""
#~ "现在，我们想用ID做一些有趣的事情，而不仅仅是打印它。 此外，我们可能需要其"
#~ "他信息，找到骨骼父母来完成链等。这是通过get / set_bone \\ _ \\ _ *函数完成"
#~ "的。"

#~ msgid ""
#~ "**To find the parent of a bone we use the get_bone_parent(id) function:**"
#~ msgstr "**要查找骨骼的父级，我们使用get_bone_parent(id)函数:**"

#, fuzzy
#~ msgid ""
#~ "The bone transforms are what interests us here. There are 3 kinds of "
#~ "transform: local, global, custom."
#~ msgstr "骨转换是我们感兴趣的事情。 有三种转换:本地，全球，自定义。"

#, fuzzy
#~ msgid ""
#~ "**To find the local Transform of a bone, we use get_bone_pose(id) "
#~ "function:**"
#~ msgstr "**要查找骨骼的局部变换，我们使用get_bone_pose(id)函数:**"

#~ msgid ""
#~ "So we get a 3x4 matrix there, with the first column filled with 1s. What "
#~ "can we do with this matrix? It is a Transform, so we can do everything we "
#~ "can do with Transforms (basically translate, rotate and scale). We could "
#~ "also multiply transforms to have more complex transforms. Remember, "
#~ "\"bones\" in Godot are just Transforms over a group of vertices. We could "
#~ "also copy Transforms of other objects there. So let's rotate our "
#~ "\"upperarm\" bone:"
#~ msgstr ""
#~ "所以我们得到一个3x4矩阵，第一列填充1s。 我们可以用这个矩阵做什么？ 它是一"
#~ "个变换，所以我们可以做任何我们可以用变换做的事情(基本上是平移，旋转和缩"
#~ "放)。 我们还可以将变换乘以更复杂的变换。 请记住，Godot的“骨头”只是在一组顶"
#~ "点上进行变换。 我们还可以复制其他对象的变换。 那么让我们旋转我们"
#~ "的“upperarm”骨骼:"

#~ msgid ""
#~ "Now we can rotate individual bones. The same happens for scale and "
#~ "translate. Try these on your own and check the results."
#~ msgstr ""
#~ "现在我们可以旋转单个骨骼。 规模和翻译也是如此。 自己尝试这些并检查结果。"

#, fuzzy
#~ msgid ""
#~ "What we used here was the local pose. By default all bones are not "
#~ "modified. But this Transform tells us nothing about the relationship "
#~ "between bones. This information is needed for quite a number of tasks. "
#~ "How can we get it? This is where the global transform comes into play:"
#~ msgstr ""
#~ "我们在这里使用的是当地的姿势。 默认情况下，不会修改所有骨骼。 但是这个变换"
#~ "没有告诉我们骨头之间的关系。 许多任务都需要此信息。 我们怎么能得到它？ 全"
#~ "球转型发挥作用:"

#~ msgid ""
#~ "**To find the bone global Transform we use get_bone_global_pose(id) "
#~ "function:**"
#~ msgstr "**要查找骨骼全局变换，我们使用get_bone_global_pose(id)函数:**"

#~ msgid "Let's find the global Transform for the lowerarm bone:"
#~ msgstr "让我们找到低胸骨的全局变换:"

#~ msgid ""
#~ "As you can see, this transform is not zeroed. While being called global, "
#~ "it is actually relative to the Skeleton origin. For a root bone, the "
#~ "origin is always at 0 if not modified. Let's print the origin for our "
#~ "lowerarm bone:"
#~ msgstr ""
#~ "如您所见，此变换未归零。 虽然被称为全球，但实际上它与Skeleton的起源有关。 "
#~ "对于根骨骼，如果未修改，则原点始终为0。 让我们打印我们的低骨骼的起源:"

#, fuzzy
#~ msgid ""
#~ "You will see a number. What does this number mean? It is a rotation point "
#~ "of the Transform. So it is base part of the bone. In Blender, you can go "
#~ "to Pose mode and try to rotate bones there. They will rotate around their "
#~ "origin."
#~ msgstr ""
#~ "您会看到一个数字。 这个数字是什么意思？ 它是变换的旋转点。 所以它是骨骼的"
#~ "基础部分。 在Blender中您可以进入Pose模式并尝试旋转骨骼。 它们将围绕它们的"
#~ "原点旋转。"

#~ msgid ""
#~ "But what about the bone tip? We can't know things like the bone length, "
#~ "which we need for many things, without knowing the tip location. For all "
#~ "bones in a chain, except for the last one, we can calculate the tip "
#~ "location. It is simply a child bone's origin. There are situations when "
#~ "this is not true, such as for non-connected bones, but that is OK for us "
#~ "for now, as it is not important regarding Transforms."
#~ msgstr ""
#~ "但骨头怎么样？ 在不知道尖端位置的情况下，我们无法知道许多东西需要的骨骼长"
#~ "度等内容。 对于链中的所有骨骼，除了最后一个骨骼，我们可以计算尖端位置。 它"
#~ "只是儿童骨骼的起源。 在某些情况下，这种情况并非如此，例如对于非连接的骨"
#~ "骼，但现在对我们来说这是好的，因为它对于变形来说并不重要。"

#~ msgid ""
#~ "Notice that the leaf bone tip is nowhere to be found. A leaf bone is a "
#~ "bone without children, so you don't have any information about its tip. "
#~ "But this is not a showstopper. You can overcome this by either adding an "
#~ "extra bone to the chain or just calculating the length of the leaf bone "
#~ "in Blender and storing the value in your script."
#~ msgstr ""
#~ "请注意，叶骨尖无处可寻。 叶骨是没有子节点的骨头，因此您没有关于其尖端的任"
#~ "何信息。 但这不是一个停滞不前的问题。 您可以通过向链中添加额外的骨骼或仅在"
#~ "Blender中计算叶骨的长度并将值存储在脚本中来解决此问题。"

#~ msgid "Using 3D \"bones\" for mesh control"
#~ msgstr "使用3D“骨骼”进行网格控制"

#, fuzzy
#~ msgid ""
#~ "Now, as you know the basics, we can apply these to make full FK-control "
#~ "of our arm (FK is forward-kinematics)."
#~ msgstr ""
#~ "现在您已经了解了我们可以应用这些基础知识来对我们的手臂进行全面的FK控制(FK"
#~ "是前向运动学)。"

#, fuzzy
#~ msgid "To fully control our arm, we need the following parameters:"
#~ msgstr "要完全控制我们的手臂，我们需要以下参数:"

#~ msgid "Upperarm angle x, y, z"
#~ msgstr "上臂角度x，y，z"

#~ msgid "Lowerarm angle x, y, z"
#~ msgstr "下臂角度x，y，z"

#~ msgid "All of these parameters can be set, incremented, and decremented."
#~ msgstr "所有这些参数都可以设置，递增和递减。"

#~ msgid "Create the following node tree:"
#~ msgstr "创建以下节点树:"

#~ msgid ""
#~ "Set up the Camera so that the arm is properly visible. Rotate "
#~ "DirectionLight so that the arm is properly lit while in scene play mode."
#~ msgstr ""
#~ "设置相机，以便可以正确看到手臂。 旋转DirectionLight，以便在场景播放模式下"
#~ "手臂正确点亮。"

#~ msgid "Now we need to create a new script under main:"
#~ msgstr "现在我们需要在main下创建一个新脚本:"

#~ msgid "First we define the setup parameters:"
#~ msgstr "首先我们定义设置参数:"

#, fuzzy
#~ msgid ""
#~ "Now we need to set up a way to change them. Let us use keys for that."
#~ msgstr "现在我们需要设置一种方法来改变它们。 让我们使用密钥。"

#~ msgid "Please create 7 actions under project settings -> Input Map:"
#~ msgstr "请在项目设置下创建7个操作 ->输入地图:"

#~ msgid "**selext_x** - bind to X key"
#~ msgstr "**selext_x** - 绑定到X键"

#~ msgid "**selext_y** - bind to Y key"
#~ msgstr "**selext_y** - 绑定到Y键"

#~ msgid "**selext_z** - bind to Z key"
#~ msgstr "**selext_z** - 绑定到Z键"

#~ msgid "**select_upperarm** - bind to key 1"
#~ msgstr "**select_upperarm** - 绑定到键1"

#~ msgid "**select_lowerarm** - bind to key 2"
#~ msgstr "**select_lowerarm** - 绑定到键2"

#~ msgid "**increment** - bind to key numpad +"
#~ msgstr "**increment** - 绑定到数字键盘键+"

#~ msgid "**decrement** - bind to key numpad -"
#~ msgstr "**decrement** - 绑定到数字键盘键 -"

#, fuzzy
#~ msgid ""
#~ "So now we want to adjust the above parameters. Therefore, we create code "
#~ "which does that:"
#~ msgstr "所以现在我们要调整上面的参数。 因此我们创建代码来执行以下操作:"

#~ msgid "The full code for arm control is this:"
#~ msgstr "手臂控制的完整代码是这样的:"

#, fuzzy
#~ msgid ""
#~ "Pressing keys 1/2 selects upperarm/lowerarm; select the axis by pressing "
#~ "x, y, z, rotate using numpad \"+\"/\"-\"."
#~ msgstr "按键1/2选择上臂/下臂，按x，y，z选择轴，使用小键盘“+”/“ - ”旋转"

#, fuzzy
#~ msgid ""
#~ "This way you fully control your arm in FK mode using 2 bones. You can add "
#~ "additional bones and/or improve the \"feel\" of the interface by using "
#~ "coefficients for the change. I recommend you play with this example a lot "
#~ "before moving on to the next part."
#~ msgstr ""
#~ "这样您就可以使用2个骨骼在FK模式下完全控制手臂。 您可以通过使用系数进行更改"
#~ "来添加其他骨骼和/或改善界面的“感觉”。 我建议您在进入下一部分之前先玩这个示"
#~ "例。"

#~ msgid "You can clone the demo code for this chapter using"
#~ msgstr "您可以使用克隆本章的演示代码"

#~ msgid "Or you can browse it using the web-interface:"
#~ msgstr "或者您可以使用Web界面浏览它:"

#~ msgid "https://github.com/slapin/godot-skel3d"
#~ msgstr "https://github.com/slapin/godot-skel3d"

#, fuzzy
#~ msgid "Using 3D \"bones\" to implement inverse kinematics"
#~ msgstr "使用3D“骨骼”实现反向运动学"

#~ msgid "See :ref:`doc_inverse_kinematics`."
#~ msgstr "请参阅 :ref:`doc_inverse_kinematics`。"

#~ msgid "Using 3D \"bones\" to implement ragdoll-like physics"
#~ msgstr "使用3D“骨头”来实现类似布娃娃的物理"

#~ msgid "Inverse kinematics"
#~ msgstr "反向运动学"

#, fuzzy
#~ msgid ""
#~ "This tutorial is a follow-up to :ref:`doc_working_with_3d_skeletons`."
#~ msgstr "本教程是后续 :ref:`doc_working_with_3d_skeletons`。"

#~ msgid ""
#~ "Previously, we were able to control the rotations of bones in order to "
#~ "manipulate where our arm was (forward kinematics). But what if we wanted "
#~ "to solve this problem in reverse? Inverse kinematics (IK) tells us *how* "
#~ "to rotate our bones in order to reach a desired position."
#~ msgstr ""
#~ "以前，我们能够控制骨骼的旋转，以便操纵我们的手臂(正向运动学)。 但是，如果"
#~ "我们想要反过来解决这个问题呢？ 反向运动学(IK)告诉我们 *如何* 旋转我们的骨"
#~ "骼以达到所需的位置。"

#~ msgid ""
#~ "A simple example of IK is the human arm: While we intuitively know the "
#~ "target position of an object we want to reach for, our brains need to "
#~ "figure out how much to move each joint in our arm to get to that target."
#~ msgstr ""
#~ "IK的一个简单示例就是人类的手臂:当我们直观地知道我们想要达到的物体的目标位"
#~ "置时，我们的大脑需要弄清楚在我们的手臂中移动每个关节到达目标的程度。"

#~ msgid "Initial problem"
#~ msgstr "最初的问题"

#, fuzzy
#~ msgid ""
#~ "We want to position the 2 angles on the joints of our upperarm and "
#~ "lowerarm so that the tip of the lowerarm bone is as close to the target "
#~ "point (which is set by the target Vector3) as possible using only "
#~ "rotations. This task is calculation-intensive and never resolved by "
#~ "analytical equation solving, as it is an under-constrained problem, which "
#~ "means that there is more than one solution to an IK problem."
#~ msgstr ""
#~ "在Godot术语中，我们要在这里解决的任务是将2个角度定位在我们的上臂和下肢的关"
#~ "节上，使得低位骨骼的尖端尽可能接近目标点(由目标Vector3设置) 尽可能只使用旋"
#~ "转。 此任务是计算密集型的，并且永远不会通过解析方程求解来解决，因为它是一"
#~ "个欠约束问题，这意味着IK问题有多个解决方案。"

#, fuzzy
#~ msgid ""
#~ "For easy calculation in this chapter, we assume the target is a child of "
#~ "Skeleton. If this is not the case for your setup, you can always reparent "
#~ "it in your script, as you will save on calculations if you do so."
#~ msgstr ""
#~ "为了便于在本章中进行计算，我们认为目标是Skeleton的子节点。 如果您的设置不"
#~ "是这种情况，您可以随时在脚本中重新显示它，因为如果您这样做，您将节省计算。"

#~ msgid ""
#~ "In the picture, you see the angles alpha and beta. In this case, we don't "
#~ "use poles and constraints, so we need to add our own. On the picture the "
#~ "angles are 2D angles living in a plane which is defined by bone base, "
#~ "bone tip, and target."
#~ msgstr ""
#~ "在图片中，您可以看到角度α和β。 在这种情况下，我们不使用极点和约束，因此我"
#~ "们需要添加自己的极点和约束。 在图片上，角度是生活在由骨基部，骨尖和目标定"
#~ "义的平面中的2D角。"

#, fuzzy
#~ msgid ""
#~ "The rotation axis is easily calculated using the cross-product of the "
#~ "bone vector and the target vector. The rotation, in this case, will "
#~ "always be in the positive direction. If ``t`` is the Transform which we "
#~ "get from the get_bone_global_pose() function, the bone vector is"
#~ msgstr ""
#~ "使用骨骼向量和目标向量的叉积容易地计算旋转轴。 在这种情况下，旋转将始终在"
#~ "正方向。 如果 ``t`` 是我们从get_bone_global_pose()函数得到的Transform，那"
#~ "么骨骼向量是"

#~ msgid "So we have all the information we need to execute our algorithm."
#~ msgstr "因此，我们拥有执行算法所需的所有信息。"

#~ msgid ""
#~ "In game dev it is common to resolve this problem by iteratively closing "
#~ "to the desired location, adding/subtracting small numbers to the angles "
#~ "until the distance change achieved is less than some small error value. "
#~ "Sounds easy enough, but there are still Godot problems we need to resolve "
#~ "to achieve our goal."
#~ msgstr ""
#~ "在游戏开发中，通常通过迭代地闭合到期望位置来解决该问题，向角度添加/减去小"
#~ "数字直到所实现的距离变化小于某个小的误差值。 听起来很容易，但我们需要解决"
#~ "的Godot问题才能实现我们的目标。"

#~ msgid "**How to find coordinates of the tip of the bone?**"
#~ msgstr "**如何找到骨尖的坐标？**"

#~ msgid "**How to find the vector from the bone base to the target?**"
#~ msgstr "**如何找到从骨基部到目标的载体？**"

#~ msgid ""
#~ "For our goal (tip of the bone moved within area of target), we need to "
#~ "know where the tip of our IK bone is. As we don't use a leaf bone as IK "
#~ "bone, we know the coordinate of the bone base is the tip of the parent "
#~ "bone. All these calculations are quite dependent on the skeleton's "
#~ "structure. You could use pre-calculated constants, or you could add an "
#~ "extra bone at the tip of the IK bone and calculate using that."
#~ msgstr ""
#~ "为了我们的目标(在目标区域内移动骨骼的尖端)，我们需要知道IK骨骼的尖端在哪"
#~ "里。 由于我们不使用叶骨作为IK骨骼，因此我们知道骨骼基座的坐标是父骨骼的尖"
#~ "端。 所有这些计算都完全取决于骨架的结构。 您可以使用预先计算的常量，或者可"
#~ "以在IK骨骼的顶端添加额外的骨骼并使用它进行计算。"

#~ msgid ""
#~ "We will use an exported variable for the bone length to make it easy."
#~ msgstr "我们将使用导出的变量作为骨骼长度来简化。"

#~ msgid ""
#~ "Now, we need to apply our transformations from the IK bone to the base of "
#~ "the chain, so we apply a rotation to the IK bone, then move from our IK "
#~ "bone up to its parent, apply rotation again, then move to the parent of "
#~ "the current bone again, etc. So we need to limit our chain somewhat."
#~ msgstr ""
#~ "现在，我们需要将IK骨骼的变换应用到链的基础，因此我们将旋转应用于IK骨骼，然"
#~ "后从IK骨骼移动到其父骨骼，再次应用旋转，然后移动到父骨骼 当前的骨头等等。"
#~ "所以我们需要稍微限制我们的链条。"

#~ msgid "For the ``_ready()`` function:"
#~ msgstr "对于 ``_ready()`` 函数:"

#~ msgid "Now we can write our chain-passing function:"
#~ msgstr "现在我们可以编写链传递函数:"

#~ msgid "And for the ``_process()`` function:"
#~ msgstr "对于 ``_process()`` 函数:"

#~ msgid ""
#~ "Executing this script will pass through the bone chain, printing bone "
#~ "transforms."
#~ msgstr "执行此脚本将通过骨链，打印骨骼变换。"

#, fuzzy
#~ msgid ""
#~ "Now we need to actually work with the target. The target should be placed "
#~ "somewhere accessible. Since \"arm\" is an imported scene, we better place "
#~ "the target node within our top level scene. But for us to work with "
#~ "target easily, its Transform should be on the same level as the Skeleton."
#~ msgstr ""
#~ "现在我们需要实际使用目标。 目标应该放在可以访问的地方。 由于“arm”是导入的"
#~ "场景，我们最好将目标节点放在顶级场景中。 但是为了让我们轻松地使用目标，它"
#~ "的变换应该与Skeleton处于同一水平。"

#, fuzzy
#~ msgid ""
#~ "To cope with this problem, we create a \"target\" node under our scene "
#~ "root node and will reparent it at runtime, copying the global transform, "
#~ "which will achieve the desired effect."
#~ msgstr ""
#~ "为了解决这个问题，我们在场景根节点下创建一个“目标”节点，在运行时我们将重新"
#~ "显示它，复制全局变换，这将实现所需的效果。"

#~ msgid ""
#~ "Create a new Spatial node under the root node and rename it to \"target"
#~ "\". Then modify the ``_ready()`` function to look like this:"
#~ msgstr ""
#~ "在根节点下创建一个新的Spatial节点，并将其重命名为“target”。 然后修改 "
#~ "``_ready()`` 函数看起来像这样:"

#~ msgid ""
#~ "Set the environment variable ``ANDROID_NDK_ROOT`` to point to the Android "
#~ "NDK."
#~ msgstr "将环境变量ANDROID_NDK_ROOT设置为指向Android NDK。"

#~ msgid ""
#~ "GameObject -> Node Add a component -> Inheriting Prefab -> Externalized "
#~ "branch"
#~ msgstr "GameObject ->节点 添加组件 ->继承 预制体 ->外化分支"

#~ msgid ""
#~ "Our level will contain these objects: 1. A room 2. A bed 3. A lamp 4. A "
#~ "desk 5. A bookshelf"
#~ msgstr "我们的水平将包含这些物品:1。房间2.床3.灯2.桌子5.书架"

#~ msgid "Lets go over what's happening here:"
#~ msgstr "让我们回顾一下这里发生的事情:"

#~ msgid "Lets go over what this function is doing:"
#~ msgstr "让我们来看看这个函数正在做什么:"

#~ msgid "In this guide you will learn:"
#~ msgstr "在本指南中，您将学习:"

#~ msgid "Collision Layers and Masks"
#~ msgstr "碰撞层和遮罩"

#~ msgid "Look at function"
#~ msgstr "看函数"

#~ msgid ""
#~ "Unlike the shader language in Godot 2.x, this implementation is much "
#~ "closer to the original."
#~ msgstr "与Godot 2.x中的着色器语言不同，此实现更接近原始语言。"

#~ msgid "Operators:"
#~ msgstr "操作符:"

#~ msgid "Functions can be used from any other function that is below it."
#~ msgstr "函数可以被它下面的任何其他函数中调用。"

#~ msgid ""
#~ "Depending on shader type, a different set of built-in inputs and outputs "
#~ "are provided. In general, vertex functions are not that commonly used."
#~ msgstr ""
#~ "根据着色器类型的不同，会提供一组不同的内置输入和输出。一般来说，顶点函数并"
#~ "不常用。"

#~ msgid "**noperspective**"
#~ msgstr "**noperspective**"

#~ msgid "The value is linearly interpolated in window-space"
#~ msgstr "该值在窗口空间中线性插值"

#~ msgid "Shader Types In-Depth"
#~ msgstr "着色器类型深入"

#~ msgid "Accepted render modes and built-ins for **shader_type spatial;**."
#~ msgstr "接受** shader_type spatial的渲染模式和内置函数; **。"

#~ msgid "Substractive blend mode."
#~ msgstr "减法混合模式。"

#~ msgid "Vertex in local coords (see doc below)."
#~ msgstr "局部坐标中的顶点(见下文)。"

#~ msgid ""
#~ "It is also possible to completely disable the built-in modelview "
#~ "transform (projection will still happen later, though) with the following "
#~ "code, so it can be done manually:"
#~ msgstr ""
#~ "也可以使用以下代码完全禁用内置模型视图变换(投影仍将在稍后进行)，因此可以手"
#~ "动完成:"

#~ msgid "Rim (0..1)."
#~ msgstr "Rim (0..1)."

#~ msgid "Small added specular blob."
#~ msgstr "小添加镜面斑点。"

#~ msgid "Gloss of Clearcoat."
#~ msgstr "透明涂层的光泽。"

#~ msgid "Strength of Subsurface Scattering (default 0)."
#~ msgstr "次表面散射强度(默认值为0)。"

#~ msgid "Transmission mask (default 0,0,0)."
#~ msgstr "传输掩码(默认为0,0,0)。"

#~ msgid "out vec2 **SCREEN_UV**"
#~ msgstr "out vec2 **SCREEN_UV**"

#~ msgid "Normal vector."
#~ msgstr "法向量。"

#~ msgid "View vector."
#~ msgstr "查看向量。"

#~ msgid "Light Vector."
#~ msgstr "光向量。"

#~ msgid ""
#~ "Writing light shaders is completely optional. Unlike other game engines, "
#~ "they don't affect performance or force a specific pipeline."
#~ msgstr ""
#~ "编写灯光着色器是完全可选的。 与其他游戏引擎不同，它们不会影响性能或强制使"
#~ "用特定的管道。"

#~ msgid "Canvas Item"
#~ msgstr "画布项目"

#~ msgid ""
#~ "Accepted render modes and built-ins for **shader_type canvas_item;**."
#~ msgstr "接受** shader_type canvas_item; **的渲染模式和内置函数。"

#~ msgid "Normal, writable."
#~ msgstr "正常，可写。"

#~ msgid "Normal from texture, default is read from NORMAL_TEXTURE."
#~ msgstr "从纹理开始，从NORMAL_TEXTURE读取默认值。"

#~ msgid "Color from vertex function."
#~ msgstr "顶点函数的颜色。"

#~ msgid "Height of Light."
#~ msgstr "光的高度。"

#~ msgid ""
#~ "Value from the Light texture. **(shader is ignored if this is not used)."
#~ "** Can be modified."
#~ msgstr "轻质感的价值。 **(如果未使用，则忽略着色器。)**可以修改。"

#~ msgid "Accepted render modes and built-ins for **shader_type particles;**."
#~ msgstr "接受** shader_type粒子的渲染模式和内置函数; **。"

#~ msgid "Disable force."
#~ msgstr "禁用力量。"

#~ msgid "Disable velocity."
#~ msgstr "禁用速度。"

#~ msgid "Packaging Godot"
#~ msgstr "包装Godot"

#~ msgid ""
#~ "Godot has features to make it easier to distribute and to package it for "
#~ "application repositories."
#~ msgstr "Godot具有使其更易于分发和将其打包为应用程序存储库的功能。"

#~ msgid "Default behaviour"
#~ msgstr "默认行为"

#~ msgid ""
#~ "By default, Godot stores all settings and installed templates in a per-"
#~ "user directory. First Godot checks the ``APPDATA`` environment variable. "
#~ "If it exists, the per-user directory is the ``Godot`` subdirectory of "
#~ "``APPDATA``. If ``APPDATA`` doesn't exist, Godot checks the ``HOME`` "
#~ "environment variable. The per-user directory is then the \".godot\" "
#~ "subdir of ``HOME``."
#~ msgstr ""
#~ "默认情况下，Godot将所有设置和已安装的模板存储在每个用户目录中。 First "
#~ "Godot检查 ``APPDATA`` 环境变量。 如果它存在，则每用户目录是 ``APPDATA`` "
#~ "的 ``Godot`` 子目录。 如果 ``APPDATA`` 不存在，Godot会检查 ``HOME`` 环境变"
#~ "量。 然后，每用户目录是 ``HOME`` 的“.godot”子目录。"

#~ msgid "This meets common operating system standards."
#~ msgstr "这符合通用操作系统标准。"

#~ msgid "Global template path (Unix only)"
#~ msgstr "全局模板路径(仅限Unix)"

#~ msgid ""
#~ "The ``unix_global_settings_path`` build variable is meant for Unix/Linux "
#~ "distro packagers who want to package export templates together with "
#~ "godot. It allows to put the export templates on a hardcoded path."
#~ msgstr ""
#~ "``unix_global_settings_path``构建变量适用于想要将导出模板与godot一起打包的"
#~ "Unix / Linux发行版打包程序。 它允许将导出模板放在硬编码路径上。"

#~ msgid ""
#~ "To use it, pass the desired path via the scons "
#~ "``unix_global_settings_path`` build variable when building the editor. "
#~ "The export templates then live at the \"templates\" subdirectory of the "
#~ "path specified."
#~ msgstr ""
#~ "要使用它，在构建编辑器时，通过scons ``unix_global_settings_path`` 构建变量"
#~ "传递所需的路径。 然后，导出模板位于指定路径的“templates”子目录中。"

#~ msgid ""
#~ "Templates installed at the per-user location still override the system "
#~ "wide templates."
#~ msgstr "安装在每个用户位置的模板仍会覆盖系统范围的模板。"

#~ msgid "This option is only available on unix based platforms."
#~ msgstr "此选项仅适用于基于unix的平台。"

#~ msgid "Self contained mode"
#~ msgstr "自包含模式"

#~ msgid ""
#~ "The self contained mode can be used to package Godot for distribution "
#~ "systems where it doesn't live at a fixed location. If the editor finds a "
#~ "``._sc_`` file in the directory the executable is located in, Godot will "
#~ "continue in \"self contained mode\". On Windows, the file name to use is "
#~ "``_sc_`` (without the preceding dot)."
#~ msgstr ""
#~ "自包含模式可用于将Godot打包到不在固定位置的分发系统。 如果编辑器在可执行文"
#~ "件所在的目录中找到 ``._sc_`` 文件，Godot将继续处于“自包含模式”。 在Windows"
#~ "上，要使用的文件名是 ``_sc_`` (没有前面的点)。"

#~ msgid ""
#~ "In self contained mode, all config files are located next to the "
#~ "executable in a directory called ``editor_data``. Godot doesn't read or "
#~ "write to the per-user location anymore."
#~ msgstr ""
#~ "在自包含模式下，所有配置文件都位于名为 ``editor_data`` 的目录中的可执行文"
#~ "件旁边。 Godot不再读取或写入每个用户的位置。"

#~ msgid ""
#~ "The contents of the ``._sc_`` file (when not empty) are read with the "
#~ "ConfigFile api (same format as ``project.godot``, etc). So far it can "
#~ "contain a list of pre-loaded project in this format:"
#~ msgstr ""
#~ "使用ConfigFile api(格式为 ``project.godot`` 等)读取 ``._sc_`` 文件(非空时)"
#~ "的内容。 到目前为止，它可以包含以下格式的预加载项目列表:"

#~ msgid ""
#~ "The paths are relative to the executable location, and will be added to "
#~ "the file ``editor_settings.xml`` when this is created for the first time."
#~ msgstr ""
#~ "路径相对于可执行位置，并且在第一次创建时将添加到文件 ``editor_settings."
#~ "xml`` 中。"

#~ msgid "Project Setup"
#~ msgstr "项目设置"

#~ msgid ""
#~ "Before we translate the documentation, we need to complete and proof-read "
#~ "it in English. We'll work on localization when we get past 90% completion."
#~ msgstr ""
#~ "在我们翻译文档之前，我们需要用英语完成并校对。 当我们达到90％的完成度后，"
#~ "我们将致力于本地化。"

#~ msgid ""
#~ "If you're using C#, you need to restart Godot editor temporarily to see "
#~ "exported variables in the editor until it's fixed."
#~ msgstr ""
#~ "如果你正在使用C#，则需要临时重启Godot编辑器，以便在编辑器中查看导出的变"
#~ "量，直到修复为止。"

#~ msgid "Some examples:"
#~ msgstr "一些例子:"

#~ msgid ""
#~ "`Built-in types <http://docs.godotengine.org/en/3.0/getting_started/"
#~ "scripting/gdscript/gdscript_basics.html#built-in-types>`__"
#~ msgstr ""
#~ "`内置类型 <http://docs.godotengine.org/en/3.0/getting_started/scripting/"
#~ "gdscript/gdscript_basics.html#built-in-types>`__"

#~ msgid "Is SRGB"
#~ msgstr "是SRGB"

#~ msgid "[Windows only] PyWin32 (optional, for parallel compilation)"
#~ msgstr "[仅限Windows] PyWin32（可选，用于并行编译）"

#~ msgid ""
#~ "Android SDK version 23.0.3 [Note: Please install all tools and extras of "
#~ "the SDK Manager]"
#~ msgstr "Android SDK版本23.0.3 [注意：请安装SDK Manager的所有工具和附加功能]"

#~ msgid "Android build tools version 19.1"
#~ msgstr "Android构建工具版本19.1"

#~ msgid "Android NDK r13 or later"
#~ msgstr "Android NDK r13或更高版本"

#~ msgid ""
#~ "JDK 6 or later (either OpenJDK or Oracle JDK) - JDK 9 & 10 do not work "
#~ "with current Gradle."
#~ msgstr ""
#~ "JDK 6或更高版本（OpenJDK或Oracle JDK） - JDK 9和10不适用于当前的Gradle。"

#~ msgid ""
#~ "Set the environment variable ANDROID_HOME to point to the Android SDK."
#~ msgstr "将环境变量ANDROID_HOME设置为指向Android SDK。"

#~ msgid ""
#~ "(on Linux or macOS, execute the `gradlew` script with `./gradlew build`)"
#~ msgstr "（在Linux或macOS上，使用`./gradlew build`执行`gradlew`脚本）"

#~ msgid "The resulting APK is in:"
#~ msgstr "生成的APK位于："

#~ msgid "Faster compilation"
#~ msgstr "编译速度更快"

#~ msgid ""
#~ "If you are on Unix or installed PyWin32 on Windows and have multiple CPU "
#~ "cores available, you can speed up the compilation by adding the ``-jX`` "
#~ "argument to the SCons command, where ``X`` is the number of cores that "
#~ "you want to allocate to the compilation, e.g. ``scons -j4``."
#~ msgstr ""
#~ "如果你在Unix上或在Windows上安装了PyWin32并且有多个CPU内核可用，你可以通过"
#~ "在SCons命令中添加``-jX``参数来加速编译，其中``X``是那个核的数量。 你想分配"
#~ "给编译，例如 ``scons -j4``。"

#~ msgid ""
#~ "This will create a fat binary that works in both platforms, but will add "
#~ "about 6 megabytes to the APK."
#~ msgstr ""
#~ "这将创建一个可在两个平台上运行的胖二进制文件，但会为APK增加大约6兆字节。"

#~ msgid ""
#~ "It might be necessary to clean the build cache between two APK "
#~ "compilations, as some users have reported issues when building the two "
#~ "export templates one after the other."
#~ msgstr ""
#~ "可能有必要清除两个APK编辑之间的构建缓存，因为一些用户在逐个构建两个导出模"
#~ "板时报告了问题。"

#~ msgid "Seek assistance if you can't figure it out."
#~ msgstr "如果你想不通，请寻求帮助。"

#~ msgid "libgodot_android.so is not in ``lib/armeabi-v7a`` or ``lib/armeabi``"
#~ msgstr "libgodot_android.so不在``lib / armeabi-v7a``或``lib / armeabi``中"

#~ msgid "Device does not support armv7 (try compiling yourself for armv6)"
#~ msgstr "设备不支持armv7（尝试为armv6编译自己）"

#~ msgid "Device is Intel, and apk is compiled for ARM."
#~ msgstr "设备是Intel，apk是为ARM编译的。"

#~ msgid "Compilation fails"
#~ msgstr "编译失败"

#~ msgid ""
#~ "On Linux systems with Kernel version 4.3 or newer, compilation may fail "
#~ "with the error \"pthread_create failed: Resource temporarily unavailable."
#~ "\""
#~ msgstr ""
#~ "在内核版本为4.3或更高版本的Linux系统上，编译可能会失败，并显示错"
#~ "误“pthread_create failed：资源暂时不可用。”"

#~ msgid ""
#~ "This is because of a change in the way Linux limits thread creation. But "
#~ "you can change those limits through the command line. Please read this "
#~ "section thoroughly before beginning."
#~ msgstr ""
#~ "这是因为Linux限制线程创建的方式发生了变化。 但您可以通过命令行更改这些限"
#~ "制。 请在开始之前仔细阅读本节内容。"

#~ msgid ""
#~ "First open a terminal, then begin compilation as usual (it may be a good "
#~ "idea to run a --clean first). While compiling enter the following in your "
#~ "terminal:"
#~ msgstr ""
#~ "首先打开一个终端，然后像往常一样开始编译（首先运行--clean可能是个好主"
#~ "意）。 编译时在终端中输入以下内容："

#~ msgid ""
#~ "The output should list a scons process, with its PID as the first number "
#~ "in the output. For example the PID 1077 in the output shown below:"
#~ msgstr ""
#~ "输出应列出scons进程，其PID为输出中的第一个数字。 例如，输出中的PID 1077如"
#~ "下所示："

#~ msgid ""
#~ "Now you can use another command to increase the number of processes that "
#~ "scons is allowed to spawn. You can check its current limits with:"
#~ msgstr ""
#~ "现在，您可以使用另一个命令来增加允许生成scons的进程数。 您可以通过以下方式"
#~ "检查其当前限制:"

#~ msgid "You can increase those limits with the command:"
#~ msgstr "您可以使用以下命令增加这些限制："

#~ msgid ""
#~ "Obviously you should substitute the scons PID output by top and a limits "
#~ "that you think suitable. These are in the form --nproc=soft:hard where "
#~ "soft must be lesser than or equal to hard. See the man page for more "
#~ "information."
#~ msgstr ""
#~ "显然你应该用顶部的scons PID输出和你认为合适的限制来代替。 它们的形式为--"
#~ "nproc = soft：hard，其中soft必须小于或等于hard。 有关更多信息，请参见手册"
#~ "页。"

#~ msgid ""
#~ "If all went well, and you entered the prlimit command while scons was "
#~ "running, then your compilation should continue without the error."
#~ msgstr ""
#~ "如果一切顺利，并且您在scons运行时输入了prlimit命令，那么您的编译应该继续而"
#~ "不会出现错误。"

#~ msgid ""
#~ "We'll be looking at NativeScript 1.0 which is available in Godot 3.0. "
#~ "Godot 3.1 will see the introduction of NativeScript 1.1, which comes with "
#~ "a number of improvements. We'll update this tutorial once it is "
#~ "officially released, but the overall structure remains similar."
#~ msgstr ""
#~ "我们将关注Godot 3.0中提供的NativeScript 1.0。 Godot 3.1将会看到"
#~ "NativeScript 1.1的引入，它带来了许多改进。 我们将在正式发布后更新本教程，"
#~ "但整体结构仍然类似。"

#~ msgid ""
#~ "a copy of the `godot_headers repository <https://github.com/"
#~ "GodotNativeTools/godot_headers>`_,"
#~ msgstr ""
#~ "`godot_headers repository <https://github.com/GodotNativeTools/"
#~ "godot_headers>`_ 的副本，"

#~ msgid ""
#~ "mkdir gdnative_cpp_example cd gdnative_cpp_example git clone --recursive -"
#~ "b 3.0 https://github.com/GodotNativeTools/godot-cpp"
#~ msgstr ""
#~ "mkdir gdnative_cpp_example cd gdnative_cpp_example git clone --recursive -"
#~ "b 3.0 https://github.com/GodotNativeTools/godot-cpp"

#~ msgid ""
#~ "We usually try to keep the Godot Android build code up to date, but "
#~ "Google changes their toolchain versions often, so if compilation fails "
#~ "due to wrong toolchain version, go to your NDK directory and check the "
#~ "current number, then set the following environment variable:"
#~ msgstr ""
#~ "我们通常会尝试更新Godot Android构建代码，但Google经常更改其工具链版本，因"
#~ "此如果由于错误的工具链版本导致编译失败，请转到NDK目录并检查当前编号，然后"
#~ "设置以下环境变量："

#~ msgid ""
#~ "Another reason is that, for distribution, the developer might prefer a "
#~ "specially compiled binary, which is smaller in size, more optimized and "
#~ "does not include tools inside (like the editor, debugger, etc.)."
#~ msgstr ""
#~ "另一个原因是，为了分发，开发人员可能更喜欢一个特别编译的二进制文件，它的大"
#~ "小更小，更优化，并且不包含内部工具（如编辑器，调试器等）。"

#, fuzzy
#~ msgid "There is a few things to note here."
#~ msgstr "Godot没有任何使用限制"

#~ msgid ""
#~ "Note that there are currently `issues <https://github.com/godotengine/"
#~ "godot/issues/5182>`__ with parallel builds for at least some users, so if "
#~ "you are running into errors, try building without the ``-j`` parameter."
#~ msgstr ""
#~ "提示，少数用户执行多核构建任务中会碰到 `这个问题 <https://github.com/"
#~ "godotengine/godot/issues/5182>`__ ， 如果你也刚好遇到这个麻烦，请试着去到 "
#~ "``-j`` 命令进行构建。"

#, fuzzy
#~ msgid "default: no"
#~ msgstr "默认环境"

#, fuzzy
#~ msgid "default: yes"
#~ msgstr "默认功能"

#~ msgid "Mac OS X"
#~ msgstr "Mac OS X"

#~ msgid ""
#~ "C# is usually the best choice for companies. The large amount of "
#~ "programmers familiar with it means less time can be spent learning Godot "
#~ "and more time can be spent programming with it."
#~ msgstr ""
#~ "C#通常是公司的最佳选择，很多程序员熟悉它，可以花更少的时间学习Godot，有了"
#~ "更多时间用它编程。"

#~ msgid "Code Structure"
#~ msgstr "代码结构"

#~ msgid "Nodes:"
#~ msgstr "节点："

#~ msgid ""
#~ "Sería excelente que el mundo hablara solo un idioma. Unfortunately for us "
#~ "developers, that is not the case. While not generally a big requirement "
#~ "when developing indie or niche games, it is also common that games going "
#~ "into a more massive market require localization."
#~ msgstr ""
#~ "Sería excelente que el mundo hablara solo un idioma（西班牙语：\n"
#~ "如果世界只说一种语言，那将是非常好的）。不幸的是, 对于美国开发者来说, 情况"
#~ "并非如此。虽然在开发独立游戏或利基游戏（niche音译，可理解为小众游戏）时通"
#~ "常并不是一个很大的需求, 但是对于正在进入一个更大规模市场的游戏而言，本地化"
#~ "需求也很常见。"

#~ msgid ""
#~ "Godot offers many tools to make this process more straightforward, so "
#~ "this tutorial is more like a collection of tips and tricks."
#~ msgstr ""
#~ "Godot提供了许多工具来使这个过程更加简单, 因此本教程更像是一个提示和技巧的"
#~ "集合。"

#~ msgid ""
#~ "As always, If you don't know the code of a language or zone, :ref:`check "
#~ "the list <doc_locales>`."
#~ msgstr ""
#~ "与往常一样, 如果您不知道语言或区域的代码,:ref:`查看这个列表 "
#~ "<doc_locales>`。"

#~ msgid "For the build system, choose \"custom build system\"."
#~ msgstr "至于构建系统，我们选择 \"自定义构建系统（custom build system）\"。"

#~ msgid ""
#~ "For dynamic memory, the DVector<> template is provided. Use it like this:"
#~ msgstr "对于动态内存分配，可以使用DVector<>模板。就像这样："

#~ msgid ""
#~ "DVector is a standard vector class, it can be accessed using the [] "
#~ "operator, but that's probably slow for large amount of accesses (as it "
#~ "has to lock internally). A few helpers exist for this:"
#~ msgstr ""
#~ "DVector就像标准的vector类，它能通过运算符[]被访问；但是大量读写访问的情况"
#~ "下，那是低效的（因为它内部使用了锁）。这里有使用示例："

#~ msgid ""
#~ "respectively. These allow fast read/write from DVectors and keep it "
#~ "locked until they go out of scope."
#~ msgstr ""
#~ "这样，允许从 DVectors 快速读写并保持锁定状态，直到它们它们超出作用域。"

#~ msgid ""
#~ "Click \"Play Scene\" (``F6``) and confirm you can move the player around "
#~ "the screen in all directions."
#~ msgstr "点击“运行场景”（``F6``）并确认您能够在屏幕中沿任一方向移动玩家。"

#, fuzzy
#~ msgid "Supported Animation"
#~ msgstr "精灵动画"

#, fuzzy
#~ msgid "Placing of AnimationPlayer"
#~ msgstr "动画"

#~ msgid ""
#~ "This means it is free as in \"free speech\" as well as in \"free beer\"."
#~ msgstr "这就是说它是免费的，对，就是“免费的午餐”。"

#~ msgid "There are no usage restrictions on Godot"
#~ msgstr "Godot没有任何使用限制"

#~ msgid ""
#~ "This means you can use it for any game or application, commercially or "
#~ "non-commercially, in any industry"
#~ msgstr "这意味着你可以使用它在任何行业内制作商业或非商业的游戏或应用"

#~ msgid ""
#~ "For more, see `here <https://tldrlegal.com/license/mit-license>`_ or ask "
#~ "your lawyer of choice."
#~ msgstr ""
#~ "有关详细情况, 请参阅 `此处 <https://tldrlegal.com/license/mit-license>`_ "
#~ "或咨询律师。"

#~ msgid ""
#~ "Note that C# and Visual Scripting support is comparatively young and "
#~ "GDScript still has some advantages as outlined below."
#~ msgstr ""
#~ "注意C#和可视化脚本支持还相对不完善，GDScript仍然有优势，下面会提到。"

#~ msgid ""
#~ "Support for new languages can be added by third parties using the "
#~ "GDNative / NativeScript / PluginScript facilities. (See question about "
#~ "plugins below.)"
#~ msgstr ""
#~ "可以使用GDNative / NativeScript / PluginScript工具添加对新语言的支持。（请"
#~ "参阅下面关于插件的问题。）"

#~ msgid ""
#~ "GDScript? Why use a custom scripting language instead of my language of "
#~ "choice?"
#~ msgstr "GDScript？为什么使用自定义脚本语言而不是我选择的现有语言？"

#~ msgid ""
#~ "GDScript is designed to integrate from the ground to the way Godot works, "
#~ "more than any other language, and is simple and easy to learn. Takes at "
#~ "most a day or two to get comfortable and it's easy to see the benefits "
#~ "once you do. Please make the effort to learn GDScript, you will not "
#~ "regret it."
#~ msgstr ""
#~ "GDScript是为了从底层整合Godot的工作方式而诞生的，这方面它比任何其他语言都"
#~ "更加契合引擎，并且简单易学。最多只需一两天就可以舒适的使用它，一旦你那样做"
#~ "了，很容易便会看到它的优势。请花些功夫学习GDScript，你不会后悔的。"

#~ msgid ""
#~ "Godot C++ API is also efficient and easy to use (the entire Godot editor "
#~ "is made with this API), and an excellent tool to optimize parts of a "
#~ "project, but trying to use it instead of GDScript for an entire game is, "
#~ "in most cases, a waste of time."
#~ msgstr ""
#~ "Godot C ++ API也是高效易用的（整个Godot编辑器就是用这个API编写的），并且是"
#~ "优化项目性能的优秀工具，但是在整个游戏中使用它代替GDScript，在大多数情况下"
#~ "都是浪费时间。"

#~ msgid ""
#~ "Yes, for more than a decade we tried in the past integrating several VMs "
#~ "(and even shipped games using them), such as Python, Squirrel and Lua (in "
#~ "fact we authored tolua++ in the past, one of the most popular C++ "
#~ "binders). None of them worked as well as GDScript does now."
#~ msgstr ""
#~ "是的，我们十多年来尝试整合了几种虚拟机（甚至用它们发行游戏），比如Python，"
#~ "Squirrel和Lua（事实上我们曾参与开发过tolua++，最流行的C++绑定器之一）。但"
#~ "他们都没有像GDScript现在这样好。"

#~ msgid "For the more technically versed, proceed to the next item."
#~ msgstr "有关技术上的解释，请看下一项。"

#~ msgid ""
#~ "I don't believe you. What are the technical reasons for the item above?"
#~ msgstr "我不信。上面所说的技术原因呢？"

#~ msgid "The main reasons are:"
#~ msgstr "主要原因："

#~ msgid ""
#~ "GDScript was designed to solve the issues above, and performs well in all "
#~ "the above scenarios. Please learn GDScript and enjoy a smooth integration "
#~ "of scripting with the game engine (yes, it's a rare but enjoyable "
#~ "situation when things just work). It's worth it, give it a try!"
#~ msgstr ""
#~ "GDScript旨在解决上述问题，并且表现良好。请学习GDScript并享受GDScript和游戏"
#~ "引擎的平滑集成（是的，虽然听上去不可能但真的很爽）。这是值得的，试一试吧！"

#~ msgid "I want to extend Godot. What are my options for creating plugins?"
#~ msgstr "我想扩展Godot引擎。有什么开发插件的选项吗？"

#~ msgid ""
#~ "Additional languages could be added via PluginScript or the more low-"
#~ "level NativeScript."
#~ msgstr "其它语言的插件可以通过PluginScript或更底层的NativeScript添加。"

#~ msgid ""
#~ "If you want to add a certain native library, your best bet is GDNative "
#~ "and custom C++ modules."
#~ msgstr "如果你想添加一个本地库，最好的选择是使用GDNative或定制C++模块。"

#~ msgid "Why is FBX not supported for import?"
#~ msgstr "为什么不支持导入FBX？"

#~ msgid ""
#~ "That said, Godot's Collada support is good, please use the `OpenCollada "
#~ "<https://github.com/KhronosGroup/OpenCOLLADA/wiki/OpenCOLLADA-Tools>`_ "
#~ "exporter for maximum compatibility if you are using Maya or 3DS Max. If "
#~ "you are using Blender, take a look at our own `Better Collada Exporter "
#~ "<https://godotengine.org/download>`_."
#~ msgstr ""
#~ "即便如此，Godot对Collada的支持非常好，如果您在用Maya或3DS Max，请使用 "
#~ "`OpenCollada <https://github.com/KhronosGroup/OpenCOLLADA/wiki/"
#~ "OpenCOLLADA-Tools>`_ 导出，以便得到最大程度地兼容。如果您使用的是Blender，"
#~ "可以用我们的 `Better Collada Exporter <https://godotengine.org/"
#~ "download>`_。"

#~ msgid "Also, glTF support was added in Godot 3.0."
#~ msgstr "另外，Godot在3.0加入了glTF支持。"

#~ msgid ""
#~ "FBX support could still be provided by third parties as a plugin. (See "
#~ "Plugins question above.)"
#~ msgstr "FBX支持仍然可以由第三方以插件形式提供。（请参阅上面插件相关问题。）"

#~ msgid ""
#~ "No, the aim of Godot is to create a complete open source engine licensed "
#~ "under MIT, so you have complete control over every single piece of it. "
#~ "Open versions of functionality or features from such SDKs may be "
#~ "eventually added though."
#~ msgstr ""
#~ "不行，Godot的目标是创建一个基于MIT许可的完全开源引擎，以便于完全控制它的每"
#~ "一块。不过这些SDK的功能或其开放版本最终有可能会添加进来。"

#~ msgid "I have a great idea that will make Godot better. What do you think?"
#~ msgstr "我有一个好想法能让Godot变得更好！你觉得呢？"

#~ msgid ""
#~ "Your idea will most certainly be ignored. Examples of stuff that is "
#~ "ignored by the developers:"
#~ msgstr "你的想法基本会被忽视。开发者们会无视下面的例子："

#~ msgid "Let's do this because it will make Godot better"
#~ msgstr "大家来做吧！它会让Godot变得更好"

#~ msgid "Let's do this in Godot because another game engine does it"
#~ msgstr "大家来实现这个吧！其它游戏引擎就是这么做的"

#~ msgid "Let's remove this because I think it's not needed"
#~ msgstr "删掉这个功能！因为我觉得它没什么用"

#~ msgid "Let's remove clutter and bloat and make Godot look nicer"
#~ msgstr "把这些乱七八糟的东西取消吧！这样Godot看起来会更好点"

#~ msgid "Let's add an alternative workflow for people who prefer it"
#~ msgstr "来确立新的开发流程吧！有的人会很喜欢"

#~ msgid ""
#~ "Godot developers are always willing to talk to you and listen to your "
#~ "feedback very openly, to an extent rarely seen in open source projects, "
#~ "but they will care mostly about real issues you have while using Godot, "
#~ "not ideas solely based on personal belief. Developers are interested in "
#~ "(for example):"
#~ msgstr ""
#~ "Godot开发人员总是愿意与您交流并且非常开放地倾听您的反馈意见，这在开源项目"
#~ "中很罕见，但他们将主要关注您在使用Godot时遇到的实际问题，而不是仅基于个人"
#~ "的想法。开发人员会感兴趣的（例如）："

#~ msgid ""
#~ "Once one of the above points is stated, we can work together on a "
#~ "solution and this is where your ideas and suggestions are most valuable "
#~ "and welcome, they need to be in context of a real issue."
#~ msgstr ""
#~ "只要提出上述内容之一，我们就可以一起解决问题，这就是您的想法和建议最有价值"
#~ "和最受欢迎的地方，它们才是正式的问题。"

#~ msgid "Examples of how NOT to state problems generally and vaguely are:"
#~ msgstr "不要像这样普通地和模糊地陈述问题："

#~ msgid "Certain feature is ugly"
#~ msgstr "某些功能很糟糕"

#~ msgid "Certain workflow is slow"
#~ msgstr "某些工作流程很慢"

#~ msgid "Certain feature needs optimization"
#~ msgstr "某些功能需要优化"

#~ msgid "Certain aspect of the UI looks cluttered"
#~ msgstr "UI的某些地方看起来很乱"

#~ msgid ""
#~ "Associating something with an adjective will not get you much attention "
#~ "and developers will most likely not understand you. Instead, try to "
#~ "reformulate your problem as a story such as:"
#~ msgstr ""
#~ "将某些东西与形容词联系起来并不会引人注意，开发者们也很可能不会理解。相反，"
#~ "尝试将您的问题作为例子重新表达，例如："

#~ msgid "I try to move objects around but always end up picking the wrong one"
#~ msgstr "我尝试移动物件，但总是选错了一个"

#~ msgid ""
#~ "I tried to make a game like Battlefield but I'm not managing to "
#~ "understand how to get lighting to look the same."
#~ msgstr ""
#~ "我试图做像战地这样的游戏，但我并没有理解清楚如何让灯光看起来一模一样。"

#~ msgid ""
#~ "I always forget which script I was editing, and it takes me too many "
#~ "steps to go back to it."
#~ msgstr "我老是忘记我正编辑的是哪个脚本，而且我要花太多的步骤才能找到它。"

#~ msgid ""
#~ "This will allow you to convey what you are thinking much better and set a "
#~ "common ground for discussion. Please try your best to state your problems "
#~ "as stories to the developers and the community, before discussing any "
#~ "idea. Be specific and concrete."
#~ msgstr ""
#~ "这将使你能够更好地表达你的想法，并为讨论建立一个共同点。在讨论任何想法之"
#~ "前，请尽量将您的问题作为例子向开发人员和社区说明，具体而形象。"

#, fuzzy
#~ msgid "Export Templates"
#~ msgstr "导出模板"

#~ msgid "Platform bits (64/32)."
#~ msgstr "平台位数 (64/32)。"

#~ msgid "Running on X11"
#~ msgstr "在 X11 上运行"

#, fuzzy
#~ msgid "Node Path"
#~ msgstr "NodePath"

#~ msgid ""
#~ "As always, ``godot`` refers to the compiled Godot binary, so if it isn't "
#~ "in your PATH, you need to give the full path to the executable, e.g. if "
#~ "it is located in the ``bin`` subfolder, it becomes ``bin/godot``."
#~ msgstr ""
#~ "这里的 ``godot`` 指的是编译好的 Godot 二进制文件。 因此如果它不在你系统的 "
#~ "PATH 变量中的话，你需要替换成你的可执行文件的绝对路径。 例如，在 ``bin``子"
#~ "目录中， 它就是 ``bin/godot``。"

#~ msgid ""
#~ "However, what it does is not completely obvious. When running on PC, the "
#~ "engine will attempt to set this resolution (or use something smaller if "
#~ "it fails). On mobile, consoles or devices with a fixed resolution or full "
#~ "screen rendering, this resolution will be ignored and the native "
#~ "resolution will be used instead. To compensate for this, Godot offers "
#~ "many ways to control how the screen will resize and stretch to different "
#~ "screen sizes."
#~ msgstr ""
#~ "然而, 这个设置所做的具体事情并不完全显而易见。比如在 PC 上运行时, 引擎将尝"
#~ "试设置成此分辨率 (如果失败则使用更小的尺寸)。但在移动端、游戏主机或其他具"
#~ "有固定分辨率或全屏渲染的设备上时, 此分辨率将被忽略, 取而代之使用设备的本机"
#~ "分辨率。作为这个设置分辨率功能的补充, Godot提供了许多方法来控制屏幕尺寸的"
#~ "调整方式和拉伸到不同的屏幕大小时的方式。"

#~ msgid ""
#~ "**Disabled**: The first is the stretch mode. By default this is disabled, "
#~ "which means no stretching happens (the bigger the screen or window, the "
#~ "bigger the resolution, always matching pixels 1:1)."
#~ msgstr ""
#~ "** Disabled **: 这是我们的第一个拉伸模式。默认情况下, 拉伸模式就是被禁用"
#~ "的，这意味着不发生任何拉伸（屏幕或窗口越大, 分辨率就越大, 总是匹配像素 "
#~ "1:1）。"

#~ msgid ""
#~ "**Keep Width**: Keep aspect ratio when stretching the screen, but if the "
#~ "resulting screen is taller than the specified resolution, it will be "
#~ "stretched vertically (and more vertical resolution will be reported in "
#~ "the viewport, proportionally). This is usually the best option for "
#~ "creating GUIs or HUDs that scale, so some controls can be anchored to the "
#~ "bottom (:ref:`doc_size_and_anchors`)."
#~ msgstr ""
#~ "** Keep Width **: 拉伸屏幕时保持纵横比, 但如果最终屏幕高度比指定分辨率更"
#~ "高, 则垂直拉伸 (在viewport中按比例显示更多垂直分辨率)。这通常是创建可缩放"
#~ "的 GUI 或 HUD 的最佳选项, 因此某些控件就可以锚定到底部了 (见文章:ref:"
#~ "`doc_size_and_anchors`)。"

#~ msgid ""
#~ "**Keep Height**: Keep aspect ratio when stretching the screen, but if the "
#~ "resulting screen is wider than the specified resolution, it will be "
#~ "stretched horizontally (and more horizontal resolution will be reported "
#~ "in the viewport, proportionally). This is usually the best option for 2D "
#~ "games that scroll horizontally (like runners or platformers)."
#~ msgstr ""
#~ "** Keep Height **: 拉伸屏幕时保持纵横比, 但如果最终屏幕宽度比指定分辨率更"
#~ "宽, 则将水平拉伸 (按比例显示更多水平分辨率)。对于2D横板滚轴游戏来说, 这通"
#~ "常是最好的选择 (如跑酷类和平台跳跃类游戏)。"

#~ msgid ""
#~ "It is a free, open source IDE (Integrated Development Environment) for "
#~ "Linux, Solaris, FreeBSD, Mac OS X and other Unix flavors."
#~ msgstr ""
#~ "这是一款免费并开源的IDE （Integrated Development Environment）， 你可以"
#~ "在  Linux, Solaris, FreeBSD, Mac OS X 和其他类 Unix 平台上使用它。"

#~ msgid "Type ``scons`` in the *Command* field."
#~ msgstr "在 *命令(Command)* 栏键入 ``scons``。"

#, fuzzy
#~ msgid "Adding AI"
#~ msgstr "填充"

#, fuzzy
#~ msgid "Adding Input support"
#~ msgstr "添加脚本"

#~ msgid ""
#~ "Godot has a small but useful feature called viewports. Viewports are, as "
#~ "the name implies, rectangles where the world is drawn. They have three "
#~ "main uses, but can flexibly adapted to a lot more. All this is done via "
#~ "the :ref:`Viewport <class_Viewport>` node."
#~ msgstr ""
#~ "Godot有一个很小但有用的功能称为视区。顾名思义, 视区是绘制世界的长方形。他"
#~ "们有三主要用途, 但能灵活地适应更多目的。所有这一切都是通过:ref:`Viewport "
#~ "<class_Viewport>` 节点完成的。"

#~ msgid ""
#~ "**Scene Root**: The root of the active scene is always a Viewport. This "
#~ "is what displays the scenes created by the user. (You should know this by "
#~ "having read previous tutorials!)"
#~ msgstr ""
#~ "** 场景的根 **: 场景的根节点始终是视区。这用来显示用户创建的场景的内容。"
#~ "(通过阅读以前的教程您应该知晓这一点!）"

#~ msgid ""
#~ "**Sub-Viewports**: These can be created when a Viewport is a child of a :"
#~ "ref:`Control <class_Control>`."
#~ msgstr ""
#~ "** 子视区 **: 当视区为 :ref:`Control <class_Control>` 的子节点时, 子视区就"
#~ "会被创建出来。"

#~ msgid ""
#~ "**Render Targets**: Viewports can be set to \"RenderTarget\" mode. This "
#~ "means that the viewport is not directly visible, but its contents can be "
#~ "accessed via a :ref:`Texture <class_Texture>`."
#~ msgstr ""
#~ "** 渲染目标 **: 视区可以设置为 \"RenderTarget\" （渲染目标）模式。这意味着"
#~ "视区不是直接可见的, 但它的内容可以通过:ref:`Texture <class_Texture>`来访"
#~ "问。"

#~ msgid "Viewport"
#~ msgstr "Viewport"

#~ msgid ""
#~ "Camera will display on the parent viewport, but in the following one:"
#~ msgstr "摄像机将显示其父视区, 但在下面的层次结构中:"

#~ msgid ""
#~ "It will not (or may display in the root viewport if this is a subscene)."
#~ msgstr "它不会 (或者显示其根视区如果这是一个子场景的话)。"

#~ msgid ""
#~ "Viewports have a \"rect\" property. X and Y are often not used (only the "
#~ "root viewport uses them), while WIDTH AND HEIGHT represent the size of "
#~ "the viewport in pixels. For Sub-Viewports, these values are overridden by "
#~ "the ones from the parent control, but for render targets this sets their "
#~ "resolution."
#~ msgstr ""
#~ "视区有一个 \"rect\" 属性。通常不使用 X 和 Y (只有根视区使用它们), 而是"
#~ "用“宽度”和“高度”表示视区的大小 (以像素为单位)。对于“子视区”而言, 这些值是"
#~ "由其某个父控件的对应属性所覆写的, 但对于“渲染目标”而言, 这两个属性会确定它"
#~ "的分辨率。"

#~ msgid ""
#~ "The root viewport uses this for the stretch options in the project "
#~ "settings."
#~ msgstr "“根视区”用这些语句设定项目设置中的拉伸选项。"

#~ msgid ""
#~ "If the returned image is empty, capture still didn't happen, wait a "
#~ "little more, as this API is asynchronous."
#~ msgstr ""
#~ "如果你发现返回的图像为空, 则说明捕获截图的行为仍未发生, 请稍微多等一会, 因"
#~ "为这个 API 是异步的。"

#~ msgid "Sub-viewport"
#~ msgstr "子视区"

#~ msgid "``TODO: Review the doc, change outdated and add more images.``"
#~ msgstr "``TODO: 审阅文档, 更改过期内容并添加更多图片。``"

#~ msgid "That alone makes for an empty Godot project."
#~ msgstr "这仅仅创建了一个空的 Godot 项目。"

#~ msgid ""
#~ "As you see, it's really easy to develop Godot in C++. Just write your "
#~ "stuff normally and remember to:"
#~ msgstr ""
#~ "如你所见， 使用 C++ 进行Godot开发如此简单。只需要按照你往常那样编写你的模"
#~ "块代码， 同时需要记住这几点就可以了："

#~ msgid "**Never!**"
#~ msgstr "**绝对不要这样做**"
