# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2021, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-11-04 16:27+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../docs/getting_started/editor/unity_to_godot.rst:8
msgid "From Unity to Godot Engine"
msgstr "从 Unity 迁移到 Godot 引擎"

#: ../../docs/getting_started/editor/unity_to_godot.rst:10
msgid ""
"This guide provides an overview of Godot Engine from the viewpoint of a "
"Unity user, and aims to help you migrate your existing Unity experience into "
"the world of Godot."
msgstr ""
"本指南从Unity用户的角度概述了Godot引擎, 旨在帮助你将现有的Unity体验迁移到"
"Godot的世界中."

#: ../../docs/getting_started/editor/unity_to_godot.rst:15
msgid ""
"This article talks about older versions of Unity. Nestable prefabs ('Nested "
"prefabs') were added to Unity 2018.3. Nestable prefabs are analogous to "
"Godot's scenes, and allow a more Godot-like approach to scene organization."
msgstr ""
"本文讨论了旧版本的Unity. 可嵌套的预制件( ``嵌套的预制件(Nested prefabs)`` )已"
"添加到Unity 2018.3中. 可嵌套的预制件类似于Godot的场景, 允许采用更像Godot的方"
"式进行场景组织."

#: ../../docs/getting_started/editor/unity_to_godot.rst:18
msgid "Differences"
msgstr "差异"

#: ../../docs/getting_started/editor/unity_to_godot.rst:21
msgid "Unity"
msgstr "Unity"

#: ../../docs/getting_started/editor/unity_to_godot.rst:21
msgid "Godot"
msgstr "Godot"

#: ../../docs/getting_started/editor/unity_to_godot.rst:23
msgid "License"
msgstr "许可证"

#: ../../docs/getting_started/editor/unity_to_godot.rst:23
msgid ""
"Proprietary, closed, free license with revenue caps and usage restrictions"
msgstr "专有, 封闭, 有收入上限和使用限制的免费许可证"

#: ../../docs/getting_started/editor/unity_to_godot.rst:23
msgid "MIT license, free and fully open source without any restriction"
msgstr "MIT许可证, 免费, 完全开源, 没有任何限制"

#: ../../docs/getting_started/editor/unity_to_godot.rst:25
msgid "OS (editor)"
msgstr "操作系统(编辑器)"

#: ../../docs/getting_started/editor/unity_to_godot.rst:25
msgid "Windows, macOS, Linux"
msgstr "Windows, macOS, Linux"

#: ../../docs/getting_started/editor/unity_to_godot.rst:25
msgid "Windows, macOS, X11 (Linux, \\*BSD)"
msgstr "Windows, macOS, X11(Linux, \\*BSD)"

#: ../../docs/getting_started/editor/unity_to_godot.rst:27
msgid "OS (export)"
msgstr "操作系统 (导出)"

#: ../../docs/getting_started/editor/unity_to_godot.rst:27
msgid "**Desktop:** Windows, macOS, Linux"
msgstr "**桌面端:** Windows, macOS, Linux"

#: ../../docs/getting_started/editor/unity_to_godot.rst:28
msgid "**Mobile:** Android, iOS, Windows Phone, Tizen"
msgstr "**移动端:** Android, iOS, Windows Phone, Tizen"

#: ../../docs/getting_started/editor/unity_to_godot.rst:29
msgid "**Web:** WebAssembly or asm.js"
msgstr "**网页:** WebAssembly 或 asm.js"

#: ../../docs/getting_started/editor/unity_to_godot.rst:30
msgid "**Consoles:** PS4, PS Vita, Xbox One, Xbox 360, Wii U, Nintendo 3DS"
msgstr "**游戏主机:** PS4, PS Vita, Xbox One, Xbox 360, Wii U, Nintendo 3DS"

#: ../../docs/getting_started/editor/unity_to_godot.rst:31
msgid ""
"**VR:** Oculus Rift, SteamVR, Google Cardboard, PlayStation VR, Gear VR, "
"HoloLens"
msgstr ""
"**虚拟现实(VR):** Oculus Rift, SteamVR, Google Cardboard, Playstation VR, "
"Gear VR, HoloLens"

#: ../../docs/getting_started/editor/unity_to_godot.rst:32
msgid "**TV:** Android TV, Samsung SMART TV, tvOS"
msgstr "**电视端:** Android TV, Samsung SMART TV, tvOS"

#: ../../docs/getting_started/editor/unity_to_godot.rst:27
msgid "**Desktop:** Windows, macOS, X11"
msgstr "**桌面端:** Windows, macOS, X11"

#: ../../docs/getting_started/editor/unity_to_godot.rst:28
msgid "**Mobile:** Android, iOS"
msgstr "**移动端:** Android, iOS"

#: ../../docs/getting_started/editor/unity_to_godot.rst:29
msgid "**Web:** WebAssembly"
msgstr "**网页:** WebAssembly"

#: ../../docs/getting_started/editor/unity_to_godot.rst:30
msgid "**Console:** See :ref:`doc_consoles`"
msgstr "**游戏主机:** 见 :ref:`doc_consoles`"

#: ../../docs/getting_started/editor/unity_to_godot.rst:31
msgid "**VR:** Oculus Rift, SteamVR"
msgstr "**虚拟现实端:** Oculus Rift, SteamVR"

#: ../../docs/getting_started/editor/unity_to_godot.rst:34
msgid "Scene system"
msgstr "场景系统"

#: ../../docs/getting_started/editor/unity_to_godot.rst:34
msgid "Component/Scene (GameObject > Component)"
msgstr "组件/场景 (游戏物体(GameObject) > 组件(Component))"

#: ../../docs/getting_started/editor/unity_to_godot.rst:35
msgid "Prefabs"
msgstr "预制体"

#: ../../docs/getting_started/editor/unity_to_godot.rst:34
msgid ""
":ref:`Scene tree and nodes <doc_scenes_and_nodes>`, allowing scenes to be "
"nested and/or inherit other scenes"
msgstr ""
":ref:`场景树和节点 <doc_scenes_and_nodes>`, 允许场景被嵌套和/或继承其他场景"

#: ../../docs/getting_started/editor/unity_to_godot.rst:37
msgid "Third-party tools"
msgstr "第三方工具"

#: ../../docs/getting_started/editor/unity_to_godot.rst:37
msgid "Visual Studio or VS Code"
msgstr "Visual Studio 或 VS Code"

#: ../../docs/getting_started/editor/unity_to_godot.rst:37
msgid ":ref:`External editors are possible <doc_external_editor>`"
msgstr ":ref:`可使用外部编辑器 <doc_external_editor>`"

#: ../../docs/getting_started/editor/unity_to_godot.rst:38
msgid ":ref:`Android SDK for Android export <doc_exporting_for_android>`"
msgstr ":ref:`用于导出安卓平台的 Android SDK <doc_exporting_for_android>`"

#: ../../docs/getting_started/editor/unity_to_godot.rst:40
msgid "Notable advantages"
msgstr "显著优势"

#: ../../docs/getting_started/editor/unity_to_godot.rst:40
msgid "Huge community"
msgstr "庞大的社区"

#: ../../docs/getting_started/editor/unity_to_godot.rst:41
msgid "Large assets store"
msgstr "丰富的素材商店"

#: ../../docs/getting_started/editor/unity_to_godot.rst:40
msgid "Scene System"
msgstr "场景系统"

#: ../../docs/getting_started/editor/unity_to_godot.rst:41
msgid ":ref:`Animation Pipeline <doc_animations>`"
msgstr ":ref:`动画管线 <doc_animations>`"

#: ../../docs/getting_started/editor/unity_to_godot.rst:42
msgid ":ref:`Easy to write Shaders <doc_shading_language>`"
msgstr ":ref:`易于编写着色器 <doc_shading_language>`"

#: ../../docs/getting_started/editor/unity_to_godot.rst:43
msgid "Debug on Device"
msgstr "在设备上排错"

#: ../../docs/getting_started/editor/unity_to_godot.rst:50
msgid "The editor"
msgstr "编辑器"

#: ../../docs/getting_started/editor/unity_to_godot.rst:52
msgid ""
"Godot Engine provides a rich-featured editor that allows you to build your "
"games. The pictures below display the default layouts of both editors with "
"colored blocks to indicate common functionalities."
msgstr ""
"Godot引擎提供了功能丰富的编辑器, 可让您构建游戏. 下图显示了两个编辑器的默认布"
"局, 并带有彩色块, 以指示常用功能."

#: ../../docs/getting_started/editor/unity_to_godot.rst:58
msgid ""
"While both editors may seem similar, there are many differences below the "
"surface. Both let you organize the project using the filesystem, but Godot's "
"approach is simpler with a single configuration file, minimalist text "
"format, and no metadata. This makes Godot more friendly to VCS systems, such "
"as Git, Subversion, or Mercurial."
msgstr ""
"尽管两个编辑器看起来很相似, 但外表下有许多差异. 两者都允许您使用文件系统来组"
"织项目, 但是Godot的方法更简单, 只需一个配置文件, 简约的文本格式且没有元数据. "
"这使Godot对VCS系统(如Git,Subversion或Mercurial)更加友好."

#: ../../docs/getting_started/editor/unity_to_godot.rst:63
msgid ""
"Godot's Scene panel is similar to Unity's Hierarchy panel but, as each node "
"has a specific function, the approach used by Godot is more visually "
"descriptive. It's easier to understand what a scene does at a glance."
msgstr ""
"Godot的场景面板与Unity的层次结构面板类似, 但是由于每个节点都有特定的功能, 因"
"此Godot所使用的方法更具视觉描述性. 一目了然地了解场景干什么."

#: ../../docs/getting_started/editor/unity_to_godot.rst:67
msgid ""
"The Inspector in Godot is more minimal, it shows only properties. Thanks to "
"this, objects can expose more useful parameters to the user without having "
"to hide functionality in language APIs. As a plus, Godot allows animating "
"any of those properties visually. Changing colors, textures, enumerations, "
"or even links to resources in real-time is possible without needing to write "
"code."
msgstr ""
"Godot 的属性检查器更为简单, 它仅显示属性. 得益于此, 对象可以向用户暴露大量有"
"用的参数, 而无需把功能隐藏在语言 API 中. 另外,Godot允许可视化地动画化这些属"
"性. 无需编写代码就可以实时更改颜色, 纹理, 枚举, 甚至是资源链接."

#: ../../docs/getting_started/editor/unity_to_godot.rst:72
msgid ""
"The Toolbar at the top of the screen is similar in both editors, offering "
"control over project playback. Projects in Godot run in a separate window, "
"rather than inside the editor (but the tree and objects can still be "
"explored in the debugger window)."
msgstr ""
"屏幕顶部的工具栏在两个编辑器中都相似, 提供对项目运行的控制.Godot中的项目在单"
"独的窗口中运行, 而不是在编辑器中运行(但是仍然可以在调试器窗口中浏览树和对象)."

#: ../../docs/getting_started/editor/unity_to_godot.rst:76
msgid "This approach has several advantages:"
msgstr "这一方法有着如下优点:"

#: ../../docs/getting_started/editor/unity_to_godot.rst:78
msgid ""
"Running the project and closing it is fast (Unity has to save, run the "
"project, close the project, and then reload the previous state)."
msgstr ""
"运行项目以及关闭它的速度很快(Unity必须保存, 运行项目, 关闭项目, 然后重新加载"
"先前的状态)."

#: ../../docs/getting_started/editor/unity_to_godot.rst:79
msgid ""
"Live editing is a lot more useful because changes done to the editor take "
"effect immediately in the game and are not lost (nor have to be synced) when "
"the game is closed. This allows fantastic workflows, like creating levels "
"while you play them."
msgstr ""
"实时编辑更为有用, 因为对编辑器所做的更改会在游戏中立即生效, 并且在游戏关闭时"
"不会丢失(也不必同步). 这样允许出色的工作流程, 例如在运行游戏时创建关卡."

#: ../../docs/getting_started/editor/unity_to_godot.rst:80
msgid "The editor is more stable because the game runs in a separate process."
msgstr "编辑器更稳定, 因为游戏在单独的进程中运行."

#: ../../docs/getting_started/editor/unity_to_godot.rst:81
msgid ""
"The running game can be explored from different angles by toggling the "
"\"Camera Override\" button in the editor viewport, which will switch between "
"using the editor view and the game camera view."
msgstr ""
"通过在编辑器视窗中切换 \"摄影机替代\" 按钮, 可以从不同角度浏览正在运行的游"
"戏, 该按钮将在使用编辑器视图和游戏摄影机视图之间进行切换."

#: ../../docs/getting_started/editor/unity_to_godot.rst:83
msgid ""
"Finally, Godot's top toolbar includes a menu for remote debugging. These "
"options allow deployment to a device (connected phone, tablet, or browser "
"via HTML5), and debugging/live editing on it after the game is exported."
msgstr ""
"最后,Godot的顶部工具栏包括一个用于远程调试的菜单. 这些选项允许将设备部署到设"
"备(通过HTML5连接的手机, 平板电脑, 或浏览器), 并在导出游戏后对其进行调试/实时"
"编辑."

#: ../../docs/getting_started/editor/unity_to_godot.rst:88
msgid "The scene system"
msgstr "场景系统"

#: ../../docs/getting_started/editor/unity_to_godot.rst:90
msgid ""
"This is the most important difference between Unity and Godot and the "
"favorite feature of most Godot users."
msgstr "这是Unity和Godot之间的最重要区别, 也是大多数Godot用户最喜欢的功能."

#: ../../docs/getting_started/editor/unity_to_godot.rst:92
msgid ""
"Working on a 'level' in Unity usually means embedding all the required "
"assets in a scene and linking them together with components and scripts."
msgstr ""
"在Unity中一个 ``关卡`` 上工作通常意味着将所有必需的素材嵌入场景中, 并将它们与"
"组件和脚本链接在一起."

#: ../../docs/getting_started/editor/unity_to_godot.rst:95
msgid ""
"Godot's scene system is superficially similar to Unity. A 'level' consists "
"of a collection of nodes, each with its own purpose: Sprite, Mesh, Light, "
"etc. However, in Godot the nodes are arranged in a tree. Each node can have "
"multiple children, which makes each a subscene of the main scene. This means "
"you can compose a whole scene with different scenes stored in different "
"files."
msgstr ""
"Godot的场景系统表面上类似于Unity. 一个 ``关卡`` 由一组节点组成, 每个节点都有"
"其自己的用途:Sprite, Mesh, Light等. 但是, 在Godot中, 节点排列在一棵树中. 每个"
"节点可以有多个子代, 这使得每个子代都是主场景的一个子场景. 这意味着您可以用存"
"储在不同文件中的不同场景组合成整个场景."

#: ../../docs/getting_started/editor/unity_to_godot.rst:98
msgid ""
"For example, think of a platformer level. You would compose it with multiple "
"elements:"
msgstr "例如, 一个平台游戏的关卡. 你可以用多个元素来组合它:"

#: ../../docs/getting_started/editor/unity_to_godot.rst:100
msgid "Bricks"
msgstr "砖块"

#: ../../docs/getting_started/editor/unity_to_godot.rst:101
msgid "Coins"
msgstr "金币"

#: ../../docs/getting_started/editor/unity_to_godot.rst:102
msgid "The player"
msgstr "游戏角色"

#: ../../docs/getting_started/editor/unity_to_godot.rst:103
msgid "The enemies"
msgstr "敌人"

#: ../../docs/getting_started/editor/unity_to_godot.rst:105
msgid ""
"In Unity, you would put all the GameObjects in the scene: the player, "
"multiple instances of enemies, bricks everywhere to form the ground of the "
"level and then multiple instances of coins all over the level. You would "
"then add various components to each element to link them and add logic in "
"the level: For example, you'd add a BoxCollider2D to all the elements of the "
"scene so that they can collide. This principle is different in Godot."
msgstr ""
"在Unity中, 您将所有游戏对象(GameObjects)放置在场景中: 游戏角色, 敌人的多个实"
"例, 到处都是用砖块构成关卡的地面, 然后在关卡中放置的硬币的多个实例. 然后, 您"
"将向每个元素添加各种组件以链接它们并在关卡中添加逻辑: 例如, 您将 "
"``BoxCollider2D`` 添加到场景的所有元素, 以便它们可以碰撞. 这一理念在Godot中不"
"同."

#: ../../docs/getting_started/editor/unity_to_godot.rst:110
msgid ""
"In Godot, you would split your whole scene into three separate, smaller "
"scenes, and instance them in the main scene."
msgstr ""
"在Godot中, 您将整个场景分为三个单独的较小的场景, 并在主场景中对其进行实例化."

#: ../../docs/getting_started/editor/unity_to_godot.rst:112
msgid "**A scene for the Player alone.**"
msgstr "**仅用于游戏角色(Player)的场景.**"

#: ../../docs/getting_started/editor/unity_to_godot.rst:114
msgid ""
"Consider the player as an element we'd like to use in different parent "
"scenes (for instance 'level' scenes). In our case, the player element needs "
"at least an AnimatedSprite node. This node contains the sprite textures "
"necessary for various animations (for example, a walking animation)."
msgstr ""
"将游戏角色视为我们要在不同父场景(例如 ``关卡`` 场景)中使用的元素. 在我们的例"
"子中, 游戏角色元素至少需要一个 ``AnimatedSprite`` 节点. 该节点包含各种动画(例"
"如, 行走动画)所需的精灵纹理."

#: ../../docs/getting_started/editor/unity_to_godot.rst:116
msgid "**A scene for the Enemy.**"
msgstr "**一个用于敌人的场景.**"

#: ../../docs/getting_started/editor/unity_to_godot.rst:118
msgid ""
"An enemy is also an element we'd like to use in several scenes. It's almost "
"the same as the Player node. The only differences are the script (it needs "
"'AI' routines to generate the enemy's behavior) and the sprite textures used "
"by the AnimatedSprite node."
msgstr ""
"敌人也是我们想在多个场景中使用的元素. 它与 ``Player`` 节点几乎相同. 唯一的区"
"别是脚本(需要 ``AI`` 程序来生成敌人的行为)和 ``AnimatedSprite`` 节点使用的精"
"灵纹理不同."

#: ../../docs/getting_started/editor/unity_to_godot.rst:122
msgid "**A Level scene.**"
msgstr "**一个关卡场景.**"

#: ../../docs/getting_started/editor/unity_to_godot.rst:124
msgid ""
"A Level scene is composed of Bricks (for platforms), Coins (for the player "
"to collect) and a number of instances of the Enemy scene. Each instance is a "
"node in the Level scene tree. These instances are separate enemies, which "
"initially have shared behavior and appearance as defined in the Enemy scene. "
"You can set different properties for each Enemy node (to change its color, "
"for example)."
msgstr ""
"关卡场景由砖块(用于平台), 硬币(供玩家收集)和敌人场景的多个实例组成. 每个实例"
"都是关卡场景树中的一个节点. 这些实例是单独的敌人, 最初具有在敌人场景中定义的"
"共同行为和外观. 您可以为每个敌人节点设置不同的属性(例如, 更改其颜色)."

#: ../../docs/getting_started/editor/unity_to_godot.rst:128
msgid ""
"4. **A Main scene.** The Main scene would be composed of one root node with "
"2 children: a Player instance node, and a Level instance node. The root node "
"can be anything, generally a \"root\" type such as \"Node\" which is the "
"most global type, or \"Node2D\" (root type of all 2D-related nodes), "
"\"Spatial\" (root type of all 3D-related nodes) or \"Control\" (root type of "
"all GUI-related nodes)."
msgstr ""
"4. **一个主场景** 主场景将由一个根节点以及2个子节点的组成: 一个 ``Player`` 实"
"例节点和一个 ``Level`` 实例节点. 根节点可以是任何东西, 通常是 ``根(root)`` 类"
"型, 例如最全局的 ``节点(Node)``, 或 ``Node2D`` (所有与2D相关的节点的根类型), "
"``Spatial`` (所有3D相关的节点), 或 ``Control`` (所有与GUI相关的节点的根类型)."

#: ../../docs/getting_started/editor/unity_to_godot.rst:134
msgid ""
"As you can see, every scene is organized as a tree. The same goes for nodes' "
"properties: you don't *add* a collision component to a node to make it "
"collidable like Unity does. Instead, you make this node a *child* of a new "
"specific node that has collision properties. Godot features various "
"collision types nodes, depending on the usage (see the :ref:`Physics "
"introduction <doc_physics_introduction>`)."
msgstr ""
"如您所见, 每个场景都被组织成一棵树. 节点的属性也是如此: 您不会像Unity那样向节"
"点 *添加* 一个碰撞组件以使其可碰撞. 相反, 您可以使该节点创建一个 *子级* 节"
"点, 即具有碰撞属性的新特定节点 .Godot根据用途使用各种碰撞类型节点(请参阅 :"
"ref:`物理介绍 <doc_physics_introduction>`)."

#: ../../docs/getting_started/editor/unity_to_godot.rst:139
msgid ""
"What are the advantages of this system? Wouldn't this system potentially "
"increase the depth of the scene tree? And doesn't Unity already allow you to "
"organize GameObjects by putting them inside empty GameObjects?"
msgstr ""
"该系统的优点是什么？这个系统不会增加场景树的深度吗？而且Unity是否还是不允许您"
"通过将游戏对象放到空的游戏对象中来组织游戏对象？"

#: ../../docs/getting_started/editor/unity_to_godot.rst:141
msgid ""
"Godot's system is closer to the well-known object-oriented paradigm: Godot "
"provides a number of nodes which are not clearly \"Game Objects\", but they "
"provide their children with their own capabilities: this is inheritance."
msgstr ""
"Godot的系统更接近众所周知的面向对象的范例:Godot提供了许多不明确的 \"游戏对象"
"\" 节点, 但它们为子节点提供了自己的功能: 这就是继承."

#: ../../docs/getting_started/editor/unity_to_godot.rst:142
msgid ""
"Godot allows the extraction of a subtree of a scene to make it a scene of "
"its own. So if a scene tree gets too deep, it can be split into smaller "
"subtrees. This is better for reusability, as you can include any subtree as "
"a child of any node. Putting multiple GameObjects in an empty GameObject in "
"Unity does not provide the same functionality."
msgstr ""
"Godot允许抽取一个场景的子树以使其成为它自己的场景. 因此, 如果场景树变得过深, "
"则可以将其拆分为较小的子树. 这对于可重用性来说也很好, 因为您可以将任何子树作"
"为子级包含在其他任何节点中. 在Unity中, 将多个 ``GameObject`` 放入空 "
"``GameObject`` 中不会提供相同的功能."

#: ../../docs/getting_started/editor/unity_to_godot.rst:145
msgid "Project organization"
msgstr "项目组织"

#: ../../docs/getting_started/editor/unity_to_godot.rst:149
msgid ""
"There is no perfect project architecture. Any architecture can be made to "
"work in either Unity and Godot."
msgstr "没有完美的项目架构. 任何架构都可以在Unity和Godot中使用."

#: ../../docs/getting_started/editor/unity_to_godot.rst:152
msgid ""
"However, a common architecture for Unity projects is to have one Assets "
"folder in the root directory that contains various folders, one per type of "
"asset: Audio, Graphics, Models, Materials, Scripts, Scenes, and so on."
msgstr ""
"但是,Unity项目的通用架构是在根目录中有一个 ``Assets`` 文件夹, 其中包含各种文"
"件夹, 每种素材类型有一个文件夹: 音频(Audio), 图形(Graphics), 模型(Models), 材"
"质(Materials), 脚本(Scripts), 场景(Scenes)等."

#: ../../docs/getting_started/editor/unity_to_godot.rst:155
msgid ""
"Since Godot allows splitting scenes into smaller scenes, each scene and "
"subscene existing as a file in the project, we recommend organizing your "
"project a bit differently. This wiki provides a page for this: :ref:"
"`doc_project_organization`."
msgstr ""
"由于Godot允许将场景拆分为较小的场景, 在项目中, 每个场景和子场景都作为文件存"
"在, 因此我们建议对项目进行一些不同的组织. 该手册为此提供了一个页面: :ref:"
"`doc_project_organization`."

#: ../../docs/getting_started/editor/unity_to_godot.rst:160
msgid "Where are my prefabs?"
msgstr "我的预制体在哪里？"

#: ../../docs/getting_started/editor/unity_to_godot.rst:162
msgid ""
"A prefab as provided by Unity is a 'template' element of the scene. It is "
"reusable, and each instance of the prefab that exists in the scene has an "
"existence of its own, but all of them have the same properties as defined by "
"the prefab."
msgstr ""
"Unity提供的预制件是场景的 ``模板`` 元素. 它是可重复使用的, 并且场景中存在的预"
"制体的每个实例都有其自己的存在, 但所有它们都具有与预制体所定义的相同的属性."

#: ../../docs/getting_started/editor/unity_to_godot.rst:166
msgid ""
"Godot does not provide prefabs as such, but the same functionality is "
"provided by its scene system: The scene system is organized as a tree. Godot "
"allows you to save any subtree of a scene as a scene file. This new scene "
"can then be instanced as many times as you want, as a child of any node. Any "
"change you make to this new, separate scene will be applied to its "
"instances. However, any change you make to the instance will not have any "
"impact on the 'template' scene."
msgstr ""
"Godot本身不提供预制件, 但其场景系统提供了相同的功能: 场景系统组织为一棵树."
"Godot允许您将场景的任何子树保存为一个场景文件. 然后, 可以将这个新场景作为任意"
"节点的子节点实例化任意多次. 您对此新的独立场景所做的任何更改都将应用于其实"
"例. 但是, 您对实例所做的任何更改都不会对 ``模板`` 场景产生任何影响."

#: ../../docs/getting_started/editor/unity_to_godot.rst:173
msgid ""
"To be precise, you can modify the parameters of an instance in the Inspector "
"panel. The nodes that compose this instance are initially locked. You can "
"unlock them if you need to by right-clicking the instance in the Scene tree "
"and selecting \"Editable children\" in the menu. You don't need to do this "
"to add *new* child nodes to this node. Remember that any new children will "
"belong to the instance, not to the 'template' scene on disk. If you want to "
"add new children to every instance of your 'template' scene, then you should "
"add them in the 'template' scene."
msgstr ""
"确切地说, 您可以在属性检查器面板中修改实例的参数. 组成此实例的节点最初被锁"
"定. 如果需要, 可以通过右键点击场景树中的实例并在菜单中选择 ``可编辑子代`` 来"
"解锁它们. 您无需执行此操作即可向该节点添加 *新的* 子节点. 请记住, 任何新的子"
"项都将属于该实例, 而不是磁盘上的 ``模板`` 场景. 如果要将新的子项添加到 ``模板"
"`` 场景的每个实例, 则应将在 ``模板`` 场景中添加."

#: ../../docs/getting_started/editor/unity_to_godot.rst:183
msgid "Glossary correspondence"
msgstr "术语对应"

#: ../../docs/getting_started/editor/unity_to_godot.rst:185
msgid "GameObject -> Node"
msgstr "游戏对象(GameObject) -> 节点(Node)"

#: ../../docs/getting_started/editor/unity_to_godot.rst:186
msgid "Add a component -> Inheriting"
msgstr "添加组件(Add a component) -> 继承(Inheriting)"

#: ../../docs/getting_started/editor/unity_to_godot.rst:187
msgid "Prefab -> Reusable Scene file"
msgstr "预制件(Prefab) -> 可重用的场景文件(Reusable Scene file)"

#: ../../docs/getting_started/editor/unity_to_godot.rst:191
msgid "Scripting: GDScript, C# and Visual Script"
msgstr "编写脚本：GDScript、C# 和 Visual Script"

#: ../../docs/getting_started/editor/unity_to_godot.rst:194
msgid "Design"
msgstr "设计"

#: ../../docs/getting_started/editor/unity_to_godot.rst:196
msgid ""
"Unity supports C#. C# benefits from its integration with Visual Studio and "
"has desirable features such as static typing."
msgstr ""
"Unity支持C#.C#受益于它与Visual Studio的集成, 并具有理想的功能, 例如静态类型."

#: ../../docs/getting_started/editor/unity_to_godot.rst:198
msgid ""
"Godot provides its own scripting language, :ref:`GDScript <doc_scripting>` "
"as well as support for :ref:`Visual Script <toc-learn-scripting-"
"visual_script>` and :ref:`C# <doc_c_sharp>`. GDScript borrows its syntax "
"from Python, but is not related to it. If you wonder about the reasoning for "
"a custom scripting language, please read the :ref:`doc_gdscript` and :ref:"
"`doc_faq` pages. GDScript is strongly attached to the Godot API and doesn't "
"take long to learn: Between one evening for an experienced programmer and a "
"week for a complete beginner."
msgstr ""
"Godot提供了自己的脚本语言, :ref:`GDScript <doc_scripting>`, 以及对 :ref:"
"`Visual Script <toc-learn-scripting-visual_script>` 和 :ref:`C # "
"<doc_c_sharp>` 的支持.GDScript虽然从 Python 中借用了它的语法, 但与它无关. 如"
"果您想了解自定义脚本语言的原因, 请阅读 :ref:`doc_gdscript` 和 :ref:`doc_faq` "
"页面.GDScript与Godot API紧密相连, 无需花太多时间即可学习: 一个经验丰富的程序"
"员的一个晚上, 一个完全的初学者的一周时间, 即可学会."

#: ../../docs/getting_started/editor/unity_to_godot.rst:204
msgid ""
"Unity allows you to attach as many scripts as you want to a GameObject. Each "
"script adds a behavior to the GameObject: For example, you can attach a "
"script so that it reacts to the player's controls, and another that controls "
"its specific game logic."
msgstr ""
"Unity允许您将任意数量的脚本附加到 GameObject 上. 每个脚本都会向 GameObject 添"
"加一个行为: 例如, 您可以附加一个脚本, 使其对玩家的控制做出反应, 而另一个脚本"
"则控制其特定的游戏逻辑."

#: ../../docs/getting_started/editor/unity_to_godot.rst:208
msgid ""
"In Godot, you can only attach one script per node. You can use either an "
"external GDScript file or include the script directly in the node. If you "
"need to attach more scripts to one node, then you may consider two "
"solutions, depending on your scene and on what you want to achieve:"
msgstr ""
"在Godot中, 每个节点只能附加一个脚本. 您可以使用外部GDScript文件, 也可以将脚本"
"直接包含在节点中. 如果需要将更多脚本附加到一个节点, 则可以根据场景和要实现的"
"目标考虑两种解决方案:"

#: ../../docs/getting_started/editor/unity_to_godot.rst:212
msgid ""
"either add a new node between your target node and its current parent, then "
"add a script to this new node."
msgstr "在目标节点与其当前父节点之间添加一个新节点, 然后向该新节点添加脚本."

#: ../../docs/getting_started/editor/unity_to_godot.rst:213
msgid ""
"or, you can split your target node into multiple children and attach one "
"script to each of them."
msgstr "或者, 您可以将目标节点拆分为多个子节点, 并在每个子节点上附加一个脚本."

#: ../../docs/getting_started/editor/unity_to_godot.rst:215
msgid ""
"As you can see, it can be easy to turn a scene tree to a mess. Consider "
"splitting any complicated scene into multiple, smaller branches."
msgstr ""
"如您所见, 将场景树变成一团糟很容易. 考虑将任何复杂的场景分为多个较小的分支."

#: ../../docs/getting_started/editor/unity_to_godot.rst:218
msgid "Connections: groups and signals"
msgstr "连接: 编组和信号"

#: ../../docs/getting_started/editor/unity_to_godot.rst:220
msgid ""
"You can control nodes by accessing them via script and calling built-in or "
"user-defined functions on them. You can also place nodes in a group and call "
"functions on all nodes in this group. See more in the :ref:`scripting "
"documentation <doc_scripting_continued>`."
msgstr ""
"您可以通过脚本访问节点以及在其上调用内置或用户定义的函数来控制节点. 您还可以"
"将节点放在一个编组中, 并在该编组中的所有节点上调用函数. 有关更多信息, 请参"
"见 :ref:`脚本文档 <doc_scripting_continued>`."

#: ../../docs/getting_started/editor/unity_to_godot.rst:225
msgid ""
"Nodes can send a signal when a specified action occurs. A signal can be set "
"to call any function. You can define custom signals and specify when they "
"are triggered. See more in the :ref:`signals documentation "
"<doc_gdscript_signals>`."
msgstr ""
"发生指定的操作时, 节点可以发送信号. 可以设置信号来调用任何函数. 您可以定义自"
"定义信号并指定触发它们的时间. 请参阅 :ref:`信号文档 <doc_gdscript_signals>` "
"中的更多内容."

#: ../../docs/getting_started/editor/unity_to_godot.rst:230
msgid "Script serialization"
msgstr "脚本序列化"

#: ../../docs/getting_started/editor/unity_to_godot.rst:232
msgid "Unity can handle script serialization in two ways:"
msgstr "Unity可以通过两种方式处理脚本序列化:"

#: ../../docs/getting_started/editor/unity_to_godot.rst:234
msgid ""
"Implicit: All public fields in a class are automatically serialized if the "
"type is a serializable type (``Dictionary`` is not serializable)."
msgstr ""
"隐式: 如果类型是可序列化的类型(``Dictionary`` 不可序列化), 则类中的所有公共字"
"段都会自动进行序列化."

#: ../../docs/getting_started/editor/unity_to_godot.rst:235
msgid ""
"Explicit: Non-public fields can be serialized using the ``[SerializeField]`` "
"attribute."
msgstr "显式: 可以使用 ``[SerializeField]`` 属性来序列化非公共字段."

#: ../../docs/getting_started/editor/unity_to_godot.rst:237
msgid ""
"Godot also has a built-in script serialization system, but it works only "
"explicitly. You can serialize any serializable type (:ref:`built-in and "
"various engine types <doc_binary_serialization_api>`, including :ref:"
"`class_Array` and :ref:`class_Dictionary`) using the ``export`` keyword. See "
"the :ref:`exports documentation <doc_gdscript_exports>` for details."
msgstr ""
"Godot也具有内置脚本序列化系统,, 但它仅显式工作. 您可以使用 ``export`` 关键字"
"序列化任何可序列化的类型( :ref:`内置和各种引擎类型 "
"<doc_binary_serialization_api>`, 包括 :ref:`class_Array` 和 :ref:"
"`class_Dictionary`). 有关详细信息, 请参见 :ref:`导出器文档 "
"<doc_gdscript_exports>`."

#: ../../docs/getting_started/editor/unity_to_godot.rst:242
msgid ""
"Unity also has a data type called ``ScriptableObject`` used to serialize "
"custom asset objects. Its equivalent in Godot is the base class for all "
"resources: :ref:`class_Resource`. Creating a script that inherits :ref:"
"`class_Resource` will allow you to create custom serializable objects. More "
"information about resources can be found :ref:`here <doc_resources>`."
msgstr ""
"Unity还具有一个名为 ``ScriptableObject`` 的数据类型, 用于序列化自定义素材对"
"象. 它在Godot中的等效项是所有资源的基类: :ref:`class_Resource`. 创建一个继承"
"了 :ref:`class_Resource` 的脚本, 将允许您创建自定义的可序列化对象. 有关资源的"
"更多信息, 请参见 :ref:`这里 <doc_resources>`."

#: ../../docs/getting_started/editor/unity_to_godot.rst:247
msgid "Using Godot in C++"
msgstr "在 Godot 中使用 C++"

#: ../../docs/getting_started/editor/unity_to_godot.rst:249
msgid ""
"Godot allows you to develop your project directly in C++ by using its API, "
"which is not possible with Unity at the moment. As an example, you can "
"consider Godot Engine's editor as a \"game\" written in C++ using the Godot "
"API."
msgstr ""
"Godot允许您使用其API直接使用C++开发项目, 而这在Unity中目前是不可能的. 例如, "
"您可以将Godot引擎的编辑器视为使用Godot API用C++编写的 ``游戏``."

#: ../../docs/getting_started/editor/unity_to_godot.rst:252
msgid ""
"If you are interested in using Godot in C++, you may want to start reading "
"the :ref:`Developing in C++ <doc_introduction_to_godot_development>` page."
msgstr ""
"如果你对使用Godot时使用C++感兴趣, 你可能想要开始阅读 :ref:`用C++开发 "
"<doc_introduction_to_godot_development>` 页面."
