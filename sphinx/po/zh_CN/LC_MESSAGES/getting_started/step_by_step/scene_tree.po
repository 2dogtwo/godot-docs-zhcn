# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2019, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-03-10 11:47+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:4
#: ../../docs/getting_started/step_by_step/scene_tree.rst:41
msgid "SceneTree"
msgstr "场景树"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:7
msgid "Introduction"
msgstr "简介"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:9
msgid ""
"This is where things start getting abstract, but don't panic. There's not "
"much more depth than this."
msgstr "这就是事情开始变得抽象的地方, 但不要慌张。没有比这更深入的了。"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:12
msgid ""
"In previous tutorials, everything revolved around the concept of nodes. "
"Scenes are simply a collection of nodes. They become active once they enter "
"the *scene tree*."
msgstr ""
"在前面的教程中, 一切都围绕节点的概念展开。场景只是节点的集合。一旦进入 *场景"
"树* , 它们就会被激活。"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:16
msgid ""
"This concept deserves going into a little more detail. In fact, the scene "
"system is not even a core component of Godot as it is possible to skip it "
"and write a script (or C++ code) that talks directly to the servers, but "
"making a game that way would be a lot of work."
msgstr ""
"这个概念值得更详细一些。事实上, 场景系统甚至不是Godot的核心组件, 因为可以跳过"
"它, 编写一个直接与服务器对话的脚本 (或 C++ 代码), 但以这种方式制作游戏将是一"
"项大量的工作。"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:22
msgid "MainLoop"
msgstr "主循环"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:24
msgid ""
"The way Godot works internally is as follows. There is the :ref:`OS "
"<class_OS>` class, which is the only instance that runs at the beginning. "
"Afterwards, all drivers, servers, scripting languages, scene system, etc are "
"loaded."
msgstr ""
"Godot内部的工作方式如下所示。有 :ref:`OS <class_OS>` 类, 它是在开始时运行的唯"
"一实例。之后, 加载所有驱动程序、服务器、脚本语言、场景系统等。"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:29
msgid ""
"When initialization is complete, :ref:`OS <class_OS>` needs to be supplied "
"a :ref:`MainLoop <class_MainLoop>` to run. Up to this point, all this is "
"internals working (you can check main/main.cpp file in the source code if "
"you are ever interested to see how this works internally)."
msgstr ""
"初始化完成后, 需要向 :ref:`OS <class_OS>` 提供一个 :ref:`MainLoop "
"<class_MainLoop>` 来运行。到目前为止, 所有这些都是内部工作 (您可以检查main/"
"main.cpp文件在源代码中, 如果您曾经有兴趣看到它是如何在内部工作)。"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:35
msgid ""
"The user program, or game, starts in the MainLoop. This class has a few "
"methods, for initialization, idle (frame-synchronized callback), fixed "
"(physics-synchronized callback), and input. Again, this is low level and "
"when making games in Godot, writing your own MainLoop seldom makes sense."
msgstr ""
"用户程序或游戏从主循环开始。此类有几个方法, 用于初始化、空闲 (框架同步回调)、"
"固定 (物理同步回调) 和输入。同样, 这是低级别的, 在Godot中制作游戏时, 编写自己"
"的主循环意义不大。"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:43
msgid ""
"One of the ways to explain how Godot works is that it's a high level game "
"engine over a low level middleware."
msgstr ""
"解释Godot如何工作的方法之一是, 它是一个高级的游戏引擎, 超过了一个低级中间件。"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:46
msgid ""
"The scene system is the game engine, while the :ref:`OS <class_OS>` and "
"servers are the low level API."
msgstr "场景系统是游戏引擎, 而 :ref:`OS <class_OS>` 和服务器是低级API。"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:49
msgid ""
"In any case, the scene system provides its own main loop to OS, :ref:"
"`SceneTree <class_SceneTree>`. This is automatically instanced and set when "
"running a scene, no need to do any extra work."
msgstr ""
"在任何情况下, 场景系统都为操作系统 :ref:`SceneTree <class_SceneTree>` 提供了"
"自己的主循环。这是在运行场景时自动进行实例化和设置的, 无需执行任何额外的工"
"作。"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:54
msgid ""
"It's important to know that this class exists because it has a few important "
"uses:"
msgstr "重要的是要知道此类的存在, 因为它有几个重要的用途:"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:57
msgid ""
"It contains the root :ref:`Viewport <class_Viewport>`, to which a scene is "
"added as a child when it's first opened to become part of the *Scene Tree* "
"(more on that next)"
msgstr ""
"它包含根 :ref:`Viewport <class_Viewport>`, 当场景第一次打开时, 场景将作为子对"
"象添加到其中 (接下来会有更多)"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:60
msgid ""
"It contains information about the groups and has the means to call all nodes "
"in a group or get a list of them."
msgstr "它包含有关组的信息, 并具有调用组中的所有节点或获取它们的列表的方法。"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:62
msgid ""
"It contains some global state functionality, such as setting pause mode or "
"quitting the process."
msgstr "它包含一些全局状态功能, 如设置暂停模式或退出进程。"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:65
#, fuzzy
msgid ""
"When a node is part of the Scene Tree, the :ref:`SceneTree "
"<class_SceneTree>` singleton can be obtained by simply calling :ref:`Node."
"get_tree() <class_Node_method_get_tree>`."
msgstr ""
"当节点是场景树的一部分时, 只需调用 :ref:`Node.get_tree() "
"<class_Node_method_get_tree>` 即可获得 :ref:`场景树 <class_SceneTree>` 单例。"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:71
msgid "Root viewport"
msgstr "根视区"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:73
msgid ""
"The root :ref:`Viewport <class_Viewport>` is always at the top of the scene. "
"From a node, it can be obtained in two different ways:"
msgstr ""
"根 :ref:`Viewport <class_Viewport>` 始终位于场景的顶部。从节点中, 可以通过两"
"种不同的方式获得它:"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:88
msgid ""
"This node contains the main viewport, anything that is a child of a :ref:"
"`Viewport <class_Viewport>` is drawn inside of it by default, so it makes "
"sense that the top of all nodes is always a node of this type otherwise "
"nothing would be seen!"
msgstr ""
"此节点包含主视区, 默认情况下, 任何作为 :ref:`Viewport <class_Viewport>` 子视"
"区的内容都将在其中绘制, 因此, 所有节点的顶部始终是此类型的节点是有意义的, 否"
"则不会看到任何内容！"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:93
msgid ""
"While other viewports can be created in the scene (for split-screen effects "
"and such), this one is the only one that is never created by the user. It's "
"created automatically inside SceneTree."
msgstr ""
"虽然可以在场景中创建其他视区 (用于拆分屏幕效果等), 但这是唯一一个从未由用户创"
"建的视区。它是在“场景树”内自动创建的。"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:98
msgid "Scene tree"
msgstr "场景树"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:100
msgid ""
"When a node is connected, directly or indirectly, to the root viewport, it "
"becomes part of the *scene tree*."
msgstr "当节点直接或间接连接到根视区时, 它将成为 *场景树* 的一部分。"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:103
msgid ""
"This means that as explained in previous tutorials, it will get the "
"_enter_tree() and _ready() callbacks (as well as _exit_tree())."
msgstr ""
"这意味着, 正如在前面的教程中所解释的, 它将得到 _enter_tree() 和 _ready() 回"
"调 (以及_exit_tree())。"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:108
msgid ""
"When nodes enter the *Scene Tree*, they become active. They get access to "
"everything they need to process, get input, display 2D and 3D, "
"notifications, play sound, groups, etc. When they are removed from the "
"*scene tree*, they lose access."
msgstr ""
"当节点进入 *场景树* 时, 它们将变为活动状态。他们可以访问处理、获取输入、显示"
"2d 和3d、通知、播放声音、组等所需的一切。当它们从 *场景树* 中删除时, 它们将失"
"去访问权限。"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:114
msgid "Tree order"
msgstr "树顺序"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:116
msgid ""
"Most node operations in Godot, such as drawing 2D, processing, or getting "
"notifications are done in tree order. This means that parents and siblings "
"with a smaller rank in the tree order will get notified before the current "
"node."
msgstr ""
"Godot中的大多数节点操作 (如绘制2d、处理或获取通知) 都是按树顺序完成的。这意味"
"着在树顺序中排名较小的家长和兄弟姐妹将在当前节点之前收到通知。"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:124
msgid "\"Becoming active\" by entering the *Scene Tree*"
msgstr "通过进入 *场景树* \"被激活\""

#: ../../docs/getting_started/step_by_step/scene_tree.rst:126
msgid "A scene is loaded from disk or created by scripting."
msgstr "场景是从磁盘加载或通过脚本创建的。"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:127
msgid ""
"The root node of that scene (only one root, remember?) is added as either a "
"child of the \"root\" Viewport (from SceneTree), or to any child or "
"grandchild of it."
msgstr ""
"该场景的根节点 (只记得一个根节点？) 被添加为“根”视区 (从场景树) 的子节点, 或"
"添加到该场景的任何子节点或孙子。"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:130
msgid ""
"Every node of the newly added scene, will receive the \"enter_tree\" "
"notification ( _enter_tree() callback in GDScript) in top-to-bottom order."
msgstr ""
"新添加的场景的每个节点都将按从上到底顺序收到“enter_tree”通知(GDScript中的 "
"_enter_tree 回调)。"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:133
msgid ""
"An extra notification, \"ready\" ( _ready() callback in GDScript) is "
"provided for convenience, when a node and all its children are inside the "
"active scene."
msgstr ""
"当节点及其所有子节点位于活动场景中时, 为方便起见, 提供了一个额外的通知, "
"即“ready”(GDScript中的 _ready() 回调)。"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:136
msgid ""
"When a scene (or part of it) is removed, they receive the \"exit scene\" "
"notification ( _exit_tree() callback in GDScript) in bottom-to-top order"
msgstr ""
"删除场景 (或其中一部分) 后, 它们将按从下到上的顺序收到“退出场景”通知(GDScript"
"中的 _exit_tree() 回调)"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:141
msgid "Changing current scene"
msgstr "更改当前场景"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:143
#, fuzzy
msgid ""
"After a scene is loaded, it is often desired to change this scene for "
"another one. The simple way to do this is to use the :ref:`SceneTree."
"change_scene() <class_SceneTree_method_change_scene>` function:"
msgstr ""
"加载场景后, 通常需要将此场景更改为另一个场景。简单的方法是使用 :ref:"
"`SceneTree.change_scene() <class_SceneTree_method_change_scene>` 方法:"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:161
#, fuzzy
msgid ""
"Rather than using file paths, one can also use ready-made :ref:`PackedScene "
"<class_PackedScene>` resources using the equivalent function :ref:`SceneTree."
"change_scene_to(PackedScene scene) <class_SceneTree_method_change_scene_to>`:"
msgstr ""
"除了使用文件路径, 也可以通过使用等效函数 :ref:`SceneTree."
"change_scene_to(PackedScene scene)<class_SceneTree_method_change_scene_to>` "
"来利用现成的 :ref:`PackedScene <class_PackedScene>` 资源:"

#: ../../docs/getting_started/step_by_step/scene_tree.rst:182
msgid ""
"These are quick and useful ways to switch scenes but have the drawback that "
"the game will stall until the new scene is loaded and running. At some point "
"in your game, it may be desired to create proper loading screens with "
"progress bar, animated indicators or thread (background) loading. This must "
"be done manually using autoloads (see next chapter!) and :ref:"
"`doc_background_loading`."
msgstr ""
"这是一个快速和有用的方式来切换场景, 但有一个缺点, 游戏将停止, 直到新的场景加"
"载并运行。在游戏中的某个时刻, 可能需要创建适当的加载屏幕, 其中包含进度条、动"
"画指示器或线程 (后台) 加载。这必须使用自动加载手动完成 (请参阅下一章) 和 :"
"ref:`doc_background_loading` 。"
