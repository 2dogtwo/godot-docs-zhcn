# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2019, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-02-10 13:55+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../docs/getting_started/step_by_step/signals.rst:4
msgid "Signals"
msgstr "信号"

#: ../../docs/getting_started/step_by_step/signals.rst:7
msgid "Introduction"
msgstr "简介"

#: ../../docs/getting_started/step_by_step/signals.rst:9
msgid ""
"Signals are Godot's version of the *observer* pattern. They allow a node to "
"send out a message that other nodes can listen for and respond to. For "
"example, rather than continuously checking a button to see if it's being "
"pressed, the button can emit a signal when it's pressed."
msgstr ""
"信号是Godot版本的观察者模式。它允许一个节点发送消息到其他节点，令其他节点也可"
"以监听和响应这个消息。举个示例，当按键按下时信号就会发出，而不是不停地检查按"
"键是否被按压。"

#: ../../docs/getting_started/step_by_step/signals.rst:14
msgid ""
"You can read more about the observer pattern here: http://"
"gameprogrammingpatterns.com/observer.html"
msgstr ""
"您可以在这里查看更多关于观察者模式: http://gameprogrammingpatterns.com/"
"observer.html"

#: ../../docs/getting_started/step_by_step/signals.rst:16
msgid ""
"Signals are a way to *decouple* your game objects, which leads to better "
"organized and more manageable code. Instead of forcing game objects to "
"expect other objects to always be present, they can instead emit signals "
"that any interested objects can subscribe to and respond."
msgstr ""
"信号是一种 *解耦* 游戏对象的方法，从而使代码更有条理，更易于管理。他们可以对"
"任何感兴趣的可以订阅的对象发出信号和响应，而不是强制游戏对象去期望其他对象始"
"终存在。"

#: ../../docs/getting_started/step_by_step/signals.rst:21
msgid ""
"Below you can see some examples of how you can use signals in your own "
"projects."
msgstr "接下来您可以看到一些如何在自己的项目中使用信号的示例。"

#: ../../docs/getting_started/step_by_step/signals.rst:24
msgid "Timer example"
msgstr "计时器示例"

#: ../../docs/getting_started/step_by_step/signals.rst:26
msgid ""
"To see how signals work, let's try using a :ref:`Timer <class_Timer>` node. "
"Create a new scene with a Node and two children: a Timer and a :ref:`Sprite "
"<class_Sprite>`. You can use the Godot icon for the Sprite's texture, or any "
"other image you like. Attach a script to the root node, but don't add any "
"code to it yet."
msgstr ""
"要查看信号是如何工作的，让我们尝试使用 :ref:`Timer <class_Timer>` 节点。使用"
"一个节点和两个子节点来创建一个新场景:一个是:Timer和一个 :ref:`Sprite "
"<class_Sprite>`。您可以使用Godot图标作为Sprite的纹理，或者其他您喜欢的任意图"
"像。"

#: ../../docs/getting_started/step_by_step/signals.rst:31
msgid "Your scene tree should look like this:"
msgstr "您的场景树应该是这样的:"

#: ../../docs/getting_started/step_by_step/signals.rst:35
msgid ""
"In the Timer node's properties, check the \"On\" box next to *Autostart*. "
"This will cause the timer to start automatically when you run the scene. You "
"can leave the *Wait Time* at 1 second."
msgstr ""
"在Timer节点的属性中，勾选 *自动启动* 旁边的选框。这会令计时器在您运行场景时自"
"动启动。您可以将 *等待时间* 保留为1秒。"

#: ../../docs/getting_started/step_by_step/signals.rst:39
msgid ""
"Next to the \"Inspector\" tab is a tab labeled \"Node\". Click on this tab "
"and you'll see all of the signals that the selected node can emit. In the "
"case of the Timer node, the one we're concerned with is \"timeout\". This "
"signal is emitted whenever the Timer reaches ``0``."
msgstr ""
"在 \"属性面板\" 选项卡旁边是一个标记为 \"节点\" 的标签。单击此选项卡，您将看"
"到所选节点可以发出的所有信号。在计时器节点的情况下，我们关心的是\"超时\"。每"
"当计时器到达 ``0`` 时，就会发出这个信号。"

#: ../../docs/getting_started/step_by_step/signals.rst:46
msgid ""
"Click on the \"timeout()\" signal and click \"Connect...\". You'll see the "
"following window, where you can define how you want to connect the signal:"
msgstr ""
"点击 \"timeout()\" 信号，点击 \"Connect...\"。您将看到以下窗口，您可以在其中"
"定义如何连接信号:"

#: ../../docs/getting_started/step_by_step/signals.rst:51
msgid ""
"On the left side, you'll see the nodes in your scene and can select the node "
"that you want to \"listen\" for the signal. Note that the Timer node is red "
"- this is *not* an error, but is a visual indication that it's the node that "
"is emitting the signal. Select the root node."
msgstr ""
"在左侧，您将看到您场景中的节点，并可以选择您想要“侦听”的节点信号。需要留意的"
"是，定时器节点变红——这不是一个错误，但它是节点发出信号的视觉提示。选择根节"
"点。"

#: ../../docs/getting_started/step_by_step/signals.rst:56
msgid ""
"The target node *must* have a script attached or you'll receive an error "
"message."
msgstr "目标节点 *必须* 附加一个脚本，否则您将收到一条错误消息。"

#: ../../docs/getting_started/step_by_step/signals.rst:59
msgid ""
"On the bottom of the window is a field labeled \"Method In Node\". This is "
"the name of the function in the target node's script that you want to use. "
"By default, Godot will create this function using the naming convention "
"``_on_<node_name>_<signal_name>`` but you can change it if you wish."
msgstr ""
"在窗口的底部有一个“节点中的方法”标签。这是您在目标节点脚本中要使用的函数名。"
"默认情况下，Godot将会按命名规则' ' _on_<node_name>_<signal_name> ' ' '创建这"
"个函数，但您可以按您的意愿更改它。"

#: ../../docs/getting_started/step_by_step/signals.rst:64
msgid ""
"Click \"Connect\" and you'll see that the function has been created in the "
"script:"
msgstr "单击“Connect”，您将看到该函数已在脚本中创建:"

#: ../../docs/getting_started/step_by_step/signals.rst:84
msgid ""
"Now we can replace the placeholder code with whatever code we want to run "
"when the signal is received. Let's make the Sprite blink:"
msgstr ""
"现在，我们可以将占位符代码替换为接收到信号时要运行的任何代码。让我们让精灵闪"
"烁:"

#: ../../docs/getting_started/step_by_step/signals.rst:106
msgid ""
"Run the scene and you'll see the Sprite blinking on and off every second. "
"You can change the Timer's *Wait Time* property to alter this."
msgstr ""
"运行这个场景，您会看到精灵每秒钟都在闪烁。您可以更改计时器的 *等待时间* 属性"
"来改变这一点。"

#: ../../docs/getting_started/step_by_step/signals.rst:110
msgid "Connecting signals in code"
msgstr "连接代码中的信号"

#: ../../docs/getting_started/step_by_step/signals.rst:112
msgid ""
"You can also make the signal connection in code rather than with the editor. "
"This is usually necessary when you're instancing nodes via code and so you "
"can't use the editor to make the connection."
msgstr ""
"您还可以在代码中进行信号连接而不是在编辑器中。当您通过代码实例化节点时，您并"
"不能使用编辑器进行连接，因此这通常是必要的。"

#: ../../docs/getting_started/step_by_step/signals.rst:116
msgid ""
"First, disconnect the signal by selecting the connection in the Timer's "
"\"Node\" tab and clicking disconnect."
msgstr "首先，在计时器的“节点”选项卡中选中’链接‘，并单击’断开连接‘来断开信号。"

#: ../../docs/getting_started/step_by_step/signals.rst:121
msgid ""
"To make the connection in code, we can use the ``connect`` function. We'll "
"put it in ``_ready()`` so that the connection will be made on run. The "
"syntax of the function is ``<source_node>.connect(<signal_name>, "
"<target_node>, <target_function_name>)``. Here is the code for our Timer "
"connection:"
msgstr ""
"要在代码中进行连接，我们可以使用 ``connect`` 函数。我们将把它放在 "
"``_ready()`` 函数中，这样连接就会在运行时进行。函数的语法是 ``<source_node>."
"connect(<signal_name>, <target_node>, <target_function_name>)`` 。下面是我们"
"的计时器连接的代码:"

#: ../../docs/getting_started/step_by_step/signals.rst:154
msgid "Custom signals"
msgstr "自定义信号"

#: ../../docs/getting_started/step_by_step/signals.rst:156
msgid "You can also declare your own custom signals in Godot:"
msgstr "您也可以在Godot中声明您的的自定义信号:"

#: ../../docs/getting_started/step_by_step/signals.rst:174
msgid ""
"Once declared, your custom signals will appear in the Inspector and can be "
"connected in the same way as a node's built-in signals."
msgstr ""
"一旦声明，您的自定义信号就会出现在属性面板中，并且可以用与节点内置信号以相同"
"的方式进行连接。"

#: ../../docs/getting_started/step_by_step/signals.rst:177
msgid "To emit a signal via code, use the ``emit`` function:"
msgstr "要通过代码发出信号，使用 ``emit`` 函数:"

#: ../../docs/getting_started/step_by_step/signals.rst:203
msgid "Shooting example"
msgstr "射击示例"

#: ../../docs/getting_started/step_by_step/signals.rst:205
msgid ""
"As another example of signal usage, let's consider a player character that "
"can rotate and shoot towards the mouse. Every time the mouse button is "
"clicked, we create an instance of the bullet at the player's location. See :"
"ref:`doc_instancing` for details."
msgstr ""
"作为信号使用的另一个示例，让我们考虑一个可以旋转并向鼠标射击的游戏角色角色。"
"每次单击鼠标按钮，我们都会在游戏角色的位置创建子弹的实例。详情请参阅 :ref:"
"`doc_instancing` 。"

#: ../../docs/getting_started/step_by_step/signals.rst:210
msgid ""
"However, if the bullets are added as children of the player, then they will "
"remain \"attached\" to the player as it rotates:"
msgstr ""
"然而，如果子弹作为游戏角色的子节点添加，那么当它旋转时，子弹将仍然保持“附"
"着”在游戏角色身上:"

#: ../../docs/getting_started/step_by_step/signals.rst:215
msgid ""
"Instead, we need the bullets to be independent of the player's movement - "
"once fired, they should continue traveling in a straight line and the player "
"can no longer affect them. Instead of being added to the scene tree as a "
"child of the player, it makes more sense to add the bullet as a child of the "
"\"main\" game scene, which may be the player's parent or even further up the "
"tree."
msgstr ""
"相反，我们需要子弹独立于游戏角色的移动——一旦发射，子弹就会继续沿着直线运动，"
"游戏角色就不能再影响它们了。与其作为游戏角色的子节点被添加到场景树中，不如将"
"子弹作为“主”游戏场景的子节点添加上去更有意义，后者可能是游戏角色的父节点，甚"
"至可能是更高层级的树。"

#: ../../docs/getting_started/step_by_step/signals.rst:221
msgid "You could do this by adding the bullet directly:"
msgstr "您可以通过直接添加子弹来做到这一点:"

#: ../../docs/getting_started/step_by_step/signals.rst:234
msgid ""
"However, this will lead to a different problem. Now if you try and test your "
"\"Player\" scene independently, it will crash on shooting, because there is "
"no parent node to access. This makes it a lot harder to test your player "
"code independently and also means that if you decide to change your main "
"scene's node structure, the player's parent may no longer be the appropriate "
"node to receive the bullets."
msgstr ""
"然而，这将导致一个不同的问题。现在如果您尝试独立测试您的“游戏角色”场景，它会"
"在射击时崩溃，因为没有父节点可以访问。这使得独立测试游戏角色角色代码变得更加"
"困难，也意味着如果您决定改变主场景的节点结构，游戏角色的父节点可能不再是接收"
"子弹的合适节点。"

#: ../../docs/getting_started/step_by_step/signals.rst:241
msgid ""
"The solution to this is to use a signal to \"emit\" the bullets from the "
"player. The player then has no need to \"know\" what happens to the bullets "
"after that - whatever node is connected to the signal can \"receive\" the "
"bullets and take the appropriate action to spawn them."
msgstr ""
"解决这个问题的方法是使用一个信号来“发射”游戏角色的子弹。游戏角色不需要“知"
"道”子弹在那之后发生了什么——任何连接到信号的节点都可以“接收”子弹并采取适当的行"
"动来产生它们。"

#: ../../docs/getting_started/step_by_step/signals.rst:247
msgid "Here is the code for the player using signals to emit the bullet:"
msgstr "下面是游戏角色使用信号发射子弹的代码:"

#: ../../docs/getting_started/step_by_step/signals.rst:290
msgid ""
"In the main scene, we then connect the player's signal (it will appear in "
"the \"Node\" tab)."
msgstr "在主场景中，我们连接游戏角色的信号(它将出现在“Node”选项卡中)。"

#: ../../docs/getting_started/step_by_step/signals.rst:314
msgid ""
"Now the bullets will maintain their own movement independent of the player's "
"rotation:"
msgstr "现在子弹将保持自己的运动独立于游戏角色的旋转:"

#: ../../docs/getting_started/step_by_step/signals.rst:320
msgid "Conclusion"
msgstr "总结"

#: ../../docs/getting_started/step_by_step/signals.rst:322
msgid ""
"Many of Godot's built-in node types provide signals you can use to detect "
"events. For example, an :ref:`Area2D <class_Area2D>` representing a coin "
"emits a ``body_entered`` signal whenever the player's physics body enters "
"its collision shape, allowing you to know when the player collected it."
msgstr ""
"Godot的许多内置节点类型都提供可以用来检测事件的信号。例如，代表硬币的 :ref:"
"`Area2D <class_Area2D>` 在游戏角色的物理体进入碰撞形状时发出 "
"``body_entered`` 信号，让您知道游戏角色什么时候收集它。"

#: ../../docs/getting_started/step_by_step/signals.rst:327
msgid ""
"In the next section, :ref:`doc_your_first_game`, you'll build a complete "
"game including several uses of signals to connect different game components."
msgstr ""
"在下一节 :ref:`doc_your_first_game` 中，您将构建一个完整的游戏，其中包括连接"
"不同游戏组件的几种信号用法。"
