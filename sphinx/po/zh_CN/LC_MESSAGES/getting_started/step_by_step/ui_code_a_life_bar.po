# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2019, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-04-09 11:43+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:4
msgid "Control the game's UI with code"
msgstr "用代码控制游戏UI"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:7
msgid "Intro"
msgstr "简介"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:9
msgid ""
"In this tutorial, you will connect a character to a life bar and animate the "
"health loss."
msgstr "在本教程中，您将生命条关联到一个角色，并动画化生命值损失。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:14
msgid ""
"Here's what you'll create: the bar and the counter animate when the "
"character takes a hit. They fade when it dies."
msgstr ""
"下面是您将创建的:当角色受到攻击时，工具条和计数器将显示动画。当它消失的时候，"
"它们就会褪色。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:18
msgid "You will learn:"
msgstr "您将学习:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:20
msgid "How to **connect** a character to a GUI with signals"
msgstr "如何用信号将一个角色 **连接** 到GUI"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:21
msgid "How to **control** a GUI with GDscript"
msgstr "如何用GDscript **控制** 一个GUI"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:22
msgid "How to **animate** a life bar with the :ref:`Tween <class_Tween>` node"
msgstr "如何用 :ref:`Tween <class_Tween>` 节点 **动画化** 生命条"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:25
msgid ""
"If you want to learn how to set up the interface instead, check out the step-"
"by-step UI tutorials:"
msgstr "如果您想学习如何设置界面，请查看按部就班的UI教程:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:28
msgid "Create a main menu screen"
msgstr "创建一个主菜单屏幕"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:29
msgid "Create a game user interface"
msgstr "创建一个游戏用户界面"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:32
msgid ""
"When you code a game, you want to build the core gameplay first: the main "
"mechanics, player input, win and loss conditions. The UI comes a bit later. "
"You want to keep all the elements that make up your project separate if "
"possible. Each character should be in its own scene, with its own scripts, "
"and so should the UI elements. This prevents bugs, keeps your project "
"manageable, and allows different team members to work on different parts of "
"the game."
msgstr ""
"当您编写一款游戏时，您首先要构建核心游戏玩法:主要机制，游戏角色输入，胜败条"
"件。UI要晚一些。如果可能的话，您希望将组成项目的所有元素分开。每个角色都应该"
"在自己的场景中，有自己的脚本，UI元素也应该如此。这可以防止bug，保持项目的可管"
"理性，并允许不同的团队成员在游戏的不同部分工作。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:40
msgid ""
"Once the core gameplay and the UI are ready, you'll need to connect them "
"somehow. In our example, we have the Enemy who attacks the Player at "
"constant time intervals. We want the life bar to update when the Player "
"takes damage."
msgstr ""
"一旦核心游戏玩法和UI准备就绪，您就需要以某种方式将它们连接起来。在我们的示例"
"中，我们有敌人以固定的时间间隔攻击游戏角色。当游戏角色受到伤害时，我们希望生"
"命条能够更新。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:45
msgid "To do this, we will use **signals**."
msgstr "为此，我们将使用 **信号** 。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:49
msgid ""
"Signals are Godot's version of the Observer pattern. They allow us to send "
"out some message. Other nodes can connect to the object that **emits** the "
"signal and receive the information. It's a powerful tool we use a lot for "
"User Interface and achievement systems. You don't want to use them "
"everywhere, though. Connecting two nodes adds some coupling between them. "
"When there's a lot of connections, they become hard to manage. For more "
"information, check out the `signals video tutorial <https://youtu.be/"
"l0BkQxF7X3E>`_ on GDquest."
msgstr ""
"信号是Godot观察者模式的版本。他们允许我们发出一些信息。其他节点可以连接到 "
"**emits(发出)** 信号并接收信息的对象。这是一个强大的工具，我们经常使用用户界"
"面和成就系统。但是，您不希望在任何地方都使用它们。连接两个节点增加了它们之间"
"的耦合。当有很多联系时，就很难管理了。有关更多信息，请在GDquest查看“信号视频"
"教程`signals video tutorial <https://youtu.be/l0BkQxF7X3E>`_ 。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:53
msgid "Download and explore the start project"
msgstr "下载并探索启动项目"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:55
msgid ""
"Download the Godot project: :download:`ui_code_life_bar.zip <files/"
"ui_code_life_bar.zip>`. It contains all the assets and scripts you need to "
"get started. Extract the .zip archive to get two folders: `start` and `end`."
msgstr ""
"下载Godot项目: :download:`ui_code_life_bar.zip <files/ui_code_life_bar."
"zip>`。它包含启动所需的所有资源和脚本。提取.zip归档文件以获得两个文件夹: "
"*start* 和 *end* 。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:58
msgid ""
"Load the ``start`` project in Godot. In the ``FileSystem`` dock, double "
"click on LevelMockup.tscn to open it. It's an RPG game's mockup where 2 "
"characters face each other. The pink enemy attacks and damages the green "
"square at regular time intervals, until its death. Feel free to try out the "
"game: the basic combat mechanics already work. But as the character isn't "
"connected to the life bar, the ``GUI`` doesn't do anything."
msgstr ""
"加载Godot中的 ``start`` 项目。在 ``FileSystem`` 面板中双击LevelMockup.tscn打"
"开它。这是一个RPG游戏的模型，两个角色面对面。粉色的敌人定期攻击并破坏绿色的正"
"方形，直到它死亡。请随意尝试游戏:基本的战斗机制已经工作。但由于角色没有连接到"
"生命条，`GUI`什么也做不了。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:68
msgid ""
"This is typical of how you'd code a game: you implement the core gameplay "
"first, handle the player's death, and only then you'll add the interface. "
"That's because the UI listens to what's happening in the game. So it can't "
"work if other systems aren't in place yet. If you design the UI before you "
"prototype and test the gameplay, chances are it won't work well and you'll "
"have to re-create it from scratch."
msgstr ""
"这是编写游戏代码的典型方式:首先实现核心玩法，处理游戏角色死亡，然后才添加界"
"面。这是因为UI会监听游戏中发生的事情。因此，如果其他系统还没有到位，它就无法"
"工作。如果您在原型和测试游戏玩法之前设计UI，很有可能它不能很好地工作，您必须"
"从头重新创建它。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:71
msgid "The scene contains a background sprite, a GUI, and two characters."
msgstr "场景包含一个背景精灵、一个GUI和两个角色。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:75
msgid "The scene tree, with the GUI scene set to display its children"
msgstr "场景树，用GUI场景设置来显示它的子对象"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:77
msgid ""
"The GUI scene encapsulates all of the game's Graphical User Interface. It "
"comes with a barebones script where we get the path to nodes that exist "
"inside the scene:"
msgstr ""
"GUI场景封装了所有的游戏用户界面。它附带了一个基本的脚本，我们可以在其中获得到"
"场景中存在的节点的路径:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:105
msgid ""
"``number_label`` displays a life count as a number. It's a ``Label`` node"
msgstr "``number_label`` 将生命计数显示为数字。它是一个 ``标签`` 节点"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:107
msgid "``bar`` is the life bar itself. It's a ``TextureProgress`` node"
msgstr "``bar`` 是生命条本身。它是一个 ``TextureProgress`` 节点"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:108
msgid ""
"``tween`` is a component-style node that can animate and control any value "
"or method from any other node"
msgstr ""
"``tween`` 是一个组件样式的节点，它可以动画和控制来自任何其他节点的任何值或方"
"法"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:113
msgid ""
"The project uses a simple organisation that works for game jams and tiny "
"games."
msgstr "该项目使用了一个简单的组织，可以用于游戏jams和小型游戏。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:115
msgid ""
"At the root of the project, in the `res://` folder, you will find the "
"`LevelMockup`. That's the main game scene and the one we will work with. All "
"the components that make up the game are in the `scenes/` folder. The "
"`assets/` folder contains the game sprites and the font for the HP counter. "
"In the `scripts/` folder you will find the enemy, the player, and the GUI "
"controller scripts."
msgstr ""
"在项目的根目录 *res://* 文件夹中，您将找到 *LevelMockup* 。这是主要的游戏场"
"景，也是我们要学习的内容。构成游戏的所有组件都在*scene /*文件夹中。*assets/*"
"文件夹包含游戏精灵和HP计数器的字体。在*scripts/*文件夹中，您会发现敌人、游戏"
"角色和GUI控制器脚本。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:117
msgid ""
"Click the edit scene icon to the right of the node in the scene tree to open "
"the scene in the editor. You'll see the LifeBar and EnergyBar are sub-scenes "
"themselves."
msgstr ""
"单击场景树中节点右侧的edit scene图标，在编辑器中打开场景。您会看到LifeBar和"
"EnergyBar本身就是子场景。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:121
msgid "The scene tree, with the Player scene set to display its children"
msgstr "场景树，用游戏角色场景设置来显示它的子节点"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:124
msgid "Set up the Lifebar with the Player's max\\_health"
msgstr "用游戏角色的最大生命值设置生命条"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:126
msgid ""
"We have to tell the GUI somehow what the player's current health is, to "
"update the lifebar's texture, and to display the remaining health in the HP "
"counter in the top left corner of the screen. To do this we send the "
"player's health to the GUI every time they take damage. The GUI will then "
"update the ``Lifebar`` and ``Number`` nodes with this value."
msgstr ""
"我们必须以某种方式告诉GUI游戏角色当前的健康状况，更新生命条的纹理，并在屏幕左"
"上角的HP计数器中显示剩余的健康状况。为了做到这一点，每当游戏角色的生命值受到"
"伤害时，我们就会将他们的生命值发送给GUI。然后GUI将用这个值更新`Lifebar`和"
"`Number`节点。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:132
msgid ""
"We could stop here to display the number, but we need to initialize the "
"bar's ``max_value`` for it to update in the right proportions. The first "
"step is thus to tell the ``GUI`` what the green character's ``max_health`` "
"is."
msgstr ""
"我们可以在这里停止来显示数字，但是我们需要初始化bar的 ``max_value`` ，让它以"
"正确的比例进行更新。因此，第一步是告诉 ``GUI`` 绿色角色的 ``max_health`` 是什"
"么。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:139
msgid ""
"The bar, a `TextureProgress`, has a `max_value` of `100` by default. If you "
"don't need to display the character's health with a number, you don't need "
"to change its `max_value` property. You send a percentage from the `Player` "
"to the `GUI` instead:  `health / max_health * 100`."
msgstr ""
"默认情况下，这个名为`TextureProgress`的工具条的max_value为`100`。如果不需要用"
"数字显示角色的健康状态，则不需要更改其`max_value`属性。从`Player`向`GUI`发送"
"一个百分比，而不是`health / max_health * 100`。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:143
msgid ""
"Click the script icon to the right of the ``GUI`` in the Scene dock to open "
"its script. In the ``_ready`` function, we're going to store the "
"``Player``'s ``max_health`` in a new variable and use it to set the "
"``bar``'s ``max_value``:"
msgstr ""
"点击场景面板中`GUI`右边的脚本图标，打开脚本。在`_ready`函数中，我们将把"
"`Player`'s`max_health`存储在一个新变量中，并使用它设置`bar`'s`max_value`:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:164
msgid ""
"Let's break it down. ``$\"../Characters/Player\"`` is a shorthand that goes "
"one node up in the scene tree, and retrieves the ``Characters/Player`` node "
"from there. It gives us access to the node. The second part of the "
"statement, ``.max_health``, accesses the ``max_health`` on the Player node."
msgstr ""
"让我们把它分解一下。`$\"../Characters/Player\"`是场景树中一个节点的简写，从那"
"里检索`Characters/Player`节点。它允许我们访问节点。陈述的第二部分，`."
"max_health`，访问游戏角色节点上的`max_health`。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:170
msgid ""
"The second line assigns this value to ``bar.max_value``. You could combine "
"the two lines into one, but we'll need to use ``player_max_health`` again "
"later in the tutorial."
msgstr ""
"第二行将该值赋给`bar.max_value`。您可以将这两行合并为一行，但是我们需要在本教"
"程后面再次使用`player_max_health`。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:174
msgid ""
"``Player.gd`` sets the ``health`` to ``max_health`` at the start of the "
"game, so we could work with this. Why do we still use ``max_health``? There "
"are two reasons:"
msgstr ""
"`Player.gd`在游戏开始时设置`health`到`max_health`，所以我们可以使用这个。为什"
"么我们仍然使用`max_health`？有两个原因:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:178
msgid ""
"We don't have the guarantee that ``health`` will always equal "
"``max_health``: a future version of the game may load a level where the "
"player already lost some health."
msgstr ""
"我们不能保证`health`总是等于`max_health`:未来版本的游戏可能会加载一个游戏角色"
"已经失去健康的关卡。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:184
msgid ""
"When you open a scene in the game, Godot creates nodes one by one, following "
"the order in your Scene dock, from top to bottom. `GUI` and `Player` are not "
"part of the same node branch. To make sure they both exist when we access "
"each other, we have to use the `_ready` function. Godot calls `_ready` right "
"after it loaded all nodes, before the game starts. It's the perfect function "
"to set everything up and prepare the game session. Learn more about _ready: :"
"doc:`scripting_continued`"
msgstr ""
"当您在游戏中打开一个场景时，Godot会按照您的场景面板的顺序，从上到下依次创建节"
"点。`GUI`和`Player`不是同一个节点分支的一部分。为了确保当我们访问对方时它们都"
"存在，我们必须使用`_ready`函数。Godot在加载所有节点之后，在游戏开始之前调用"
"`_ready`。这是一个完美的功能来设置和准备游戏会话。了解关于_ready: :doc:"
"`scripting_continued`的更多信息"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:188
msgid "Update health with a signal when the player takes a hit"
msgstr "当游戏角色受到攻击时，用信号更新生命值"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:190
msgid ""
"Our GUI is ready to receive the ``health`` value updates from the "
"``Player``. To achieve this we're going to use **signals**."
msgstr ""
"我们的GUI已经准备好接收来自`Player`的`health`值更新。为了实现这一点，我们将使"
"用 **信号** 。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:195
msgid ""
"There are many useful built-in signals like `enter_tree` and `exit_tree`, "
"that all nodes emit when they are respectively created and destroyed. You "
"can also create your own using the `signal` keyword. On the `Player` node, "
"you'll find two signals we created for you: `died` and `health_changed`."
msgstr ""
"有许多有用的内置信号，如`enter_tree`和`exit_tree`，当它们分别被创建和销毁时，"
"所有节点都会发出这些信号。您也可以使用`signal`关键字创建您自己的。在`Player`"
"节点上，您会发现我们为您创建的两个信号:`died`和`health_changed`。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:197
msgid ""
"Why don't we directly get the ``Player`` node in the ``_process`` function "
"and look at the health value? Accessing nodes this way creates tight "
"coupling between them. If you did it sparingly it may work. As your game "
"grows bigger, you may have many more connections. If you get nodes this way "
"it gets complex quickly. Not only that: you need to listen to the state "
"change constantly in the ``_process`` function. This check happens 60 times "
"a second and you'll likely break the game because of the order in which the "
"code runs."
msgstr ""
"我们为什么不直接在`_process`函数中获取`Player`节点并查看健康值呢?以这种方式访"
"问节点会在节点之间产生紧密耦合。如果您少做一点，它可能会起作用。当您的游戏越"
"来越大，您可能会有更多的连接。如果您用这种方法得到节点，它会很快变得复杂。不"
"仅如此:您需要在`_process`函数中不断地监听状态变化。这种检查每秒进行60次，您可"
"能会因为代码运行的顺序而中断游戏。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:206
msgid ""
"On a given frame you may look at another node's property *before* it was "
"updated: you get a value from the last frame. This leads to obscure bugs "
"that are hard to fix. On the other hand, a signal is emitted right after a "
"change happened. It **guarantees** you're getting a fresh piece of "
"information. And you will update the state of your connected node *right "
"after* the change happened."
msgstr ""
"在给定的框架中，您可以在更新 *前* 查看另一个节点的属性:从最后一个框架中获取"
"值。这会导致难以修复的模糊bug。另一方面，一个信号在发生变化后立即发出。它 **"
"保证** 您得到了一个新的信息。您将在更改 *发生后* 立即更新连接节点的状态。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:215
msgid ""
"The Observer pattern, that signals derive from, still adds a bit of coupling "
"between node branches. But it's generally lighter and more secure than "
"accessing nodes directly to communicate between two separate classes. It can "
"be okay for a parent node to get values from its children. But you'll want "
"to favor signals if you're working with two separate branches. Read Game "
"Programming Patterns for more information on the `Observer pattern <http://"
"gameprogrammingpatterns.com/observer.html>`_. The `full book <http://"
"gameprogrammingpatterns.com/contents.html>`_ is available online for free."
msgstr ""
"从信号派生而来的观察者模式仍然在节点分支之间添加了一些耦合。但是它通常比直接"
"访问节点来在两个单独的类之间通信更轻、更安全。父节点可以从其子节点获取值。但"
"是，如果您使用的是两个独立的分支，那么您会希望使用信号。在`Observer pattern "
"<http://gameprogrammingpatterns.com/observer.html>`_ 阅读游戏编程模式以获得更"
"多信息。`这本书 <http://gameprogrammingpatterns.com/contents.html>`_ 的全文可"
"在网上免费获得。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:219
msgid ""
"With this in mind, let's connect the ``GUI`` to the ``Player``. Click on the "
"``Player`` node in the scene dock to select it. Head down to the Inspector "
"and click on the Node tab. This is the place to connect nodes to listen to "
"the one you selected."
msgstr ""
"考虑到这一点，让我们将`GUI`连接到`Playe`。点击场景面板中的`Player`节点来选择"
"它。转到属性面板，单击Node选项卡。这是连接节点侦听所选节点的地方。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:224
msgid "The first section lists custom signals defined in ``Player.gd``:"
msgstr "第一部分列出了在`Player.gd`中定义的自定义信号:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:226
msgid ""
"``died`` is emitted when the character died. We will use it in a moment to "
"hide the UI."
msgstr "`died`在角色死亡时发出。我们稍后将使用它来隐藏UI。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:228
msgid "``health_changed`` is emitted when the character got hit."
msgstr "`health_changed`在角色被击中时发出。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:232
msgid "We're connecting to the health\\_changed signal"
msgstr "我们连接到health\\_changed信号"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:234
msgid ""
"Select ``health_changed`` and click on the Connect button in the bottom "
"right corner to open the Connect Signal window. On the left side you can "
"pick the node that will listen to this signal. Select the ``GUI`` node. The "
"right side of the screen lets you pack optional values with the signal. We "
"already took care of it in ``Player.gd``. In general I recommend not to add "
"too many arguments using this window as they're less convenient than doing "
"it from the code."
msgstr ""
"选择`health_changed`，然后单击右下角的Connect按钮，打开Connect信号窗口。在左"
"侧，您可以选择监听此信号的节点。选择`GUI`节点。屏幕的右侧允许您将可选值与信号"
"打包。我们已经在`Player.gd`中处理过了。一般来说，我建议不要使用这个窗口添加太"
"多的参数，因为它们比从代码中添加更不方便。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:244
msgid "The Connect Signal window with the GUI node selected"
msgstr "选择GUI节点的连接信号窗口"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:248
msgid ""
"You can optionally connect nodes from the code. However doing it from the "
"editor has two advantages:"
msgstr "您可以选择从代码中连接节点。然而，编辑这样做有两个好处:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:250
msgid "Godot can write new callback functions for you in the connected script"
msgstr "Godot可以在连接的脚本中为您编写新的回调函数"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:251
msgid ""
"An emitter icon appears next to the node that emits the signal in the Scene "
"dock"
msgstr "一个发射器图标出现在场景基座中发出信号的节点旁边"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:253
msgid ""
"At the bottom of the window you will find the path to the node you selected. "
"We're interested in the second row called \"Method in Node\". This is the "
"method on the ``GUI`` node that gets called when the signal is emitted. This "
"method receives the values sent with the signal and lets you process them. "
"If you look to the right, there is a \"Make Function\" radio button that is "
"on by default. Click the connect button at the bottom of the window. Godot "
"creates the method inside the ``GUI`` node. The script editor opens with the "
"cursor inside a new ``_on_Player_health_changed`` function."
msgstr ""
"在窗口的底部，您将找到您选择的节点的路径。我们对第二行`Node中的方法`感兴趣。"
"这是`GUI`节点上在发出信号时调用的方法。此方法接收随信号发送的值，并允许您处理"
"它们。如果您向右看，默认情况下有一个`Make Function`单选按钮。单击窗口底部的"
"connect按钮。Godot在`GUI`节点中创建方法。脚本编辑器在一个新的"
"`_on_Player_health_changed`函数中打开光标。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:265
msgid ""
"When you connect nodes from the editor, Godot generates a method name with "
"the following pattern: ``_on_EmitterName_signal_name``. If you wrote the "
"method already, the \"Make Function\" option will keep it. You may replace "
"the name with anything you'd like."
msgstr ""
"当您从编辑器中连接节点时，Godot会生成一个方法名，其模式是:"
"`_on_EmitterName_signal_name`。如果您已经编写了该方法，`Make Function`选项将"
"保留它。您可以用任何您想要的东西来代替这个名字。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:272
msgid "Godot writes the callback method for you and takes you to it"
msgstr "Godot为您编写回调方法并将您带到它"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:274
#, fuzzy
msgid ""
"Inside the parentheses after the function name, add a ``player_health`` "
"argument. When the player emits the ``health_changed`` signal, it will send "
"its current ``health`` alongside it. Your code should look like:"
msgstr ""
"在函数名后面的参数中，添加一个`player_health`参数。当游戏角色发出"
"`health_changed`信号时，它会将当前的`health`发送到旁边。您的代码应该如下所示:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:292
msgid ""
"The engine does not convert PascalCase to snake_case, for C# examples we'll "
"be using PascalCase for method names & camelCase for method parameters, "
"which follows the official `C# naming conventions. <https://docs.microsoft."
"com/en-us/dotnet/standard/design-guidelines/capitalization-conventions>`_"
msgstr ""
"引擎不会将PascalCase转换成snake_case，对于C#示例，我们将使用PascalCase来表示"
"方法名，而camelCase用于方法参数，这些参数遵循 `官方的C#命名约定。 <https://"
"docs.microsoft.com/en-us/dotnet/standard/design-guidelines/capitalization-"
"conventions>`_"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:299
msgid ""
"In Player.gd, when the Player emits the health\\_changed signal, it also "
"sends its health value"
msgstr ""
"在Player.gd。当游戏角色发出health\\_changed信号时，它也会发送其health值"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:302
msgid ""
"Inside ``_on_Player_health_changed``, let's call a second function called "
"``update_health`` and pass it the ``player_health`` variable."
msgstr ""
"在`_on_Player_health_changed`中，我们调用第二个函数`update_health`，并将"
"`player_health`变量传递给它。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:307
msgid ""
"We could directly update the health value on `LifeBar` and `Number`. There "
"are two reasons to use this method instead:"
msgstr "我们可以直接在`LifeBar`和`Number`上更新健康值。使用这种方法有两个原因:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:309
msgid ""
"The name makes it clear for our future selves and teammates that when the "
"player took damage, we update the health count on the GUI"
msgstr ""
"这个名字清楚地告诉我们未来的自己和队友，当游戏角色受到伤害时，我们会更新GUI的"
"生命值"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:310
msgid "We will reuse this method a bit later"
msgstr "稍后我们会重复使用这个方法"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:312
msgid ""
"Create a new ``update_health`` method below ``_on_Player_health_changed``. "
"It takes a new\\_value as its only argument:"
msgstr ""
"在`_on_Player_health_changed`下面创建一个新的`update_health`方法。它的唯一参"
"数是一个新的\\_value:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:327
msgid "This method needs to:"
msgstr "此方法需要:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:329
msgid ""
"set the ``Number`` node's ``text`` to ``new_value`` converted to a string"
msgstr "将`Number`节点的`text`设置为`new_value`转换为字符串"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:331
msgid "set the ``TextureProgress``'s ``value`` to ``new_value``"
msgstr "将`TextureProgress`的`value`设置为`new_value`"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:350
msgid ""
"``str`` is a built-in function that converts about any value to text. "
"``Number``'s ``text`` property requires a string, so we can't assign it to "
"``new_value`` directly"
msgstr ""
"``str`` 是一个内置函数，可以将任何值转换为文本。 ``Number`` 的 ``text`` 属性"
"需要一个字符串，所以我们不能直接将它分配给 ``new_value``"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:354
msgid ""
"Also call ``update_health`` at the end of the ``_ready`` function to "
"initialize the ``Number`` node's ``text`` with the right value at the start "
"of the game. Press F5 to test the game: the life bar updates with every "
"attack!"
msgstr ""
"还可以在 ``_ready`` 函数末尾调用 ``update_health`` 函数，以在游戏开始时用正确"
"的值初始化 ``Number`` 节点的 ``text`` 。按F5测试游戏:生命条更新与每次攻击!"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:361
msgid ""
"Both the Number node and the TextureProgress update when the Player takes a "
"hit"
msgstr "当游戏角色受到攻击时，数字节点和TextureProgress都会进行更新"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:365
msgid "Animate the loss of life with the Tween node"
msgstr "用渐变节点动画生命的损失"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:367
msgid ""
"Our interface is functional, but it could use some animation. That's a good "
"opportunity to introduce the ``Tween`` node, an essential tool to animate "
"properties. ``Tween`` animates anything you'd like from a start to an end "
"state over a certain duration. For example, it can animate the health on the "
"``TextureProgress`` from its current level to the ``Player``'s new "
"``health`` when the character takes damage."
msgstr ""
"我们的界面是功能性的，但它可以使用一些动画。这是引入`Tween`节点的好机会，这是"
"动画属性的一个基本工具。`Tween`在一定的持续时间内，使您从开始到结束的任何状态"
"都具有动画效果。例如，当角色受到伤害时，它可以将`TextureProgress`上的生命值从"
"当前级别激活到`Player`的新`health`。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:374
msgid ""
"The ``GUI`` scene already contains a ``Tween`` child node stored in the "
"``tween`` variable. Let's now use it. We have to make some changes to "
"``update_health``."
msgstr ""
"`GUI`场景已经包含一个`Tween`子节点存储在`Tween`变量中。现在让我们使用它。我们"
"必须对`update_health`做一些修改。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:378
msgid ""
"We will use the ``Tween`` node's ``interpolate_property`` method. It takes "
"seven arguments:"
msgstr "我们将使用`Tween` `node` `interpolate_property`方法。它需要七个参数:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:381
msgid "A reference to the node who owns the property to animate"
msgstr "对拥有该属性的节点进行动画的引用"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:382
msgid "The property's identifier as a string"
msgstr "属性的标识符作为字符串"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:383
msgid "The starting value"
msgstr "起始值"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:384
msgid "The end value"
msgstr "端值"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:385
msgid "The animation's duration in seconds"
msgstr "动画以秒为单位的持续时间"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:386
msgid "The type of the transition"
msgstr "过渡的类型"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:387
msgid "The easing to use in combination with the equation."
msgstr "与方程结合使用的缓和。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:389
#, fuzzy
msgid ""
"The last two arguments combined correspond to an easing equation. This "
"controls how the value evolves from the start to the end point."
msgstr ""
"最后两个参数组合起来相当于一个`easing equation <#>`__。这控制了值从开始到结束"
"的演化过程。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:393
msgid ""
"Click the script icon next to the ``GUI`` node to open it again. The "
"``Number`` node needs text to update itself, and the ``Bar`` needs a float "
"or an integer. We can use ``interpolate_property`` to animate a number, but "
"not to animate text directly. We're going to use it to animate a new ``GUI`` "
"variable named ``animated_health``."
msgstr ""
"单击`GUI`节点旁边的脚本图标，再次打开它。`Number`节点需要文本来更新自己，"
"`Bar`需要一个浮点数或整数。我们可以使用`interpolate_property 插值属性`来动画"
"一个数字，但不能直接动画文本。我们将使用它来动画一个新的`GUI`变量命名为"
"`animated_health`。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:399
msgid ""
"At the top of the script, define a new variable, name it "
"``animated_health``, and set its value to 0. Navigate back to the "
"``update_health`` method and clear its content. Let's animate the "
"``animated_health`` value. Call the ``Tween`` node's "
"``interpolate_property`` method:"
msgstr ""
"在脚本的顶部，定义一个新变量，将其命名为`animated_health`，并将其值设置为0。"
"导航回`update_health`方法并清除其内容。让我们对`animated_health`值进行动画处"
"理。调用`ween` `node` `interpolate_property`方法:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:421
msgid "Let's break down the call:"
msgstr "让我们把调用分解一下:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:427
msgid ""
"We target ``animated_health`` on ``self``, that is to say the ``GUI`` node. "
"``Tween``'s interpolate\\_property takes the property's name as a string. "
"That's why we write it as ``\"animated_health\"``."
msgstr ""
"我们的目标是`self`上的`animated_health`，也就是说`GUI`节点。`Tween`'s的插值"
"\\_property将属性的名称作为字符串。这就是为什么我们把它写成"
"`animated_health`。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:435
msgid ""
"The starting point is the current value the bar's at. We still have to code "
"this part, but it's going to be ``animated_health``. The end point of the "
"animation is the ``Player``'s ``health`` after the ``health_changed``: "
"that's ``new_value``. And ``0.6`` is the animation's duration in seconds."
msgstr ""
"起点是该条的当前值。我们仍然需要对这部分进行编码，但它将是`animated_health`。"
"动画的结束点是在`health_changed`之后的`Player`的`health`:这是`new_value`。"
"`0.6`是动画的持续时间，以秒为单位。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:445
msgid ""
"The last two arguments are constants from the ``Tween`` class. "
"``TRANS_LINEAR`` means the animation should be linear. ``EASE_IN`` doesn't "
"do anything with a linear transition, but we must provide this last argument "
"or we'll get an error."
msgstr ""
"最后两个参数是`Tween`类中的常量。`TRANS_LINEAR`意味着动画应该是线性的。"
"`EASE_IN`对于线性变换没有任何作用，但我们必须提供最后一个参数，否则会得到一个"
"错误。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:450
msgid ""
"The animation will not play until we activated the ``Tween`` node with "
"``tween.start()``. We only have to do this once if the node is not active. "
"Add this code after the last line:"
msgstr ""
"动画将不会播放，直到我们用`tween.start() `激活`Tween`节点。如果节点不活动，我"
"们只需要这样做一次。在最后一行之后添加以下代码:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:469
msgid ""
"Although we could animate the `health` property on the `Player`, we "
"shouldn't. Characters should lose life instantly when they get hit. It makes "
"it a lot easier to manage their state, like to know when one died. You "
"always want to store animations in a separate data container or node. The "
"`tween` node is perfect for code-controlled animations. For hand-made "
"animations, check out `AnimationPlayer`."
msgstr ""
"虽然我们可以在`Player`上激活`health`属性，但我们不应该。角色一旦被击中就会立"
"即失去生命。这使得管理他们的状态变得容易得多，比如知道他们的死亡时间。您总是"
"希望将动画存储在单独的数据容器或节点中。补间节点非常适合代码控制的动画。对于"
"手工制作的动画，请查看`AnimationPlayer`。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:472
msgid "Assign the animated\\_health to the LifeBar"
msgstr "将动画\\_health分配给LifeBar"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:474
msgid ""
"Now the ``animated_health`` variable animates but we don't update the actual "
"``Bar`` and ``Number`` nodes anymore. Let's fix this."
msgstr ""
"现在`animated_health`变量会启动，但是我们不再更新实际的`Bar`和`Number`节点。"
"让我们解决这个问题。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:477
msgid "So far, the update\\_health method looks like this:"
msgstr "到目前为止，update\\_health方法如下:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:501
msgid ""
"In this specific case, because ``number_label`` takes text, we need to use "
"the ``_process`` method to animate it. Let's now update the ``Number`` and "
"``TextureProgress`` nodes like before, inside of ``_process``:"
msgstr ""
"在这种情况下，因为`number_label`接受文本，我们需要使用`_process`方法来动画"
"它。现在让我们更新`Number`和`TextureProgress`节点像以前一样，在`_process`里"
"面:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:523
msgid ""
"`number_label` and `bar` are variables that store references to the `Number` "
"and `TextureProgress` nodes."
msgstr ""
"`number_label`和`bar`是存储对`Number`和`TextureProgress`节点的引用的变量。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:525
msgid ""
"Play the game to see the bar animate smoothly. But the text displays decimal "
"number and looks like a mess. And considering the style of the game, it'd be "
"nice for the life bar to animate in a choppier fashion."
msgstr ""
"玩这个游戏，可以看到条形图的动画是流畅的。但是文本显示的是十进制数，看起来很"
"乱。考虑到游戏的风格，生命条以一种更加起伏不定的方式进行动画是很好的。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:531
msgid "The animation is smooth, but the number is broken"
msgstr "动画很流畅，但是数字被打破了"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:533
msgid ""
"We can fix both problems by rounding out ``animated_health``. Use a local "
"variable named ``round_value`` to store the rounded ``animated_health``. "
"Then assign it to ``number_label.text`` and ``bar.value``:"
msgstr ""
"我们可以通过舍入`animated_health`来解决这两个问题。使用一个名为`round_value`"
"的局部变量来存储完整的`animated_health`。然后将其赋值给`number_label.text`和"
"`bar.value`:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:555
msgid "Try the game again to see a nice blocky animation."
msgstr "再次尝试游戏，看看一个不错的方块动画。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:559
msgid "By rounding out animated\\_health, we kill two birds with one stone"
msgstr "通过完成animated\\_health，我们达到了一石二鸟的效果"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:563
msgid ""
"Every time the player takes a hit, the ``GUI`` calls "
"``_on_Player_health_changed``, which in turn calls ``update_health``. This "
"updates the animation and the ``number_label`` and ``bar`` follow in "
"``_process``. The animated life bar that shows the health going down "
"gradually is a trick. It makes the GUI feel alive. If the ``Player`` takes 3 "
"damage, it happens in an instant."
msgstr ""
"每当游戏角色受到攻击时， ``GUI`` 就会调用 ``_on_Player_health_changed`` ，然"
"后调用 ``update_health``。这将更新动画和 ``number_label`` 和 ``bar`` 跟随 "
"``_process``。显示健康逐渐下降的动画生命条是一个技巧。它让GUI感觉自己是活着"
"的。如果 ``Player`` 受到3点伤害，就会在瞬间发生。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:571
msgid "Fade the bar when the Player dies"
msgstr "当游戏角色死亡时，淡出条形栏"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:573
msgid ""
"When the green character dies, it plays a death animation and fades out. At "
"this point, we shouldn't show the interface anymore. Let's fade the bar as "
"well when the character died. We will reuse the same ``Tween`` node as it "
"manages multiple animations in parallel for us."
msgstr ""
"当绿色角色死亡时，它会播放死亡动画并淡出。此时，我们不应该再显示界面。当角色"
"死亡时，让我们也淡出栏。我们将重用相同的`Tween`节点，因为它为我们同时管理多个"
"动画。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:578
msgid ""
"First, the ``GUI`` needs to connect to the ``Player``'s ``died`` signal to "
"know when it died. Press :kbd:`F1` to jump back to the 2D Workspace. Select "
"the ``Player`` node in the Scene dock and click on the Node tab next to the "
"Inspector."
msgstr ""
"首先，``GU`` 需要连接到 ``Player`` 的 ``died`` 信号，以知道它何时死亡。按 :"
"kbd:`F1` 跳转回2D工作区。在场景面板中选择 ``Player`` 节点，然后单击属性面板旁"
"边的节点选项卡。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:583
msgid "Find the ``died`` signal, select it, and click the Connect button."
msgstr "找到 ``died`` 信号，选择它，然后点击连接按钮。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:587
msgid "The signal should already have the Enemy connected to it"
msgstr "这个信号应该已经连上了敌人"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:589
msgid ""
"In the Connecting Signal window, connect to the ``GUI`` node again. The Path "
"to Node should be ``../../GUI`` and the Method in Node should show "
"``_on_Player_died``. Leave the Make Function option on and click Connect at "
"the bottom of the window. This will take you to the ``GUI.gd`` file in the "
"Script Workspace."
msgstr ""
"在连接信号窗口中，再次连接到`GUI`节点。节点的路径应该是`../../GUI`并且节点中"
"的方法应该显示`_on_Player_died`。保留Make函数选项并单击窗口底部的Connect。这"
"将把您带到脚本工作空间中的`GUI.gd`文件中。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:597
msgid "You should get these values in the Connecting Signal window"
msgstr "您应该在连接信号窗口中获得这些值"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:601
msgid ""
"You should see a pattern by now: every time the GUI needs a new piece of "
"information, we emit a new signal. Use them wisely: the more connections you "
"add, the harder they are to track."
msgstr ""
"您现在应该看到一个模式:每当GUI需要一条新的信息时，我们都会发出一个新的信号。"
"明智地使用它们:添加的连接越多，跟踪它们就越困难。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:603
msgid ""
"To animate a fade on a UI element, we have to use its ``modulate`` property. "
"``modulate`` is a ``Color`` that multiplies the colors of our textures."
msgstr ""
"要使UI元素的淡入动画，我们必须使用它的 ``modulate`` 属性。``modulate`` 是一"
"种 ``Color``，它可以使我们的纹理颜色倍增。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:609
msgid ""
"`modulate` comes from the `CanvasItem` class, All 2D and UI nodes inherit "
"from it. It lets you toggle the visibility of the node, assign a shader to "
"it, and modify it using a color with `modulate`."
msgstr ""
"``modulate`` 来自 ``CanvasItem`` 类，所有2D和UI节点都继承自它。它允许您切换节"
"点的可见性，给它分配一个着色器，然后用一个带有``modulate`` 的颜色来修改它。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:611
msgid ""
"``modulate`` takes a ``Color`` value with 4 channels: red, green, blue and "
"alpha. If we darken any of the first three channels it darkens the "
"interface. If we lower the alpha channel, our interface fades out."
msgstr ""
"`modulate`具有`Color`值，有4个通道:红色、绿色、蓝色和alpha。如果我们使前三个"
"通道中的任何一个都变暗，它就会使界面变暗。如果我们降低alpha通道，我们的界面就"
"会消失。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:615
msgid ""
"We're going to tween between two color values: from a white with an alpha of "
"``1``, that is to say at full opacity, to a pure white with an alpha value "
"of ``0``, completely transparent. Let's add two variables at the top of the "
"``_on_Player_died`` method and name them ``start_color`` and ``end_color``. "
"Use the ``Color()`` constructor to build two ``Color`` values."
msgstr ""
"我们将在两个颜色值之间进行渐变:从alpha值为`1`的白色，也就是说完全不透明，到"
"alpha值为`0`的纯白色，完全透明。让我们在`_on_player_die`方法的顶部添加两个变"
"量，并将它们命名为`start_color`和`end_color`。使用`Color()`构造函数构建两个"
"`Color`值。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:637
msgid ""
"``Color(1.0, 1.0, 1.0)`` corresponds to white. The fourth argument, "
"respectively ``1.0`` and ``0.0`` in ``start_color`` and ``end_color``, is "
"the alpha channel."
msgstr ""
"`Color(1.0, 1.0, 1.0)`对应于白色。第四个参数，分别是`start_color`和"
"`end_color`中的`1.0`和`0.0`，是alpha通道。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:641
msgid ""
"We then have to call the ``interpolate_property`` method of the ``Tween`` "
"node again:"
msgstr "然后我们必须再次调用`Tween`节点的`interpolate_property`方法:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:654
msgid ""
"This time, we change the ``modulate`` property and have it animate from "
"``start_color`` to the ``end_color``. The duration is of one second, with a "
"linear transition. Here again, because the transition is linear, the easing "
"does not matter. Here's the complete ``_on_Player_died`` method:"
msgstr ""
"这一次，我们改变了`modulate`属性，并将其从`start_color`动画为`end_color`。持"
"续时间为1秒，线性过渡。再一次，因为过渡是线性的，宽松并不重要。下面是完整的"
"`_on_Player_died`方法:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:679
msgid "And that is it. You may now play the game to see the final result!"
msgstr "就是这样。您现在可以玩游戏，看看最后的结果!"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:683
msgid "The final result. Congratulations for getting there!"
msgstr "最终结果。恭喜您做到了!"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:687
msgid ""
"Using the exact same techniques, you can change the color of the bar when "
"the Player gets poisoned, turn the bar red when its health drops low, shake "
"the UI when they take a critical hit... the principle is the same: emit a "
"signal to forward the information from the `Player` to the `GUI` and let the "
"`GUI` process it."
msgstr ""
"使用完全相同的技术，当游戏角色中毒时，您可以改变工具条的颜色，当生命值降低时"
"将工具条变成红色，当他们受到致命一击时摇动UI……原理是一样的:发射信号将信息从"
"`Player`转发到`GUI`，然后让`GUI`处理它。"
