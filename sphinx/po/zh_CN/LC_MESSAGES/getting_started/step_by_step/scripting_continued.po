# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2018, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-07-26 10:06+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:4
msgid "Scripting (continued)"
msgstr "脚本（续）"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:7
msgid "Processing"
msgstr "流程"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:9
msgid ""
"Several actions in Godot are triggered by callbacks or virtual functions, so "
"there is no need to write code that runs all the time."
msgstr ""
"Godot中的许多动作是由回调函数或虚函数触发，所以不需要编写那些总是运行的代码。"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:12
msgid ""
"However, it is still common to need a script to be processed on every frame. "
"There are two types of processing: idle processing and physics processing."
msgstr ""
"但是，在每一帧上都需要处理脚本仍然很常见。有两种类型的处理：空闲处理和物理处"
"理。"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:16
msgid ""
"Idle processing is activated when the method :ref:`Node._process() "
"<class_Node__process>` is found in a script. It can be turned off and on "
"with the :ref:`Node.set_process() <class_Node_set_process>` function."
msgstr ""
"当 :ref:`Node._process() <class_Node__process>` 方法在函数中被定义处理流程就"
"会被激活.。可以通过 :ref:`Node.set_process() <class_Node_set_process>` 函数来"
"进行开关."

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:20
msgid ""
"This method will be called every time a frame is drawn, so it's fully "
"dependent on how many frames per second (FPS) the application is running at:"
msgstr ""
"每次绘制时都会调用此方法，因此调用频率完全取决于应用程序在每秒运行的帧数"
"（FPS）："

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:37
#, fuzzy
msgid ""
"The delta parameter contains the time elapsed in seconds, as a floating "
"point, since the previous call to ``_process()``."
msgstr ""
"delta参数包含自从上一次调用``_process（）``以来以秒为单位的时间，类型是浮点"
"数。"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:40
msgid ""
"This parameter can be used to make sure things always take the same amount "
"of time, regardless of the game's FPS."
msgstr "无论游戏的FPS如何，这个参数都可以用来确保事务总是占用相同的时间。"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:43
msgid ""
"For example, movement is often multiplied with a time delta to make movement "
"speed both constant and independent from the frame rate."
msgstr "例如，运动常常乘以时间增量以使运动速度既恒定又独立于帧速率。"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:46
#, fuzzy
msgid ""
"Physics processing with ``_physics_process()`` is similar, but it should be "
"used for processes that must happen before each physics step, such as "
"controlling a character. It always runs before a physics step and it is "
"called at fixed time intervals: 60 times per second by default. You can "
"change the interval from the Project Settings, under Physics -> Common -> "
"Physics Fps."
msgstr ""
"使用``_physics_process()``进行物理处理是类似的，但它发生的进程必须是在应用于"
"每个物理步骤之前，比如控制一个角色。它始终在物理步骤之前运行，并以固定的时间"
"间隔调用：默认情况下每秒60次。您可以从项目设置中更改物理 - >常用 - >物理Fps下"
"的时间间隔。"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:52
msgid ""
"The function ``_process()``, however, is not synced with physics. Its frame "
"rate is not constant and is dependent on hardware and game optimization. Its "
"execution is done after the physics step on single-threaded games."
msgstr ""
"函数``_process()``不与物理同步。它的帧频不是恒定的，并且取决于硬件和游戏优"
"化。在单线程游戏中它的执行是在的物理步骤之后完成的。"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:55
msgid ""
"A simple way to test this is to create a scene with a single Label node, "
"with the following script:"
msgstr "测试此方法的一种简单方法是使用以下脚本创建具有单个标签节点的场景："

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:82
msgid "Which will show a counter increasing each frame."
msgstr "这将显示一个每帧增加的计数器。"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:85
msgid "Groups"
msgstr "分组"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:87
msgid ""
"Nodes can be added to groups, as many as desired per node, and is a useful "
"feature for organizing large scenes. There are two ways to do this. The "
"first is from the UI, from the Groups button under the Node panel:"
msgstr ""
"随着节点数的增加，一个有用的管理方式是把节点添加到组里。有两种方法可以做到这"
"一点。第一个通过UI实现，在Node面板下的Groups按钮："

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:92
msgid ""
"And the second way is from code. One example would be to tag scenes which "
"are enemies:"
msgstr "第二种方法是通过代码实现。下面的例子是在场景中标记出敌人："

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:110
msgid ""
"This way, if the player is discovered sneaking into a secret base, all "
"enemies can be notified about its alarm sounding by using :ref:`SceneTree."
"call_group() <class_SceneTree_call_group>`:"
msgstr ""
"这样一来, 如果玩家在潜入一个秘密基地时被发现时, 可以通过使用 :ref:`SceneTree."
"call_group() <class_SceneTree_call_group>` 发出的警报声来通知到所有的敌人："

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:127
msgid ""
"The above code calls the function ``player_was_discovered`` on every member "
"of the group ``enemies``."
msgstr ""
"上面的代码会使在群组 ``enemies`` 里的每个成员都会调用函数"
"``player_was_discovered``。"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:130
msgid ""
"It is also possible to get the full list of ``enemies`` nodes by calling :"
"ref:`SceneTree.get_nodes_in_group() <class_SceneTree_get_nodes_in_group>`:"
msgstr ""
"通过调用：ref:`SceneTree.get_nodes_in_group() "
"<class_SceneTree_get_nodes_in_group>`也可以获得``enemies``节点的完整列表："

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:143
msgid ""
"The :ref:`SceneTree <class_SceneTree>` class provides many useful methods, "
"like interacting with scenes, their node hierarchy and groups of nodes. It "
"allows you to easily switch scenes or reload them, to quit the game or pause "
"and unpause it. It even comes with interesting signals. So check it out if "
"you got some time!"
msgstr ""
"类 :ref:`SceneTree <class_SceneTree>` 提供了很多有用的方法，例如与场景、场景"
"中节点的层次、节点分组交互。它让你可以很方便切换场景，重载场景，退出游戏，暂"
"停和继续游戏。它还有一些有趣的信号，如果你有空可以详细去查看！"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:151
msgid "Notifications"
msgstr "通知"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:153
msgid ""
"Godot has a system of notifications. These are usually not needed for "
"scripting, as it's too low-level and virtual functions are provided for most "
"of them. It's just good to know they exist. For example, you may add an :ref:"
"`Object._notification() <class_Object__notification>` function in your "
"script:"
msgstr ""
"Godot 有一个通知系统。这个是非常底层的虚函数，通常不需要放入代码里。只需要知"
"道有这个系统的存在。例如，你可以添加 :ref:`Object._notification() "
"<class_Object__notification>` 到你的代码里："

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:188
msgid ""
"The documentation of each class in the :ref:`Class Reference <toc-class-"
"ref>` shows the notifications it can receive. However, in most cases "
"GDScript provides simpler overrideable functions."
msgstr ""
"在 :ref:`Class Reference <toc-class-ref>` 里的所有类的文档里说明了他们能接受"
"的通知。然而，在GDScript里有类似的更简便的可重写函数。"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:193
msgid "Overrideable functions"
msgstr "可覆写的函数"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:195
msgid ""
"Such overrideable functions, which are described as follows, can be applied "
"to nodes:"
msgstr "以下所描述的这些可覆写的函数，能够应用于节点："

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:267
msgid ""
"As mentioned before, it's better to use these functions instead of the "
"notification system."
msgstr "如前所诉，用这些函数替代通知系统是更好的选择。"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:271
msgid "Creating nodes"
msgstr "创建节点"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:273
msgid ""
"To create a node from code, call the ``.new()`` method, like for any other "
"class-based datatype. For example:"
msgstr ""
"如果要用代码方式创建一个节点， 只需调用“.new()”方法即可，这也适用于其他的基于"
"类的数据类型。举例说明："

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:297
msgid ""
"To delete a node, be it inside or outside the scene, ``free()`` must be used:"
msgstr "若要删除一个节点，无论其是否在场景树之内，“free()”方法一定会被调用:"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:313
msgid ""
"When a node is freed, it also frees all its children nodes. Because of this, "
"manually deleting nodes is much simpler than it appears. Free the base node "
"and everything else in the subtree goes away with it."
msgstr ""
"当一个节点被释放时, 它也会释放其所有子节点。因此, 手动删除节点比看起来简单得"
"多。释放基节点, 那么子树中的其他所有东西都会随之消失。"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:317
msgid ""
"A situation might occur where we want to delete a node that is currently "
"\"blocked\", because it is emitting a signal or calling a function. This "
"will crash the game. Running Godot with the debugger will often catch this "
"case and warn you about it."
msgstr ""
"当我们要删除一个当前处于“阻塞”状态的节点时，就可能发生这种情况， 因为此时它正"
"在发出信号或者在调用一个函数。这会导致游戏崩溃。使用调试器运行Godot通常能捕获"
"这种情况并向你发出警告。"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:322
msgid ""
"The safest way to delete a node is by using :ref:`Node.queue_free() "
"<class_Node_queue_free>`. This erases the node safely during idle."
msgstr ""
"删除一个节点最安全的方法是使用: ref: \"节点. queue_free () "
"<class_Node_queue_free>\"。这会在程序空闲时安全地擦除该节点。"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:340
msgid "Instancing scenes"
msgstr "实例化场景"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:342
msgid ""
"Instancing a scene from code is done in two steps. The first one is to load "
"the scene from your hard drive:"
msgstr "用代码方法实例化一个场景分为两步。 第一个步骤是从你的硬盘中加载场景："

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:355
#, fuzzy
msgid ""
"Preloading it can be more convenient, as it happens at parse time (GDScript "
"only):"
msgstr "预加载它可以更方便, 因为它发生在语法解析的时候:"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:362
msgid ""
"But ``scene`` is not yet a node. It's packed in a special resource called :"
"ref:`PackedScene <class_PackedScene>`. To create the actual node, the "
"function :ref:`PackedScene.instance() <class_PackedScene_instance>` must be "
"called. This will return the tree of nodes that can be added to the active "
"scene:"
msgstr ""
"但是``场景``还不是一个节点，它被打包在一类称为:ref:"
"`PackedScene<class_PackedScene>`（封包场景）的资源。要想创建实际的节点，就必"
"须调用函数:ref:`PackedScene.instance() <class_PackedScene_instance>`。它会返"
"回能够被添加到该活动 场景中的节点树："

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:380
#, fuzzy
msgid ""
"The advantage of this two-step process is that a packed scene may be kept "
"loaded and ready to use so that you can create as many instances as desired. "
"This is especially useful to quickly instance several enemies, bullets, and "
"other entities in the active scene."
msgstr ""
"两步处理的好处是打包好的场景可以保持被加载并且可以直接使用，因此你可以按照你"
"的想法不断创造实例。这对在一个激活的场景里快速的添加例如一些敌人、子弹或其它"
"实体时是很实用的。"
