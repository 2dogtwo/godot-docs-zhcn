# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2019, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-07-17 12:25+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../docs/getting_started/workflow/best_practices/node_alternatives.rst:4
msgid "When and how to avoid using nodes for everything"
msgstr "何时以及如何避免在任何情况下都使用节点"

#: ../../docs/getting_started/workflow/best_practices/node_alternatives.rst:7
msgid ""
"Nodes are cheap to produce, but even they have their limits. A project may "
"have tens of thousands of nodes all doing things. The more complex their "
"behavior though, the larger the strain each one adds to a project's "
"performance."
msgstr ""
"节点生产成本低廉，但是他们也有一定的局限性。一个项目可能有成千上万个节点在做"
"所有事情。他们的行为越复杂，每个节点对项目性能增加的压力就越大。"

#: ../../docs/getting_started/workflow/best_practices/node_alternatives.rst:12
msgid ""
"Godot provides more lightweight objects for creating APIs which nodes use. "
"Be sure to keep these in mind as options when designing how you wish to "
"build your project's features."
msgstr ""
"Godot为创建节点使用的api提供了更轻量级的对象。在设计如何构建项目的特性时，请"
"务必将这些作为选项牢记在心。"

#: ../../docs/getting_started/workflow/best_practices/node_alternatives.rst:16
msgid ""
":ref:`Object <class_Object>`: The ultimate lightweight object, the original "
"Object must use manual memory management. With that said, it isn't too "
"difficult to create one's own custom data structures, even node structures, "
"that are also lighter than the :ref:`Node <class_Node>` class."
msgstr ""
":参考:`对象<类_对象>`: 终极轻量级对象，原始对象必须使用手动内存管理。尽管如"
"此，创建自己的自定义数据结构并不难，甚至于节点结构，它也比:参考:`节点<类_节点"
">`类更轻。"

#: ../../docs/getting_started/workflow/best_practices/node_alternatives.rst:21
msgid ""
"**Example:** See the :ref:`Tree <class_Tree>` node. It supports a high level "
"of customization for a table of content with an arbitrary number of rows and "
"columns. The data that it uses to generate its visualization though is "
"actually a tree of :ref:`TreeItem <class_TreeItem>` Objects."
msgstr ""
"**示例:**参见:参考:`树<类_树>`节点。它支持对具有任意行数和列数的内容表进行高"
"级定制。用来生成可视化的数据实际上是:参考:`树组件<类_树组件>`对象的树。"

#: ../../docs/getting_started/workflow/best_practices/node_alternatives.rst:26
msgid ""
"**Advantages:** Simplifying one's API to smaller scoped objects helps "
"improve its accessibility improve iteration time. Rather than working with "
"the entire Node library, one creates an abbreviated set of Objects from "
"which a node can generate and manage the appropriate sub-nodes."
msgstr ""
"**优点:**将API简化为更小的作用域对象，有助于提升其可访问性，提高迭代时间。而"
"不是使用整个节点库，一种方法是创建一组简短的对象，节点可以从中生成和管理适当"
"的子节点。"

#: ../../docs/getting_started/workflow/best_practices/node_alternatives.rst:31
msgid ""
"One should be careful when handling them. One can store an Object into a "
"variable, but these references can become invalid without warning. For "
"example, if the object's creator decides to delete it out of nowhere, this "
"would trigger an error state when one next accesses it."
msgstr ""
"处理它们时要小心。可以将对象存储到变量中，但是这些引用可能在没有警告的情况下"
"失效。例如，如果对象的创建者决定删除它，这将在下一次访问错误状态时触发错误状"
"态。"

#: ../../docs/getting_started/workflow/best_practices/node_alternatives.rst:36
msgid ""
":ref:`Reference <class_Reference>`: Only a little more complex than Object. "
"They track references to themselves, only deleting loaded memory when no "
"further references to themselves exist. These are useful in the majority of "
"cases where one needs data in a custom class."
msgstr ""
":参考:`引用<类_引用>`:只比对象稍微复杂一点。他们追踪对自己的引用，只有在不再"
"存在对其本身的引用时，才删除已加载的内存。在需要自定义类中的数据的大多数情况"
"下，这些都很有用。"

#: ../../docs/getting_started/workflow/best_practices/node_alternatives.rst:41
msgid ""
"**Example:** See the :ref:`File <class_File>` object. It functions just like "
"a regular Object except that one need not delete it themselves."
msgstr ""
"**示例：**参见:参考:`文件<类_文件>`对象。它的功能就像普通对象一样，只是不需要"
"自己删除它。"

#: ../../docs/getting_started/workflow/best_practices/node_alternatives.rst:44
#, fuzzy
msgid "**Advantages:** same as the Object."
msgstr "**优势:**"

#: ../../docs/getting_started/workflow/best_practices/node_alternatives.rst:46
msgid ""
":ref:`Resource <class_Resource>`: Only slightly more complex than Reference. "
"They have the innate ability to serialize/deserialize (i.e. save and load) "
"their object properties to/from Godot resource files."
msgstr ""
":参考:`资源<类_资源>`: 只比引用稍微复杂一点。它们天然具有将其对象属性序列化/"
"反序列化(即保存和加载)到/从Godot资源文件的能力。"

#: ../../docs/getting_started/workflow/best_practices/node_alternatives.rst:50
msgid ""
"**Example:** Scripts, PackedScene (for scene files), and other types like "
"each of the :ref:`AudioEffect <class_AudioEffect>` classes. Each of these "
"can be save and loaded, therefore they extend from Resource."
msgstr ""
"**示例:**脚本，打包场景(用于场景文件)，以及其他类型，比如:参考:`音频效果<类_"
"音频效果>`类。每一个都可以保存和加载，因此他们从资源扩展。"

#: ../../docs/getting_started/workflow/best_practices/node_alternatives.rst:54
msgid ""
"**Advantages:** Much has :ref:`already been said <doc_resources>` on :ref:"
"`Resource <class_Resource>`'s advantages over traditional data storage "
"methods. In the context of using Resources over Nodes though, their main "
"advantage is in Inspector-compatibility. While nearly as lightweight as "
"Object/Reference, they can still display and export properties in the "
"Inspector. This allows them to fulfill a purpose much like sub-Nodes on the "
"usability front, but also improve performance if one plans to have many such "
"Resources/Nodes in their scenes."
msgstr ""
"**优点:**有很多::参考:`已说过<文档_资源>`:参考:`资源<类_资源>`相比传统数据存"
"储方法的优点。然而，通过节点使用资源的上下文，它们的主要优点是与属性面板的兼"
"容性。虽然几乎和对象/引用一样轻量级，它们仍然可以在属性面板中显示和导出属性。"
"这使他们实现一个目标，就像子节点在可用性方面,但是，如果您计划在场景中拥有许多"
"这样的资源/节点，那么还可以提高性能。"
