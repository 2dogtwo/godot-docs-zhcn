# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2019, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-07-02 14:18+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:4
#, fuzzy
msgid "Godot notifications"
msgstr "推送通知"

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:6
msgid ""
"Every Object in Godot implements a :ref:`_notification "
"<class_Object_method__notification>` method. Its purpose is to allow the "
"Object to respond to a variety of engine-level callbacks that may relate to "
"it. For example, if the engine tells a :ref:`CanvasItem <class_CanvasItem>` "
"to \"draw\", it will call ``_notification(NOTIFICATION_DRAW)``."
msgstr ""
"Godot中的每个对象都实现了一个:参考:`_通知 <类_对象_方法__通知>`方法。目的是允"
"许对象响应可能与之相关的各种引擎级回调。例如，如果引擎告诉:参考:`画布组件<类_"
"画布组件>`来“绘制”，它将调用``_通知(通知_绘制)``。"

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:13
msgid ""
"Some of these notifications, like draw, are useful to override in scripts. "
"So much so that Godot exposes many of them with dedicated functions:"
msgstr ""
"其中一些通知，与绘制类似，在脚本中重写也是有效的。以至于Godot公开了其中许多专"
"用函数："

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:16
msgid "``_ready()`` : NOTIFICATION_READY"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:18
msgid "``_enter_tree()`` : NOTIFICATION_ENTER_TREE"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:20
msgid "``_exit_tree()`` : NOTIFICATION_EXIT_TREE"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:22
msgid "``_process(delta)`` : NOTIFICATION_PROCESS"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:24
msgid "``_physics_process(delta)`` : NOTIFICATION_PHYSICS_PROCESS"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:26
msgid "``_input()`` : NOTIFICATION_INPUT"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:28
msgid "``_unhandled_input()`` : NOTIFICATION_UNHANDLED_INPUT"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:30
msgid "``_draw()`` : NOTIFICATION_DRAW"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:32
msgid ""
"What users might *not* realize is that notifications exist for types other "
"than Node alone:"
msgstr "用户可能*没有*意识到，除了节点之外，还有其他类型的通知："

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:35
msgid ""
":ref:`Object::NOTIFICATION_POSTINITIALIZE "
"<class_Object_constant_NOTIFICATION_POSTINITIALIZE>`: a callback that "
"triggers during object initialization. Not accessible to scripts."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:38
msgid ""
":ref:`Object::NOTIFICATION_PREDELETE "
"<class_Object_constant_NOTIFICATION_PREDELETE>`: a callback that triggers "
"before the engine deletes an Object, i.e. a 'destructor'."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:42
msgid ""
":ref:`MainLoop::NOTIFICATION_WM_MOUSE_ENTER "
"<class_MainLoop_constant_NOTIFICATION_WM_MOUSE_ENTER>`: a callback that "
"triggers when the mouse enters the window in the operating system that "
"displays the game content."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:46
msgid ""
"And many of the callbacks that *do* exist in Nodes don't have any dedicated "
"methods, but are still quite useful."
msgstr ""
"而且，节点中*确实*存在的许多回调函数没有任何专用的方法，但仍然非常有用。"

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:49
msgid ""
":ref:`Node::NOTIFICATION_PARENTED "
"<class_Node_constant_NOTIFICATION_PARENTED>`: a callback that triggers "
"anytime one adds a child node to another node."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:52
msgid ""
":ref:`Node::NOTIFICATION_UNPARENTED "
"<class_Node_constant_NOTIFICATION_UNPARENTED>`: a callback that triggers "
"anytime one removes a child node from another node."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:56
msgid ""
":ref:`Popup::NOTIFICATION_POST_POPUP "
"<class_Popup_constant_NOTIFICATION_POST_POPUP>`: a callback that triggers "
"after a Popup node completes any ``popup*`` method. Note the difference from "
"its ``about_to_show`` signal which triggers *before* its appearance."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:61
msgid ""
"One can access all these custom notifications from the universal "
"``_notification`` method."
msgstr "您可以从通用的``_通知``方法访问所有这些自定义通知。"

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:65
msgid ""
"Methods in the documentation labeled as \"virtual\" are also intended to be "
"overridden by scripts."
msgstr "文档中标记为“虚拟”的方法也可以被脚本覆盖。"

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:68
msgid ""
"A classic example is the :ref:`_init <class_Object_method__init>` method in "
"Object. While it has no NOTIFICATION_* equivalent, the engine still calls "
"the method. Most languages (except C#) rely on it as a constructor."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:73
msgid ""
"So, in which situation should one use each of these notifications or virtual "
"functions?"
msgstr "那么，在哪种情况下应该使用这些通知或虚函数呢？"

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:77
msgid "_process vs. _physics_process vs. \\*_input"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:79
msgid ""
"Use ``_process`` when one needs a framerate-dependent deltatime between "
"frames. If code that updates object data needs to update as often as "
"possible, this is the right place. Recurring logic checks and data caching "
"often execute here, but it comes down to the frequency at which one needs "
"the evaluations to update. If they don't need to execute every frame, then "
"implementing a Timer-yield-timeout loop is another option."
msgstr ""
"当需要帧与帧之间的帧间时间间隔时，使用“_处理”。如果更新对象数据的代码需要尽可"
"能频繁地更新，这是正确的地方。这里经常执行循环逻辑检查和数据缓存，但这取决于"
"更新评估的频率。如果它们不需要执行每一帧，那么使用定时器-暂停-超时循环是另一"
"个选项。"

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:97
msgid ""
"Use ``_physics_process`` when one needs a framerate-independent deltatime "
"between frames. If code needs consistent updates over time, regardless of "
"how fast or slow time advances, this is the right place. Recurring kinematic "
"and object transform operations should execute here."
msgstr ""
"当需要帧与帧之间独立的时间间隔时，使用``_物理_处理``。如果代码需要持续一致的"
"更新，无论时间进展得多快或多慢，这是正确的地方。重复的动力学学和对象变换操作"
"应该在这里执行。"

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:102
msgid ""
"While it is possible, to achieve the best performance, one should avoid "
"making input checks during these callbacks. ``_process`` and "
"``_physics_process`` will trigger at every opportunity (they do not \"rest\" "
"by default). In contrast, ``*_input`` callbacks will trigger only on frames "
"in which the engine has actually detected the input."
msgstr ""
"虽然有可能达到最好的性能，应避免在这些回调期间进行输入检查。“_处理”和“_物理_"
"处理”将在任何机会触发（默认情况下，它们不会“休息”）。相反，“*_输入”回调只会在"
"引擎实际检测到输入的帧上触发。"

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:108
msgid ""
"One can check for input actions within the input callbacks just the same. If "
"one wants to use delta time, one can fetch it from the related deltatime "
"methods as needed."
msgstr ""
"可以检查输入回调中的输入操作。如果想使用增量时间，可以根据需要从相关的增量时"
"间方法获取它。"

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:156
msgid "_init vs. initialization vs. export"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:158
msgid ""
"If the script initializes its own node subtree, without a scene, that code "
"should execute here. Other property or SceneTree-independent initializations "
"should also run here. This triggers before ``_ready`` or ``_enter_tree``, "
"but after a script creates and initializes its properties."
msgstr ""
"如果脚本初始化它自己的节点子树，没有场景，代码应该在这里执行。其他属性或独立"
"于场景树的初始化也应该在这里运行。这在``_准备``或``_进入_树``之前触发，但是在"
"脚本创建并初始化其属性之后。"

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:163
msgid ""
"Scripts have three types of property assignments that can occur during "
"instantiation:"
msgstr "脚本有三种类型的属性分配，可以在实例化过程中发生："

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:210
msgid ""
"When instantiating a scene, property values will set up according to the "
"following sequence:"
msgstr "当实例化一个场景时，属性值将按照以下顺序设置："

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:213
msgid ""
"**Initial value assignment:** instantiation will assign either the "
"initialization value or the init assignment value. Init assignments take "
"priority over initialization values."
msgstr ""
"**初始值赋值：**实例化将分配初始化值或初始化赋值。初始化赋值优先于初始化值。"

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:217
msgid ""
"**Exported value assignment:** If instancing from a scene rather than a "
"script, Godot will assign the exported value to replace the initial value "
"defined in the script."
msgstr ""
"**导出值赋值：**如果从一个场景而不是脚本中，Godot将分配导出的值来替换脚本中定"
"义的初始值。"

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:221
msgid ""
"As a result, instantiating a script versus a scene will affect both the "
"initialization *and* the number of times the engine calls the setter."
msgstr "因此，实例化脚本和场景将影响初始化*和*引擎调用设值函数的次数。"

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:225
msgid "_ready vs. _enter_tree vs. NOTIFICATION_PARENTED"
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:227
msgid ""
"When instantiating a scene connected to the first executed scene, Godot will "
"instantiate nodes down the tree (making ``_init`` calls) and build the tree "
"going downwards from the root. This causes ``_enter_tree`` calls to cascade "
"down the tree. Once the tree is complete, leaf nodes call ``_ready``. A node "
"will call this method once all child nodes have finished calling theirs. "
"This then causes a reverse cascade going up back to the tree's root."
msgstr ""
"当实例化连接到第一个执行场景时，Godot将实例化树下的节点(调用``_初始化``)并从"
"根向下构建树。这会导致``_进入_树``调用级联到树的下面。当树构建完成，叶子节点"
"调用``_准备``。一旦所有子节点都完成了对它们的子节点的调用，节点就会调用这个方"
"法。这将导致反向级联回到树的根部。"

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:234
msgid ""
"When instantiating a script or a standalone scene, nodes are not added to "
"the SceneTree upon creation, so no ``_enter_tree`` callbacks trigger. "
"Instead, only the ``_init`` and later ``_ready`` calls occur."
msgstr ""
"在实例化脚本或独立场景时，节点不会在创建时添加到场景树，所以没有``_进入_树``"
"的回调触发器。相反，只发生``_初始化``和之后的``_准备``调用。"

#: ../../docs/getting_started/workflow/best_practices/godot_notifications.rst:238
msgid ""
"If one needs to trigger behavior that occurs as nodes parent to another, "
"regardless of whether it occurs as part of the main/active scene or not, one "
"can use the :ref:`PARENTED <class_Node_constant_NOTIFICATION_PARENTED>` "
"notification. For example, here is a snippet that connects a node's method "
"to a custom signal on the parent node without failing. Useful on data-"
"centric nodes that one might create at runtime."
msgstr ""
"如果一个节点需要触发作为另一个节点的父节点发生的行为，不管它是否出现在主要/活"
"动场景中，可以使用:参考:`父级<类_节点_常数_通知_父级>`通知。例如，以下是将节"
"点连接到父节点上的自定义信号，而代码段不出错的方法。可以在运行时创建以数据为"
"中心的节点。"
