# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2019, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-07-02 14:18+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../docs/getting_started/workflow/best_practices/logic_preferences.rst:4
#, fuzzy
msgid "Logic preferences"
msgstr "参考"

#: ../../docs/getting_started/workflow/best_practices/logic_preferences.rst:6
msgid ""
"Ever wondered whether one should approach problem X with strategy Y or Z? "
"This article covers a variety of topics related to these dilemmas."
msgstr ""
"有没有想过应该用策略Y还是Z，来处理问题X？本文包括与这些难题相关的各种主题。"

#: ../../docs/getting_started/workflow/best_practices/logic_preferences.rst:10
#, fuzzy
msgid "Loading vs. preloading"
msgstr "加载场景"

#: ../../docs/getting_started/workflow/best_practices/logic_preferences.rst:12
msgid ""
"In GDScript, there exists the global :ref:`preload "
"<class_@GDScript_method_preload>` method. It loads resources as early as "
"possible to front-load the \"loading\" operations and avoid loading "
"resources while in the middle of performance-sensitive code."
msgstr ""
"在GDScript中，存在全局:参考:`预加载<类_@GDScript_方法_预加载>`方法。它尽可能"
"早地加载资源，以便提前进行“加载”操作，并避免在执行性能敏感的代码时加载资源。"

#: ../../docs/getting_started/workflow/best_practices/logic_preferences.rst:17
msgid ""
"Its counterpart, the :ref:`load <class_@GDScript_method_load>` method, loads "
"a resource only when it reaches the load statement. That is, it will load a "
"resource in-place which can cause slowdowns then it occurs in the middle of "
"sensitive processes. The ``load`` function is also an alias for :ref:"
"`ResourceLoader.load(path) <class_ResourceLoader_method_load>` which is "
"accessible to *all* scripting languages."
msgstr ""
"与其对应，:参考:`加载 <类_@GDScript_方法_加载>`方法，仅当资源到达加载语句时才"
"加载它。也就是说，它将在适当的位置加载资源，这会导致速度下降，然后在敏感进程"
"的中间发生。“加载”函数也是:参考:`资源加载器.加载(路径) <类_资源加载器_方法_加"
"载>`的别名。*所有*脚本语言都可访问。"

#: ../../docs/getting_started/workflow/best_practices/logic_preferences.rst:24
msgid ""
"So, when exactly does preloading occur versus loading, and when should one "
"use either? Let's see an example:"
msgstr ""
"那么，预加载和加载到底在什么时候发生，什么时候又应该使用这两种方法呢?我们来看"
"一个例子："

#: ../../docs/getting_started/workflow/best_practices/logic_preferences.rst:88
msgid ""
"Preloading allows the script to handle all the loading the moment one loads "
"the script. Preloading is useful, but there are also times when one doesn't "
"wish for it. To distinguish these situations, there are a few things one can "
"consider:"
msgstr ""
"预加载允许脚本在加载脚本时处理所有加载。预加载是有用的，但也有一些时候，人们"
"并不希望这样。为了区分这些情况，我们可以考虑以下几点："

#: ../../docs/getting_started/workflow/best_practices/logic_preferences.rst:93
msgid ""
"If one cannot determine when the script might load, then preloading a "
"resource, especially a scene or script, could result in further loads one "
"does not expect. This could lead to unintentional, variable-length load "
"times on top of the original script's load operations."
msgstr ""
"如果无法确定脚本何时加载，则需要预加载资源，特别是场景或脚本，可能会导致超出"
"预期的进一步加载。这可能会导致无意中，在原始脚本的加载操作之上的可变长度加载"
"时间。"

#: ../../docs/getting_started/workflow/best_practices/logic_preferences.rst:98
msgid ""
"If something else could replace the value (like a scene's exported "
"initialization), then preloading the value has no meaning. This point isn't "
"a significant factor if one intends to always create the script on its own."
msgstr ""
"如果有其他东西可以替代这个值(比如场景的导出初始化)，那么预加载值就没有意义"
"了。如果打算总是自己创建脚本，那么这点就不是一个重要因素。"

#: ../../docs/getting_started/workflow/best_practices/logic_preferences.rst:102
msgid ""
"If one wishes only to 'import' another class resource (script or scene), "
"then using a preloaded constant is often the best course of action. However, "
"in exceptional cases, one my wish not to do this:"
msgstr ""
"如果只希望“导入”另一个类资源(脚本或场景)，那么使用预加载的常量通常是最好的做"
"法。但在特殊情况下，我不希望这样做："

#: ../../docs/getting_started/workflow/best_practices/logic_preferences.rst:106
msgid ""
"If the 'imported' class is liable to change, then it should be a property "
"instead, initialized either using an ``export`` or a ``load`` (and perhaps "
"not even initialized until later)."
msgstr ""
"如果“导入”类可能更改，那么它应该是一个属性，使用“导出”或“加载”初始化（可能直"
"到稍后才初始化）。"

#: ../../docs/getting_started/workflow/best_practices/logic_preferences.rst:110
msgid ""
"If the script requires a great many dependencies, and one does not wish to "
"consume so much memory, then one may wish to, load and unload various "
"dependencies at runtime as circumstances change. If one preloads resources "
"into constants, then the only way to unload these resources would be to "
"unload the entire script. If they are instead loaded properties, then one "
"can set them to ``null`` and remove all references to the resource entirely "
"(which, as a :ref:`Reference <class_Reference>`-extending type, will cause "
"the resources to delete themselves from memory)."
msgstr ""
"如果脚本需要很多依赖项，人们不希望消耗这么多内存，也许有人希望随着环境的变"
"化，在运行时加载和卸载各种依赖项。如果将资源预加载到常量中，那么卸载这些资源"
"的唯一方法，就是卸载整个脚本。如果它们是加载的属性，然后可以将它们设置"
"为“空”，并完全删除对资源的所有引用(作为:参考:`引用<类_引用>`扩展类型，将导致"
"资源从内存中删除它们自己)。"

#: ../../docs/getting_started/workflow/best_practices/logic_preferences.rst:121
msgid "Large levels: static vs. dynamic"
msgstr "大型关卡：静态和动态"

#: ../../docs/getting_started/workflow/best_practices/logic_preferences.rst:123
msgid ""
"If one is creating a large level, which circumstances are most appropriate? "
"Should they create the level as one static space? Or should they load the "
"level in pieces and shift the world's content as needed?"
msgstr ""
"如果一个人正在创建一个大型关卡，哪种情况是最合适的？他们应该将关卡创建为一个"
"静态空间吗？或者他们应该将关卡分成几部分，并根据需要改变世界的内容吗？"

#: ../../docs/getting_started/workflow/best_practices/logic_preferences.rst:127
msgid ""
"Well, the simple answer is , \"when the performance requires it.\" The "
"dilemma associated with the two options is one of the age-old programming "
"choices: does one optimize memory over speed, or vice versa?"
msgstr ""
"答案很简单，“当性能需要的时候。”与这两种选择有关的困境，是一种古老的编程选"
"择：是否会优化内存而不是速度，反之亦然？"

#: ../../docs/getting_started/workflow/best_practices/logic_preferences.rst:131
msgid ""
"The naive answer is to use a static level that loads everything at once. "
"But, depending on the project, this could consume a large amount of memory. "
"Wasting users' RAM leads to programs running slow or outright crashing from "
"everything else the computer tries to do at the same time."
msgstr ""
"最简单的方法是使用静态关卡，它可以一次加载所有内容。但是，根据项目的不同，这"
"可能会消耗大量内存。浪费用户的运行内存会导致程序运行缓慢，或者计算机在同一时"
"间尝试做的所有其他事情都会崩溃。"

#: ../../docs/getting_started/workflow/best_practices/logic_preferences.rst:136
msgid ""
"No matter what, one should break larger scenes into smaller ones (to aid in "
"reusability of assets). Developers can then design a node that manages the "
"creation/loading and deletion/unloading of resources and nodes in real-time. "
"Games with large and varied environments or procedurally generated elements "
"often implement these strategies to avoid wasting memory."
msgstr ""
"无论如何，我们应该把大场景分成小场景(提升资产的可复用性)。然后，开发人员可以"
"设计一个节点，来实时管理资源和节点的创建/加载和删除/卸载。拥有大而多样的环境"
"或程序生成元素的游戏，通常会执行这些策略，以避免浪费内存。"

#: ../../docs/getting_started/workflow/best_practices/logic_preferences.rst:142
msgid ""
"On the flip side, coding a dynamic system is more complex, i.e. uses more "
"programmed logic, which results in opportunities for errors and bugs. If one "
"isn't careful, they can develop a system that bloats the technical debt of "
"the application."
msgstr ""
"另一方面，编写动态系统的代码要复杂得多，即使用更多的程序逻辑，这会导致出现错"
"误和bug的机会。如果不小心的话，开发的系统，会增加应用程序的技术成本。"

#: ../../docs/getting_started/workflow/best_practices/logic_preferences.rst:147
msgid "As such, the best options would be..."
msgstr "因此，最好的选择是……"

#: ../../docs/getting_started/workflow/best_practices/logic_preferences.rst:149
msgid "To use a static level for smaller games."
msgstr "在小型游戏中使用静态关卡。"

#: ../../docs/getting_started/workflow/best_practices/logic_preferences.rst:151
msgid ""
"If one has the time/resources on a medium/large game, create a library or "
"plugin that can code the management of nodes and resources. If refined over "
"time, so as to improve usability and stability, then it could evolve into a "
"reliable tool across projects."
msgstr ""
"如果一个人有时间/资源开发中型/大型游戏，使用一个可以编写节点和资源管理代码的"
"库或插件。那么随着时间的推移，为了提高可用性和稳定性，它就可以发展成为跨项目"
"的可靠工具。"

#: ../../docs/getting_started/workflow/best_practices/logic_preferences.rst:156
msgid ""
"Code the dynamic logic for a medium/large game because one has the coding "
"skills, but not the time or resources to refine the code (game's gotta get "
"done). Could potentially refactor later to outsource the code into a plugin."
msgstr ""
"为一款中/大型游戏编写动态逻辑代码，因为你拥有编程技能，但却没有时间或资源去完"
"善代码(必须要完成游戏)。以后可能会进行重构，将代码外包到插件中。"

#: ../../docs/getting_started/workflow/best_practices/logic_preferences.rst:161
msgid ""
"For an example of the various ways one can swap scenes around at runtime, "
"please see the :ref:`\"Change scenes manually\" "
"<doc_change_scenes_manually>` documentation."
msgstr ""
"举个例子，我们可以在运行时交换场景，请参见:参考:`\"手动更改场景\" <文档_手动_"
"更改_场景>`文档。"
