# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2019, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-06-16 22:53+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../docs/getting_started/workflow/best_practices/autoloads_versus_internal_nodes.rst:4
msgid "Autoloads versus internal nodes"
msgstr "自动加载与内部节点"

#: ../../docs/getting_started/workflow/best_practices/autoloads_versus_internal_nodes.rst:6
msgid ""
"Other engines might encourage the use of creating \"manager\" classes that "
"organize lots of functionality into a globally accessible entity. Godot "
"thrives by supporting ways to cut down the size of such objects. Instead it "
"shifts content into individual nodes as much as possible."
msgstr ""
"其他引擎可能鼓励创建“管理”类，这些类将许多功能组织成一个全局可访问的实体。"
"Godot通过支持减少此类对象大小的方法而蓬勃发展。相反，它尽可能地将内容转移到各"
"个节点。"

#: ../../docs/getting_started/workflow/best_practices/autoloads_versus_internal_nodes.rst:11
msgid ""
"For example, what if a developer is building a platformer and they want to "
"collect coins that play a sound effect? Well, there's a node for that: the :"
"ref:`AudioStreamPlayer <class_AudioStreamPlayer>`. But they notice during "
"their testing that if they \"play\" an AudioStreamPlayer while it is already "
"playing the sound, then the new sound interrupts the first sound, "
"terminating it before it can play."
msgstr ""
"例如，如果开发者正在创建一个平台游戏，而他们想要收集金币时能播放声音效果，那"
"该怎么办？这里有一个节点:参考:`音频流播放器<类_音频流播放器>`。但是他们注意"
"到，在测试过程中，如果他们“播放”一个已经在播放声音的音频流播放器，然后新的声"
"音打断了第一个声音，可以在播放之前终止它。"

#: ../../docs/getting_started/workflow/best_practices/autoloads_versus_internal_nodes.rst:18
msgid ""
"Users tend to think the best solution is to make the whole system smarter by "
"making a SoundManager autoload node. It generates a pool of "
"AudioStreamPlayers that cycle through as each new request for sound effects "
"comes in. They then make this SoundManager an autoload so that they can "
"access it from anywhere with `SFX.play(\"coin_pickup.ogg\")`. Little do they "
"know, they've invited a great many complications into their code."
msgstr ""
"用户倾向于认为最好的解决方案是，通过使音效管理器自动加载节点，使整个系统更智"
"能。它生成一个音频流播放器池，当每个对声音效果的新请求到来时，这些播放器就会"
"循环播放。然后，他们将这个音效管理器设置为一个自动加载器，这样他们就可以通"
"过“SFX.play(“coin_pick.ogg”)从任何地方访问它。而他们根本不知道，代码中引入了"
"很多复杂的东西。"

#: ../../docs/getting_started/workflow/best_practices/autoloads_versus_internal_nodes.rst:25
msgid ""
"**global state**: One object is now responsible for all objects' data. If "
"SFX has errors or doesn't have an AudioStreamPlayer available, everything "
"will break."
msgstr ""
"**全局状态**:一个对象现在负责所有对象的数据。如果音效有错误或没有可用的音频流"
"播放器，一切都会崩溃。"

#: ../../docs/getting_started/workflow/best_practices/autoloads_versus_internal_nodes.rst:29
msgid ""
"**global access**: Now that any object can call `SFX.play(sound_path)` from "
"anywhere, there's no longer an easy way to track where an SFX bug began."
msgstr ""
"**全局访问**：现在任何对象都可以从任何地方调用“SFX.play(音效_路径)”，现在已没"
"有一种简单的方法来跟踪音效bug是从哪里开始的了。"

#: ../../docs/getting_started/workflow/best_practices/autoloads_versus_internal_nodes.rst:33
msgid ""
"**global resource allocation**: If all objects' data and processing is "
"centralized from the start, then one must either..."
msgstr ""
"**全局资源配置**：如果所有对象的数据和处理，从一开始就是集中管理的，然后你必"
"须……"

#: ../../docs/getting_started/workflow/best_practices/autoloads_versus_internal_nodes.rst:36
msgid "risk under-allocating resources which might lead to faulty behavior."
msgstr "资源分配不足的风险，可能导致发生错误行为。"

#: ../../docs/getting_started/workflow/best_practices/autoloads_versus_internal_nodes.rst:38
msgid ""
"Ex: Have too few AudioStreamPlayers in the object pool. Sound doesn't play "
"or it interrupts another sound."
msgstr "例如：在对象池中音频流播放器太少。声音不播放或打断其他声音。"

#: ../../docs/getting_started/workflow/best_practices/autoloads_versus_internal_nodes.rst:41
msgid "over-allocate resources and use more memory/processing than it needs."
msgstr "过度分配资源和使用更多内存/处理超出它的需要。"

#: ../../docs/getting_started/workflow/best_practices/autoloads_versus_internal_nodes.rst:43
msgid ""
"Ex: Have an arbitrarily large number of AudioStreamPlayers, with many of "
"them idling away and not doing anything."
msgstr "例如：拥有任意数量的音频播放器，其中有许多处于闲置状态，什么都没做。"

#: ../../docs/getting_started/workflow/best_practices/autoloads_versus_internal_nodes.rst:46
msgid ""
"have each object that needs an AudioStreamPlayer register exactly how many "
"it needs and for which sounds. This defeats the purpose of using a 3rd party "
"though; it is now coupled to each object, just as a child node would have "
"been. One has added an unnecessary middleman to the equation."
msgstr ""

#: ../../docs/getting_started/workflow/best_practices/autoloads_versus_internal_nodes.rst:52
msgid ""
"Contrast this with each scene keeping as many AudioStreamPlayer nodes as it "
"needs within itself and all these problems go away."
msgstr ""
"与之形成对比的是，在每个场景中保留尽可能多的音频流播放器节点，所有这些问题都"
"会消失。"

#: ../../docs/getting_started/workflow/best_practices/autoloads_versus_internal_nodes.rst:55
msgid ""
"Each scene manages its own state information. If there is a problem with the "
"data, it will only cause issues in that one scene."
msgstr ""
"每个场景管理自己的状态信息。如果数据出了问题，它只会在单个场景中引起问题。"

#: ../../docs/getting_started/workflow/best_practices/autoloads_versus_internal_nodes.rst:58
msgid ""
"Each scene accesses only its own nodes. Now, if there is a bug, tracing "
"which node is responsible (probably the root node of the scene), and where "
"in the code it's making the problematic call (locate where the code "
"references the given node) is going to be much easier."
msgstr ""
"每一个场景都只能访问自己的节点。现在，如果有一个bug，跟踪哪个节点(可能是场景"
"的根节点)，而在代码中，确定哪个位置进行有问题的调用(定位代码引用给定节点的位"
"置)将会容易得多。"

#: ../../docs/getting_started/workflow/best_practices/autoloads_versus_internal_nodes.rst:63
msgid ""
"Each scene knows exactly how many resources it needs for the task it "
"performs. No waste of memory or processing due to a lack of information."
msgstr ""
"每个场景都确切地知道执行任务需要多少资源。不会造成由于缺乏信息而造成的内存或"
"者数据处理的浪费。"

#: ../../docs/getting_started/workflow/best_practices/autoloads_versus_internal_nodes.rst:66
msgid ""
"The typical justifications for the Autoload include, \"I have common Xs that "
"involve many nodes across many scenes, and I want each scene to have X.\""
msgstr ""
"典型的自动装载的理由包括，“我有一些公共的x，它包含很多场景中的节点，我希望每"
"个场景都有x。”"

#: ../../docs/getting_started/workflow/best_practices/autoloads_versus_internal_nodes.rst:69
msgid ""
"If X is a function, then the solution is to create a new type of :ref:`Node "
"<class_Node>` that deals with providing that feature for an individual scene "
"or node subtree."
msgstr ""
"如果x是一个函数，那么，解决方案是创建一个新的类型:参考:`节点<类_节点>`，它被"
"处理为单个场景或为节点子树提供该特性。"

#: ../../docs/getting_started/workflow/best_practices/autoloads_versus_internal_nodes.rst:73
msgid ""
"If X is data, then the solution is either 1) to create a new type of :ref:"
"`Resource <class_Resource>` to share the data, or 2) to store the data in an "
"object to which each node has access (nodes within a scene can use "
"`get_owner()` to fetch the scene root for example)."
msgstr ""
"如果x是数据，那么解决方案是:1)创建一个新的类型:参考:`资源<类_资源>`来共享数"
"据，或者2)将数据存储在每个节点都可以访问的对象中(例如，场景中的节点可以使用"
"`get_owner()`来获取场景根)。"

#: ../../docs/getting_started/workflow/best_practices/autoloads_versus_internal_nodes.rst:78
msgid "So when *should* one use an autoload?"
msgstr "那么什么时候*应该*使用自动加载呢？"

#: ../../docs/getting_started/workflow/best_practices/autoloads_versus_internal_nodes.rst:80
msgid ""
"**Static Data**: if you need static data, i.e. data that should be "
"associated with a class (so there is only ever one copy of the data), then "
"autoloads are good opportunities for that. Static data doesn't exist in "
"Godot's scripting API, so autoload singletons are the next best thing. If "
"one creates a class as an autoload, and never creates another copy of that "
"class within a scene, then it will function in place of a formal singleton "
"API."
msgstr ""
"**静态数据**：如果需要静态数据，即应该与类关联的数据（所以只有一个数据拷"
"贝），自动加载是很好的机会。静态数据并不存在于Godot的脚本API中，所以自动装载"
"单例是其次最好的事情。将类创建为自动加载，而且永远不会在场景中创建该类的另一"
"个副本，那么它将代替一个正式的单例API。"

#: ../../docs/getting_started/workflow/best_practices/autoloads_versus_internal_nodes.rst:88
msgid ""
"**Convenience**: autoloaded nodes have a global variable for their name "
"generated in GDScript. This can be very convenient for defining objects that "
"should always exist, but which need object instance information. The "
"alternative is to create a namespace script: a script that's purpose is only "
"to load and create constants to access other Script or PackedScene "
"resources, resulting in something like ``MyAutoload.MyNode.new()``."
msgstr ""
"**便利**：自动加载的节点在GDScript中，以其名称生成一个全局变量。这对于定义应"
"该始终存在的对象非常方便，但是需要对象实例的信息。另一种方法是创建一个命名空"
"间脚本：一个脚本的目的只是加载和创建常量，来访问其他脚本或打包的场景资源，生"
"成类似于``MyAutoload.MyNode.new()``的东西。"

#: ../../docs/getting_started/workflow/best_practices/autoloads_versus_internal_nodes.rst:95
msgid ""
"Note that the introduction of script classes in Godot 3.1 questions the "
"validity of this reason. With them, one can access scripts using an explicit "
"name from GDScript. Using an autoload to get to a namespace script becomes "
"unnecessary, e.g. ``MyScriptClass.MyPreloadedScript.new()``."
msgstr ""
"注意，Godot 3.1中引入的脚本类对这个原因的有效性提出了质疑。对于它们，可以使用"
"GDScript的显式名称访问脚本。没有必要使用自动加载来获取命令空间脚本，如"
"``MyScriptClass.MyPreloadedScript.new()``。"

#: ../../docs/getting_started/workflow/best_practices/autoloads_versus_internal_nodes.rst:100
msgid ""
"If the singleton is managing its own information and not invading the data "
"of other objects, then it's a great way to create a \"system\" class that "
"handles a broad-scoped task. For example a targeting system, quest system, "
"or dialogue system would be great use cases of singleton implementations."
msgstr ""
"如果单例对象管理自身的信息，而不入侵其他对象的数据，那么创建一个“系统”类来处"
"理一个范围广泛的任务的好方法。例如一个目标系统，任务系统，以及对话系统将是单"
"例实现的很好用例。"
