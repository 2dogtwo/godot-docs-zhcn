# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2019, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-06-16 22:53+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:4
msgid "When to use scenes versus scripts"
msgstr "什么时候使用场景，什么时候使用脚本"

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:6
msgid ""
"We've already covered how scenes and scripts are different. Scripts define "
"an engine class extension with imperative code, scenes with declarative code."
msgstr ""
"我们已经介绍了场景和脚本的不同之处。脚本使用命令式代码定义引擎类扩展，而场景"
"带有声明性代码。"

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:10
msgid ""
"Each system's capabilities are different as a result. Scenes can define how "
"an extended class initializes, but not what its behavior actually is. Scenes "
"are often used in conjunction with a script so that the scene acts as an "
"extension of the scripts declarative code."
msgstr ""
"因此，每个系统的功能是不同的。场景可以定义扩展类如何初始化，但不关心它的实际"
"行为。场景经常与脚本结合使用，使得场景作为脚本声明性代码的扩展。"

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:16
msgid "Anonymous types"
msgstr "匿名类型"

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:18
msgid ""
"It *is* possible to completely define a scenes' contents using a script "
"alone. This is, in essence, what the Godot Editor does, only in the C++ "
"constructor of its objects."
msgstr ""
"*仅仅*使用脚本就可以完全定义场景的内容。这就是Godot编辑器的本质，只存在于c+"
"+构造函数的对象中。"

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:22
msgid ""
"But, choosing which one to use can be a dilemma. Creating script instances "
"is identical to creating in-engine classes whereas handling scenes requires "
"a change in API:"
msgstr ""
"但是，选择使用哪个可能是个两难的选择。创建脚本实例与创建引擎内的类相同，但是"
"处理场景需要更改API:"

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:59
msgid ""
"Also, scripts will operate a little slower than scenes due to the speed "
"differences between engine and script code. The larger and more complex the "
"node, the more reason there is to build it as a scene."
msgstr ""
"此外，由于引擎和脚本代码之间的速度差异，脚本的运行速度会比场景略慢。节点越大"
"越复杂，所以更加有理由把它建立为一个场景。"

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:64
#, fuzzy
msgid "Named types"
msgstr "着色器类型"

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:66
msgid ""
"In some cases, a user can register a script as a new type within the editor "
"itself. This displays it as a new type in the node or resource creation "
"dialog with an optional icon. In these cases, the user's ability to use the "
"script is much more streamlined. Rather than having to..."
msgstr ""
"在某些情况下，用户可以在编辑器内，将脚本注册为新类型。在节点或资源创建对话框"
"中，将其显示为新类型，并带有可选图标。在这些情况下，用户使用脚本的能力更加流"
"畅。而不必……"

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:71
msgid "Know the base type of the script they would like to use."
msgstr "了解他们想要使用的脚本的基本类型。"

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:73
#, fuzzy
msgid "Create an instance of that base type."
msgstr "创建自定义数据类型"

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:75
#, fuzzy
msgid "Add the script to the node."
msgstr "资源的文字描述。"

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:77
msgid "(Drag-n-drop method)"
msgstr "（拖放方法）"

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:79
#, fuzzy
msgid "Find the script in the FileSystem dock."
msgstr "在编辑器中执行脚本。"

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:81
#, fuzzy
msgid "Drag and drop the script onto the node in the Scene dock."
msgstr "编写脚本，使其能访问场景中的其它节点。"

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:83
msgid "(Property method)"
msgstr "(属性方法)"

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:85
msgid ""
"Scroll down to the bottom of the Inspector to find the ``script`` property "
"and select it."
msgstr "向下滚动到属性面板的底部，找到“脚本”属性并选择它。"

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:87
#, fuzzy
msgid "Select \"Load\" from the dropdown."
msgstr "在顶部菜单中选择“loc”和“rot”。"

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:89
#, fuzzy
msgid "Select the script from the file dialog."
msgstr "在编辑器中执行脚本。"

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:91
msgid ""
"With a registered script, the scripted type instead becomes a creation "
"option like the other nodes and resources in the system. One need not do any "
"of the above work. The creation dialog even has a search bar to look up the "
"type by name."
msgstr ""
"使用注册脚本，相反，脚本类型变成了创建选项，就像系统中的其他节点和资源一样。"
"你不需要做任何的工作。创建有一个搜索栏的对话框来按名称查找类型。"

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:96
#, fuzzy
msgid "There are two systems for registering types..."
msgstr "有6中模式类型:"

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:98
#, fuzzy
msgid ":ref:`Custom Types <doc_making_plugins>`"
msgstr ":ref:`易于书写的着色器 <doc_shading_language>`"

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:100
msgid "Editor-only. Typenames are not accessible at runtime."
msgstr "仅限编辑器。运行时无法访问类型名。"

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:102
msgid "Does not support inherited custom types."
msgstr "不支持继承自定义类型。"

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:104
msgid "An initializer tool. Creates the node with the script. Nothing more."
msgstr "初始化工具。使用脚本创建节点。仅此而已。"

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:106
msgid ""
"Editor has no type-awareness of the script or its relationship to other "
"engine types or scripts."
msgstr "编辑器不知道脚本的类型，也不知道它与其他引擎类型或脚本的关系。"

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:109
#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:127
msgid "Allows users to define an icon."
msgstr "允许用户定义图标。"

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:111
msgid ""
"Works for all scripting languages because it deals with Script resources in "
"abstract."
msgstr "适用于所有脚本语言，因为它处理抽象的脚本资源。"

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:113
msgid ""
"Set up using :ref:`EditorPlugin.add_custom_type "
"<class_EditorPlugin_method_add_custom_type>`."
msgstr ""
"设置使用:参考:`编辑器插件.添加_自定义_类型<类_编辑器插件_方法_添加_自定义_类"
"型>`。"

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:115
msgid ":ref:`Script Classes <doc_scripting_continued_class_name>`"
msgstr ":参考:`脚本类<文档_脚本_持续_类_名称>`"

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:117
msgid "Editor and runtime accessible."
msgstr "编辑器和运行时可访问。"

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:119
msgid "Displays inheritance relationships in full."
msgstr "显示全部继承关系。"

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:121
msgid ""
"Creates the node with the script, but can also change types or extend the "
"type from the editor."
msgstr "使用脚本创建节点，但也可以从编辑器更改或扩展类型。"

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:124
msgid ""
"Editor is aware of inheritance relationships between scripts, script "
"classes, and engine C++ classes."
msgstr "编辑器知道脚本、脚本类和引擎c++类之间的继承关系。"

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:129
msgid ""
"Engine developers must add support for languages manually (both name "
"exposure and runtime accessibility)."
msgstr "引擎开发人员必须手动添加对语言的支持(包括名称公开和运行时的可访问性)。"

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:132
msgid "Godot 3.1+ only."
msgstr "仅适用于Godot 3.1版本。"

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:134
msgid ""
"The Editor scans project folders and registers any exposed names for all "
"scripting languages. Each scripting language must implement its own support "
"for exposing this information."
msgstr ""
"编辑器扫描项目文件夹，并为所有脚本语言注册任何公开的名称。每种脚本语言都必须"
"实现自己对公开此信息的支持。"

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:138
msgid ""
"Both methodologies add names to the creation dialog, but script classes, in "
"particular, also allow for users to access the typename without loading the "
"script resource. Creating instances and accessing constants or static "
"methods is viable from anywhere."
msgstr ""
"这两种方法都向创建对话框添加名称，特别是脚本类，还允许用户在不加载脚本资源的"
"情况下访问类别名称。在任何地方都可以使用实例和访问常量或静态方法。"

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:143
msgid ""
"With features like these, one may wish their type to be a script without a "
"scene due to the ease of use it grants users. Those developing plugins or "
"creating in-house tools for designers to use will find an easier time of "
"things this way."
msgstr ""
"有了这些功能，人们或许希望他们的类型是没有场景的脚本，因为它给用户提供了易用"
"性。通过这种方式，开发插件或为设计师创建内部工具将会更容易。"

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:148
msgid ""
"On the downside, it also means having to use largely imperative programming."
msgstr "不足之处在于，这也意味着很大程度上必须使用命令式编程。"

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:151
msgid "Conclusion"
msgstr "总结"

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:153
msgid "In the end, the best approach is to consider the following:"
msgstr "最后，最好的方法是考虑以下几点:"

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:155
msgid ""
"If one wishes to create a basic tool that is going to be re-used in several "
"different projects and which people of all skill levels will likely use "
"(including those who don't label themselves as \"programmers\"), then "
"chances are that it should probably be a script, likely one with a custom "
"name/icon."
msgstr ""
"如果希望创建一个基本工具，它将在几个不同的项目中重用，以及可能提供给不同技能"
"水平的人使用。(包括那些不认为自己是个“程序员”的用户)，它很可能是一个脚本，有"
"一个自定义名称/图标。"

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:160
msgid ""
"If one wishes to create a concept that is particular to their game, then it "
"should always be a scene. Scenes are easier to track/edit and provide more "
"security than scripts."
msgstr ""
"如果希望创建一个特定概念的游戏，那么它应该是一个场景。场景比脚本更容易跟踪/编"
"辑，并提供更多的安全性。"

#: ../../docs/getting_started/workflow/best_practices/scenes_versus_scripts.rst:164
msgid ""
"If one would like to give a name to a scene, then they can still sort of do "
"this in 3.1 by declaring a script class and giving it a scene as a constant. "
"The script becomes, in effect, a namespace:"
msgstr ""
"如果有人想命名一个场景，他们仍然可以在3.1版本中，通过声明一个脚本类并给它一个"
"场景作为常量来实现这一点。实际上，该脚本变成了一个命名空间:"
