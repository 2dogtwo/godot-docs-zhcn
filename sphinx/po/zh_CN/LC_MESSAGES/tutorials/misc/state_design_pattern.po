# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2021, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-10-08 12:36+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../docs/tutorials/misc/state_design_pattern.rst:4
msgid "State design pattern"
msgstr "状态设计模式"

#: ../../docs/tutorials/misc/state_design_pattern.rst:7
msgid "Introduction"
msgstr "简介"

#: ../../docs/tutorials/misc/state_design_pattern.rst:9
msgid ""
"Scripting a game can be difficult when there are many states that need to "
"handled, but only one script can be attached to a node at a time. Instead of "
"creating a state machine within the player's control script, it would make "
"development simpler if the states were separated out into different classes."
msgstr ""
"当有许多状态需要处理, 但一次只能将一个脚本附加到一个节点上时, 编写游戏脚本是"
"很困难的. 与其在玩家的控制脚本中创建一个状态机, 不如将状态分离出来, 分成不同"
"的类, 这样会使开发更加简单."

#: ../../docs/tutorials/misc/state_design_pattern.rst:14
msgid ""
"There are many ways to implement a state machine with Godot, and some other "
"methods are below:"
msgstr "用Godot实现状态机的方法有很多, 下面是一些其他方法:"

#: ../../docs/tutorials/misc/state_design_pattern.rst:16
msgid ""
"The player can have a child node for each state, which are called when "
"utilized."
msgstr "玩家的每一个状态都可以有一个子节点, 在使用时会被调用."

#: ../../docs/tutorials/misc/state_design_pattern.rst:17
msgid "Enums can be used in conjunction with a match statement."
msgstr "Enums可以与匹配语句一起使用."

#: ../../docs/tutorials/misc/state_design_pattern.rst:18
msgid ""
"The state scripts themselves could be swapped out from a node dynamically at "
"run-time."
msgstr "状态脚本本身可以在运行时动态地从一个节点上换掉."

#: ../../docs/tutorials/misc/state_design_pattern.rst:20
msgid ""
"This tutorial will focus only on adding and removing nodes which have a "
"state script attached. Each state script will be an implementation of a "
"different state."
msgstr ""
"本教程将只专注于添加和删除附加有状态脚本的节点. 每个状态脚本将是不同状态的实"
"现."

#: ../../docs/tutorials/misc/state_design_pattern.rst:24
msgid ""
"There is a great resource explaining the concept of the state design pattern "
"here: https://gameprogrammingpatterns.com/state.html"
msgstr ""
"这里有一个很好的资源来解释状态设计模式的概念 : https://"
"gameprogrammingpatterns.com/state.html"

#: ../../docs/tutorials/misc/state_design_pattern.rst:28
msgid "Script setup"
msgstr "脚本设置"

#: ../../docs/tutorials/misc/state_design_pattern.rst:30
msgid ""
"The feature of inheritance is useful for getting started with this design "
"principle. A class should be created that describes the base features of the "
"player. For now, a player will be limited to two actions: **move left**, "
"**move right**. This means there will be two states: **idle** and **run**."
msgstr ""
"继承的特性对于开始使用这个设计原则是很有用的. 应该创建一个类来描述玩家的基本"
"功能. 现在, 一个玩家将被限制为两个动作. **向左移动** , **向右移动** . 这意味"
"着将有两种状态. **闲置** 和 **运行** ."

#: ../../docs/tutorials/misc/state_design_pattern.rst:35
msgid "Below is the generic state, from which all other states will inherit."
msgstr "下面是通用状态, 所有其他状态都将从该状态继承."

#: ../../docs/tutorials/misc/state_design_pattern.rst:66
msgid ""
"A few notes on the above script. First, this implementation uses a "
"``setup(change_state, animated_sprite, persistent_state)`` method to assign "
"references. These references will be instantiated in the parent of this "
"state. This helps with something in programming known as *cohesion*. The "
"state of the player does not want the responsibility of creating these "
"variables, but does want to be able to use them. However, this does make the "
"state *coupled* to the state's parent. This means that the state is highly "
"reliant on whether it has a parent which contains these variables. So, "
"remember that *coupling* and *cohesion* are important concepts when it comes "
"to code management."
msgstr ""
"对上面的脚本做一些说明. 首先, 这个实现使用了一个``setup(change_state, "
"animated_sprite, persistent_state)``方法来分配引用. 这些引用将在这个状态的父"
"体中被实例化. 这有助于在编程中被称为*内聚的东西. 玩家的状态不希望承担创建这些"
"变量的责任, 但确实希望能够使用它们. 然而, 这确实使状态与状态的父体*耦合. 这意"
"味着, 状态高度依赖于它是否有一个包含这些变量的父体. 所以, 请记住, 当涉及到代"
"码管理时,*耦合* 和 *内聚* 是重要的概念."

#: ../../docs/tutorials/misc/state_design_pattern.rst:75
msgid ""
"See the following page for more details on cohesion and coupling: https://"
"courses.cs.washington.edu/courses/cse403/96sp/coupling-cohesion.html"
msgstr ""
"有关内聚力和耦合的更多详情, 请参见以下网页:https://courses.cs.washington.edu/"
"courses/cse403/96sp/coupling-cohesion.html"

#: ../../docs/tutorials/misc/state_design_pattern.rst:78
msgid ""
"Second, there are some methods in the script for moving, but no "
"implementation. The state script just uses ``pass`` to show that it will not "
"execute any instructions when the methods are called. This is important."
msgstr "其次, 脚本中还有一些移动的方法, 但没有实现. 这一点很重要."

#: ../../docs/tutorials/misc/state_design_pattern.rst:81
msgid ""
"Third, the ``_physics_process(delta)`` method is actually implemented here. "
"This allows the states to have a default ``_physics_process(delta)`` "
"implementation where ``velocity`` is used to move the player. The way that "
"the states can modify the movement of the player is to use the ``velocity`` "
"variable defined in their base class."
msgstr ""
"第三, 这里实际上实现了 ``_physics_process(delta)`` 方法. 这使得状态可以有一个"
"默认的 ``_physics_process(delta)`` 实现, 其中 ``velocity`` 用于移动玩家. 状态"
"可以修改玩家移动的方法是使用定义在其基类中的 ``velocity`` 变量."

#: ../../docs/tutorials/misc/state_design_pattern.rst:85
msgid ""
"Finally, this script is actually being designated as a class named "
"``State``. This makes refactoring the code easier, since the file path from "
"using the ``load()`` and ``preload()`` functions in Godot will not be needed."
msgstr ""
"最后, 这个脚本实际上被指定为一个名为 ``State`` 的类. 这使得重构代码变得更容"
"易, 因为在Godot中使用 ``load()`` 和 ``preload()`` 函数的文件路径将不再需要."

#: ../../docs/tutorials/misc/state_design_pattern.rst:88
msgid ""
"So, now that there is a base state, the two states discussed earlier can be "
"implemented."
msgstr "所以, 现在有了基础状态, 前面讨论的两种状态就可以实现了."

#: ../../docs/tutorials/misc/state_design_pattern.rst:154
msgid ""
"Since the ``Run`` and ``Idle`` states extend from ``State`` which extends "
"``Node2D``, the function ``_physics_process(delta)`` is called from the "
"**bottom-up** meaning ``Run`` and ``Idle`` will call their implementation of "
"``_physics_process(delta)``, then ``State`` will call its implementation, "
"then ``Node2D`` will call its own implementation and so on. This may seem "
"strange, but it is only relevant for predefined functions such as "
"``_ready()``, ``_process(delta)``, etc. Custom functions use the normal "
"inheritance rules of overriding the base implementation."
msgstr ""
"由于 ``Run`` 和 ``Idle`` 状态是从 ``State`` 延伸出来的, 而 ``State`` 又是 "
"``Node2D`` 的延伸, 所以函数 ``_physics_process(delta)`` 是从 **底向上** 调用"
"的, 也就是说 ``Run`` 和 ``Idle`` 将调用它们的实现 "
"``_physics_process(delta)`` . 然后 ``State`` 将调用它的实现, 然后 ``Node2D`` "
"将调用它自己的实现, 以此类推. 这可能看起来很奇怪, 但它只与预定义函数有关, 如 "
"``_ready()`` , ``_process(delta)`` 等. 自定义函数使用正常的继承规则, 即覆盖基"
"础实现."

#: ../../docs/tutorials/misc/state_design_pattern.rst:161
msgid ""
"There is a roundabout method for obtaining a state instance. A state factory "
"can be used."
msgstr "有一种迂回的方法可以获得一个状态实例. 可以使用状态工厂."

#: ../../docs/tutorials/misc/state_design_pattern.rst:184
msgid ""
"This will look for states in a dictionary and return the state if found."
msgstr "这将在字典中查找状态, 如果找到则返回状态."

#: ../../docs/tutorials/misc/state_design_pattern.rst:186
msgid ""
"Now that all the states are defined with their own scripts, it is time to "
"figure out how those references that passed to them will be instantiated. "
"Since these references will not change it makes sense to call this new "
"script ``persistent_state.gd``."
msgstr ""
"现在, 所有的状态都用自己的脚本定义了, 现在是时候弄清楚如何实例化那些传递给它"
"们的引用了. 由于这些引用不会改变, 所以调用这个新脚本 ``persistent_state.gd`` "
"是有意义的."

#: ../../docs/tutorials/misc/state_design_pattern.rst:230
msgid ""
"The ``persistent_state.gd`` script contains code for detecting input. This "
"was to make the tutorial simple, but it is not usually best practice to do "
"this."
msgstr ""
"``persistent_state.gd`` 脚本包含检测输入的代码. 这是为了使教程简单化, 但通常"
"这样做不是最好的做法."

#: ../../docs/tutorials/misc/state_design_pattern.rst:234
msgid "Project setup"
msgstr "项目设置"

#: ../../docs/tutorials/misc/state_design_pattern.rst:236
msgid ""
"This tutorial made an assumption that the node it would be attached to "
"contained a child node which is an :ref:`AnimatedSprite "
"<class_AnimatedSprite>`. There is also the assumption that this :ref:"
"`AnimatedSprite <class_AnimatedSprite>` has at least two animations, the "
"idle and run animations. Also, the top-level node is assumed to be a :ref:"
"`KinematicBody2D <class_KinematicBody2D>`."
msgstr ""
"本教程做了一个假设, 即它要连接的节点包含一个子节点, 这个子节点是一个 :ref:"
"`AnimatedSprite <class_AnimatedSprite>`. 还有一个假设是, 这个 :ref:"
"`AnimatedSprite <class_AnimatedSprite>` 至少有两个动画, 即空闲和运行动画. 另"
"外, 还假设顶层节点是一个 :ref:`KinematicBody2D <class_KinematicBody2D>`."

#: ../../docs/tutorials/misc/state_design_pattern.rst:243
msgid ""
"The zip file of the llama used in this tutorial is :download:`here <files/"
"llama.zip>`. The source was from `piskel_llama <https://www.piskelapp.com/p/"
"agxzfnBpc2tlbC1hcHByEwsSBlBpc2tlbBiAgICfx5ygCQw/edit>`_, but I couldn't find "
"the original creator information on that page... There is also a good "
"tutorial for sprite animation already. See :ref:`2D Sprite Animation "
"<doc_2d_sprite_animation>`."
msgstr ""
"本教程中使用的骆驼的压缩文件是: 下载: `here <files/llama.zip>` . 源自 "
"`piskel_llama <https://www.piskelapp.com/p/"
"agxzfnBpc2tlbC1hcHByEwsSBlBpc2tlbBiAgICfx5ygCQw/edit>`_ , 但我在那个页面上找"
"不到原创作者的信息...... 还有一个好的精灵动画教程已经有了. 参见 :ref:`2D 精灵"
"动画 <doc_2d_sprite_animation>` ."

#: ../../docs/tutorials/misc/state_design_pattern.rst:248
msgid ""
"So, the only script that must be attached is ``persistent_state.gd``, which  "
"should be attached to the top node of the player, which is a :ref:"
"`KinematicBody2D <class_KinematicBody2D>`."
msgstr ""
"所以, 唯一必须附加的脚本是 ``persistent_state.gd`` , 它应该附加在玩家的顶部节"
"点上, 这是一个 :ref:`KinematicBody2D <class_KinematicBody2D>` ."

#: ../../docs/tutorials/misc/state_design_pattern.rst:255
msgid ""
"Now the player has utilized the state design pattern to implement its two "
"different states. The nice part of this pattern is that if one wanted to add "
"another state, then it would involve creating another class that need only "
"focus on itself and how it changes to another state. Each state is "
"functionally separated and instantiated dynamically."
msgstr ""
"现在玩家已经利用状态设计模式实现了它的两种不同的状态. 这种模式的好处是, 如果"
"想要添加另一个状态, 那么就需要创建另一个类, 而这个类只需要关注自己以及如何变"
"化到另一个状态. 每个状态在功能上是分离的, 并且是动态实例化的."
