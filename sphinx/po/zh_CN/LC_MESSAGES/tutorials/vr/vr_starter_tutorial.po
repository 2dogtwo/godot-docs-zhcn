# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2018, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-12-13 12:14+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:4
msgid "VR starter tutorial"
msgstr "VR入门教程"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:7
msgid "Introduction"
msgstr "简介"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:11
msgid ""
"This tutorial series will show you how to make a simple VR game/project. The "
"intent of this tutorial is to give you an idea on how to make VR games in "
"Godot."
msgstr ""
"本系列教程将向您展示如何制作简单的VR游戏/项目。 本教程的目的是让您了解如何在"
"Godot中制作VR游戏。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:14
msgid ""
"Keep in mind, **one of the most important things when making VR content is "
"getting the scale of your assets correct**! It can take lots of practice and "
"iterations to get this right, but there are a few things you can do to make "
"it easier:"
msgstr ""
"请记住，**制作VR内容时最重要的事情之一是保证您的资源大小合适**！ 这可以通过大"
"量练习和反复调整来实现这一目标，但是您可以采取一些措施来简化这个过程："

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:17
msgid ""
"In VR, 1 unit is often considered 1 meter. If you design your assets around "
"that standard, you can save yourself a lot of headache."
msgstr ""
"在VR中，1个单位通常被认为是1米。 如果按照该标准设计资产，可以省去很多麻烦。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:18
msgid ""
"In your 3D model program, see if there is a way to measure and use real "
"world distances. In Blender you can use the MeasureIt add-on, in Maya you "
"can use the Measure Tool."
msgstr ""
"在3D模型程序中，查看是否有测量和使用真实世界距离的方法。 在Blender中，您可以"
"使用MeasureIt插件，在Maya中，您可以使用测量工具。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:19
msgid ""
"You can make rough models using a tool like `Google Blocks <https://vr."
"google.com/blocks/>`_, and then refine in another 3D modelling program."
msgstr ""
"您可以使用诸如“Google Blocks <https://vr.google.com/blocks/>`_之类的工具制作"
"粗略模型，然后在另一个3D建模程序中进行优化。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:20
msgid ""
"Test often, as the assets can look dramatically different in VR than on a "
"flat screen!"
msgstr "经常测试，因为VR中的资产看起来与平面屏幕上的显着不同！"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:22
msgid "Throughout the course of this tutorial, we will cover:"
msgstr "在本教程的整个过程中，我们将介绍："

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:24
msgid "How to tell Godot to run in VR."
msgstr "如何让Godot以VR模式运行。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:25
msgid "How to make a teleportation system for moving the player."
msgstr "如何制作用于移动游戏角色的传送系统。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:26
msgid ""
"How to make a directional movement system (locomotion) for moving the player."
msgstr "如何制作用于移动玩家的定向移动系统（移动）。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:27
msgid ""
"How to make a :ref:`RigidBody <class_RigidBody>` based pick up and drop "
"system."
msgstr "如何制作一个：ref：`RigidBody <class_RigidBody>`基于拾取和放下系统。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:28
msgid "How to make various items that can be used in VR"
msgstr "如何制作可在VR中使用的各种物品"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:30
msgid ""
"While this tutorial can be completed by beginners, it is highly advised to "
"complete :ref:`doc_your_first_game`, if you are new to Godot and/or game "
"development and have some experience with making 3D games **before** going "
"through this tutorial series."
msgstr ""
"虽然本教程可以由初学者完成，但强烈建议您完成：ref：`doc_your_first_game`，如"
"果您是Godot和/或游戏开发的新手，并且在完成本教程之前有一些制作3D游戏的经验** "
"系列。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:35
msgid ""
"This tutorial assumes you know have experience working with the Godot "
"editor, have basic programming experience in GDScript, and have basic 3D "
"game development experience."
msgstr ""
"本教程假设您具有使用Godot编辑器的经验，具有GDScript的基本编程经验，并具有基本"
"的3D游戏开发经验。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:38
msgid ""
"Also, it is assumed you have both a OpenVR-ready headset and two OpenVR-"
"ready controllers! This tutorial was written using a Windows Mixed Reality "
"headset on Windows 10, so the tutorial is written to work on that headset. "
"You may need to adjust the code to work with other VR headsets such as the "
"Oculus Rift or HTC Vive."
msgstr ""
"此外，假设您有一个支持OpenVR的耳机和两个支持OpenVR的控制器！ 本教程是在"
"Windows 10上使用Windows Mixed Reality耳机编写的，因此编写本教程是为了使用该耳"
"机。 您可能需要调整代码以使用其他VR耳机，例如Oculus Rift或HTC Vive。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:41
msgid ""
"You can find the start assets for this tutorial here: :download:"
"`VR_Starter_Tutorial_Start.zip <files/VR_Starter_Tutorial_Start.zip>`"
msgstr ""
"您可以在此处找到本教程的起始资产:: download：`VR_Starter_Tutorial_Start.zip "
"<files / VR_Starter_Tutorial_Start.zip>`"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:43
msgid ""
"The provided starter assets contain some 3D models, sounds, and a few scenes "
"already set up and configured for this tutorial."
msgstr ""
"提供的初始化资源包含一些3D模型，声音以及已为本教程设置和配置的一些场景。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:45
msgid ""
"Feel free to use these assets however you want! All original assets belong "
"to the Godot community, with the other assets belonging to those listed "
"below:"
msgstr ""
"您可以随意使用这些资产！ 所有原始资产均属于戈多社区，其他资产属于以下列出的资"
"产："

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:47
msgid ""
"The sky panorama was created by **CGTuts** and can be found `here <https://"
"cgi.tutsplus.com/articles/freebie-8-awesome-ocean-hdris--cg-5684>`_."
msgstr ""
"天空全景由 **CGTuts** 创建，可在 `此处找到 <https://cgi.tutsplus.com/"
"articles/freebie-8-awesome-ocean-hdris--cg-5684>`_。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:49
msgid ""
"The font used is **Titillium-Regular**, and is licensed under the SIL Open "
"Font License, Version 1.1."
msgstr ""
"使用的字体是** Titillium-Regular **，并根据SIL Open Font License 1.1版获得许"
"可。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:51
msgid ""
"The audio used are from several different sources, all downloaded from the "
"**Sonnis #GameAudioGDC Bundle**. The license for the sound effects is "
"included as a PDF `here <https://sonniss.com/gdc-bundle-license/>`_. The "
"folders where the audio files are stored have the same name as folders in "
"the bundle."
msgstr ""
"所使用的音频来自几个不同的来源，都来自 **Sonnis #GameAudioGDC Bundle**。 声音"
"效果的许可证包含在PDF `此处 <https://sonniss.com/gdc-bundle-license/>`_中。 "
"存储音频文件的文件夹与包中的文件夹具有相同的名称。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:54
msgid ""
"The **OpenVR addon** was created by Bastiaan Olij and is released under the "
"MIT license. It can be found both `on the Asset Library <https://godotengine."
"org/asset-library/asset/150>`_ and `on GitHub <https://github.com/GodotVR/"
"godot-openvr-asset>`_."
msgstr ""
"** OpenVR插件**由Bastiaan Olij创建，并在MIT许可下发布。 它可以在 `资产库 "
"<https://godotengine.org/asset-library/asset/150>`_ 和在 `GitHub上找到 "
"<https://github.com/GodotVR/godot-openvr-asset>`_。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:56
msgid ""
"Everything else is original and created solely for this tutorial by "
"TwistedTwigleg. They are released under the MIT license, so feel free to use "
"them however you see fit!"
msgstr ""
"其他一切都是原创的，仅由TwistedTwigleg为本教程创建。 它们是在MIT许可下发布"
"的，所以您可以随意使用它们，但是您认为合适！"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:58
msgid "You can find the finished project at the bottom of this page."
msgstr "您可以在本页底部找到已完成的项目。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:61
msgid "Getting everything ready"
msgstr "准备好一切"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:63
msgid "Launch Godot and open up the project included in the starter assets."
msgstr "启动Godot并打开启动资产中包含的项目。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:65
msgid ""
"While these assets are not necessarily required to use the scripts provided "
"in this tutorial, they will make the tutorial much easier to follow as there "
"are several premade scenes we will be using throughout the tutorial series."
msgstr ""
"虽然这些资源不一定需要使用本教程中提供的脚本，但它们将使教程更容易理解，因为"
"我们将在整个教程系列中使用几个预制场景。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:69
msgid ""
"First, you may notice there is already quite a bit set up. This includes a "
"pre-built level, several instanced scenes placed around, some background "
"music, and several GUI-related :ref:`MeshInstances <class_MeshInstance>` "
"nodes."
msgstr ""
"首先，您可能会注意到已经设置了很多。 这包括预先构建的级别，放置的几个实例场"
"景，一些背景音乐，以及几个与GUI相关的：ref：`MeshInstances "
"<class_MeshInstance>`节点。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:72
msgid ""
"You may notice that the GUI-related meshes already have a script attached to "
"them, and this is simply used to show whatever is inside the :ref:`Viewport "
"<class_Viewport>` on the mesh. Feel free to take a look if you want, but "
"this tutorial will not be going over how to use the :ref:`Viewport "
"<class_Viewport>` nodes for making 3D GUI :ref:`MeshInstance "
"<class_MeshInstance>` nodes."
msgstr ""
"您可能会注意到与GUI相关的网格已经附加了一个脚本，这只是用于显示网格上的："
"ref：`Viewport <class_Viewport>`内的任何内容。 如果您愿意，请随意查看，但本教"
"程不会讨论如何使用：ref：`Viewport <class_Viewport>`节点来制作3D GUI：ref："
"`MeshInstance <class_MeshInstance>`节点。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:76
msgid ""
"The other thing to notice before we jump into writing the code is how the :"
"ref:`ARVROrigin <class_ARVROrigin>` node works. How it works is kind of hard "
"to explain, especially if you have never used VR before, but here is the "
"gist of it: The :ref:`ARVROrigin <class_ARVROrigin>` node is the center "
"point of the room. If there is no room-scale tracking, then the :ref:"
"`ARVROrigin <class_ARVROrigin>` will be directly below the player, but if "
"there is room-scale tracking, then the :ref:`ARVROrigin <class_ARVROrigin>` "
"will be the center of the tracked room."
msgstr ""
"在我们开始编写代码之前要注意的另一件事是：ref：`ARVROrigin "
"<class_ARVROrigin>`节点是如何工作的。 它是如何工作的有点难以解释，特别是如果"
"你之前从未使用过VR，但这里有它的要点：：ref：`ARVROrigin <class_ARVROrigin>`"
"节点是房间的中心点。 如果没有房间尺度跟踪，那么：ref：`ARVROrigin "
"<class_ARVROrigin>`将直接位于玩家的下方，但是如果有房间尺度跟踪，那么：ref："
"`ARVROrigin <class_ARVROrigin>`将是 被跟踪的房间的中心。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:81
msgid ""
"This is a bit of a simplification, and honestly, I do not know enough about "
"the various different VR headsets and how they work to give a more detailed "
"and complete explanation. The simple way is to look at it like this: The :"
"ref:`ARVROrigin <class_ARVROrigin>` is the center of the VR world. If there "
"is room tracking, the player can move away from the center point, the :ref:"
"`ARVROrigin <class_ARVROrigin>` node, but only as far as the room scaling "
"tracks."
msgstr ""
"这有点简化，老实说，我对各种不同的VR耳机以及它们如何工作以提供更详细和完整的"
"解释知之甚少。 简单的方法就是这样看：它：ref：`ARVROrigin <class_ARVROrigin>`"
"是VR世界的中心。 如果有房间跟踪，玩家可以远离中心点，即：ref：`ARVROrigin "
"<class_ARVROrigin>`节点，但只能移动到房间缩放轨道。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:85
msgid ""
"If you select the :ref:`ARVROrigin <class_ARVROrigin>` node, you may notice "
"that the world scale is set to ``1.4``. This is because I originally made "
"the world too big, and so I needed to scale the VR player slightly so they "
"better fit the world. As mentioned earlier, keeping the scale relatively "
"constant is very important!"
msgstr ""
"如果选择：ref：`ARVROrigin <class_ARVROrigin>`节点，您可能会注意到世界比例设"
"置为“1.4”。 这是因为我最初让世界变得太大，所以我需要稍微扩展VR播放器以便它们"
"更适合这个世界。 如前所述，保持比例相对稳定非常重要！"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:88
msgid ""
"Another thing to notice here is how we have everything set up under the :ref:"
"`ARVROrigin <class_ARVROrigin>` node. The player camera is a :ref:"
"`ARVRCamera <class_ARVRCamera>` that represents the player's head in the "
"game. The :ref:`ARVRCamera <class_ARVRCamera>` will be offset by the "
"player's height, and if there is room tracking, then the camera can move "
"around 3D space as well, relative to the :ref:`ARVROrigin "
"<class_ARVROrigin>`. This is important to note, especially for later when we "
"add teleporting."
msgstr ""
"另外需要注意的是我们如何在：ref：`ARVROrigin <class_ARVROrigin>`节点下设置所"
"有内容。 玩家相机是：ref：`ARVRCamera <class_ARVRCamera>`代表玩家在游戏中的头"
"部。 ：ref：`ARVRCamera <class_ARVRCamera>`将被玩家的高度偏移，如果有房间跟"
"踪，那么相对于：ref：`ARVROrigin <class_ARVROrigin>`，相机也可以在3D空间中移"
"动。 这一点很重要，特别是以后我们添加传送时。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:92
msgid ""
"Notice how there is a :ref:`ColorRect <class_ColorRect>` node called "
"``Movement_Vignette``. This will be a vignette shader that will only be "
"visible when the player is moving. We are going to use the vignette shader "
"to help reduce motion sickness while moving in VR. The reason it is a child "
"of :ref:`ARVROrigin <class_ARVROrigin>` is because we want it to easily "
"access the VR controllers."
msgstr ""
"注意如何：ref：`ColorRect <class_ColorRect>`节点名为``Movement_Vignette``。 "
"这将是一个小插图着色器，只有在玩家移动时才会显示。 我们将使用晕影着色器来帮助"
"减少在VR中移动时的晕动病。 它是孩子的原因：ref：`ARVROrigin "
"<class_ARVROrigin>`是因为我们希望它能够轻松访问VR控制器。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:96
msgid ""
"The final thing to note is that there are two :ref:`ARVRController "
"<class_ARVRController>` nodes, and these will represent the left and right "
"controllers in 3D space. A :ref:`ARVRController <class_ARVRController>` with "
"an ID of 1 is the left hand, while a :ref:`ARVRController "
"<class_ARVRController>` with an ID of 2 is the right hand."
msgstr ""
"最后要注意的是有两个：ref：`ARVRController <class_ARVRController>`节点，这些"
"节点将代表3D空间中的左右控制器。 答：ref：`ARVRController "
"<class_ARVRController>`的ID是左手，而a：ref：`ARVRController "
"<class_ARVRController>`的ID是右手。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:100
msgid "Starting VR"
msgstr "启动VR"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:102
msgid ""
"First, let's get the VR up and going! While ``Game.tscn`` is open, select "
"the ``Game`` node and make a new script called ``Game.gd``. Add the "
"following code:"
msgstr ""
"首先，让我们开始VR吧！ 当``Game.tscn``打开时，选择``Game``节点并创建一个名为"
"``Game.gd``的新脚本。 添加以下代码："

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:119
msgid ""
"For this to work, you will need to have the `OpenVR asset from the Asset "
"Library <https://godotengine.org/asset-library/asset/150>`_. The OpenVR "
"asset is included in the starter assets, but there may be newer versions "
"that work better, so I would highly suggest deleting the ``addons`` folder, "
"then going to the Asset Library and downloading the newest version."
msgstr ""
"要实现这一点，您需要拥有资产库中的 `OpenVR资产 <https://godotengine.org/"
"asset-library/asset/150>`_。 OpenVR资产包含在初始资产中，但可能有更新版本更"
"好，所以我强烈建议删除 ``addons`` 文件夹，然后转到资源库并下载最新版本。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:123
msgid "With that done, let's quickly go over what this script does."
msgstr "完成后，让我们快速浏览一下这个脚本的功能。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:125
msgid ""
"First, we find a VR interface from the ARVR server. We do this because by "
"default Godot does not include any VR interfaces, but rather exposes a API "
"so anyone can make AR/VR interfaces with GDNative/C++. Next, we check to see "
"if a OpenVR interface was found, and then we initialize it."
msgstr ""
"首先，我们从ARVR服务器找到VR接口。 我们这样做是因为默认情况下，Godot不包含任"
"何VR接口，而是公开API，因此任何人都可以使用GDNative / C ++制作AR / VR接口。 "
"接下来，我们检查是否找到了OpenVR接口，然后我们初始化它。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:128
msgid ""
"Assuming nothing went wrong with initializing, we then turn the main :ref:"
"`Viewport <class_Viewport>` into a AR/VR viewport, by setting ``arvr`` to "
"``true``. We also set HDR to ``false``, since you cannot use HDR in OpenVR."
msgstr ""
"假设初始化没有出错，我们将main：ref：`Viewport <class_Viewport>`转换为AR / VR"
"视口，将``arvr``设置为``true``。 我们还将HDR设置为“false”，因为您无法在OpenVR"
"中使用HDR。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:131
msgid ""
"Then we disable V-Sync and set the target FPS to 90 frames per second. Most "
"VR headsets run at 90 Hz, and since the game will both display on the VR "
"headset and on the computer's monitor, we want to disable V-Sync and set the "
"target FPS manually so the computer's monitor does not drag the VR display "
"down to 60 FPS."
msgstr ""
"然后我们禁用V-Sync并将目标FPS设置为每秒90帧。 大多数VR头戴式耳机以90 Hz的频率"
"运行，由于游戏将同时显示在VR头戴式耳机和计算机的显示器上，我们希望禁用V-Sync"
"并手动设置目标FPS，以便计算机的显示器不会将VR显示器拖动到 60 FPS。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:134
msgid ""
"One thing to notice as well is that the physics FPS is also set to 90! This "
"makes the physics run at the same frame rate as the display, which makes "
"things look smoother in VR."
msgstr ""
"有一点需要注意的是，物理FPS也设置为90！ 这使得物理运行与显示器的帧速率相同，"
"这使VR中的内容看起来更平滑。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:139
msgid ""
"With that done, go ahead and give the game a try! If everything goes well, "
"you will now be able to look around the world! If you have a VR headset with "
"room tracking, you will be able to move around as far as the room tracking "
"allows."
msgstr ""
"完成后，继续尝试游戏吧！ 如果一切顺利，您现在可以环顾世界！ 如果您的VR耳机具"
"有房间跟踪功能，您可以在房间跟踪允许的情况下四处移动。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:143
msgid "Coding the controllers"
msgstr "编码控制器"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:145
msgid ""
"While perhaps interesting if we were making a VR film, we really want to do "
"more than stand around and look. Currently we cannot move outside of the "
"room tracking boundaries (assuming your VR headset has room tracking) and we "
"cannot interact with anything! Let's change that!"
msgstr ""
"虽然我们制作VR电影可能很有意思，但我们真的想做的不仅仅是站着看看。 目前我们无"
"法移动到房间跟踪边界之外（假设您的VR耳机有房间跟踪），我们无法与任何东西互"
"动！ 让我们改变它！"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:148
msgid ""
"You may have noticed that you have a pair of green and black hands following "
"the controllers. Let's write the code for those controllers, which will "
"allow the player to teleport around the world and allow the player to grab "
"and release :ref:`RigidBody <class_RigidBody>` nodes."
msgstr ""
"您可能已经注意到控制器后面有一对绿色和黑色指针。 让我们为这些控制器编写代码，"
"这将允许玩家在世界各地传送并允许玩家抓取并释放：ref：`RigidBody "
"<class_RigidBody>`节点。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:151
msgid ""
"Open either ``Left_Controller.tscn`` or ``Right_Controller.tscn``. Feel free "
"to look at how the scene is set up; there is only a couple things of note to "
"point out."
msgstr ""
"打开``Left_Controller.tscn``或``Right_Controller.tscn``。 随意看看场景是如何"
"设置的; 只有几点值得注意。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:153
msgid ""
"First, notice how there is a couple :ref:`Raycast <class_Raycast>` nodes. We "
"will be using one :ref:`Raycast <class_Raycast>` to teleport around the game "
"world (``Raycast``) and we will use the other for picking up objects "
"(``GrabCast``) if the player is using :ref:`Raycast <class_Raycast>` nodes "
"to pick up objects."
msgstr ""
"首先，注意如何有一对：ref：`Raycast <class_Raycast>`节点。 我们将使用一个："
"ref：`Raycast <class_Raycast>`来传送游戏世界（``Raycast``），如果玩家正在使"
"用，我们将使用另一个来拾取对象（``GrabCast``）： ref：`Raycast "
"<class_Raycast>`节点来拾取对象。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:156
msgid ""
"The other thing to note is how there is an :ref:`Area <class_Area>` simply "
"called ``Area``, that is a small sphere in the palm of the hand. This will "
"be used to detect objects the player can pick up with that hand if the "
"player is using :ref:`Area <class_Area>` nodes to pick up objects."
msgstr ""
"另外需要注意的是：如何存在：ref：`Area <class_Area>`简称为``Area``，这是手掌"
"中的一个小球体。 如果玩家正在使用，这将用于检测玩家可以用该手拿起的对象："
"ref：`Area <class_Area>`节点来拾取对象。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:159
msgid ""
"We also have a larger :ref:`Area <class_Area>` called ``Sleep_Area``, which "
"will simply be used to wake :ref:`RigidBody <class_RigidBody>` nodes when "
"the hands get close."
msgstr ""
"我们还有一个更大的：ref：`Area <class_Area>`名为``Sleep_Area``，它只是用来唤"
"醒：当手靠近时ref：`RigidBody <class_RigidBody>`节点。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:161
msgid ""
"Select the root node, either ``Left_Controller`` or ``Right_Controller`` "
"depending on which scene you chose, and create a new script called "
"``VR_Controller.gd``. Add the following to ``VR_Controller.gd``:"
msgstr ""
"根据您选择的场景选择根节点，``Left_Controller``或``Right_Controller``，并创建"
"一个名为``VR_Controller.gd``的新脚本。 将以下内容添加到``VR_Controller.gd``："

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:415
msgid ""
"This is quite a bit of code to go through, so let's break it down bit by "
"bit. Let's start with the class variables, which are variables outside of "
"any/all functions."
msgstr ""
"这是相当多的代码，所以让我们一点一点地分解它。 让我们从类变量开始，这些变量是"
"任何/所有函数之外的变量。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:418
msgid ""
"``controller_velocity``: The velocity the controller is moving at. We will "
"calculate this by changes in position every physics frame."
msgstr ""
"``controller_velocity``：控制器移动的速度。 我们将通过每个物理框架的位置变化"
"来计算它。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:419
msgid ""
"``prior_controller_position``: The controller's previous position. We will "
"use this to calculate the controller's velocity."
msgstr ""
"``prior_controller_position``：控制器的先前位置。 我们将使用它来计算控制器的"
"速度。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:420
msgid ""
"``prior_controller_velocities``: The last 30 calculated velocities (1/3 of a "
"second worth of velocities, assuming the game is running at 90 FPS)."
msgstr ""
"``prior_controller_velocities``：最后30个计算的速度（速度的1/3，假设游戏以90 "
"FPS运行）。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:421
msgid ""
"``held_object``: The currently-held object, a :ref:`RigidBody "
"<class_RigidBody>`, if there is one."
msgstr ""
"``held_object``：当前持有的对象，a：ref：`RigidBody <class_RigidBody>`，如果"
"有的话。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:422
msgid ""
"``held_object_data``: The data of the currently-held object, used to reset "
"the object when it is no longer being held."
msgstr ""
"``held_object_data``：当前保持对象的数据，用于在不再保持对象时重置对象。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:423
msgid "``grab_area``: The :ref:`Area <class_Area>` node used to grab objects."
msgstr "``grab_area``：用于抓取对象的：ref：`Area <class_Area>`节点。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:424
msgid "``grab_pos_node``: The position where held objects stay."
msgstr "``grab_pos_node``：保持对象所在的位置。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:425
msgid ""
"``hand_mesh``: The hand mesh, used to represent the player's hand when they "
"are not holding anything."
msgstr "``hand_mesh``：手形网格，用于表示玩家手上没有任何东西时的手牌。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:426
msgid ""
"``teleport_pos``: The position the teleport :ref:`Raycast <class_Raycast>` "
"is aimed at."
msgstr "``teleport_pos``：传送的位置：ref：`Raycast <class_Raycast>`的目标是。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:427
msgid "``teleport_mesh``: The meshed used to represent the teleport position."
msgstr "``teleport_mesh``：用于表示传送位置的网格。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:428
msgid ""
"``teleport_button_down``: A variable for tracking whether the teleport "
"button is being held down or not."
msgstr "``teleport_button_down``：用于跟踪传送按钮是否被按下的变量。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:429
msgid ""
"``teleport_raycast``: The teleport :ref:`Raycast <class_Raycast>` node, used "
"for calculating the teleportation position."
msgstr ""
"``teleport_raycast``：传送：ref：`Raycast <class_Raycast>`节点，用于计算传送"
"位置。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:430
msgid ""
"``CONTROLLER_DEADZONE``: The dead zone for both the trackpad and the "
"joystick."
msgstr "``CONTROLLER DEADZONE``：触控板和操纵杆的死区。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:431
msgid ""
"``MOVEMENT_SPEED``: The speed the player moves at when moving using the "
"trackpad and/or the joystick."
msgstr "``MOVEMENT_SPEED``：使用触控板和/或操纵杆移动时玩家移动的速度。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:432
msgid ""
"``directional_movement``: A boolean to track whether the player is moving "
"using this controller."
msgstr ""
"``directional_movement``：一个布尔值，用于跟踪玩家是否正在使用此控制器移动。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:436
msgid "Next, let's go through ``_ready``."
msgstr "接下来，让我们通过``_ready``。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:438
msgid ""
"First we get the teleport :ref:`Raycast <class_Raycast>` node and assign it "
"to ``teleport_raycast``."
msgstr ""
"首先我们得到teleport：ref：`Raycast <class_Raycast>`节点并将其分配给"
"``teleport_raycast``。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:440
msgid ""
"Next, we get the teleport mesh; notice how we are getting it from ``Game/"
"Teleport_Mesh`` using ``get_tree().root``. This is because we need the "
"teleport mesh to be separate from the controller, so moving and rotating the "
"controller does not affect the position and rotation of the teleportation "
"mesh."
msgstr ""
"接下来，我们得到了传送网; 注意我们如何使用``get_tree（）。root``从``Game / "
"Teleport_Mesh``获取它。 这是因为我们需要将传送网格与控制器分开，因此移动和旋"
"转控制器不会影响传送网格的位置和旋转。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:443
msgid ""
"Then we get the grab area, grab :ref:`Raycast <class_Raycast>`, and position "
"node and assign them to the proper variables."
msgstr ""
"然后我们得到抓取区域，抓住：ref：`Raycast <class_Raycast>`，并定位节点并将它"
"们分配给适当的变量。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:445
msgid ""
"We set the default grab mode to ``AREA`` so it uses the :ref:`Area "
"<class_Area>` node to grab objects by default."
msgstr ""
"我们将默认的抓取模式设置为``AREA``，因此它使用：ref：`Area <class_Area>`节点"
"默认抓取对象。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:447
msgid ""
"Then we connect the ``body_entered`` and ``body_exited`` signals from the "
"sleep area node, we get the hand mesh and assign it the proper variable, and "
"finally we connect the ``button_pressed`` and ``button_released`` signals "
"from the :ref:`ARVRController <class_ARVRController>`."
msgstr ""
"然后我们连接来自睡眠区域节点的``body_entered``和``body_exited``信号，我们获得"
"手网格并为其分配适当的变量，最后我们连接``button_pressed``和"
"``button_released`` 来自：ref：`ARVRController <class_ARVRController>`的信"
"号。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:452
msgid "Now let's go through ``_physics_process``."
msgstr "现在让我们来看看`_physics_process``。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:454
msgid ""
"First, we check to see if the teleportation button is down or not. If the "
"teleportation button is down, we then force the teleportation :ref:`Raycast "
"<class_Raycast>` to update, which will give us frame perfect collision "
"detection. We then check to see if the :ref:`Raycast <class_Raycast>` is "
"colliding with anything."
msgstr ""
"首先，我们检查传送按钮是否关闭。 如果传送按钮关闭，我们然后强制传送：ref："
"`Raycast <class_Raycast>`更新，这将给我们帧完美的碰撞检测。 然后我们检查："
"ref：`Raycast <class_Raycast>`是否与任何东西发生碰撞。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:457
msgid ""
"Next, we check to see if the collision body the :ref:`Raycast "
"<class_Raycast>` is colliding with is a :ref:`StaticBody "
"<class_StaticBody>`. We do this to ensures the player can only teleport on :"
"ref:`StaticBody <class_StaticBody>` nodes. We then check to see if the ``Y`` "
"value returned by the :ref:`Raycast <class_Raycast>`'s "
"``get_collision_normal`` function is more than ``0.85``, which is mostly "
"pointing straight up. This allows the player only to teleport on fairly flat "
"faces pointing upwards."
msgstr ""
"接下来，我们检查一下碰撞体是否与：ref：`Raycast <class_Raycast>`碰撞的是："
"ref：`StaticBody <class_StaticBody>`。 我们这样做是为了确保玩家只能传送："
"ref：`StaticBody <class_StaticBody>`节点。 然后我们检查一下：ref：`Raycast "
"<class_Raycast>`的``get_collision_normal``函数返回的``Y``值是否大于``0.85``，"
"这大多指向直线。 这允许玩家仅在相当平坦的面向上传送。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:461
msgid ""
"If all those checks for the teleport :ref:`Raycast <class_Raycast>` return "
"true, we then set ``teleport_pos`` to the collision point, and we move the "
"teleportation mesh to ``teleport_pos``."
msgstr ""
"如果对teleport的所有检查：ref：`Raycast <class_Raycast>`返回true，我们将"
"``teleport_pos``设置为碰撞点，然后我们将远程传送网格移动到``teleport_pos``。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:464
msgid ""
"The next thing we check is to see if the :ref:`ARVRController "
"<class_ARVRController>` is active or not. If the :ref:`ARVRController "
"<class_ARVRController>` is active, then that means there is a controller and "
"it is being tracked. If the controller is active, we then reset "
"``controller_velocity`` to a empty :ref:`Vector3 <class_Vector3>`."
msgstr ""
"接下来我们要检查的是：ref：`ARVRController <class_ARVRController>`是否处于活"
"动状态。 如果：ref：`ARVRController <class_ARVRController>`处于活动状态，则表"
"示存在控制器并且正在跟踪它。 如果控制器处于活动状态，我们将"
"``controller_velocity``重置为空：ref：`Vector3 <class_Vector3>`。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:467
msgid ""
"We then add all of the prior velocity calculations in "
"``prior_controller_velocities`` to ``controller_velocity``. By using the "
"prior calculations, we get a smoother throwing/catching experience, although "
"it is not perfect. We want to get the average of these velocities, as "
"otherwise we'd get crazy high velocity numbers that are not realistic."
msgstr ""
"然后，我们将``prior_controller_velocities``中的所有先前速度计算添加到"
"``controller_velocity``中。 通过使用先前的计算，我们获得了更平滑的投掷/捕捉体"
"验，尽管它并不完美。 我们希望得到这些速度的平均值，否则我们会得到疯狂的高速数"
"字，这是不现实的。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:470
msgid ""
"Next we calculate the velocity from the position the controller currently "
"is, from the position the controller was at. We can use this difference in "
"position to help track the controller's velocity."
msgstr ""
"接下来，我们从控制器当前所处的位置，从控制器所处的位置计算速度。 我们可以使用"
"这种位置差异来帮助跟踪控制器的速度。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:473
msgid ""
"We then add the velocity from the controller this physics frame and the last "
"physics frame to ``controller_velocity``. We then update "
"``prior_controller_position`` to the current position, so we can use it in "
"the calculations in the velocity next physics frame."
msgstr ""
"然后我们将控制器的速度从物理框架和最后一个物理框架添加"
"到“controller_velocity”。 然后我们将``prior_controller_position``更新到当前位"
"置，这样我们就可以在速度下一个物理帧的计算中使用它。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:476
msgid ""
"The way we are calculating velocity is not perfect by any means, since it "
"relies on a consistent amount of frames per second. Ideally we would be able "
"to find the velocity directly from the VR controller but currently in OpenVR "
"there is not way to access the controller's velocity. We can get pretty "
"close to the real velocity by comparing positions between frames though, and "
"this will work just fine for this project."
msgstr ""
"我们计算速度的方式无论如何都不是完美的，因为它依赖于每秒一致的帧数。 理想情况"
"下，我们可以直接从VR控制器中找到速度，但目前在OpenVR中无法访问控制器的速度。 "
"通过比较帧之间的位置，我们可以非常接近真实速度，这对于这个项目来说效果很好。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:480
msgid ""
"Then we check to see if we have more than 30 stored velocities (more than a "
"third of a second). If there are more than 30, we remove the oldest velocity "
"from ``prior_controller_velocities``."
msgstr ""
"然后我们检查我们是否有超过30个存储的速度（超过三分之一秒）。 如果超过30，我们"
"从``prior_controller_velocities``中删除最旧的速度。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:484
msgid ""
"Next we check to see if there is a held object. If there is, we update the "
"position and rotation of the held object to the position and rotation of "
"``grab_pos_node``. Because of how scale works, we need to temporarily store "
"the scale and then reset the scale once we have updated the transform, "
"otherwise the scale will always be the same as the controller, which will "
"break the immersion if the player grabs a scaled object."
msgstr ""
"接下来我们检查是否有被保持的物体。 如果有，我们将被保持对象的位置和旋转更新"
"为“grab_pos_node”的位置和旋转。 由于比例是如何工作的，我们需要暂时存储比例，"
"然后在我们更新变换后重置比例，否则比例将始终与控制器相同，如果玩家抓取比例对"
"象，这将打破沉浸。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:489
msgid ""
"The last thing we are going to do in ``_physics_process`` is move the player "
"if they are moving the trackpad/joystick on the VR controller."
msgstr ""
"我们在``_physics_process``中要做的最后一件事是移动播放器，如果他们正在移动VR"
"控制器上的触控板/操纵杆。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:491
msgid ""
"First, we convert the axis values into :ref:`Vector2 <class_Vector2>` "
"variables so we can process them. We invert the X axis so moving the "
"trackpad/joystick left will move the player left."
msgstr ""
"首先，我们将轴值转换为：ref：`Vector2 <class_Vector2>`变量，以便我们可以处理"
"它们。 我们将X轴反转，因此向左移动触控板/操纵杆将使玩家向左移动。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:494
msgid ""
"Depending on your VR controller and OS, you may need to change the code so "
"it gets the proper axis values!"
msgstr "根据您的VR控制器和操作系统，您可能需要更改代码，以便获得正确的轴值！"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:496
msgid ""
"Next we account for dead zones on both the trackpad and the joystick. The "
"code for doing this is adapted from the link below, and I would highly "
"recommend looking at it."
msgstr ""
"接下来，我们会在触控板和操纵杆上考虑死区。 执行此操作的代码改编自以下链接，我"
"强烈建议您查看它。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:498
msgid ""
"You can find a great article explaining joystick dead zones `here <http://"
"www.third-helix.com/2013/04/12/doing-thumbstick-dead-zones-right.html>`_."
msgstr ""
"你可以找到一篇很棒的文章解释操纵杆死区`这里 <http://www.third-helix."
"com/2013/04/12/doing-thumbstick-dead-zones-right.html>`_。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:500
msgid ""
"One thing to note is how large we are making the dead zones. The reason we "
"are using such large dead zones is so the player cannot move themselves "
"accidentally by placing their finger on the center of the touchpad/joystick, "
"which can make players experience motion sickness if they are not expecting "
"it."
msgstr ""
"需要注意的一点是我们制造死区有多大。 我们使用如此大的死区的原因是玩家不能通过"
"将他们的手指放在触摸板/操纵杆的中心而不小心移动自己，这可能会让玩家在不期待它"
"时遇到晕动病。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:503
msgid ""
"Next, we get the forward and right directional vectors from the VR camera. "
"We need these so we can move the player forward/backwards and right/left "
"based on where they are currently looking."
msgstr ""
"接下来，我们从VR摄像机获得前向和右向方向矢量。 我们需要这些，所以我们可以根据"
"他们当前所在的位置向前/向后和向右/向左移动玩家。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:506
msgid ""
"Then we calculate how much the player will be moving by adding both the "
"trackpad and the joystick vectors together and normalizing them."
msgstr ""
"然后我们通过将触控板和操纵杆矢量一起添加并将它们标准化来计算玩家将移动多少。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:508
msgid ""
"Next, we calculate how far the player will go forwards/backwards and right/"
"left by multiplying the VR camera's directional vectors by the combined "
"trackpad/joystick vector."
msgstr ""
"接下来，我们通过将VR摄像机的方向向量乘以组合的触控板/操纵杆向量来计算玩家前"
"进/后退和右/左的距离。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:510
msgid ""
"We then remove movement on the Y axis so the player cannot fly/fall simply "
"by moving using the trackpad/joystick."
msgstr ""
"然后我们移除Y轴上的移动，这样玩家就不能通过使用触控板/操纵杆移动来飞行/跌落。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:512
msgid ""
"And finally, we move the player if there is any movement forwards/backwards "
"or right/left. If we are moving the player, we set ``directional_movement`` "
"accordingly."
msgstr ""
"最后，如果向前/向后或向右/向左移动，我们会移动玩家。 如果我们移动玩家，我们相"
"应地设置``directional_movement``。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:516
msgid "Now, let's look at ``button_pressed``."
msgstr "现在，让我们看看``button_pressed``。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:518
msgid ""
"If the button pressed is button 15, which for the Windows Mixed Reality "
"controllers is the trigger button, we will interact with the held object "
"assuming the controller is holding one, and if the player is not holding a "
"object, we will try to start teleporting."
msgstr ""
"如果按下的按钮是按钮15，对于Windows混合现实控制器是触发按钮，我们将与保持的对"
"象交互，假设控制器持有一个，如果玩家没有持有对象，我们将尝试开始传送。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:521
msgid ""
"If the controller is holding a object, and the held object has a method/"
"function called ``interact``, we call the ``interact`` function on the held "
"object."
msgstr ""
"如果控制器持有一个对象，并且持有的对象有一个名为``interact``的方法/函数，我们"
"在被保持的对象上调用``interact``函数。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:524
msgid ""
"If the controller is not holding a object, we then check to make sure the "
"teleportation mesh is not visible. This check ensure the player cannot "
"teleport cannot teleport with both hands/controllers at the same time. If "
"the teleportation mesh is not visible, we set ``teleport_button_down`` to "
"``true``, make ``teleport_mesh`` visible, and make the teleportation raycast "
"visible. This makes it where the teleportation mesh will follow the :ref:"
"`Raycast <class_Raycast>` coming from the pointer finger of the hand."
msgstr ""
"如果控制器没有拿着物体，我们检查以确保隐形传送网格不可见。 此检查确保玩家不能"
"同时传送不能用双手/控制器传送。 如果远程传送网格不可见，我们将"
"``teleport_button_down``设置为``true``，使``teleport_mesh``可见，并使远距传送"
"光线投射可见。 这使得远程传送网格将遵循：ref：`Raycast <class_Raycast>`来自手"
"的指针。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:529
msgid ""
"If the button pressed is button 2, which for the Windows Mixed Reality "
"controllers is the grab/grip button, we will grab/throw a object."
msgstr ""
"如果按下的按钮是按钮2，对于Windows混合现实控制器是抓取/抓握按钮，我们将抓取/"
"抛出一个对象。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:531
msgid ""
"First, we make sure the player is not trying to teleport, as we do not want "
"the player to be able to grab something while in the middle of trying to "
"teleport."
msgstr ""
"首先，我们确保玩家不会尝试传送，因为我们不希望玩家在尝试传送的过程中能够抓住"
"某些东西。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:533
msgid ""
"Then we check to see if the controller is already holding a object or not."
msgstr "然后我们检查控制器是否已经持有一个对象。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:535
msgid ""
"If the controller is not holding a object, we check to see which grab mode "
"the player is using."
msgstr "如果控制器没有拿着物体，我们会检查玩家正在使用哪种抓取模式。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:537
msgid ""
"If the player is using the ``AREA`` grab mode, we then get all of the bodies "
"overlapping the grab :ref:`Area <class_Area>`. We go through all of the "
"bodies in the grab :ref:`Area <class_Area>` and see if there is a :ref:"
"`RigidBody <class_RigidBody>`. We also check to make sure any :ref:"
"`RigidBody <class_RigidBody>` nodes in the :ref:`Area <class_Area>` do not "
"have a variable called ``NO_PICKUP``, since we do not want to be able to "
"pick up nodes with that variable."
msgstr ""
"如果玩家正在使用``AREA``抓取模式，那么我们将获得所有与grab重叠的实体：ref："
"`Area <class_Area>`。 我们遍历了grab中的所有实体：ref：`Area <class_Area>`并"
"查看是否有：ref：`RigidBody <class_RigidBody>`。 我们还检查以确定：ref："
"`RigidBody <class_RigidBody>`节点：ref：`Area <class_Area>`没有名为"
"``NO_PICKUP``的变量，因为我们不希望能够选择 具有该变量的节点。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:541
msgid ""
"Assuming there is a :ref:`RigidBody <class_RigidBody>` node inside the grab :"
"ref:`Area <class_Area>` that does not have a variable called ``NO_PICKUP``, "
"we assign it to ``rigid_body`` for additional processing."
msgstr ""
"假设在：grab：ref：`Area <class_Area>`里面有一个：ref：`RigidBody "
"<class_RigidBody>`节点，它没有一个名为``NO_PICKUP``的变量，我们将它分配给"
"``rigid_body``以获得额外的处理。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:544
msgid ""
"If the player is using the ``RAYCAST`` grab mode, we first force the :ref:"
"`Raycast <class_Raycast>` to update. We then check to see if the :ref:"
"`Raycast <class_Raycast>` is colliding with something."
msgstr ""
"如果玩家正在使用``RAYCAST``抓取模式，我们首先强制：ref：`Raycast "
"<class_Raycast>`进行更新。 然后我们检查：ref：`Raycast <class_Raycast>`是否与"
"某些东西发生碰撞。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:547
msgid ""
"If the :ref:`Raycast <class_Raycast>` is colliding with something, we then "
"check to see if what is colliding with is a :ref:`RigidBody "
"<class_RigidBody>`, and that it does not have a variable called "
"``NO_PICKUP``. If the :ref:`Raycast <class_Raycast>` is colliding with a :"
"ref:`RigidBody <class_RigidBody>`, and it does not have a variable called "
"``NO_PICKUP``, we assign it to ``rigid_body`` for additional processing."
msgstr ""
"如果：ref：`Raycast <class_Raycast>`与某些内容发生冲突，我们检查是否发生冲突"
"的是：ref：`RigidBody <class_RigidBody>`，并且它没有一个名为``NO_PICKUP的变量"
"``。 如果：ref：`Raycast <class_Raycast>`与：ref：`RigidBody "
"<class_RigidBody>`冲突，并且它没有一个名为``NO_PICKUP``的变量，我们将它分配给"
"``rigid_body``以获得额外的处理。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:551
msgid ""
"If ``rigid_body`` is not ``null``, meaning we found a :ref:`RigidBody "
"<class_RigidBody>` in the grab :ref:`Area <class_Area>`, we assign "
"``held_object`` to it. Then we store the now held :ref:`RigidBody "
"<class_RigidBody>`'s information in ``held_object_data``. We are storing "
"the :ref:`RigidBody <class_RigidBody>` mode, layer, and mask so later when "
"we drop it, we can reset all of those variables back to what they were "
"before we picked up the :ref:`RigidBody <class_RigidBody>`."
msgstr ""
"如果``rigid_body``不是``null``，意味着我们在grab：ref：`Area <class_Area>`中"
"找到了一个：ref：`RigidBody <class_RigidBody>`，我们给它分配了"
"``held_object``。 然后我们在``held_object_data``中存储现在持有的：ref："
"`RigidBody <class_RigidBody>的信息。 我们正在存储：ref：`RigidBody "
"<class_RigidBody>`模式，图层和掩码，所以稍后当我们删除它时，我们可以将所有这"
"些变量重置回原来的状态：ref：`RigidBody <class_RigidBody>`。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:555
msgid ""
"We then set the held object's :ref:`RigidBody <class_RigidBody>` mode to "
"``MODE_STATIC`` and set the collision layer and mask to 0 so it cannot "
"collide with any other physic bodies."
msgstr ""
"然后我们将保持对象的：ref：`RigidBody <class_RigidBody>`模式设置为"
"``MODE_STATIC``并将碰撞层和掩码设置为0，这样它就不会与任何其他物理机构发生碰"
"撞。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:558
msgid ""
"We make the hand mesh invisible so it does not get in the way of the object "
"we are holding (and also because I did not feel like animating the hand). We "
"also make the grab :ref:`Raycast <class_Raycast>` invisible so the mesh used "
"for showing the :ref:`Raycast <class_Raycast>` is no longer visible."
msgstr ""
"我们使手网不可见，因此它不会妨碍我们持有的对象（也因为我不喜欢动画手）。 我们"
"也使得：ref：`Raycast <class_Raycast>`看不见，因此用于显示：ref：`Raycast "
"<class_Raycast>`的网格不再可见。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:561
msgid ""
"If the :ref:`RigidBody <class_RigidBody>` we picked up has the ``picked_up`` "
"method/function, we call it. If the :ref:`RigidBody <class_RigidBody>` we "
"picked up has a variable called ``controller``, we set it to this controller."
msgstr ""
"如果我们选择的：ref：`RigidBody <class_RigidBody>`有``picked_up``方法/函数，"
"我们称之为。 如果：ref：`RigidBody <class_RigidBody>`我们选择了一个名为"
"``controller``的变量，我们将它设置为该控制器。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:564
msgid ""
"If the controller is not holding a object, and the button pressed is 2, we "
"want to drop/throw the held object."
msgstr ""
"如果控制器没有持有一个对象，并且按下的按钮是2，我们想要删除/抛出被保持的对"
"象。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:566
msgid ""
"First, we set the held :ref:`RigidBody <class_RigidBody>`'s mode, layer, and "
"mask back to what they were when we picked the object up. We then apply a "
"impulse to the held object, using the controller's velocity as the force."
msgstr ""
"首先，我们将hold：ref：`RigidBody <class_RigidBody>的模式，图层和蒙版设置回我"
"们拾取对象时的状态。 然后，我们使用控制器的速度作为力，对保持的对象施加脉冲。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:569
msgid ""
"If the previously held :ref:`RigidBody <class_RigidBody>` has a function "
"called ``dropped``, we call it. If the :ref:`RigidBody <class_RigidBody>` "
"has a variable called ``controller`` we set it to ``null``."
msgstr ""
"如果以前持有的：ref：`RigidBody <class_RigidBody>`有一个名为``dropped``的函"
"数，我们称之为。 如果：ref：`RigidBody <class_RigidBody>`有一个名为"
"``controller``的变量，我们将它设置为``null``。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:572
msgid ""
"Then we set ``held_object`` to ``null``, since we are no longer holding any "
"objects, and we make the hand mesh visible again."
msgstr ""
"然后我们将``held_object``设置为``null``，因为我们不再持有任何对象，我们再次使"
"手网可见。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:574
msgid ""
"If we are using the ``RAYCAST`` grab mode, we make the :ref:`Raycast "
"<class_Raycast>` visible so we can see the mesh used for showing the grab :"
"ref:`Raycast <class_Raycast>`."
msgstr ""
"如果我们使用``RAYCAST``抓取模式，我们将：ref：`Raycast <class_Raycast>`显示为"
"可见，这样我们就可以看到用于显示抓取的网格：ref：`Raycast <class_Raycast>`。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:576
msgid ""
"Finally, regardless of whether we are grabbing a object or releasing it, we "
"play the sound loaded into ``AudioStreamPlayer3D``, which is a pick-up/drop "
"noise."
msgstr ""
"最后，无论我们是抓取对象还是释放它，我们都会播放加载到“AudioStreamPlayer3D”中"
"的声音，这是一种拾取/丢弃噪声。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:578
msgid ""
"The last thing we are doing in ``button_pressed`` is checking to see if the "
"button pressed is 1, which for the Windows Mixed Reality controllers is the "
"menu button."
msgstr ""
"我们在``button_pressed``中做的最后一件事是检查按下的按钮是否为1，对于Windows "
"Mixed Reality控制器是菜单按钮。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:580
msgid ""
"If the menu button is pressed, we change grab modes, and set the visibility "
"of the grab :ref:`Raycast <class_Raycast>` so it is only visible when using "
"``RAYCAST`` as the grab mode."
msgstr ""
"如果按下菜单按钮，我们更改抓取模式，并设置抓取的可见性：ref：`Raycast "
"<class_Raycast>`所以只有在使用``RAYCAST``作为抓取模式时才能看到它。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:584
msgid "Let's look at ``button_released`` next."
msgstr "我们接下来看看``button_released``。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:586
msgid ""
"If the button released is button 15, the trigger, then we potentially want "
"to teleport."
msgstr "如果释放的按钮是按钮15，触发器，那么我们可能想要传送。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:588
msgid ""
"First, we check to see if ``teleport_button_down`` is ``true``. If it is, "
"that means the player is intending to teleport, while if it is ``false``, "
"the player has simply released the trigger while holding a object."
msgstr ""
"首先，我们检查``teleport_button_down``是否为``true``。 如果是，那意味着玩家打"
"算传送，而如果它是“假”，玩家只需在拿着一个物体时释放扳机。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:591
msgid ""
"We then check to see if this controller has a teleport position, and we "
"check to make sure the teleport mesh is visible."
msgstr "然后我们检查该控制器是否具有传送位置，我们检查以确保传送网格可见。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:593
msgid ""
"If both of those conditions are ``true``, we then calculate the offset the :"
"ref:`ARVRCamera <class_ARVRCamera>` has from the :ref:`ARVROrigin "
"<class_ARVROrigin>`. We do this because of how :ref:`ARVRCamera "
"<class_ARVRCamera>` and :ref:`ARVROrigin <class_ARVROrigin>` work with room-"
"scale tracking."
msgstr ""
"如果这两个条件都是``true``，那么我们计算偏移：ref：`ARVRCamera "
"<class_ARVRCamera>`来自：ref：`ARVROrigin <class_ARVROrigin>`。 我们这样做是"
"因为：ref：`ARVRCamera <class_ARVRCamera>`和：ref：`ARVROrigin "
"<class_ARVROrigin>`使用房间尺度跟踪。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:596
msgid ""
"Because we want to teleport the player in their current position to the "
"teleport position, and remember because of room-scale tracking their current "
"position can be offset from the origin, we have to figure out that offset so "
"when we teleport we can remove it so that player's current position is "
"teleported to the teleport position."
msgstr ""
"因为我们想将当前位置的玩家传送到传送位置，并且因为房间尺度跟踪而记住它们的当"
"前位置可能偏离原点，我们必须弄清楚偏移，所以当我们传送时我们可以删除它 该球员"
"的当前位置被传送到传送位置。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:599
msgid ""
"We set the Y value of the camera_offset to zero because we do not want to "
"account for offsets in the player's height."
msgstr "我们将camera_offset的Y值设置为零，因为我们不想考虑玩家身高的偏移量。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:601
msgid ""
"Then we teleport the :ref:`ARVROrigin <class_ARVROrigin>` to the teleport "
"position, applying the camera offset."
msgstr ""
"然后我们将：ref：`ARVROrigin <class_ARVROrigin>`传送到传送位置，应用相机偏"
"移。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:603
msgid ""
"Regardless of whether we teleported or not, we reset all of the teleport-"
"related variables so the controller has to get new ones before teleporting "
"again."
msgstr ""
"无论我们是否传送，我们都会重置所有与传送相关的变量，以便控制器必须在再次传送"
"之前获得新的变量。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:607
msgid ""
"Finally, let's look at ``sleep_area_entered`` and ``sleep_area_exited``."
msgstr "最后，让我们看一下``sleep_area_entered``和``sleep_area_exited``。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:609
msgid ""
"When a body enters or exists the sleep area, we check if it has a variable "
"called ``can_sleep``. If it does, we then set it to ``false`` and wake the "
"body if it has entered the sleep area, while if it has exited we set it to "
"``true`` so the :ref:`RigidBody <class_RigidBody>` nodes can sleep (which "
"can decrease CPU usage)."
msgstr ""
"当身体进入或存在睡眠区域时，我们检查它是否有一个名为“can_sleep”的变量。 如果"
"确实如此，我们将其设置为“false”并在身体进入睡眠区域时唤醒身体，如果已经退出，"
"我们将其设置为“真实”，以便：ref：`RigidBody <class_RigidBody> `节点可以睡眠"
"（可以降低CPU使用率）。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:614
msgid ""
"Okay, phew! That was a lot of code! Add the same script, ``VR_Controller."
"gd`` to the other controller so both controllers have the same script."
msgstr ""
"好的，p！ 那是很多代码！ 将相同的脚本``VR_Controller.gd``添加到另一个控制器，"
"以便两个控制器具有相同的脚本。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:616
msgid ""
"Now go ahead and try the game again, and you should find you can teleport "
"around by pressing the touch pad, and can grab and throw objects using the "
"grab/grip buttons."
msgstr ""
"现在再继续尝试游戏，你会发现你可以通过按下触摸板来传送，并且可以使用抓握/抓握"
"按钮抓住并扔掉物体。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:619
msgid ""
"Now, you may want to try moving using the trackpads and/or joysticks, but "
"**it may make you motion sick!**"
msgstr ""
"现在，您可能想尝试使用触控板和/或操纵杆移动，但**它可能会让您运动生病！**"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:621
msgid ""
"One of the main reasons this can make you feel motion sick is because your "
"vision tells you that you are moving, while your body is not moving. This "
"conflict of signals makes the body feel sick, so let's fix it!"
msgstr ""
"这可能让你感到晕车的主要原因之一是因为你的视力告诉你，你的身体不动，你正在移"
"动。 这种信号冲突使身体感到恶心，所以让我们解决它！"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:625
msgid "Reducing motion sickness"
msgstr "减少晕动病"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:627
msgid ""
"There are plenty of ways to reduce motion sickness in VR, and there is no "
"one perfect way to reduce motion sickness. See `this page on the Oculus "
"Developer Center <https://developer.oculus.com/design/latest/concepts/bp-"
"locomotion/>`_ for more information on how to implement locomotion and "
"reducing motion sickness."
msgstr ""
"有很多方法可以减少VR中的晕动病，并且没有一种方法可以减少晕动病。 有关如何实施"
"运动和减少晕动病的更多信息，请参阅Oculus开发人员中心的 `这个页面 <https://"
"developer.oculus.com/design/latest/concepts/bp-locomotion/>`_。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:631
msgid ""
"To help reduce motion sickness while moving, we are going to add a vignette "
"effect that will only be visible while the player moves."
msgstr ""
"为了帮助减少移动时的晕车，我们将添加一个只有在玩家移动时才能看到的晕影效果。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:633
msgid ""
"Open up ``Movement_Vignette.tscn``, which you can find in the ``Scenes`` "
"folder. Notice how it is just a :ref:`ColorRect <class_ColorRect>` node with "
"a custom shader. Feel free to look at the custom shader if you want, it is "
"just a slightly modified version of the vignette shader you can find in the "
"Godot demo repository."
msgstr ""
"打开``Movement_Vignette.tscn``，您可以在``Scenes``文件夹中找到它。 注意它只是"
"一个：ref：`ColorRect <class_ColorRect>`带有自定义着色器的节点。 如果需要，可"
"以随意查看自定义着色器，它只是您可以在Godot演示库中找到的晕影着色器的略微修改"
"版本。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:636
msgid ""
"With ``Movement_Vignette`` selected, make a new script called "
"``Movement_Vignette.gd``. Add the following code to ``Movement_Vignette.gd``:"
msgstr ""
"选择``Movement_Vignette``后，创建一个名为``Movement_Vignette.gd``的新脚本。 "
"将以下代码添加到``Movement_Vignette.gd``："

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:672
msgid ""
"Because this script is fairly simple, let's quickly go over what it does."
msgstr "因为这个脚本非常简单，所以让我们快速回顾它的作用。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:674
msgid ""
"In ``_ready``, we wait for four frames. We do this to ensure the VR "
"interface is ready and going."
msgstr "在``_ready``中，我们等待四帧。 我们这样做是为了确保VR界面准备就绪。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:676
msgid ""
"Next, we get the current VR interface, and resize the :ref:`ColorRect "
"<class_ColorRect>` node's size and position so that it covers the entire "
"view in VR."
msgstr ""
"接下来，我们获取当前的VR接口，并调整：ref：`ColorRect <class_ColorRect>`节点"
"的大小和位置，以便它覆盖VR中的整个视图。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:678
msgid ""
"Then we get the left and right controllers, assigning them to "
"``controller_one`` and ``controller_two``."
msgstr ""
"然后我们得到左右控制器，将它们分配给``controller_one``和``controller_two``。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:680
msgid "We then make the vignette invisible by default."
msgstr "然后，我们默认情况下使小插图不可见。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:682
msgid ""
"In ``_process``, we check to see if either of the controllers are moving the "
"player by checking ``directional_movement``. If either controller is moving "
"the player, we make the vignette visible, while if neither controller is "
"moving the player, we make the vignette invisible."
msgstr ""
"在``_process``中，我们通过检查``directional_movement``来检查其中一个控制器是"
"否正在移动播放器。 如果任一控制器正在移动播放器，我们使小插图可见，而如果两个"
"控制器都没有移动播放器，我们使小插图不可见。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:687
msgid ""
"With that done, go ahead and try moving around with the joystick and/or the "
"trackpad. You should find it is much less motion sickness-inducing than "
"before!"
msgstr ""
"完成后，继续尝试使用操纵杆和/或触控板。 你应该会发现它比以前少了晕动病！"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:689
msgid ""
"Let's add some special :ref:`RigidBody <class_RigidBody>` nodes we can "
"interact with next."
msgstr ""
"让我们添加一些特殊的：ref：`RigidBody <class_RigidBody>`我们可以与下一个交互"
"的节点。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:692
msgid "Adding destroyable targets"
msgstr "添加可销毁的目标"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:694
msgid ""
"First, let's start by making some targets we will destroy in various "
"different ways with various different special :ref:`RigidBody "
"<class_RigidBody>` nodes."
msgstr ""
"首先，让我们从制作一些目标开始，我们将以各种不同的方式销毁各种不同的特殊目"
"标：ref：`RigidBody <class_RigidBody>`节点。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:696
msgid ""
"Open up ``Sphere_Target.tscn``, which you can find in the ``Scenes`` folder. "
"``Sphere.tscn`` is just a :ref:`StaticBody <class_StaticBody>` with a :ref:"
"`CollisionShape <class_CollisionShape>`, a mesh, and a audio player."
msgstr ""
"打开``Sphere_Target.tscn``，您可以在``Scenes``文件夹中找到它。 ``Sphere."
"tscn``只是一个：ref：`StaticBody <class_StaticBody>`带有：ref："
"`CollisionShape <class_CollisionShape>`，一个网格和一个音频播放器。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:699
msgid ""
"Select the ``Sphere_Target`` root node, the :ref:`StaticBody "
"<class_StaticBody>` node, and make a new script called ``Sphere_Target.gd``. "
"Add the following to ``Sphere_Target.gd``:"
msgstr ""
"选择``Sphere_Target``根节点，：ref：`StaticBody <class_StaticBody>`节点，并创"
"建一个名为``Sphere_Target.gd``的新脚本。 将以下内容添加到``Sphere_Target."
"gd``："

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:746
msgid "Let's go over how this script works, starting with the class variables."
msgstr "让我们来看看这个脚本的工作原理，从类变量开始。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:748
msgid "``destroyed``: A variable to track if this target is destroyed or not."
msgstr "``destroyed``：一个变量，用于跟踪此目标是否被销毁。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:749
msgid ""
"``destroyed_timer``: A variable to track how long the target has been "
"destroyed."
msgstr "``destroyed_timer``：一个跟踪目标被摧毁多久的变量。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:750
msgid ""
"``DESTROY_WAIT_TIME``: A constant to tell the sphere target how long to wait "
"before destroying/deleting itself."
msgstr ""
"``DESTROY_WAIT_TIME``：一个常数，用于告诉球体目标在销毁/删除自身之前需要等待"
"多长时间。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:751
msgid "``health``: The amount of health the target has."
msgstr "``health``：目标所具有的健康量。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:752
msgid ""
"``RIGID_BODY_TARGET``: The target broken into several smaller :ref:"
"`RigidBody <class_RigidBody>` nodes."
msgstr ""
"``RIGID_BODY_TARGET``：目标分成几个较小的：ref：`RigidBody <class_RigidBody>`"
"节点。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:756
#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:903
msgid "Let's go over ``_ready``."
msgstr "让我们回顾一下``_ready``。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:758
msgid ""
"All we are doing in ``_ready`` is setting ``_physics_process`` to ``false``. "
"This is because we will only use ``_physics_process`` for destroying the "
"target, so we do not want to call it until the target is broken."
msgstr ""
"我们在``_ready``中所做的就是将``_physics_process``设置为``false``。 这是因为"
"我们只使用``_physics_process``来销毁目标，所以我们不想在目标被破坏之前调用"
"它。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:763
msgid "Next, let's go over ``_physics_process``."
msgstr "接下来，让我们回顾一下``_physics_process``。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:765
msgid ""
"First, we add time to ``destroyed_timer``. Then we check to see if enough "
"time has passed and we can destroy the target. If enough time has passed, we "
"free/destroy the target using ``queue_free``."
msgstr ""
"首先，我们为``destroyed_timer``增加时间。 然后我们检查是否已经过了足够的时"
"间，我们可以摧毁目标。 如果已经过了足够的时间，我们使用``queue_free``释放/销"
"毁目标。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:770
msgid "Finally, let's go over ``damage``."
msgstr "最后，让我们回顾一下``damage``。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:772
msgid "First, we check to make sure the target has not already been destroyed."
msgstr "首先，我们检查以确保目标尚未被销毁。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:774
msgid ""
"Then, we remove however much damage the target has taken from the target's "
"health."
msgstr "然后，我们移除了目标从目标生命值中获得的大量伤害。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:776
msgid ""
"If the target has zero or less health, then it has taken enough damage to "
"break."
msgstr "如果目标的生命值为零或更低，则它已经受到足够的破坏。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:778
msgid ""
"First, we disable the collision shape and make the whole target mesh "
"invisible. Next, we spawn/instance the :ref:`RigidBody <class_RigidBody>` "
"version of the target, and instance it at this target's position."
msgstr ""
"首先，我们禁用碰撞形状并使整个目标网格不可见。 接下来，我们生成/实例：ref："
"`RigidBody <class_RigidBody>`目标版本，并在此目标位置实例化它。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:781
msgid ""
"Then we set ``destroyed`` to ``true`` and start processing "
"``_physics_process``. Finally, we play a sound, and remove a sphere from "
"``Game.gd`` by calling ``remove_sphere``."
msgstr ""
"然后我们将``destroyed``设置为``true``并开始处理``_physics_process``。 最后，"
"我们播放声音，并通过调用“remove_sphere”来从“Game.gd”中删除一个球体。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:786
msgid ""
"Now, you may have noticed we are calling a function in ``Game.gd`` we have "
"not made yet, so let's fix that!"
msgstr ""
"现在，您可能已经注意到我们正在调用我们尚未制作的“Game.gd”中的函数，所以让我们"
"解决这个问题！"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:788
msgid ""
"First, open up ``Game.gd`` and add the following additional class variables:"
msgstr "首先，打开``Game.gd``并添加以下附加类变量："

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:795
msgid "``spheres_left``: The amount of sphere targets left in the game world."
msgstr "``spheres_left``：游戏世界中留下的球体目标数量。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:796
msgid "``sphere_ui``: A reference to the sphere UI. We will use this later!"
msgstr "``sphere_ui``：对球体UI的引用。 我们稍后会用到这个！"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:798
msgid ""
"Next, we need to add the ``remove_sphere`` function. Add the following to "
"``Game.gd``:"
msgstr ""
"接下来，我们需要添加``remove_sphere``函数。 将以下内容添加到``Game.gd``："

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:808
msgid "What this function does is it removes one from ``spheres_left``."
msgstr "这个函数的作用是从``spheres_left``中删除一个。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:810
msgid ""
"Then it checks to see if ``sphere_ui`` is not null, and if it is not, then "
"it calls its ``update_ui`` function, passing in the amount of sphere's left. "
"We'll add the UI code later in this part."
msgstr ""
"然后它检查``sphere_ui``是否为空，如果不是，则调用它的``update_ui``函数，传入"
"球的左边数量。 我们将在本部分后面添加UI代码。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:813
msgid "Now that we have destroyable targets, we need a way to destroy them!"
msgstr "既然我们有可销毁的目标，我们需要一种方法来摧毁它们！"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:816
msgid "Adding a pistol"
msgstr "加一把手枪"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:818
msgid ""
"Okay, let's add a simple pistol. Open up ``Pistol.tscn``, which you will "
"find in the ``Scenes`` folder."
msgstr ""
"好的，让我们添加一把简单的手枪。 打开``Pistol.tscn``，您可以在``Scenes``文件"
"夹中找到它。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:820
msgid ""
"There is a few things to note here. The first thing to note is how "
"everything is rotated. This is to make the pistol rotate correctly when the "
"player grabs it. The other thing to notice is how there is a laser sight "
"mesh, and a flash mesh, both of these do what you'd expect: act as a laser "
"pointer and act as a muzzle flash respectively."
msgstr ""
"这里有几点需要注意。 首先要注意的是如何旋转一切。 这是为了让玩家在抓住手枪时"
"正确旋转。 另外需要注意的是激光瞄准网和闪光网是如何做到的，它们都可以达到您的"
"期望：充当激光指针并分别充当枪口闪光灯。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:823
msgid ""
"The other thing to notice is how there is a :ref:`Raycast <class_Raycast>` "
"node at the end of the pistol. This is what we will be using to calculate "
"where the bullets impact."
msgstr ""
"另一件需要注意的事情是手枪末端有一个：ref：`Raycast <class_Raycast>`节点。 这"
"是我们将用于计算子弹影响的位置。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:825
msgid ""
"Now that we have looked at the scene, let's write the code. Select the "
"``Pistol`` root node, the :ref:`RigidBody <class_RigidBody>` node, and make "
"a new script called ``Pistol.gd``. Add the following code to ``Pistol.gd``:"
msgstr ""
"现在我们已经查看了场景，让我们编写代码。 选择``Pistol``根节点，：ref："
"`RigidBody <class_RigidBody>`节点，并创建一个名为``Pistol.gd``的新脚本。 将以"
"下代码添加到``Pistol.gd``："

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:892
msgid "Let's go over what this script does, starting with the class variables:"
msgstr "让我们回顾一下这个脚本的作用，从类变量开始："

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:894
msgid "``flash_mesh``: The mesh used to make the muzzle flash."
msgstr "``flash_mesh``：用于使枪口闪光的网格。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:895
msgid "``FLASH_TIME``: The length of time the muzzle flash is visible."
msgstr "``FLASH_TIME``：枪口闪光可见的时间长度。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:896
msgid ""
"``flash_timer``: A variable to track how long the muzzle flash has been "
"visible."
msgstr "``flash_timer``：一个跟踪枪口闪光可见时间的变量。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:897
msgid "``laser_sight_mesh``: A long rectangular mesh used for the laser sight."
msgstr "``laser_sight_mesh``：用于激光瞄准器的长矩形网格。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:898
msgid "``raycast``: The raycast node used for the pistol firing."
msgstr "``raycast``：用于手枪射击的射线播放节点。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:899
msgid "``BULLET_DAMAGE``: The amount of damage a single bullet does."
msgstr "``BULLET_DAMAGE``：单个子弹造成的伤害量。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:905
msgid ""
"All we are doing here is getting the nodes and assigning them to the proper "
"variables. We also make sure the flash and laser sight meshes are invisible."
msgstr ""
"我们在这里所做的就是获取节点并将它们分配给适当的变量。 我们还确保闪光灯和激光"
"瞄准网不可见。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:910
msgid "Next, let's look at ``_physics_process``."
msgstr "接下来，让我们看看`_physics_process``。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:912
msgid ""
"First, we check to see if the flash is visible. We do this by checking to "
"see if ``flash_timer`` is more than zero. This is because ``flash_timer`` "
"will be a inverted timer, a timer that counts down instead of counting up."
msgstr ""
"首先，我们检查闪光灯是否可见。 我们通过检查``flash_timer``是否大于零来做到这"
"一点。 这是因为``flash_timer``将是一个倒置计时器，一个计时器倒计时而不是计"
"数。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:915
msgid ""
"If ``flash_timer`` is more than zero, we remove ``delta`` from it and check "
"to see if it is equal to zero or less. If it is, we make the flash mesh "
"invisible."
msgstr ""
"如果``flash_timer``大于零，我们从中删除``delta``并检查它是否等于零或更小。 如"
"果是，我们使闪光网不可见。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:918
msgid ""
"This makes it where the flash mesh becomes invisible after ``FLASH_TIME`` "
"many seconds has gone by."
msgstr "这使得闪存网格在“FLASH_TIME”经过许多秒后变得不可见。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:922
msgid ""
"Now let's look at ``interact``, which is called when the trigger button on "
"the VR controller is pressed and the pistol is being held."
msgstr ""
"现在让我们看一下``interact``，当按下VR控制器上的触发按钮并握住手枪时调用它。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:924
msgid ""
"First, we check to see if the flash timer is less than or equal to zero. "
"This check makes it where we cannot fire when the flash is visible, limiting "
"how often the pistol can fire."
msgstr ""
"首先，我们检查闪光定时器是否小于或等于零。 当闪光灯可见时，这个检查使我们无法"
"开火，限制了手枪射击的频率。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:927
msgid ""
"If we can fire, we reset ``flash_timer`` by setting it to ``FLASH_TIME``, "
"and we make the flash mesh visible."
msgstr ""
"如果我们可以触发，我们通过将它设置为“FLASH_TIME”来重置``flash_timer``，并且我"
"们使flash网格可见。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:929
msgid ""
"We then update the :ref:`Raycast <class_Raycast>` and check to see if it is "
"colliding with anything."
msgstr ""
"然后我们更新：ref：`Raycast <class_Raycast>`并检查它是否与任何东西发生碰撞。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:931
msgid ""
"If the :ref:`Raycast <class_Raycast>` is colliding with something, we get "
"the collider. We check to see if the collider has the ``damage`` function, "
"and if it does we call it. If it does not, we then check to see if the "
"collider has the ``apply_impulse`` function, and if it does, we call it "
"after calculating the direction from the :ref:`Raycast <class_Raycast>` to "
"the collider."
msgstr ""
"如果：ref：`Raycast <class_Raycast>`与某些东西发生碰撞，我们就会得到对撞机。 "
"我们检查对撞机是否有“损坏”功能，如果有，我们称之为。 如果没有，我们检查对撞机"
"是否具有``apply_impulse``函数，如果有，我们在计算从：ref：`Raycast "
"<class_Raycast>`到对撞机的方向后调用它。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:935
msgid ""
"Finally, regardless of whether the pistol hit something or not, we play the "
"pistol firing sound."
msgstr "最后，无论手枪是否击中，我们都会发出手枪发出的声音。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:939
msgid ""
"Finally, let's look at ``picked_up`` and ``dropped``, which are called when "
"the pistol is picked up and dropped respectively."
msgstr ""
"最后，让我们看一下``picked_up``和``dropped``，它们分别在拾取和放下手枪时被调"
"用。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:941
msgid ""
"All we are doing in these functions is making the laser pointer visible when "
"the pistol is picked up, and making it invisible when the pistol is dropped."
msgstr ""
"我们在这些功能中所做的就是在拿起手枪时使激光指示器可见，并在手枪掉落时使其不"
"可见。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:947
msgid ""
"With that done, go ahead and give the game a try! If you climb up the stairs "
"and grab the pistols, you should be able to fire at the spheres and they "
"will break!"
msgstr ""
"完成后，继续尝试游戏吧！ 如果你爬上楼梯并抓住手枪，你应该能够在球体上射击并且"
"它们会破裂！"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:950
msgid "Adding a shotgun"
msgstr "添加霰弹枪"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:952
msgid ""
"Let's add a different type of shooting :ref:`RigidBody <class_RigidBody>`: A "
"shotgun. This is fairly simple to do, and almost everything is the same as "
"the pistol."
msgstr ""
"让我们添加一种不同类型的射击：ref：`RigidBody <class_RigidBody>`：霰弹枪。 这"
"很简单，几乎所有东西都和手枪一样。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:954
msgid ""
"Open up ``Shotgun.tscn``, which you can find in ``Scenes``. Notice how "
"everything is more or less the same, but instead of a single :ref:`Raycast "
"<class_Raycast>`, there are five, and there is no laser pointer. This is "
"because a shotgun generally fires in a cone shape, and so we are going to "
"emulate that by having several :ref:`Raycast <class_Raycast>` nodes, all "
"rotated randomly in a cone shape, and I removed the laser pointer so the "
"player has to aim without knowing for sure where the shotgun is pointing."
msgstr ""
"打开``Shotgun.tscn``，你可以在``Scenes``找到它。 注意一切都或多或少相同，但不"
"是一个：ref：`Raycast <class_Raycast>`，有五个，没有激光指针。 这是因为霰弹枪"
"通常以锥形形状发射，因此我们将通过几个：ref：`Raycast <class_Raycast>`节点模"
"拟它们，所有节点都以锥形随机旋转，然后我移除了激光指示器 玩家必须瞄准而不确定"
"霰弹枪指向的位置。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:959
msgid ""
"Alright, select the ``Shotgun`` root node, the :ref:`RigidBody "
"<class_RigidBody>` and make a new script called ``Shotgun.gd``. Add the "
"following to ``Shotgun.gd``:"
msgstr ""
"好吧，选择``Shotgun``根节点，：ref：`RigidBody <class_RigidBody>`并创建一个名"
"为``Shotgun.gd``的新脚本。 将以下内容添加到``Shotgun.gd``："

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1019
msgid ""
"You may have noticed this is almost exactly the same as the pistol, and "
"indeed it is, so let's only go over what has changed."
msgstr ""
"您可能已经注意到这几乎与手枪完全一样，事实上它也是如此，所以让我们只看看已经"
"改变的东西。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1021
msgid ""
"``raycasts``: The node that holds all of the five :ref:`Raycast "
"<class_Raycast>` nodes used for the shotgun's firing."
msgstr ""
"``raycasts``：包含所有五个节点的节点：ref：`Raycast <class_Raycast>`用于霰弹"
"枪射击的节点。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1023
msgid ""
"In ``_ready``, we get the ``Raycasts`` node, instead of just a single :ref:"
"`Raycast <class_Raycast>`."
msgstr ""
"在``_ready``中，我们得到``Raycasts``节点，而不只是一个：ref：`Raycast "
"<class_Raycast>`。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1025
msgid ""
"The only other change, besides there being nothing in ``picked_up`` and "
"``dropped`` is in ``interact``."
msgstr ""
"除了在``picked_up``和``dropped``中没有任何内容之外，唯一的另一个变化是"
"``interact``。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1027
msgid ""
"Now we go through each :ref:`Raycast <class_Raycast>` in ``raycasts``. We "
"then rotate it on the X and Z axis, making within a 10 to ``-10`` cone. From "
"there, we process each :ref:`Raycast <class_Raycast>` like we did the "
"single :ref:`Raycast <class_Raycast>` in the pistol, nothing changed at all, "
"we are just doing it five times, once for each :ref:`Raycast "
"<class_Raycast>` in ``raycasts``."
msgstr ""
"现在我们通过每个：ref：``Raycast <class_Raycast>`在``raycasts``中。 然后我们"
"在X轴和Z轴上旋转它，在10到“-10”锥形范围内。 从那里开始，我们处理每个：ref："
"`Raycast <class_Raycast>`就像我们做的那样：ref：`Raycast <class_Raycast>`在手"
"枪中，没有任何改变，我们只是做了五次，每次一次： ref：``raycasts``中的"
"`Raycast <class_Raycast>`。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1033
msgid ""
"Now you can find and fire the shotgun too! The shotgun is located around the "
"back behind one of the walls (not in the building though!)."
msgstr ""
"现在你也可以找到并发射霰弹枪！ 霰弹枪位于其中一个墙后面的后面（虽然不在建筑物"
"中！）。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1036
msgid "Adding a bomb"
msgstr "添加炸弹"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1038
msgid ""
"While both of those are well and good, let's add something we can throw next "
"— a bomb!"
msgstr "虽然这两个都很好，但我们可以添加一些我们可以抛出的东西 - 炸弹！"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1040
msgid "Open up ``Bomb.tscn``, which you will find in the ``Scenes`` folder."
msgstr "打开``Bomb.tscn``，您可以在``Scenes``文件夹中找到它。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1042
msgid ""
"First, notice how there is a rather large :ref:`Area <class_Area>` node. "
"This is the explosion radius for the bomb. Anything within this :ref:`Area "
"<class_Area>` will be effected by the explosion when the bomb explodes."
msgstr ""
"首先，注意有一个相当大的：ref：`Area <class_Area>`节点。 这是炸弹的爆炸半"
"径。 其中的任何内容：ref：`Area <class_Area>`将在炸弹爆炸时受到爆炸的影响。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1045
msgid ""
"The other thing to note is how there are two sets of :ref:`Particles "
"<class_Particles>`: one for smoke coming out of the fuse, and another for "
"the explosion itself. Feel free to take a look at the :ref:`Particles "
"<class_Particles>` nodes if you want!"
msgstr ""
"另外需要注意的是如何有两组：ref：`Particles <class_Particles>`：一个用于从保"
"险丝中出来的烟雾，另一个用于爆炸本身。 如果需要，请随意查看：ref：`Particles "
"<class_Particles>`节点！"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1048
msgid ""
"The only thing to notice his how long the explosion :ref:`Particles "
"<class_Particles>` node will last, their lifetime, which is 0.75 seconds. We "
"need to know this so we can time the removal of the bomb with the end of the "
"explosion :ref:`Particles <class_Particles>`."
msgstr ""
"唯一需要注意的是他的爆炸时间：ref：`Particles <class_Particles>`节点将持续，"
"它们的生命周期为0.75秒。 我们需要知道这一点，所以我们可以在爆炸结束时抽出炸弹"
"的时间：ref：`Particles <class_Particles>`。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1051
msgid ""
"Alright, now let's write the code for the bomb. Select the ``Bomb`` :ref:"
"`RigidBody <class_RigidBody>` node and make a new script called ``Bomb.gd``. "
"Add the following code to ``Bomb.gd``:"
msgstr ""
"好的，现在让我们写下炸弹的代码。 选择``Bomb``：ref：`RigidBody "
"<class_RigidBody>`节点并创建一个名为``Bomb.gd``的新脚本。 将以下代码添加到"
"``Bomb.gd``："

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1142
msgid ""
"Let's go through what this script does, starting with the class variables:"
msgstr "让我们来看看这个脚本的作用，从类变量开始："

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1144
msgid ""
"``bomb_mesh``: The :ref:`MeshInstance <class_MeshInstance>` used for the "
"bomb mesh."
msgstr ""
"``bomb_mesh``：用于炸弹网格的：ref：`MeshInstance <class_MeshInstance>`。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1145
msgid "``FUSE_TIME``: The length of time the fuse burns for."
msgstr "``FUSE_TIME``：保险丝燃烧的时间长度。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1146
msgid ""
"``fuse_timer``: A variable for tracking how long the fuse has been burning."
msgstr "``fuse_timer``：用于跟踪保险丝燃烧时间的变量。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1147
msgid ""
"``explosion_area``: The :ref:`Area <class_Area>` node used for detecting "
"what nodes are inside the explosion."
msgstr ""
"``explosion_area``：：ref：`Area <class_Area>`节点，用于检测爆炸内的节点。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1148
msgid "``EXPLOSION_DAMAGE``: The amount of damage the explosion does."
msgstr "``EXPLOSION_DAMAGE``：爆炸造成的伤害量。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1149
msgid ""
"``EXPLOSION_TIME``: The length of time the explosion :ref:`Particles "
"<class_Particles>` take (you can calculate this number by multiplying the "
"particles ``lifetime`` by its ``speed scale``)"
msgstr ""
"``EXPLOSION_TIME``：爆炸的时间长度：ref：`Particles "
"<class_Particles>`take（你可以通过将粒子``lifetime``乘以它的``speed scale``来"
"计算这个数字）"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1150
msgid ""
"``explosion_timer``: A variable for tracking how long the explosion has "
"lasted."
msgstr "``explosion_timer``：用于跟踪爆炸持续时间的变量。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1151
msgid "``explode``: A boolean for tracking whether the bomb has exploded."
msgstr "``explode``：用于跟踪炸弹是否爆炸的布尔值。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1152
msgid "``fuse_particles``: The fuse :ref:`Particles <class_Particles>` node."
msgstr "``fuse_particles``：保险丝：ref：`Particles <class_Particles>`节点。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1153
msgid ""
"``explosion_particles``: The explosion :ref:`Particles <class_Particles>` "
"node."
msgstr ""
"``explosion_particles``：爆炸：ref：`Particles <class_Particles>`node。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1154
msgid ""
"``controller``: The controller that is currently holding the bomb, if there "
"is one. This is set by the controller, so we do not need to check anything "
"outside of checking if it is ``null``."
msgstr ""
"``controller``：当前持有炸弹的控制器，如果有的话。 这是由控制器设置的，所以除"
"了检查是否为“null”之外，我们不需要检查任何内容。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1158
msgid "Let's go through ``_ready``."
msgstr "让我们来看看``_ready``。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1160
msgid ""
"First, we get all of the nodes and assign them to the proper variables for "
"later use."
msgstr "首先，我们获取所有节点并将它们分配给适当的变量供以后使用。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1162
msgid ""
"Then, we make sure ``_physics_process`` is not going to be called. We do "
"this since we will be using ``_physics_process`` only for the fuse and for "
"destroying the bomb, so we do not want to trigger that early, we only want "
"the fuse to start when the player interacts while holding a bomb."
msgstr ""
"然后，我们确保不会调用``_physics_process``。 我们这样做是因为我们只使用"
"``_physics_process``作为保险丝和销毁炸弹，所以我们不想早点触发，我们只想让玩"
"家在拿着炸弹时进行交互时启动保险丝。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1167
msgid "Now, let's look at ``_physics_process``."
msgstr "现在，让我们看看`_physics_process``。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1169
msgid ""
"First we check to see if ``fuse_timer`` is less than ``FUSE_TIME``. If "
"``fuse_timer`` is less than ``FUSE_TIME``, then the bomb must be burning "
"down the fuse."
msgstr ""
"首先，我们检查``fuse_timer``是否小于``FUSE_TIME``。 如果``fuse_timer``小于"
"``FUSE_TIME``，那么炸弹必须烧掉保险丝。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1171
msgid ""
"We then add time to ``fuse_timer``, and check to see if the bomb has waited "
"long enough and has burned through the entire fuse."
msgstr ""
"然后我们将时间添加到``fuse_timer``，并检查炸弹是否已经等待足够长的时间并烧掉"
"整个保险丝。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1173
msgid ""
"If the bomb has waited long enough, then we need to explode the bomb. We do "
"this first by stopping the smoke :ref:`Particles <class_Particles>` from "
"emitting, and making the explosion :ref:`Particles <class_Particles>` emit. "
"We also hide the bomb mesh so it is no longer visible."
msgstr ""
"如果炸弹已经等了足够长的时间，那么我们需要爆炸炸弹。 我们首先停止冒烟：ref："
"`Particles <class_Particles>`来自发射，然后进行爆炸：ref：`Particles "
"<class_Particles>`emit。 我们还隐藏了炸弹网，使其不再可见。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1176
msgid ""
"Next, we make the set the collision layer and mask to zero, and set the :ref:"
"`RigidBody <class_RigidBody>` mode to static. This makes it where the now "
"exploded bomb cannot interact with the physics world, and so it will stay in "
"place."
msgstr ""
"接下来，我们将碰撞层和掩码设置为零，并将：ref：`RigidBody <class_RigidBody>`"
"模式设置为static。 这使得它现在爆炸的炸弹无法与物理世界相互作用，因此它将保持"
"原位。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1179
msgid ""
"Then we go through everything inside the explosion :ref:`Area <class_Area>`. "
"We make sure the bodies inside the explosion :ref:`Area <class_Area>` are "
"not the bomb itself, since we do not want to explode the bomb with itself. "
"We then check to see if the bodies have the ``damage`` method/function, and "
"if it does we call that, while if it does not we check to see if it has the "
"``apply_impulse`` method/function, and call that instead."
msgstr ""
"然后我们浏览爆炸内的所有内容：ref：`Area <class_Area>`。 我们确保爆炸内部的物"
"体：ref：`Area <class_Area>`不是炸弹本身，因为我们不想用它自己爆炸炸弹。 然后"
"我们检查一下是否有``damage``方法/函数，如果是，我们称之为，如果不是，我们检查"
"它是否有``apply_impulse``方法/函数，并且 打电话给那个。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1183
msgid ""
"Then we set ``explode`` to true since the bomb has exploded, and we play a "
"sound."
msgstr "然后我们将``explode``设置为true，因为炸弹已爆炸，我们发出声音。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1185
msgid ""
"Next, we check to see if the bomb has exploded, as we need to wait until the "
"explosion :ref:`Particles <class_Particles>` are done."
msgstr ""
"接下来，我们检查炸弹是否爆炸，因为我们需要等到爆炸：ref：`Particles "
"<class_Particles>`完成。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1187
msgid ""
"If the bomb has exploded, we add time to ``explosion_timer``. We then check "
"to see if the explosion :ref:`Particles <class_Particles>` are done. If they "
"are, we set the explosion :ref:`Area <class_Area>`'s monitoring property to "
"``false`` to ensure we do not get any bugs in the debugger, we make the "
"controller drop the bomb if it is holding onto it, we make the grab :ref:"
"`Raycast <class_Raycast>` visible if the grab mode is ``RAYCAST``, and we "
"free/destroy the bomb using ``queue_free``."
msgstr ""
"如果炸弹爆炸了，我们就加时间``explosion_timer``。 然后我们检查是否爆炸：ref："
"`Particles <class_Particles>`完成。 如果它们是，我们设置爆炸：ref：`Area "
"<class_Area>`的监视属性为``false``以确保我们不会在调试器中得到任何错误，我们"
"让控制器丢弃炸弹如果它持有 在它上面，我们制作了抓取：ref：`Raycast "
"<class_Raycast>`如果抓取模式是``RAYCAST``可见，我们使用``queue_free``释放/销"
"毁炸弹。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1193
msgid "Finally, let's look at ``interact``."
msgstr "最后，让我们看一下``interact``。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1195
msgid ""
"All we are doing here is making it where ``_physics_process`` will be "
"called, which will start the fuse. We also make the fuse :ref:`Particles "
"<class_Particles>` start emitting, so smoke comes out the top of the bomb."
msgstr ""
"我们在这里所做的只是调用``_physics_process``，这将启动保险丝。 我们还制作了保"
"险丝：ref：`Particles <class_Particles>`开始发射，所以烟雾从炸弹顶部出来。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1200
msgid ""
"With that done, the bombs are ready to go! You can find them in the orange "
"building. Because of how we are calculating velocity, it is easiest to throw "
"bombs in a trusting-like motion as opposed to a more natural throwing like "
"motion. The smooth curve of a throwing-like motion is harder to track, and "
"the because of how we are tracking velocity it does not always work."
msgstr ""
"完成后，炸弹准备好了！ 您可以在橙色建筑中找到它们。 由于我们如何计算速度，最"
"容易投掷类似信任的运动中的炸弹，而不是像运动那样更自然的投掷。 投掷式运动的平"
"滑曲线更难以跟踪，并且由于我们跟踪速度的方式并不总是有效。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1205
msgid "Adding a sword"
msgstr "加一把剑"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1207
msgid "Finally, let's add a sword so we can slice through things!"
msgstr "最后，让我们添加一把剑，这样我们就可以切入一些东西！"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1209
msgid "Open up ``Sword.tscn``, which you will find in ``Scenes``."
msgstr "打开``Sword.tscn``，你会在``Scenes``中找到它。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1211
msgid ""
"There is not a whole lot to note here, but there is just one thing, and that "
"is how the length of the blade of the sword is broken into several small :"
"ref:`Area <class_Area>` nodes. This is because we need to roughly know where "
"on the blade the sword collided, and this is the easiest (and only) way I "
"could figure out how to do this."
msgstr ""
"这里没有太多值得注意的，但只有一件事，那就是刀剑的长度被分成几个小的：ref："
"`Area <class_Area>`节点。 这是因为我们需要粗略地知道剑碰撞的刀片在哪里，这是"
"我能弄清楚如何做到这一点的最简单（也是唯一的）方法。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1214
msgid ""
"If you know how to find the point where a :ref:`Area <class_Area>` and a :"
"ref:`CollisionObject <class_CollisionObject>` meet, please let me know and/"
"or make a PR on the Godot documentation! This method of using several small :"
"ref:`Area <class_Area>` nodes works okay, but it is not ideal."
msgstr ""
"如果你知道如何找到一个点：ref：`Area <class_Area>`和a：ref：`CollisionObject "
"<class_CollisionObject>`见面，请告诉我和/或在Godot文档上做一个PR！ 这个使用几"
"个小的方法：ref：`Area <class_Area>`节点工作正常，但它并不理想。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1217
msgid ""
"Other than that, there really is not much of note, so let's write the code. "
"Select the ``Sword`` root node, the :ref:`RigidBody <class_RigidBody>` and "
"make a new script called ``Sword.gd``. Add the following code to ``Sword."
"gd``:"
msgstr ""
"除此之外，确实没有多少注意事项，所以让我们编写代码。 选择``Sword``根节点，："
"ref：`RigidBody <class_RigidBody>`并创建一个名为``Sword.gd``的新脚本。 将以下"
"代码添加到``Sword.gd``："

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1281
msgid ""
"Let's go over what this script does, starting with the two class variables:"
msgstr "让我们回顾一下这个脚本的作用，从两个类变量开始："

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1283
msgid "``SWORD_DAMAGE``: The amount of damage a single sword slice does."
msgstr "``SWORD_DAMAGE``：单个剑片所造成的伤害量。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1284
msgid ""
"``controller``: The controller that is holding the sword, if there is one. "
"This is set by the controller, so we do not need to set it here in ``Sword."
"gd``."
msgstr ""
"``controller``：拿着剑的控制器，如果有的话。 这是由控制器设置的，所以我们不需"
"要在``Sword.gd``中设置它。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1288
msgid "Let's go over ``_ready`` next."
msgstr "让我们接下来回顾一下``_ready``。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1290
msgid ""
"All we are doing here is connecting each of the :ref:`Area <class_Area>` "
"nodes ``body_entered`` signal to the ``body_entered_sword`` function, "
"passing in a additional argument which will be the number of the damage :ref:"
"`Area <class_Area>`, so we can figure out where on the sword the body "
"collided."
msgstr ""
"我们在这里所做的就是将每个：ref：`Area <class_Area>`nodes``body_entered``信号"
"连接到``body_entered_sword``函数，传入一个额外的参数，它将是损坏的数量：ref "
"：`Area <class_Area>`，所以我们可以弄清楚身体碰撞的剑在哪里。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1295
msgid "Now let's go over ``body_entered_sword``."
msgstr "现在让我们回顾一下``body_entered_sword``。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1297
msgid "First, we make sure the body the sword has collided with is not itself."
msgstr "首先，我们确保剑与之碰撞的身体本身并不存在。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1299
msgid ""
"Then we figure out which part of the sword the body collided with, using the "
"passed-in number."
msgstr "然后我们使用传入的数字找出身体碰撞的剑的哪一部分。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1301
msgid ""
"Next, we check to see if the body the sword collided with has the ``damage`` "
"function, and if it does, we call it and play a sound."
msgstr ""
"接下来，我们检查剑与剑相撞的身体是否具有“伤害”功能，如果有，我们称之为并发出"
"声音。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1303
msgid ""
"If it does not have the damage function, we then check to see if it has the "
"``apply_impulse`` function. If it does, we then calculation the direction "
"from the sword part the body collided with to the body. We then check to see "
"if the sword is being held or not."
msgstr ""
"如果它没有损坏功能，我们检查它是否具有``apply_impulse``功能。 如果是这样，我"
"们然后计算从身体碰撞的剑部分到身体的方向。 然后我们检查剑是否被关押。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1306
msgid ""
"If the sword is not being held, we use the :ref:`RigidBody "
"<class_RigidBody>`'s velocity as the force in ``apply_impulse``, while if "
"the sword is being held, we use the controller's velocity as the force in "
"the impulse."
msgstr ""
"如果没有持剑，我们使用：ref：`RigidBody <class_RigidBody>的速度作"
"为“apply_impulse”的力量，而如果持剑，我们使用控制器的速度作为力量 冲动。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1309
msgid "Finally, we play a sound."
msgstr "最后，我们发出声音。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1315
msgid ""
"With that done, you can now slice through the targets! You can find the "
"sword in the corner in between the shotgun and the pistol."
msgstr "完成后，您现在可以切入目标了！ 你可以在霰弹枪和手枪之间的角落找到剑。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1318
msgid "Updating the target UI"
msgstr "更新目标UI"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1320
msgid "Okay, let's update the UI as the sphere targets are destroyed."
msgstr "好吧，让我们在球体目标被破坏时更新UI。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1322
msgid ""
"Open up ``Game.tscn`` and then expand the ``GUI`` :ref:`MeshInstance "
"<class_MeshInstance>`. From there, expand the ``GUI`` :ref:`Viewport "
"<class_Viewport>` node and then select the ``base_control`` node. Add a new "
"script called ``Base_Control``, and add the following:"
msgstr ""
"打开``Game.tscn``然后展开``GUI``：ref：`MeshInstance <class_MeshInstance>`。 "
"从那里，展开``GUI``：ref：`Viewport <class_Viewport>`节点，然后选择"
"``base_control``节点。 添加一个名为``Base_Control``的新脚本，并添加以下内容："

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1342
msgid "Let's go over what this script does quickly, as it is fairly simple."
msgstr "让我们快速了解一下这个脚本的作用，因为它非常简单。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1344
msgid ""
"First, in ``_ready``, we get the :ref:`Label <class_Label>` that shows how "
"many spheres are left and assign it to the ``sphere_count_label`` class "
"variable. Next, we get ``Game.gd`` by using ``get_tree().root`` and assign "
"``sphere_ui`` to this script."
msgstr ""
"首先，在``_ready``中，我们得到：ref：`Label <class_Label>`，显示剩下多少个球"
"体并将其分配给``sphere_count_label``类变量。 接下来，我们使用``get_tree（）。"
"root``获得``Game.gd``并将``sphere_ui``分配给该脚本。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1347
msgid ""
"In ``update_ui``, we change the sphere :ref:`Label <class_Label>`'s text. If "
"there is at least one sphere remaining, we change the text to show how many "
"sphere's are still left in the world. If there are no more spheres "
"remaining, we change the text and congratulate the player."
msgstr ""
"在``update_ui``中，我们改变了球体：ref：`Label <class_Label>的文本。 如果剩下"
"至少一个球体，我们会更改文本以显示世界上还剩下多少球体。 如果没有更多的球体，"
"我们会更改文字并祝贺玩家。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1351
msgid "Adding the final special RigidBody"
msgstr "添加最终的特殊RigidBody"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1353
msgid ""
"Finally, before we finish this tutorial, let's add a way to reset the game "
"while in VR."
msgstr "最后，在我们完成本教程之前，让我们添加一种在VR中重置游戏的方法。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1355
msgid ""
"Open up ``Reset_Box.tscn``, which you will find in ``Scenes``. Select the "
"``Reset_Box`` :ref:`RigidBody <class_RigidBody>` node and make a new script "
"called ``Reset_Box.gd``. Add the following code to ``Reset_Box.gd``:"
msgstr ""
"打开``Reset_Box.tscn``，你会在``Scenes``中找到它。 选择``Reset_Box``：ref："
"`RigidBody <class_RigidBody>`节点并创建一个名为``Reset_Box.gd``的新脚本。 将"
"以下代码添加到``Reset_Box.gd``："

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1394
msgid "Let's go over what this does quickly, as it is also fairly simple."
msgstr "让我们快速回顾一下这个问题，因为它也很简单。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1396
msgid ""
"First, we get the starting global :ref:`Transform <class_Transform>` in "
"``_ready``, and assign it to ``start_transform``. We will use this to reset "
"the position of the reset box ever so often."
msgstr ""
"首先，我们在``_ready``中得到起始全局：ref：`Transform <class_Transform>`，并"
"将其赋值给``start_transform``。 我们将使用它来经常重置复位盒的位置。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1398
msgid ""
"In ``_physics_process``, we check to see if enough time has passed to reset. "
"If it has, we reset the box's :ref:`Transform <class_Transform>` and then "
"reset the timer."
msgstr ""
"在``_physics_process``中，我们检查是否有足够的时间重置。 如果有，我们重置框"
"的：ref：`Transform <class_Transform>`然后重置计时器。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1400
msgid ""
"If the player interacts while holding the reset box, we reset the scene by "
"calling ``get_tree().change_scene`` and passing in the path to the current "
"scene. This resets/restarts the scene completely."
msgstr ""
"如果玩家在按住重置框时进行交互，我们通过调用“get_tree（）。change_scene``并将"
"路径传递到当前场景来重置场景。 这会完全重置/重新启动场景。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1403
msgid ""
"When the reset box is dropped, we reset the :ref:`Transform "
"<class_Transform>` and timer."
msgstr ""
"当重置框被删除时，我们重置：ref：`Transform <class_Transform>`和计时器。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1407
msgid ""
"With that done, when you grab and interact with the reset box, the entire "
"scene will reset/restart and you can destroy all of the targets again!"
msgstr ""
"完成后，当您抓住并与重置框交互时，整个场景将重置/重新启动，您可以再次销毁所有"
"目标！"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1410
msgid "Final notes"
msgstr "最后的笔记"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1414
msgid "Phew! That was a lot of work. Now you have a fairly simple VR project!"
msgstr "唷！ 这是很多工作。 现在你有一个相当简单的VR项目！"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1416
msgid "If you ever get lost, be sure to read over the code again!"
msgstr "如果您迷路了，请务必再次阅读代码！"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1418
msgid ""
"You can download the finished project for this part here: :download:"
"`VR_Starter_Tutorial_Complete.zip <files/VR_Starter_Tutorial_Complete.zip>`"
msgstr ""
"您可以在此处下载此部分的已完成项目:: download：`VR_Starter_Tutorial_Complete."
"zip <files / VR_Starter_Tutorial_Complete.zip>`"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1420
msgid ""
"This hopefully will serve as a introduction into making fully featured VR "
"games in Godot! The code written here can be expanded to make puzzle games, "
"action games, story-based games, and more!"
msgstr ""
"这有望成为在Godot制作功能齐全的VR游戏的介绍！ 这里编写的代码可以扩展为制作益"
"智游戏，动作游戏，基于故事的游戏等等！"
