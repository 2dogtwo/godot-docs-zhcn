# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2019, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-07-29 21:34+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:4
msgid "VR starter tutorial"
msgstr "VR入门教程"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:7
msgid "Introduction"
msgstr "简介"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:11
#, fuzzy
msgid ""
"This tutorial will show you how to make a beginner VR game project in Godot."
msgstr "本教程系列将向您展示如何制作单人FPS游戏。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:13
msgid ""
"Keep in mind, **one of the most important things when making VR content is "
"getting the scale of your assets correct**! It can take lots of practice and "
"iterations to get this right, but there are a few things you can do to make "
"it easier:"
msgstr ""
"请记住， **制作VR内容时最重要的事情之一是保证您的资源大小合适** ！ 这可以通过"
"大量练习和反复调整来实现这一目标，但是您可以采取一些措施来简化这个过程:"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:16
#, fuzzy
msgid ""
"In VR, 1 unit is typically considered 1 meter. If you design your assets "
"around that standard, you can save yourself a lot of headache."
msgstr ""
"在VR中，1个单位通常被认为是1米。 如果按照该标准设计资源，可以省去很多麻烦。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:17
#, fuzzy
msgid ""
"In your 3D modeling program, see if there is a way to measure and use real "
"world distances. In Blender, you can use the MeasureIt add-on; in Maya, you "
"can use the Measure Tool."
msgstr ""
"在3D模型程序中，查看是否有测量和使用真实世界距离的方法。 在Blender中，您可以"
"使用MeasureIt插件，在Maya中，您可以使用测量工具。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:18
msgid ""
"You can make rough models using a tool like `Google Blocks <https://vr."
"google.com/blocks/>`_, and then refine in another 3D modelling program."
msgstr ""
"您可以使用诸如 `Google Blocks <https://vr.google.com/blocks/>`_ 之类的工具制"
"作粗略模型，然后在另一个3D建模程序中进行优化。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:19
msgid ""
"Test often, as the assets can look dramatically different in VR than on a "
"flat screen!"
msgstr "经常测试，因为VR中的资源看起来与平面屏幕上的显着不同！"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:21
msgid "Throughout the course of this tutorial, we will cover:"
msgstr "在本教程的整个过程中，我们将介绍:"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:23
msgid "How to tell Godot to run in VR."
msgstr "如何让Godot以VR模式运行。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:24
msgid "How to make a teleportation system for moving the player."
msgstr "如何制作用于移动游戏角色的传送系统。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:25
msgid ""
"How to make a directional movement system (locomotion) for moving the player."
msgstr "如何制作用于移动游戏角色的定向移动系统(移动)。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:26
#, fuzzy
msgid ""
"How to make a :ref:`RigidBody <class_RigidBody>`-based pick up and drop "
"system."
msgstr "如何制作一个 :ref:`RigidBody <class_RigidBody>` 基于拾取和放下系统。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:27
msgid "How to make various items that can be used in VR."
msgstr "如何制作可在虚拟现实场景内使用的各种物品。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:29
msgid ""
"While this tutorial can be completed by beginners, it is highly advised to "
"complete :ref:`doc_your_first_game`, if you are new to Godot and/or game "
"development and have some experience with making 3D games **before** going "
"through this tutorial series."
msgstr ""
"虽然本教程可以由初学者完成，但强烈建议您完成 :ref:`doc_your_first_game`，如果"
"您是Godot和/或游戏开发的新手，并且在完成本教程之前有一些制作3D游戏的经验** 系"
"列。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:34
msgid ""
"This tutorial assumes you have experience working with the Godot editor, "
"have basic programming experience in GDScript, and have basic 3D game "
"development experience."
msgstr ""
"本教程假设您有使用Godot编辑器的经验，基础GDScript编程经验，以及基础3D游戏开发"
"经验。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:37
#, fuzzy
msgid ""
"Also, it is assumed you have both an OpenVR-ready headset and two OpenVR-"
"ready controllers! This tutorial was written using a Windows Mixed Reality "
"headset on Windows 10, so the tutorial is written to work on that headset. "
"It has also been tested on the HTC Vive. You may need to adjust the code to "
"work with other VR headsets, such as the Oculus Rift."
msgstr ""
"此外，假设您有一个支持OpenVR的耳机和两个支持OpenVR的控制器！ 本教程是在"
"Windows 10上使用Windows Mixed Reality耳机编写的，因此编写本教程是为了使用该耳"
"机。 您可能需要调整代码以使用其他VR耳机，例如Oculus Rift或HTC Vive。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:40
msgid ""
"You can find the start assets for this tutorial here: :download:"
"`VR_Starter_Tutorial_Start.zip <files/VR_Starter_Tutorial_Start.zip>`"
msgstr ""
"您可以在此处找到本教程的起始资源: :download:`VR_Starter_Tutorial_Start.zip "
"<files / VR_Starter_Tutorial_Start.zip>`"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:42
msgid ""
"The provided starter assets contain some 3D models, sounds, and a few scenes "
"already set up and configured for this tutorial."
msgstr ""
"提供的初始化资源包含一些3D模型，声音以及已为本教程设置和配置的一些场景。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:44
msgid ""
"Feel free to use these assets however you want! All original assets belong "
"to the Godot community, with the other assets belonging to those listed "
"below:"
msgstr ""
"您可以随意使用这些资源！ 所有原始资源均属于Godot社区，其他资源属于以下列出的"
"资源:"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:46
#, fuzzy
msgid ""
"The sky panorama was created by **CGTuts** (`original source <https://cgi."
"tutsplus.com/articles/freebie-8-awesome-ocean-hdris--cg-5684>`_)."
msgstr ""
"天空全景由 **CGTuts** 创建，可在 `此处找到 <https://cgi.tutsplus.com/"
"articles/freebie-8-awesome-ocean-hdris--cg-5684>`_ 。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:48
msgid ""
"The font used is **Titillium-Regular**, and is licensed under the SIL Open "
"Font License, Version 1.1."
msgstr ""
"使用的字体是** Titillium-Regular **，并根据SIL Open Font License 1.1版获得许"
"可。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:50
#, fuzzy
msgid ""
"The audio used are from several different sources, all downloaded from the "
"**Sonnis #GameAudioGDC Bundle** (`license in PDF format <https://sonniss.com/"
"gdc-bundle-license/>`_). The folders where the audio files are stored have "
"the same name as folders in the bundle."
msgstr ""
"所使用的音频来自几个不同的来源，都来自 **Sonnis #GameAudioGDC Bundle**。 声音"
"效果的许可证包含在PDF `此处 <https://sonniss.com/gdc-bundle-license/>`_ 中。 "
"存储音频文件的文件夹与包中的文件夹具有相同的名称。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:53
msgid ""
"The **OpenVR addon** was created by Bastiaan Olij and is released under the "
"MIT license. It can be found both `on the Asset Library <https://godotengine."
"org/asset-library/asset/150>`_ and `on GitHub <https://github.com/GodotVR/"
"godot-openvr-asset>`_."
msgstr ""
"** OpenVR插件**由Bastiaan Olij创建，并在MIT许可下发布。 它可以在 `资源馆 "
"<https://godotengine.org/asset-library/asset/150>`_ 和在 `GitHub上找到 "
"<https://github.com/GodotVR/godot-openvr-asset>`_ 。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:55
msgid ""
"Everything else is original and created solely for this tutorial by "
"TwistedTwigleg. They are released under the MIT license, so feel free to use "
"them however you see fit!"
msgstr ""
"其他一切都是原创的，仅由TwistedTwigleg为本教程创建。 它们是在MIT许可下发布"
"的，所以您可以随意使用它们，但是您认为合适！"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:57
msgid "You can find the finished project at the bottom of this page."
msgstr "您可以在本页底部找到已完成的项目。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:60
msgid "Getting everything ready"
msgstr "准备好一切"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:62
msgid "Launch Godot and open up the project included in the starter assets."
msgstr "启动Godot并打开启动资源中包含的项目。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:64
msgid ""
"While these assets are not necessarily required to use the scripts provided "
"in this tutorial, they will make the tutorial much easier to follow, as "
"there are several premade scenes we will be using throughout the tutorial "
"series."
msgstr ""
"虽然使用这些资源并不一定需要本教程提供的脚本，但它们将使教程内容更容易理解，"
"所以我们将在本系列教程中使用这些预先制作的场景。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:68
msgid ""
"First, you may notice there is already quite a bit set up. This includes a "
"pre-built level, several instanced scenes placed around, some background "
"music, and several GUI-related :ref:`MeshInstances <class_MeshInstance>` "
"nodes."
msgstr ""
"首先，您可能会注意到已经设置了很多。 这包括预先构建的级别，放置的几个实例场"
"景，一些背景音乐，以及几个与GUI相关的 :ref:`MeshInstances "
"<class_MeshInstance>` 节点。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:71
#, fuzzy
msgid ""
"You may also notice that the GUI-related meshes already have a script "
"attached to them. This is used to show whatever is inside the :ref:`Viewport "
"<class_Viewport>` on the mesh. Feel free to take a look if you want, but "
"this tutorial will not be going over how to use the :ref:`Viewport "
"<class_Viewport>` nodes for making 3D GUI :ref:`MeshInstance "
"<class_MeshInstance>` nodes."
msgstr ""
"您可能会注意到与GUI相关的网格已经附加了一个脚本，这只是用于显示网格上的 :ref:"
"`Viewport <class_Viewport>` 内的任何内容。 如果您愿意，请随意查看，但本教程不"
"会讨论如何使用 :ref:`Viewport <class_Viewport>` 节点来制作3D GUI :ref:"
"`MeshInstance <class_MeshInstance>` 节点。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:75
#, fuzzy
msgid ""
"The other thing to notice, before we jump into writing the code, is how the :"
"ref:`ARVROrigin <class_ARVROrigin>` node works. How it works is kind of hard "
"to explain, especially if you have never used VR before, but here is the "
"gist of it: The :ref:`ARVROrigin <class_ARVROrigin>` node is the center "
"point of the room. If there is no room-scale tracking, then the :ref:"
"`ARVROrigin <class_ARVROrigin>` will be directly below the player, but if "
"there is room-scale tracking, then the :ref:`ARVROrigin <class_ARVROrigin>` "
"will be the center of the tracked room."
msgstr ""
"在我们开始编写代码之前要注意的另一件事是 :ref:`ARVROrigin "
"<class_ARVROrigin>` 节点是如何工作的。 它是如何工作的有点难以解释，特别是如果"
"您之前从未使用过VR，但这里有它的要点: :ref:`ARVROrigin <class_ARVROrigin>` 节"
"点是房间的中心点。 如果没有房间尺度跟踪，那么 :ref:`ARVROrigin "
"<class_ARVROrigin>` 将直接位于游戏角色的下方，但是如果有房间尺度跟踪，那么 :"
"ref:`ARVROrigin <class_ARVROrigin>` 将是 被跟踪的房间的中心。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:80
#, fuzzy
msgid ""
"This is a bit of a simplification, and honestly, I do not know enough about "
"the various different VR headsets and how they work to give a more detailed "
"and complete explanation. Consider it like this: The :ref:`ARVROrigin "
"<class_ARVROrigin>` is the center of the VR world. If there is room "
"tracking, the player can move away from the center point, the :ref:"
"`ARVROrigin <class_ARVROrigin>` node, but only as far as the room scaling "
"tracks."
msgstr ""
"这有点简化，老实说，我对各种不同的VR耳机以及它们如何工作以提供更详细和完整的"
"解释知之甚少。 简单的方法就是这样看:它 :ref:`ARVROrigin <class_ARVROrigin>` "
"是VR世界的中心。 如果有房间跟踪，游戏角色可以远离中心点，即 :ref:`ARVROrigin "
"<class_ARVROrigin>` 节点，但只能移动到房间缩放轨道。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:84
msgid ""
"If you select the :ref:`ARVROrigin <class_ARVROrigin>` node, you may notice "
"that the world scale is set to ``1.4``. This is because I originally made "
"the world too big, and so I needed to scale the VR player slightly so they "
"better fit the world. As mentioned earlier, keeping the scale relatively "
"constant is very important!"
msgstr ""
"如果选择 :ref:`ARVROrigin <class_ARVROrigin>` 节点，您可能会注意到世界比例设"
"置为“1.4”。 这是因为我最初让世界变得太大，所以我需要稍微扩展VR游戏角色以便它"
"们更适合这个世界。 如前所述，保持比例相对稳定非常重要！"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:87
#, fuzzy
msgid ""
"Another thing to notice here is how we have everything set up under the :ref:"
"`ARVROrigin <class_ARVROrigin>` node. The player camera is an :ref:"
"`ARVRCamera <class_ARVRCamera>` that represents the player's head in the "
"game. The :ref:`ARVRCamera <class_ARVRCamera>` will be offset by the "
"player's height, and if there is room tracking, then the camera can move "
"around 3D space as well, relative to the :ref:`ARVROrigin "
"<class_ARVROrigin>`. This is important to note, especially for later when we "
"add teleporting."
msgstr ""
"另外需要注意的是我们如何在 :ref:`ARVROrigin <class_ARVROrigin>` 节点下设置所"
"有内容。 游戏角色相机是 :ref:`ARVRCamera <class_ARVRCamera>` 代表游戏角色在游"
"戏中的头部。 :ref:`ARVRCamera <class_ARVRCamera>` 将被游戏角色的高度偏移，如"
"果有房间跟踪，那么相对于 :ref:`ARVROrigin <class_ARVROrigin>`，相机也可以在3D"
"空间中移动。 这一点很重要，特别是以后我们添加传送时。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:91
msgid ""
"Notice how there is a :ref:`ColorRect <class_ColorRect>` node called "
"``Movement_Vignette``. This will be a vignette shader that will only be "
"visible when the player is moving. We are going to use the vignette shader "
"to help reduce motion sickness while moving in VR. The reason it is a child "
"of :ref:`ARVROrigin <class_ARVROrigin>` is because we want it to easily "
"access the VR controllers."
msgstr ""
"注意如何 :ref:`ColorRect <class_ColorRect>` 节点名为 "
"``Movement_Vignette`` 。 这将是一个小插图着色器，只有在游戏角色移动时才会显"
"示。 我们将使用晕影着色器来帮助减少在VR中移动时的晕动病。 它是子节点的原因 :"
"ref:`ARVROrigin <class_ARVROrigin>` 是因为我们希望它能够轻松访问VR控制器。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:95
#, fuzzy
msgid ""
"The final thing to note is that there are two :ref:`ARVRController "
"<class_ARVRController>` nodes, and these will represent the left and right "
"controllers in 3D space. An :ref:`ARVRController <class_ARVRController>` "
"with an ID of 1 is the left hand, while an :ref:`ARVRController "
"<class_ARVRController>` with an ID of 2 is the right hand."
msgstr ""
"最后要注意的是有两个 :ref:`ARVRController <class_ARVRController>` 节点，这些"
"节点将代表3D空间中的左右控制器。 答 :ref:`ARVRController "
"<class_ARVRController>` 的ID是左手，而a :ref:`ARVRController "
"<class_ARVRController>` 的ID是右手。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:99
msgid "Starting VR"
msgstr "启动VR"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:101
msgid ""
"First, let's get the VR up and going! While ``Game.tscn`` is open, select "
"the ``Game`` node and make a new script called ``Game.gd``. Add the "
"following code:"
msgstr ""
"首先，让我们启动VR!打开“Game.tscn”场景,选择“游戏”（Game）节点并创建一个名"
"为“Game.gd”的新脚本。添加以下代码:"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:142
msgid ""
"For this to work, you will need to have the `OpenVR asset from the Asset "
"Library <https://godotengine.org/asset-library/asset/150>`_. The OpenVR "
"asset is included in the starter assets, but there may be newer versions "
"that work better, so I would highly suggest deleting the ``addons`` folder, "
"then going to the Asset Library and downloading the newest version."
msgstr ""
"要实现这一点，您需要拥有资源馆中的 `OpenVR资源 <https://godotengine.org/"
"asset-library/asset/150>`_ 。 OpenVR资源包含在初始资源中，但可能有更新版本更"
"好，所以我强烈建议删除 ``addons`` 文件夹，然后转到资源馆并下载最新版本。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:146
msgid "With that done, let's quickly go over what this script does."
msgstr "完成后，让我们快速浏览一下这个脚本的功能。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:148
#, fuzzy
msgid ""
"First, we find a VR interface from the ARVR server. We do this because by "
"default Godot does not include any VR interfaces, but rather exposes an API "
"so anyone can make AR/VR interfaces with GDNative/C++. Next, we check to see "
"if an OpenVR interface was found, and then we initialize it."
msgstr ""
"首先，我们从ARVR服务器找到VR界面。 我们这样做是因为默认情况下，Godot不包含任"
"何VR界面，而是公开API，因此任何人都可以使用GDNative / C++制作AR / VR界面。 接"
"下来，我们检查是否找到了OpenVR界面，然后我们初始化它。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:151
#, fuzzy
msgid ""
"Assuming nothing went wrong with initializing, we then turn the main :ref:"
"`Viewport <class_Viewport>` into an AR/VR viewport, by setting ``arvr`` to "
"``true``. We also set HDR to ``false``, since you cannot use HDR in OpenVR."
msgstr ""
"假设初始化没有出错，我们将main :ref:`Viewport <class_Viewport>` 转换为AR / VR"
"视区，将 ``arvr`` 设置为 ``true`` 。 我们还将HDR设置为“false”，因为您无法在"
"OpenVR中使用HDR。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:154
#, fuzzy
msgid ""
"Then, we disable V-Sync and set the target FPS to 90 frames per second. Most "
"VR headsets run at 90 Hz, and since the game will display on both the VR "
"headset and the computer's monitor, we want to disable V-Sync and set the "
"target FPS manually, so the computer's monitor does not drag the VR display "
"down to 60 FPS."
msgstr ""
"然后我们禁用V-Sync并将目标FPS设置为每秒90帧。 大多数VR头戴式耳机以90 Hz的频率"
"运行，由于游戏将同时显示在VR头戴式耳机和计算机的显示器上，我们希望禁用V-Sync"
"并手动设置目标FPS，以便计算机的显示器不会将VR显示器拖动到 60 FPS。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:157
msgid ""
"One thing to notice as well is that the physics FPS is also set to 90! This "
"makes the physics run at the same frame rate as the display, which makes "
"things look smoother in VR."
msgstr ""
"有一点需要注意的是，物理FPS也设置为90！ 这使得物理运行与显示器的帧速率相同，"
"这使VR中的内容看起来更平滑。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:162
msgid ""
"With that done, go ahead and give the game a try! If everything goes well, "
"you will now be able to look around the world! If you have a VR headset with "
"room tracking, you will be able to move around as far as the room tracking "
"allows."
msgstr ""
"完成后，继续尝试游戏吧！ 如果一切顺利，您现在可以环顾世界！ 如果您的VR耳机具"
"有房间跟踪功能，您可以在房间跟踪允许的情况下四处移动。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:166
msgid "Coding the controllers"
msgstr "编码控制器"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:168
#, fuzzy
msgid ""
"While perhaps interesting if we were making a VR film, we really want to do "
"more than stand around and look. Currently, we cannot move outside of the "
"room tracking boundaries (assuming your VR headset has room tracking) and we "
"cannot interact with anything! Let's change that!"
msgstr ""
"虽然我们制作VR电影可能很有意思，但我们真的想做的不仅仅是站着看看。 目前我们无"
"法移动到房间跟踪边界之外(假设您的VR耳机有房间跟踪)，我们无法与任何东西互动！ "
"让我们改变它！"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:171
msgid ""
"You may have noticed that you have a pair of green and black hands following "
"the controllers. Let's write the code for those controllers, which will "
"allow the player to teleport around the world and allow the player to grab "
"and release :ref:`RigidBody <class_RigidBody>` nodes."
msgstr ""
"您可能已经注意到控制器后面有一对绿色和黑色指针。 让我们为这些控制器编写代码，"
"这将允许游戏角色在世界各地传送并允许游戏角色抓取并释放 :ref:`RigidBody "
"<class_RigidBody>` 节点。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:174
#, fuzzy
msgid ""
"Open either ``Left_Controller.tscn`` or ``Right_Controller.tscn``. Feel free "
"to look at how the scene is set up; there are only a couple things of note "
"to point out."
msgstr ""
"打开 ``Left_Controller.tscn`` 或``Right_Controller.tscn``。 随意看看场景是如"
"何设置的; 只有几点值得注意。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:176
#, fuzzy
msgid ""
"First, notice how there are a couple :ref:`Raycast <class_Raycast>` nodes. "
"We will be using one :ref:`Raycast <class_Raycast>` to teleport around the "
"game world (``Raycast``) and we will use the other for picking up objects "
"(``GrabCast``) if the player is using :ref:`Raycast <class_Raycast>` nodes "
"to pick up objects."
msgstr ""
"首先，注意如何有一对 :ref:`Raycast <class_Raycast>` 节点。 我们将使用一个 :"
"ref:`Raycast <class_Raycast>` 来传送游戏世界(``Raycast``)，如果游戏角色正在使"
"用，我们将使用另一个来拾取对象(``GrabCast``) :ref:`Raycast <class_Raycast>` "
"节点来拾取对象。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:179
#, fuzzy
msgid ""
"The other thing to note is how there is an :ref:`Area <class_Area>` called "
"``Area``, that is a small sphere in the palm of the hand. This will be used "
"to detect objects the player can pick up with that hand if the player is "
"using :ref:`Area <class_Area>` nodes to pick up objects."
msgstr ""
"另外需要注意的是:如何存在 :ref:`Area <class_Area>` 简称为 ``Area`` ，这是手掌"
"中的一个小球体。 如果游戏角色正在使用，这将用于检测游戏角色可以用该手拿起的对"
"象 :ref:`Area <class_Area>` 节点来拾取对象。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:182
#, fuzzy
msgid ""
"We also have a larger :ref:`Area <class_Area>` called ``Sleep_Area``, which "
"will be used to wake :ref:`RigidBody <class_RigidBody>` nodes when the hands "
"get close."
msgstr ""
"我们还有一个更大的 :ref:`Area <class_Area>` 名为 ``Sleep_Area`` ，它只是用来"
"唤醒:当手靠近时ref:`RigidBody <class_RigidBody>` 节点。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:184
msgid ""
"Select the root node, either ``Left_Controller`` or ``Right_Controller`` "
"depending on which scene you chose, and create a new script called "
"``VR_Controller.gd``. Add the following to ``VR_Controller.gd``:"
msgstr ""
"根据您选择的场景选择根节点， ``Left_Controller`` 或``Right_Controller``，并创"
"建一个名为 ``VR_Controller.gd`` 的新脚本。 将以下内容添加到``VR_Controller."
"gd``:"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:428
msgid ""
"This is quite a bit of code to go through, so let's break it down bit by "
"bit. Let's start with the class variables, which are variables outside of "
"any/all functions."
msgstr ""
"这是相当多的代码，所以让我们一点一点地分解它。 让我们从类变量开始，这些变量是"
"任何/所有函数之外的变量。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:431
msgid ""
"``controller_velocity``: The velocity the controller is moving at. We will "
"calculate this by changes in position every physics frame."
msgstr ""
"``controller_velocity``:控制器移动的速度。 我们将通过每个物理框架的位置变化来"
"计算它。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:432
msgid ""
"``prior_controller_position``: The controller's previous position. We will "
"use this to calculate the controller's velocity."
msgstr ""
"``prior_controller_position``:控制器的先前位置。 我们将使用它来计算控制器的速"
"度。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:433
msgid ""
"``prior_controller_velocities``: The last 30 calculated velocities (1/3 of a "
"second worth of velocities, assuming the game is running at 90 FPS)."
msgstr ""
"``prior_controller_velocities``:最后30个计算的速度(速度的1/3，假设游戏以90 "
"FPS运行)。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:434
msgid ""
"``held_object``: The currently-held object, a :ref:`RigidBody "
"<class_RigidBody>`, if there is one."
msgstr ""
"``held_object``:当前持有的对象，a :ref:`RigidBody <class_RigidBody>`，如果有"
"的话。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:435
msgid ""
"``held_object_data``: The data of the currently-held object, used to reset "
"the object when it is no longer being held."
msgstr ""
"``held_object_data``:当前保持对象的数据，用于在不再保持对象时重置对象。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:436
msgid "``grab_area``: The :ref:`Area <class_Area>` node used to grab objects."
msgstr "``grab_area``:用于抓取对象的 :ref:`Area <class_Area>` 节点。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:437
msgid "``grab_pos_node``: The position where held objects stay."
msgstr "``grab_pos_node``:保持对象所在的位置。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:438
msgid ""
"``hand_mesh``: The hand mesh, used to represent the player's hand when they "
"are not holding anything."
msgstr "``hand_mesh``:手形网格，用于表示游戏角色手上没有任何东西时的手牌。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:439
#, fuzzy
msgid ""
"``teleport_pos``: The position at which the teleport :ref:`Raycast "
"<class_Raycast>` is aimed."
msgstr "``teleport_pos``:传送的位置 :ref:`Raycast <class_Raycast>` 的目标是。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:440
#, fuzzy
msgid "``teleport_mesh``: The mesh used to represent the teleport position."
msgstr "``teleport_mesh``:用于表示传送位置的网格。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:441
msgid ""
"``teleport_button_down``: A variable for tracking whether the teleport "
"button is being held down or not."
msgstr "``teleport_button_down``:用于跟踪传送按钮是否被按下的变量。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:442
msgid ""
"``teleport_raycast``: The teleport :ref:`Raycast <class_Raycast>` node, used "
"for calculating the teleportation position."
msgstr ""
"``teleport_raycast``:传送 :ref:`Raycast <class_Raycast>` 节点，用于计算传送位"
"置。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:443
msgid ""
"``CONTROLLER_DEADZONE``: The dead zone for both the trackpad and the "
"joystick."
msgstr "``CONTROLLER DEADZONE``:触控板和操纵杆的死区。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:444
msgid ""
"``MOVEMENT_SPEED``: The speed the player moves at when moving using the "
"trackpad and/or the joystick."
msgstr "``MOVEMENT_SPEED``:使用触控板和/或操纵杆移动时游戏角色移动的速度。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:445
msgid ""
"``directional_movement``: A boolean to track whether the player is moving "
"using this controller."
msgstr ""
"``directional_movement``:一个布尔值，用于跟踪游戏角色是否正在使用此控制器移"
"动。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:449
msgid "Next, let's go through ``_ready``."
msgstr "接下来，让我们通过 ``_ready`` 。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:451
#, fuzzy
msgid ""
"Firstly, we get the teleport :ref:`Raycast <class_Raycast>` node and assign "
"it to ``teleport_raycast``."
msgstr ""
"首先我们得到teleport :ref:`Raycast <class_Raycast>` 节点并将其分配给 "
"``teleport_raycast`` 。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:453
msgid ""
"Next, we get the teleport mesh; notice how we are getting it from ``Game/"
"Teleport_Mesh`` using ``get_tree().root``. This is because we need the "
"teleport mesh to be separate from the controller, so moving and rotating the "
"controller does not affect the position and rotation of the teleportation "
"mesh."
msgstr ""
"接下来，我们得到了传送网; 注意我们如何使用 ``get_tree().root`` 从``Game / "
"Teleport_Mesh``获取它。 这是因为我们需要将传送网格与控制器分开，因此移动和旋"
"转控制器不会影响传送网格的位置和旋转。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:456
msgid ""
"Then we get the grab area, grab :ref:`Raycast <class_Raycast>`, and position "
"node and assign them to the proper variables."
msgstr ""
"然后我们得到抓取区域，抓住 :ref:`Raycast <class_Raycast>`，并定位节点并将它们"
"分配给适当的变量。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:458
msgid ""
"We set the default grab mode to ``AREA`` so it uses the :ref:`Area "
"<class_Area>` node to grab objects by default."
msgstr ""
"我们将默认的抓取模式设置为 ``AREA`` ，因此它使用 :ref:`Area <class_Area>` 节"
"点默认抓取对象。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:460
msgid ""
"Then we connect the ``body_entered`` and ``body_exited`` signals from the "
"sleep area node, we get the hand mesh and assign it the proper variable, and "
"finally we connect the ``button_pressed`` and ``button_released`` signals "
"from the :ref:`ARVRController <class_ARVRController>`."
msgstr ""
"然后我们连接来自睡眠区域节点的 ``body_entered`` 和``body_exited``信号，我们获"
"得手网格并为其分配适当的变量，最后我们连接 ``button_pressed`` 和"
"``button_released`` 来自 :ref:`ARVRController <class_ARVRController>` 的信"
"号。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:465
msgid "Now let's go through ``_physics_process``."
msgstr "现在让我们来看看`_physics_process``。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:467
#, fuzzy
msgid ""
"Firstly, we check to see if the teleportation button is down or not. If the "
"teleportation button is down, we then force the teleportation :ref:`Raycast "
"<class_Raycast>` to update, which will give us frame perfect collision "
"detection. We then check to see if the :ref:`Raycast <class_Raycast>` is "
"colliding with anything."
msgstr ""
"首先，我们检查传送按钮是否关闭。 如果传送按钮关闭，我们然后强制传送 :ref:"
"`Raycast <class_Raycast>` 更新，这将给我们帧完美的碰撞检测。 然后我们检查 :"
"ref:`Raycast <class_Raycast>` 是否与任何东西发生碰撞。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:470
#, fuzzy
msgid ""
"Next, we check to see if the collision body the :ref:`Raycast "
"<class_Raycast>` is colliding with is a :ref:`StaticBody "
"<class_StaticBody>`. We do this to ensure the player can only teleport on :"
"ref:`StaticBody <class_StaticBody>` nodes. We then check to see if the ``Y`` "
"value returned by the :ref:`Raycast <class_Raycast>`'s "
"``get_collision_normal`` function is more than ``0.85``, which is mostly "
"pointing straight up. This allows the player only to teleport on fairly flat "
"faces pointing upwards."
msgstr ""
"接下来，我们检查一下碰撞体是否与 :ref:`Raycast <class_Raycast>` 碰撞的是 :"
"ref:`StaticBody <class_StaticBody>`。 我们这样做是为了确保游戏角色只能传送 :"
"ref:`StaticBody <class_StaticBody>` 节点。 然后我们检查一下 :ref:`Raycast "
"<class_Raycast>` 的 ``get_collision_normal`` 函数返回的 ``Y`` 值是否大于 "
"``0.85`` ，这大多指向直线。 这允许游戏角色仅在相当平坦的面向上传送。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:474
msgid ""
"If all those checks for the teleport :ref:`Raycast <class_Raycast>` return "
"true, we then set ``teleport_pos`` to the collision point, and we move the "
"teleportation mesh to ``teleport_pos``."
msgstr ""
"如果对teleport的所有检查 :ref:`Raycast <class_Raycast>` 返回true，我们将 "
"``teleport_pos`` 设置为碰撞点，然后我们将远程传送网格移动到 "
"``teleport_pos`` 。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:477
#, fuzzy
msgid ""
"The next thing we check is to see if the :ref:`ARVRController "
"<class_ARVRController>` is active or not. If the :ref:`ARVRController "
"<class_ARVRController>` is active, then that means there is a controller and "
"it is being tracked. If the controller is active, we then reset "
"``controller_velocity`` to an empty :ref:`Vector3 <class_Vector3>`."
msgstr ""
"接下来我们要检查的是 :ref:`ARVRController <class_ARVRController>` 是否处于活"
"动状态。 如果 :ref:`ARVRController <class_ARVRController>` 处于活动状态，则表"
"示存在控制器并且正在跟踪它。 如果控制器处于活动状态，我们将 "
"``controller_velocity`` 重置为空 :ref:`Vector3 <class_Vector3>`。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:480
msgid ""
"We then add all of the prior velocity calculations in "
"``prior_controller_velocities`` to ``controller_velocity``. By using the "
"prior calculations, we get a smoother throwing/catching experience, although "
"it is not perfect. We want to get the average of these velocities, as "
"otherwise we'd get crazy high velocity numbers that are not realistic."
msgstr ""
"然后，我们将 ``prior_controller_velocities`` 中的所有先前速度计算添加到 "
"``controller_velocity`` 中。 通过使用先前的计算，我们获得了更平滑的投掷/捕捉"
"体验，尽管它并不完美。 我们希望得到这些速度的平均值，否则我们会得到疯狂的高速"
"数字，这是不现实的。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:483
#, fuzzy
msgid ""
"Next, we calculate the velocity from the position where the controller is "
"currently, from the position the controller was at. We can use this "
"difference in position to help track the controller's velocity."
msgstr ""
"接下来，我们从控制器当前所处的位置，从控制器所处的位置计算速度。 我们可以使用"
"这种位置差异来帮助追踪控制器的速度。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:486
msgid ""
"We then add the velocity from the controller this physics frame and the last "
"physics frame to ``controller_velocity``. We then update "
"``prior_controller_position`` to the current position, so we can use it in "
"the calculations in the velocity next physics frame."
msgstr ""
"然后我们将控制器的速度从物理框架和最后一个物理框架添加"
"到“controller_velocity”。 然后我们将 ``prior_controller_position`` 更新到当前"
"位置，这样我们就可以在速度下一个物理帧的计算中使用它。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:489
#, fuzzy
msgid ""
"The way we are calculating velocity is not perfect by any means, since it "
"relies on a consistent amount of frames per second. Ideally, we would be "
"able to find the velocity directly from the VR controller, but currently in "
"OpenVR, there is no way to access the controller's velocity. We can get "
"pretty close to the real velocity by comparing positions between frames "
"though, and this will work just fine for this project."
msgstr ""
"我们计算速度的方式无论如何都不是完美的，因为它依赖于每秒一致的帧数。 理想情况"
"下，我们可以直接从VR控制器中找到速度，但目前在OpenVR中无法访问控制器的速度。 "
"通过比较帧之间的位置，我们可以非常接近真实速度，这对于这个项目来说效果很好。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:493
#, fuzzy
msgid ""
"Then, we check to see if we have more than 30 stored velocities (more than a "
"third of a second). If there are more than 30, we remove the oldest velocity "
"from ``prior_controller_velocities``."
msgstr ""
"然后我们检查我们是否有超过30个存储的速度(超过三分之一秒)。 如果超过30，我们"
"从 ``prior_controller_velocities`` 中删除最旧的速度。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:497
#, fuzzy
msgid ""
"Next, we check to see whether there is a held object. If there is, we update "
"the position and rotation of the held object to the position and rotation of "
"``grab_pos_node``. Because of how scale works, we need to temporarily store "
"the scale and then reset the scale once we have updated the transform; "
"otherwise, the scale would always be the same as the controller, which would "
"ruin immersion if the player grabbed a scaled object."
msgstr ""
"接下来我们检查是否有被保持的物体。 如果有，我们将被保持对象的位置和旋转更新"
"为“grab_pos_node”的位置和旋转。 由于比例是如何工作的，我们需要暂时存储比例，"
"然后在我们更新变换后重置比例，否则比例将始终与控制器相同，如果游戏角色抓取比"
"例对象，这将打破沉浸。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:502
msgid ""
"The last thing we are going to do in ``_physics_process`` is move the player "
"if they are moving the trackpad/joystick on the VR controller."
msgstr ""
"我们在 ``_physics_process`` 中要做的最后一件事是移动游戏角色，如果他们正在移"
"动VR控制器上的触控板/操纵杆。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:504
#, fuzzy
msgid ""
"Firstly, we convert the axis values into :ref:`Vector2 <class_Vector2>` "
"variables, so we can process them. We invert the X axis, so moving the "
"trackpad/joystick left will move the player left."
msgstr ""
"首先，我们将轴值转换为 :ref:`Vector2 <class_Vector2>` 变量，以便我们可以处理"
"它们。 我们将X轴反转，因此向左移动触控板/操纵杆将使游戏角色向左移动。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:507
msgid ""
"Depending on your VR controller and OS, you may need to change the code so "
"it gets the proper axis values!"
msgstr "根据您的VR控制器和操作系统，您可能需要更改代码，以便获得正确的轴值！"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:509
#, fuzzy
msgid ""
"Next, we account for dead zones on both the trackpad and the joystick. The "
"code for doing this is adapted from the link below, and I would highly "
"recommend looking at it."
msgstr ""
"接下来，我们会在触控板和操纵杆上考虑死区。 执行此操作的代码改编自以下链接，我"
"强烈建议您查看它。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:511
#, fuzzy
msgid ""
"You can find a great article explaining joystick dead zones `on Third Helix "
"<http://www.third-helix.com/2013/04/12/doing-thumbstick-dead-zones-right."
"html>`_."
msgstr ""
"您可以找到一篇很棒的文章解释操纵杆死区`这里 <http://www.third-helix."
"com/2013/04/12/doing-thumbstick-dead-zones-right.html>`_ 。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:513
msgid ""
"One thing to note is how large we are making the dead zones. The reason we "
"are using such large dead zones is so the player cannot move themselves "
"accidentally by placing their finger on the center of the touchpad/joystick, "
"which can make players experience motion sickness if they are not expecting "
"it."
msgstr ""
"需要注意的一点是我们制造死区有多大。 我们使用如此大的死区的原因是游戏角色不能"
"通过将他们的手指放在触摸板/操纵杆的中心而不小心移动自己，这可能会让游戏角色在"
"不期待它时遇到晕动病。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:516
msgid ""
"Next, we get the forward and right directional vectors from the VR camera. "
"We need these so we can move the player forward/backwards and right/left "
"based on where they are currently looking."
msgstr ""
"接下来，我们从VR摄像机获得前向和右向方向向量。 我们需要这些，所以我们可以根据"
"他们当前所在的位置向前/向后和向右/向左移动游戏角色。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:519
#, fuzzy
msgid ""
"Then, we calculate how much the player will be moving by adding both the "
"trackpad and the joystick vectors together and normalizing them."
msgstr ""
"然后我们通过将触控板和操纵杆向量一起添加并将它们标准化来计算游戏角色将移动多"
"少。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:521
msgid ""
"Next, we calculate how far the player will go forwards/backwards and right/"
"left by multiplying the VR camera's directional vectors by the combined "
"trackpad/joystick vector."
msgstr ""
"接下来，我们通过将VR摄像机的方向向量乘以组合的触控板/操纵杆向量来计算游戏角色"
"前进/后退和右/左的距离。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:523
#, fuzzy
msgid ""
"We then remove movement on the Y axis so the player cannot fly/fall by "
"moving using the trackpad/joystick."
msgstr ""
"然后我们移除Y轴上的移动，这样游戏角色就不能通过使用触控板/操纵杆移动来飞行/跌"
"落。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:525
msgid ""
"And finally, we move the player if there is any movement forwards/backwards "
"or right/left. If we are moving the player, we set ``directional_movement`` "
"accordingly."
msgstr ""
"最后，如果向前/向后或向右/向左移动，我们会移动游戏角色。 如果我们移动游戏角"
"色，我们相应地设置 ``directional_movement`` 。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:529
msgid "Now, let's look at ``button_pressed``."
msgstr "现在，让我们看看 ``button_pressed`` 。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:531
#, fuzzy
msgid ""
"If the button pressed is button 15, which for the Windows Mixed Reality "
"controllers is the trigger button, we will interact with the held object "
"assuming the controller is holding one, and if the player is not holding an "
"object, we will try to start teleporting."
msgstr ""
"如果按下的按钮是按钮15，对于Windows混合现实控制器是触发按钮，我们将与保持的对"
"象交互，假设控制器持有一个，如果游戏角色没有持有对象，我们将尝试开始传送。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:534
#, fuzzy
msgid ""
"If the controller is holding an object, and the held object has a method/"
"function called ``interact``, we call the ``interact`` function on the held "
"object."
msgstr ""
"如果控制器持有一个对象，并且持有的对象有一个名为 ``interact`` 的方法/函数，我"
"们在被保持的对象上调用 ``interact`` 函数。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:537
#, fuzzy
msgid ""
"If the controller is not holding an object, we then check to make sure the "
"teleportation mesh is not visible. This check ensures the player cannot "
"teleport with both hands/controllers at the same time. If the teleportation "
"mesh is not visible, we set ``teleport_button_down`` to ``true``, make "
"``teleport_mesh`` visible, and make the teleportation raycast visible. This "
"makes it where the teleportation mesh will follow the :ref:`Raycast "
"<class_Raycast>` coming from the pointer finger of the hand."
msgstr ""
"如果控制器没有拿着物体，我们检查以确保隐形传送网格不可见。 此检查确保游戏角色"
"不能同时传送不能用双手/控制器传送。 如果远程传送网格不可见，我们将 "
"``teleport_button_down`` 设置为 ``true`` ，使 ``teleport_mesh`` 可见，并使远"
"距传送光线投射可见。 这使得远程传送网格将遵循 :ref:`Raycast <class_Raycast>` "
"来自手的指针。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:542
#, fuzzy
msgid ""
"If the button pressed is button 2, which, for the Windows Mixed Reality "
"controllers, is the grab/grip button, we will grab/throw an object."
msgstr ""
"如果按下的按钮是按钮2，对于Windows混合现实控制器是抓取/抓握按钮，我们将抓取/"
"抛出一个对象。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:544
#, fuzzy
msgid ""
"Firstly, we make sure the player is not trying to teleport, as we do not "
"want the player to be able to grab something while in the middle of trying "
"to teleport."
msgstr ""
"首先，我们确保游戏角色不会尝试传送，因为我们不希望游戏角色在尝试传送的过程中"
"能够抓住某些东西。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:546
#, fuzzy
msgid ""
"Then, we check to see whether the controller is already holding a object or "
"not."
msgstr "然后我们检查控制器是否已经持有一个对象。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:548
#, fuzzy
msgid ""
"If the controller is not holding an object, we check to see which grab mode "
"the player is using."
msgstr "如果控制器没有拿着物体，我们会检查游戏角色正在使用哪种抓取模式。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:550
#, fuzzy
msgid ""
"If the player is using the ``AREA`` grab mode, we then get all the bodies "
"overlapping the grab :ref:`Area <class_Area>`. We go through all the bodies "
"in the grab :ref:`Area <class_Area>` and see if there is a :ref:`RigidBody "
"<class_RigidBody>`. We also check to make sure any :ref:`RigidBody "
"<class_RigidBody>` nodes in the :ref:`Area <class_Area>` do not have a "
"variable called ``NO_PICKUP``, since we do not want to be able to pick up "
"nodes with that variable."
msgstr ""
"如果游戏角色正在使用 ``AREA`` 抓取模式，那么我们将获得所有与grab重叠的实体 :"
"ref:`Area <class_Area>`。 我们遍历了grab中的所有实体 :ref:`Area "
"<class_Area>` 并查看是否有 :ref:`RigidBody <class_RigidBody>`。 我们还检查以"
"确定 :ref:`RigidBody <class_RigidBody>` 节点 :ref:`Area <class_Area>` 没有名"
"为 ``NO_PICKUP`` 的变量，因为我们不希望能够选择 具有该变量的节点。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:554
msgid ""
"Assuming there is a :ref:`RigidBody <class_RigidBody>` node inside the grab :"
"ref:`Area <class_Area>` that does not have a variable called ``NO_PICKUP``, "
"we assign it to ``rigid_body`` for additional processing."
msgstr ""
"假设在:grab :ref:`Area <class_Area>` 里面有一个 :ref:`RigidBody "
"<class_RigidBody>` 节点，它没有一个名为 ``NO_PICKUP`` 的变量，我们将它分配给 "
"``rigid_body`` 以获得额外的处理。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:557
#, fuzzy
msgid ""
"If the player is using the ``RAYCAST`` grab mode, we first force the :ref:"
"`Raycast <class_Raycast>` to update. We then check to see whether the :ref:"
"`Raycast <class_Raycast>` is colliding with something."
msgstr ""
"如果游戏角色正在使用 ``RAYCAST`` 抓取模式，我们首先强制 :ref:`Raycast "
"<class_Raycast>` 进行更新。 然后我们检查 :ref:`Raycast <class_Raycast>` 是否"
"与某些东西发生碰撞。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:560
#, fuzzy
msgid ""
"If the :ref:`Raycast <class_Raycast>` is colliding with something, we then "
"check to see if what it is colliding with is a :ref:`RigidBody "
"<class_RigidBody>`, and that it does not have a variable called "
"``NO_PICKUP``. If the :ref:`Raycast <class_Raycast>` is colliding with a :"
"ref:`RigidBody <class_RigidBody>`, and it does not have a variable called "
"``NO_PICKUP``, we assign it to ``rigid_body`` for additional processing."
msgstr ""
"如果 :ref:`Raycast <class_Raycast>` 与某些内容发生冲突，我们检查是否发生冲突"
"的是 :ref:`RigidBody <class_RigidBody>`，并且它没有一个名为 ``NO_PICKUP的变量"
"`` 。 如果 :ref:`Raycast <class_Raycast>` 与 :ref:`RigidBody "
"<class_RigidBody>` 冲突，并且它没有一个名为 ``NO_PICKUP`` 的变量，我们将它分"
"配给 ``rigid_body`` 以获得额外的处理。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:564
#, fuzzy
msgid ""
"If ``rigid_body`` is not ``null``, meaning we found a :ref:`RigidBody "
"<class_RigidBody>` in the grab :ref:`Area <class_Area>`, we assign "
"``held_object`` to it. Then we store the now held :ref:`RigidBody "
"<class_RigidBody>`'s information in ``held_object_data``. We are storing "
"the :ref:`RigidBody <class_RigidBody>` mode, layer, and mask so later, when "
"we drop it, we can reset all those variables back to what they were before "
"we picked up the :ref:`RigidBody <class_RigidBody>`."
msgstr ""
"如果 ``rigid_body`` 不是 ``null`` ，意味着我们在grab :ref:`Area "
"<class_Area>` 中找到了一个 :ref:`RigidBody <class_RigidBody>`，我们给它分配"
"了 ``held_object`` 。 然后我们在 ``held_object_data`` 中存储现在持有的 :ref:"
"`RigidBody <class_RigidBody>的信息。 我们正在存储 :ref:`RigidBody "
"<class_RigidBody>` 模式，图层和掩码，所以稍后当我们删除它时，我们可以将所有这"
"些变量重置回原来的状态 :ref:`RigidBody <class_RigidBody>`。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:568
msgid ""
"We then set the held object's :ref:`RigidBody <class_RigidBody>` mode to "
"``MODE_STATIC`` and set the collision layer and mask to 0 so it cannot "
"collide with any other physic bodies."
msgstr ""
"然后我们将保持对象的 :ref:`RigidBody <class_RigidBody>` 模式设置为 "
"``MODE_STATIC`` 并将碰撞层和掩码设置为0，这样它就不会与任何其他物理机构发生碰"
"撞。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:571
msgid ""
"We make the hand mesh invisible so it does not get in the way of the object "
"we are holding (and also because I did not feel like animating the hand). We "
"also make the grab :ref:`Raycast <class_Raycast>` invisible so the mesh used "
"for showing the :ref:`Raycast <class_Raycast>` is no longer visible."
msgstr ""
"我们使手网不可见，因此它不会妨碍我们持有的对象(也因为我不喜欢动画手)。 我们也"
"使得 :ref:`Raycast <class_Raycast>` 看不见，因此用于显示 :ref:`Raycast "
"<class_Raycast>` 的网格不再可见。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:574
msgid ""
"If the :ref:`RigidBody <class_RigidBody>` we picked up has the ``picked_up`` "
"method/function, we call it. If the :ref:`RigidBody <class_RigidBody>` we "
"picked up has a variable called ``controller``, we set it to this controller."
msgstr ""
"如果我们选择的 :ref:`RigidBody <class_RigidBody>` 有 ``picked_up`` 方法/函"
"数，我们称之为。 如果 :ref:`RigidBody <class_RigidBody>` 我们选择了一个名为 "
"``controller`` 的变量，我们将它设置为该控制器。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:577
#, fuzzy
msgid ""
"If the controller is not holding an object, and the button pressed is 2, we "
"want to drop/throw the held object."
msgstr ""
"如果控制器没有持有一个对象，并且按下的按钮是2，我们想要删除/抛出被保持的对"
"象。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:579
#, fuzzy
msgid ""
"Firstly, we set the held :ref:`RigidBody <class_RigidBody>`'s mode, layer, "
"and mask back to what they were when we picked the object up. We then apply "
"an impulse to the held object, using the controller's velocity as the force."
msgstr ""
"首先，我们将hold :ref:`RigidBody <class_RigidBody>的模式，图层和蒙版设置回我"
"们拾取对象时的状态。 然后，我们使用控制器的速度作为力，对保持的对象施加脉冲。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:582
#, fuzzy
msgid ""
"If the previously held :ref:`RigidBody <class_RigidBody>` has a function "
"called ``dropped``, we call it. If the :ref:`RigidBody <class_RigidBody>` "
"has a variable called ``controller``, we set it to ``null``."
msgstr ""
"如果以前持有的 :ref:`RigidBody <class_RigidBody>` 有一个名为 ``dropped`` 的函"
"数，我们称之为。 如果 :ref:`RigidBody <class_RigidBody>` 有一个名为 "
"``controller`` 的变量，我们将它设置为 ``null`` 。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:585
#, fuzzy
msgid ""
"Then, we set ``held_object`` to ``null``, since we are no longer holding any "
"objects, and we make the hand mesh visible again."
msgstr ""
"然后我们将 ``held_object`` 设置为 ``null`` ，因为我们不再持有任何对象，我们再"
"次使手网可见。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:587
msgid ""
"If we are using the ``RAYCAST`` grab mode, we make the :ref:`Raycast "
"<class_Raycast>` visible so we can see the mesh used for showing the grab :"
"ref:`Raycast <class_Raycast>`."
msgstr ""
"如果我们使用 ``RAYCAST`` 抓取模式，我们将 :ref:`Raycast <class_Raycast>` 显示"
"为可见，这样我们就可以看到用于显示抓取的网格 :ref:`Raycast <class_Raycast>`。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:589
#, fuzzy
msgid ""
"Finally, regardless of whether we are grabbing an object or releasing it, we "
"play the sound loaded into ``AudioStreamPlayer3D``, which is a pick-up/drop "
"noise."
msgstr ""
"最后，无论我们是抓取对象还是释放它，我们都会播放加载到“AudioStreamPlayer3D”中"
"的声音，这是一种拾取/丢弃噪声。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:591
#, fuzzy
msgid ""
"The last thing we are doing in ``button_pressed`` is checking to see if the "
"button pressed is 1, which, for the Windows Mixed Reality controllers, is "
"the menu button."
msgstr ""
"我们在 ``button_pressed`` 中做的最后一件事是检查按下的按钮是否为1，对于"
"Windows Mixed Reality控制器是菜单按钮。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:593
msgid ""
"If the menu button is pressed, we change grab modes, and set the visibility "
"of the grab :ref:`Raycast <class_Raycast>` so it is only visible when using "
"``RAYCAST`` as the grab mode."
msgstr ""
"如果按下菜单按钮，我们更改抓取模式，并设置抓取的可见性 :ref:`Raycast "
"<class_Raycast>` 所以只有在使用 ``RAYCAST`` 作为抓取模式时才能看到它。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:597
msgid "Let's look at ``button_released`` next."
msgstr "我们接下来看看 ``button_released`` 。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:599
msgid ""
"If the button released is button 15, the trigger, then we potentially want "
"to teleport."
msgstr "如果释放的按钮是按钮15，触发器，那么我们可能想要传送。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:601
#, fuzzy
msgid ""
"Firstly, we check to see whether ``teleport_button_down`` is ``true``. If it "
"is, that means the player is intending to teleport, while if it is "
"``false``, the player has released the trigger while holding an object."
msgstr ""
"首先，我们检查 ``teleport_button_down`` 是否为 ``true`` 。 如果是，那意味着游"
"戏角色打算传送，而如果它是“假”，游戏角色只需在拿着一个物体时释放扳机。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:604
msgid ""
"We then check to see if this controller has a teleport position, and we "
"check to make sure the teleport mesh is visible."
msgstr "然后我们检查该控制器是否具有传送位置，我们检查以确保传送网格可见。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:606
msgid ""
"If both of those conditions are ``true``, we then calculate the offset the :"
"ref:`ARVRCamera <class_ARVRCamera>` has from the :ref:`ARVROrigin "
"<class_ARVROrigin>`. We do this because of how :ref:`ARVRCamera "
"<class_ARVRCamera>` and :ref:`ARVROrigin <class_ARVROrigin>` work with room-"
"scale tracking."
msgstr ""
"如果这两个条件都是 ``true`` ，那么我们计算偏移 :ref:`ARVRCamera "
"<class_ARVRCamera>` 来自 :ref:`ARVROrigin <class_ARVROrigin>`。 我们这样做是"
"因为 :ref:`ARVRCamera <class_ARVRCamera>` 和 :ref:`ARVROrigin "
"<class_ARVROrigin>` 使用房间尺度跟踪。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:609
#, fuzzy
msgid ""
"Because we want to teleport the player in their current position to the "
"teleport position, and remember, because of room-scale tracking, their "
"current position can be offset from the origin, we have to figure out that "
"offset so when we teleport, we can remove it so that player's current "
"position is teleported to the teleport position."
msgstr ""
"因为我们想将当前位置的游戏角色传送到传送位置，并且因为房间尺度跟踪而记住它们"
"的当前位置可能偏离原点，我们必须弄清楚偏移，所以当我们传送时我们可以删除它 该"
"球员的当前位置被传送到传送位置。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:612
msgid ""
"We set the Y value of the camera_offset to zero because we do not want to "
"account for offsets in the player's height."
msgstr ""
"我们将camera_offset的Y值设置为零，因为我们不想考虑游戏角色身高的偏移量。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:614
#, fuzzy
msgid ""
"Then, we teleport the :ref:`ARVROrigin <class_ARVROrigin>` to the teleport "
"position, applying the camera offset."
msgstr ""
"然后我们将 :ref:`ARVROrigin <class_ARVROrigin>` 传送到传送位置，应用相机偏"
"移。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:616
#, fuzzy
msgid ""
"Regardless of whether we teleported or not, we reset all the teleport-"
"related variables so the controller has to get new ones before teleporting "
"again."
msgstr ""
"无论我们是否传送，我们都会重置所有与传送相关的变量，以便控制器必须在再次传送"
"之前获得新的变量。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:620
msgid ""
"Finally, let's look at ``sleep_area_entered`` and ``sleep_area_exited``."
msgstr "最后，让我们看一下 ``sleep_area_entered`` 和``sleep_area_exited``。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:622
#, fuzzy
msgid ""
"When a body enters or exists the sleep area, we check whether it has a "
"variable called ``can_sleep``. If it does, we then set it to ``false`` and "
"wake the body if it has entered the sleep area, while if it has exited, we "
"set it to ``true`` so the :ref:`RigidBody <class_RigidBody>` nodes can sleep "
"(which can decrease CPU usage)."
msgstr ""
"当物体进入或存在睡眠区域时，我们检查它是否有一个名为“can_sleep”的变量。 如果"
"确实如此，我们将其设置为“false”并在物体进入睡眠区域时唤醒物体，如果已经退出，"
"我们将其设置为“真实”，以便 :ref:`RigidBody <class_RigidBody> `节点可以睡眠(可"
"以降低CPU使用率)。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:627
#, fuzzy
msgid ""
"Okay, whew! That was a lot of code! Add the same script, ``VR_Controller."
"gd`` to the other controller so both controllers have the same script."
msgstr ""
"好的，p！ 那是很多代码！ 将相同的脚本 ``VR_Controller.gd`` 添加到另一个控制"
"器，以便两个控制器具有相同的脚本。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:629
msgid ""
"Now go ahead and try the game again, and you should find you can teleport "
"around by pressing the touch pad, and can grab and throw objects using the "
"grab/grip buttons."
msgstr ""
"现在再继续尝试游戏，您会发现您可以通过按下触摸板来传送，并且可以使用抓握/抓握"
"按钮抓住并扔掉物体。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:632
msgid ""
"Now, you may want to try moving using the trackpads and/or joysticks, but "
"**it may make you motion sick!**"
msgstr ""
"现在，您可能想尝试使用触控板和/或操纵杆移动，但**它可能会让您运动生病！**"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:634
msgid ""
"One of the main reasons this can make you feel motion sick is because your "
"vision tells you that you are moving, while your body is not moving. This "
"conflict of signals makes the body feel sick, so let's fix it!"
msgstr ""
"这可能让您感到晕车的主要原因之一是因为您的视力告诉您，您的物体不动，您正在移"
"动。 这种信号冲突使物体感到恶心，所以让我们解决它！"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:638
msgid "Reducing motion sickness"
msgstr "减少晕动病"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:640
msgid ""
"There are plenty of ways to reduce motion sickness in VR, and there is no "
"one perfect way to reduce motion sickness. See `this page on the Oculus "
"Developer Center <https://developer.oculus.com/design/latest/concepts/bp-"
"locomotion/>`_ for more information on how to implement locomotion and "
"reducing motion sickness."
msgstr ""
"有很多方法可以减少VR中的晕动病，并且没有一种方法可以减少晕动病。 有关如何实施"
"运动和减少晕动病的更多信息，请参阅Oculus开发人员中心的 `这个页面 <https://"
"developer.oculus.com/design/latest/concepts/bp-locomotion/>`_ 。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:644
msgid ""
"To help reduce motion sickness while moving, we are going to add a vignette "
"effect that will only be visible while the player moves."
msgstr ""
"为了帮助减少移动时的晕车，我们将添加一个只有在游戏角色移动时才能看到的晕影效"
"果。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:646
msgid ""
"Open up ``Movement_Vignette.tscn``, which you can find in the ``Scenes`` "
"folder. Notice how it is just a :ref:`ColorRect <class_ColorRect>` node with "
"a custom shader. Feel free to look at the custom shader if you want, it is "
"just a slightly modified version of the vignette shader you can find in the "
"Godot demo repository."
msgstr ""
"打开 ``Movement_Vignette.tscn`` ，您可以在 ``Scenes`` 文件夹中找到它。 注意它"
"只是一个 :ref:`ColorRect <class_ColorRect>` 带有自定义着色器的节点。 如果需"
"要，可以随意查看自定义着色器，它只是您可以在Godot演示库中找到的晕影着色器的略"
"微修改版本。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:649
msgid ""
"With ``Movement_Vignette`` selected, make a new script called "
"``Movement_Vignette.gd``. Add the following code to ``Movement_Vignette.gd``:"
msgstr ""
"选择 ``Movement_Vignette`` 后，创建一个名为 ``Movement_Vignette.gd`` 的新脚"
"本。 将以下代码添加到``Movement_Vignette.gd``:"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:686
#, fuzzy
msgid ""
"Because this script is fairly brief, let's quickly go over what it does."
msgstr "因为这个脚本非常简单，所以让我们快速回顾它的作用。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:688
msgid ""
"In ``_ready``, we wait for four frames. We do this to ensure the VR "
"interface is ready and going."
msgstr "在 ``_ready`` 中，我们等待四帧。 我们这样做是为了确保VR界面准备就绪。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:690
msgid ""
"Next, we get the current VR interface, and resize the :ref:`ColorRect "
"<class_ColorRect>` node's size and position so that it covers the entire "
"view in VR."
msgstr ""
"接下来，我们获取当前的VR界面，并调整 :ref:`ColorRect <class_ColorRect>` 节点"
"的大小和位置，以便它覆盖VR中的整个视图。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:692
#, fuzzy
msgid ""
"Then, we get the left and right controllers, assigning them to "
"``controller_one`` and ``controller_two``."
msgstr ""
"然后我们得到左右控制器，将它们分配给 ``controller_one`` 和"
"``controller_two``。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:694
msgid "We then make the vignette invisible by default."
msgstr "然后，我们默认情况下使小插图不可见。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:696
msgid ""
"In ``_process``, we check to see if either of the controllers are moving the "
"player by checking ``directional_movement``. If either controller is moving "
"the player, we make the vignette visible, while if neither controller is "
"moving the player, we make the vignette invisible."
msgstr ""
"在 ``_process`` 中，我们通过检查 ``directional_movement`` 来检查其中一个控制"
"器是否正在移动游戏角色。 如果任一控制器正在移动游戏角色，我们使小插图可见，而"
"如果两个控制器都没有移动游戏角色，我们使小插图不可见。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:701
msgid ""
"With that done, go ahead and try moving around with the joystick and/or the "
"trackpad. You should find it is much less motion sickness-inducing than "
"before!"
msgstr ""
"完成后，继续尝试使用操纵杆和/或触控板。 您应该会发现它比以前少了晕动病！"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:703
msgid ""
"Let's add some special :ref:`RigidBody <class_RigidBody>` nodes we can "
"interact with next."
msgstr ""
"让我们添加一些特殊的 :ref:`RigidBody <class_RigidBody>` 我们可以与下一个交互"
"的节点。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:706
msgid "Adding destroyable targets"
msgstr "添加可销毁的目标"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:708
#, fuzzy
msgid ""
"Firstly, let's start by making some targets we will destroy in various ways "
"with various special :ref:`RigidBody <class_RigidBody>` nodes."
msgstr ""
"首先，让我们从制作一些目标开始，我们将以各种不同的方式销毁各种不同的特殊目"
"标 :ref:`RigidBody <class_RigidBody>` 节点。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:710
msgid ""
"Open up ``Sphere_Target.tscn``, which you can find in the ``Scenes`` folder. "
"``Sphere.tscn`` is just a :ref:`StaticBody <class_StaticBody>` with a :ref:"
"`CollisionShape <class_CollisionShape>`, a mesh, and a audio player."
msgstr ""
"打开 ``Sphere_Target.tscn`` ，您可以在 ``Scenes`` 文件夹中找到它。 ``Sphere."
"tscn``只是一个 :ref:`StaticBody <class_StaticBody>` 带有 :ref:"
"`CollisionShape <class_CollisionShape>`，一个网格和一个音频播放器。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:713
msgid ""
"Select the ``Sphere_Target`` root node, the :ref:`StaticBody "
"<class_StaticBody>` node, and make a new script called ``Sphere_Target.gd``. "
"Add the following to ``Sphere_Target.gd``:"
msgstr ""
"选择 ``Sphere_Target`` 根节点， :ref:`StaticBody <class_StaticBody>` 节点，并"
"创建一个名为 ``Sphere_Target.gd`` 的新脚本。 将以下内容添加到``Sphere_Target."
"gd``:"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:760
msgid "Let's go over how this script works, starting with the class variables."
msgstr "让我们来看看这个脚本的工作原理，从类变量开始。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:762
#, fuzzy
msgid ""
"``destroyed``: A variable to track whether this target is destroyed or not."
msgstr "``destroyed``:一个变量，用于跟踪此目标是否被销毁。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:763
msgid ""
"``destroyed_timer``: A variable to track how long the target has been "
"destroyed."
msgstr "``destroyed_timer``:一个跟踪目标被摧毁多久的变量。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:764
msgid ""
"``DESTROY_WAIT_TIME``: A constant to tell the sphere target how long to wait "
"before destroying/deleting itself."
msgstr ""
"``DESTROY_WAIT_TIME``:一个常数，用于告诉球体目标在销毁/删除自身之前需要等待多"
"长时间。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:765
msgid "``health``: The amount of health the target has."
msgstr "``health``:目标所具有的健康量。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:766
msgid ""
"``RIGID_BODY_TARGET``: The target broken into several smaller :ref:"
"`RigidBody <class_RigidBody>` nodes."
msgstr ""
"``RIGID_BODY_TARGET``:目标分成几个较小的 :ref:`RigidBody <class_RigidBody>` "
"节点。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:770
#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:912
msgid "Let's go over ``_ready``."
msgstr "让我们回顾一下 ``_ready`` 。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:772
msgid ""
"All we are doing in ``_ready`` is setting ``_physics_process`` to ``false``. "
"This is because we will only use ``_physics_process`` for destroying the "
"target, so we do not want to call it until the target is broken."
msgstr ""
"我们在 ``_ready`` 中所做的就是将 ``_physics_process`` 设置为 ``false`` 。 这"
"是因为我们只使用 ``_physics_process`` 来销毁目标，所以我们不想在目标被破坏之"
"前调用它。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:777
msgid "Next, let's go over ``_physics_process``."
msgstr "接下来，让我们回顾一下 ``_physics_process`` 。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:779
#, fuzzy
msgid ""
"Firstly, we add time to ``destroyed_timer``. Then we check to see whether "
"enough time has passed and we can destroy the target. If enough time has "
"passed, we free/destroy the target using ``queue_free``."
msgstr ""
"首先，我们为 ``destroyed_timer`` 增加时间。 然后我们检查是否已经过了足够的时"
"间，我们可以摧毁目标。 如果已经过了足够的时间，我们使用 ``queue_free`` 释放/"
"销毁目标。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:784
msgid "Finally, let's go over ``damage``."
msgstr "最后，让我们回顾一下 ``damage`` 。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:786
#, fuzzy
msgid ""
"Firstly, we check to make sure the target has not already been destroyed."
msgstr "首先，我们检查以确保目标尚未被销毁。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:788
msgid ""
"Then, we remove however much damage the target has taken from the target's "
"health."
msgstr "然后，我们移除了目标从目标生命值中获得的大量伤害。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:790
msgid ""
"If the target has zero or less health, then it has taken enough damage to "
"break."
msgstr "如果目标的生命值为零或更低，则它已经受到足够的破坏。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:792
#, fuzzy
msgid ""
"Firstly, we disable the collision shape and make the whole target mesh "
"invisible. Next, we spawn/instance the :ref:`RigidBody <class_RigidBody>` "
"version of the target, and instance it at this target's position."
msgstr ""
"首先，我们禁用碰撞形状并使整个目标网格不可见。 接下来，我们生成/实例 :ref:"
"`RigidBody <class_RigidBody>` 目标版本，并在此目标位置实例化它。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:795
#, fuzzy
msgid ""
"Then, we set ``destroyed`` to ``true`` and start processing "
"``_physics_process``. Finally, we play a sound, and remove a sphere from "
"``Game.gd`` by calling ``remove_sphere``."
msgstr ""
"然后我们将 ``destroyed`` 设置为 ``true`` 并开始处理 ``_physics_process`` 。 "
"最后，我们播放声音，并通过调用“remove_sphere”来从“Game.gd”中删除一个球体。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:800
msgid ""
"Now, you may have noticed we are calling a function in ``Game.gd`` we have "
"not made yet, so let's fix that!"
msgstr ""
"现在，您可能已经注意到我们正在调用我们尚未制作的“Game.gd”中的函数，所以让我们"
"解决这个问题！"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:802
#, fuzzy
msgid ""
"Firstly, open up ``Game.gd`` and add the following additional class "
"variables:"
msgstr "首先，打开 ``Game.gd`` 并添加以下附加类变量:"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:810
msgid "``spheres_left``: The amount of sphere targets left in the game world."
msgstr "``spheres_left``:游戏世界中留下的球体目标数量。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:811
msgid "``sphere_ui``: A reference to the sphere UI. We will use this later!"
msgstr "``sphere_ui``:对球体UI的引用。 我们稍后会用到这个！"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:813
msgid ""
"Next, we need to add the ``remove_sphere`` function. Add the following to "
"``Game.gd``:"
msgstr ""
"接下来，我们需要添加 ``remove_sphere`` 函数。 将以下内容添加到``Game.gd``:"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:824
#, fuzzy
msgid "What this function does is it subtracts one from ``spheres_left``."
msgstr "这个函数的作用是从 ``spheres_left`` 中删除一个。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:826
#, fuzzy
msgid ""
"Then, it checks to see whether ``sphere_ui`` is not null, and if it is not, "
"then it calls its ``update_ui`` function, passing in the amount of spheres "
"left. We'll add the UI code later in this part."
msgstr ""
"然后它检查 ``sphere_ui`` 是否为空，如果不是，则调用它的 ``update_ui`` 函数，"
"传入球的左边数量。 我们将在本部分后面添加UI代码。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:829
msgid "Now that we have destroyable targets, we need a way to destroy them!"
msgstr "既然我们有可销毁的目标，我们需要一种方法来摧毁它们！"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:832
msgid "Adding a pistol"
msgstr "加一把手枪"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:834
#, fuzzy
msgid ""
"Okay, let's add a pistol. Open up ``Pistol.tscn``, which you will find in "
"the ``Scenes`` folder."
msgstr ""
"好的，让我们添加一把简单的手枪。 打开 ``Pistol.tscn`` ，您可以在 ``Scenes`` "
"文件夹中找到它。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:836
#, fuzzy
msgid ""
"There are a few things to note here. The first thing to note is how "
"everything is rotated. This is to make the pistol rotate correctly when the "
"player grabs it. The other thing to notice is how there is a laser sight "
"mesh, and a flash mesh; both of these do what you'd expect: act as a laser "
"pointer and muzzle flash, respectively."
msgstr ""
"这里有几点需要注意。 首先要注意的是如何旋转一切。 这是为了让游戏角色在抓住手"
"枪时正确旋转。 另外需要注意的是激光瞄准网和闪光网是如何做到的，它们都可以达到"
"您的期望:充当激光指针并分别充当枪口闪光灯。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:839
msgid ""
"The other thing to notice is how there is a :ref:`Raycast <class_Raycast>` "
"node at the end of the pistol. This is what we will be using to calculate "
"where the bullets impact."
msgstr ""
"另一件需要注意的事情是手枪末端有一个 :ref:`Raycast <class_Raycast>` 节点。 这"
"是我们将用于计算子弹影响的位置。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:841
msgid ""
"Now that we have looked at the scene, let's write the code. Select the "
"``Pistol`` root node, the :ref:`RigidBody <class_RigidBody>` node, and make "
"a new script called ``Pistol.gd``. Add the following code to ``Pistol.gd``:"
msgstr ""
"现在我们已经查看了场景，让我们编写代码。 选择 ``Pistol`` 根节点， :ref:"
"`RigidBody <class_RigidBody>` 节点，并创建一个名为 ``Pistol.gd`` 的新脚本。 "
"将以下代码添加到``Pistol.gd``:"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:901
msgid "Let's go over what this script does, starting with the class variables:"
msgstr "让我们回顾一下这个脚本的作用，从类变量开始:"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:903
msgid "``flash_mesh``: The mesh used to make the muzzle flash."
msgstr "``flash_mesh``:用于使枪口闪光的网格。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:904
msgid "``FLASH_TIME``: The length of time the muzzle flash is visible."
msgstr "``FLASH_TIME``:枪口闪光可见的时间长度。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:905
msgid ""
"``flash_timer``: A variable to track how long the muzzle flash has been "
"visible."
msgstr "``flash_timer``:一个跟踪枪口闪光可见时间的变量。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:906
msgid "``laser_sight_mesh``: A long rectangular mesh used for the laser sight."
msgstr "``laser_sight_mesh``:用于激光瞄准器的长矩形网格。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:907
msgid "``raycast``: The raycast node used for the pistol firing."
msgstr "``raycast``:用于手枪射击的射线播放节点。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:908
msgid "``BULLET_DAMAGE``: The amount of damage a single bullet does."
msgstr "``BULLET_DAMAGE``:单个子弹造成的伤害量。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:914
msgid ""
"All we are doing here is getting the nodes and assigning them to the proper "
"variables. We also make sure the flash and laser sight meshes are invisible."
msgstr ""
"我们在这里所做的就是获取节点并将它们分配给适当的变量。 我们还确保闪光灯和激光"
"瞄准网不可见。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:919
msgid "Next, let's look at ``_physics_process``."
msgstr "接下来，让我们看看`_physics_process``。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:921
#, fuzzy
msgid ""
"Firstly, we check to see if the flash is visible. We do this by checking to "
"see if ``flash_timer`` is more than zero. This is because ``flash_timer`` "
"will be an inverted timer, a timer that counts down instead of counting up."
msgstr ""
"首先，我们检查闪光灯是否可见。 我们通过检查 ``flash_timer`` 是否大于零来做到"
"这一点。 这是因为 ``flash_timer`` 将是一个倒置计时器，一个计时器倒计时而不是"
"计数。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:924
#, fuzzy
msgid ""
"If ``flash_timer`` is more than zero, we subtract ``delta`` from it and "
"check to see whether it is equal to zero or less. If it is, we make the "
"flash mesh invisible."
msgstr ""
"如果 ``flash_timer`` 大于零，我们从中删除 ``delta`` 并检查它是否等于零或更"
"小。 如果是，我们使闪光网不可见。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:927
#, fuzzy
msgid ""
"This makes it where the flash mesh becomes invisible after ``FLASH_TIME`` "
"many seconds have gone by."
msgstr "这使得闪存网格在“FLASH_TIME”经过许多秒后变得不可见。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:931
#, fuzzy
msgid ""
"Now, let's look at ``interact``, which is called when the trigger button on "
"the VR controller is pressed and the pistol is being held."
msgstr ""
"现在让我们看一下 ``interact`` ，当按下VR控制器上的触发按钮并握住手枪时调用"
"它。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:933
#, fuzzy
msgid ""
"Firstly, we check to see if the flash timer is less than or equal to zero. "
"This check makes it where we cannot fire when the flash is visible, limiting "
"how often the pistol can fire."
msgstr ""
"首先，我们检查闪光定时器是否小于或等于零。 当闪光灯可见时，这个检查使我们无法"
"开火，限制了手枪射击的频率。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:936
msgid ""
"If we can fire, we reset ``flash_timer`` by setting it to ``FLASH_TIME``, "
"and we make the flash mesh visible."
msgstr ""
"如果我们可以触发，我们通过将它设置为“FLASH_TIME”来重置 ``flash_timer`` ，并且"
"我们使flash网格可见。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:938
msgid ""
"We then update the :ref:`Raycast <class_Raycast>` and check to see if it is "
"colliding with anything."
msgstr ""
"然后我们更新 :ref:`Raycast <class_Raycast>` 并检查它是否与任何东西发生碰撞。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:940
#, fuzzy
msgid ""
"If the :ref:`Raycast <class_Raycast>` is colliding with something, we get "
"the collider. We check to see if the collider has the ``damage`` function, "
"and if it does, we call it. If it does not, we then check to see if the "
"collider has the ``apply_impulse`` function, and if it does, we call it "
"after calculating the direction from the :ref:`Raycast <class_Raycast>` to "
"the collider."
msgstr ""
"如果 :ref:`Raycast <class_Raycast>` 与某些东西发生碰撞，我们就会得到对撞机。 "
"我们检查对撞机是否有“损坏”功能，如果有，我们称之为。 如果没有，我们检查对撞机"
"是否具有 ``apply_impulse`` 函数，如果有，我们在计算从 :ref:`Raycast "
"<class_Raycast>` 到对撞机的方向后调用它。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:944
msgid ""
"Finally, regardless of whether the pistol hit something or not, we play the "
"pistol firing sound."
msgstr "最后，无论手枪是否击中，我们都会发出手枪发出的声音。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:948
#, fuzzy
msgid ""
"Finally, let's look at ``picked_up`` and ``dropped``, which are called when "
"the pistol is picked up and dropped, respectively."
msgstr ""
"最后，让我们看一下 ``picked_up`` 和``dropped``，它们分别在拾取和放下手枪时被"
"调用。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:950
msgid ""
"All we are doing in these functions is making the laser pointer visible when "
"the pistol is picked up, and making it invisible when the pistol is dropped."
msgstr ""
"我们在这些功能中所做的就是在拿起手枪时使激光指示器可见，并在手枪掉落时使其不"
"可见。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:956
msgid ""
"With that done, go ahead and give the game a try! If you climb up the stairs "
"and grab the pistols, you should be able to fire at the spheres and they "
"will break!"
msgstr ""
"完成后，继续尝试游戏吧！ 如果您爬上楼梯并抓住手枪，您应该能够在球体上射击并且"
"它们会破裂！"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:959
msgid "Adding a shotgun"
msgstr "添加霰弹枪"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:961
#, fuzzy
msgid ""
"Let's add a different type of weapon :ref:`RigidBody <class_RigidBody>`: a "
"shotgun. This is fairly straightforward, as almost everything is the same as "
"the pistol."
msgstr ""
"让我们添加一种不同类型的射击 :ref:`RigidBody <class_RigidBody>`:霰弹枪。 这很"
"简单，几乎所有东西都和手枪一样。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:963
msgid ""
"Open up ``Shotgun.tscn``, which you can find in ``Scenes``. Notice how "
"everything is more or less the same, but instead of a single :ref:`Raycast "
"<class_Raycast>`, there are five, and there is no laser pointer. This is "
"because a shotgun generally fires in a cone shape, and so we are going to "
"emulate that by having several :ref:`Raycast <class_Raycast>` nodes, all "
"rotated randomly in a cone shape, and I removed the laser pointer so the "
"player has to aim without knowing for sure where the shotgun is pointing."
msgstr ""
"打开 ``Shotgun.tscn`` ，您可以在 ``Scenes`` 找到它。 注意一切都或多或少相同，"
"但不是一个 :ref:`Raycast <class_Raycast>`，有五个，没有激光指针。 这是因为霰"
"弹枪通常以锥形形状发射，因此我们将通过几个 :ref:`Raycast <class_Raycast>` 节"
"点模拟它们，所有节点都以锥形随机旋转，然后我移除了激光指示器 游戏角色必须瞄准"
"而不确定霰弹枪指向的位置。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:968
msgid ""
"Alright, select the ``Shotgun`` root node, the :ref:`RigidBody "
"<class_RigidBody>` and make a new script called ``Shotgun.gd``. Add the "
"following to ``Shotgun.gd``:"
msgstr ""
"好吧，选择 ``Shotgun`` 根节点， :ref:`RigidBody <class_RigidBody>` 并创建一个"
"名为 ``Shotgun.gd`` 的新脚本。 将以下内容添加到``Shotgun.gd``:"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1027
msgid ""
"You may have noticed this is almost exactly the same as the pistol, and "
"indeed it is, so let's only go over what has changed."
msgstr ""
"您可能已经注意到这几乎与手枪完全一样，事实上它也是如此，所以让我们只看看已经"
"改变的东西。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1029
msgid ""
"``raycasts``: The node that holds all of the five :ref:`Raycast "
"<class_Raycast>` nodes used for the shotgun's firing."
msgstr ""
"``raycasts``:包含所有五个节点的节点 :ref:`Raycast <class_Raycast>` 用于霰弹枪"
"射击的节点。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1031
msgid ""
"In ``_ready``, we get the ``Raycasts`` node, instead of just a single :ref:"
"`Raycast <class_Raycast>`."
msgstr ""
"在 ``_ready`` 中，我们得到 ``Raycasts`` 节点，而不只是一个 :ref:`Raycast "
"<class_Raycast>`。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1033
#, fuzzy
msgid ""
"The only other change, besides there being nothing in ``picked_up`` and "
"``dropped``, is in ``interact``."
msgstr ""
"除了在 ``picked_up`` 和``dropped``中没有任何内容之外，唯一的另一个变化是 "
"``interact`` 。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1035
#, fuzzy
msgid ""
"Now we go through each :ref:`Raycast <class_Raycast>` in ``raycasts``. We "
"then rotate it on the X and Z axes, making within a 10 to ``-10`` cone. From "
"there, we process each :ref:`Raycast <class_Raycast>` like we did the "
"single :ref:`Raycast <class_Raycast>` in the pistol, nothing changed at all, "
"we are just doing it five times, once for each :ref:`Raycast "
"<class_Raycast>` in ``raycasts``."
msgstr ""
"现在我们通过每个 :ref:``Raycast <class_Raycast>` 在 ``raycasts`` 中。 然后我"
"们在X轴和Z轴上旋转它，在10到“-10”锥形范围内。 从那里开始，我们处理每个 :ref:"
"`Raycast <class_Raycast>` 就像我们做的那样 :ref:`Raycast <class_Raycast>` 在"
"手枪中，没有任何改变，我们只是做了五次，每次一次 :ref:``raycasts`` 中的"
"`Raycast <class_Raycast>` 。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1041
msgid ""
"Now you can find and fire the shotgun too! The shotgun is located around the "
"back behind one of the walls (not in the building though!)."
msgstr ""
"现在您也可以找到并发射霰弹枪！ 霰弹枪位于其中一个墙后面的后面(虽然不在建筑物"
"中！)。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1044
msgid "Adding a bomb"
msgstr "添加炸弹"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1046
msgid ""
"While both of those are well and good, let's add something we can throw next "
"— a bomb!"
msgstr "虽然这两个都很好，但我们可以添加一些我们可以抛出的东西 - 炸弹！"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1048
msgid "Open up ``Bomb.tscn``, which you will find in the ``Scenes`` folder."
msgstr "打开 ``Bomb.tscn`` ，您可以在 ``Scenes`` 文件夹中找到它。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1050
msgid ""
"First, notice how there is a rather large :ref:`Area <class_Area>` node. "
"This is the explosion radius for the bomb. Anything within this :ref:`Area "
"<class_Area>` will be effected by the explosion when the bomb explodes."
msgstr ""
"首先，注意有一个相当大的 :ref:`Area <class_Area>` 节点。 这是炸弹的爆炸半"
"径。 其中的任何内容 :ref:`Area <class_Area>` 将在炸弹爆炸时受到爆炸的影响。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1053
msgid ""
"The other thing to note is how there are two sets of :ref:`Particles "
"<class_Particles>`: one for smoke coming out of the fuse, and another for "
"the explosion itself. Feel free to take a look at the :ref:`Particles "
"<class_Particles>` nodes if you want!"
msgstr ""
"另外需要注意的是如何有两组 :ref:`Particles <class_Particles>`:一个用于从保险"
"丝中出来的烟雾，另一个用于爆炸本身。 如果需要，请随意查看 :ref:`Particles "
"<class_Particles>` 节点！"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1056
#, fuzzy
msgid ""
"The only thing to notice is how long the explosion :ref:`Particles "
"<class_Particles>` node will last, their lifetime, which is 0.75 seconds. We "
"need to know this so we can time the removal of the bomb with the end of the "
"explosion :ref:`Particles <class_Particles>`."
msgstr ""
"唯一需要注意的是他的爆炸时间 :ref:`Particles <class_Particles>` 节点将持续，"
"它们的生命周期为0.75秒。 我们需要知道这一点，所以我们可以在爆炸结束时抽出炸弹"
"的时间 :ref:`Particles <class_Particles>`。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1059
msgid ""
"Alright, now let's write the code for the bomb. Select the ``Bomb`` :ref:"
"`RigidBody <class_RigidBody>` node and make a new script called ``Bomb.gd``. "
"Add the following code to ``Bomb.gd``:"
msgstr ""
"好的，现在让我们写下炸弹的代码。 选择``Bomb`` :ref:`RigidBody "
"<class_RigidBody>` 节点并创建一个名为 ``Bomb.gd`` 的新脚本。 将以下代码添加到"
"``Bomb.gd``:"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1143
msgid ""
"Let's go through what this script does, starting with the class variables:"
msgstr "让我们来看看这个脚本的作用，从类变量开始:"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1145
msgid ""
"``bomb_mesh``: The :ref:`MeshInstance <class_MeshInstance>` used for the "
"bomb mesh."
msgstr ""
"``bomb_mesh``:用于炸弹网格的 :ref:`MeshInstance <class_MeshInstance>` 。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1146
#, fuzzy
msgid "``FUSE_TIME``: The length of time for which the fuse burns."
msgstr "``FUSE_TIME``:保险丝燃烧的时间长度。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1147
msgid ""
"``fuse_timer``: A variable for tracking how long the fuse has been burning."
msgstr "``fuse_timer``:用于跟踪保险丝燃烧时间的变量。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1148
msgid ""
"``explosion_area``: The :ref:`Area <class_Area>` node used for detecting "
"what nodes are inside the explosion."
msgstr ""
"``explosion_area``: :ref:`Area <class_Area>` 节点，用于检测爆炸内的节点。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1149
msgid "``EXPLOSION_DAMAGE``: The amount of damage the explosion does."
msgstr "``EXPLOSION_DAMAGE``:爆炸造成的伤害量。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1150
msgid ""
"``EXPLOSION_TIME``: The length of time the explosion :ref:`Particles "
"<class_Particles>` take (you can calculate this number by multiplying the "
"particles ``lifetime`` by its ``speed scale``)"
msgstr ""
"``EXPLOSION_TIME``:爆炸的时间长度 :ref:`Particles <class_Particles>` take(您"
"可以通过将粒子 ``lifetime`` 乘以它的``speed scale``来计算这个数字)"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1151
msgid ""
"``explosion_timer``: A variable for tracking how long the explosion has "
"lasted."
msgstr "``explosion_timer``:用于跟踪爆炸持续时间的变量。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1152
msgid "``explode``: A boolean for tracking whether the bomb has exploded."
msgstr "``explode``:用于跟踪炸弹是否爆炸的布尔值。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1153
msgid "``fuse_particles``: The fuse :ref:`Particles <class_Particles>` node."
msgstr "``fuse_particles``:保险丝 :ref:`Particles <class_Particles>` 节点。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1154
msgid ""
"``explosion_particles``: The explosion :ref:`Particles <class_Particles>` "
"node."
msgstr "``explosion_particles``:爆炸 :ref:`Particles <class_Particles>` node。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1155
msgid ""
"``controller``: The controller that is currently holding the bomb, if there "
"is one. This is set by the controller, so we do not need to check anything "
"outside of checking if it is ``null``."
msgstr ""
"``controller``:当前持有炸弹的控制器，如果有的话。 这是由控制器设置的，所以除"
"了检查是否为“null”之外，我们不需要检查任何内容。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1159
msgid "Let's go through ``_ready``."
msgstr "让我们来看看 ``_ready`` 。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1161
#, fuzzy
msgid ""
"Firstly, we get all the nodes and assign them to the proper variables for "
"later use."
msgstr "首先，我们获取所有节点并将它们分配给适当的变量供以后使用。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1163
msgid ""
"Then, we make sure ``_physics_process`` is not going to be called. We do "
"this since we will be using ``_physics_process`` only for the fuse and for "
"destroying the bomb, so we do not want to trigger that early, we only want "
"the fuse to start when the player interacts while holding a bomb."
msgstr ""
"然后，我们确保不会调用 ``_physics_process`` 。 我们这样做是因为我们只使用 "
"``_physics_process`` 作为保险丝和销毁炸弹，所以我们不想早点触发，我们只想让游"
"戏角色在拿着炸弹时进行交互时启动保险丝。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1168
msgid "Now, let's look at ``_physics_process``."
msgstr "现在，让我们看看`_physics_process``。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1170
#, fuzzy
msgid ""
"Firstly we check to see whether ``fuse_timer`` is less than ``FUSE_TIME``. "
"If ``fuse_timer`` is less than ``FUSE_TIME``, then the bomb must be burning "
"down the fuse."
msgstr ""
"首先，我们检查 ``fuse_timer`` 是否小于 ``FUSE_TIME`` 。 如果 ``fuse_timer`` "
"小于 ``FUSE_TIME`` ，那么炸弹必须烧掉保险丝。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1172
#, fuzzy
msgid ""
"We then add time to ``fuse_timer``, and check to see whether the bomb has "
"waited long enough and has burned through the entire fuse."
msgstr ""
"然后我们将时间添加到 ``fuse_timer`` ，并检查炸弹是否已经等待足够长的时间并烧"
"掉整个保险丝。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1174
msgid ""
"If the bomb has waited long enough, then we need to explode the bomb. We do "
"this first by stopping the smoke :ref:`Particles <class_Particles>` from "
"emitting, and making the explosion :ref:`Particles <class_Particles>` emit. "
"We also hide the bomb mesh so it is no longer visible."
msgstr ""
"如果炸弹已经等了足够长的时间，那么我们需要爆炸炸弹。 我们首先停止冒烟 :ref:"
"`Particles <class_Particles>` 来自发射，然后进行爆炸 :ref:`Particles "
"<class_Particles>` emit。 我们还隐藏了炸弹网，使其不再可见。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1177
msgid ""
"Next, we make the set the collision layer and mask to zero, and set the :ref:"
"`RigidBody <class_RigidBody>` mode to static. This makes it where the now "
"exploded bomb cannot interact with the physics world, and so it will stay in "
"place."
msgstr ""
"接下来，我们将碰撞层和掩码设置为零，并将 :ref:`RigidBody <class_RigidBody>` "
"模式设置为static。 这使得它现在爆炸的炸弹无法与物理世界相互作用，因此它将保持"
"原位。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1180
#, fuzzy
msgid ""
"Then, we go through everything inside the explosion :ref:`Area "
"<class_Area>`. We make sure the bodies inside the explosion :ref:`Area "
"<class_Area>` are not the bomb itself, since we do not want to explode the "
"bomb with itself. We then check to see whether the bodies have the "
"``damage`` method/function, and if it does, we call that, while if it does "
"not, we check to see if it has the ``apply_impulse`` method/function, and "
"call that instead."
msgstr ""
"然后我们浏览爆炸内的所有内容 :ref:`Area <class_Area>`。 我们确保爆炸内部的物"
"体 :ref:`Area <class_Area>` 不是炸弹本身，因为我们不想用它自己爆炸炸弹。 然后"
"我们检查一下是否有 ``damage`` 方法/函数，如果是，我们称之为，如果不是，我们检"
"查它是否有 ``apply_impulse`` 方法/函数，并且 打电话给那个。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1184
#, fuzzy
msgid ""
"Then, we set ``explode`` to true since the bomb has exploded, and we play a "
"sound."
msgstr "然后我们将 ``explode`` 设置为true，因为炸弹已爆炸，我们发出声音。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1186
msgid ""
"Next, we check to see if the bomb has exploded, as we need to wait until the "
"explosion :ref:`Particles <class_Particles>` are done."
msgstr ""
"接下来，我们检查炸弹是否爆炸，因为我们需要等到爆炸 :ref:`Particles "
"<class_Particles>` 完成。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1188
msgid ""
"If the bomb has exploded, we add time to ``explosion_timer``. We then check "
"to see if the explosion :ref:`Particles <class_Particles>` are done. If they "
"are, we set the explosion :ref:`Area <class_Area>`'s monitoring property to "
"``false`` to ensure we do not get any bugs in the debugger, we make the "
"controller drop the bomb if it is holding onto it, we make the grab :ref:"
"`Raycast <class_Raycast>` visible if the grab mode is ``RAYCAST``, and we "
"free/destroy the bomb using ``queue_free``."
msgstr ""
"如果炸弹爆炸了，我们就加时间 ``explosion_timer`` 。 然后我们检查是否爆炸 :"
"ref:`Particles <class_Particles>` 完成。 如果它们是，我们设置爆炸 :ref:`Area "
"<class_Area>` 的监视属性为 ``false`` 以确保我们不会在调试器中得到任何错误，我"
"们让控制器丢弃炸弹如果它持有 在它上面，我们制作了抓取 :ref:`Raycast "
"<class_Raycast>` 如果抓取模式是 ``RAYCAST`` 可见，我们使用 ``queue_free`` 释"
"放/销毁炸弹。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1194
msgid "Finally, let's look at ``interact``."
msgstr "最后，让我们看一下 ``interact`` 。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1196
msgid ""
"All we are doing here is making it where ``_physics_process`` will be "
"called, which will start the fuse. We also make the fuse :ref:`Particles "
"<class_Particles>` start emitting, so smoke comes out the top of the bomb."
msgstr ""
"我们在这里所做的只是调用 ``_physics_process`` ，这将启动保险丝。 我们还制作了"
"保险丝 :ref:`Particles <class_Particles>` 开始发射，所以烟雾从炸弹顶部出来。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1201
#, fuzzy
msgid ""
"With that done, the bombs are ready to go! You can find them in the orange "
"building. Because of how we are calculating velocity, it is easiest to throw "
"bombs in a trusting-like motion as opposed to a more natural throwing like "
"motion. The smooth curve of a throwing-like motion is harder to track, and "
"the because of how we are tracking velocity, it does not always work."
msgstr ""
"完成后，炸弹准备好了！ 您可以在橙色建筑中找到它们。 由于我们如何计算速度，最"
"容易投掷类似信任的运动中的炸弹，而不是像运动那样更自然的投掷。 投掷式运动的平"
"滑曲线更难以跟踪，并且由于我们跟踪速度的方式并不总是有效。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1206
msgid "Adding a sword"
msgstr "加一把剑"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1208
msgid "Finally, let's add a sword so we can slice through things!"
msgstr "最后，让我们添加一把剑，这样我们就可以切入一些东西！"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1210
msgid "Open up ``Sword.tscn``, which you will find in ``Scenes``."
msgstr "打开 ``Sword.tscn`` ，您会在 ``Scenes`` 中找到它。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1212
msgid ""
"There is not a whole lot to note here, but there is just one thing, and that "
"is how the length of the blade of the sword is broken into several small :"
"ref:`Area <class_Area>` nodes. This is because we need to roughly know where "
"on the blade the sword collided, and this is the easiest (and only) way I "
"could figure out how to do this."
msgstr ""
"这里没有太多值得注意的，但只有一件事，那就是刀剑的长度被分成几个小的 :ref:"
"`Area <class_Area>` 节点。 这是因为我们需要粗略地知道剑碰撞的刀片在哪里，这是"
"我能弄清楚如何做到这一点的最简单(也是唯一的)方法。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1215
#, fuzzy
msgid ""
"If you know how to find the point where an :ref:`Area <class_Area>` and a :"
"ref:`CollisionObject <class_CollisionObject>` meet, please let me know and/"
"or make a PR on the Godot documentation! This method of using several small :"
"ref:`Area <class_Area>` nodes works okay, but it is not ideal."
msgstr ""
"如果您知道如何找到一个点 :ref:`Area <class_Area>` 和a :ref:`CollisionObject "
"<class_CollisionObject>` 见面，请告诉我和/或在Godot文档上做一个PR！ 这个使用"
"几个小的方法 :ref:`Area <class_Area>` 节点工作正常，但它并不理想。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1218
msgid ""
"Other than that, there really is not much of note, so let's write the code. "
"Select the ``Sword`` root node, the :ref:`RigidBody <class_RigidBody>` and "
"make a new script called ``Sword.gd``. Add the following code to ``Sword."
"gd``:"
msgstr ""
"除此之外，确实没有多少注意事项，所以让我们编写代码。 选择 ``Sword`` 根节"
"点， :ref:`RigidBody <class_RigidBody>` 并创建一个名为 ``Sword.gd`` 的新脚"
"本。 将以下代码添加到``Sword.gd``:"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1283
msgid ""
"Let's go over what this script does, starting with the two class variables:"
msgstr "让我们回顾一下这个脚本的作用，从两个类变量开始:"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1285
msgid "``SWORD_DAMAGE``: The amount of damage a single sword slice does."
msgstr "``SWORD_DAMAGE``:单个剑片所造成的伤害量。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1286
#, fuzzy
msgid ""
"``controller``: The controller that is holding the sword, if there is one. "
"This is set by the controller, so we do not need to set it here, in ``Sword."
"gd``."
msgstr ""
"``controller``:拿着剑的控制器，如果有的话。 这是由控制器设置的，所以我们不需"
"要在 ``Sword.gd`` 中设置它。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1290
msgid "Let's go over ``_ready`` next."
msgstr "让我们接下来回顾一下 ``_ready`` 。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1292
#, fuzzy
msgid ""
"All we are doing here is connecting each of the :ref:`Area <class_Area>` "
"nodes ``body_entered`` signal to the ``body_entered_sword`` function, "
"passing in an additional argument, which will be the number of the damage :"
"ref:`Area <class_Area>`, so we can figure out where on the sword the body "
"collided."
msgstr ""
"我们在这里所做的就是将每个 :ref:`Area <class_Area>` nodes ``body_entered`` 信"
"号连接到 ``body_entered_sword`` 函数，传入一个额外的参数，它将是损坏的数量:"
"ref :`Area <class_Area>`，所以我们可以弄清楚物体碰撞的剑在哪里。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1297
msgid "Now let's go over ``body_entered_sword``."
msgstr "现在让我们回顾一下 ``body_entered_sword`` 。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1299
#, fuzzy
msgid ""
"Firstly, we make sure the body the sword has collided with is not itself."
msgstr "首先，我们确保剑与之碰撞的物体本身并不存在。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1301
msgid ""
"Then we figure out which part of the sword the body collided with, using the "
"passed-in number."
msgstr "然后我们使用传入的数字找出物体碰撞的剑的哪一部分。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1303
#, fuzzy
msgid ""
"Next, we check to see whether the body the sword collided with has the "
"``damage`` function, and if it does, we call it and play a sound."
msgstr ""
"接下来，我们检查剑与剑相撞的物体是否具有“伤害”功能，如果有，我们称之为并发出"
"声音。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1305
#, fuzzy
msgid ""
"If it does not have the damage function, we then check to see whether it has "
"the ``apply_impulse`` function. If it does, we then calculate the direction "
"from the sword part the body collided with to the body. We then check to see "
"whether the sword is being held or not."
msgstr ""
"如果它没有损坏功能，我们检查它是否具有 ``apply_impulse`` 功能。 如果是这样，"
"我们然后计算从物体碰撞的剑部分到物体的方向。 然后我们检查剑是否被关押。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1308
msgid ""
"If the sword is not being held, we use the :ref:`RigidBody "
"<class_RigidBody>`'s velocity as the force in ``apply_impulse``, while if "
"the sword is being held, we use the controller's velocity as the force in "
"the impulse."
msgstr ""
"如果没有持剑，我们使用 :ref:`RigidBody <class_RigidBody>的速度作"
"为“apply_impulse”的力量，而如果持剑，我们使用控制器的速度作为力量 冲动。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1311
msgid "Finally, we play a sound."
msgstr "最后，我们发出声音。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1317
msgid ""
"With that done, you can now slice through the targets! You can find the "
"sword in the corner in between the shotgun and the pistol."
msgstr "完成后，您现在可以切入目标了！ 您可以在霰弹枪和手枪之间的角落找到剑。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1320
msgid "Updating the target UI"
msgstr "更新目标UI"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1322
msgid "Okay, let's update the UI as the sphere targets are destroyed."
msgstr "好吧，让我们在球体目标被破坏时更新UI。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1324
#, fuzzy
msgid ""
"Open up ``Game.tscn`` and then expand the ``GUI`` :ref:`MeshInstance "
"<class_MeshInstance>`. From there, expand the ``GUI`` :ref:`Viewport "
"<class_Viewport>` node and then select the ``Base_Control`` node. Add a new "
"script called ``Base_Control``, and add the following:"
msgstr ""
"打开 ``Game.tscn`` 然后展开``GUI`` :ref:`MeshInstance "
"<class_MeshInstance>`。 从那里，展开``GUI`` :ref:`Viewport <class_Viewport>` "
"节点，然后选择 ``base_control`` 节点。 添加一个名为 ``Base_Control`` 的新脚"
"本，并添加以下内容:"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1343
msgid "Let's go over what this script does."
msgstr "我们来看看这个脚本的功能。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1345
#, fuzzy
msgid ""
"First, in ``_ready``, we get the :ref:`Label <class_Label>` that shows how "
"many spheres are left and assign it to the ``sphere_count_label`` class "
"variable. Next, we get ``Game.gd`` by using ``get_tree().root`` and assign "
"``sphere_ui`` to this script."
msgstr ""
"首先，在 ``_ready`` 中，我们得到 :ref:`Label <class_Label>` ，显示剩下多少个"
"球体并将其分配给 ``sphere_count_label`` 类变量。 接下来，我们使用 "
"``get_tree().root`` 获得 ``Game.gd`` 并将 ``sphere_ui`` 分配给该脚本。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1348
#, fuzzy
msgid ""
"In ``update_ui``, we change the sphere :ref:`Label <class_Label>`'s text. If "
"there is at least one sphere remaining, we change the text to show how many "
"spheres are still left in the world. If there are no more spheres remaining, "
"we change the text and congratulate the player."
msgstr ""
"在 ``update_ui`` 中，我们改变了球体 :ref:`Label <class_Label>的文本。 如果剩"
"下至少一个球体，我们会更改文本以显示世界上还剩下多少球体。 如果没有更多的球"
"体，我们会更改文字并祝贺游戏角色。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1352
msgid "Adding the final special RigidBody"
msgstr "添加最终的特殊RigidBody"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1354
msgid ""
"Finally, before we finish this tutorial, let's add a way to reset the game "
"while in VR."
msgstr "最后，在我们完成本教程之前，让我们添加一种在VR中重置游戏的方法。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1356
msgid ""
"Open up ``Reset_Box.tscn``, which you will find in ``Scenes``. Select the "
"``Reset_Box`` :ref:`RigidBody <class_RigidBody>` node and make a new script "
"called ``Reset_Box.gd``. Add the following code to ``Reset_Box.gd``:"
msgstr ""
"打开 ``Reset_Box.tscn`` ，您会在 ``Scenes`` 中找到它。 选择``Reset_Box`` :"
"ref:`RigidBody <class_RigidBody>` 节点并创建一个名为 ``Reset_Box.gd`` 的新脚"
"本。 将以下代码添加到``Reset_Box.gd``:"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1396
#, fuzzy
msgid "Let's go over what this does."
msgstr "我们来看看这个脚本的功能。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1398
#, fuzzy
msgid ""
"First, we get the starting global :ref:`Transform <class_Transform>` in "
"``_ready``, and assign it to ``start_transform``. We will use this to reset "
"the position of the reset box every so often."
msgstr ""
"首先，我们在 ``_ready`` 中得到起始全局 :ref:`Transform <class_Transform>` ，"
"并将其赋值给 ``start_transform`` 。 我们将使用它来经常重置复位盒的位置。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1400
msgid ""
"In ``_physics_process``, we check to see if enough time has passed to reset. "
"If it has, we reset the box's :ref:`Transform <class_Transform>` and then "
"reset the timer."
msgstr ""
"在 ``_physics_process`` 中，我们检查是否有足够的时间重置。 如果有，我们重置框"
"的 :ref:`Transform <class_Transform>` 然后重置计时器。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1402
msgid ""
"If the player interacts while holding the reset box, we reset the scene by "
"calling ``get_tree().change_scene`` and passing in the path to the current "
"scene. This resets/restarts the scene completely."
msgstr ""
"如果游戏角色在按住重置框时进行交互，我们通过调用“get_tree()。change_scene``并"
"将路径传递到当前场景来重置场景。 这会完全重置/重新启动场景。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1405
msgid ""
"When the reset box is dropped, we reset the :ref:`Transform "
"<class_Transform>` and timer."
msgstr ""
"当重置框被删除时，我们重置 :ref:`Transform <class_Transform>` 和计时器。"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1409
#, fuzzy
msgid ""
"With that done, when you grab and interact with the reset box, the entire "
"scene will reset/restart and you can destroy all the targets again!"
msgstr ""
"完成后，当您抓住并与重置框交互时，整个场景将重置/重新启动，您可以再次销毁所有"
"目标！"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1412
msgid "Final notes"
msgstr "最后的笔记"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1416
#, fuzzy
msgid "Whew! That was a lot of work. Now you have a VR project!"
msgstr "唷！ 这是很多工作。 现在您有一个相当简单的VR项目！"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1418
msgid "If you ever get lost, be sure to read over the code again!"
msgstr "如果您迷路了，请务必再次阅读代码！"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1420
msgid ""
"You can download the finished project for this part here: :download:"
"`VR_Starter_Tutorial_Complete.zip <files/VR_Starter_Tutorial_Complete.zip>`"
msgstr ""
"您可以在此处下载此部分的已完成项目: :download:`VR_Starter_Tutorial_Complete."
"zip <files / VR_Starter_Tutorial_Complete.zip>`"

#: ../../docs/tutorials/vr/vr_starter_tutorial.rst:1422
#, fuzzy
msgid ""
"This will hopefully serve as an introduction to making fully-featured VR "
"games in Godot! The code written here can be expanded to make puzzle games, "
"action games, story-based games, and more!"
msgstr ""
"这有望成为在Godot制作功能齐全的VR游戏的介绍！ 这里编写的代码可以扩展为制作益"
"智游戏，动作游戏，基于故事的游戏等等！"
