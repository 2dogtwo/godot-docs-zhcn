# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-11-21 12:44+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Custom drawing in 2D"
msgstr "2D 中的自定义绘图"

msgid "Introduction"
msgstr "前言"

msgid ""
"Godot has nodes to draw sprites, polygons, particles, and all sorts of "
"stuff. For most cases, this is enough. If there's no node to draw something "
"specific you need, you can make any 2D node (for example, :ref:`Control "
"<class_Control>` or :ref:`Node2D <class_Node2D>` based) draw custom commands."
msgstr ""
"Godot 有用于绘制精灵、多边形、粒子以及各种东西的节点。在大多数情况下，这就已"
"经足够了。如果没有节点可以绘制你需要的特定内容，你可以用任何 2D 节点（例如，"
"基于 :ref:`Control <class_Control>` 或 :ref:`Node2D <class_Node2D>` ）绘制自"
"定义命令。"

msgid ""
"Custom drawing in a 2D node is *really* useful. Here are some use cases:"
msgstr "2D 节点中的自定义绘制\\ *非常*\\ 有用。下面是一些用例："

msgid ""
"Drawing shapes or logic that existing nodes can't do, such as an image with "
"trails or a special animated polygon."
msgstr ""
"绘制现有节点类型无法完成的形状或逻辑，例如带有轨迹或特殊动态多边形的图像。"

msgid ""
"Visualizations that are not that compatible with nodes, such as a tetris "
"board. (The tetris example uses a custom draw function to draw the blocks.)"
msgstr ""
"与节点不太兼容的呈现方式，比如俄罗斯方块的棋盘。（俄罗斯方块的例子使用的是自"
"定义绘制函数来绘制方块。）"

msgid ""
"Drawing a large number of simple objects. Custom drawing avoids the overhead "
"of using a large number of nodes, possibly lowering memory usage and "
"improving performance."
msgstr ""
"绘制大量简单的对象。自定义绘制避免了使用大量节点的开销，能降低内存占用，并提"
"高性能。"

msgid ""
"Making a custom UI control. There are plenty of controls available, but when "
"you have unusual needs, you will likely need a custom control."
msgstr "制作自定义的 UI 控件，以满足很多可用的控件之外的特别需求。"

msgid "Drawing"
msgstr "绘制"

msgid ""
"Add a script to any :ref:`CanvasItem <class_CanvasItem>` derived node, like :"
"ref:`Control <class_Control>` or :ref:`Node2D <class_Node2D>`. Then override "
"the ``_draw()`` function."
msgstr ""
"添加一个脚本到任何 :ref:`CanvasItem <class_CanvasItem>` 的派生节点，如 :ref:"
"`Control <class_Control>` 或 :ref:`Node2D <class_Node2D>`\\ 。然后重载 "
"``_draw()`` 函数。"

msgid ""
"Draw commands are described in the :ref:`CanvasItem <class_CanvasItem>` "
"class reference. There are plenty of them."
msgstr ""
"绘制命令在 :ref:`CanvasItem <class_CanvasItem>` 的类参考中有所描述，数量很"
"多。"

msgid "Updating"
msgstr "更新"

msgid ""
"The ``_draw()`` function is only called once, and then the draw commands are "
"cached and remembered, so further calls are unnecessary."
msgstr ""
"``_draw()`` 函数只调用一次, 然后绘制命令被缓存并记住, 因此不需要进一步调用."

msgid ""
"If re-drawing is required because a state or something else changed, call :"
"ref:`CanvasItem.queue_redraw() <class_CanvasItem_method_queue_redraw>` in "
"that same node and a new ``_draw()`` call will happen."
msgstr ""
"如果因为状态或其他方面的变化而需要重新绘制，在当前节点中调用 :ref:"
"`CanvasItem.queue_redraw() <class_CanvasItem_method_queue_redraw>` ，触发新"
"的 ``_draw()`` 调用。"

msgid ""
"Here is a little more complex example, a texture variable that will be "
"redrawn if modified:"
msgstr "这是一个更复杂的示例，一个被修改就会重新绘制的纹理变量："

msgid ""
"In some cases, it may be desired to draw every frame. For this, call "
"``queue_redraw()`` from the ``_process()`` callback, like this:"
msgstr ""
"在某些情况下，可能需要绘制每一帧。 为此，从 ``_process()`` 回调中调用 "
"``queue_redraw()`` ，如下所示："

msgid "Coordinates"
msgstr "坐标"

msgid ""
"The drawing API uses the CanvasItem's coordinate system, not necessarily "
"pixel coordinates. Which means it uses the coordinate space created after "
"applying the CanvasItem's transform. Additionally, you can apply a custom "
"transform on top of it by using :ref:"
"`draw_set_transform<class_CanvasItem_method_draw_set_transform>` or :ref:"
"`draw_set_transform_matrix<class_CanvasItem_method_draw_set_transform_matrix>`."
msgstr ""
"绘图 API 使用 CanvasItem 的坐标系，不一定是像素坐标。这意味着它使用在应用 "
"CanvasItem 的变换后创建的坐标空间。此外，你可以使用 :ref:"
"`draw_set_transform<class_CanvasItem_method_draw_set_transform>` 或 :ref:"
"`draw_set_transform_matrix<class_CanvasItem_method_draw_set_transform_matrix>` "
"在它上面应用自定义变换。"

msgid ""
"When using ``draw_line``, you should consider the width of the line. When "
"using a width that is an odd size, the position should be shifted by ``0.5`` "
"to keep the line centered as shown below."
msgstr ""
"使用 ``draw_line`` 时，应考虑线条的宽度。如果使用的宽度是奇数，则应将位置移"
"动 ``0.5`` 以保持线条居中，如下图所示。"

msgid "The same applies to the ``draw_rect`` method with ``filled = false``."
msgstr "这同样适用于使用 ``filled = false`` 的 ``draw_rect`` 方法。"

msgid "An example: drawing circular arcs"
msgstr "示例：绘制圆弧"

msgid ""
"We will now use the custom drawing functionality of the Godot Engine to draw "
"something that Godot doesn't provide functions for. As an example, Godot "
"provides a ``draw_circle()`` function that draws a whole circle. However, "
"what about drawing a portion of a circle? You will have to code a function "
"to perform this and draw it yourself."
msgstr ""
"我们现在将使用 Godot 引擎的自定义绘图功能来绘制 Godot 未提供函数的内容。比"
"如，Godot 提供了 ``draw_circle()`` 函数，它可以绘制一个完整的圆。但是，画一个"
"圆的一部分怎么说？你必须编写一个函数来执行此操作，自己绘制它。"

msgid "Arc function"
msgstr "弧函数"

msgid ""
"An arc is defined by its support circle parameters, that is, the center "
"position and the radius. The arc itself is then defined by the angle it "
"starts from and the angle at which it stops. These are the 4 arguments that "
"we have to provide to our drawing function. We'll also provide the color "
"value, so we can draw the arc in different colors if we wish."
msgstr ""
"弧由其所在的圆的参数定义。即中心位置和半径。弧本身由开始的角度和停止的角度来"
"定义。这些是我们必须为绘图提供的4个参数。我们还将提供颜色值，因此我们可以根据"
"需要绘制不同颜色的圆弧。"

msgid ""
"Basically, drawing a shape on the screen requires it to be decomposed into a "
"certain number of points linked from one to the next. As you can imagine, "
"the more points your shape is made of, the smoother it will appear, but the "
"heavier it will also be in terms of processing cost. In general, if your "
"shape is huge (or in 3D, close to the camera), it will require more points "
"to be drawn without it being angular-looking. On the contrary, if your shape "
"is small (or in 3D, far from the camera), you may decrease its number of "
"points to save processing costs; this is known as *Level of Detail (LOD)*. "
"In our example, we will simply use a fixed number of points, no matter the "
"radius."
msgstr ""
"基本上，在屏幕上绘制形状需要将其分解为一定量首位相接的点。你可以预见到，点越"
"多，它就越平滑，但处理开销就越大。一般来说，如果你的形状很大（或者在 3D 场景"
"中靠近相机），则需要绘制更多的点才不会看起来像是有棱角的。相反，如果你的形状"
"很小（或在 3D 场景里远离相机），你可以减少其点数以节省处理成本。这称为 *细节"
"层次 (LOD)* 。在我们的示例中，无论半径如何，我们都只使用固定数量的点。"

msgid ""
"Remember the number of points our shape has to be decomposed into? We fixed "
"this number in the ``nb_points`` variable to a value of ``32``. Then, we "
"initialize an empty ``PackedVector2Array``, which is simply an array of "
"``Vector2``\\ s."
msgstr ""
"还记得我们的形状必须分解成多少个点吗？我们将 ``nb_points`` 变量中的这个数字修"
"改为 ``32`` 。然后，我们初始化一个空的 ``PackedVector2Array`` ，它就是一个 "
"``Vector2`` 数组。"

msgid ""
"The next step consists of computing the actual positions of these 32 points "
"that compose an arc. This is done in the first for-loop: we iterate over the "
"number of points for which we want to compute the positions, plus one to "
"include the last point. We first determine the angle of each point, between "
"the starting and ending angles."
msgstr ""
"下一步包括计算构成弧的这32个点的实际位置. 这是在第一个for循环中完成的: 我们迭"
"代我们想要计算位置的点的数量, 后面+1来包括最后一个点. 我们首先确定起点和终点"
"之间每个点的角度."

msgid ""
"The reason why each angle is decreased by 90° is that we will compute 2D "
"positions out of each angle using trigonometry (you know, cosine and sine "
"stuff...). However, ``cos()`` and ``sin()`` use radians, not degrees. The "
"angle of 0° (0 radian) starts at 3 o'clock, although we want to start "
"counting at 12 o'clock. So we decrease each angle by 90° in order to start "
"counting from 12 o'clock."
msgstr ""
"每个角度减少 90° 的原因是我们将使用三角函数（你懂的，余弦和正弦之类的东"
"西......）计算每个角度的 2D 位置。但是， ``cos()`` 和 ``sin()`` 使用弧度，而"
"不是角度。 0°（0 弧度）的角度从 3 点钟位置开始，尽管我们想从 12 点钟位置开"
"始。因此，我们将每个角度减少 90°，以便从 12 点钟开始计数。"

msgid ""
"The actual position of a point located on a circle at angle ``angle`` (in "
"radians) is given by ``Vector2(cos(angle), sin(angle))``. Since ``cos()`` "
"and ``sin()`` return values between -1 and 1, the position is located on a "
"circle of radius 1. To have this position on our support circle, which has a "
"radius of ``radius``, we simply need to multiply the position by ``radius``. "
"Finally, we need to position our support circle at the ``center`` position, "
"which is performed by adding it to our ``Vector2`` value. Finally, we insert "
"the point in the ``PackedVector2Array`` which was previously defined."
msgstr ""
"以角度 ``angle`` （单位是弧度）位于圆上的点的实际位置由 "
"``Vector2(cos(angle), sin(angle))`` 给出。由于 ``cos()`` 和 ``sin()`` 返回介"
"于 -1 和 1 之间的值，因此位置位于半径为 1 的圆上。要将此位置放在我们的半径为 "
"``radius`` 的辅助圆上，我们只需要将那个位置乘以 ``radius`` 。最后，我们需要将"
"我们的辅助圆定位在 ``center`` 位置，这是通过将其与我们的 ``Vector2`` 相加来实"
"现的。最后，我们在之前定义的 ``PackedVector2Array`` 中插入这个点。"

msgid ""
"Now, we need to actually draw our points. As you can imagine, we will not "
"simply draw our 32 points: we need to draw everything that is between each "
"of them. We could have computed every point ourselves using the previous "
"method, and drew it one by one. But this is too complicated and inefficient "
"(except if explicitly needed), so we simply draw lines between each pair of "
"points. Unless the radius of our support circle is big, the length of each "
"line between a pair of points will never be long enough to see them. If that "
"were to happen, we would simply need to increase the number of points."
msgstr ""
"现在, 我们需要实际绘制我们的点. 你可以想象, 我们不会简单地画出我们的32个点: "
"我们需要绘制每一点之间的所有内容. 我们可以使用前面的方法自己计算每个点, 然后"
"逐个绘制. 但这太复杂和低效了(除非确实需要). 因此, 我们只需在每对点之间绘制线"
"条. 除非我们的辅助圆的半径很大, 否则一对点之间每条线的长度永远不会长到足以看"
"到它们. 如果发生这种情况, 我们只需要增加点的个数就可以了."

msgid "Draw the arc on the screen"
msgstr "在屏幕上绘制弧形"

msgid ""
"We now have a function that draws stuff on the screen; it is time to call it "
"inside the ``_draw()`` function:"
msgstr ""
"我们现在有一个在屏幕上绘制内容的函数; 是时候在 ``_draw()`` 函数中调用它了:"

msgid "Result:"
msgstr "结果:"

msgid "Arc polygon function"
msgstr "弧多边形函数"

msgid ""
"We can take this a step further and not only write a function that draws the "
"plain portion of the disc defined by the arc, but also its shape. The method "
"is exactly the same as before, except that we draw a polygon instead of "
"lines:"
msgstr ""
"我们可以更进一步, 不仅仅绘制一个由弧定义的扇形的边缘, 还可以绘制其形体. 该方"
"法与以前完全相同, 只是我们绘制的是多边形而不是线条:"

msgid "Dynamic custom drawing"
msgstr "动态自定义绘图"

msgid ""
"All right, we are now able to draw custom stuff on the screen. However, it "
"is static; let's make this shape turn around the center. The solution to do "
"this is simply to change the angle_from and angle_to values over time. For "
"our example, we will simply increment them by 50. This increment value has "
"to remain constant or else the rotation speed will change accordingly."
msgstr ""
"好吧, 我们现在能够在屏幕上绘制自定义内容. 然而, 它是静态的; 我们让这个形状围"
"绕中心转动吧. 这样做的方法就是随着时间的推移改变angle_from和angle_to值. 对于"
"我们的示例, 我们将简单地将它们递增50. 此增量值必须保持不变, 否则旋转速度将相"
"应地改变."

msgid ""
"First, we have to make both angle_from and angle_to variables global at the "
"top of our script. Also note that you can store them in other nodes and "
"access them using ``get_node()``."
msgstr ""
"首先, 我们必须在我们的angle_from和angle_to变量变成全局变量, 放在脚本顶部. 另"
"请注意, 你可以将它们存储在其他节点中并使用 ``get_node()`` 访问它们."

msgid "We make these values change in the _process(delta) function."
msgstr "我们在_process(delta)函数中更改这些值."

msgid ""
"We also increment our angle_from and angle_to values here. However, we must "
"not forget to ``wrap()`` the resulting values between 0 and 360°! That is, "
"if the angle is 361°, then it is actually 1°. If you don't wrap these "
"values, the script will work correctly, but the angle values will grow "
"bigger and bigger over time until they reach the maximum integer value Godot "
"can manage (``2^31 - 1``). When this happens, Godot may crash or produce "
"unexpected behavior."
msgstr ""
"我们也在这里增加angle_from和angle_to值. 但是, 我们不能忘记将结果 ``wrap()`` "
"在0到360°之间！ 也就是说, 如果角度是361°, 那么它实际上是1°. 如果你不包装这些"
"值, 脚本将正常工作, 但角度值将随着时间的推移变得越来越大, 直到它们达到Godot可"
"以管理的最大整数值(``2^31 - 1``). 当发生这种情况时,Godot可能会崩溃或产生意外"
"行为."

msgid ""
"Finally, we must not forget to call the ``queue_redraw()`` function, which "
"automatically calls ``_draw()``. This way, you can control when you want to "
"refresh the frame."
msgstr ""
"最后, 我们一定不要忘记调用 ``queue_redraw()`` 函数, 它会自动调用 "
"``_draw()`` 。这样, 你就可以控制何时去刷新这一帧。"

msgid ""
"Also, don't forget to modify the ``_draw()`` function to make use of these "
"variables:"
msgstr "另外, 不要忘记修改 ``_draw()`` 函数来使用这些变量:"

msgid ""
"Let's run! It works, but the arc is rotating insanely fast! What's wrong?"
msgstr "我们运行吧！ 它工作正常, 但弧线旋转快得疯掉了！ 怎么了？"

msgid ""
"The reason is that your GPU is actually displaying the frames as fast as it "
"can. We need to \"normalize\" the drawing by this speed; to achieve that, we "
"have to make use of the ``delta`` parameter of the ``_process()`` function. "
"``delta`` contains the time elapsed between the two last rendered frames. It "
"is generally small (about 0.0003 seconds, but this depends on your "
"hardware), so using ``delta`` to control your drawing ensures that your "
"program runs at the same speed on everybody's hardware."
msgstr ""
"原因是你的 GPU 实际上正在尽可能快地显示帧。我们需要以这个速度为基准 “标准化” "
"绘图的速度。为了实现这个效果，我们必须使用 ``_process()`` 函数的 ``delta`` 参"
"数。 ``delta`` 包含最后两个渲染帧之间经过的时间。它通常很小（约0.0003秒，但这"
"取决于你的硬件）。因此，使用 ``delta`` 来控制绘图可确保程序在每个人的硬件上以"
"相同的速度运行。"

msgid ""
"In our case, we simply need to multiply our ``rotation_angle`` variable by "
"``delta`` in the ``_process()`` function. This way, our 2 angles will be "
"increased by a much smaller value, which directly depends on the rendering "
"speed."
msgstr ""
"在我们的示例中, 我们只需要在 ``_process()`` 函数中将 ``rotation_angle`` 变量"
"乘以 ``delta`` . 这样, 我们的2个角度会以一个小得多的值递增, 值的大小直接取决"
"于渲染速度."

msgid "Let's run again! This time, the rotation displays fine!"
msgstr "让我们再运行一次！ 这次, 旋转显示正常！"

msgid "Antialiased drawing"
msgstr "抗锯齿绘图"

#, fuzzy
msgid ""
"Godot offers method parameters in :ref:"
"`draw_line<class_CanvasItem_method_draw_line>` to enable antialiasing, but "
"not all custom drawing methods offer this ``antialiased`` parameter."
msgstr ""
"Godot在 :ref:`draw_line<class_CanvasItem_method_draw_line>`中提供方法参数来启"
"用抗锯齿功能，但并非所有自定义绘图方法都提供这个 ``抗锯齿（antialiased）`` 参"
"数。"

#, fuzzy
msgid ""
"For custom drawing methods that don't provide an ``antialiased`` parameter, "
"you can enable 2D MSAA instead, which affects rendering in the entire "
"viewport. This provides high-quality antialiasing, but a higher performance "
"cost and only on specific elements. See :ref:`doc_2d_antialiasing` for more "
"information."
msgstr ""
"对于不提供 ``抗锯齿（antialiased）`` 参数的自定义绘图方法，你可以启用 2D "
"MSAA，这会影响整个视口的渲染。这个功能（2D MSAA）提供了高质量的抗锯齿，但性能"
"成本更高，而且只适用于特定元素。参见 :ref:`doc_2d_antialiasing` 以了解更多信"
"息。"

msgid "Tools"
msgstr "工具"

msgid ""
"Drawing your own nodes might also be desired while running them in the "
"editor. This can be used as a preview or visualization of some feature or "
"behavior. See :ref:`doc_running_code_in_the_editor` for more information."
msgstr ""
"在编辑器中运行节点时，可能也会用到绘图。可以用于某些特性或行为的预览或可视"
"化。详情请参阅 :ref:`doc_running_code_in_the_editor`\\ 。"

msgid "Translation status"
msgstr "翻译状态"
