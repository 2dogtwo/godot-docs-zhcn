# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2018, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-06-13 14:08+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../docs/tutorials/viewports/viewports.rst:4
msgid "Viewports"
msgstr "视区"

#: ../../docs/tutorials/viewports/viewports.rst:7
msgid "Introduction"
msgstr "简介"

#: ../../docs/tutorials/viewports/viewports.rst:9
msgid ""
"Godot has a small but useful feature called viewports. Viewports are, as the "
"name implies, rectangles where the world is drawn. They have three main "
"uses, but can flexibly adapted to a lot more. All this is done via the :ref:"
"`Viewport <class_Viewport>` node."
msgstr ""
"Godot有一个很小但有用的功能称为视区。顾名思义, 视区是绘制世界的长方形。他们有"
"三主要用途, 但能灵活地适应更多目的。所有这一切都是通过:ref:`Viewport "
"<class_Viewport>` 节点完成的。"

#: ../../docs/tutorials/viewports/viewports.rst:16
msgid "The main uses in question are:"
msgstr "上面提到的三个主要用途如下："

#: ../../docs/tutorials/viewports/viewports.rst:18
msgid ""
"**Scene Root**: The root of the active scene is always a Viewport. This is "
"what displays the scenes created by the user. (You should know this by "
"having read previous tutorials!)"
msgstr ""
"** 场景的根 **: 场景的根节点始终是视区。这用来显示用户创建的场景的内容。(通过"
"阅读以前的教程您应该知晓这一点!）"

#: ../../docs/tutorials/viewports/viewports.rst:21
msgid ""
"**Sub-Viewports**: These can be created when a Viewport is a child of a :ref:"
"`Control <class_Control>`."
msgstr ""
"** 子视区 **: 当视区为 :ref:`Control <class_Control>` 的子节点时, 子视区就会"
"被创建出来。"

#: ../../docs/tutorials/viewports/viewports.rst:23
msgid ""
"**Render Targets**: Viewports can be set to \"RenderTarget\" mode. This "
"means that the viewport is not directly visible, but its contents can be "
"accessed via a :ref:`Texture <class_Texture>`."
msgstr ""
"** 渲染目标 **: 视区可以设置为 \"RenderTarget\" （渲染目标）模式。这意味着视"
"区不是直接可见的, 但它的内容可以通过:ref:`Texture <class_Texture>`来访问。"

#: ../../docs/tutorials/viewports/viewports.rst:28
msgid "Input"
msgstr "输入"

#: ../../docs/tutorials/viewports/viewports.rst:30
msgid ""
"Viewports are also responsible of delivering properly adjusted and scaled "
"input events to all its children nodes. Both the root viewport and sub-"
"viewports do this automatically, but render targets do not. Because of this, "
"the user must do it manually via the :ref:`Viewport.input() "
"<class_Viewport_input>` function if needed."
msgstr ""
"视区还负责向其所有子节点传递关于适当调整和缩放的输入事件。根视区和子视区都会"
"自动执行此任务, 但作渲染目标用途时不会。因此, 在需要的时候用户必须手动通过:"
"ref:`Viewport.input() <class_Viewport_input>`来实现（传递输入事件）。"

#: ../../docs/tutorials/viewports/viewports.rst:37
msgid "Listener"
msgstr "侦听者"

#: ../../docs/tutorials/viewports/viewports.rst:39
msgid ""
"Godot supports 3D sound (in both 2D and 3D nodes), more on this can be found "
"in another tutorial (one day..). For this type of sound to be audible, the "
"viewport needs to be enabled as a listener (for 2D or 3D). If you are using "
"a custom viewport to display your world, don't forget to enable this!"
msgstr ""
"Godot支持3D声音 (2D和3D节点皆可), 更多关于这点的信息可以在另一个教程中找到 "
"(有朝一日......)。要使此类声音能被侦听到, 视区需要作为侦听器（listener） (2D"
"或3D) 启用。如果您使用自定义视区来显示您的世界, 请不要忘记启用此项!"

#: ../../docs/tutorials/viewports/viewports.rst:46
msgid "Cameras (2D & 3D)"
msgstr "摄像机 (2D和3D)"

#: ../../docs/tutorials/viewports/viewports.rst:48
msgid ""
"When using a 2D or 3D :ref:`Camera <class_Camera>` / :ref:`Camera2D "
"<class_Camera2D>`, cameras will always display on the closest parent "
"viewport (going towards the root). For example, in the following hierarchy:"
msgstr ""
"当使用2D或3D:ref:`Camera <class_Camera>` / :ref:`Camera2D <class_Camera2D>`"
"类 时, 摄像机将始终显示其最近的父视区 (向根方向)。例如, 在以下层次结构中:"

#: ../../docs/tutorials/viewports/viewports.rst:53
#: ../../docs/tutorials/viewports/viewports.rst:61
#: ../../docs/tutorials/viewports/viewports.rst:159
msgid "Viewport"
msgstr "Viewport"

#: ../../docs/tutorials/viewports/viewports.rst:55
#: ../../docs/tutorials/viewports/viewports.rst:59
msgid "Camera"
msgstr "Camera"

#: ../../docs/tutorials/viewports/viewports.rst:57
msgid "Camera will display on the parent viewport, but in the following one:"
msgstr "摄像机将显示其父视区, 但在下面的层次结构中:"

#: ../../docs/tutorials/viewports/viewports.rst:63
msgid ""
"It will not (or may display in the root viewport if this is a subscene)."
msgstr "它不会 (或者显示其根视区如果这是一个子场景的话)。"

#: ../../docs/tutorials/viewports/viewports.rst:65
msgid ""
"There can be only one active camera per viewport, so if there is more than "
"one, make sure that the desired one has the \"current\" property set, or "
"make it the current camera by calling:"
msgstr ""
"每个视区只能有一个激活的摄像机, 因此, 如果有多个摄像机时, 请确保你需要的那个"
"摄像机的“current”属性被设置上，或者通过调用以下语句来使其成为当前摄像机:"

#: ../../docs/tutorials/viewports/viewports.rst:74
msgid "Scale & stretching"
msgstr "缩放和拉伸"

#: ../../docs/tutorials/viewports/viewports.rst:76
msgid ""
"Viewports have a \"rect\" property. X and Y are often not used (only the "
"root viewport uses them), while WIDTH AND HEIGHT represent the size of the "
"viewport in pixels. For Sub-Viewports, these values are overridden by the "
"ones from the parent control, but for render targets this sets their "
"resolution."
msgstr ""
"视区有一个 \"rect\" 属性。通常不使用 X 和 Y (只有根视区使用它们), 而是用“宽"
"度”和“高度”表示视区的大小 (以像素为单位)。对于“子视区”而言, 这些值是由其某个"
"父控件的对应属性所覆写的, 但对于“渲染目标”而言, 这两个属性会确定它的分辨率。"

#: ../../docs/tutorials/viewports/viewports.rst:82
msgid ""
"It is also possible to scale the 2D content and make it believe the viewport "
"resolution is other than the one specified in the rect, by calling:"
msgstr "通过调用以下语句，还可以缩放2D内容, 使其忽略rect中已指定的视区分辨率:"

#: ../../docs/tutorials/viewports/viewports.rst:91
msgid ""
"The root viewport uses this for the stretch options in the project settings."
msgstr "“根视区”用这些语句设定项目设置中的拉伸选项。"

#: ../../docs/tutorials/viewports/viewports.rst:95
msgid "Worlds"
msgstr "世界类（World）"

#: ../../docs/tutorials/viewports/viewports.rst:97
msgid ""
"For 3D, a Viewport will contain a :ref:`World <class_World>`. This is "
"basically the universe that links physics and rendering together. Spatial-"
"base nodes will register using the World of the closest viewport. By "
"default, newly created viewports do not contain a World but use the same as "
"a parent viewport (root viewport does contain one though, which is the one "
"objects are rendered to by default). A world can be set in a viewport using "
"the \"world\" property, and that will separate all children nodes of that "
"viewport from interacting with the parent viewport world. This is especially "
"useful in scenarios where, for example, you might want to show a separate "
"character in 3D imposed over the game (like in Starcraft)."
msgstr ""
"对于3D, 视区将包含一个:ref:`World <class_World>`类。这基本上就是一个把物理和"
"渲染联系在一起的宇宙世界。基于空间概念的节点将使用最接近的视区的世界进行注"
"册。默认情况下, 新创建的视区并不包含一个新的World对象, 而是使用与父视区相同的"
"World (但是根视区确实会包含一个World对象, 其他对象默认会渲染在里面)。可以使"
"用 \"world\" 属性在视区中设置一个世界, 这将隔离该视区的所有子节点同该视区的父"
"视区交互。这在某些情形下尤为有用, 例如, 您可能希望在游戏中以三维视角来看的上"
"方显示一个单独的字符（比如星际争霸）。"

#: ../../docs/tutorials/viewports/viewports.rst:109
msgid ""
"As a helper for situations where you want to create viewports that display "
"single objects and don't want to create a world, viewport has the option to "
"use its own World. This is useful when you want to instance 3D characters or "
"objects in the 2D world."
msgstr ""
"某些时刻您希望创建用来显示单个对象的viewport，且不想创建World, 为帮助您实现按"
"这样的需求视区提供了选项来自行指定World。当您希望在2D世界中实例化3D角色或对象"
"时, 这个选项很有用。"

#: ../../docs/tutorials/viewports/viewports.rst:114
msgid ""
"For 2D, each Viewport always contains its own :ref:`World2D "
"<class_World2D>`. This suffices in most cases, but in case sharing them may "
"be desired, it is possible to do so by calling the viewport API manually."
msgstr ""
"对于2D, 每个Viewport始终包含其自己的:ref:`World2D <class_World2D>`。在大多数"
"情况下这是足够的, 但如果需要共享World, 那么手动调用视区的 API 来实现也是可行"
"的。"

#: ../../docs/tutorials/viewports/viewports.rst:119
msgid "Capture"
msgstr "截图"

#: ../../docs/tutorials/viewports/viewports.rst:121
msgid ""
"It is possible to query a capture of the viewport contents. For the root "
"viewport this is effectively a screen capture. This is done with the "
"following API:"
msgstr ""
"可以通过查询得到视区内容的一份截图。对于”根视区“, 这实际上是一个屏幕截图。这"
"是通过以下 API 完成的:"

#: ../../docs/tutorials/viewports/viewports.rst:137
msgid ""
"But if you use this in _ready() or from the first frame of the viewport's "
"initialization you will get an empty texture cause there is nothing to get "
"as texture. You can deal with it using (for example):"
msgstr ""
"但是要注意, 如果您在 _ready() 或视区初始化的第一帧中使用上述方法, 则会得到一"
"个空的texture, 因为没有任何纹理可供获取。您可以使用如下方法来处理这种情况（见"
"例子）:"

#: ../../docs/tutorials/viewports/viewports.rst:148
msgid ""
"If the returned image is empty, capture still didn't happen, wait a little "
"more, as this API is asynchronous."
msgstr ""
"如果你发现返回的图像为空, 则说明捕获截图的行为仍未发生, 请稍微多等一会, 因为"
"这个 API 是异步的。"

#: ../../docs/tutorials/viewports/viewports.rst:152
msgid "Sub-viewport"
msgstr "子视区"

#: ../../docs/tutorials/viewports/viewports.rst:154
msgid ""
"If the viewport is a child of a :ref:`ViewportContainer "
"<class_viewportcontainer>`, it will become active and display anything it "
"has inside. The layout is something like this:"
msgstr ""
"如果视区是:ref:`ViewportContainer <class_viewportcontainer>`的子节点, 那么它"
"将变为活动状态并显示其内部的任何内容。层级关系布局类似如下:"

#: ../../docs/tutorials/viewports/viewports.rst:157
msgid "ViewportContainer"
msgstr "ViewportContainer"

#: ../../docs/tutorials/viewports/viewports.rst:161
msgid ""
"The viewport will cover the area of its parent control completely, if "
"stretch is set to true in Viewport Container. But you will have to setup the "
"Viewport Size to get the the appropriate part of the Viewport. And Viewport "
"Container can not be smaller than the size of the Viewport."
msgstr ""
"如果在视区容器（Viewport Container）中将拉伸设置为 true, 则视区（Viewport）将"
"完全覆盖其父控件的区域。但您必须设置Viewport的”Size“属性才能获取合适的视区部"
"分。并且注意视区容器的尺寸不能小于视区本身的尺寸。"

#: ../../docs/tutorials/viewports/viewports.rst:168
msgid "Render target"
msgstr "渲染目标"

#: ../../docs/tutorials/viewports/viewports.rst:170
msgid ""
"To set as a render target, toggle the \"render target\" property of the "
"viewport to enabled. Note that whatever is inside will not be visible in the "
"scene editor. To display the contents, the method remains the same. This can "
"be requested via code using (for example):"
msgstr ""
"为了启用”渲染目标“模式, 请勾选视区的 \"render target\" 属性，切换为 enable。"
"请注意, 该模式下任何视区内部的东西都不会在场景编辑器中看到。若要显示内容, 方"
"法与之前一样。可以通过使用代码 来请求到需要的内容（如下）:"

#: ../../docs/tutorials/viewports/viewports.rst:181
msgid ""
"By default, re-rendering of the render target happens when the render target "
"texture has been drawn in a frame. If visible, it will be rendered, "
"otherwise it will not. This behavior can be changed to manual rendering "
"(once), or always render, no matter if visible or not."
msgstr ""
"默认情况下, 当”渲染目标“的纹理在某一帧被绘制时, ”渲染目标“会被重新渲染。如果"
"是可见的, 就渲染它, 反之则不。此行为可以更改为手动渲染 (一次), 或始终渲染, 无"
"论是否可见。"

#: ../../docs/tutorials/viewports/viewports.rst:186
msgid "``TODO: Review the doc, change outdated and add more images.``"
msgstr "``TODO: 审阅文档, 更改过期内容并添加更多图片。``"

#: ../../docs/tutorials/viewports/viewports.rst:188
msgid ""
"Make sure to check the viewport demos! Viewport folder in the demos archive "
"available to download, or https://github.com/godotengine/godot-demo-projects/"
"tree/master/viewport"
msgstr ""
"请务必查看Viewport的演示项目!在可下载的demo汇总压缩包中的viewport文件夹下可以"
"找到它们，或者在这里下载 https://github.com/godotengine/godot-demo-projects/"
"tree/master/viewport"
