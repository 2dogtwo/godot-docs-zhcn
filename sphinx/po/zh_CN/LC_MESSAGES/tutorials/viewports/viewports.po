# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2018, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-11-20 12:09+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../docs/tutorials/viewports/viewports.rst:4
msgid "Viewports"
msgstr "视区"

#: ../../docs/tutorials/viewports/viewports.rst:7
msgid "Introduction"
msgstr "简介"

#: ../../docs/tutorials/viewports/viewports.rst:9
msgid ""
"Think of :ref:`Viewports <class_Viewport>` as a screen that the game is "
"projected onto. In order to see the game we need to have a surface to draw "
"it on, this surface is the Root :ref:`Viewport <class_Viewport>`."
msgstr ""

#: ../../docs/tutorials/viewports/viewports.rst:16
msgid ""
":ref:`Viewports <class_Viewport>` can also be added to the scene so that "
"there are multiple surfaces to draw on. When we are drawing to a :ref:"
"`Viewport <class_Viewport>` that is not the Root we call it a render target. "
"We can access the contents of a render target by accessing its "
"corresponding :ref:`texture <class_ViewportTexture>`. By using a :ref:"
"`Viewport <class_Viewport>` as a render target we can either render multiple "
"scenes simultaneously or we can render to a :ref:`texture "
"<class_ViewportTexture>` which is applied to an object in the scene, for "
"example a dynamic skybox."
msgstr ""

#: ../../docs/tutorials/viewports/viewports.rst:25
msgid ""
":ref:`Viewports <class_Viewport>` have a variety of use cases including:"
msgstr ""

#: ../../docs/tutorials/viewports/viewports.rst:27
msgid "Rendering 3D objects within a 2D game"
msgstr ""

#: ../../docs/tutorials/viewports/viewports.rst:28
msgid "Rendering 2D elements in a 3D game"
msgstr ""

#: ../../docs/tutorials/viewports/viewports.rst:29
msgid "Rendering dynamic textures"
msgstr ""

#: ../../docs/tutorials/viewports/viewports.rst:30
msgid "Generating procedural textures at runtime"
msgstr ""

#: ../../docs/tutorials/viewports/viewports.rst:31
msgid "Rendering multiple cameras in the same scene"
msgstr ""

#: ../../docs/tutorials/viewports/viewports.rst:33
msgid ""
"What all these use cases have in common is that you are given the ability to "
"draw objects to a texture as if it were another screen and then you can "
"choose what to do with the resulting texture."
msgstr ""

#: ../../docs/tutorials/viewports/viewports.rst:38
msgid "Input"
msgstr "输入"

#: ../../docs/tutorials/viewports/viewports.rst:40
#, fuzzy
msgid ""
":ref:`Viewports <class_Viewport>` are also responsible for delivering "
"properly adjusted and scaled input events to all their children nodes. "
"Typically input is received by the nearest :ref:`Viewport <class_Viewport>` "
"in the tree, but you can set :ref:`Viewports <class_Viewport>` to not "
"receive input by checking 'Disable Input' to 'on', this will allow the next "
"nearest :ref:`Viewport <class_Viewport>` in the tree to capture the input."
msgstr ""
"视区还负责向其所有子节点传递关于适当调整和缩放的输入事件。根视区和子视区都会"
"自动执行此任务, 但作渲染目标用途时不会。因此, 在需要的时候用户必须手动通过:"
"ref:`Viewport.input() <class_Viewport_input>`来实现（传递输入事件）。"

#: ../../docs/tutorials/viewports/viewports.rst:48
#, fuzzy
msgid ""
"For more information on how Godot handles input please read the :ref:`Input "
"Event Tutorial<doc_inputevent>`."
msgstr "有关事件（event）本身的详细信息, 请查看 :ref:`doc_inputevent` 教程。"

#: ../../docs/tutorials/viewports/viewports.rst:51
msgid "Listener"
msgstr "侦听者"

#: ../../docs/tutorials/viewports/viewports.rst:53
#, fuzzy
msgid ""
"Godot supports 3D sound (in both 2D and 3D nodes), more on this can be found "
"in the :ref:`Audio Streams Tutorial<doc_audio-streams>`. For this type of "
"sound to be audible, the :ref:`Viewport <class_Viewport>` needs to be "
"enabled as a listener (for 2D or 3D). If you are using a custom :ref:"
"`Viewport <class_Viewport>` to display your :ref:`World <class_World>`, "
"don't forget to enable this!"
msgstr ""
"Godot支持3D声音 (2D和3D节点皆可), 更多关于这点的信息可以在另一个教程中找到 "
"(有朝一日......)。要使此类声音能被侦听到, 视区需要作为侦听器（listener） (2D"
"或3D) 启用。如果您使用自定义视区来显示您的世界, 请不要忘记启用此项!"

#: ../../docs/tutorials/viewports/viewports.rst:60
msgid "Cameras (2D & 3D)"
msgstr "摄像机 (2D和3D)"

#: ../../docs/tutorials/viewports/viewports.rst:62
#, fuzzy
msgid ""
"When using a :ref:`Camera <class_Camera>` / :ref:`Camera2D "
"<class_Camera2D>`, cameras will always display on the closest parent :ref:"
"`Viewport <class_Viewport>` (going towards the root). For example, in the "
"following hierarchy:"
msgstr ""
"当使用2D或3D:ref:`Camera <class_Camera>` / :ref:`Camera2D <class_Camera2D>`"
"类 时, 摄像机将始终显示其最近的父视区 (向根方向)。例如, 在以下层次结构中:"

#: ../../docs/tutorials/viewports/viewports.rst:69
msgid ""
"CameraA will display on the Root :ref:`Viewport <class_Viewport>` and it "
"will draw MeshA. CameraB will be captured by the :ref:`Viewport "
"<class_Viewport>` Node along with MeshB. Even though MeshB is in the scene "
"hierarchy, it will still not be drawn to the Root :ref:`Viewport "
"<class_Viewport>`. Similarly MeshA will not be visible from the :ref:"
"`Viewport <class_Viewport>` node because :ref:`Viewport <class_Viewport>` "
"nodes only capture nodes below them in the hierarchy."
msgstr ""

#: ../../docs/tutorials/viewports/viewports.rst:75
#, fuzzy
msgid ""
"There can only be one active camera per :ref:`Viewport <class_Viewport>`, so "
"if there is more than one, make sure that the desired one has the \"current"
"\" property set, or make it the current camera by calling:"
msgstr ""
"每个视区只能有一个激活的摄像机, 因此, 如果有多个摄像机时, 请确保你需要的那个"
"摄像机的“current”属性被设置上，或者通过调用以下语句来使其成为当前摄像机:"

#: ../../docs/tutorials/viewports/viewports.rst:84
msgid "Scale & stretching"
msgstr "缩放和拉伸"

#: ../../docs/tutorials/viewports/viewports.rst:86
msgid ""
":ref:`Viewports <class_Viewport>` have a \"size\" property which represents "
"the size of the :ref:`Viewport <class_Viewport>` in pixels. For :ref:"
"`Viewports <class_Viewport>` which are children of :ref:`ViewportContainers "
"<class_viewportcontainer>`, these values are overridden, but for all others "
"this sets their resolution."
msgstr ""

#: ../../docs/tutorials/viewports/viewports.rst:90
#, fuzzy
msgid ""
"It is also possible to scale the 2D content and make the :ref:`Viewport "
"<class_Viewport>` resolution different than the one specified in size, by "
"calling:"
msgstr "通过调用以下语句，还可以缩放2D内容, 使其忽略rect中已指定的视区分辨率:"

#: ../../docs/tutorials/viewports/viewports.rst:98
msgid ""
"The root :ref:`Viewport <class_Viewport>` uses this for the stretch options "
"in the project settings. For more information on scaling and stretching "
"visit the :ref:`Multiple Resolutions Tutorial <doc_multiple_resolutions>`"
msgstr ""

#: ../../docs/tutorials/viewports/viewports.rst:102
msgid "Worlds"
msgstr "世界类（World）"

#: ../../docs/tutorials/viewports/viewports.rst:104
#, fuzzy
msgid ""
"For 3D, a :ref:`Viewport <class_Viewport>` will contain a :ref:`World "
"<class_World>`. This is basically the universe that links physics and "
"rendering together. Spatial-base nodes will register using the :ref:`World "
"<class_World>` of the closest :ref:`Viewport <class_Viewport>`. By default, "
"newly created :ref:`Viewports <class_Viewport>` do not contain a :ref:`World "
"<class_World>` but use the same as their parent :ref:`Viewport "
"<class_Viewport>` (root :ref:`Viewport <class_Viewport>` always contains a :"
"ref:`World <class_World>`, which is the one objects are rendered to by "
"default). A :ref:`World <class_World>` can be set in a :ref:`Viewport "
"<class_Viewport>` using the \"world\" property, and that will separate all "
"children nodes of that :ref:`Viewport <class_Viewport>` from interacting "
"with the parent :ref:`Viewport's <class_Viewport>` :ref:`World "
"<class_World>`. This is especially useful in scenarios where, for example, "
"you might want to show a separate character in 3D imposed over the game "
"(like in StarCraft)."
msgstr ""
"对于3D, 视区将包含一个:ref:`World <class_World>`类。这基本上就是一个把物理和"
"渲染联系在一起的宇宙世界。基于空间概念的节点将使用最接近的视区的世界进行注"
"册。默认情况下, 新创建的视区并不包含一个新的World对象, 而是使用与父视区相同的"
"World (但是根视区确实会包含一个World对象, 其他对象默认会渲染在里面)。可以使"
"用 \"world\" 属性在视区中设置一个世界, 这将隔离该视区的所有子节点同该视区的父"
"视区交互。这在某些情形下尤为有用, 例如, 您可能希望在游戏中以三维视角来看的上"
"方显示一个单独的字符（比如星际争霸）。"

#: ../../docs/tutorials/viewports/viewports.rst:116
#, fuzzy
msgid ""
"As a helper for situations where you want to create :ref:`Viewports "
"<class_Viewport>` that display single objects and don't want to create a :"
"ref:`World <class_World>`, :ref:`Viewport <class_Viewport>` has the option "
"to use its own :ref:`World <class_World>`. This is useful when you want to "
"instance 3D characters or objects in a 2D :ref:`World <class_World2D>`."
msgstr ""
"某些时刻您希望创建用来显示单个对象的viewport，且不想创建World, 为帮助您实现按"
"这样的需求视区提供了选项来自行指定World。当您希望在2D世界中实例化3D角色或对象"
"时, 这个选项很有用。"

#: ../../docs/tutorials/viewports/viewports.rst:121
#, fuzzy
msgid ""
"For 2D, each :ref:`Viewport <class_Viewport>` always contains its own :ref:"
"`World2D <class_World2D>`. This suffices in most cases, but in case sharing "
"them may be desired, it is possible to do so by setting the :ref:`Viewport's "
"<class_Viewport>` :ref:`World2D <class_World2D>` manually."
msgstr ""
"对于2D, 每个Viewport始终包含其自己的:ref:`World2D <class_World2D>`。在大多数"
"情况下这是足够的, 但如果需要共享World, 那么手动调用视区的 API 来实现也是可行"
"的。"

#: ../../docs/tutorials/viewports/viewports.rst:125
msgid ""
"For an example of how this works see the demo projects `3D in 2D <https://"
"github.com/godotengine/godot-demo-projects/tree/master/viewport/3d_in_2d>`_ "
"and `2D in 3D <https://github.com/godotengine/godot-demo-projects/tree/"
"master/viewport/2d_in_3d>`_ respectively."
msgstr ""

#: ../../docs/tutorials/viewports/viewports.rst:128
msgid "Capture"
msgstr "捕获"

#: ../../docs/tutorials/viewports/viewports.rst:130
#, fuzzy
msgid ""
"It is possible to query a capture of the :ref:`Viewport <class_Viewport>` "
"contents. For the root :ref:`Viewport <class_Viewport>` this is effectively "
"a screen capture. This is done with the following code:"
msgstr ""
"可以通过查询得到视区内容的一份截图。对于”根视区“, 这实际上是一个屏幕截图。这"
"是通过以下 API 完成的:"

#: ../../docs/tutorials/viewports/viewports.rst:147
#, fuzzy
msgid ""
"But if you use this in _ready() or from the first frame of the :ref:"
"`Viewport's <class_Viewport>` initialization you will get an empty texture "
"cause there is nothing to get as texture. You can deal with it using (for "
"example):"
msgstr ""
"但是要注意, 如果您在 _ready() 或视区初始化的第一帧中使用上述方法, 则会得到一"
"个空的texture, 因为没有任何纹理可供获取。您可以使用如下方法来处理这种情况（见"
"例子）:"

#: ../../docs/tutorials/viewports/viewports.rst:158
msgid ""
"If the returned image is empty, capture still didn't happen, wait a little "
"more, as Godot's rendering API is asynchronous. For a working example of "
"this check out the `Screen Capture example <https://github.com/godotengine/"
"godot-demo-projects/tree/master/viewport/screen_capture>`_ in the demo "
"projects"
msgstr ""

#: ../../docs/tutorials/viewports/viewports.rst:163
#, fuzzy
msgid "Viewport Container"
msgstr "ViewportContainer"

#: ../../docs/tutorials/viewports/viewports.rst:165
#, fuzzy
msgid ""
"If the :ref:`Viewport <class_Viewport>` is a child of a :ref:"
"`ViewportContainer <class_viewportcontainer>`, it will become active and "
"display anything it has inside. The layout looks like this:"
msgstr ""
"如果视区是:ref:`ViewportContainer <class_viewportcontainer>`的子节点, 那么它"
"将变为活动状态并显示其内部的任何内容。层级关系布局类似如下:"

#: ../../docs/tutorials/viewports/viewports.rst:169
#, fuzzy
msgid ""
"The :ref:`Viewport <class_Viewport>` will cover the area of its parent :ref:"
"`ViewportContainer <class_viewportcontainer>` completely if stretch is set "
"to true in :ref:`ViewportContainer <class_viewportcontainer>`. Note: The "
"size of the :ref:`ViewportContainer <class_viewportcontainer>` cannot be "
"smaller than the size of the :ref:`Viewport <class_Viewport>`."
msgstr ""
"如果在视区容器（Viewport Container）中将拉伸设置为 true, 则视区（Viewport）将"
"完全覆盖其父控件的区域。但您必须设置Viewport的”Size“属性才能获取合适的视区部"
"分。并且注意视区容器的尺寸不能小于视区本身的尺寸。"

#: ../../docs/tutorials/viewports/viewports.rst:174
msgid "Rendering"
msgstr ""

#: ../../docs/tutorials/viewports/viewports.rst:176
msgid ""
"Due to the fact that the :ref:`Viewport <class_Viewport>` is an entryway "
"into another rendering surface, it exposes a few rendering properties that "
"can be different from the project settings. The first is MSAA, you can "
"choose to use a different level of MSAA for each :ref:`Viewport "
"<class_Viewport>`, the default behavior is DISABLED. You can also set the :"
"ref:`Viewport <class_Viewport>` to use HDR, HDR is very useful for when you "
"want to store values in the texture that are outside the range 0.0 - 1.0."
msgstr ""

#: ../../docs/tutorials/viewports/viewports.rst:181
msgid ""
"If you know how the :ref:`Viewport <class_Viewport>` is going to be used, "
"you can set its Usage to either 3D or 2D. Godot will then restrict how the :"
"ref:`Viewport <class_Viewport>` is drawn to in accordance with your choice, "
"default is 3D."
msgstr ""

#: ../../docs/tutorials/viewports/viewports.rst:184
msgid ""
"Godot also provides a way of customizing how everything is drawn inside :ref:"
"`Viewports <class_Viewport>` using “Debug Draw”. Debug Draw allows you to "
"specify one of four options for how the :ref:`Viewport <class_Viewport>` "
"will display things drawn inside it. Debug Draw is disabled by default."
msgstr ""

#: ../../docs/tutorials/viewports/viewports.rst:190
msgid "*A scene drawn with Debug Draw disabled*"
msgstr ""

#: ../../docs/tutorials/viewports/viewports.rst:192
msgid ""
"The other three options are Unshaded, Overdraw, and Wireframe. Unshaded "
"draws the scene without using lighting information so all the objects appear "
"flatly colored the color of their albedo."
msgstr ""

#: ../../docs/tutorials/viewports/viewports.rst:198
msgid "*The same scene with Debug Draw set to Unshaded*"
msgstr ""

#: ../../docs/tutorials/viewports/viewports.rst:200
msgid ""
"Overdraw draws the meshes semi-transparent with an additive blend so you can "
"see how the meshes overlap."
msgstr ""

#: ../../docs/tutorials/viewports/viewports.rst:204
msgid "*The same scene with Debug Draw set to Overdraw*"
msgstr ""

#: ../../docs/tutorials/viewports/viewports.rst:206
msgid ""
"Lastly, Wireframe draws the scene using only the edges of triangles in the "
"meshes. NOTE: As of this writing (v3.0.2), wireframe mode is not functional "
"and currently renders the scene normally."
msgstr ""

#: ../../docs/tutorials/viewports/viewports.rst:210
msgid "Render target"
msgstr "渲染目标"

#: ../../docs/tutorials/viewports/viewports.rst:212
#, fuzzy
msgid ""
"When rendering to a :ref:`Viewport <class_Viewport>` whatever is inside will "
"not be visible in the scene editor. To display the contents, you have to "
"draw the :ref:`Viewport's <class_Viewport>` :ref:`ViewportTexture "
"<class_ViewportTexture>` somewhere. This can be requested via code using "
"(for example):"
msgstr ""
"为了启用”渲染目标“模式, 请勾选视区的 \"render target\" 属性，切换为 enable。"
"请注意, 该模式下任何视区内部的东西都不会在场景编辑器中看到。若要显示内容, 方"
"法与之前一样。可以通过使用代码 来请求到需要的内容（如下）:"

#: ../../docs/tutorials/viewports/viewports.rst:222
msgid ""
"Or it can be assigned in the editor by selecting \"New ViewportTexture\""
msgstr ""

#: ../../docs/tutorials/viewports/viewports.rst:226
msgid ""
"and then selecting the :ref:`Viewport <class_Viewport>` you want to use."
msgstr ""

#: ../../docs/tutorials/viewports/viewports.rst:230
msgid ""
"Every frame the :ref:`Viewport <class_Viewport>`'s texture is cleared away "
"with the default clear color (or a transparent color if Transparent BG is "
"set to true). This can be changed by setting Clear Mode to Never or Next "
"Frame. As the name implies, Never means the texture will never be cleared "
"while next frame will clear the texture on the next frame and then set "
"itself to Never."
msgstr ""

#: ../../docs/tutorials/viewports/viewports.rst:235
#, fuzzy
msgid ""
"By default, re-rendering of the :ref:`Viewport <class_Viewport>` happens "
"when the :ref:`Viewport <class_Viewport>`'s :ref:`ViewportTexture "
"<class_ViewportTexture>` has been drawn in a frame. If visible, it will be "
"rendered, otherwise it will not. This behavior can be changed to manual "
"rendering (once), or always render, no matter if visible or not. This "
"flexibility allows users to render an image once and then use the texture "
"without incurring the cost of rendering every frame."
msgstr ""
"默认情况下, 当”渲染目标“的纹理在某一帧被绘制时, ”渲染目标“会被重新渲染。如果"
"是可见的, 就渲染它, 反之则不。此行为可以更改为手动渲染 (一次), 或始终渲染, 无"
"论是否可见。"

#: ../../docs/tutorials/viewports/viewports.rst:243
#, fuzzy
msgid ""
"Make sure to check the Viewport demos! Viewport folder in the demos archive "
"available to download, or https://github.com/godotengine/godot-demo-projects/"
"tree/master/viewport"
msgstr ""
"请务必查看Viewport的演示项目!在可下载的demo汇总压缩包中的viewport文件夹下可以"
"找到它们，或者在这里下载 https://github.com/godotengine/godot-demo-projects/"
"tree/master/viewport"
