# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2021, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-11-19 11:09+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../docs/tutorials/content/procedural_geometry/immediategeometry.rst:4
msgid "Using ImmediateGeometry"
msgstr "使用即时几何体"

#: ../../docs/tutorials/content/procedural_geometry/immediategeometry.rst:6
msgid ""
"Unlike the SurfaceTool or ArrayMesh, :ref:`ImmediateGeometry "
"<class_ImmediateGeometry>` is an actual node. Being a node makes it quick to "
"add to a scene and get visual output. It uses an OpenGL 1.x-style API like "
"SurfaceTool, but it's actually designed to create meshes on the fly."
msgstr ""
"与SurfaceTool或ArrayMesh不同, :ref:`ImmediateGeometry "
"<class_ImmediateGeometry>` 是一个实际的节点. 作为一个节点, 它可以快速添加到场"
"景中, 并获得可视化输出. 它使用像SurfaceTool一样的OpenGL 1.x风格的API, 但它实"
"际上是为了在动态创建网格而设计的."

#: ../../docs/tutorials/content/procedural_geometry/immediategeometry.rst:10
msgid ""
"Generating complex geometry (several thousand vertices) with this node is "
"inefficient, even if it's done only once. Instead, it is designed to "
"generate simple geometry that changes every frame."
msgstr ""
"用这个节点生成复杂的几何体(几千个顶点), 即使只做一次, 效率也很低. 相反, 它的"
"设计是为了生成每一帧变化的简单几何体."

#: ../../docs/tutorials/content/procedural_geometry/immediategeometry.rst:13
msgid ""
"Before starting, you should clear the geometry by calling ``clear()``. This "
"ensures that you are not building upon the geometry from the previous frame. "
"If you want to keep geometry between frames, do not call ``clear()``."
msgstr ""
"在开始之前, 你应该通过调用 ``clear()`` 来清除几何体. 这可以确保你没有在前一帧"
"的几何体上进行构建. 如果你想在帧之间保留几何体, 不要调用 ``clear()`` ."

#: ../../docs/tutorials/content/procedural_geometry/immediategeometry.rst:17
msgid ""
"To begin generating geometry you must call ``begin()``. ``begin()`` takes a "
"``PrimitiveType`` as an argument. ``PrimitiveType`` is an OpenGL concept "
"that instructs the GPU how to arrange the primitive based on the vertices "
"given whether it is triangles, lines, points, etc. A complete list can be "
"found under the :ref:`Mesh <class_mesh>` class reference page."
msgstr ""
"要开始生成几何体, 必须调用 ``begin()`` . ``begin()`` 将一个 "
"``PrimitiveType`` 作为参数. ``PrimitiveType`` 是一个OpenGL概念, 它指示GPU如何"
"根据给定的顶点来安排基元, 无论是三角形, 线, 点等. 完整的列表可以在 :ref:"
"`Mesh <class_mesh>` 类参考页面中找到."

#: ../../docs/tutorials/content/procedural_geometry/immediategeometry.rst:22
msgid ""
"Once you have called ``begin()`` you are ready to start adding vertices. You "
"add vertices one at a time. First you add vertex specific attributes such as "
"normals or UVs using ``set_****()`` (e.g. ``set_normal()``). Then you call "
"``add_vertex()`` to add a vertex with those attributes. For example:"
msgstr ""
"一旦你调用了 ``begin()`` , 就可以开始添加顶点了. 每次添加一个顶点, 首先使用 "
"``set_ **** ()`` 添加顶点的特定属性, 如法线或UV(例如 ``set_normal()`` ). 然后"
"调用 ``add_vertex()`` 来添加一个带有这些属性的顶点. 例如 \"add_vertex()\" :"

#: ../../docs/tutorials/content/procedural_geometry/immediategeometry.rst:34
msgid ""
"Only attributes added before the call to ``add_vertex()`` will be included "
"in that vertex."
msgstr "只有在调用 ``add_vertex()`` 之前添加的属性才会被包含在该顶点中."

#: ../../docs/tutorials/content/procedural_geometry/immediategeometry.rst:36
msgid ""
"Finally, once you have added all your vertices call ``end()`` to signal that "
"you have finished generating the mesh."
msgstr "最后, 当添加了所有的顶点后, 调用 ``end()`` 来表示已经完成了网格的生成."

#: ../../docs/tutorials/content/procedural_geometry/immediategeometry.rst:38
msgid "The example code below draws a single triangle."
msgstr "下面的示例代码绘制了一个三角形."
