# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 18:00+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using Lightmap global illumination"
msgstr ""

#, fuzzy
msgid ""
"Baked lightmaps are a workflow for adding indirect (or fully baked) lighting "
"to a scene. Unlike the :ref:`VoxelGI <doc_using_voxel_gi>` and :ref:`SDFGI "
"<doc_using_sdfgi>` approaches, baked lightmaps work fine on low-end PCs and "
"mobile devices, as they consume almost no resources at run-time. Also unlike "
"VoxelGI and SDFGI, baked lightmaps can optionally be used to store direct "
"lighting, which provides even further performance gains."
msgstr ""
"烘焙的光照贴图也是一种为场景添加间接光照（也叫全烘焙光照）的工作流程。与 :"
"ref:`doc_gi_probes` 的方法不同，烘焙光照贴图在低端PC和移动设备上运行良好，因"
"为在运行时几乎不消耗资源。与 GIProbe 的另一个不同点是，烘焙光照贴图还能够用来"
"保存直接光照，可以进一步提升性能。"

#, fuzzy
msgid ""
"Unlike VoxelGI and SDFGI, baked lightmaps are completely static. Once baked, "
"they can't be modified at all. They also don't provide the scene with "
"reflections, so using :ref:`doc_reflection_probes` together with it on "
"interiors (or using a Sky on exteriors) is a requirement to get good quality."
msgstr ""
"烘焙光照贴图与 GIProbe 不同，是完全静态的，一旦被烘焙就完全不能被修改。它也不"
"能为场景提供反射，所以如果要达到较好的画质，在室内场景（或者是使用 Sky 的室外"
"场景）中就需要和 :ref:`doc_reflection_probes` 搭配使用。"

#, fuzzy
msgid ""
"As they are baked, they have fewer problems than VoxelGI and SDFGI regarding "
"light bleeding, and indirect light will often look better. The downside is "
"that baking lightmaps takes longer compared to baking VoxelGI. While baking "
"VoxelGI can be done in a matter of seconds, baking lightmaps can take "
"several minutes if not more. This can slow down iteration speed "
"significantly, so it is recommended to bake lightmaps only when you actually "
"need to see changes in lighting. Since Godot 4.0, lightmaps are baked on the "
"GPU, making light baking faster if you have a mid-range or high-end "
"dedicated GPU."
msgstr ""
"因为是烘焙出来的，所以在光线渗透方面的问题就比 ``GIProbe`` 少很多，并且间接光"
"照也会看上去更漂亮。烘焙光照贴图的缺点是烘焙所需的时间比 GIProbe 长很多，"
"GIProbe 几秒钟就能搞定的烘焙，换成烘焙光照贴图就可能至少得花上几分钟。这会严"
"重拖慢迭代速度，所以推荐只在确实有查看光照变化的需求时进行光照贴图的烘焙。"

#, fuzzy
msgid ""
"Baking lightmaps will also reserve baked materials' UV2 slot, which means "
"you can no longer use it for other purposes in materials (either in the "
"built-in :ref:`doc_standard_material_3d` or in custom shaders)."
msgstr ""
"烘焙光照贴图还会占用被烘焙材质的 UV2 栏位，也就是说你无法再把 UV2 用于该材质"
"的其它用途（无论是内置的 :ref:`doc_spatial_material` 还是自定义着色器）。"

msgid ""
"Despite their lack of flexibility, baked lightmaps typically offer both the "
"best quality *and* performance at the same time in (mostly) static scenes. "
"This makes lightmaps still popular in game development, despite lightmaps "
"being the oldest technique for global illumination in video games."
msgstr ""

msgid ""
"Not sure if LightmapGI is suited to your needs? See :ref:"
"`doc_introduction_to_global_illumination_comparison` for a comparison of GI "
"techniques available in Godot 4."
msgstr ""

msgid "Visual comparison"
msgstr "视觉比较"

msgid "LightmapGI disabled."
msgstr ""

msgid "LightmapGI enabled (with indirect light baked only)."
msgstr ""

msgid ""
"LightmapGI enabled (with indirect light baked only). Direct light is still "
"real-time, allowing for subtle changes during gameplay."
msgstr ""

msgid "LightmapGI enabled (with direct and indirect light baked)."
msgstr ""

msgid ""
"LightmapGI enabled (with direct and indirect light baked). Best performance, "
"but lower quality visuals. Notice the blurrier sun shadow in the top-right "
"corner."
msgstr ""

#, fuzzy
msgid ""
"Here are some comparisons of how LightmapGI vs. VoxelGI look. Notice that "
"lightmaps are more accurate, but also suffer from the fact that lighting is "
"on an unwrapped texture, so transitions and resolution may not be that good. "
"VoxelGI looks less accurate (as it's an approximation), but smoother overall."
msgstr ""
"以下是 BakedLightmap 和 GIProbe 的一些显示效果比较。可以看到光照贴图更精确，"
"但由于使用的是展开后的纹理，所以过渡以及分辨率可能就没有那么理想。GIProbe 看"
"上去没有那么精确（因为是近似估算），但总体上更平滑。"

msgid ""
"SDFGI is also less accurate compared to LightmapGI. However, SDFGI can "
"support large open worlds without any need for baking."
msgstr ""

msgid "Setting up"
msgstr "设置"

msgid ""
"First of all, before the lightmapper can do anything, the objects to be "
"baked need an UV2 layer and a texture size. An UV2 layer is a set of "
"secondary texture coordinates that ensures any face in the object has its "
"own place in the UV map. Faces must not share pixels in the texture."
msgstr ""
"首先，在光照贴图器可以执行任何操作之前，要烘焙的对象需要 UV2 图层和纹理大小。"
"UV2 图层是一组辅助纹理坐标，可确保对象中的任何面在 UV 贴图中都有自己的位置。"
"面与面之间不得共享纹理中的像素。"

msgid ""
"There are a few ways to ensure your object has a unique UV2 layer and "
"texture size:"
msgstr "这里有几种方法可以确保您的对象具有唯一的 UV2 层和纹理大小："

#, fuzzy
msgid "Unwrap on scene import (recommended)"
msgstr "场景导入时展开"

#, fuzzy
msgid ""
"In most scenarios, this is the best approach to use. The only downside is "
"that, on large models, unwrapping can take a while on import. Nonetheless, "
"Godot will cache the UV2 across reimports, so it will only be regenerated "
"when needed."
msgstr ""
"总体来说，这可能是最好的方法。唯一的缺点是，在大型模型上，导入时展开可能需要"
"一段时间。不过Godot会在重新导入时缓存UV2，所以只会在需要时重新生成。"

msgid ""
"Select the imported scene in the filesystem dock, then go to the **Import** "
"dock. There, the following option can be modified:"
msgstr ""
"在文件系统面板中选择被导入的场景，然后切换到\\ **导入**\\ 面板。这里可以修改"
"以下选项："

msgid ""
"The **Meshes > Light Baking** option must be set to **Static Lightmaps "
"(VoxelGI/SDFGI/LightmapGI)**:"
msgstr ""

msgid ""
"When unwrapping on import, you can adjust the texture size using the "
"**Meshes > Lightmap Texel Size** option. *Lower* values will result in more "
"detailed lightmaps, possibly resulting in higher visual quality at the cost "
"of longer bake times and larger lightmap file sizes. The default value of "
"``0.2`` is suited for small/medium-sized scenes, but you may want to "
"increase it to ``0.5`` or even more for larger scenes. This is especially "
"the case if you're baking indirect lighting only, as indirect light is low-"
"frequency data (which means it doesn't need high-resolution textures to be "
"accurately represented)."
msgstr ""

msgid ""
"The effect of setting this option is that all meshes within the scene will "
"have their UV2 maps properly generated."
msgstr "设置此选项的效果是场景中的所有网格都将正确生成其UV2贴图."

#, fuzzy
msgid ""
"When reusing a mesh within a scene, keep in mind that UVs will be generated "
"for the first instance found. If the mesh is re-used with different scales "
"(and the scales are wildly different, more than half or twice), this will "
"result in inefficient lightmaps. To avoid this, adjust the **Lightmap "
"Scale** property in the GeometryInstance3D section of a MeshInstance3D node. "
"This lets you *increase* the level of lightmap detail for specific "
"MeshInstance3D nodes (but not decrease it)."
msgstr ""
"如果在场景中复用了网格，请注意生成 UV 时只会使用第一个找到的实例。如果复用时"
"使用了不同的缩放比例（并且相差很大，超过了一半或者两倍），会导致生成低效的光"
"照贴图。如果你想用光照贴图，就不要在复用原始网格时使用明显不同的缩放比例。"

msgid ""
"Also, the ``*.unwrap_cache`` files should *not* be ignored in version "
"control as these files guarantee that UV2 reimports are consistent across "
"platforms and engine versions."
msgstr ""
"另外，请\\ *不要*\\ 在版本控制系统中忽略 ``*.unwrap_cache`` 文件，这些文件可"
"以用来保证不同平台、不同版本的引擎在重新导入 UV2 时的一致性。"

msgid "Unwrap from within Godot"
msgstr "使用 Godot 进行展开"

msgid ""
"If this Mesh menu operation is used on an imported 3D scene, the generated "
"UV2 will be lost when the scene is reloaded."
msgstr ""

#, fuzzy
msgid ""
"Godot has an option to unwrap meshes and visualize the UV channels. After "
"selecting a MeshInstance3D node, it can be found in the **Mesh** menu at the "
"top of the 3D editor viewport:"
msgstr "Godot可以选择打开网格并可视化UV通道. 它可以在Mesh菜单中找到:"

#, fuzzy
msgid ""
"This will generate a second set of UV2 coordinates which can be used for "
"baking. It will also set the texture size automatically."
msgstr "这将生成第二组UV2坐标, 可用于烘焙, 并且还将自动设置纹理大小."

#, fuzzy
msgid "Unwrap from your 3D modeling software"
msgstr "使用 3D DCC 展开"

#, fuzzy
msgid ""
"The last option is to do it from your favorite 3D app. This approach is "
"generally **not recommended**, but it's explained so that you know it "
"exists. The main advantage is that, on complex objects that you may want to "
"re-import a lot, the texture generation process can be quite costly within "
"Godot, so having it unwrapped before import can be faster."
msgstr ""
"最后一种方法是在你喜欢的 3D 应用程序中进行操作。通常不推荐这种做法，但为了让"
"你知道它的存在，这里还是解释一下。这种做法的主要优势在于，针对可能要经常重新"
"导入的复杂对象，在 Godot 中进行纹理生成的代价可能相当高，所以在导入前展开可以"
"提高速度。"

msgid "Simply do an unwrap on the second UV2 layer."
msgstr "只需在第二个UV2层上进行展开即可。"

msgid ""
"Then import the 3D scene normally. Remember you will need to set the texture "
"size on the mesh after import."
msgstr "然后正常导入 3D 场景。记得在导入后为网格设置纹理大小。"

#, fuzzy
msgid ""
"If you use external meshes on import, the size will be kept. Be wary that "
"most unwrappers in 3D modeling software are not quality-oriented, as they "
"are meant to work quickly. You will mostly need to use seams or other "
"techniques to create better unwrapping."
msgstr ""
"如果在导入时使用外部网格, 则将保留大小. 请注意,3D DCC中的大多数解包器都不是面"
"向质量的, 因为它们可以快速工作. 您通常需要使用接缝或其他技术来创建更好的展开."

#, fuzzy
msgid "Generating UV2 for primitive meshes"
msgstr "将 Sprite 转换为 2D 网格"

msgid ""
"This option is only available for primitive meshes such as :ref:"
"`class_BoxMesh`, :ref:`class_CylinderMesh`, :ref:`class_PlaneMesh`, etc."
msgstr ""

msgid ""
"Enabling UV2 on primitive meshes allows you to make them receive and "
"contribute to baked lighting. This can be used in certain lighting setups. "
"For instance, you could hide a torus that has an emissive material after "
"baking lightmaps to create an area light that follows the shape of a torus."
msgstr ""

msgid ""
"By default, primitive meshes do not have UV2 generated to save resources (as "
"these meshes may be created during gameplay). You can edit a primitive mesh "
"in the inspector and enable **Add UV2** to make the engine procedurally "
"generate UV2 for a primitive mesh. The default **UV2 Padding** value is "
"tuned to avoid most lightmap bleeding, without wasting too much space on the "
"edges. If you notice lightmap bleeding on a specific primitive mesh only, "
"you may have to increase **UV2 Padding**."
msgstr ""

msgid ""
"**Lightmap Size Hint** represents the size taken by a single mesh on the "
"lightmap texture, which varies depending on the mesh's size properties and "
"the **UV2 Padding** value. **Lightmap Size Hint** should not be manually "
"changed, as any modifications will be lost when the scene is reloaded."
msgstr ""

msgid "Checking UV2"
msgstr "检查 UV2"

#, fuzzy
msgid ""
"In the **Mesh** menu mentioned before, the UV2 texture coordinates can be "
"visualized. If something is failing, double-check that the meshes have these "
"UV2 coordinates:"
msgstr ""
"在前面提到的网格菜单中, 可以显示UV2纹理坐标. 如果出现问题, 请确保检查网格是否"
"具有以下UV2坐标:"

msgid "Setting up the scene"
msgstr "设置场景"

#, fuzzy
msgid ""
"Before anything is done, a **LightmapGI** node needs to be added to a scene. "
"This will enable light baking on all nodes (and sub-nodes) in that scene, "
"even on instanced scenes."
msgstr ""
"首先需要在场景中添加一个 **BakedLightmap** 节点。添加后，场景中的所有节点（和"
"子节点）就都可以进行光照烘焙了，甚至实例化的场景也可以。"

#, fuzzy
msgid ""
"A sub-scene can be instanced several times, as this is supported by the "
"baker. Each instance will be assigned a lightmap of its own. To avoid issues "
"with inconsistent lightmap texel scaling, make sure to respect the rule "
"about mesh scaling mentioned before."
msgstr ""
"烘焙器支持同一子场景存在多个实例，它们会有各自独立的光照贴图（前提是你得遵守"
"之前提过的关于缩放的规则）："

msgid "Setting up meshes"
msgstr "设置网格"

#, fuzzy
msgid ""
"For a **MeshInstance3D** node to take part in the baking process, it needs "
"to have its bake mode set to **Static**. Meshes that have their bake mode "
"set to **Disabled** or **Dynamic** will be ignored by the lightmapper."
msgstr ""
"如果需要让 **MeshInstance** 节点参与烘焙，需要启用 **Use in Baked Light** 属"
"性。"

msgid ""
"When auto-generating lightmaps on scene import, this is enabled "
"automatically."
msgstr "在场景导入时自动生成光照贴图时, 会自动启用此功能."

msgid "Setting up lights"
msgstr "设置灯光"

#, fuzzy
msgid ""
"Lights are baked with indirect light only by default. This means that "
"shadowmapping and lighting are still dynamic and affect moving objects, but "
"light bounces from that light will be baked."
msgstr ""
"默认情况下, 灯光采用间接灯光烘焙. 这意味着阴影贴图和光照仍然是动态的并影响移"
"动的物体, 但是光线反射的光将被烘焙."

msgid ""
"Lights can be disabled (no bake) or be fully baked (direct and indirect). "
"This can be controlled from the **Bake Mode** menu in lights:"
msgstr ""
"灯可以禁用(不烘焙)或完全烘焙(直接和间接). 这可以通过灯光中的 **烘焙模式** 菜"
"单进行控制:"

msgid "The modes are:"
msgstr "模式有："

msgid "Disabled"
msgstr "Disabled（禁用）"

msgid ""
"The light is ignored when baking lightmaps. Keep in mind hiding a light will "
"have no effect for baking, so this must be used instead of hiding the Light "
"node."
msgstr ""
"烘焙光照贴图时忽略灯光。注意烘焙时隐藏灯光是无效的，必须在这里设置禁用才能达"
"到隐藏灯光节点的效果。"

msgid ""
"This is the mode to use for dynamic lighting effects such as explosions and "
"weapon effects."
msgstr "这个模式可以用于动态光照效果，例如爆炸和武器特效。"

#, fuzzy
msgid "Dynamic"
msgstr "动态的："

#, fuzzy
msgid ""
"This is the default mode, and is a compromise between performance and real-"
"time friendliness. Only indirect lighting will be baked. Direct light and "
"shadows are still real-time, as they would be without LightmapGI."
msgstr ""
"这是默认的模式，是性能与实时友好性的折衷。只会烘焙间接光照。直接灯光和阴影仍"
"旧是实时的，与不使用 BakedLightmap 时一致。"

msgid ""
"This mode allows performing *subtle* changes to a light's color, energy and "
"position while still looking fairly correct. For example, you can use this "
"to create flickering static torches that have their indirect light baked."
msgstr ""
"这个模式可以在保持显示效果相对正确的同时，允许进行灯光颜色、能量、以及位置的 "
"*微调* 。例如，你可以借此实现静态火把的闪烁，它的间接光照仍然是烘焙的。"

#, fuzzy
msgid "Static"
msgstr "静态的："

#, fuzzy
msgid ""
"Both indirect and direct lighting will be baked. Since static surfaces can "
"skip lighting and shadow computations entirely, this mode provides the best "
"performance along with smooth shadows that never fade based on distance. The "
"real-time light will not affect baked surfaces anymore, but it will still "
"affect dynamic objects. When using the **All** bake mode on a light, dynamic "
"objects will not cast real-time shadows onto baked surfaces, so you need to "
"use a different approach such as blob shadows instead. Blob shadows can be "
"implemented with a Decal node."
msgstr ""
"间接和直接光照都会被烘焙。因为静态表面可以完全跳过光照和阴影的计算，所以这个"
"模式可以提供最佳的性能，并且实现不随距离衰减的平滑的阴影。实时灯光不会再影响"
"烘焙的表面，但仍然可以影响动态的对象。在光源上使用 **All** （全部）烘焙模式"
"时，动态对象不会在烘焙表面上投射阴影，所以你需要使用别的方法，比如软阴影。软"
"阴影既可以通过 Sprite3D + RayCast 实现，也可以通过把朝下的反 SpotLight 的烘焙"
"模式设置成 **禁用** 实现。"

#, fuzzy
msgid ""
"The light will not be adjustable at all during gameplay. Moving the light or "
"changing its color (or energy) will not have any effect on static surfaces."
msgstr ""
"游戏过程中无法调整灯光。灯光的移动、变色、能量调整不会对静态表面产生影响。"

#, fuzzy
msgid ""
"Since bake modes can be adjusted on a per-light basis, it is possible to "
"create hybrid baked light setups. One popular option is to use a real-time "
"DirectionalLight with its bake mode set to **Dynamic**, and use the "
"**Static** bake mode for OmniLights and SpotLights. This provides good "
"performance while still allowing dynamic objects to cast real-time shadows "
"in outdoor areas."
msgstr ""
"因为烘焙模式可以分光源调整，所以可以设置出混合的烘焙光照。一个比较流行的做法"
"是使用实时 DirectionalLight 并把它的烘焙模式设置成 **Indirect**\\ ，然后把 "
"OmniLight 和 SpotLight 的烘焙模式都设置成 **All**\\ 。这样做的性能不错，同时"
"也允许动态对象在室外投射实时阴影。"

msgid ""
"Fully baked lights can also make use of light nodes' **Size** (omni/spot) or "
"**Angular Distance** (directional) properties. This allows for shadows with "
"realistic penumbra that increases in size as the distance between the caster "
"and the shadow increases. This also has a lower performance cost compared to "
"real-time PCSS shadows, as only dynamic objects have real-time shadows "
"rendered on them."
msgstr ""

msgid "Baking"
msgstr "烘焙"

#, fuzzy
msgid ""
"To begin the bake process, click the **Bake Lightmaps** button at the top of "
"the 3D editor viewport when selecting the LightmapGI node:"
msgstr ""
"开始烘焙只需在选中 BakedLightmap 节点后点击上方的 **烘焙光照贴图** 按钮："

msgid ""
"This can take from seconds to minutes (or hours) depending on scene size, "
"bake method and quality selected."
msgstr ""
"根据场景大小、所选烘焙方法以及质量的不同，其过程可能花费几秒钟到几分钟不等"
"（也可能是几小时）。"

msgid ""
"Baking lightmaps is a process that can require a lot of video memory, "
"especially if the resulting texture is large. Due to internal limitations, "
"the engine may also crash if the generated texture size is too large (even "
"on systems with a lot of video memory)."
msgstr ""

msgid ""
"To avoid crashes, make sure the lightmap texel size in the Import dock is "
"set to a high enough value."
msgstr ""

msgid "Tweaks"
msgstr "Tweaks（调整）"

#, fuzzy
msgid ""
"**Quality:** Four bake quality modes are provided: Low, Medium, High, and "
"Ultra. Higher quality takes more time, but result in a better-looking "
"lightmap with less noise. The difference is especially noticeable with "
"emissive materials or areas that get little to no direct lighting. Each bake "
"quality mode can be further adjusted in the Project Settings."
msgstr ""
"**Quality（质量）**\\ ：提供了四种烘焙质量：Low（低级）、Medium（中级）、High"
"（高级）、Ultra（超级）。质量越高所需的时间越长，但最终光照贴图的显示效果越"
"好、噪点也越少。针对发光材质或者几乎没有直接光照的地方，不同质量之间的区别尤"
"为显著。"

#, fuzzy
msgid ""
"**Bounces:** The number of bounces to use for indirect lighting. The default "
"value (``3``) is a good compromise between bake times and quality. Higher "
"values will make light bounce around more times before it stops, which makes "
"indirect lighting look smoother (but also brighter). During the initial "
"lighting iteration work, it is recommended to decrease the number of bounces "
"to ``1`` to speed up baking. Remember that your scene will be darker when "
"decreasing the number of bounces."
msgstr ""
"**Bounces（反弹）** ：间接光照的反弹次数。默认值（3）是烘焙时间和质量之间的一"
"个平衡点。取值越高，光线在停止之前反弹的次数越多，间接光照的效果也就越好（同"
"时也越亮）。在做最初的光照迭代工作时，建议把反弹次数减小到 1，这样可以加快烘"
"焙速度。注意降低反弹次数会让场景变暗。"

msgid ""
"**Directional:** If enabled, stores directional information for lightmaps. "
"This improves normal mapped materials' appearance for baked surfaces, "
"especially with fully baked lights (since they also have direct light "
"baked). The downside is that directional lightmaps are slightly more "
"expensive to render. They also require more time to bake and result in "
"larger file sizes."
msgstr ""

msgid ""
"**Interior:** If enabled, environment lighting will not be sourced. Use this "
"for purely indoor scenes to avoid light leaks."
msgstr ""

#, fuzzy
msgid ""
"**Use Denoiser:** If enabled, uses `OpenImageDenoise <https://www."
"openimagedenoise.org/>`__ to make the lightmap significantly less noisy. "
"This increases bake times and can occasionally introduce artifacts, but the "
"result is often worth it. **All** bake mode on a light, this will turn "
"colored lighting into grayscale lighting. This can be disabled together with "
"HDR to get the smallest possible lightmap file at a given resolution."
msgstr ""
"**Use Color（使用彩色）** ：禁用时，光照贴图会占用更少的磁盘空间，但就会无法"
"保存彩色灯光。仅烘焙间接光照时，由于间接灯光通常对比度不高，所以可能几乎看不"
"出区别。然而使用 **All** 烘焙模式同时烘焙直接和间接光照时，就会导致彩色灯光变"
"成灰度灯光。该选项和 HDR 一起禁用后可以得到相同分辨率下最小的光照贴图。"

#, fuzzy
msgid ""
"**Bias:** The offset value to use for shadows in 3D units. You generally "
"don't need to change this value, except if you run into issues with light "
"bleeding or dark spots in your lightmap after baking. This setting does not "
"affect real-time shadows casted on baked surfaces (for lights with "
"**Dynamic** bake mode)."
msgstr ""
"**Bias（偏置）** ：阴影的偏移量，使用 3D 单位。除非你遇到了光线渗透问题或者光"
"照贴图在烘焙后存在暗区，否则通常情况下不需要修改这个值。该选项不会影响投射在"
"烘焙表面上的实时阴影。"

msgid ""
"**Max Texture Size:** The maximum texture size for the generated texture "
"atlas. Higher values will result in fewer slices being generated, but may "
"not work on all hardware as a result of hardware limitations on texture "
"sizes. Leave this at its default value of ``16384`` if unsure."
msgstr ""

msgid ""
"**Environment > Mode:** Controls how environment lighting is sourced when "
"baking lightmaps. The default value of **Scene** is suited for levels with "
"visible exterior parts. For purely indoor scenes, set this to **Disabled** "
"to avoid light leaks and speed up baking. This can also be set to **Custom "
"Sky** or **Custom Color** to use environment lighting that differs from the "
"actual scene's environment sky."
msgstr ""

msgid ""
"**Gen Probes > Subdiv:** See :ref:`doc_using_lightmap_gi_dynamic_objects`."
msgstr ""

msgid "**Data > Light Data:** See :ref:`doc_using_lightmap_gi_data`."
msgstr ""

msgid "Balancing bake times with quality"
msgstr "平衡烘焙时间和质量"

#, fuzzy
msgid ""
"Since high-quality bakes can take very long (up to dozens of minutes for "
"large complex scenes), it is recommended to use lower quality settings at "
"first. Then, once you are confident with your scene's lighting setup, raise "
"the quality settings and perform a \"final\" bake before exporting your "
"project."
msgstr ""
"因为高质量的烘焙可能花费非常长的时间（大型复杂场景可能需要若干小时），推荐首"
"先设置成较低质量，将场景中的灯光布置成满意的效果后再改成较高的质量，在导出项"
"目前进行“终极”烘焙。"

msgid ""
"Reducing the lightmap resolution by increasing **Lightmap Texel Size** on "
"the imported 3D scenes will also speed up baking significantly. However, "
"this will require you to reimport all lightmapped 3D scenes before you can "
"bake lightmaps again."
msgstr ""

msgid "Dynamic objects"
msgstr "动态对象"

msgid ""
"Unlike VoxelGI and SDFGI, dynamic objects receive indirect lighting "
"differently compared to static objects. This is because lightmapping is only "
"performed on static objects."
msgstr ""

msgid ""
"To display indirect lighting on dynamic objects, a 3D probe system is used, "
"with light probes being spread throughout the scene. When baking lightmaps, "
"the lightmapper will calculate the amount of *indirect* light received by "
"the probe. Direct light is not stored within light probes, even for lights "
"that have their bake mode set to **Static** (as dynamic objects continue to "
"be lit in real-time)."
msgstr ""

#, fuzzy
msgid "There are 2 ways to add light probes to a scene:"
msgstr "有两种方法可以导出服务项目:"

msgid ""
"**Automatic:** Set **Gen Probes > Subdiv** to a value other than "
"**Disabled**, then bake lightmaps. The default is ``8``, but you can choose "
"a greater value to improve precision at the cost of longer bake times and "
"larger output file size."
msgstr ""

msgid ""
"**Manual:** In addition or as an alternative to generating probes "
"automatically, you can add light probes manually by adding :ref:"
"`class_LightmapProbe` nodes to the scene. This can be used to improve "
"lighting detail in areas frequently travelled by dynamic objects. After "
"placing LightmapProbe nodes in the scene, you must bake lightmaps again for "
"them to be effective."
msgstr ""

msgid ""
"After baking lightmaps, you will notice white spheres in the 3D scene that "
"represent how baked lighting will affect dynamic objects. These spheres do "
"**not** appear in the running project."
msgstr ""

msgid ""
"If you want to hide these spheres in the editor, toggle **View > Gizmos > "
"LightmapGI** at the top of the 3D editor (a \"closed eye\" icon indicates "
"the gizmo is hidden)."
msgstr ""

msgid "Lightmap data"
msgstr ""

#, fuzzy
msgid ""
"The **Data > Light Data** property in the LightmapGI node contains the "
"lightmap data after baking. Textures are saved to disk, but this also "
"contains the capture data for dynamic objects, which can be heavy. If you "
"are using a scene in ``.tscn`` format, you should save this resource to an "
"external binary ``.lmbake`` file to avoid bloating the ``.tscn`` scene with "
"binary data encoded in Base64."
msgstr ""
"**Light Data（光照数据）** ：烘焙后包含光照烘焙数据。纹理会被保存到磁盘上，但"
"这里还会包含动态对象的捕获数据，数据量可能非常大。如果你使用的是 ``.tscn`` 格"
"式的场景，应该将此资源保存成外部的二进制 ``.lmbake`` 文件，否则 ``.tscn`` 场"
"景可能因为使用 Base64 编码二进制数据而变得巨大。"

msgid ""
"The generated EXR file can be viewed and even edited using an image editor "
"to perform post-processing if needed. However, keep in mind that changes to "
"the EXR file will be lost when baking lightmaps again."
msgstr ""
"如果有后期处理的需要，可以使用图像编辑器查看并编辑所生成的 EXR 文件。不过请注"
"意，重新烘焙贴图会覆盖你对 EXR 文件的修改。"

msgid "Translation status"
msgstr "翻译状态"
