# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2021, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-03-31 15:34+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:4
#, fuzzy
msgid "GPU optimization"
msgstr "优化"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:7
msgid "Introduction"
msgstr "简介"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:9
msgid ""
"The demand for new graphics features and progress almost guarantees that you "
"will encounter graphics bottlenecks. Some of these can be on the CPU side, "
"for instance in calculations inside the Godot engine to prepare objects for "
"rendering. Bottlenecks can also occur on the CPU in the graphics driver, "
"which sorts instructions to pass to the GPU, and in the transfer of these "
"instructions. And finally, bottlenecks also occur on the GPU itself."
msgstr ""
"对新的图形功能和进步的需求几乎可以保证你必会遇到图形瓶颈。有些瓶颈可能出现在"
"CPU端，例如在Godot引擎内部的计算中，为渲染准备对象。瓶颈也可能发生在CPU上的图"
"形驱动中，它将指令分类传递给GPU，以及这些指令的传输过程。最后，瓶颈也会发生在"
"GPU本身。"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:16
msgid ""
"Where bottlenecks occur in rendering is highly hardware-specific. Mobile "
"GPUs in particular may struggle with scenes that run easily on desktop."
msgstr ""
"渲染中的瓶颈发生在哪里，高度依赖于硬件。特别是移动GPU可能会在桌面上轻松运行的"
"场景中挣扎。"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:19
msgid ""
"Understanding and investigating GPU bottlenecks is slightly different to the "
"situation on the CPU. This is because, often, you can only change "
"performance indirectly by changing the instructions you give to the GPU. "
"Also, it may be more difficult to take measurements. In many cases, the only "
"way of measuring performance is by examining changes in the time spent "
"rendering each frame."
msgstr ""
"了解和调查GPU瓶颈与CPU上的情况略有不同。这是因为，通常情况下，你只能通过改变"
"你给GPU的指令来间接改变性能。另外，测量起来可能更困难。在许多情况下，衡量性能"
"的唯一方法是通过检查每帧渲染时间的变化。"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:26
msgid "Draw calls, state changes, and APIs"
msgstr "绘制调用，状态更变和api"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:28
msgid ""
"The following section is not relevant to end-users, but is useful to provide "
"background information that is relevant in later sections."
msgstr "以下部分与最终用户无关，但对于提供与后面章节相关的背景信息是有用的。"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:31
msgid ""
"Godot sends instructions to the GPU via a graphics API (OpenGL, OpenGL ES or "
"Vulkan). The communication and driver activity involved can be quite costly, "
"especially in OpenGL and OpenGL ES. If we can provide these instructions in "
"a way that is preferred by the driver and GPU, we can greatly increase "
"performance."
msgstr ""
"Godot通过图形API（OpenGL、OpenGL ES或Vulkan）向GPU发送指令。所涉及的通信和驱"
"动活动可能非常昂贵，尤其是在OpenGL和OpenGL ES中。如果我们能以驱动和GPU喜欢的"
"方式提供这些指令，就能大大提高性能。"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:37
msgid ""
"Nearly every API command in OpenGL requires a certain amount of validation "
"to make sure the GPU is in the correct state. Even seemingly simple commands "
"can lead to a flurry of behind-the-scenes housekeeping. Therefore, the goal "
"is to reduce these instructions to a bare minimum and group together similar "
"objects as much as possible so they can be rendered together, or with the "
"minimum number of these expensive state changes."
msgstr ""
"OpenGL中几乎每一个API命令都需要一定的验证，以确保GPU处于正确的状态。即使是看"
"似简单的命令，也会导致一连串的幕后工作。因此，我们的目标是将这些指令减少到最"
"低限度，并尽可能地将相似的对象分组，以便它们可以一起渲染，或者以最少的数量进"
"行这些昂贵的状态变化。"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:45
#, fuzzy
msgid "2D batching"
msgstr "搜索"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:47
msgid ""
"In 2D, the costs of treating each item individually can be prohibitively "
"high - there can easily be thousands of them on the screen. This is why 2D "
"*batching* is used. Multiple similar items are grouped together and rendered "
"in a batch, via a single draw call, rather than making a separate draw call "
"for each item. In addition, this means state changes, material and texture "
"changes can be kept to a minimum."
msgstr ""
"在2D中，单独处理每个项目的成本可能会非常高--屏幕上很容易有成千上万的项目。这"
"就是为什么使用2D *批处理* 的原因。多个类似的项目被归为一组，并通过一个单一的"
"绘制调用进行批量渲染，而不是对每个项目进行单独的绘制调用。此外，这意味着状态"
"变化、材质和纹理变化可以保持在最低限度。"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:54
#, fuzzy
msgid "For more information on 2D batching, see :ref:`doc_batching`."
msgstr "有关光线烘焙的更多信息，请参阅 :ref:`doc_baked_lightmaps`。"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:57
#, fuzzy
msgid "3D batching"
msgstr "搜索"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:59
msgid ""
"In 3D, we still aim to minimize draw calls and state changes. However, it "
"can be more difficult to batch together several objects into a single draw "
"call. 3D meshes tend to comprise hundreds or thousands of triangles, and "
"combining large meshes in real-time is prohibitively expensive. The costs of "
"joining them quickly exceeds any benefits as the number of triangles grows "
"per mesh. A much better alternative is to **join meshes ahead of time** "
"(static meshes in relation to each other). This can either be done by "
"artists, or programmatically within Godot."
msgstr ""
"在3D中，我们的目标仍然是尽量减少绘制调用和状态变化。然而，将多个对象批量合并"
"到一个绘图调用中可能比较困难。3D网格往往由数百个或数千个三角形组成，而实时组"
"合大型网格的成本非常高。随着每个网格的三角形数量的增加，加入它们的成本很快就"
"超过了带来的好处。一个更好的选择是 **提前加入网格** （静态网格之间的关系）。"
"这可以由设计师完成，或者在Godot中以编程方式完成。"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:67
msgid ""
"There is also a cost to batching together objects in 3D. Several objects "
"rendered as one cannot be individually culled. An entire city that is off-"
"screen will still be rendered if it is joined to a single blade of grass "
"that is on screen. Thus, you should always take objects' location and "
"culling into account when attempting to batch 3D objects together. Despite "
"this, the benefits of joining static objects often outweigh other "
"considerations, especially for large numbers of distant or low-poly objects."
msgstr ""
"在3D中把物体批处理在一起也是有成本的。几个对象渲染成一个，就不能单独剔除。如"
"果将屏幕外的整座城市与屏幕上的一片草地连接在一起，那么它仍然会被渲染。因此，"
"当试图将3D对象批量连接在一起时，应该始终考虑到对象的位置和剔除。尽管如此，加"
"入静态对象的好处往往大于其他考虑因素，特别是对于大量的远距离或低多边形物体。"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:75
msgid ""
"For more information on 3D specific optimizations, see :ref:"
"`doc_optimizing_3d_performance`."
msgstr ""
"有关特定于3D的优化的更多信息，请参阅 :ref:`doc_optimizing_3d_performance`。"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:79
#, fuzzy
msgid "Reuse Shaders and Materials"
msgstr "重复使用着色器和材质"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:81
#, fuzzy
msgid ""
"The Godot renderer is a little different to what is out there. It's designed "
"to minimize GPU state changes as much as possible. :ref:`SpatialMaterial "
"<class_SpatialMaterial>` does a good job at reusing materials that need "
"similar shaders.  if custom shaders are used, make sure to reuse them as "
"much as possible. Godot's priorities are:"
msgstr ""
"Godot渲染器与其他的渲染器略有不同。 它旨在尽可能减少GPU状态的变化。 :ref:"
"`class_SpatialMaterial` 在重用需要类似着色器的材质方面做得很好但是，如果使用"
"自定义着色器，请确保尽可能多地重用它们。 Godot的优先事项如下:"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:87
#, fuzzy
msgid ""
"**Reusing Materials:** The fewer different materials in the scene, the "
"faster the rendering will be. If a scene has a huge amount of objects (in "
"the hundreds or thousands), try reusing the materials. In the worst case, "
"use atlases to decrease the amount of texture changes."
msgstr ""
"**重复使用材质**:场景中不同的材质越少，渲染速度就越快。 如果一个场景有大量的"
"物体(数百或数千)，请尝试重复使用这些材质，或者，在最坏的情况下，使用图集。"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:91
#, fuzzy
msgid ""
"**Reusing Shaders:** If materials can't be reused, at least try to re-use "
"shaders (or SpatialMaterials with different parameters but the same "
"configuration)."
msgstr ""
"**重用着色器**: 如果材质无法重复使用，至少尝试重新使用着色器(或具有不同参数但"
"配置相同的SpatialMaterials)。"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:95
#, fuzzy
msgid ""
"If a scene has, for example, ``20,000`` objects with ``20,000`` different "
"materials each, rendering will be slow. If the same scene has ``20,000`` "
"objects, but only uses ``100`` materials, rendering will be much faster."
msgstr ""
"例如，如果一个场景有20.000个对象，每个对象有20.000个不同的材质，那么渲染将会"
"很慢。如果同一场景有20.000个对象，但只使用100个素材，渲染将非常迅速。"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:100
#, fuzzy
msgid "Pixel cost versus vertex cost"
msgstr "像素成本vs顶点成本"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:102
#, fuzzy
msgid ""
"You may have heard that the lower the number of polygons in a model, the "
"faster it will be rendered. This is *really* relative and depends on many "
"factors."
msgstr ""
"人们普遍认为，模型中多边形的数量越少，渲染的速度就越快。这是 *非常* 相对的，"
"取决于很多因素。"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:105
#, fuzzy
msgid ""
"On a modern PC and console, vertex cost is low. GPUs originally only "
"rendered triangles. This meant that every frame:"
msgstr ""
"在现代PC和控制台上，顶点成本很低。 GPU最初只渲染三角形，所以所有顶点都是:"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:108
#, fuzzy
msgid "All vertices had to be transformed by the CPU (including clipping)."
msgstr "要被CPU变换(包括剪裁)。"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:109
#, fuzzy
msgid "All vertices had to be sent to the GPU memory from the main RAM."
msgstr "要从主RAM发送到GPU内存。"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:111
#, fuzzy
msgid ""
"Nowadays, all this is handled inside the GPU, greatly increasing "
"performance. 3D artists usually have the wrong feeling about polycount "
"performance because 3D DCCs (such as Blender, Max, etc.) need to keep "
"geometry in CPU memory for it to be edited, reducing actual performance. "
"Game engines rely on the GPU more, so they can render many triangles much "
"more efficiently."
msgstr ""
"如今，所有这些都是在GPU内部处理的，因此性能非常高。 3D艺术家通常对多计数性能"
"有错误的感觉，因为3D DCC(例如Blender，Max等)需要将几何保留在CPU内存中以便进行"
"编辑，从而降低实际性能。 事实上，3D引擎渲染的模型比3D DCC显示模型更加优化。"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:117
#, fuzzy
msgid ""
"On mobile devices, the story is different. PC and console GPUs are brute-"
"force monsters that can pull as much electricity as they need from the power "
"grid. Mobile GPUs are limited to a tiny battery, so they need to be a lot "
"more power efficient."
msgstr ""
"在移动设备上又是另一个故事了。 PC和控制台GPU是蛮力的怪物，可以从电网中获取所"
"需的电量。移动GPU仅限于小型电池，因此它们需要更高的能量使用效率。"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:122
#, fuzzy
msgid ""
"To be more efficient, mobile GPUs attempt to avoid *overdraw*. Overdraw "
"occurs when the same pixel on the screen is being rendered more than once. "
"Imagine a town with several buildings. GPUs don't know what is visible and "
"what is hidden until they draw it. For example, a house might be drawn and "
"then another house in front of it (which means rendering happened twice for "
"the same pixel). PC GPUs normally don't care much about this and just throw "
"more pixel processors to the hardware to increase performance (which also "
"increases power consumption)."
msgstr ""
"为了提高效率，移动GPU试图避免 *透支* 。 这意味着，屏幕上的相同像素被渲染(如，"
"通过照明计算等)不止一次。 想象一个有几座建筑的小镇，GPU不知道什么是可见的，什"
"么是隐藏的，直到它们绘制它。 GPU可能会绘制一个房子，然后在它前面的另一个房子"
"(对于同一个像素渲染两次！)。 PC GPU通常不关心这一点，只是将更多像素处理器投入"
"硬件以提高性能(但这也增加了功耗)。"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:130
#, fuzzy
msgid ""
"Using more power is not an option on mobile so mobile devices use a "
"technique called *tile-based rendering* which divides the screen into a "
"grid. Each cell keeps the list of triangles drawn to it and sorts them by "
"depth to minimize *overdraw*. This technique improves performance and "
"reduces power consumption, but takes a toll on vertex performance. As a "
"result, fewer vertices and triangles can be processed for drawing."
msgstr ""
"在移动设备上，提供更多能量不是一种选择，因此使用了一种称为“Tile Based "
"Rendering(基于图块渲染)”的技术(几乎每个移动硬件都使用它的一种变体)，它将屏幕"
"划分为网格。 每个单元格保留绘制到它的三角形列表，并按深度对它们进行排序，以最"
"小化 *重绘* 。 这种技术可以提高性能并降低功耗，但会降低顶点性能。 因此，可以"
"处理进行绘制更少的顶点和三角形。"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:137
#, fuzzy
msgid ""
"Additionally, tile-based rendering struggles when there are small objects "
"with a lot of geometry within a small portion of the screen. This forces "
"mobile GPUs to put a lot of strain on a single screen tile, which "
"considerably decreases performance as all the other cells must wait for it "
"to complete before displaying the frame."
msgstr ""
"一般来说，这并不是那么糟糕，但在移动设备上有一个必须避免的特殊情况，即在屏幕"
"的一小部分内具有大量几何形状的小物体。 这迫使移动GPU在单个屏幕单元上用很大的"
"力气，大大降低了性能(因为所有其他单元必须等待它完成才能显示帧)。"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:143
#, fuzzy
msgid ""
"To summarize, don't worry about vertex count on mobile, but **avoid "
"concentration of vertices in small parts of the screen**. If a character, "
"NPC, vehicle, etc. is far away (which means it looks tiny), use a smaller "
"level of detail (LOD) model. Even on desktop GPUs, it's preferable to avoid "
"having triangles smaller than the size of a pixel on screen."
msgstr ""
"简单地说，不要太担心移动设备上的顶点数量，但要避免在屏幕的小部分中集中顶点。 "
"例如，如果角色，NPC，车辆等距离较远(因此看起来很小)，请使用细节程度(Level of "
"detail, LOD) 较小的模型。"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:149
msgid "Pay attention to the additional vertex processing required when using:"
msgstr "使用时要注意额外的顶点处理:"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:151
msgid "Skinning (skeletal animation)"
msgstr "蒙皮(骨骼动画)"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:152
msgid "Morphs (shape keys)"
msgstr "变形(形态键)"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:153
#, fuzzy
msgid "Vertex-lit objects (common on mobile)"
msgstr "顶点照明对象(在移动设备上常见)"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:156
msgid "Pixel/fragment shaders and fill rate"
msgstr "像素/片段着色器和填充速率"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:158
msgid ""
"In contrast to vertex processing, the costs of fragment (per-pixel) shading "
"have increased dramatically over the years. Screen resolutions have "
"increased (the area of a 4K screen is 8,294,400 pixels, versus 307,200 for "
"an old 640×480 VGA screen, that is 27x the area), but also the complexity of "
"fragment shaders has exploded. Physically-based rendering requires complex "
"calculations for each fragment."
msgstr ""
"与顶点处理相比，片段着色器（每像素）的成本在这些年里急剧增加。屏幕分辨率提高"
"了（4K屏幕的面积是829400像素，而老式640×480 VGA屏幕的面积是307200，是27倍），"
"但片段着色器的复杂度也爆炸式增长。基于物理的渲染需要对每个片段进行复杂的计"
"算。"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:165
msgid ""
"You can test whether a project is fill rate-limited quite easily. Turn off V-"
"Sync to prevent capping the frames per second, then compare the frames per "
"second when running with a large window, to running with a very small "
"window. You may also benefit from similarly reducing your shadow map size if "
"using shadows. Usually, you will find the FPS increases quite a bit using a "
"small window, which indicates you are to some extent fill rate-limited. On "
"the other hand, if there is little to no increase in FPS, then your "
"bottleneck lies elsewhere."
msgstr ""
"你可以很容易地测试一个项目是否受到填充率限制。关闭V-Sync以防止每秒帧数的上"
"限，然后比较使用大窗口运行时的每秒帧数和使用非常小的窗口运行时的帧数。如果使"
"用阴影，你也可以从同样减少阴影贴图大小中获益。通常，你会发现使用小窗口的FPS会"
"增加不少，这说明你在某种程度上受到了填充率的限制。另一方面，如果FPS几乎没有增"
"加，那么你的瓶颈就在其他地方。"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:174
msgid ""
"You can increase performance in a fill rate-limited project by reducing the "
"amount of work the GPU has to do. You can do this by simplifying the shader "
"(perhaps turn off expensive options if you are using a :ref:`SpatialMaterial "
"<class_SpatialMaterial>`), or reducing the number and size of textures used."
msgstr ""
"你可以通过减少GPU的工作量来提高填充率限制项目的性能。你可以通过简化着色器（如"
"果你使用的是 :ref:`SpatialMaterial <class_SpatialMaterial> `，也许可以关闭昂"
"贵的选项），或者减少使用的纹理数量和大小来实现。"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:179
msgid ""
"**When targeting mobile devices, consider using the simplest possible "
"shaders you can reasonably afford to use.**"
msgstr "**在针对移动设备时，考虑使用你能合理负担得起的最简单的着色器.**"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:183
#, fuzzy
msgid "Reading textures"
msgstr "渲染动态纹理"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:185
msgid ""
"The other factor in fragment shaders is the cost of reading textures. "
"Reading textures is an expensive operation, especially when reading from "
"several textures in a single fragment shader. Also, consider that filtering "
"may slow it down further (trilinear filtering between mipmaps, and "
"averaging). Reading textures is also expensive in terms of power usage, "
"which is a big issue on mobiles."
msgstr ""
"片段着色器的另一个因素是读取纹理的成本。读取纹理是一项昂贵的操作，尤其是在一"
"个片段着色器中从多个纹理中读取时。另外，考虑到过滤可能会进一步减慢它的速度"
"（mipmaps之间的三线性过滤，以及平均）。读取纹理在功耗方面也很昂贵，这在手机上"
"是个大问题。"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:192
msgid ""
"**If you use third-party shaders or write your own shaders, try to use "
"algorithms that require as few texture reads as possible.**"
msgstr ""
"**如果您使用第三方着色器或编写自己的着色器，请尽量使用需要尽可能少的纹理读取"
"的算法。**"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:196
msgid "Texture compression"
msgstr "纹理压缩"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:198
#, fuzzy
msgid ""
"By default, Godot compresses textures of 3D models when imported using video "
"RAM (VRAM) compression. Video RAM compression isn't as efficient in size as "
"PNG or JPG when stored, but increases performance enormously when drawing "
"large enough textures."
msgstr ""
"Godot提供在导入时压缩3D模型的纹理(VRAM压缩)。 视频RAM压缩在存储时的大小不如"
"PNG或JPG，但在绘制时极大地提高了性能。"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:203
msgid ""
"This is because the main goal of texture compression is bandwidth reduction "
"between memory and the GPU."
msgstr "这是因为纹理压缩的主要目标是在内存和GPU之间减少带宽。"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:206
#, fuzzy
msgid ""
"In 3D, the shapes of objects depend more on the geometry than the texture, "
"so compression is generally not noticeable. In 2D, compression depends more "
"on shapes inside the textures, so the artifacts resulting from 2D "
"compression are more noticeable."
msgstr ""
"在3D中，对象的形状更多地取决于几何形状而不是纹理，因此压缩通常不明显。 在2D"
"中，压缩更多地取决于纹理内部的形状，因此压缩产生的伪像更加明显。"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:211
msgid ""
"As a warning, most Android devices do not support texture compression of "
"textures with transparency (only opaque), so keep this in mind."
msgstr ""
"作为警告，大多数Android设备不支持具有透明度的纹理的纹理压缩(仅不透明)，因此请"
"记住这一点。"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:216
msgid ""
"Even in 3D, \"pixel art\" textures should have VRAM compression disabled as "
"it will negatively affect their appearance, without improving performance "
"significantly due to their low resolution."
msgstr ""
"即使在3D中，\"像素艺术 \"纹理也应该禁用VRAM压缩，因为这会对其外观产生负面影"
"响，而不会因为其低分辨率而显著提高性能。"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:222
msgid "Post-processing and shadows"
msgstr "后处理和阴影"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:224
msgid ""
"Post-processing effects and shadows can also be expensive in terms of "
"fragment shading activity. Always test the impact of these on different "
"hardware."
msgstr ""
"就片段着色活动而言，后期处理效果和阴影也可能很昂贵。始终测试这些对不同硬件的"
"影响。"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:227
msgid ""
"**Reducing the size of shadowmaps can increase performance**, both in terms "
"of writing and reading the shadowmaps. On top of that, the best way to "
"improve performance of shadows is to turn shadows off for as many lights and "
"objects as possible. Smaller or distant OmniLights/SpotLights can often have "
"their shadows disabled with only a small visual impact."
msgstr ""
"**减少阴影图的大小可以提高性能** ，无论是在写还是读取阴影贴图方面。除此之外，"
"提高阴影性能的最好方法是关闭尽可能多的灯光和物体的阴影。较小或较远的"
"OmniLights/SpotLights通常可以禁用它们的阴影，而对视觉影响很小。"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:234
#, fuzzy
msgid "Transparency and blending"
msgstr "透明"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:236
msgid ""
"Transparent objects present particular problems for rendering efficiency. "
"Opaque objects (especially in 3D) can be essentially rendered in any order "
"and the Z-buffer will ensure that only the front most objects get shaded. "
"Transparent or blended objects are different. In most cases, they cannot "
"rely on the Z-buffer and must be rendered in \"painter's order\" (i.e. from "
"back to front) to look correct."
msgstr ""
"透明物体对渲染效率带来了特殊的问题。不透明的对象（尤其是在3D中）基本上可以以"
"任意顺序渲染，Z-缓冲区将确保只有最前面的对象得到阴影。透明或混合对象则不同，"
"在大多数情况下，它们不能依赖Z-缓冲区，必须以 \"画家顺序\"（即从后到前）渲染才"
"能看起来正确。"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:243
msgid ""
"Transparent objects are also particularly bad for fill rate, because every "
"item has to be drawn even if other transparent objects will be drawn on top "
"later on."
msgstr ""
"透明对象的填充率也特别差，因为每一个项目都要绘制，即使之面会在上面绘制其他透"
"明对象。"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:247
msgid ""
"Opaque objects don't have to do this. They can usually take advantage of the "
"Z-buffer by writing to the Z-buffer only first, then only performing the "
"fragment shader on the \"winning\" fragment, the object that is at the front "
"at a particular pixel."
msgstr ""
"不透明的对象不需要这样做。它们通常可以利用Z-缓冲区，只先向Z-缓冲区写入数据，"
"然后只在 \"胜利\" 的片段上执行片段着色器，也就是在某一像素处处于前面的对象。"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:252
msgid ""
"Transparency is particularly expensive where multiple transparent objects "
"overlap. It is usually better to use transparent areas as small as possible "
"to minimize these fill rate requirements, especially on mobile, where fill "
"rate is very expensive. Indeed, in many situations, rendering more complex "
"opaque geometry can end up being faster than using transparency to \"cheat\"."
msgstr ""
"在多个透明对象重叠的情况下，透明度特别昂贵。通常情况下，使用透明区域越小越"
"好，以尽量降低这些填充率要求，尤其是在移动端。事实上，在很多情况下，渲染更复"
"杂的不透明几何体最终可能比使用透明度来 \"作弊\" 更快。"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:259
#, fuzzy
msgid "Multi-platform advice"
msgstr "多平台游戏"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:261
msgid ""
"If you are aiming to release on multiple platforms, test *early* and test "
"*often* on all your platforms, especially mobile. Developing a game on "
"desktop but attempting to port it to mobile at the last minute is a recipe "
"for disaster."
msgstr ""
"如果您的目标是在多个平台上发布，请在您的所有平台上（尤其是移动平台）上进行 *"
"早期* 并 *经常* 性测试。在桌面上开发游戏，但试图在最后一刻将其移植到移动设"
"备，这是灾难的根源。"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:265
msgid ""
"In general, you should design your game for the lowest common denominator, "
"then add optional enhancements for more powerful platforms. For example, you "
"may want to use the GLES2 backend for both desktop and mobile platforms "
"where you target both."
msgstr ""
"一般来说，你应该从最底的共性设计你的游戏，然后为更强大的平台添加可选的增强功"
"能。例如，你可能希望在同时针对桌面和移动平台的情况下，同时使用GLES2后台。"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:271
msgid "Mobile/tiled renderers"
msgstr "移动端和图块渲染"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:273
msgid ""
"As described above, GPUs on mobile devices work in dramatically different "
"ways from GPUs on desktop. Most mobile devices use tile renderers. Tile "
"renderers split up the screen into regular-sized tiles that fit into super "
"fast cache memory, which reduces the number of read/write operations to the "
"main memory."
msgstr ""
"如上所述，移动设备上的GPU与桌面上的GPU工作方式有很大不同。大多数移动设备都使"
"用图块渲染器。图块渲染器将屏幕分割成规则大小的图块，这些图块可以放入超快的缓"
"存中，从而减少了对主内存的读和写操作次数。"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:278
msgid ""
"There are some downsides though. Tiled rendering can make certain techniques "
"much more complicated and expensive to perform. Tiles that rely on the "
"results of rendering in different tiles or on the results of earlier "
"operations being preserved can be very slow. Be very careful to test the "
"performance of shaders, viewport textures and post processing."
msgstr ""
"不过也有一些缺点。图块渲染会让某些技术变得更加复杂，执行起来也更加昂贵。依赖"
"于不同图块渲染的结果，或者依赖于早期操作的结果被保存的图块可能会非常慢。要非"
"常小心地测试着色器、视图纹理和后期处理的性能。"
