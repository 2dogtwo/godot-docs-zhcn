# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2021, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-12-16 15:51+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#, fuzzy
msgid "Introduction to shaders"
msgstr "导出简介"

#, fuzzy
msgid ""
"This page explains what shaders are and will give you an overview of how "
"they work in Godot. For a detailed reference of the engine's shading "
"language, see :ref:`doc_shading_language`."
msgstr ""
"这个文档为您提供了一些特定于Godot的着色器的信息. 有关Godot中着色语言的详细信"
"息, 请参见 :ref:`Godot 着色语言文档 <doc_shading_language>`."

msgid ""
"Shaders are a special kind of program that runs on Graphics Processing Units "
"(GPUs). They were initially used to shade 3D scenes but can nowadays do much "
"more. You can use them to control how the engine draws geometry and pixels "
"on the screen, allowing you to achieve all sorts of effects."
msgstr ""

msgid ""
"Modern rendering engines like Godot draw everything with shaders: graphics "
"cards can run thousands of instructions in parallel, leading to incredible "
"rendering speed."
msgstr ""

msgid ""
"Because of their parallel nature, though, shaders don't process information "
"the way a typical program does. Shader code runs on each vertex or pixel in "
"isolation. You cannot store data between frames either. As a result, when "
"working with shaders, you need to code and think differently from other "
"programming languages."
msgstr ""

#, fuzzy
msgid ""
"Suppose you want to update all the pixels in a texture to a given color. In "
"GDScript, your code would use ``for`` loops::"
msgstr "假设你想要将纹理中的所有像素更新为给定的颜色, 你可以在CPU上这样写:"

msgid ""
"Your code is already part of a loop in a shader, so the corresponding code "
"would look like this."
msgstr ""

msgid ""
"The graphics card calls the ``fragment()`` function once or more for each "
"pixel it has to draw. More on that below."
msgstr ""

#, fuzzy
msgid "Shaders in Godot"
msgstr "Godot中的关键帧"

msgid ""
"Godot provides a shading language based on the popular OpenGL Shading "
"Language (GLSL) but simplified. The engine handles some of the lower-level "
"initialization work for you, making it easier to write complex shaders."
msgstr ""

#, fuzzy
msgid ""
"In Godot, shaders are made up of three main functions: ``vertex()``, "
"``fragment()``, and ``light()``."
msgstr ""
"在Godot中, 着色器由3个主要函数组成:\"vertex()\" 函数,\"fragment()\" 和 "
"\"light()\" 函数."

#, fuzzy
msgid ""
"The ``vertex()`` function runs over all the vertices in the mesh and sets "
"their positions and some other per-vertex variables."
msgstr ""
"\"vertex()\" 函数运行在网格中的所有顶点上, 并设置它们的位置以及部分其他每个顶"
"点的变量."

#, fuzzy
msgid ""
"The ``fragment()`` function runs for every pixel covered by the mesh. It "
"uses values output by the ``vertex()`` function, interpolated between the "
"vertices."
msgstr ""
"函数的作用是: 为网格所覆盖的每个像素运行 \"fragment()\" 函数. 它使用 "
"\"vertex()\" 函数中的变量来运行.\"vertex()\" 函数中的变量在顶点之间进行插值, "
"以提供 \"fragment()\" 函数的值."

#, fuzzy
msgid ""
"The ``light()`` function runs for every pixel and for every light. It takes "
"variables from the ``fragment()`` function and from its previous runs."
msgstr ""
"\"light()\" 函数用于每个像素和每束光照. 它从 \"fragment()\" 函数和以前的运行"
"中获取变量."

#, fuzzy
msgid ""
"The ``light()`` function won't run if the ``vertex_lighting`` render mode is "
"enabled, or if **Rendering > Quality > Shading > Force Vertex Shading** is "
"enabled in the Project Settings. It's enabled by default on mobile platforms."
msgstr ""
"如果启用了 ``vertex_lighting`` 渲染模式, 或者在项目设置中启用了 **Rendering渲"
"染>Quality质量>Shading着色>强制顶点着色** , 则不会运行 ``light()`` 函数.(在移"
"动平台上默认启用.)"

msgid "Shader types"
msgstr "着色器类型"

#, fuzzy
msgid ""
"Instead of supplying a general-purpose configuration for all uses (2D, 3D, "
"particles), you must specify the type of shader you're writing. Different "
"types support different render modes, built-in variables, and processing "
"functions."
msgstr ""
"Godot着色语言必须指定着色器的用途, 而不是提供通用配置给所有用途(2D, 3D, 粒"
"子). 不同的类型支持不同的渲染模式, 内置变量, 和处理函数."

#, fuzzy
msgid ""
"In Godot, all shaders need to specify their type in the first line, like so:"
msgstr "所有着色器都需要在第一行指定其类型, 格式如下:"

#, fuzzy
msgid "Here are the available types:"
msgstr "有6种模式类型:"

#, fuzzy
msgid ":ref:`spatial <doc_spatial_shader>` for 3D rendering."
msgstr ":ref:`spatial <doc_spatial_shader>`: 用于3D渲染."

#, fuzzy
msgid ":ref:`canvas_item <doc_canvas_item_shader>` for 2D rendering."
msgstr ":ref:`canvas_item <doc_canvas_item_shader>`: 用于2D渲染."

#, fuzzy
msgid ":ref:`particles <doc_particle_shader>` for particle systems."
msgstr ":ref:`particles <doc_particle_shader>`: 用于粒子系统."

msgid "Render modes"
msgstr "渲染模式"

msgid ""
"Shaders have optional render modes you can specify on the second line, after "
"the shader type, like so:"
msgstr ""

msgid ""
"Render modes alter the way Godot applies the shader. For example, the "
"``unshaded`` mode makes the engine skip the built-in light processor "
"function."
msgstr ""

#, fuzzy
msgid ""
"Each shader type has different render modes. See the reference for each "
"shader type for a complete list of render modes."
msgstr ""
"每种着色器类型都有不同的渲染模式列表. 有关渲染模式的完整列表, 请参阅每种着色"
"器类型的文档."

msgid "Processor functions"
msgstr "处理器函数"

#, fuzzy
msgid ""
"Depending on the shader type, you can override different processor "
"functions. For ``spatial`` and ``canvas_item``, you have access to "
"``vertex()``, ``fragment()``, and ``light()``. For ``particles``, you only "
"have access to ``vertex()``."
msgstr ""
"根据着色器的类型, 不同的处理器功能可以被选择性地重写. 对于 \"spatial\" 和 "
"\"canvas_item\" , 可以覆盖 ``vertex`` , ``fragment`` 和 ``light`` . 对于 "
"\"particles\" , 只有 ``vertex`` 可以被覆盖."

msgid "Vertex processor"
msgstr "顶点处理器"

#, fuzzy
msgid ""
"The ``vertex()`` processing function is called once for every vertex in "
"``spatial`` and ``canvas_item`` shaders. For ``particles`` shaders, it is "
"called once for every particle."
msgstr ""
"在 \"spatial\" 和 \"canvas_item\" 着色器中, 每一个顶点都要调用一次 "
"``vertex`` 处理函数. 对于 \"particles\" 着色器, 它对每个粒子都调用一次."

msgid ""
"Each vertex in your world's geometry has properties like a position and "
"color. The function modifies those values and passes them to the fragment "
"function. You can also use it to send extra data to the fragment function "
"using varyings."
msgstr ""

#, fuzzy
msgid ""
"By default, Godot transforms your vertex information for you, which is "
"necessary to project geometry onto the screen. You can use render modes to "
"transform the data yourself; see the :ref:`Spatial shader doc "
"<doc_spatial_shader>` for an example."
msgstr ""
"默认情况下,Godot将获取您的顶点信息, 并相应地对其进行转换以便绘制. 如果这是不"
"可用的, 您可以使用渲染模式转换数据;查看 :ref:`空间着色器文档 "
"<doc_spatial_shader>` 来获得这个示例."

msgid "Fragment processor"
msgstr "片段处理器"

msgid ""
"The ``fragment()`` processing function is used to set up the Godot material"
msgstr ""

#, fuzzy
msgid ""
"parameters per pixel. This code runs on every visible pixel the object or "
"primitive draws. It is only available in ``spatial`` and ``canvas_item`` "
"shaders."
msgstr ""
"``fragment`` 处理函数用于设置每个像素的Godot材质参数. 该代码在对象或基本单元"
"绘制的每个可见像素上运行. 它只在 \"spatial\" 和 \"canvas_item\" 着色器中可用."

#, fuzzy
msgid ""
"The standard use of the fragment function is to set up material properties "
"used to calculate lighting. For example, you would set values for "
"``ROUGHNESS``, ``RIM``, or ``TRANSMISSION``, which would tell the light "
"function how the lights respond to that fragment. This makes it possible to "
"control a complex shading pipeline without the user having to write much "
"code. If you don't need this built-in functionality, you can ignore it and "
"write your own light processing function, and Godot will optimize it away. "
"For example, if you do not write a value to ``RIM``, Godot will not "
"calculate rim lighting. During compilation, Godot checks to see if ``RIM`` "
"is used; if not, it cuts all the corresponding code out. Therefore, you will "
"not waste calculations on the effects that you do not use."
msgstr ""
"分段函数的标准用法是设置用于计算光照的材质属性. 例如, 你可以设置 \"粗糙度"
"\" , \"边缘\" 或 \"传递\" 的值, 可以告诉光照功能, 以及光照对这个片段的响应. "
"这使得控制复杂的着色管道成为可能, 而无需用户编写太多代码. 如果你不需要这个内"
"置功能, 可以忽略它, 编写自己的光照处理函数,Godot会优化它. 例如, 如果你不给 "
"\"边缘\" 设定一个值,Godot将不计算边缘照明. 编译期间,Godot检查是否使用了 \"边"
"缘\" ；如果没有, 它将删除所有对应的代码. 因此, 您不会将计算力浪费在不使用的效"
"果上."

msgid "Light processor"
msgstr "光处理器"

#, fuzzy
msgid ""
"The ``light()`` processor runs per pixel too, and it runs once for every "
"light that affects the object. It does not run if no lights affect the "
"object. It exists as a function called inside the ``fragment()`` processor "
"and typically operates on the material properties setup inside the "
"``fragment()`` function."
msgstr ""
"``light`` 处理也是按像素运行的, 但也为每一个影响物体的光线而运行(如果没有光线"
"影响物体, 则不运行). 它作为一个函数存在于 \"fragment\" 处理内部, 通常在 "
"\"fragment\" 函数中设置的材质属性上运行."

#, fuzzy
msgid ""
"The ``light()`` processor works differently in 2D than it does in 3D; for a "
"description of how it works in each, see their documentation, :ref:"
"`CanvasItem shaders <doc_canvas_item_shader>` and :ref:`Spatial shaders "
"<doc_spatial_shader>`, respectively."
msgstr ""
"``light`` 处理在2D中的工作方式与在3D中的工作方式不同；关于它在每一种情况下的"
"工作方式的描述, 请分别参阅它们的文档, :ref:`CanvasItem shaders "
"<doc_canvas_item_shader>` 和 :ref:`Spatial shaders <doc_spatial_shader>` ."
