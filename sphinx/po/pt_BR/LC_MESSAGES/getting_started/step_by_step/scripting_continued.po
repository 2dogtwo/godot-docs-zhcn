# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2019, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-12-17 12:01+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:4
msgid "Scripting (continued)"
msgstr "Roteirizando (continuação)"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:7
msgid "Processing"
msgstr "Processamentos"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:9
msgid ""
"Several actions in Godot are triggered by callbacks or virtual functions, so "
"there is no need to write code that runs all the time."
msgstr ""
"Muitas ações no Godot são disparadas por funções virtuais ou de retorno, "
"então não há necessidade de escrever um código que execute o tempo todo."

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:12
msgid ""
"However, it is still common to need a script to be processed on every frame. "
"There are two types of processing: idle processing and physics processing."
msgstr ""
"Entretanto, ainda é comum precisar que um roteiro seja processado a cada "
"quadro. Existem dois tipos de processamento: o ocioso e o físico."

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:16
msgid ""
"Idle processing is activated when the method :ref:`Node._process() "
"<class_Node_method__process>` is found in a script. It can be turned off and "
"on with the :ref:`Node.set_process() <class_Node_method_set_process>` "
"function."
msgstr ""
"Processamento ocioso é ativado quando o método :ref:`Node._process() "
"<class_Node_method__process>` é encontrado em um roteiro. Ele pode ser "
"desativado e reativado com a função :ref:`Node.set_process() "
"<class_Node_method_set_process>`."

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:20
msgid "This method will be called every time a frame is drawn:"
msgstr "Esse método será chamado toda vez que um quadro é desenhado:"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:36
msgid ""
"It's important to bear in mind that the frequency with which ``_process()`` "
"will be called depends on how many frames per second (FPS) your application "
"is running at. This rate can vary over time and devices."
msgstr ""
"É importante ter em mente que a frequência em que a função ``_process()`` "
"será chamada depende de quantos quadros por segundo (FPS) sua aplicação está "
"rodando. Essa taxa pode variar com o tempo e dispositivos."

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:40
msgid ""
"To help manage this variability the ``delta`` parameter contains the time "
"elapsed in seconds, as a floating point, since the previous call to "
"``_process()``."
msgstr ""
"Para ajudar a gerenciar essa variabilidade o parâmetro ``delta`` contém o "
"tempo decorrido em segundos, sendo um número decimal, desde a chamada "
"anterior de ``_process()``."

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:43
msgid ""
"This parameter can be used to make sure things always take the same amount "
"of time, regardless of the game's FPS."
msgstr ""
"Este parâmetro pode ser usado para garantir que as coisas sempre levem a "
"mesma quantidade de tempo, independentemente do taxa de quadros (FPS) do "
"jogo."

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:46
msgid ""
"For example, movement is often multiplied with a time delta to make movement "
"speed both constant and independent from the frame rate."
msgstr ""
"Por exemplo, é frequente multiplicar o movimento pelo delta para tornar a "
"velocidade de movimento constante independente da taxa de quadros."

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:49
msgid ""
"Physics processing with ``_physics_process()`` is similar, but it should be "
"used for processes that must happen before each physics step, such as "
"controlling a character. It always runs before a physics step and it is "
"called at fixed time intervals: 60 times per second by default. You can "
"change the interval from the Project Settings, under Physics -> Common -> "
"Physics Fps."
msgstr ""
"Processamento físico com ``_physics_process()`` funciona similar, mas "
"deveria ser usado para processo que tenham que acontecer antes de cada passo "
"da física, tais como controlar um personagem. Ele sempre é executado antes "
"de um passo da física e é chamado a intervalos fixos de tempo: 60 vezes por "
"segundo por padrão. Você pode alterar o intervalo nas Configurações do "
"Projeto, em Physics -> Common -> Physics Fps (Física -> Comum -> Fps Física)."

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:55
msgid ""
"The function ``_process()``, however, is not synced with physics. Its frame "
"rate is not constant and is dependent on hardware and game optimization. Its "
"execution is done after the physics step on single-threaded games."
msgstr ""
"A função ``_process()``, contudo, não é sincronizado com a física. Sua taxa "
"de quadros não é constante e depende do hardware e da otimização do jogo. "
"Sua execução é feita depois do passo da física em jogos de thread única."

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:58
msgid ""
"A simple way to see the ``_process()`` function at work is to create a scene "
"with a single Label node, with the following script:"
msgstr ""
"Uma maneira simples de ver a função ``_process()`` funcionando é criar uma "
"cena com um único nó Label, com o seguinte roteiro:"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:85
msgid "Which will show a counter increasing each frame."
msgstr "Que vai mostrar um contador aumentando a cada quadro."

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:88
msgid "Groups"
msgstr "Grupos"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:90
msgid ""
"Groups in Godot work like tags you might have come across in other software. "
"A node can be added to as many groups as desired. This is a useful feature "
"for organizing large scenes. There are two ways to add nodes to groups. The "
"first is from the UI, using the Groups button under the Node panel:"
msgstr ""
"Grupos no Godot funcionam como tags que você pode encontrar em outros "
"softwares. 'Nós', podem ser adicionados a grupos, a quantidade que desejar "
"por nó, e isso é uma funcionalidade útil para organizar cenas grandes. Há "
"duas formas de fazer isso. A primeira é pela interface gráfica, a partir do "
"botão Grupos dentro do painel Nó:"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:97
msgid ""
"And the second way is from code. The following script would add the current "
"node to the ``enemies`` group as soon as it appeared in the scene tree."
msgstr ""
"E a segunda maneira é por código. O sequinte script adicionará o nó atual ao "
"grupo ``enemies`` assim que aparecesse na árvore de cena."

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:115
msgid ""
"This way, if the player is discovered sneaking into a secret base, all "
"enemies can be notified about its alarm sounding by using :ref:`SceneTree."
"call_group() <class_SceneTree_method_call_group>`:"
msgstr ""
"Desta maneira, se o jogador é descoberto se esgueirando pela base secreta, "
"todos os inimigos podem ser notificados por alarme sonoro usando :ref:"
"`SceneTree.call_group() <class_SceneTree_method_call_group>`:"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:132
msgid ""
"The above code calls the function ``player_was_discovered`` on every member "
"of the group ``enemies``."
msgstr ""
"O código acima chama a função ``player_was_discovered`` "
"(\"jogador_foi_descoberto\") de cada membro do grupo `enemies`` (\"inimigos"
"\")."

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:135
msgid ""
"It is also possible to get the full list of ``enemies`` nodes by calling :"
"ref:`SceneTree.get_nodes_in_group() "
"<class_SceneTree_method_get_nodes_in_group>`:"
msgstr ""
"É também possível conseguir a lista completa de nós ``inimigos`` chamando :"
"ref:`SceneTree.get_nodes_in_group() "
"<class_SceneTree_method_get_nodes_in_group>`:"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:148
msgid ""
"The :ref:`SceneTree <class_SceneTree>` class provides many useful methods, "
"like interacting with scenes, their node hierarchy and groups of nodes. It "
"allows you to easily switch scenes or reload them, to quit the game or pause "
"and unpause it. It even comes with interesting signals. So check it out if "
"you have some time!"
msgstr ""
"A classe :ref:`SceneTree <class_SceneTree>` fornece muitos métodos úteis, "
"como interagir com cenas, suas hierarquias e grupos de nós. Ela lhe permite "
"facilmente trocar ou recarregar cenas, sair do jogo ou pausa-lo ou retomá-"
"lo. Ela até vem com sinais interessantes. Então dê uma olhada nela se tiver "
"um tempo!"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:156
msgid "Notifications"
msgstr "Notificações"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:158
msgid ""
"Godot has a system of notifications. These are usually not needed for "
"scripting, as it's too low-level and virtual functions are provided for most "
"of them. It's just good to know they exist. For example, you may add an :ref:"
"`Object._notification() <class_Object_method__notification>` function in "
"your script:"
msgstr ""
"O Godot tem um sistema de notificações. Elas não costumam ser necessárias "
"para roteirizar, já que são programação de baixo nível e se provê funções "
"virtuais para a maioria delas. Mas é bom saber que elas existem. Por "
"exemplo, você pode adicionar uma função :ref:`Object._notification() "
"<class_Object_method__notification>` ao seu roteiro:"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:193
#, fuzzy
msgid ""
"The documentation of each class in the :ref:`Class Reference <toc-class-"
"ref>` shows the notifications it can receive. However, in most cases "
"GDScript provides simpler overridable functions."
msgstr ""
"A documentação de cada classe na :ref:`Referência das Classes <toc-class-"
"ref>` mostra as notificações que ela pode receber. No entanto, na maior "
"parte dos casos, a GDScript fornece funções substituíveis mais simples."

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:198
#, fuzzy
msgid "Overridable functions"
msgstr "Funções substituíveis"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:200
#, fuzzy
msgid ""
"Such overridable functions, which are described as follows, can be applied "
"to nodes:"
msgstr ""
"Tais funções substituíveis, como descritas no código, podem ser aplicadas a "
"nós:"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:272
msgid ""
"As mentioned before, it's better to use these functions instead of the "
"notification system."
msgstr ""
"Como já mencionado, é melhor usar essas funções ao invés do sistema de "
"notificações."

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:276
msgid "Creating nodes"
msgstr "Criando nós"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:278
msgid ""
"To create a node from code, call the ``.new()`` method, like for any other "
"class-based datatype. For example:"
msgstr ""
"Para criar um nó a partir do código, chame o método ``.new()``, assim como "
"faria para qualquer tipo de dado baseado em classe. Por exemplo:"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:302
msgid ""
"To delete a node, be it inside or outside the scene, ``free()`` must be used:"
msgstr ""
"Para excluir um nó, esteja ele dentro ou fora da cena, deve-se usar "
"``free()``:"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:318
msgid ""
"When a node is freed, it also frees all its child nodes. Because of this, "
"manually deleting nodes is much simpler than it appears. Free the base node "
"and everything else in the subtree goes away with it."
msgstr ""
"Quando um nó é liberado da memória, ele também libera todos os seus nós "
"filhos. Por isso, excluir nós manualmente é mais simples do que parece. "
"Libere o nó base e todo o resto vai embora junto com ele."

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:322
msgid ""
"A situation might occur where we want to delete a node that is currently "
"\"blocked\", because it is emitting a signal or calling a function. This "
"will crash the game. Running Godot with the debugger will often catch this "
"case and warn you about it."
msgstr ""
"Uma situação pode acontecer quando queremos excluir um nó que está "
"\"bloqueado\" atualmente, por estar emitindo um sinal ou chamando uma "
"função. Isso quebra o jogo. Executar o Godot com o depurador irá pegar esse "
"caso frequentemente e lhe alertar sobre isso."

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:327
msgid ""
"The safest way to delete a node is by using :ref:`Node.queue_free() "
"<class_Node_method_queue_free>`. This erases the node safely during idle."
msgstr ""
"A forma mais segura de excluir um nó é usando :ref:`Node.queue_free() "
"<class_Node_method_queue_free>`. Isso apaga o nó com segurança durante o "
"tempo ocioso."

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:345
msgid "Instancing scenes"
msgstr "Criando instâncias de cenas"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:347
msgid ""
"Instancing a scene from code is done in two steps. The first one is to load "
"the scene from your hard drive:"
msgstr ""
"Criar uma instância de cena a partir do código é feito em duas estapas. A "
"primeira é carregar a cena do seu disco rígido:"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:360
msgid ""
"Preloading it can be more convenient, as it happens at parse time (GDScript "
"only):"
msgstr ""
"Pré-carregamento pode ser mais conveniente, já que acontece durante o tempo "
"de análise (apenas para GDScript):"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:368
msgid ""
"But ``scene`` is not yet a node. It's packed in a special resource called :"
"ref:`PackedScene <class_PackedScene>`. To create the actual node, the "
"function :ref:`PackedScene.instance() <class_PackedScene_method_instance>` "
"must be called. This will return the tree of nodes that can be added to the "
"active scene:"
msgstr ""
"Mas ``cena`` ainda não é um nó. Ela está empacotada em um recurso especial "
"chamado :ref:`PackedScene <class_PackedScene>`. Para criar um nó de fato, é "
"preciso chamar a função :ref:`PackedScene.instance() "
"<class_PackedScene_method_instance>`. Ela vai retornar a árvore de nós que "
"pode ser adicionada à cena ativa:"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:386
msgid ""
"The advantage of this two-step process is that a packed scene may be kept "
"loaded and ready to use so that you can create as many instances as desired. "
"This is especially useful to quickly instance several enemies, bullets, and "
"other entities in the active scene."
msgstr ""
"A vantagem deste processo de duas etapas é que uma cena empacotada pode ser "
"mantida carregada e pronta para uso, de forma que você possa gerar quantas "
"instâncias desejar. É útil especialmente para, rapidamente, criar instâncias "
"de vários inimigos, balas e outras entidades na cena ativa."

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:394
msgid "Register scripts as classes"
msgstr "Registre scripts como classes"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:396
msgid ""
"Godot has a \"Script Class\" feature to register individual scripts with the "
"Editor. By default, you can only access unnamed scripts by loading the file "
"directly."
msgstr ""
"Godot tem uma função \"Classe Script\" para registrar scripts individuais "
"com o editor. Por padrão, você só pode acessar scripts sem nome ao carregar "
"o arquivo diretamente."

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:400
msgid ""
"You can name a script and register it as a type in the editor with the "
"``class_name`` keyword followed by the class's name. You may add a comma and "
"an optional path to an image to use as an icon. You will then find your new "
"type in the Node or Resource creation dialog."
msgstr ""
"Você pode nomear um script e o registrar como um tipo no editor com a "
"palavra chave ``class_name`` seguido pelo nome da classe. Você pode "
"adicionar uma vírgula e um caminho opcional a uma imagem para usar como "
"ícone. Então, você encontrará seu novo tipo na janela de criação de Nodes e "
"recursos."

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:422
msgid "In Godot 3.1:"
msgstr "Em Godot 3.1:"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:424
msgid ""
"Only GDScript and NativeScript, i.e., C++ and other GDNative-powered "
"languages, can register scripts."
msgstr ""
"Apenas GDScript e NativeScript (ex: C++) e outras linguagens baseadas em "
"GDNative, podem registrar scripts."

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:425
msgid "Only GDScript creates global variables for each named script."
msgstr "Apenas GDScript pode criar variáveis globais para cada script nomeado."
