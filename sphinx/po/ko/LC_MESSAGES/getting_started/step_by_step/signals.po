# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2019, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-02-10 13:55+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../docs/getting_started/step_by_step/signals.rst:4
msgid "Signals"
msgstr "시그널"

#: ../../docs/getting_started/step_by_step/signals.rst:7
msgid "Introduction"
msgstr "소개"

#: ../../docs/getting_started/step_by_step/signals.rst:9
msgid ""
"Signals are Godot's version of the *observer* pattern. They allow a node to "
"send out a message that other nodes can listen for and respond to. For "
"example, rather than continuously checking a button to see if it's being "
"pressed, the button can emit a signal when it's pressed."
msgstr ""
"시그널은 *옵저버* 패턴의 Godot 버전입니다. 시그널로 노드는 다른 노드로 메시지"
"를 보내고 다른 노드는 이것을 받고 응답할 수 있습니다. 예를 들어, 버튼의 눌림 "
"여부를 파악하기 위해 주기적으로 버튼을 확인하는 대신 버튼이 눌렸을 때 시그널"
"을 방출(emit)할 수 있습니다."

#: ../../docs/getting_started/step_by_step/signals.rst:14
msgid ""
"You can read more about the observer pattern here: http://"
"gameprogrammingpatterns.com/observer.html"
msgstr ""
"옵저버 패턴에 대해 더 알아보려면 다음 주소를 참고하세요: http://"
"gameprogrammingpatterns.com/observer.html"

#: ../../docs/getting_started/step_by_step/signals.rst:16
msgid ""
"Signals are a way to *decouple* your game objects, which leads to better "
"organized and more manageable code. Instead of forcing game objects to "
"expect other objects to always be present, they can instead emit signals "
"that any interested objects can subscribe to and respond."
msgstr ""
"시그널은 게임 객체들을 *분리하는* 도구로, 이를 활용하여 더 체계적이고 관리하"
"기 쉬운 코드를 작성할 수 있습니다. 게임 객체가 다른 객체가 존재하도록 강요하"
"는 대신, 한 객체가 방출한 시그널을 필요로 하는 다른 객체만 구독하거나 응답할 "
"수 있도록 합니다."

#: ../../docs/getting_started/step_by_step/signals.rst:21
msgid ""
"Below you can see some examples of how you can use signals in your own "
"projects."
msgstr ""
"아래에서 여러분의 프로젝트에 시그널을 활용할 수 있는 방법을 담은 예시들을 살"
"펴보겠습니다."

#: ../../docs/getting_started/step_by_step/signals.rst:24
msgid "Timer example"
msgstr "타이머(Timer) 예제"

#: ../../docs/getting_started/step_by_step/signals.rst:26
msgid ""
"To see how signals work, let's try using a :ref:`Timer <class_Timer>` node. "
"Create a new scene with a Node and two children: a Timer and a :ref:`Sprite "
"<class_Sprite>`. You can use the Godot icon for the Sprite's texture, or any "
"other image you like. Attach a script to the root node, but don't add any "
"code to it yet."
msgstr ""
"시그널이 어떻게 작동하는지 알아보기 위해, :ref: `Timer <class_Timer>` 노드를 "
"사용하겠습니다. Node와 두 자식 노드가 있는 씬을 만듭니다: 하나는 Timer이고 다"
"른 하나는 :ref:`Sprite <class_Sprite>`\\ 입니다. 스프라이트의 텍스쳐로 Godot "
"아이콘을 쓸 수도 있고, 원하는 어떤 이미지를 놓아도 좋습니다. 루트 노드에 스크"
"립트를 붙이되, 아직 아무 코드도 넣지 마세요."

#: ../../docs/getting_started/step_by_step/signals.rst:31
msgid "Your scene tree should look like this:"
msgstr "씬 트리는 다음과 같아야 합니다:"

#: ../../docs/getting_started/step_by_step/signals.rst:35
msgid ""
"In the Timer node's properties, check the \"On\" box next to *Autostart*. "
"This will cause the timer to start automatically when you run the scene. You "
"can leave the *Wait Time* at 1 second."
msgstr ""
"Timer 노드의 속성에서, *Autostart* 옆에 박스를 \"On\" 하세요. 그렇게 하면 씬"
"을 실행할 때 자동으로 타이머가 실행합니다. 또한 *Wait Time*\\ 을 1초로 처리"
"할 수 있습니다."

#: ../../docs/getting_started/step_by_step/signals.rst:39
msgid ""
"Next to the \"Inspector\" tab is a tab labeled \"Node\". Click on this tab "
"and you'll see all of the signals that the selected node can emit. In the "
"case of the Timer node, the one we're concerned with is \"timeout\". This "
"signal is emitted whenever the Timer reaches ``0``."
msgstr ""
"\"인스펙터\" 탭 옆에 \"노드\"라는 라벨이 붙은 탭이 있습니다. 이 탭을 클릭하"
"면 선택한 노드에서 방출할 수 있는 모든 시그널이 표시됩니다. Timer  노드의 경"
"우, 주목해야 할 시그널은 \"timeout\"입니다. 이 시그널은 Timer가 ``0``\\ 이 "
"될 때마다 방출합니다."

#: ../../docs/getting_started/step_by_step/signals.rst:46
msgid ""
"Click on the \"timeout()\" signal and click \"Connect...\". You'll see the "
"following window, where you can define how you want to connect the signal:"
msgstr ""
"\"timeout()\" 시그널을 클릭하고 그리고 \"연결하기...\"를 누릅니다. 다음과 같"
"은 창이 나타나는데, 여기서 당신은 시그널을 어떻게 연결할 지를 정의할 수 있습"
"니다:"

#: ../../docs/getting_started/step_by_step/signals.rst:51
msgid ""
"On the left side, you'll see the nodes in your scene and can select the node "
"that you want to \"listen\" for the signal. Note that the Timer node is red "
"- this is *not* an error, but is a visual indication that it's the node that "
"is emitting the signal. Select the root node."
msgstr ""
"왼쪽에는 씬의 노드가 표시되고 시그널을 \"받는\" 노드를 선택할 수 있습니다. "
"Timer 노드는 적색입니다 - 이는 오류가 아니며 신호를 방출하는 노드임을 시각적"
"으로 나타냅니다. 루트 노드를 선택합니다."

#: ../../docs/getting_started/step_by_step/signals.rst:56
msgid ""
"The target node *must* have a script attached or you'll receive an error "
"message."
msgstr ""
"대상 노드는 *반드시* 스크립트가 붙게 되고 그렇지 않으면 오류 메시지를 받습니"
"다."

#: ../../docs/getting_started/step_by_step/signals.rst:59
msgid ""
"On the bottom of the window is a field labeled \"Method In Node\". This is "
"the name of the function in the target node's script that you want to use. "
"By default, Godot will create this function using the naming convention "
"``_on_<node_name>_<signal_name>`` but you can change it if you wish."
msgstr ""
"창의 아래쪽을 보시면 \"Method In Node\"라고 적혀있는 영역이 있습니다. 대상 노"
"드의 스크립트에서 이것을 함수 이름으로 사용합니다. 기본적으로, Godot는 명명 "
"규칙에 따라 ``_on_<노드이름>_<시그널이름>``\\ 으로 함수 이름을 만들지만 원한"
"다면 바꿀 수 있습니다."

#: ../../docs/getting_started/step_by_step/signals.rst:64
msgid ""
"Click \"Connect\" and you'll see that the function has been created in the "
"script:"
msgstr "\"연결\"을 클릭하면 스크립트 안에 함수가 만들어진 것을 볼 수 있습니다:"

#: ../../docs/getting_started/step_by_step/signals.rst:84
msgid ""
"Now we can replace the placeholder code with whatever code we want to run "
"when the signal is received. Let's make the Sprite blink:"
msgstr ""
"이제 자리 표시자 코드는 시그널을 받게 되면 실행시키길 원하는 어떤 코드든지 변"
"환될 수 있습니다. 스프라이트 깜박임을 만들어 봅시다:"

#: ../../docs/getting_started/step_by_step/signals.rst:106
msgid ""
"Run the scene and you'll see the Sprite blinking on and off every second. "
"You can change the Timer's *Wait Time* property to alter this."
msgstr ""
"씬을 실행하면 Sprite가 매 초마다 깜박이는 것을 볼 수 있습니다. Timer의 *Wait "
"Time* 속성을 변경하여 주기를 변경할 수 있습니다."

#: ../../docs/getting_started/step_by_step/signals.rst:110
msgid "Connecting signals in code"
msgstr "노드에서 시그널 연결하기"

#: ../../docs/getting_started/step_by_step/signals.rst:112
msgid ""
"You can also make the signal connection in code rather than with the editor. "
"This is usually necessary when you're instancing nodes via code and so you "
"can't use the editor to make the connection."
msgstr ""
"에디터에서 뿐만 아니라 코드에서도 시그널 연결을 만들 수 있습니다. 보통은 코드"
"를 통해 노드를 인스턴스할 때 필요하기 때문에 에디터에서 이런 시그널 연결을 만"
"들 수는 없습니다."

#: ../../docs/getting_started/step_by_step/signals.rst:116
msgid ""
"First, disconnect the signal by selecting the connection in the Timer's "
"\"Node\" tab and clicking disconnect."
msgstr ""
"먼저, Timer의 \"노드\" 탭에서 연결 끊기를 클릭해서 시그널의 연결을 풉니다."

#: ../../docs/getting_started/step_by_step/signals.rst:121
msgid ""
"To make the connection in code, we can use the ``connect`` function. We'll "
"put it in ``_ready()`` so that the connection will be made on run. The "
"syntax of the function is ``<source_node>.connect(<signal_name>, "
"<target_node>, <target_function_name>)``. Here is the code for our Timer "
"connection:"
msgstr ""
"코드에서 연결을 만들기 위해, ``connect`` 함수를 사용할 수 있습니다. "
"``_ready()``\\ 안에 이 함수를 넣으면 연결을 실행하는 준비가 된 것입니다. 함수"
"의 문법은 ``<소스_이름>.connect(<시그널_이름>, <대상_이름>, <대상_함수_이름"
">)``\\ 입니다. 이것이 Timer 연결을 위한 코드입니다:"

#: ../../docs/getting_started/step_by_step/signals.rst:154
msgid "Custom signals"
msgstr "커스텀 시그널"

#: ../../docs/getting_started/step_by_step/signals.rst:156
msgid "You can also declare your own custom signals in Godot:"
msgstr "Godot에 당신의 커스텀 시그널을 선언할 수 있습니다:"

#: ../../docs/getting_started/step_by_step/signals.rst:174
msgid ""
"Once declared, your custom signals will appear in the Inspector and can be "
"connected in the same way as a node's built-in signals."
msgstr ""
"시그널은 선언하면, 커스텀 시그널은 인스펙터에 나타나고 노드의 내장 시그널과 "
"같은 방식으로 연결할 수 있습니다."

#: ../../docs/getting_started/step_by_step/signals.rst:177
msgid "To emit a signal via code, use the ``emit`` function:"
msgstr "코드를 통해 시그널을 방출하기 위해선, ``emit`` 함수를 사용합니다:"

#: ../../docs/getting_started/step_by_step/signals.rst:203
msgid "Shooting example"
msgstr "발사 예제"

#: ../../docs/getting_started/step_by_step/signals.rst:205
msgid ""
"As another example of signal usage, let's consider a player character that "
"can rotate and shoot towards the mouse. Every time the mouse button is "
"clicked, we create an instance of the bullet at the player's location. See :"
"ref:`doc_instancing` for details."
msgstr ""
"시그널 사용의 다른 예제로, 마우스 방향으로 회전하며 발사할 수 있는 플레이어"
"를 생각해봅시다. 마우스 버튼을 클릭할 때 마다, 플레이어의 위치에 총알의 인스"
"턴스를 만듭니다. 자세한 설명은 :ref:`doc_instancing`\\ 를 참고하세요."

#: ../../docs/getting_started/step_by_step/signals.rst:210
msgid ""
"However, if the bullets are added as children of the player, then they will "
"remain \"attached\" to the player as it rotates:"
msgstr ""
"하지만, 총알이 플레이어의 자식으로 추가된다면, 플레이어가 회전하는 것에 따라 "
"\"붙어있는 채로\" 남아있을 것입니다:"

#: ../../docs/getting_started/step_by_step/signals.rst:215
msgid ""
"Instead, we need the bullets to be independent of the player's movement - "
"once fired, they should continue traveling in a straight line and the player "
"can no longer affect them. Instead of being added to the scene tree as a "
"child of the player, it makes more sense to add the bullet as a child of the "
"\"main\" game scene, which may be the player's parent or even further up the "
"tree."
msgstr ""
"대신, 총알을 플레이어의 움직임에 독립하도록 해야 합니다 - 일단 발사가 되면, "
"플레이어가 그것에 영향을 주지 않고 직선으로 계속 나아가야 합니다. 플레이어의 "
"자식으로 씬 트리에 추가하는 대신, 총알을 \"메인\" 게임 씬의 자식으로 추가하"
"는 것이 더 합리적입니다, 이렇게 하면 총알이 플레이어의 부모나 더 위로 올라갈 "
"수도 있습니다."

#: ../../docs/getting_started/step_by_step/signals.rst:221
msgid "You could do this by adding the bullet directly:"
msgstr "총알에 직접 이 코드를 추가하는 것으로 가능합니다:"

#: ../../docs/getting_started/step_by_step/signals.rst:234
msgid ""
"However, this will lead to a different problem. Now if you try and test your "
"\"Player\" scene independently, it will crash on shooting, because there is "
"no parent node to access. This makes it a lot harder to test your player "
"code independently and also means that if you decide to change your main "
"scene's node structure, the player's parent may no longer be the appropriate "
"node to receive the bullets."
msgstr ""
"그러나 이것은 다른 문제를 불러올 수 있습니다. 이제 \"Player\" 씬을 독립적으"
"로 테스트해 보신다면, 액세스할 부모 노드가 없기 때문에, 발사를 할 때 팅길 것"
"입니다. 이는 플레이어 코드를 독립적으로 테스트하기가 더 까다로울 뿐만 아니"
"라, 메인 씬의 노드 구조를 바꾸기로 한다면 플레이어의 부모는 더 이상 총알을 받"
"기에 적절한 노드가 아니게 됩니다."

#: ../../docs/getting_started/step_by_step/signals.rst:241
msgid ""
"The solution to this is to use a signal to \"emit\" the bullets from the "
"player. The player then has no need to \"know\" what happens to the bullets "
"after that - whatever node is connected to the signal can \"receive\" the "
"bullets and take the appropriate action to spawn them."
msgstr ""
"해결책은 플레이어로부터 총알을 \"방출\"하는 시그널을 사용하는 것입니다. 그렇"
"게 하면 플레이어는 총알이 어떻게 되는지 \"알\" 필요가 없습니다 - 이 시그널에 "
"연결된 어떤 노드라도 총알을 \"받을\" 수 있고 총알을 스폰하기 위한 적절한 행동"
"을 취해줄 수 있습니다."

#: ../../docs/getting_started/step_by_step/signals.rst:247
msgid "Here is the code for the player using signals to emit the bullet:"
msgstr "이것이 시그널을 사용해 플레이어가 총알을 방출하는 코드입니다:"

#: ../../docs/getting_started/step_by_step/signals.rst:290
msgid ""
"In the main scene, we then connect the player's signal (it will appear in "
"the \"Node\" tab)."
msgstr ""
"메인 씬에서, 이제 플레이어의 시그널을 연결합니다 (\"노드\" 탭에 나타날 것입니"
"다)."

#: ../../docs/getting_started/step_by_step/signals.rst:314
msgid ""
"Now the bullets will maintain their own movement independent of the player's "
"rotation:"
msgstr ""
"이제 총알은 움직임을 유지한 채로 플레이어의 회전에 독립을 유지할 것입니다:"

#: ../../docs/getting_started/step_by_step/signals.rst:320
msgid "Conclusion"
msgstr "결론"

#: ../../docs/getting_started/step_by_step/signals.rst:322
msgid ""
"Many of Godot's built-in node types provide signals you can use to detect "
"events. For example, an :ref:`Area2D <class_Area2D>` representing a coin "
"emits a ``body_entered`` signal whenever the player's physics body enters "
"its collision shape, allowing you to know when the player collected it."
msgstr ""
"Godot의 내장 노드 타입의 대다수는 이벤트를 감지하는 데 사용할 수 있는 시그널"
"을 제공합니다. 예를 들어, 동전 하나를 나타내는 :ref:`Area2D <class_Area2D>`"
"는 플레이어의 물리 바디가 충돌 모양에 들어갈 때마다 ``body_entered`` 시그널"
"을 방출하며, 이를 통해 플레이어가 동전을 언제 먹었는 지를 알 수 있습니다."

#: ../../docs/getting_started/step_by_step/signals.rst:327
msgid ""
"In the next section, :ref:`doc_your_first_game`, you'll build a complete "
"game including several uses of signals to connect different game components."
msgstr ""
"다음 섹션은, :ref:`doc_your_first_game`\\ 으로, 서로 다른 게임 구성 요소들을 "
"여러 시그널을 사용하여 연결하는 것을 포함한 완전한 게임을 만들 것입니다."
