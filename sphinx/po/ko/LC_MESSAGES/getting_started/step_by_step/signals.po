# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2019, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-01-08 11:44+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../docs/getting_started/step_by_step/signals.rst:4
msgid "Signals"
msgstr "시그널(Signal)"

#: ../../docs/getting_started/step_by_step/signals.rst:7
msgid "Introduction"
msgstr "소개"

#: ../../docs/getting_started/step_by_step/signals.rst:9
msgid ""
"Signals are Godot's version of the *observer* pattern. They allow a node to "
"send out a message that other nodes can listen for and respond to. For "
"example, rather than continuously checking a button to see if it's being "
"pressed, the button can emit a signal when it's pressed."
msgstr ""
"시그널(신호)은 *옵저버* 패턴의 Godot 버전입니다. 시그널을 사용하면 한 노드가 "
"다른 노드들이 듣고 응답할 수 있는 메시지를 보낼 수 있습니다. 그 예로, 버튼의 "
"눌림 여부를 파악하기 위해 주기적으로 버튼을 확인하는 대신 버튼이 눌렸을 때 시"
"그널을 발생(emit)할 수 있습니다."

#: ../../docs/getting_started/step_by_step/signals.rst:14
msgid ""
"You can read more about the observer pattern here: http://"
"gameprogrammingpatterns.com/observer.html"
msgstr ""
"Observer 패턴에 대해 더 알아보려면 다음 주소를 참고해주세요: http://"
"gameprogrammingpatterns.com/observer.html"

#: ../../docs/getting_started/step_by_step/signals.rst:16
msgid ""
"Signals are a way to *decouple* your game objects, which leads to better "
"organized and more manageable code. Instead of forcing game objects to "
"expect other objects to always be present, they can instead emit signals "
"that any interested objects can subscribe to and respond."
msgstr ""
"시그널은 게임 객체들을 *분리하는* 도구로, 이를 활용하여 더 체계적이고 관리하"
"기 쉬운 코드를 작성할 수 있습니다. 게임 객체가 다른 객체가 존재하도록 강요하"
"는 대신, 한 객체가 방출한 시그널을 필요로 하는 다른 객체만 구독하거나 응답할 "
"수 있도록 합니다."

#: ../../docs/getting_started/step_by_step/signals.rst:21
msgid ""
"Below you can see some examples of how you can use signals in your own "
"projects."
msgstr ""
"아래에서 여러분의 프로젝트에 시그널을 활용할 수 있는 방법을 담은 예시들을 살"
"펴보겠습니다."

#: ../../docs/getting_started/step_by_step/signals.rst:24
msgid "Timer example"
msgstr "타이머(Timer) 예제"

#: ../../docs/getting_started/step_by_step/signals.rst:26
msgid ""
"To see how signals work, let's try using a :ref:`Timer <class_Timer>` node. "
"Create a new scene with a Node and two children: a Timer and a :ref:`Sprite "
"<class_Sprite>`. You can use the Godot icon for the Sprite's texture, or any "
"other image you like. Attach a script to the root node, but don't add any "
"code to it yet."
msgstr ""
"시그널이 어떻게 돌아가는지 이해하기 위해, :ref: `Timer <class_Timer>` 노드를 "
"사용해봅시다. 부모로 노드, 자식으로 타이머와 :ref:`Sprite <class_Sprite>`노드"
"를 가지는 씬을 만드세요. 스프라이트의 텍스쳐로 Godot 아이콘을 쓸 수도 있고, "
"아무거나 원하는 이미지로 설정해도 좋습니다. 루트 노드에 스크립트를 붙이되, 아"
"직 아무 코드도 넣지 마세요."

#: ../../docs/getting_started/step_by_step/signals.rst:31
msgid "Your scene tree should look like this:"
msgstr "씬 트리는 다음과 같아야 합니다:"

#: ../../docs/getting_started/step_by_step/signals.rst:35
msgid ""
"In the Timer node's properties, check the \"On\" box next to *Autostart*. "
"This will cause the timer to start automatically when you run the scene. You "
"can leave the *Wait Time* at 1 second."
msgstr ""
"타이머 속성안에서 *Autostart* 옆에 박스를 체크하세요 체크하면 scene이 작동될"
"때 자동적으로 타이머가 작동됩니다. 또한 1초의 *Wait Time*을 남길 수 있습니다."

#: ../../docs/getting_started/step_by_step/signals.rst:39
msgid ""
"Next to the \"Inspector\" tab is a tab labeled \"Node\". Click on this tab "
"and you'll see all of the signals that the selected node can emit. In the "
"case of the Timer node, the one we're concerned with is \"timeout\". This "
"signal is emitted whenever the Timer reaches ``0``."
msgstr ""
"\"Inspector\" 탭 옆에 \"Node\"라는 라벨이 붙은 탭이 있습니다. 이 탭을 클릭하"
"면 선택한 노드에서 방출할 수 있는 모든 신호가 표시됩니다. 타이머 노드의 경"
"우, \"timeout\"이 중요합니다. 타이머가 0에 도달할 때마다 신호가 발생합니다."

#: ../../docs/getting_started/step_by_step/signals.rst:46
msgid ""
"Click on the \"timeout()\" signal and click \"Connect...\". You'll see the "
"following window, where you can define how you want to connect the signal:"
msgstr ""
"\"timeout()\" 시그널을 클릭하고 그리고 \"Connect...\"를 누릅니다. 다음과 같"
"은 창이 나타나는데, 여기서 당신은 시그널을 어떻게 연결할 지를 정의할 수 있습"
"니다:"

#: ../../docs/getting_started/step_by_step/signals.rst:51
msgid ""
"On the left side, you'll see the nodes in your scene and can select the node "
"that you want to \"listen\" for the signal. Note that the Timer node is red "
"- this is *not* an error, but is a visual indication that it's the node that "
"is emitting the signal. Select the root node."
msgstr ""
"왼쪽에는 씬(scene)의 노드가 표시되고 신호에 대해 \"수신\"할 노드를 선택할 수 "
"있습니다. 타이머 노드는 적색입니다. 오류가 아니며 신호를 방출하는 노드임을 시"
"각적으로 나타냅니다. 루트 노드를 선택하십시오."

#: ../../docs/getting_started/step_by_step/signals.rst:56
msgid ""
"The target node *must* have a script attached or you'll receive an error "
"message."
msgstr ""
"대상 노드는 *반드시* 스크립트가 붙을 것이고 그렇지 않으면 에러 메시지를 받습"
"니다."

#: ../../docs/getting_started/step_by_step/signals.rst:59
msgid ""
"On the bottom of the window is a field labeled \"Method In Node\". This is "
"the name of the function in the target node's script that you want to use. "
"By default, Godot will create this function using the naming convention "
"``_on_<node_name>_<signal_name>`` but you can change it if you wish."
msgstr ""
"창의 아래쪽을 보시면 \"Method In Node\" 라고 적혀있는 입력 란이 있습니다. 이"
"것은 대상 노드 스크립트에서 함수 이름으로 당신이 사용할 것입니다. 기본적으"
"로, Godot는 명명 규칙에 따라 ``_on_<노드이름>_<시그널이름>`` 으로 함수 이름"
"을 만들지만 원한다면 바꿀 수 있습니다."

#: ../../docs/getting_started/step_by_step/signals.rst:64
msgid ""
"Click \"Connect\" and you'll see that the function has been created in the "
"script:"
msgstr ""
"\"연결\"을 클릭하세요 그러면 스크립트 안에 함수가 만들어진 것을 볼 수 있습니"
"다:"

#: ../../docs/getting_started/step_by_step/signals.rst:84
msgid ""
"Now we can replace the placeholder code with whatever code we want to run "
"when the signal is received. Let's make the Sprite blink:"
msgstr ""
"이제 우리는 시그널이 왔을때 작동되기를 원하는 어떤 코드이던지 placeholder코드"
"를 대체할 수있습니다 Sprite blink를 만들어 보세요:"

#: ../../docs/getting_started/step_by_step/signals.rst:106
msgid ""
"Run the scene and you'll see the Sprite blinking on and off every second. "
"You can change the Timer's *Wait Time* property to alter this."
msgstr ""
"씬을 실행하면 Sprite가 매초마다 깜박이는 것을 볼 수 있습니다. 타이머의 *Wait "
"Time* 속성을 변경하여 변경할 수 있습니다."

#: ../../docs/getting_started/step_by_step/signals.rst:110
msgid "Connecting signals in code"
msgstr "노드에서 시그널 연결하기"

#: ../../docs/getting_started/step_by_step/signals.rst:112
msgid ""
"You can also make the signal connection in code rather than with the editor. "
"This is usually necessary when you're instancing nodes via code and so you "
"can't use the editor to make the connection."
msgstr ""
"코드안에서 사용자는 신호연결을 할 수 있습니다. 사용자가 연결을 위해서 에디터"
"를 사용할 수 없을때 코드를경유하여 노드들을 인스턴화할때 필요합니다."

#: ../../docs/getting_started/step_by_step/signals.rst:116
msgid ""
"First, disconnect the signal by selecting the connection in the Timer's "
"\"Node\" tab and clicking disconnect."
msgstr ""
"타이머의 노드에 연결을 선택하여 시그널은 끊어 낼려면 우선 \"끊기\" 를 클릭하"
"세요."

#: ../../docs/getting_started/step_by_step/signals.rst:121
msgid ""
"To make the connection in code, we can use the ``connect`` function. We'll "
"put it in ``_ready()`` so that the connection will be made on run. The "
"syntax of the function is ``<source_node>.connect(<signal_name>, "
"<target_node>, <target_function_name>)``. Here is the code for our Timer "
"connection:"
msgstr ""
"코드안에서 연결하기 위해서는 'connect' 기능을 사용할 수 있습니다. 사용자가 "
"ready()를 선택하게 되면 연결이 실행됩니다. 함수의 문법은 <source_node>."
"connect(<signal_name>, <target_node>, <target_function_name>) 여기에 godot의 "
"타이머 연결 코드가 있습니다:"

#: ../../docs/getting_started/step_by_step/signals.rst:154
msgid "Custom signals"
msgstr "커스텀 시그널"

#: ../../docs/getting_started/step_by_step/signals.rst:156
msgid "You can also declare your own custom signals in Godot:"
msgstr "Godot안에 당신의 커스텀 시그널을 선언할 수 있습니다:"

#: ../../docs/getting_started/step_by_step/signals.rst:174
msgid ""
"Once declared, your custom signals will appear in the Inspector and can be "
"connected in the same way as a node's built-in signals."
msgstr ""
"일단 한번 선언 되면, 사용자의 커스텀 시그널들은 인스펙터에 나타나게 됩니다 그"
"리고 노드의 시그널 만드는 방식과 같은 방식으로 연결됩니다."

#: ../../docs/getting_started/step_by_step/signals.rst:177
msgid "To emit a signal via code, use the ``emit`` function:"
msgstr "코드를 이용하여 시그널을 보내기 위해서 'emit' 함수를 사용하십시오:"

#: ../../docs/getting_started/step_by_step/signals.rst:203
msgid "Shooting example"
msgstr "예제"

#: ../../docs/getting_started/step_by_step/signals.rst:205
msgid ""
"As another example of signal usage, let's consider a player character that "
"can rotate and shoot towards the mouse. Every time the mouse button is "
"clicked, we create an instance of the bullet at the player's location. See :"
"ref:`doc_instancing` for details."
msgstr ""
"시그널 사용의 다른 예제로 마우스로 총을 쏘고 캐릭터를 회전 시킬 수 있는 플레"
"이어를 생각해보자 마우스가 클릭될때마다 엔진에서 사용자의 위치에 총알 인스턴"
"스가 생성됩니다. 세부사항은 'doc_instancing'를 보십시오."

#: ../../docs/getting_started/step_by_step/signals.rst:210
msgid ""
"However, if the bullets are added as children of the player, then they will "
"remain \"attached\" to the player as it rotates:"
msgstr ""
"그러나 만약 플레이어의 자식으로써 총알이 더해지면 총알 객체들이 플레이어에 "
"\"attached\" 가 됩니다:"

#: ../../docs/getting_started/step_by_step/signals.rst:215
msgid ""
"Instead, we need the bullets to be independent of the player's movement - "
"once fired, they should continue traveling in a straight line and the player "
"can no longer affect them. Instead of being added to the scene tree as a "
"child of the player, it makes more sense to add the bullet as a child of the "
"\"main\" game scene, which may be the player's parent or even further up the "
"tree."
msgstr ""
"대신에 우리는 플레이어의 움직임에 총알이 독립적으로  움직일 필요가 있습니다. "
"한번 발사가되면 일직선으로 계속 나아가야 한다 그리고 플레이어는 더 이상 총알"
"들에 영향을 끼칠 수 없습니다. 플레이어의 자식으로 scene 트리에 더하는것 대신"
"에 게임scene의 메인에 자식으로 총알을 더하는것이  더 좋습니다."

#: ../../docs/getting_started/step_by_step/signals.rst:221
msgid "You could do this by adding the bullet directly:"
msgstr "사용자는 총알을 직접적으로 추가하는것에 의해 이것을 할 수 있습니다:"

#: ../../docs/getting_started/step_by_step/signals.rst:234
msgid ""
"However, this will lead to a different problem. Now if you try and test your "
"\"Player\" scene independently, it will crash on shooting, because there is "
"no parent node to access. This makes it a lot harder to test your player "
"code independently and also means that if you decide to change your main "
"scene's node structure, the player's parent may no longer be the appropriate "
"node to receive the bullets."
msgstr ""
"그러나 이것은 다른 문제를 불러올 수 있습니다. 지금 \"player\"scene을 독립적으"
"로 테스트 해보세요 액세스할 상위 노드가 없기 때문에 촬영 중에 충돌이 발생합니"
"다. 이렇게 하면 플레이어 코드를 독립적으로 테스트하기가 훨씬 어려워지며, 주 "
"씬의 노드 구조를 변경하기로 결정한 경우 플레이어의 부모가 더 이상 총알을 받"
"을 적절한 노드가 아닐 수도 있습니다."

#: ../../docs/getting_started/step_by_step/signals.rst:241
msgid ""
"The solution to this is to use a signal to \"emit\" the bullets from the "
"player. The player then has no need to \"know\" what happens to the bullets "
"after that - whatever node is connected to the signal can \"receive\" the "
"bullets and take the appropriate action to spawn them."
msgstr ""
"이것을 해결하기위해  플레이어에게 총알을 \"emit\"하라는 시그널을 사용합니다. "
"사용자는 이동작이후에 총알에 어떤일이 발생하는지 알필요가 없습니다.신호에 연"
"결된 노드가 무엇이든 총탄을 \"수신\"하고 이를 생성하기 위한 적절한 조치를 취"
"할 수 있습니다."

#: ../../docs/getting_started/step_by_step/signals.rst:247
msgid "Here is the code for the player using signals to emit the bullet:"
msgstr ""
"여기 총알을 방출하기 위해 플레이어가 사용할 시그널들에 대한 코드가 있습니다:"

#: ../../docs/getting_started/step_by_step/signals.rst:290
msgid ""
"In the main scene, we then connect the player's signal (it will appear in "
"the \"Node\" tab)."
msgstr ""
"메인 scene에서 우리는 플레이어의 시그널과 연결합니다(이것은 노드 텝에 나타납"
"니다)."

#: ../../docs/getting_started/step_by_step/signals.rst:314
msgid ""
"Now the bullets will maintain their own movement independent of the player's "
"rotation:"
msgstr ""
"이제 총알은 자신의 움직임을 유지한체로 플레이어의 위치와 관계없이 독립적으로 "
"움직일 것입니다:"

#: ../../docs/getting_started/step_by_step/signals.rst:320
msgid "Conclusion"
msgstr "결론"

#: ../../docs/getting_started/step_by_step/signals.rst:322
msgid ""
"Many of Godot's built-in node types provide signals you can use to detect "
"events. For example, an :ref:`Area2D <class_Area2D>` representing a coin "
"emits a ``body_entered`` signal whenever the player's physics body enters "
"its collision shape, allowing you to know when the player collected it."
msgstr ""
"Godot의 내장 노드 유형 중 다수는 이벤트를 감지하는 데 사용할 수 있는 신호를 "
"제공합니다. 예를 들어, 동전 하나를 나타내는 :ref:Area2D <class_Area2D>는 플레"
"이어가 충돌하는 모양을 만들 때 마다 \"body_entered\" 신호를 발산하여 사용자"
"가 알 수 있게 합니다."

#: ../../docs/getting_started/step_by_step/signals.rst:327
msgid ""
"In the next section, :ref:`doc_your_first_game`, you'll build a complete "
"game including several uses of signals to connect different game components."
msgstr ""
"다음 섹션인 :ref:doc_your_first_게임은 다양한 게임 컴포넌트를 연결하기 위한 "
"몇 가지 신호 사용이 포함된 완전한 게임을 만들 것입니다."
