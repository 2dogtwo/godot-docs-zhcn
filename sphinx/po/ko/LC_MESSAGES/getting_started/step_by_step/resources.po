# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2019, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-12-21 12:27+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../docs/getting_started/step_by_step/resources.rst:4
msgid "Resources"
msgstr "리소스"

#: ../../docs/getting_started/step_by_step/resources.rst:7
msgid "Nodes and resources"
msgstr "노드와 리소스"

#: ../../docs/getting_started/step_by_step/resources.rst:9
msgid ""
"Up to this tutorial, we focused on the :ref:`Node <class_Node>` class in "
"Godot as that's the one you use to code behavior and most of the engine's "
"features rely on it. There is another datatype that is just as important: :"
"ref:`Resource <class_Resource>`."
msgstr ""
"지금까지, :ref:`Node <class_Node>` 클래스는  Godot에서 가장 중요한 데이터 형"
"식으로 엔진 내 대부분의 기능과 작동이 이것으로 이루어 졌다는 것에 초점을 두었"
"습니다. 이와 똑같이 중요한 데이터 형식이 있습니다: :ref:`Resource "
"<class_Resource>` 입니다."

#: ../../docs/getting_started/step_by_step/resources.rst:15
msgid ""
"*Nodes* give you functionality: they draw sprites, 3D models, simulate "
"physics, arrange user interfaces, etc. **Resources** are **data "
"containers**. They don't do anything on their own: instead, nodes use the "
"data contained in resources."
msgstr ""
"*노드*\\ 는 다음과 같은 기능을 제공합니다: 스프라이트를 그려주고 3D 모델링을 "
"해주며 물리 시뮬레이션을 해주고, 유저 인터페이스 정리 등을 해줍니다.\n"
"**리소스**\\ 는 **데이터 컨테이너**\\ 입니다. 리소스 그 자체로는 아무 일도 하"
"지 않습니다: 대신에 노드가 리소스에 포함되어 있는 데이터를 사용합니다."

#: ../../docs/getting_started/step_by_step/resources.rst:19
#, fuzzy
msgid ""
"Anything Godot saves or loads from disk is a resource. Be it a scene (a ``."
"tscn`` or an ``.scn`` file), an image, a script... Here are some "
"``Resource`` examples: :ref:`Texture <class_Texture>`, :ref:`Script "
"<class_Script>`, :ref:`Mesh <class_Mesh>`, :ref:`Animation "
"<class_Animation>`, :ref:`AudioStream <class_AudioStream>`, :ref:`Font "
"<class_Font>`, :ref:`Translation <class_Translation>`."
msgstr ""
"Godot에서 디스크에 저장하고 불러오는 모든 것이 리소스입니다. 씬이나 (.tscn 이"
"나 .scn 파일), 이미지, 스크립트... ``리소스`` 예제들입니다: :ref:`Texture "
"<class_Texture>`, :ref:`Script <class_Script>`, :ref:`Mesh <class_Mesh>`, :"
"ref:`Animation <class_Animation>`, :ref:`AudioStream <class_AudioStream>`, :"
"ref:`Font <class_Font>`, :ref:`Translation <class_Translation>`."

#: ../../docs/getting_started/step_by_step/resources.rst:26
msgid ""
"When the engine loads a resource from disk, **it only loads it once**. If a "
"copy of that resource is already in memory, trying to load the resource "
"again will return the same copy every time. As resources only contain data, "
"there is no need to duplicate them."
msgstr ""
"리소스가 디스크에서 불러올 때, **항상 한번만 불러옵니다**. 즉, 메모리에서 이"
"미 불러온 리소스의 복사본이 있다면, 다시 리소스를 불러 오려고 해도 같은 복사"
"본을 계속해서 반환될 것입니다. 리소스는 오직 데이터 컨테이너로 복사할 필요가 "
"없습니다."

#: ../../docs/getting_started/step_by_step/resources.rst:31
msgid ""
"Every object, be it a Node or a Resource, can export properties. There are "
"many types of Properties, like String, integer, Vector2, etc., and any of "
"these types can become a resource. This means that both nodes and resources "
"can contain resources as properties:"
msgstr ""
"노드가 될 수 있는 모든 대상은 속성을 내보낼 수 있습니다. 속성은 문자열, 정"
"수, Vector2, 등과 같은 많은 타입이 될 수 있고, 그 유형들 중 하나가 리소스가 "
"될 수 있습니다. 이는 노드와 리소스가 모두 리소스를 속성으로 가질 수 있다는 것"
"을 의미합니다:"

#: ../../docs/getting_started/step_by_step/resources.rst:39
msgid "External vs built-in"
msgstr "외부(External) vs 내장(built-in)"

#: ../../docs/getting_started/step_by_step/resources.rst:41
msgid "There are two ways to save resources. They can be:"
msgstr "리소스를 저장하는 두 가지 방법이 있습니다. 이렇게 될 수 있습니다:"

#: ../../docs/getting_started/step_by_step/resources.rst:43
msgid "**External** to a scene, saved on the disk as individual files."
msgstr "씬의 **외부**에 개별 파일로 저장."

#: ../../docs/getting_started/step_by_step/resources.rst:44
#, fuzzy
msgid ""
"**Built-in**, saved inside the ``.tscn`` or the ``.scn`` file they're "
"attached to."
msgstr "\\*.tscn 이나 \\*.scn 파일 내부에 첨부하여 씬에 **내장**하여 저장."

#: ../../docs/getting_started/step_by_step/resources.rst:46
msgid ""
"To be more specific, here's a :ref:`Texture <class_Texture>` in a :ref:"
"`Sprite <class_Sprite>` node:"
msgstr ""
"보다 구체적으로는, :ref:`Sprite <class_Sprite>` 노드의 :ref:`Texture "
"<class_Texture>` 가 있습니다:"

#: ../../docs/getting_started/step_by_step/resources.rst:51
msgid ""
"Clicking the resource preview allows us to view and edit the resource's "
"properties."
msgstr "리소스 미리보기를 클릭해서 리소스를 보고 속성을 편집합니다."

#: ../../docs/getting_started/step_by_step/resources.rst:55
msgid ""
"The path property tells us where the resource comes from. In this case, it "
"comes from a PNG image called ``robi.png``. When the resource comes from a "
"file like this, it is an external resource. If you erase the path or this "
"path is empty, it becomes a built-in resource."
msgstr ""
"경로 속성은 리소스가 어디에서 오는 지를 알려줍니다. 이 경우에 리소스는  "
"``robi.png``\\ 라 부르는 PNG 이미지에서 왔습니다. 리소스가 이와 같은 파일에"
"서 올 때, 그것은 외부 리소스 입니다. 경로를 지우거나 경로가 비어있다면, 그것"
"은 내장 리소스가 됩니다."

#: ../../docs/getting_started/step_by_step/resources.rst:60
#, fuzzy
msgid ""
"The switch between built-in and external resources happens when you save the "
"scene. In the example above, if you erase the path ``\"res://robi.png\"`` "
"and save, Godot will save the image inside the ``.tscn`` scene file."
msgstr ""
"내장과 외부 리소스 간의 전환은 씬을 저장할 때 발생합니다. 위의 예시에서, 경"
"로  \\`\"res://robi.png\"\\`를 지우고 저장한다면 Godot는 .tscn 씬 파일 안에 "
"이미지를 저장합니다."

#: ../../docs/getting_started/step_by_step/resources.rst:66
msgid ""
"Even if you save a built-in resource, when you instance a scene multiple "
"times, the engine will only load one copy of it."
msgstr ""
"씬을 여러 번 인스턴스 할 때, 내장 리소스를 저장하더라도 엔진은 오직 하나의 사"
"본으로만 불러옵니다."

#: ../../docs/getting_started/step_by_step/resources.rst:70
msgid "Loading resources from code"
msgstr "코드에서 리소스를 불러오기"

#: ../../docs/getting_started/step_by_step/resources.rst:72
msgid ""
"There are two ways to load resources from code. First, you can use the "
"``load()`` function anytime:"
msgstr ""
"코드에서 리소스를 불러오는 두 가지 방법이 있습니다. 첫 번째로, 언제든지 "
"``load()`` 함수를 사용할 수 있습니다:"

#: ../../docs/getting_started/step_by_step/resources.rst:90
msgid ""
"You can also ``preload`` resources. Unlike ``load``, this function will read "
"the file from disk and load it at compile-time. As a result, you cannot call "
"preload with a variable path: you need to use a constant string."
msgstr ""
"또한 리소스를 ``미리 불러올 수(preload)`` 있습니다. ``load`` 와는 다르게, 이 "
"함수는 디스크에서 파일을 읽고 컴파일 시간에 파일을 불러옵니다. 그 결과, 변수 "
"경로로 미리 불러오기를 호출할 수 없습니다: 상수 문자열을 사용해야 합니다."

#: ../../docs/getting_started/step_by_step/resources.rst:106
msgid "Loading scenes"
msgstr "씬 불러오기"

#: ../../docs/getting_started/step_by_step/resources.rst:108
msgid ""
"Scenes are also resources, but there is a catch. Scenes saved to disk are "
"resources of type :ref:`PackedScene <class_PackedScene>`. The scene is "
"packed inside a resource."
msgstr ""
"씬 또한 리소스 입니다, 하지만 함정이 있습니다. 씬은 디스크에 :ref:"
"`PackedScene <class_PackedScene>` 타입의 리소스로 저장됩니다. 씹은 리소스 안"
"에 압축됩니다."

#: ../../docs/getting_started/step_by_step/resources.rst:112
msgid ""
"To get an instance of the scene, you have to use the :ref:`PackedScene."
"instance() <class_PackedScene_method_instance>` method."
msgstr ""
"씬의 인스턴스를 얻기 위해, :ref:`PackedScene.instance() "
"<class_PackedScene_method_instance>` 메서드를 사용해야 합니다."

#: ../../docs/getting_started/step_by_step/resources.rst:133
msgid ""
"This method creates the nodes in the scene's hierarchy, configures them, and "
"returns the root node of the scene. You can then add it as a child of any "
"other node."
msgstr ""
"이 메서드는 씬의 계층 구조에 노드들을 만들고, 그들을 구성하고, 씬의 루트 노드"
"로 반환합니다. 그런 뒤 이것을 다른 노드의 자식으로 추가할 수 있습니다."

#: ../../docs/getting_started/step_by_step/resources.rst:137
msgid ""
"The approach has several advantages. As the :ref:`PackedScene.instance() "
"<class_PackedScene_method_instance>` function is fast, you can create new "
"enemies, bullets, effects, etc. without having to load them again from disk "
"each time. Remember that, as always, images, meshes, etc. are all shared "
"between the scene instances."
msgstr ""
"이 접근은 여러 장점이 있습니다. :ref:`PackedScene.instance() "
"<class_PackedScene_method_instance>` 함수가 꽤 빠르기 때문에, 씬에 새로운 "
"적, 총알, 효과 등이 빠르게 추가되고 삭제될 수 있습니다, 각각을 디스크에서 불"
"러올 필요가 없다는 것입니다. 항상 그래왔듯, 이미지, 메시 등은 모두 씬 인스턴"
"스와 공유한다는 것을 명심하세요."

#: ../../docs/getting_started/step_by_step/resources.rst:144
msgid "Freeing resources"
msgstr "리소스 해제(Free)하기"

#: ../../docs/getting_started/step_by_step/resources.rst:146
msgid ""
"When a ``Resource`` is no longer in use, it will automatically free itself. "
"Since, in most cases, Resources are contained in Nodes, when you free a "
"node, the engine frees all the resources it owns as well if no other node "
"uses them."
msgstr ""
"``리소스``\\ 가 더 이상 사용되지 않을 때, 그것은 자동으로 스스로를 해제(Free)"
"합니다. 대부분의 경우, 리소스는 노드, 스크립트 혹은 다른 리소스에 포함되어 있"
"기 때문에, 노드를 해제할 때, 엔진은 이 노드 외에 다른 노드가 더 이상 쓰지 않"
"는 리소스도 해제합니다."

#: ../../docs/getting_started/step_by_step/resources.rst:151
msgid "Creating your own resources"
msgstr "자신의 리소스 만들기"

#: ../../docs/getting_started/step_by_step/resources.rst:153
msgid ""
"Like any Object in Godot, users can also script Resources. Resource scripts "
"inherit the ability to freely translate between object properties and "
"serialized text or binary data (/*.tres, /*.res). They also inherit the "
"reference-counting memory management from the Reference type."
msgstr ""
"Godot에서 어느 객체와 마찬가지로, 사용자는 리소스를 작성할 수 있습니다. 리소"
"스 스크립트는 객체 속성간의 자유로운 변환과 텍스트 또는 이진 데이터 (/*."
"tres, /*.res)를 직렬화하는 기능을 상속합니다. 그리고 참조 타입으로부터 참조 "
"계산 메모리 관리를 상속합니다."

#: ../../docs/getting_started/step_by_step/resources.rst:158
msgid ""
"This comes with many distinct advantages over alternative data structures, "
"such as JSON, CSV, or custom TXT files. Users can only import these assets "
"as a :ref:`Dictionary <class_Dictionary>` (JSON) or as a :ref:`File "
"<class_File>` to parse. What sets Resources apart is their inheritance of :"
"ref:`Object <class_Object>`, :ref:`Reference <class_Reference>`, and :ref:"
"`Resource <class_Resource>` features:"
msgstr ""
"JSON, CSV, 혹은 커스텀 TXT 파일로 이루어진 이것은 대체 데이터 구조를 넘어서 "
"많은 뚜렷한 이점을 제공합니다. 사용자는 이 애셋을 문법 분석하기 위해 :ref:"
"`Dictionary <class_Dictionary>` (JSON) 혹은 :ref:`File <class_File>`\\ 로만 "
"가져올 수 있습니다. 리소스는 :ref:`Object <class_Object>`, :ref:`Reference "
"<class_Reference>`, 그리고 :ref:`Resource <class_Resource>` 기능의 상속을 통"
"해 구분합니다:"

#: ../../docs/getting_started/step_by_step/resources.rst:165
msgid ""
"They can define constants, so constants from other data fields or objects "
"are not needed."
msgstr ""
"그들은 상수를 정의할 수 있기 때문에, 다른 데이터 필드나 객체의 상수는 필요하"
"지 않습니다."

#: ../../docs/getting_started/step_by_step/resources.rst:167
msgid ""
"They can define methods, including setter/getter methods for properties. "
"This allows for abstraction and encapsulation of the underlying data. If the "
"Resource script's structure needs to change, the game using the Resource "
"need not also change."
msgstr ""
"그들은 속성을 위한 setter/getter 메서드를 포함한 메서드를 정의할 수 있습니"
"다. 이것으로 기본 데이터의 추출과 캡슐화를 할 수 있습니다. 리소스 스크립트의 "
"구조가 변경되어야 하더라도, 리소스를 사용하는 게임이 변경되지 않아도 됩니다."

#: ../../docs/getting_started/step_by_step/resources.rst:169
msgid ""
"They can define signals, so Resources can trigger responses to changes in "
"the data they manage."
msgstr ""
"그들은 시그널을 정의할 수 있기 때문에, 리소스는 관리한 데이터의 변경에 대한 "
"응답을 트리거 할 수 있습니다."

#: ../../docs/getting_started/step_by_step/resources.rst:171
msgid ""
"They have defined properties, so users know 100% that their data will exist."
msgstr ""
"그들은 속성을 정의하기 때문에, 사용자는 데이터가 존재한다는 것을 100% 압니다."

#: ../../docs/getting_started/step_by_step/resources.rst:173
msgid ""
"Resource auto-serialization and deserialization is a built-in Godot Engine "
"feature. Users do not need to implement custom logic to import/export a "
"resource file's data."
msgstr ""
"리소스 자동 직렬화와 비 직렬화는 Godot 엔진 내장 기능입니다. 사용자는 리소스 "
"파일의 데이터를 가져오기/내보내기 위해 커스텀 로직을 구현할 필요가 없습니다."

#: ../../docs/getting_started/step_by_step/resources.rst:175
msgid ""
"Resources can even serialize sub-Resources recursively, meaning users can "
"design even more sophisticated data structures."
msgstr ""
"리소스는 심지어 하위 리소스를 재귀적으로 직렬화 할 수 있습니다, 즉 사용자는 "
"훨씬 더 정교한 데이터 구조를 설계할 수 있습니다."

#: ../../docs/getting_started/step_by_step/resources.rst:177
msgid ""
"Users can save Resources as version-control-friendly text files (\\*.tres). "
"Upon exporting a game, Godot serializes resource files as binary files (\\*."
"res) for increased speed and compression."
msgstr ""
"사용자는 리소스를 버전 제어 친화적 텍스트 파일 (\\*.tres)로 저장할 수 있습니"
"다. 게임을 내보낼 때, Godot는 리소스 파일을 이진 파일 (\\*.res)로 직렬화 하"
"여 속도와 압축을 증가시킵니다."

#: ../../docs/getting_started/step_by_step/resources.rst:179
msgid ""
"Godot Engine's Inspector renders and edits Resource files out-of-the-box. As "
"such, users often do not need to implement custom logic to visualize or edit "
"their data. To do so, double-click the resource file in the FileSystem dock "
"or click the folder icon in the Inspector and open the file in the dialog."
msgstr ""
"Godot 엔진의 인스펙터(Inspecter)는 리소스 파일을 즉시 렌더링하고 편집합니다. "
"이와 같이, 사용자는 종종 데이터를 시각화 하거나 편집하기 위한 커스텀 로직을 "
"구현할 필요가 없습니다. 그러기 위해서, 파일 시스템 독에서 리소스를 더블 클릭"
"하거나 인스펙터(Inspecter)에서 폴더 아이콘을 클릭하고 대화 상자에서 파일을 엽"
"니다."

#: ../../docs/getting_started/step_by_step/resources.rst:181
msgid ""
"They can extend **other** resource types besides just the base Resource."
msgstr "그들은 기본 리소스 외에도 **다른** 리소스 타입도 확장할 수 있습니다."

#: ../../docs/getting_started/step_by_step/resources.rst:185
#, fuzzy
msgid ""
"Resources and Dictionaries are both passed by reference, but only Resources "
"are reference-counted. This means that if a Dictionary is passed between "
"objects and the first object is deleted, all other objects' references to "
"the Dictionary will be invalidated. Conversely, Resources will not be freed "
"from memory until *all* the objects are deleted."
msgstr ""
"리소스와 딕셔너리는 둘 다 참조로서 전달되지만, 리소스는 참조 카운트가 된다는 "
"점에서 딕셔너리와 다릅니다. 즉, 딕셔너리가 객체 사이를 지나가고 첫 번째 객체"
"가 삭제된다면, 딕셔너리에 대한 다른 모든 객체들의 참조는 무효화될 것입니다. "
"반면, 리소스는 *모든* 객체가 사라질 때까지 메모리를 해제하지 않습니다."

#: ../../docs/getting_started/step_by_step/resources.rst:215
msgid "Godot makes it easy to create custom Resources in the Inspector."
msgstr "Godot는 인스펙터(Inspecter)에서 커스텀 리소스를 만들기 쉽게 합니다."

#: ../../docs/getting_started/step_by_step/resources.rst:217
msgid ""
"Create a plain Resource object in the Inspector. This can even be a type "
"that derives Resource, so long as your script is extending that type."
msgstr ""
"인스펙터(Inspecter)에서 순수한 리소스를 만듭니다. 스크립트가 해당 타입을 확장"
"하는 동안, 이것은 심지어 리소스를 파생하는 타입일 수 있습니다."

#: ../../docs/getting_started/step_by_step/resources.rst:218
msgid "Set the ``script`` property in the Inspector to be your script."
msgstr ""
"인스펙터(Inspecter)에서 ``script`` 속성을 당신의 스크립트로 설정합니다."

#: ../../docs/getting_started/step_by_step/resources.rst:220
msgid ""
"The Inspector will now display your Resource script's custom properties. If "
"one edits those values and saves the resource, the Inspector serializes the "
"custom properties too! To save a resource from the Inspector, click the "
"Inspector's tools menu (top right), and select \"Save\" or \"Save As...\"."
msgstr ""
"인스펙터(Inspecter)는 이제 리소스 스크립트의 커스텀 속성을 보여줍니다. 이 값"
"을 편집하고 리소스를 저장하면, 인스펙터(Inspecter)는 커스텀 속성 역시 직렬화 "
"합니다! 인스펙터(Inspecter)에서 리소스를 저장하기 위해, 인스펙터(Inspecter)"
"의 도구 메뉴 (우측 상단)를 클릭하고, \"저장하기\"나 \"다른 이름으로 저장..."
"\"을 선택합니다."

#: ../../docs/getting_started/step_by_step/resources.rst:225
msgid ""
"If the script's language supports :ref:`script classes "
"<doc_scripting_continued_class_name>`, then it streamlines the process. "
"Defining a name for your script alone will add it to the Inspector's "
"creation dialog. This will auto-add your script to the Resource object you "
"create."
msgstr ""
"스크립트의 언어가 :ref:`스크립트 클래스 <doc_scripting_continued_class_name>`"
"\\를 지원한다면, 프로세스가 간소화됩니다. 스크립트에 이름만 정의하는 것으로 "
"인스펙터(Inspecter)의 생성 대화 상자에 리소스를 추가할 것입니다. 이렇게 하면 "
"생성된 리소스 객체에 스크립트가 자동으로 추가됩니다."

#: ../../docs/getting_started/step_by_step/resources.rst:230
msgid "Let's see some examples."
msgstr "몇 가지 예를 살펴보겠습니다."

#: ../../docs/getting_started/step_by_step/resources.rst:303
msgid ""
"Resource scripts are similar to Unity's ScriptableObjects. The Inspector "
"provides built-in support for custom resources. If desired though, users can "
"even design their own Control-based tool scripts and combine them with an :"
"ref:`EditorPlugin <class_EditorPlugin>` to create custom visualizations and "
"editors for their data."
msgstr ""
"리소스 스크립트는 Unity의 ScriptableObjects(스크립트 가능한 객체)와 유사합니"
"다. 인스펙터(Inspecter)는 커스텀 리소스를 위한 내장 지원을 제공합니다. 그래"
"도 원한다면, 사용자는 자신만의 제어 기반 도구 스크립트를 설계하고 그들을 :"
"ref:`EditorPlugin <class_EditorPlugin>`\\ 으로 결합하여 커스텀 시각화와 데이"
"터를 위한 편집기를 만들 수 있습니다."

#: ../../docs/getting_started/step_by_step/resources.rst:309
msgid ""
"Unreal Engine 4's DataTables and CurveTables are also easy to recreate with "
"Resource scripts. DataTables are a String mapped to a custom struct, similar "
"to a Dictionary mapping a String to a secondary custom Resource script."
msgstr ""
"언리얼 엔진 4의 DataTables와 CurveTables 또한 리소스 스크립트로 쉽게 재생성 "
"할 수 있습니다. DataTables은 커스텀 구조체에 매핑된 문자열로, 이차적인 커스"
"텀 리소스 스크립트에 문자열을 매핑하는 딕셔너리와 유사합니다."

#: ../../docs/getting_started/step_by_step/resources.rst:345
msgid ""
"Instead of just inlining the Dictionary values, one could also, "
"alternatively..."
msgstr ""
"딕셔너리 값을 inlining(인라이닝)하는 대신, 또 다른 할 수 있는 대안으로..."

#: ../../docs/getting_started/step_by_step/resources.rst:347
msgid ""
"Import a table of values from a spreadsheet and generate these key-value "
"pairs, or..."
msgstr "스프레드 시트에서 테이블 값을 가져오고 키 값 쌍을 생성합니다, 혹은..."

#: ../../docs/getting_started/step_by_step/resources.rst:349
msgid ""
"Design a visualization within the editor and create a simple plugin that "
"adds it to the Inspector when you open these types of Resources."
msgstr ""
"편집기 내에서 시각화를 설계하고 해당 타입 리소스를 열 때 인스펙터(Inspecter)"
"에 리소스를 추가하는 간단한 플러그인을 제작합니다."

#: ../../docs/getting_started/step_by_step/resources.rst:352
msgid ""
"CurveTables are the same thing, except mapped to an Array of float values or "
"a :ref:`Curve <class_Curve>`/:ref:`Curve2D <class_Curve2D>` resource object."
msgstr ""
"두 가지 방법이 항상 호환되는 것은 아닙니다. 컨테이너는 자식을 제어하기 때문"
"에, 레이아웃 메뉴를 그것들에게 사용할 수 없습니다. 각 컨테이너는 특정한 효과"
"를 갖고 있으므로 당신은 제대로 동작하는 인터페이스를 얻기 위해 그들을 중첩"
"(nest)할지도 모릅니다. 레이아웃 접근을 사용하는 경우 자식들을 아래계층에서 위"
"계층 방향으로 작업합니다. 씬에 추가적이 컨테이너를 사용하지 않으므로 더 깨끗"
"한 계층 구조를 만들 수 있지만, 항목을 행이나 열, 격자 등으로 배열하기는 더 어"
"렵습니다."

#: ../../docs/getting_started/step_by_step/resources.rst:357
msgid ""
"Beware that resource files (\\*.tres/\\*.res) will store the path of the "
"script they use in the file. When loaded, they will fetch and load this "
"script as an extension of their type. This means that trying to assign a "
"subclass, i.e. an inner class of a script (such as using the ``class`` "
"keyword in GDScript) won't work. Godot will not serialize the custom "
"properties on the script subclass properly."
msgstr ""
"리소스 파일 (\\*.tres/\\*.res)이 파일에서 사용하는 스크립트의 경로를 저장한다"
"는 점에 주의하세요. 스크립트를 불러올 때, 이 스크립트를 가져와서 해당 타입의 "
"확장으로 불러옵니다. 다시 말해 하위 클래스, 즉 스크립트의 내부 클래스 "
"(GDScript에서 ``class`` 키워드를 사용하는 것)를 할당할 수 없습니다. Godot는 "
"스크립트 하위 클래스에 커스텀 속성을 정확하게 직렬화 하지 않을 것입니다."

#: ../../docs/getting_started/step_by_step/resources.rst:363
msgid ""
"In the example below, Godot would load the ``Node`` script, see that it "
"doesn't extend ``Resource``, and then determine that the script failed to "
"load for the Resource object since the types are incompatible."
msgstr ""
"아래 예시에서, Godot는 ``Node`` 스크립트를 불러오고, ``Resource``\\ 를 확장"
"(extend)하지 않음을 확인합니다, 그런 다음 타입이 맞지 않으면 스크립트가 리소"
"스 객체에 대해 불러오지 못했음을 확인합니다."
