# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2019, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-07-02 14:18+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:4
msgid "Scripting (continued)"
msgstr "스크립팅(계속)"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:7
msgid "Processing"
msgstr "프로세싱(Processing)"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:9
msgid ""
"Several actions in Godot are triggered by callbacks or virtual functions, so "
"there is no need to write code that runs all the time."
msgstr ""
"Godot의 여러 작업은 콜백 또는 가상 함수에 의해 트리거 되므로, 항상 실행되는 "
"코드를 작성할 필요는 없습니다."

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:12
msgid ""
"However, it is still common to need a script to be processed on every frame. "
"There are two types of processing: idle processing and physics processing."
msgstr ""
"그러나 여전히 모든 프레임에서 스크립트를 처리해야 하는 경우가 많습니다. 프로"
"세싱에는 두가지 유형이 있습니다: 정적 프로세싱과 동적 프로세싱입니다."

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:16
msgid ""
"Idle processing is activated when the method :ref:`Node._process() "
"<class_Node_method__process>` is found in a script. It can be turned off and "
"on with the :ref:`Node.set_process() <class_Node_method_set_process>` "
"function."
msgstr ""
"정적 프로세싱은 스크립트에서 :ref:`Node._process() "
"<class_Node_method__process>`\\ 라는 메서드가 발견되면 활성화됩니다. :ref:"
"`Node.set_process() <class_Node_method_set_process>`\\ 를 사용해서 이 기능을 "
"끄거나 켤 수 있습니다."

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:20
msgid "This method will be called every time a frame is drawn:"
msgstr "이 메서드는 매 프레임마다 호출됩니다:"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:36
msgid ""
"It's important to bear in mind that the frequecy with which ``_process()`` "
"will be called depends on how many frames per second (FPS) your application "
"is running at. This rate can vary over time and devices."
msgstr ""
"``_process()``\\ 가 호출되는 비중은 응용프로그램이 초 당 몇 프레임 (FPS)으로 "
"실행하는 지에 따라 다르다는 것을 마음에 두는 것이 중요합니다. 이 비율은 시간"
"과 기기에 따라 다를 수 있습니다."

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:40
msgid ""
"To help manage this variability the ``delta`` parameter contains the time "
"elapsed in seconds, as a floating point, since the previous call to "
"``_process()``."
msgstr ""
"이 변동성을 다루는 것을 돕기 위해, ``_process()``\\ 가 호출된 이후부터 "
"``delta`` 매개 변수는 경과된 시간을 초 단위, 즉 실수의 형태로 갖습니다."

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:43
msgid ""
"This parameter can be used to make sure things always take the same amount "
"of time, regardless of the game's FPS."
msgstr ""
"이 매개 변수를 사용하면 게임의 초당 프레임 수와 관계 없이, 항상 동일한 시간"
"이 소요되도록 할 수 있습니다."

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:46
msgid ""
"For example, movement is often multiplied with a time delta to make movement "
"speed both constant and independent from the frame rate."
msgstr ""
"예를 들어 이동은 시간 델타를 곱해서 이동 속도를 일정하게 하는 동시에 프레임률"
"과 따로 독립시킵니다."

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:49
msgid ""
"Physics processing with ``_physics_process()`` is similar, but it should be "
"used for processes that must happen before each physics step, such as "
"controlling a character. It always runs before a physics step and it is "
"called at fixed time intervals: 60 times per second by default. You can "
"change the interval from the Project Settings, under Physics -> Common -> "
"Physics Fps."
msgstr ""
"``_physics_process()`` 를 이용한 물리 처리는 이와 유사하지만, 이것은 캐릭터"
"를 조작하는 과정 같이, 각각의 물리 단계 이전에서 반드시 발생하는 과정에 사용"
"되어야 합니다. 이것은 항상 물리 단계 이전에 실행되며 고정된 시간 간격으로 호"
"출됩니다: 기본은 초당 60회 입니다. 프로젝트 설정의 Physics -> Common -> "
"Physics Fps에서 시간 간격을 변경할 수 있습니다."

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:55
msgid ""
"The function ``_process()``, however, is not synced with physics. Its frame "
"rate is not constant and is dependent on hardware and game optimization. Its "
"execution is done after the physics step on single-threaded games."
msgstr ""
"그러나 ``_proceed()`` 함수는 물리와 동기화되지 않습니다. 프레임률이 일정하지 "
"않고 하드웨어와 게임 최적화에 의존하기 때문입니다. 이것은 단일 스레드 게임의 "
"물리 단계를 거친 후에 실행됩니다."

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:58
msgid ""
"A simple way to see the ``_process()`` function at work is to create a scene "
"with a single Label node, with the following script:"
msgstr ""
"``_process()`` 함수가 작동하는 것을 보는 간단한 방법은 하나의 Label 노드로 "
"된 씬을 생성하고, 다음 스크립트를 넣는 것입니다:"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:85
msgid "Which will show a counter increasing each frame."
msgstr "위 스크립트는 프레임 당 증가하는 카운터를 보여 줍니다."

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:88
msgid "Groups"
msgstr "그룹"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:90
#, fuzzy
msgid ""
"Groups in Godot work like tags you might have come across in other software. "
"A node can be added to as many groups as desired. This is a useful feature "
"for organizing large scenes. There are two ways to add nodes to groups. The "
"first is from the UI, using the Groups button under the Node panel:"
msgstr ""
"Godot에서 그룹은 다른 소프트웨어에서 접했을 태그와 비슷합니다. 노드는 많은 그"
"룹에 원하는 만큼 추가될 수 있습니다. 거대한 씬을 조직하는데 유용한 기능입니"
"다. 노드를 그룹에 추가하는 두가지 방법이 있습니다. 첫번째는 UI에서 하는 것으"
"로, 노드 패널 하단의 그룹 버튼을 사용합니다:"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:97
msgid ""
"And the second way is from code. The following script would add the current "
"node to the ``enemies`` group as soon as it appeared in the scene tree."
msgstr ""
"두번째 방법은 코드에서 하는 것입니다. 다음 코드는 씬 트리가 나타나면 "
"``enemies``\\ 라는 그룹에 현재 노드를 추가할 것입니다."

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:115
msgid ""
"This way, if the player is discovered sneaking into a secret base, all "
"enemies can be notified about its alarm sounding by using :ref:`SceneTree."
"call_group() <class_SceneTree_method_call_group>`:"
msgstr ""
"이렇게 하면 플레이어가 비밀 기지에 몰래 들어간 것이 발견될 경우, :ref:"
"`SceneTree.call_group() <class_SceneTree_method_call_group>`\\ 을 사용하여 모"
"든 적에게 경보가 울린다는 사실을 알릴 수 있습니다:"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:132
msgid ""
"The above code calls the function ``player_was_discovered`` on every member "
"of the group ``enemies``."
msgstr ""
"위의 코드는 모든 ``enemies`` 의 ``player_was_discovered`` 함수를 호출합니다."

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:135
msgid ""
"It is also possible to get the full list of ``enemies`` nodes by calling :"
"ref:`SceneTree.get_nodes_in_group() "
"<class_SceneTree_method_get_nodes_in_group>`:"
msgstr ""
"또한 :ref:`SceneTree.get_nodes_in_group() "
"<class_SceneTree_method_get_nodes_in_group>`\\ 을 호출하여 ``enemies`` 노드"
"의 전체 목록을 가져올 수도 있습니다:"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:148
msgid ""
"The :ref:`SceneTree <class_SceneTree>` class provides many useful methods, "
"like interacting with scenes, their node hierarchy and groups of nodes. It "
"allows you to easily switch scenes or reload them, to quit the game or pause "
"and unpause it. It even comes with interesting signals. So check it out if "
"you have some time!"
msgstr ""
":ref:`SceneTree <class_SceneTree>` 클래스는 씬들끼리, 노드 계층끼리, 그리고 "
"노드의 그룹들끼리 상호작용하는 많은 유용한 메서드를 제공합니다. 이것으로 쉽"
"게 씬을 바꾸거나 다시 불러올 수 있고, 게임을 끄거나 일시정지를 키고 끄는 행위"
"를 할 수 있습니다. 심지어 흥미로운 시그널도 동반됩니다. 시간이 된다면 한번 확"
"인해보세요!"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:156
msgid "Notifications"
msgstr "알림(Notifications)"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:158
msgid ""
"Godot has a system of notifications. These are usually not needed for "
"scripting, as it's too low-level and virtual functions are provided for most "
"of them. It's just good to know they exist. For example, you may add an :ref:"
"`Object._notification() <class_Object_method__notification>` function in "
"your script:"
msgstr ""
"Godot에는 알림(notification) 시스템이 있습니다. 보통은 스크립팅에 쓰이진 않습"
"니다, 너무 로우 레벨이며 대부분의 경우 가상 함수를 제공하기 때문이죠. 그냥 존"
"재한다는 것 만으로도 좋은 일입니다. 예를 들어 스크립트에 :ref:`Object."
"_notification() <class_Object_method__notification>` 함수를 추가할 수 있습니"
"다:"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:193
msgid ""
"The documentation of each class in the :ref:`Class Reference <toc-class-"
"ref>` shows the notifications it can receive. However, in most cases "
"GDScript provides simpler overrideable functions."
msgstr ""
":ref:`Class Reference <toc-class-ref>` 의 각 클래스에 대한 문서는 수신 가능"
"한 알림을 보여 줍니다. 그러나 대부분의 경우 GDScript가 보다 단순한 오버라이"
"딩 할 수 있는 함수들을 제공합니다."

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:198
msgid "Overrideable functions"
msgstr "오버라이딩(Overriding) 가능한 함수들"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:200
msgid ""
"Such overrideable functions, which are described as follows, can be applied "
"to nodes:"
msgstr "다음과 같이 오버라이딩 가능한 함수들을 노드에 적용할 수 있습니다:"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:272
msgid ""
"As mentioned before, it's better to use these functions instead of the "
"notification system."
msgstr ""
"앞서 언급했듯이, 이러한 기능은 알림 시스템 대신 사용하는 것이 좋습니다."

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:276
msgid "Creating nodes"
msgstr "노드 생성하기"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:278
msgid ""
"To create a node from code, call the ``.new()`` method, like for any other "
"class-based datatype. For example:"
msgstr ""
"코드를 사용하여 노드를 생성하려면 다른 클래스 기반 데이터 유형과 마찬가지로 "
"``.new()`` 메서드를 호출해야 합니다. 예를 들어:"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:302
msgid ""
"To delete a node, be it inside or outside the scene, ``free()`` must be used:"
msgstr ""
"씬 내부 또는 외부에 있는 노드를 삭제하려면 ``free()`` 를 사용해야 합니다:"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:318
msgid ""
"When a node is freed, it also frees all its child nodes. Because of this, "
"manually deleting nodes is much simpler than it appears. Free the base node "
"and everything else in the subtree goes away with it."
msgstr ""
"노드가 삭제되면 모든 하위 노드도 삭제됩니다. 따라서 수동으로 노드를 삭제하는 "
"것이 나타내는 것보다 훨씬 간단합니다. 기본 노드를 삭제하면 하위 트리에 있는 "
"다른 모든 것이 삭제됩니다."

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:322
msgid ""
"A situation might occur where we want to delete a node that is currently "
"\"blocked\", because it is emitting a signal or calling a function. This "
"will crash the game. Running Godot with the debugger will often catch this "
"case and warn you about it."
msgstr ""
"신호를 보내거나 함수를 호출하기 때문에 현재 \"차단된\" 노드를 삭제하려는 경우"
"가 발생할 수 있습니다. 이것은 게임을 망칠 것입니다. 디버거로 Godot를 실행하"
"면 이 경우를 발견하고 경고를 표시하는 경우가 많습니다."

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:327
msgid ""
"The safest way to delete a node is by using :ref:`Node.queue_free() "
"<class_Node_method_queue_free>`. This erases the node safely during idle."
msgstr ""
"노드를 삭제하는 가장 안전한 방법은 :ref:`Node.queue_free() "
"<class_Node_method_queue_free>`\\ 를 사용하는 것입니다. 이것은 대기 상태에서"
"도 노드를 안전하게 지웁니다."

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:345
msgid "Instancing scenes"
msgstr "씬 인스턴스하기"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:347
msgid ""
"Instancing a scene from code is done in two steps. The first one is to load "
"the scene from your hard drive:"
msgstr ""
"코드에서 씬을 인스턴스 하는 작업은 두 단계로 이루어집니다. 첫 번째 방법은 하"
"드 드라이브에서 씬을 불러오는 것입니다:"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:360
msgid ""
"Preloading it can be more convenient, as it happens at parse time (GDScript "
"only):"
msgstr ""
"프리로드(Preload) 하면 문법 분석 시간에 일어나므로 더 편리할 수 있습니다 "
"(GDScript만):"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:368
msgid ""
"But ``scene`` is not yet a node. It's packed in a special resource called :"
"ref:`PackedScene <class_PackedScene>`. To create the actual node, the "
"function :ref:`PackedScene.instance() <class_PackedScene_method_instance>` "
"must be called. This will return the tree of nodes that can be added to the "
"active scene:"
msgstr ""
"그러나 ``씬`` 은 아직 하나의 노드가 아닙니다. 이것은 :ref:`PackedScene "
"<class_PackedScene>`\\ 이라는 특수 리소스에 들어 있습니다. 실제 노드를 생성하"
"려면, :ref:`PackedScene.instance() <class_PackedScene_method_instance>` 함수"
"가 호출되어야 합니다. 그러면 활성 씬에 추가할 수 있는 노드 트리를 반환합니다:"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:386
msgid ""
"The advantage of this two-step process is that a packed scene may be kept "
"loaded and ready to use so that you can create as many instances as desired. "
"This is especially useful to quickly instance several enemies, bullets, and "
"other entities in the active scene."
msgstr ""
"이 두 단계 프로세스의 이점은 포장된 씬이 불러온 상태로 유지되어 원하는 만큼"
"의 인스턴스를 생성할 수 있다는 것입니다. 이 기능은 특히 활성화된 씬에서 여러 "
"적, 글머리 기호 및 다른 도면 요소를 신속하게 인스턴스 하는 데 유용합니다."

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:394
msgid "Register scripts as classes"
msgstr "클래스로 스크립트를 등록하기"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:396
msgid ""
"Godot has a \"Script Class\" feature to register individual scripts with the "
"Editor. By default, you can only access unnamed scripts by loading the file "
"directly."
msgstr ""
"Godot는 에디터에 각각의 스크립트를 등록하기 위한 \"스크립트 클래스\" 기능을 "
"갖고 있습니다. 기본적으로, 당신은 파일을 직접 불러와서 이름이 없는 스크립트"
"에 액세스 할 수 있습니다."

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:400
msgid ""
"You can name a script and register it as a type in the editor with the "
"``class_name`` keyword followed by the class's name. You may add a comma and "
"an optional path to an image to use as an icon. You will then find your new "
"type in the Node or Resource creation dialog."
msgstr ""
"스크립트에 이름을 짓고 클래스의 이름과 함께 ``class_name`` 키워드를 통해 에디"
"터의 타입으로 등록할 수 있습니다. 쉼표나 이미지로 향하는 선택적인 경로를 추가"
"해 아이콘으로도 사용할 수 있습니다. 그런 뒤 노드나 리소스 생성 대화 상자에서 "
"당신의 새 타입을 찾으실 수 있습니다."

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:422
msgid "In Godot 3.1:"
msgstr "Godot 3.1에서는:"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:424
msgid ""
"Only GDScript and NativeScript, i.e., C++ and other GDNative-powered "
"languages, can register scripts."
msgstr ""
"오직 GDScript와 NativeScript만, 즉, C++와 다른 GDNative의 영향을 받는 언어"
"만, 스크립트로 등록이 가능합니다."

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:425
msgid "Only GDScript creates global variables for each named script."
msgstr "오직 GDScript만 각 이름이 있는 스크립트에 전역 변수를 만듭니다."
