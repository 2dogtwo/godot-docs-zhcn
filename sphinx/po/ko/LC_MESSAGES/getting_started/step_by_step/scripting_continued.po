# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2018, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-06-28 18:31+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:4
msgid "Scripting (continued)"
msgstr "스크립팅 (계속)"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:7
msgid "Processing"
msgstr "프로세싱"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:9
msgid ""
"Several actions in Godot are triggered by callbacks or virtual functions, so "
"there is no need to write code that runs all the time."
msgstr ""
"Godot의 여러 작업은 콜백 또는 가상 함수에 의해 트리거 되므로, 항상 실행되는 "
"코드를 작성할 필요는 없습니다."

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:12
msgid ""
"However, it is still common to need a script to be processed on every frame. "
"There are two types of processing: idle processing and physics processing."
msgstr ""
"그러나 여전히 모든 프레임에서 스크립트를 처리해야 하는 경우가 많습니다. 프로"
"세싱에는 두가지 유형이 있습니다: 정적 프로세싱과 동적 프로세싱입니다."

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:16
msgid ""
"Idle processing is activated when the method :ref:`Node._process() "
"<class_Node__process>` is found in a script. It can be turned off and on "
"with the :ref:`Node.set_process() <class_Node_set_process>` function."
msgstr ""
"정적 프로세싱은 스크립트에서 :ref:`Node._process() <class_Node__process>` 라"
"는 메서드가 발견되면 활성화됩니다. :ref:`Node.set_process() "
"<class_Node_set_process>` 를 사용해서 이 기능을 끄거나 켤수 있습니다."

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:20
msgid ""
"This method will be called every time a frame is drawn, so it's fully "
"dependent on how many frames per second (FPS) the application is running at:"
msgstr ""
"이 메서드는 프레임을 들일 때 호출됩니다, 따라서 애플리케이션이 실행 중인 초"
"당 프레임 수 (FPS) 에 전적으로 의존합니다:"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:37
msgid ""
"The delta parameter contains the time elapsed in seconds, as a floating "
"point, since the previous call to ``_process()``."
msgstr ""
"델타 매개 변수에는 이전 호출에서 ``_process()`` 로 이동한 이후 부터, 경과된 "
"시간을 유동적인 소수점인 초 단위로 나타냅니다."

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:40
msgid ""
"This parameter can be used to make sure things always take the same amount "
"of time, regardless of the game's FPS."
msgstr ""
"이 매개 변수를 사용하면 게임의 FPS와 관계 없이, 항상 동일한 시간이 소요되도"
"록 할 수 있습니다."

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:43
msgid ""
"For example, movement is often multiplied with a time delta to make movement "
"speed both constant and independent from the frame rate."
msgstr ""
"예를 들어 이동은 시간 델타를 곱해서 이동 속도와 일정하게 하고 프레임률과 따"
"로 독립시킵니다."

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:46
msgid ""
"Physics processing with ``_physics_process()`` is similar, but it should be "
"used for processes that must happen before each physics step, such as "
"controlling a character. It always runs before a physics step and it is "
"called at fixed time intervals: 60 times per second by default. You can "
"change the interval from the Project Settings, under Physics -> Common -> "
"Physics Fps."
msgstr ""
"``_physics_process()`` 를 이용한 물리 처리는 이와 유사하지만, 이것은 캐릭터"
"를 조작하는 과정 같이, 각각의 물리 단계 이전에서 반드시 발생하는 과정에 사용"
"되어야 한다. 이것은 항상 물리 단계 이전에 실행되며 고정된 시간 간격으로 호출"
"됩니다: 기본은 초 당 60회 입니다. 프로젝트 설정의 Physics->Common->Physics "
"Fps에서 시간 간격을 변경할 수 있습니다."

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:52
msgid ""
"The function ``_process()``, however, is not synced with physics. Its frame "
"rate is not constant and is dependent on hardware and game optimization. Its "
"execution is done after the physics step on single-threaded games."
msgstr ""
"그러나 ``_proceed()`` 함수는 물리와 동기화되지 않습니다. 프레임률이 일정하지 "
"않고 하드웨어와 게임 최적화에 의존하기 때문입니다. 그것은 단일 스레드 게임의 "
"물리 단계를 거친 후에 실행됩니다."

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:55
msgid ""
"A simple way to test this is to create a scene with a single Label node, "
"with the following script:"
msgstr ""
"이것을 테스트하는 간단한 방법은 다음 스크립트를 사용하여, 단일 Label 노드로 "
"씬을 생성하는 것입니다:"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:82
msgid "Which will show a counter increasing each frame."
msgstr "위 스크립트는 프레임 당 증가하는 카운터를 보여 줍니다."

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:85
msgid "Groups"
msgstr "그룹"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:87
msgid ""
"Nodes can be added to groups, as many as desired per node, and is a useful "
"feature for organizing large scenes. There are two ways to do this. The "
"first is from the UI, from the Groups button under the Node panel:"
msgstr ""
"노드는 노드당 원하는 수만큼 그룹에 추가할 수 있으며, 큰 장면을 구성하는 데 유"
"용합니다. 두가지 방법이 있습니다. 첫 번째 방법은 의 노드 패널 아래에 있는 그"
"룹 버튼의 UI에서 시작합니다:"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:92
msgid ""
"And the second way is from code. One example would be to tag scenes which "
"are enemies:"
msgstr ""
"두 번째 방법은 코드로 시작합니다. 예를 들어 적으로 쓰는 씬에 태그를 지정할 "
"수 있습니다:"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:110
msgid ""
"This way, if the player is discovered sneaking into a secret base, all "
"enemies can be notified about its alarm sounding by using :ref:`SceneTree."
"call_group() <class_SceneTree_call_group>`:"
msgstr ""
"이렇게 하면 플레이어가 비밀 기지에 몰래 들어간 것이 발견될 경우, :ref:"
"`SceneTree.call_group() <class_SceneTree_call_group>` 을 사용하여 모든 적에"
"게 경보가 울린다는 사실을 알릴 수 있습니다:"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:127
msgid ""
"The above code calls the function ``player_was_discovered`` on every member "
"of the group ``enemies``."
msgstr ""
"위의 코드는 모든 ``enemies`` 의 ``player_was_discovered`` 함수를 호출합니다."

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:130
msgid ""
"It is also possible to get the full list of ``enemies`` nodes by calling :"
"ref:`SceneTree.get_nodes_in_group() <class_SceneTree_get_nodes_in_group>`:"
msgstr ""
"또한 :ref:`SceneTree.get_nodes_in_group() "
"<class_SceneTree_get_nodes_in_group>` 을 호출하여 ``enemies`` 노드의 전체 목"
"록을 가져올 수도 있습니다:"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:143
msgid ""
"The :ref:`SceneTree <class_SceneTree>` class provides many useful methods, "
"like interacting with scenes, their node hierarchy and groups of nodes. It "
"allows you to easily switch scenes or reload them, to quit the game or pause "
"and unpause it. It even comes with interesting signals. So check it out if "
"you got some time!"
msgstr ""
":ref:`SceneTree<class_SceneTree>` 의 클래스는 씬 들과 노드 계층 및 노드 그룹"
"과의 상호 작용과 같은 다양한 유용한 방법들을 제공합니다. 이를 통해 씬 들을 쉽"
"게 전환하거나 다시 로드하여 게임을 종료하거나 일시 중지하거나 이를 해제할 수 "
"있습니다. 그것은 심지어 흥미로운 신호를 동반합니다. 시간이 있으면 확인해 보십"
"시오!"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:151
msgid "Notifications"
msgstr "알림"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:153
msgid ""
"Godot has a system of notifications. These are usually not needed for "
"scripting, as it's too low-level and virtual functions are provided for most "
"of them. It's just good to know they exist. For example, you may add an :ref:"
"`Object._notification() <class_Object__notification>` function in your "
"script:"
msgstr ""
"Godot에는 알림 시스템이 있습니다. 일반적으로 스크립팅에는 필요하지 않습니다. "
"스크립팅은 너무 낮은 수준이며 대부분의 경우 가상 함수가 제공됩니다. 그들이 존"
"재한다는 것을 아는 것은 좋은 일입니다. 예를 들어 스크립트에 다음과 같은 함수"
"를 추가할 수 있습니다:"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:188
msgid ""
"The documentation of each class in the :ref:`Class Reference <toc-class-"
"ref>` shows the notifications it can receive. However, in most cases "
"GDScript provides simpler overrideable functions."
msgstr ""
":ref:`Class Reference <toc-class-ref>` 의 각 클래스에 대한 문서는 수신 가능"
"한 알림을 보여 줍니다. 그러나 대부분의 경우 GDScript는 보다 단순한 오버라이"
"딩 할수 있는 함수들을 제공한다."

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:193
msgid "Overrideable functions"
msgstr "오버라이딩 가능한 함수들"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:195
msgid ""
"Such overrideable functions, which are described as follows, can be applied "
"to nodes:"
msgstr "다음과 같이 오버라이딩 가능한 함수들을 노드에 적용할 수 있습니다:"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:267
msgid ""
"As mentioned before, it's better to use these functions instead of the "
"notification system."
msgstr ""
"앞서 언급했듯이, 이러한 기능은 알림 시스템 대신 사용하는 것이 좋습니다."

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:271
msgid "Creating nodes"
msgstr "노드 생성"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:273
msgid ""
"To create a node from code, call the ``.new()`` method, like for any other "
"class-based datatype. For example:"
msgstr ""
"코드를 사용하여 노드를 생성하려면 다른 클래스 기반 데이터 유형과 마찬가지로 "
"``.new()`` 메서드를 호출하십시오. 예를들면:"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:297
msgid ""
"To delete a node, be it inside or outside the scene, ``free()`` must be used:"
msgstr ""
"씬 내부 또는 외부에 있는 노드를 삭제하려면 ``free()`` 를 사용해야 합니다:"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:313
msgid ""
"When a node is freed, it also frees all its children nodes. Because of this, "
"manually deleting nodes is much simpler than it appears. Free the base node "
"and everything else in the subtree goes away with it."
msgstr ""
"노드가 해제되면 모든 하위 노드도 해제됩니다. 따라서 수동으로 노드를 삭제하는 "
"것이 표시되는 것보다 훨씬 간단합니다. 기본 노드를 사용할 수 있도록 설정하면 "
"하위 노드에 있는 다른 모든 항목이 제거됩니다."

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:317
msgid ""
"A situation might occur where we want to delete a node that is currently "
"\"blocked\", because it is emitting a signal or calling a function. This "
"will crash the game. Running Godot with the debugger will often catch this "
"case and warn you about it."
msgstr ""
"신호를 보내거나 함수를 호출하기 때문에 현재 \"차단된 \"노드를 삭제하려는 경우"
"가 발생할 수 있습니다. 이것은 게임을 망칠 것입니다. 디버거로 Godot을 실행하"
"면 이 경우를 발견하고 경고를 표시하는 경우가 많습니다."

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:322
msgid ""
"The safest way to delete a node is by using :ref:`Node.queue_free() "
"<class_Node_queue_free>`. This erases the node safely during idle."
msgstr ""
"노드를 삭제하는 가장 안전한 방법은 다음을 사용하는 것입니다. 이렇게 하면 유"
"휴 상태에서 노드가 안전하게 지워집니다."

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:340
msgid "Instancing scenes"
msgstr "인스턴스화 씬"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:342
msgid ""
"Instancing a scene from code is done in two steps. The first one is to load "
"the scene from your hard drive:"
msgstr ""
"코드에서 장면을 인스턴스화하는 작업은 두 단계로 이루어집니다. 첫 번째 방법은 "
"하드 드라이브에서 씬을 불러오는 것입니다:"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:355
msgid ""
"Preloading it can be more convenient, as it happens at parse time (GDScript "
"only):"
msgstr ""
"구문 분석 시 발생하는 것처럼 좀 더 편리하게 미리 정렬할 수 있습니다 (GDScript"
"만):"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:362
msgid ""
"But ``scene`` is not yet a node. It's packed in a special resource called :"
"ref:`PackedScene <class_PackedScene>`. To create the actual node, the "
"function :ref:`PackedScene.instance() <class_PackedScene_instance>` must be "
"called. This will return the tree of nodes that can be added to the active "
"scene:"
msgstr ""
"그러나 ``씬`` 은 아직 하나의 노드가 아니다. :ref:`PackedScene "
"<class_PackedScene>` 라는 특수 리소스에 들어 있습니다. 실제 노드를 생성하려"
"면 :ref:`PackedScene.instance() <class_PackedScene_instance>` 기능을 호출해"
"야 합니다. 그러면 활성 장면에 추가할 수 있는 노드 트리가 반환됩니다:"

#: ../../docs/getting_started/step_by_step/scripting_continued.rst:380
msgid ""
"The advantage of this two-step process is that a packed scene may be kept "
"loaded and ready to use so that you can create as many instances as desired. "
"This is especially useful to quickly instance several enemies, bullets, and "
"other entities in the active scene."
msgstr ""
"이 두 단계 프로세스의 이점은 포장된 씬이 로드된 상태로 유지되어 원하는 만큼"
"의 인스턴스를 생성할 수 있다는 것입니다. 이 기능은 특히 활성화된 씬에서 여러 "
"적, 글머리 기호 및 다른 도면 요소를 신속하게 인스턴스화하는 데 유용합니다."
