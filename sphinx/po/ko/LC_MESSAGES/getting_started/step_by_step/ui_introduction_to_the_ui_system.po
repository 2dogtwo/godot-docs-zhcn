# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2021, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-11-19 11:09+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:4
msgid "Design interfaces with the Control nodes"
msgstr "컨트롤(Control) 노드로 인터페이스 설계하기"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:6
msgid ""
"Computer displays, mobile phones, and TV screens come in all shapes and "
"sizes. To ship a game, you'll need to support different screen ratios and "
"resolutions. It can be hard to build responsive interfaces that adapt to all "
"platforms. Thankfully, Godot comes with robust tools to design and manage a "
"responsive User Interface."
msgstr ""
"컴퓨터 디스플레이, 휴대폰 및 TV 화면은 다양한 모양과 크기로 제작됩니다. 게임"
"을 출시하려면 다양한 화면 비율과 해상도를 지원해야 합니다. 모든 플랫폼에 적응"
"하는 반응형 인터페이스를 구축하는 것은 어려울 수 있습니다. 고맙게도 Godot는 "
"반응형 유저 인터페이스를 디자인하고 관리할 수 있는 강력한 툴을 제공합니다."

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:14
msgid "Godot's editor is made with the engine's UI framework"
msgstr "Godot 에디터는 엔진의 UI 프레임워크로 만들어졌습니다"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:16
msgid "This guide will get you started with UI design. You will learn:"
msgstr ""
"이 가이드를 통해 UI 디자인을 시작할 수 있습니다. 이러한 것들을 배울 것입니다:"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:18
msgid "The five most useful control nodes to build your games' interface"
msgstr "게임 인터페이스를 구축하는 데 가장 유용한 5가지 control 노드"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:19
msgid "How to work with the anchor of UI elements"
msgstr "UI 요소의 앵커로 작업하는 방법"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:20
msgid ""
"How to efficiently place and arrange your user interface using containers"
msgstr ""
"컨테이너를 사용해 사용자 인터페이스를 효율적으로 배치하고 배열하는 방법"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:22
msgid ""
"The five most common containers (you can learn more about containers in the :"
"ref:`GUI Containers <doc_gui_containers>` documentation page)."
msgstr ""
"가장 일반적인 5가지 컨테이너(:ref:`GUI 컨테이너 <doc_gui_containers>` 문서 페"
"이지에서 컨테이너에 대한 자세한 내용을 배울 수 있습니다)."

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:25
msgid ""
"To learn how to control the interface and connect it to other scripts, read :"
"ref:`Build your first game UI in Godot <doc_ui_game_user_interface>`."
msgstr ""
"인터페이스를 제어하고 다른 스크립트에 연결하는 방법을 배우려면 :ref:`Godot에"
"서 첫 번째 게임 빌드하기 <doc_ui_game_user_interface>`\\ 를 읽어보세요."

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:28
msgid ""
"To design your UI, you'll use the Control nodes. These are the nodes with "
"green icons in the editor. There are dozens of them, for creating anything "
"from life bars to complex applications. Godot's editor itself is built using "
"Control nodes."
msgstr ""
"UI를 디자인하려면 Control 노드를 사용합니다. 이 노드는 편집기에서 녹색 아이콘"
"으로 표시됩니다. 체력 바에서 복잡한 응용 프로그램에 이르기까지 모든 것들 만"
"들 수 있는 수십 가지 종류의 Control 노드가 있습니다. Godot 에디터 자체는 "
"Control 노드를 사용해 빌드됩니다."

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:32
msgid ""
"Control nodes have unique properties that allow them to work well with one "
"another. Other visual nodes, like Node2D and Sprite don't have these "
"capabilities. So to make your life easier use Control nodes wherever "
"possible when building your UIs."
msgstr ""
"Control 노드에는 서로 잘 작동하도록 하는 고유한 속성이 있습니다. Node2D 및 "
"Sprite와 같은 다른 시각적 노드에는 이러한 기능이 없습니다. 따라서 UI를 구축"
"할 때 가능한 한 Control 노드를 사용하면 편리합니다."

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:36
msgid "All control nodes share the same main properties:"
msgstr "모든 Control 노드는 동일한 메인 속성을 공유합니다:"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:38
msgid "Anchor"
msgstr "앵커(Anchor)"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:39
msgid "Bounding rectangle"
msgstr "경계 사각형(Bounding rectangle)"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:40
msgid "Focus and focus neighbor"
msgstr "포커스(Focus)와 포커스 이웃(Focus neighbor)"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:41
msgid "Size flags"
msgstr "사이즈 플래그(Size flags)"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:42
msgid "Margin"
msgstr "마진(Margin)"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:43
msgid "The optional UI theme"
msgstr "선택적인 UI 테마"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:45
msgid ""
"Once you understand the basics of the Control node, it will take you less "
"time to learn all the nodes that derive from it."
msgstr ""
"일단 여러분이 Control 노드의 기초를 이해하면, 노드에서 파생되는 모든 다른 노"
"드들을 이해하는 데 오래 걸리지 않을 것입니다."

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:50
msgid "The 5 most common UI elements"
msgstr "가장 일반적인 5가지 UI 요소들"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:52
msgid ""
"Godot ships with dozens of Control nodes. A lot of them are here to help you "
"build editor plugins and applications."
msgstr ""
"Godot에는 수십 개의 Control 노드가 있습니다. 대다수가 에디터 플러그인과 응용"
"프로그램을 만드는데 도움이 됩니다."

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:55
msgid ""
"For most games, you'll only need five types of UI elements, and a few "
"Containers. These five Control nodes are:"
msgstr ""
"대부분의 게임은 5가지 타입의 UI 요소와 몇 개의 컨테이너만 필요합니다. 이 다"
"섯 가지 Control 노드는 다음과 같습니다:"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:58
msgid "Label: for displaying text"
msgstr "Label: 텍스트 표시에 사용"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:59
msgid ""
"TextureRect: used mostly for backgrounds, or everything that should be a "
"static image"
msgstr "TextureRect: 보통은 배경으로 사용되고, 그 외 모든 정적 이미지에 사용"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:61
msgid ""
"TextureProgress: for lifebars, loading bars, horizontal, vertical or radial"
msgstr ""
"TextureProgress: 가로 형태, 세로 형태, 혹은 방사 형태의 체력 바 및 로딩 바 등"
"에 사용"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:63
msgid "NinePatchRect: for scalable panels"
msgstr "NinePatchRect: 확장 가능한 패널에 사용"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:64
msgid "TextureButton: to create buttons"
msgstr "TextureButton: 버튼을 만들기 위해 사용"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:68
msgid "The 5 most common Control nodes for UI design"
msgstr "UI 디자인을 위한 가장 일반적인 5가지 Control 노드"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:71
msgid "TextureRect"
msgstr "TextureRect"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:73
msgid ""
"**TextureRect** displays a texture or image inside a UI. It seems similar to "
"the Sprite node, but it offers multiple scaling modes. Set the Stretch Mode "
"property to change its behavior:"
msgstr ""
"**TextureRect**는 UI 내부에 텍스처 또는 이미지를 표시합니다. Sprite 노드와 비"
"슷해 보이지만 여러 가지 크기 조정 모드를 제공합니다. Stretch Mode 속성을 설정"
"해 동작을 변경하세요:"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:77
msgid ""
"``Scale On Expand (compat)`` scales the texture to fit the node's bounding "
"rectangle, only if ``expand`` property is ``true``; otherwise, it behaves "
"like ``Keep`` mode. Default mode for backwards compatibility."
msgstr ""
"``Scale On Expand(compat)``\\ 는 ``expand`` 속성이 ``true``\\ 인 경우에만 노"
"드의 경계 사각형에 맞게 텍스처의 크기를 조정합니다. 그렇지 않으면 ``Keep`` 모"
"드처럼 작동합니다. 이전 버전과의 호환성을 위한 기본 모드입니다."

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:80
msgid "``Scale`` scales the texture to fit the node's bounding rectangle."
msgstr "``Scale``\\ 은 텍스처의 크기를 노드의 경계 사각형에 맞게 조정합니다."

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:81
msgid "``Tile`` makes the texture repeat, but it won't scale."
msgstr ""
"``Tile``\\ 은 텍스처가 반복적으로 나타나도록 하지만, 크기를 조정하지 않습니"
"다."

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:82
msgid ""
"``Keep`` and ``Keep Centered`` force the texture to remain at its original "
"size, in the top left corner or the center of the frame respectively."
msgstr ""
"``Keep``\\ 과 ``Keep Centered``\\ 는 텍스처가 각각 프레임의 왼쪽 위 구석 또"
"는 중앙에서 원래 크기로 유지되도록 합니다."

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:85
msgid ""
"``Keep Aspect`` and ``Keep Aspect Centered`` scales the texture but force it "
"to remain its original aspect ratio, in the top left corner or the center of "
"the frame respectively."
msgstr ""
"``Keep Aspect``\\ 와 ``Keep Aspect Centered``\\ 는 텍스처의 크기를 조정하지"
"만 각각 프레임의 왼쪽 위 구석 또는 중앙에서 원래의 종횡비를 유지하도록 강제합"
"니다."

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:87
msgid ""
"``Keep Aspect Covered`` works just like ``Keep Aspect Centered`` but the "
"shorter side fits the bounding rectangle and the other one clips to the "
"node's limits."
msgstr ""
"``Keep Aspect Covered``\\ 는 ``Keep Aspect Centered``\\ 와 동일하게 작동하지"
"만 더 짧은 쪽은 경계 사각형에 맞추고 다른 쪽은 노드의 한계에서 짤립니다."

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:90
msgid ""
"As with Sprite nodes, you can modulate the TextureRect's color. Click the "
"``Modulate`` property and use the color picker."
msgstr ""
"Sprite 노드와 마찬가지로 TextureRect의 색상을 조정할 수 있습니다. "
"``Modulate`` 속성을 클릭하고 색상 선택기를 사용합니다."

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:95
msgid "TextureRect modulated with a red color"
msgstr "빨강 색으로 바뀐 TextureRect"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:98
msgid "TextureButton"
msgstr "TextureButton"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:100
msgid ""
"**TextureButton** is like TextureRect, except it has 6 texture slots: one "
"for each of the button's states. Most of the time, you'll use the Normal, "
"Pressed, and Hover textures. Focused is useful if your interface listens to "
"the keyboard's input. The sixth image slot, the Click Mask, lets you define "
"the clickable area using a 1-bit, pure black and white image."
msgstr ""
"**TextureButton**\\ 은 각 버튼 상태마다 총 6개의 텍스처 슬롯이 있다는 점을 제"
"외하면 TextureRect와 비슷합니다. 대부분의 경우 Normal, Pressed 및 Hover 텍스"
"처를 사용합니다. Focused는 인터페이스가 키보드 입력을 받는 경우에 유용합니"
"다. 여섯 번째 이미지 슬롯인 Click Mask를 사용하면 1비트의 순수한 흑백 이미지"
"를 사용해 클릭 가능한 영역을 정의할 수 있습니다."

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:107
msgid ""
"In the Base Button section, you'll find a few checkboxes that change how the "
"button behaves. When ``Toggle Mode`` is on, the button will toggle between "
"active and normal states when you press it. ``Disabled`` makes it disabled "
"by default, in which case it will use the ``Disabled`` texture. "
"TextureButton shares a few properties with the texture frame: it has a "
"``modulate`` property, to change its color, and ``Resize`` and ``Stretch`` "
"modes to change its scale behavior."
msgstr ""
"BaseButton 섹션에는 버튼의 작동 방식을 변경하는 몇 가지 체크박스가 있습니다. "
"``Toggle Mode``\\ 가 켜져 있을 때 버튼을 누르면 active 상태와 normal 상태 간"
"에 전환됩니다. ``Disabled``\\ 는 기본적으로 비활성화되며 ``Disabled`` 텍스처"
"를 사용합니다. TextureButton은 텍스처 프레임과 몇 가지 속성을 공유합니다. 색"
"상을 변경하기 위한 ``modulate`` 속성과 스케일 동작을 변경하기 위한 "
"``Resize`` 및 ``Stretch`` 모드가 있습니다."

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:117
msgid "TextureButton and its 5 texture slots"
msgstr "TextureButton과 5개의 텍스처 슬롯"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:120
msgid "TextureProgress"
msgstr "TextureProgress"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:122
msgid ""
"**TextureProgress** layers up to 3 sprites to create a progress bar. The "
"Under and Over textures sandwich the Progress one, which displays the bar's "
"value."
msgstr ""
"**TextureProgress**\\ 는 최대 3개의 스프라이트로 층을 쌓아 로딩바를 만듭니"
"다. Under 및 Over 텍스처 사이에 막대 값을 표시하는 Progress 텍스처를 끼워넣습"
"니다."

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:126
msgid ""
"The ``Mode`` property controls the direction in which the bar grows: "
"horizontally, vertically, or radially. If you set it to radial, the "
"``Initial Angle`` and ``Fill Degrees`` properties let you limit the range of "
"the gauge."
msgstr ""
"``Fill Mode`` 속성은 바 진행방향을 가로, 세로 또는 방사형으로 제어합니다. 방"
"사형으로 설정하면 ``Initial Angle`` 및 ``Fill Degrees`` 속성을 사용해 게이지 "
"범위를 제한할 수 있습니다."

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:131
msgid ""
"To animate the bar, you'll want to look at the Range section. Set the "
"``Min`` and ``Max`` properties to define the range of the gauge. For "
"instance, to represent a character's life, you'll want to set ``Min`` to ``0,"
"`` and ``Max`` to the character's maximum life. Change the ``Value`` "
"property to update the bar. If you leave the ``Min`` and ``Max`` values to "
"the default of ``0`` and ``100,`` and set the ``Value`` property to ``40``, "
"40% of the ``Progress`` texture will show up, and 60% of it will stay hidden."
msgstr ""
"바에 애니메이션을 적용하려면 Range 섹션을 확인해야 합니다. 게이지의 범위를 정"
"의하려면 ``Min``\\ 과 ``Max`` 속성을 설정하세요. 예를 들어, 캐릭터의 수명을 "
"나타내려면 ``Min``\\ 을 ``0,``\\ 으로 설정하고 ``Max``\\ 를 캐릭터의 최대 수"
"명으로 설정하고 싶을 것입니다. 바를 업데이트하려면 ``Value`` 속성을 변경하세"
"요. ``Min``\\ 과 ``Max`` 값을 기본값인 ``0``\\ 과 ``100,``\\ 으로 두고 "
"``Value`` 속성을 ``40``\\ 으로 설정하면 40% ``Progress`` 텍스처가 표시되고 "
"60%는 숨겨진 상태로 유지됩니다."

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:141
msgid "TextureProgress bar, two thirds filled"
msgstr "3분의 2가 채워진 TextureProgress 막대"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:144
msgid "Label"
msgstr "Label"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:146
msgid ""
"**Label** prints text to the screen. You'll find all its properties in the "
"Label section, in the Inspector. Write the text in the ``Text`` property, "
"and check Autowrap if you want it to respect the textbox's size. If Autowrap "
"is off, you won't be able to scale the node. You can align the text "
"horizontally and vertically with Align and Valign, respectively."
msgstr ""
"**Label**\\ 은 화면에 텍스트를 출력합니다. 인스펙터(Inspector)의 Label 섹션에"
"서 모든 속성을 찾을 수 있습니다. ``Text`` 속성에 텍스트를 작성하고, 텍스트 상"
"자를 넘어가면 자동 줄바꿈되도록 하고싶으면 Autowrap을 체크하세요. Autowrap 체"
"크를 해제하면 노드의 크기를 조정할 수 없습니다. Align 및 Valign을 사용해 각"
"각 텍스트를 가로 및 세로로 배열할 수 있습니다."

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:155
msgid "Picture of a Label"
msgstr "Label 사진"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:158
msgid "NinePatchRect"
msgstr "NinePatchRect"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:160
msgid ""
"**NinePatchRect** takes a texture split in 3 rows and 3 columns. The center "
"and the sides tile when you scale the texture, but it never scales the "
"corners. It is useful to build panels, dialog boxes and scalable backgrounds "
"for your UI."
msgstr ""
"**NinePatchRect**\\ 는 3행 3열로 분할된 텍스처를 사용합니다. 텍스처의 크기를 "
"조정하면 중앙과 측면이 타일링되지만 모서리의 크기는 조정되지 않습니다. UI에 "
"대한 패널, 대화 상자 및 확장 가능한 배경을 만드는 데 유용합니다."

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:167
msgid "NinePatchRect scaled with the min\\_size property"
msgstr "min\\_size 속성으로 크기가 조정된 NinePatchRect"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:170
msgid "There are two workflows to build responsive UIs"
msgstr "반응형 UI를 구축하는 두 가지 워크플로가 있습니다"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:172
msgid ""
"There are two workflows to build scalable and flexible interfaces in Godot:"
msgstr ""
"Godot에서 확장 가능하고 유연한 인터페이스를 구축하기 위한 두 가지 워크플로가 "
"있습니다:"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:174
msgid ""
"**Place UI elements precisely with anchors:** Use the **Layout** menu to "
"place and resize a UI element relative to its parent."
msgstr ""
"**앵커를 사용해 UI 요소를 정확하게 배치:** **레이아웃(Layout)** 메뉴를 사용"
"해 부모 노드를 기준으로 UI 요소를 배치하고 크기를 조정합니다."

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:175
msgid ""
"**Arrange control nodes automatically with containers:** Use container nodes "
"to automatically scale and place UI elements."
msgstr ""
"**컨테이너로 Control 노드 자동 배열:** Container 노드를 사용해 자동으로 UI 요"
"소를 확장하고 배치합니다."

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:177
msgid ""
"The two approaches are not always compatible. Because a container controls "
"its children, you cannot use the layout menu on them. Each container has a "
"specific effect, so you may need to nest several of them to get a working "
"interface. With the layout approach you work from the bottom up, on the "
"children. As you don't insert extra containers in the scene it can make for "
"cleaner hierarchies, but it's harder to arrange items in a row, column, "
"grid, etc."
msgstr ""
"두 가지 접근 방식이 항상 호환되는 것은 아닙니다. 컨테이너는 자식을 제어하기 "
"때문에 레이아웃(Layout) 메뉴를 사용할 수 없습니다. 각 컨테이너에는 특정 효과"
"가 있으므로 작동하는 인터페이스를 얻으려면 여러 컨테이너를 중첩해야 할 수 있"
"습니다. 레이아웃 접근 방식을 사용하면 아래에서 위로 자식들로부터 작업을 시작"
"합니다. 씬에 추가 컨테이너를 삽입하지 않으면 더 깨끗한 계층 구조를 만들 수 있"
"지만 행, 열, 격자 등으로 항목을 배열하기가 더 어렵습니다."

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:179
msgid ""
"As you create UIs for your games and tools, you'll develop a sense for what "
"fits best in each situation."
msgstr ""
"게임과 툴에 대한 UI를 만들면서 각 상황에 가장 적합한 것이 무엇인지 이해하게 "
"될 것입니다."

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:183
msgid "Place UI elements precisely with anchors"
msgstr "앵커로 UI 요소를 정확하게 배치하세요"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:185
msgid ""
"Control nodes have a position and size, but they also have anchors and "
"margins. Anchors define the origin, or the reference point, for the Left, "
"Top, Right and Bottom edges of the node. Change any of the 4 anchors to "
"change the reference point of the margins."
msgstr ""
"Control 노드에는 위치와 크기가 있지만 앵커와 마진도 있습니다. 앵커는 노드의 "
"왼쪽, 위쪽, 오른쪽 및 아래쪽 가장자리에 대한 원점 또는기준점을 정의합니다. 4"
"개의 앵커 중 하나를 변경해 마진의 기준점을 변경하세요."

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:192
msgid "The anchor property"
msgstr "앵커 속성"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:195
msgid "How to change the anchor"
msgstr "앵커를 변경하는 방법"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:197
msgid ""
"Like any properties, you can edit the 4 anchor points in the Inspector, but "
"this is not the most convenient way. When you select a control node, the "
"layout menu appears above the viewport, in the toolbar. It gives you a list "
"of icons to set all 4 anchors with a single click, instead of using the "
"inspector's 4 properties. The layout menu will only show up when you select "
"a control node."
msgstr ""
"다른 속성과 마찬가지로 인스펙터(Inspector)에서 4개의 앵커 포인트를 편집할 수 "
"있지만 가장 편리한 방법은 아닙니다. Conrol 노드를 선택하면 툴바의 뷰포트 위"
"에 레이아웃(Layout) 메뉴가 나타납니다. 인스펙터의 4가지 속성을 사용하는 대신 "
"한 번의 클릭으로 4개의 앵커를 모두 설정할 수 있는 아이콘 목록을 제공합니다. "
"레이아웃 메뉴는 Control 노드를 선택하는 경우에만 표시됩니다."

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:206
msgid "The layout menu in the viewport"
msgstr "뷰포트 내의 레이아웃(Layout) 메뉴"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:209
msgid "Anchors are relative to the parent container"
msgstr "앵커는 부모 컨테이너를 기준으로 합니다"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:211
msgid ""
"Each anchor is a value between 0 and 1. For the left and top anchors, a "
"value of 0 means that without any margin, the node's edges will align with "
"the left and top edges of its parent. For the right and bottom edges, a "
"value of 1 means they'll align with the parent container's right and bottom "
"edges. On the other hand, margins represent a distance to the anchor "
"position in pixels, while anchors are relative to the parent container's "
"size."
msgstr ""
"각 앵커의 값은 0과 1 사이입니다. 왼쪽 및 위쪽 앵커의 경우 값 0은 마진이 없으"
"면 노드의 가장자리가 부모의 왼쪽 및 위쪽 가장자리에 정렬됨을 의미합니다. 오른"
"쪽 및 아래쪽 가장자리의 값이 1이면 부모 컨테이너의 오른쪽 및 아래쪽 가장자리"
"에 정렬됩니다. 앵커가 부모 컨테이너의 크기를 기준으로 하는 반면에 마진은 앵"
"커 위치까지의 거리를 픽셀 단위로 나타냅니다."

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:221
msgid ""
"Margins are relative to the anchor position, which is relative to the "
"anchors. In practice, you'll often let the container update margins for you"
msgstr ""
"마진은 앵커 위치에 상대적이고, 앵커 위치는 앵커와 상대적입니다. 실제로 여러분"
"은 자주 컨테이너가 마진을 업데이트하도록 할 것입니다"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:226
msgid "Margins change with the anchor"
msgstr "마진은 앵커가 변하면 같이 변합니다"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:228
msgid ""
"Margins update automatically when you move or resize a control node. They "
"represent the distance from the control node's edges to its anchor, which is "
"relative to the parent control node or container. That's why your control "
"nodes should always be inside a container, as we'll see in a moment. If "
"there's no parent, the margins will be relative to the node's own bounding "
"Rectangle, set in the Rect section, in the inspector."
msgstr ""
"Control 노드를 이동하거나 크기를 조정하면 마진이 자동으로 업데이트됩니다. 마"
"진은 Control 노드의 가장자리에서 앵커까지의 거리를 나타내며 이는 부모 "
"Control 노드 또는 컨테이너를 기준으로 합니다. 이 점이 바로 Control 노드가 항"
"상 컨테이너 안에 있어야 하는 이유로 잠시 후에 살펴볼 것입니다. 부모가 없는 경"
"우 마진은 인스펙터(Inspector)의 Rect 섹션에 설정된 노드 자체의 경계 사각형에 "
"상대적입니다."

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:238
msgid "Margins on a CenterContainer set to the \"Full Rect\" anchor"
msgstr "CenterContainer에 있는 \"사각형 전체(Full Rect)\" 앵커로 설정된 마진"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:240
msgid ""
"Try to change the anchors or nest your Control nodes inside Containers: the "
"margins will update. You'll rarely need to edit the margins manually. Always "
"try to find a container to help you first; Godot comes with nodes to solve "
"all the common cases for you. Need to add space between a lifebar and the "
"border of the screen? Use the MarginContainer. Want to build a vertical "
"menu? Use the VBoxContainer. More on these below."
msgstr ""
"한번 앵커 위치를 바꾸거나 Control 노드를 컨테이너 안에 넣어보세요: 마진이 업"
"데이트 될 것입니다. 여러분은 거의 마진을 수동으로 편집하진 않을 것입니다. 항"
"상 여러분을 도와줄 컨테이너를 골라보세요. Godot는 모든 일반적인 문제를 해결"
"할 수 있는 노드를 제공합니다. 체력 바와 화면 테두리 사이에 빈 공간이 필요한가"
"요? MarginContainer를 사용하세요. 세로 메뉴를 만들고 싶나요? VBoxContainer를 "
"사용하세요. 아래에서 더 자세히 설명하겠습니다."

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:249
msgid "Use size tags to change how UI elements fill the available space"
msgstr ""
"크기 태그를 사용해 UI 요소가 사용 가능한 공간을 채우는 방식을 변경하세요"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:251
msgid ""
"Every control node has Size Flags. They tell containers how the UI elements "
"should scale. If you add the \"Fill\" flag to the Horizontal or Vertical "
"property, the node's bounding box will take all the space it can, but it'll "
"respect its siblings and retain its size. If there are 3 TextureRect nodes "
"in an HBoxContainer, with the \"Fill\" flags on both axes, they'll each take "
"up to a third of the available space, but no more. The container will take "
"over the node and resize it automatically."
msgstr ""
"모든 Control 노드에는 Size Flags가 있습니다. Size Flags는 UI 요소가 크기를 조"
"절하는 방법을 컨테이너에 알려줍니다. Horizontal 또는 Vertical 속성에 \"Fill"
"\" 플래그를 추가하면 노드의 경계 상자가 가능한 모든 공간을 차지하지만 형제 노"
"드를 존중하면서 크기를 유지합니다. HBoxContainer에 3개의 TextureRect 노드가 "
"있고 두 축 모두에 \"채우기\" 플래그가 있는 경우 각 노드는 사용 가능한 공간의 "
"최대 1/3을 차지하지만 그 이상은 차지하지 않습니다. 컨테이너는 노드를 제어하"
"고 자동으로 크기를 조절합니다."

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:261
msgid "3 UI elements in an HBoxContainer, they align horizontally"
msgstr "HBoxContainer에 있는 3개의 UI 요소들, 이들은 수평으로 배열됩니다"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:263
msgid ""
"The \"Expand\" flag lets the UI element take all the space it can, and push "
"against its siblings. Its bounding rectangle will grow against the edges of "
"its parent, or until it's blocked by another UI node."
msgstr ""
"\"Expand\" 플래그는 UI 요소가 가능한 모든 공간을 차지하게 만들고, 형제 노드"
"를 밀어냅니다. 경계 사각형은 부모의 모서리까지, 혹은 다른 UI 노드로 가로막힐 "
"때까지 커집니다."

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:269
msgid ""
"The same example as above, but the center node has the \"Expand\" size flag"
msgstr ""
"위와 같은 샘플 예제에서, 가운데 노드에는 \"Expand\" 사이즈 플래그가 설정되어 "
"있습니다"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:272
msgid ""
"You'll need some practice to understand the size tags, as their effect can "
"change quite a bit depending on how you set up your interface."
msgstr ""
"인터페이스를 설정하는 방법에 따라 효과가 상당히 달라질 수 있기 때문에 크기 태"
"그를 이해하려면 몇 번의 연습이 필요합니다."

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:276
msgid "Arrange control nodes automatically with containers"
msgstr "컨테이너에 Control 노드를 자동으로 배열하기"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:278
msgid ""
"Containers automatically arrange all children Control nodes including other "
"containers in rows, columns, and more. Use them to add padding around your "
"interface or center nodes in their bounding rectangles. All built-in "
"containers update in the editor, so you can see the effect instantly."
msgstr ""
"컨테이너는 행, 열 등의 다른 컨테이너를 포함해 모든 자식 Control 노드를 자동으"
"로 배열합니다. 경계 사각형에서 인터페이스 또는 중심 노드 주위에 여백을 추가하"
"는 데 사용하세요. 내장된 모든 컨테이너는 에디터에서 업데이트되므로 즉시 효과"
"를 확인할 수 있습니다."

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:284
msgid ""
"Containers have a few special properties to control how they arrange UI "
"elements. To change them, navigate down to the Custom Constants section in "
"the Inspector."
msgstr ""
"컨테이너에는 UI 요소를 배열하는 방법을 제어하는 몇 가지 특수 속성이 있습니"
"다. 이를 변경하려면 인스펙터(Inspector)의 Custom Constants 섹션으로 이동합니"
"다."

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:289
msgid "The 5 most useful containers"
msgstr "다섯 가지 가장 유용한 컨테이너들"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:291
msgid ""
"If you build tools, you might need all of the containers. But for most "
"games, a handful will be enough:"
msgstr ""
"툴을 빌드하는 경우 모든 컨테이너가 필요할 수 있습니다. 그러나 대부분의 게임에"
"서는 이정도만 있어도 충분합니다:"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:294
msgid "MarginContainer, to add margins around parts of the UI"
msgstr "MarginContainer, UI의 가장자리에 마진 추가"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:295
msgid "CenterContainer, to center its children in its bounding box"
msgstr "CenterContainer, 경계 상자에서 자식을 중앙에 배치"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:296
msgid ""
"VboxContainer and HboxContainer, to arrange UI elements in rows or columns"
msgstr "VboxContainer와 HboxContainer, 행 또는 열 기준으로 UI 요소를 배열"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:298
msgid "GridContainer, to arrange Controls nodes in a grid-like pattern"
msgstr "GridContainer, Control 노드를 바둑판 형태로 배열"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:300
msgid ""
"CenterContainer centers all its children inside of its bounding rectangle. "
"It's one you typically use for title screens, if you want the options to "
"stay in the center of the viewport. As it centers everything, you'll often "
"want a single container nested inside it. If you use textures and buttons "
"instead, they'll stack up."
msgstr ""
"CenterContainer는 경계 사각형 내부의 모든 자식을 중앙에 배치합니다. 일반적으"
"로 타이틀 화면에서 옵션을 뷰포트 중앙에 배치하려는 경우에 사용합니다. 모든 것"
"을 중앙에 배치하기 때문에 그 안에 중첩된 단일 컨테이너가 필요한 경우가 많습니"
"다. 대신에 텍스처와 버튼을 사용하면 스택이 쌓입니다."

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:308
msgid ""
"CenterContainer in action. The life bar centers inside its parent container."
msgstr "실행 중인 CenterContainer. 체력 막대가 부모 컨테이너의 중앙에 있다."

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:311
msgid ""
"The MarginContainer adds a margin on any side of the child nodes. Add a "
"MarginContainer that encompasses the entire viewport to add a separation "
"between the edge of the window and the UI. You can set a margin on the top, "
"left, right, or bottom side of the container. No need to tick the checkbox: "
"click the corresponding value box and type any number. It will activate "
"automatically."
msgstr ""
"MarginContainer는 자식 노드의 모든 면에 마진을 추가합니다. 전체 뷰포트를 포함"
"하는 MarginContainer를 추가해 창 가장자리와 UI 사이를 분리하세요. 컨테이너의 "
"위쪽, 왼쪽, 오른쪽 또는 아래쪽에 마진을 설정할 수 있습니다. 체크박스를 건들 "
"필요가 없습니다. 해당 값 상자를 클릭하고 숫자를 입력하세요. 자동으로 활성화됩"
"니다."

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:320
msgid "The MarginContainer adds a 40px margin around the Game User Interface"
msgstr "게임 유저 인터페이스 주변에 MarginContainer가 40px의 마진을 추가합니다"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:322
msgid ""
"There are two BoxContainers: VBoxContainer and HBoxContainer. You cannot add "
"the BoxContainer node itself, as it is a helper class, but you can use "
"vertical and horizontal box containers. They arrange nodes either in rows or "
"columns. Use them to line up items in a shop, or to build complex grids with "
"rows and columns of different sizes, as you can nest them to your heart's "
"content."
msgstr ""
"BoxContainer에는 VBoxContainer와 HBoxContainer의 두 가지가 있습니다. "
"BoxContainer 노드 자체는 도우미 클래스이므로 사용할 수 없지만 수직 및 수평 상"
"자 컨테이너를 사용할 수 있습니다. 이 컨테이너들은 행이나 열로 노드를 배열합니"
"다. 이 컨테이너들을 사용해 상점의 품목을 정렬하거나 다양한 크기의 행과 열로 "
"된 복잡한 그리드를 구축할 수 있습니다."

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:331
msgid "The HBoxContainer horizontally aligns UI elements"
msgstr "HBoxContainer가 UI 요소들을 수평으로 배열합니다"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:333
msgid ""
"VBoxContainer automatically arranges its children into a column. It puts "
"them one after the other. If you use the separation parameter, it will leave "
"a gap between its children. HBoxContainer arranges UI elements in a row. "
"It's similar to the VBoxContainer, with an extra ``add_spacer`` method to "
"add a spacer control node before its first child or after its last child, "
"from a script."
msgstr ""
"VBox컨테이너는 자동으로 자식을 세로로 배열합니다. 차례대로요. 분리"
"(seperation) 매개 변수를 사용하는 경우 자식들 사이에 간격이 생깁니다. HBox컨"
"테이너는 UI 요소를 연속적으로 배열합니다. 이는 VBox컨테이너와 유사하게, 스크"
"립트에서 첫 번째 자식 노드 앞 또는 마지막 자식 노드 뒤에 간격을 띄우는 "
"Control 노드를 추가하는 ``add_spacer`` 메서드를 갖고 있습니다."

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:340
msgid ""
"The GridContainer lets you arrange UI elements in a grid-like pattern. You "
"can only control the number of columns it has, and it will set the number of "
"rows by itself, based on its children's count. If you have nine children and "
"three columns, you will have 9÷3 = 3 rows. Add three more children and "
"you'll have four rows. In other words, it will create new rows as you add "
"more textures and buttons. Like the box containers, it has two properties to "
"set the vertical and horizontal separation between the rows and columns "
"respectively."
msgstr ""
"GridContainer를 사용하면 UI 요소를 그리드와 같은 패턴으로 배열할 수 있습니"
"다. 열 수만 제어할 수 있고, 자식 수에 따라 GridContainer가 행 수를 자체적으"
"로 설정합니다. 9개의 자식 노드와 3개의 열이 있는 경우 9÷3 = 3개의 행이 만들어"
"집니다. 3명의 자식을 더 추가하면 4개의 행이 만들어집니다. 즉, 더 많은 텍스처"
"와 버튼을 추가하면 새 행이 생성됩니다. 상자 컨테이너와 마찬가지로 행과 열 사"
"이의 수직 및 수평 분리를 각각 설정하는 두 가지 속성이 있습니다."

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:351
msgid "A GridContainer with 2 columns. It sizes each column automatically."
msgstr "2열로 된 GridContainer. 각 행은 자동으로 크기가 조절됩니다."

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:353
msgid ""
"Godot's UI system is complex, and has a lot more to offer. To learn how to "
"design more advanced interfaces, head to the :ref:`GUI section "
"<doc_user_interface>` of the docs."
msgstr ""
"Godot의 UI 시스템은 복잡하고 더 많은 것을 제공합니다. 고급 인터페이스를 디자"
"인하는 방법을 배우려면 문서의 :ref:`GUI 섹션 <doc_user_interface>`\\ 으로 이"
"동하세요."
