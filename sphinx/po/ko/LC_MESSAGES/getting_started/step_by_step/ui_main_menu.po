# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2021, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-11-19 11:09+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:4
msgid "Design a title screen"
msgstr "타이틀 화면 만들기"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:6
msgid ""
"In the next two tutorials, you will build two responsive UI (user interface) "
"scenes step-by-step using the engine's UI system:"
msgstr ""
"다음 두 튜토리얼에서 엔진의 UI 시스템을 사용해 두 개의 반응형 UI(사용자 인터"
"페이스) 씬을 단계별로 빌드할 것입니다:"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:9
msgid "A main menu."
msgstr "메인 메뉴."

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:10
msgid "A game UI with a health bar, energy bar, bomb and money counters."
msgstr "체력 바, 에너지 바, 폭탄과 돈 개수 카운터가 있는 게임 UI."

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:12
msgid ""
"You will learn how to design game UIs efficiently, and how to use Godot's "
"Control nodes. This page focuses on the visual part: everything you do from "
"the editor. To learn how to code a life bar, read :doc:`ui_code_a_life_bar`."
msgstr ""
"게임 UI를 효율적으로 디자인하는 방법과 Godot의 Control 노드를 사용하는 방법"
"을 배우게 됩니다. 이 페이지는 시각적인 부분, 즉 에디터에서 수행하는 모든 작업"
"에 중점을 둡니다. 체력 바를 코딩하는 방법을 배우려면 :doc:"
"`ui_code_a_life_bar`\\ 를 읽어보세요."

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:20
msgid "The GUI you're going to create."
msgstr "앞으로 만들게 될 GUI."

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:22
msgid ""
"Download the project files: :download:`ui_main_menu_design.zip <files/"
"ui_main_menu_design.zip>` and extract the archive. Import the ``start/`` "
"project in Godot to follow this tutorial. The ``end/`` folder contains the "
"final result. You'll find all the sprites in the ``start/assets/main_menu`` "
"folder."
msgstr ""
"프로젝트 파일을 다운로드하고 :download:`ui_main_menu_design.zip <files/"
"ui_main_menu_design.zip>` 압축을 푸세요. 이 튜토리얼을 따라가려면 Godot에서 "
"``start/`` 프로젝트를 가져오세요. ``end/`` 폴더에는 최종 결과물이 들어 있습니"
"다. 모든 스프라이트는 ``start/assets/main_menu`` 폴더에서 찾을 수 있습니다."

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:30
msgid ""
"Read the :doc:`ui_introduction_to_the_ui_system` first to learn how Godot's "
"UI system works."
msgstr ""
"Godot의 UI 시스템이 어떻게 작동하는지 알아보려면 먼저 :doc:"
"`ui_introduction_to_the_ui_system`\\ 을 읽어보세요."

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:34
msgid "How to design your game UI"
msgstr "게임 UI를 디자인하는 방법"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:36
msgid ""
"To design a good UI, you want to come up with a rough mockup first: a plain "
"drawing version that focuses on the placement of your UI components, their "
"size, and user interaction. Pen and paper is all you need. You shouldn't use "
"fancy and final graphics at this stage. Then, you only need simple "
"placeholder sprites and you're good to jump into Godot. You want to make "
"sure the players can find their way around the interface using those "
"placeholders."
msgstr ""
"좋은 UI를 디자인하려면 먼저 대략적인 목업(mockup), 즉 UI 구성 요소의 배치, 크"
"기 및 사용자 상호 작용에 중점을 둔 그림을 만들어야 합니다. 펜과 종이만 있으"
"면 됩니다. 이 단계에서는 화려하고 최종적인 그래픽을 사용해서는 안 됩니다. 간"
"단한 플레이스홀더 스프라이트만 가지고 Godot에 뛰어드세요. 플레이어가 이러한 "
"플레이스홀더를 사용해 인터페이스에서 길을 찾을 수 있도록 하고 싶습니다."

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:46
msgid "The UI's rough plan or mockup"
msgstr "UI의 대략적인 계획이나 모형"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:48
msgid ""
"Placeholder doesn't have to mean ugly, but you should keep the graphics "
"simple and clean. Avoid special effects, animation, and detailed "
"illustration before you have players playtest your UI. Otherwise:"
msgstr ""
"플레이스홀더가 못생긴 것을 의미할 필요는 없지만 그래픽을 단순하고 깨끗하게 유"
"지해야 합니다. 플레이어가 UI를 플레이 테스트하게 하기 전에 특수 효과, 애니메"
"이션 및 구체적인 삽화는 피하세요. 그렇지 않으면:"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:52
msgid ""
"The graphics might skew the players' perception of the experience and you'll "
"miss out on valuable feedback."
msgstr ""
"그래픽이 플레이어의 경험에 대한 인식을 왜곡해 소중한 피드백을 놓칠 수 있습니"
"다."

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:54
msgid "If the User Experience doesn't work, you'll have to redo some sprites."
msgstr "사용자 경험이 작동하지 않으면 일부 스프라이트를 다시 만들어야 합니다."

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:58
msgid ""
"Always try to make the interface work with simple text and boxes first. It's "
"easy to replace the textures later. Professional UX designers often work "
"with plain outlines and boxes in greyscale. When you take colors and fancy "
"visuals away, it's a lot easier to size and place UI elements properly. It "
"helps you refine the design foundation you'll build upon."
msgstr ""
"항상 먼저 간단한 텍스트와 상자로 인터페이스를 작동하도록 하세요. 나중에 텍스"
"처를 쉽게 교체할 수 있습니다. 전문 UX 디자이너는 회색조의 일반 윤곽선과 상자"
"로 작업하는 경우가 많습니다. 색상과 멋진 시각적 요소를 제거하면 UI 요소의 크"
"기를 조정하고 적절하게 배치하는 것이 훨씬 쉽습니다. 구축할 디자인 기반을 개선"
"하는 데 도움이 됩니다."

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:65
msgid "There are two ways to design your UI in Godot. You can:"
msgstr "Godot에는 UI를 디자인하는 두 가지 방법이 있습니다. 여러분은:"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:67
msgid ""
"Build it all in a single scene, and eventually save some branches as "
"reusable scenes."
msgstr ""
"하나의 씬에서 모든 것을 구축하고 마지막으로 일부 분기를 재사용 가능한 씬으로 "
"저장할 수 있습니다."

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:69
msgid ""
"Build template scenes for reusable components and create specific components "
"that inherit from your base scenes."
msgstr ""
"재사용 가능한 구성 요소에 대한 템플릿 씬을 만들고 이 씬을 상속받는 특정 구성 "
"요소를 만들 수 있습니다."

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:72
msgid ""
"We will use the first approach, because the first version of your UI may not "
"work as well as you'd like. You're likely to throw parts away and redesign "
"components as you go. When you're sure everything works, it's easy to make "
"some parts reusable, as you'll see below."
msgstr ""
"UI의 첫 번째 버전이 원하는 대로 작동하지 않을 수 있으므로 우리는 첫 번째 방법"
"을 사용할 것입니다. 여러분은 부품을 버리거나 재설계할 가능성이 높습니다. 모"
"든 것이 제대로 작동한다고 확신하면 아래에서 볼 수 있듯이 일부 부품을 쉽게 재"
"사용할 수 있습니다."

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:79
msgid ""
"The files you'll find in Godot. The graphics look cleaner than on the rough "
"design, but they're still placeholders."
msgstr ""
"Godot에서 찾을 수 있는 파일. 그래픽은 대략적인 디자인보다 더 깔끔해 보이지"
"만, 여전히 플레이스홀더입니다."

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:83
msgid "Design the main menu"
msgstr "메인 메뉴 디자인하기"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:85
msgid ""
"Before we jump into the editor, we want to plan how we'll nest containers "
"based on our mockup image."
msgstr ""
"에디터로 이동하기 전에 목업 이미지를 기반으로 컨테이너를 쌓아올리는 방법을 계"
"획하고 싶습니다."

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:89
#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:292
msgid "Break down the UI mockup"
msgstr "UI 목업 파헤치기"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:91
msgid "Here are my three rules of thumb to find the right containers:"
msgstr ""
"올바른 컨테이너를 찾기 위한 저의 경험에 바탕을 둔 세 가지 법칙은 다음과 같습"
"니다:"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:93
msgid ""
"Break down the UI into nested boxes, from the largest that contains "
"everything, to the smallest ones, that encompass one widget, like a bar with "
"its label, a panel or a button."
msgstr ""
"모든 것을 포함하는 가장 큰 상자부터 레이블이 있는 바, 패널 또는 버튼과 같이 "
"하나의 위젯을 포함하는 가장 작은 상자에 이르기까지 UI를 중첩된 상자로 나눕니"
"다."

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:96
msgid "If there's some padding around an area, use a ``MarginContainer``."
msgstr "영역 주변에 여백을 만들려면, ``MarginContainer``\\ 를 사용하세요."

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:97
msgid ""
"If the elements are arranged in rows or columns, use an ``HBoxContainer`` or "
"``VBoxContainer``."
msgstr ""
"요소를 행 또는 열로 배열한다면, ``HBoxContainer`` 또는 ``VBoxContainer``\\ "
"를 사용하세요."

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:100
msgid ""
"These rules are enough to get us started, and work well for simple "
"interfaces."
msgstr ""
"이러한 규칙은 우리가 시작하기에도 충분하고, 간단한 인터페이스에 대해서도 잘 "
"작동합니다."

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:103
msgid ""
"For the main menu, the largest box is the entire game window. There's "
"padding between the edges of the window and the first components: this "
"should be a ``MarginContainer``. Then, the screen is split into two columns, "
"so we'll use an ``HBoxContainer``. In the left column, we'll manage the rows "
"with a ``VBoxContainer``. And in the right column, we'll center the "
"illustration with a ``CenterContainer``."
msgstr ""
"주 메뉴의 경우 가장 큰 상자가 전체 게임 창입니다. 창의 가장자리와 첫 번째 구"
"성 요소 사이에 여백이 있습니다. 이것은 ``MarginContainer``\\ 여야 합니다. 그"
"런 다음 화면이 두 개의 열로 분할되므로 ``HBoxContainer``\\ 를 사용합니다. 왼"
"쪽 열에서 ``VBoxContainer``\\ 로 행을 관리합니다. 그리고 오른쪽 열에서는 그림"
"을 ``CenterContainer``\\ 로 중앙에 배치합니다."

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:112
msgid "Interface building blocks, broken down using the three rules of thumb."
msgstr ""
"블록으로 만든 인터페이스. 경험에 근거한 규칙 세 가지를 사용해 나누었습니다."

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:116
msgid ""
"Containers adapt to the window's resolution and width-to-height ratio. "
"Although we could place UI elements by hand, containers are faster, more "
"precise, and **responsive**."
msgstr ""
"컨테이너는 창의 해상도 및 가로-세로 비율에 적응합니다. UI 요소를 수작업으로 "
"배치할 수 있지만 컨테이너는 더 빠르고 정확하며 **반응형**\\ 입니다."

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:121
msgid "Prepare the Main Menu scene"
msgstr "메인 메뉴 씬 준비하기"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:125
msgid ""
"This tutorial is based on a window size of 1366×768. To change the project's "
"base window size, open **Project > Project Settings** at the top of the "
"editor then change **Display > Window > Size > Width** to ``1366`` and "
"**Display > Window > Size > Height** to ``768``."
msgstr ""
"이 튜토리얼은 1366×768의 창 크기를 기준으로 합니다. 프로젝트의 기본 창 크기"
"를 변경하려면 에디터 위쪽에서 **프로젝트(Project) > 프로젝트 설정(Project "
"Settings)**\\ 을 연 다음 **Display > Window > Size > Width**\\ 를 ``1366``\\ "
"으로 변경하고 **Display > Window > Size > Height**\\ 를 ``768``\\ 으로 변경하"
"세요."

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:130
msgid ""
"If you forget to change the window size, anchors and containers may not "
"behave as expected."
msgstr ""
"창 크기 변경을 까먹을 경우 앵커와 컨테이너가 예상대로 작동하지 않을 수 있습니"
"다."

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:133
msgid ""
"Let's create the main menu. We'll build it in a single scene. To create an "
"empty scene, click on **Scene > New Scene**."
msgstr ""
"메인 메뉴를 만들어 봅시다. 하나의 씬에 메뉴를 만들 것입니다. 비어있는 씬을 만"
"들려면, **씬(Scene) > 새 씬(New Scene)**\\ 을 클릭하세요."

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:136
msgid ""
"We have to add a root node before we can save the scene. Your UI's root "
"should be the outermost container or element. In this case it's a "
"``MarginContainer``. ``MarginContainer`` is a good starting point for most "
"interfaces, as you often need padding around the UI. Press :kbd:`Ctrl + S` (:"
"kbd:`Cmd + S` on macOS) to save the scene to the disk. Name it *MainMenu*."
msgstr ""
"씬을 저장하기 전에 루트 노드를 추가해야 합니다. UI의 루트는 가장 바깥쪽 컨테"
"이너 또는 요소여야 합니다. 이 경우에는 ``MarginContainer``\\ 입니다. "
"``MarginContainer``\\ 는 UI 주위에 여백이 필요한 경우가 많으므로 대부분의 인"
"터페이스에서 좋은 출발점입니다. :kbd:`Ctrl + S`(macOS의 경우:kbd:`Cmd + S`)"
"를 눌러 씬을 디스크에 저장하세요. 이름은 *MainMenu*\\ 로 지으세요."

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:142
msgid ""
"Select the ``MarginContainer`` again, and head to the inspector to define "
"the margins' size. Scroll down the ``Control`` class, to the ``Custom "
"Constants`` section. Unfold it. Set the margins as such:"
msgstr ""
"다시 ``MarginContainer``\\ 를 선택하고 인스펙터(Inspector)로 이동해 마진"
"(margin)의 크기를 정의합니다. ``Control`` 클래스를 아래로 스크롤해 ``Custom "
"Constants`` 섹션으로 이동합니다. 섹션을 펼치세요. 마진을 다음과 같이 설정합니"
"다:"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:146
msgid "Margin Right: *120*"
msgstr "Margin Right: *120*"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:147
msgid "Margin Top: *80*"
msgstr "Margin Top: *80*"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:148
msgid "Margin Left: *120*"
msgstr "Margin Left: *120*"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:149
msgid "Margin Bottom: *80*"
msgstr "Margin Bottom: *80*"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:151
msgid ""
"We want the container to fit the window. In the toolbar above the Viewport, "
"open the **Layout** menu and select the last option, **Full Rect**."
msgstr ""
"컨테이너를 창의 크기에 맞추고 싶습니다. 뷰포트 위의 툴바에서, **레이아웃"
"(Layout)** 메뉴를 열고, 마지막 설정인 **사각형 전체(Full Rect)**\\ 를선택하세"
"요."

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:155
msgid "Add the UI sprites"
msgstr "UI 스프라이트 추가하기"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:157
msgid ""
"Select the ``MarginContainer``, and create the UI elements as "
"``TextureRect`` nodes. We need:"
msgstr ""
"``MarginContainer``\\ 를 선택하고 ``TextureRect`` 노드로 UI 요소를 만드세요. "
"우리는 다음 요소들이 필요합니다:"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:160
msgid "the title or logo,"
msgstr "타이틀이나 로고,"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:161
msgid "the three text options as individual nodes,"
msgstr "개별 노드로 구성된 세 개의 텍스트 설정,"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:162
msgid "the version note,"
msgstr "버전 노트,"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:163
msgid "and the main menu's illustration."
msgstr "그리고 메인 메뉴의 일러스트."

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:165
msgid ""
"Click the **Add Node** button or press :kbd:`Ctrl + A` (:kbd:`Cmd + A` on "
"macOS) on your keyboard. Start to type ``TextureRect`` to find the "
"corresponding node and press enter. With the new node selected, press :kbd:"
"`Ctrl + D` (:kbd:`Cmd + D` on macOS) five times to create five extra "
"``TextureRect`` instances."
msgstr ""
"**노드 추가** 버튼을 클릭하거나 키보드에서 :kbd:`Ctrl + A`(macOS의 경우 :kbd:"
"`Cmd + A`)를 누르세요. ``TextureRect``\\ 를 입력해 해당 노드를 찾고 엔터키를 "
"누르세요. 새 노드를 선택한 상태에서 :kbd:`Ctrl + D`(macOS의 경우 :kbd:`Cmd + "
"D`)를 다섯 번 눌러 ``TextureRect`` 인스턴스 5개를 추가로 생성하세요."

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:170
msgid ""
"Click each of the nodes to select it. In the inspector, find the **Texture** "
"property and click **[empty] > Load**. A file browser opens and lets you "
"pick a sprite to load into the texture slot."
msgstr ""
"각 노드를 클릭해서 선택하세요. 인스펙터(inspector)에서 **Texture** 속성을 찾"
"아, **[비었음]([empty]) -> 불러오기(Load)**\\ 를 클릭합니다. 파일 브라우저가 "
"열리면 텍스처 슬롯에 불러올 스프라이트를 선택할 수 있습니다."

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:176
msgid "The file browser lets you find and load textures."
msgstr "파일 브라우저에서 불러올 텍스처를 찾을 수 있습니다."

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:178
msgid ""
"Repeat the operation for all ``TextureRect`` nodes. You should have the "
"logo, the illustration, the three menu options and the version note, each as "
"a separate node. Then, double click on each of the nodes in the Scene tab to "
"rename them. Nothing has been placed in containers yet so this should look "
"messy."
msgstr ""
"모든 ``TextureRect`` 노드에 대해 이 작업을 반복하세요. 로고, 일러스트레이션, "
"세 가지 메뉴, 옵션, 버전 노트가 각각 별도의 노드로 만들어져 있어야 합니다. 그"
"런 다음 장면 탭에서 각 노드를 두 번 클릭해 이름을 바꾸세요. 아직 컨테이너에 "
"아무것도 넣지 않았으므로 지저분해 보입니다."

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:186
msgid "The six nodes with textures loaded."
msgstr "텍스처를 불러온 6 개의 노드."

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:190
msgid ""
"If you want to support localization in your game, use ``Labels`` for menu "
"options instead of ``TextureRect``."
msgstr ""
"게임에 현지화를 지원하고 싶다면, 메뉴 설정에 ``TextureRect`` 대신에 "
"``Labels``\\ 을 사용하세요."

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:194
msgid "Add containers to place UI elements automatically"
msgstr "컨테이너를 추가해 UI 요소들을 자동으로 배치하기"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:196
msgid ""
"Our main menu has some margin around the edges of the screen. It is split in "
"two parts: on the left, you have the logo and the menu options. On the "
"right, you have the characters. We can use one of two containers to achieve "
"this: ``HSplitContainer`` or ``HBoxContainer``. Split containers split the "
"area into two: a left and a right side or a top and a bottom side. They also "
"allow the user to resize the left and right areas using an interactive bar. "
"On the other hand, ``HBoxContainer`` just splits itself into as many columns "
"as it has children. Although you can deactivate the split container's resize "
"behavior, it's recommended to favor box containers."
msgstr ""
"메인 메뉴의 화면 가장자리에는 약간의 마진이 있습니다. 메인 메뉴는 왼쪽의 로고"
"와 메뉴 옵션, 오른쪽의 캐릭터 두 부분으로 나뉩니다. 이를 구현하기 위해 컨테이"
"너 ``HSplitContainer`` 또는 ``HBoxContainer``\\ 를 사용할 수 있습니다. 분할 "
"컨테이너(``HSplitContainer``)는 영역을 왼쪽과 오른쪽 또는 위쪽과 아래쪽 두 부"
"분으로 나눕니다. 분할 컨테이너는 사용자가 대화형 바를 사용해 왼쪽 및 오른쪽 "
"영역의 크기를 조정할 수 있도록 합니다. 반면에 박스 컨테이너"
"(``HBoxContainer``)는 자식 수 만큼의 열로 나눠집니다. 분할 컨테이너의 크기 조"
"정 동작을 비활성화할 수 있지만 저는 박스 컨테이너를 추천합니다."

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:207
msgid ""
"Select the ``MarginContainer`` and add an ``HBoxContainer``. Then, we need "
"two containers as children of our ``HBoxContainer``: a ``VBoxContainer`` for "
"the menu options on the left, and a ``CenterContainer`` for the illustration "
"on the right."
msgstr ""
"``MarginContainer``\\ 를 선택하고 ``HBoxContainer``\\ 를 추가합니다. 그런 다"
"음 ``HBoxContainer``\\ 의 자식으로 왼쪽에는 메뉴 옵션을 넣을 "
"``VBoxContainer``\\ 와 오른쪽에는 삽화를 넣을 ``CenterContainer``\\ 두 개의 "
"컨테이너가 필요합니다."

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:214
msgid ""
"You should have four nested containers and the TextureRect nodes sitting "
"aside from it."
msgstr ""
"4 개의 중첩된 컨테이너가 있고, 그 옆에 TextureRect 노드가 있어야 합니다."

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:217
msgid ""
"In the node tree, select all the ``TextureRect`` nodes that should go on the "
"left side: the logo, the menu options (Continue, NewGame, Options), and the "
"version note. Drag and drop them into the ``VBoxContainer``. The nodes "
"should position automatically."
msgstr ""
"노드 트리에서 왼쪽에 있어야 하는 모든 ``TextureRect`` 노드들, 즉 로고, 메뉴 "
"옵션(Continue, NewGame, Option), 버전 정보를 선택하세요. 노드들을 "
"``VBoxContainer``\\ 로 끌어다 놓으세요. 노드는 자동으로 배치됩니다."

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:224
msgid "Containers automatically place and resize textures"
msgstr "컨테이너가 자동으로 텍스처를 위치시키고 크기를 조정합니다"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:226
msgid "We're left with two problems to solve:"
msgstr "해결해야 할 두 가지 문제가 남아 있습니다:"

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:228
msgid "The characters on the right aren't centered."
msgstr "오른쪽의 Characters가 중앙에 있지 않습니다."

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:229
msgid "There's no space between the logo and the other UI elements."
msgstr "로고와 다른 UI 요소들 사이에 공간이 없습니다."

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:231
msgid ""
"To center the characters on the right, first select the ``CenterContainer``. "
"Then in the Inspector, scroll down to the **Size Flags** category and click "
"on the field to the right of the **Vertical** property, and check **Expand** "
"in addition to **Fill**. Do the same for the **Horizontal** property. This "
"makes the ``CenterContainer`` expand into all available space while "
"respecting its neighbour ``VBoxContainer``. Finally, drag and drop the "
"Characters node into the ``CenterContainer``. The Characters element will "
"center automatically."
msgstr ""
"캐릭터를 오른쪽 중앙에 오게 하려면 먼저 ``CenterContainer``\\ 를 선택하세요. "
"그런 다음 인스펙터(Inspector)에서 **Size Flags** 카테고리로 스크롤해 "
"**Vertical** 속성의 오른쪽에 있는 필드를 클릭하고 **Fill**\\ 과 함께 "
"**Expand**\\ 를 선택하세요. **Horizontal** 속성에도 똑같이 해주세요. 이렇게 "
"하면 ``CenterContainer``\\ 가 이웃 ``VBoxContainer``\\ 를 존중하면서 차지할 "
"수 있는 모든 공간으로 확장됩니다. 마지막으로 Characters 노드를 "
"``CenterContainer``\\ 로 끌어다 놓으세요. Characters 요소는 자동으로 중앙에 "
"배치됩니다."

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:242
msgid ""
"The character node centers inside the right half of the screen as soon as "
"you place it inside the CenterContainer."
msgstr ""
"Character 노드는 CenterContainer 내부에 배치하는 즉시 화면의 오른쪽 중앙 중앙"
"에 위치합니다."

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:245
msgid ""
"To space out the menu options and the logo on the left, we'll use one final "
"container and its size flags. Select the ``VBoxContainer`` and press :kbd:"
"`Ctrl + A` (:kbd:`Cmd + A` on macOS) to add a new node inside it. Add a "
"second ``VBoxContainer`` and name it *MenuOptions*. Select all three menu "
"options, ``Continue``, ``NewGame`` and ``Options``, and drag and drop them "
"inside the new ``VBoxContainer``. The UI's layout should barely change, if "
"at all."
msgstr ""
"메뉴 옵션과 왼쪽의 로고 사이에 간격을 두기 위해 최종 컨테이너 하나와 크기 플"
"래그를 사용할 것입니다. ``VBoxContainer``\\ 를 선택하고 :kbd:`Ctrl + A`(macOS"
"에서는 :kbd:`Cmd + A`)를 눌러 내부에 새 노드를 추가하세요. 두 번째 ``VBox컨테"
"이너``\\ 를 추가하고 이름을 *MenuOptions*\\ 이라고 지으세요. 세 가지 메뉴 옵"
"션인 ``Continue``, ``NewGame``, ``Options``\\ 를 모두 선택하고 새 "
"``VBoxContainer``\\ 에 끌어다 놓으세요. UI의 레이아웃은 전혀 변경되지 않습니"
"다."

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:255
msgid ""
"Place the new container between the other two nodes to retain the UI's "
"layout."
msgstr ""
"UI의 레이아웃을 유지하려면 다른 두 노드 사이에 새 컨테이너를 배치하세요."

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:258
msgid ""
"Now we grouped the menu options together, we can tell their container to "
"expand to take as much vertical space as possible. Select the "
"``MenuOptions`` node. In the Inspector, scroll down to the **Size Flags** "
"category. Click on the field to the right of the **Vertical** property, and "
"check **Expand** in addition to **Fill**. The container expands to take all "
"the available vertical space while respecting its neighbors, the ``Logo`` "
"and ``Version`` elements."
msgstr ""
"이제 메뉴 옵션을 함께 그룹화하면 컨테이너가 확장되어 가능한 한 많은 수직 공간"
"을 차지하도록 할 수 있습니다. ``MenuOptions`` 노드를 선택합니다. 인스펙터"
"(Inspector)에서 **Size Flags** 카테고리까지 아래로 스크롤하세요. "
"**Vertical** 속성의 오른쪽에 있는 영역을 클릭하고 **Fill**\\ 과 함께 "
"**Expand**\\ 를 선택하세요. 컨테이너는 이웃인 ``Logo`` 및 ``Version`` 요소의 "
"영역을 침범하지 않으면서 사용 가능한 모든 수직 공간을 차지하도록 확장됩니다."

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:266
msgid ""
"To center the nodes in the ``VBoxContainer``, scroll to the top of the "
"Inspector and change the **Alignment** property to **Center**."
msgstr ""
"``VBoxContainer`` 안의 노드들을 중앙에 배치하려면 인스펙터(Inspector) 위쪽으"
"로 스크롤해서 **Alignment** 속성을 **Center**\\ 로 변경하세요."

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:271
msgid "The menu options should center vertically in the UI's left column."
msgstr "메뉴 옵션들은 UI의 왼쪽 열에서 수직으로 중앙에 있어야 합니다."

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:273
msgid ""
"To wrap things up, let's add some separation between the menu options. "
"Expand the **Custom Constants** category below **Size Flags**, and click the "
"field next to the **Separation** parameter. Set it to 30. Once you press "
"enter, the **Separation** property becomes active and Godot adds 30 pixels "
"between menu options."
msgstr ""
"마무리를 위해 메뉴 옵션 사이에 약간의 분리 영역을 추가해 보겠습니다. **Size "
"Flags** 아래의 **Custom Constants** 카테고리를 확장하고 **Separation** 매개변"
"수 옆의 영역을 클릭하세요. 값을 30으로 설정하세요. 엔터를 누르면 "
"**Separation** 속성이 활성화되고 Godot가 메뉴 옵션들 사이에 30픽셀씩 추가합니"
"다."

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:281
msgid "The final interface."
msgstr "최종 인터페이스."

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:283
msgid ""
"Without a single line of code, we have a precise and responsive main menu."
msgstr ""
"코드 한 줄도 안 쓰고, 우리는 정확하고 반응성 있는 메인 메뉴를 만들었습니다."

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:286
msgid ""
"Congratulations for getting there! You can download the final menu :download:"
"`ui_main_menu_design.zip <files/ui_main_menu_design.zip>` to compare with "
"your own. In the next tutorial, you'll create a Game User Interface with "
"bars and item counters."
msgstr ""
"여기까지 오신 것을 축하합니다! 최종 메뉴 :download:`ui_main_menu_design.zip "
"<files/ui_main_menu_design.zip>`\\ 을 다운로드해서 여러분의 것과 비교할 수 있"
"습니다. 다음 튜토리얼에서는 바와 아이템 카운터가 있는 게임 사용자 인터페이스"
"를 만들 것입니다."

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:294
msgid ""
"A responsive User Interface is all about making sure our UIs scale well on "
"all screen types. TV screens and computer displays have different sizes and "
"ratios. In Godot, we use containers to control the position and the size of "
"UI elements."
msgstr ""
"반응형 사용자 인터페이스는 모든 화면 유형에서 UI가 잘 확장되도록 만드는 것을 "
"의미합니다. TV 화면과 컴퓨터 디스플레이는 크기와 비율이 다릅니다. Godot에서"
"는 컨테이너를 사용하여 UI 요소의 위치와 크기를 제어합니다."

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:299
msgid ""
"The order in which you nest matters. To see if your UI adapts nicely to "
"different screen ratios, select the root node, press :kbd:`Q` to activate "
"the Select Mode, select the container and click and drag on one of the "
"container's corners to resize it. The UI components should flow inside of it."
msgstr ""
"여러분이 중첩한 순서가 중요합니다. UI가 서로 다른 화면 비율에 잘 적응하는지 "
"확인하려면 루트 노드를 선택하고 :kbd:`Q`\\ 를 눌러 선택 모드를 활성화하고 컨"
"테이너를 선택한 다음 컨테이너의 모서리 중 하나를 클릭해 크기를 조정하세요. "
"UI 구성 요소는 UI 안에서 움직여야 합니다."

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:305
msgid ""
"You'll notice that although containers move sprites around, they don't scale "
"them. This is normal. We want the UI system to handle different screen "
"ratios, but we also need the entire game to adapt to different screen "
"resolutions. To do this, Godot scales the entire window up and down."
msgstr ""
"컨테이너가 스프라이트를 움직이지만 스프라이트의 크기를 조정하지는 않습니다. "
"정상입니다. UI 시스템이 서로 다른 화면 비율을 처리하기를 원하지만, 전체 게임"
"이 서로 다른 화면 해상도에 알맞게 처리되어야 합니다. 이를 위해 Godot는 전체 "
"창의 크기를 위아래로 조정합니다."

#: ../../docs/getting_started/step_by_step/ui_main_menu.rst:311
msgid ""
"You can change the scale mode in the project settings: click **Project > "
"Project Settings** in the top menu. In the window's left column, look for "
"the **Display** category. Click on the **Window** sub-category. On the right "
"side of the window, you'll find a **Stretch** section. The three settings, "
"**Mode**, **Aspect**, and **Shrink**, control the screen size. For more "
"information, see :ref:`doc_multiple_resolutions`."
msgstr ""
"프로젝트 설정에서 크기 조절 모드를 변경할 수 있습니다. 위쪽 메뉴에서 **프로젝"
"트(Project) > 프로젝트 설정(Project Settings)**\\ 을 클릭하세요. 창의 왼쪽 열"
"에서 **디스플레이** 카테고리를 찾으세요. **Windows** 하위 카테고리를 클릭하세"
"요. 창 오른쪽에 **Stretch** 섹션이 있습니다. **Mode**, **Aspect**, **Shrink**"
"\\ 의 세 가지 설정은 화면 크기를 제어합니다. 자세한 내용은 :ref:"
"`doc_multiple_resolutions`\\ 를 읽어보세요."
