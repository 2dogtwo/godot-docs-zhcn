# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2021, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-11-19 11:09+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:4
msgid "Control the game's UI with code"
msgstr "코드를 통해 게임 UI 제어하기"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:7
msgid "Intro"
msgstr "소개"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:9
msgid ""
"In this tutorial, you will connect a character to a life bar and animate the "
"health loss."
msgstr ""
"이 튜토리얼에서, 여러분은 캐릭터를 체력 바와 연결하고 체력이 줄어드는 애니메"
"이션을 구현할 것입니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:14
msgid ""
"Here's what you'll create: the bar and the counter animate when the "
"character takes a hit. They fade when it dies."
msgstr ""
"우리는 위와 같이 만들 것입니다. 캐릭터가 공격을 받으면 체력 바와 카운터가 줄"
"어듭니다. 체력 바와 카운터는 죽을 때 사라집니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:18
msgid "You will learn:"
msgstr "다음을 배울 것입니다:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:20
msgid "How to **connect** a character to a GUI with signals"
msgstr "시그널(signals)을 사용해 GUI에 캐릭터를 **연결(connect)**\\ 하는 방법"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:21
msgid "How to **control** a GUI with GDscript"
msgstr "GDScript로 GUI를 **제어**\\ 하는 방법"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:22
msgid "How to **animate** a life bar with the :ref:`Tween <class_Tween>` node"
msgstr ""
":ref:`Tween <class_Tween>` 노드로 체력 바에 **애니메이션을 적용**\\ 하는 방법"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:25
msgid ""
"If you want to learn how to set up the interface instead, check out the step-"
"by-step UI tutorials:"
msgstr ""
"대신 인터페이스를 설정하는 방법을 배우려면 단계별 UI 튜토리얼을 확인하세요:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:28
msgid ":doc:`ui_main_menu`"
msgstr ":doc:`ui_main_menu`"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:29
msgid ":doc:`ui_game_user_interface`"
msgstr ":doc:`ui_game_user_interface`"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:32
msgid ""
"When you code a game, you want to build the core gameplay first: the main "
"mechanics, player input, win and loss conditions. The UI comes a bit later. "
"You want to keep all the elements that make up your project separate if "
"possible. Each character should be in its own scene, with its own scripts, "
"and so should the UI elements. This prevents bugs, keeps your project "
"manageable, and allows different team members to work on different parts of "
"the game."
msgstr ""
"게임을 코딩할 때 주요 메커니즘, 플레이어 입력, 승패 조건과 같은 핵심 게임 플"
"레이를 먼저 구축하려고 합니다. UI는 조금 늦게 구축합니다. 가능하면 프로젝트"
"를 구성하는 모든 요소를 분리된 상태로 유지하려고 합니다. 각 캐릭터는 고유한 "
"스크립트와 함께 고유한 장면에 있어야 하며 UI 요소도 마찬가지입니다. 이렇게 하"
"면 버그를 방지하고 프로젝트를 관리 가능하게 유지하며 다른 팀 구성원이 게임의 "
"다른 부분에서 작업할 수 있습니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:40
msgid ""
"Once the core gameplay and the UI are ready, you'll need to connect them "
"somehow. In our example, we have the Enemy who attacks the Player at "
"constant time intervals. We want the life bar to update when the Player "
"takes damage."
msgstr ""
"핵심 게임 플레이와 UI가 준비되면 이들을 어떻게든 연결해야 합니다. 우리의 예제"
"에는 일정한 시간 간격으로 플레이어를 공격하는 적이 있습니다. 플레이어가 피해"
"를 입을 때마다 체력 바를 업데이트하고 싶습니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:45
msgid "To do this, we will use **signals**."
msgstr "그러기 위해서, 우리는 **시그널(signals)** 을 사용할 것입니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:49
msgid ""
"Signals are Godot's version of the Observer pattern. They allow us to send "
"out some message. Other nodes can connect to the object that **emits** the "
"signal and receive the information. It's a powerful tool we use a lot for "
"User Interface and achievement systems. You don't want to use them "
"everywhere, though. Connecting two nodes adds some coupling between them. "
"When there's a lot of connections, they become hard to manage. For more "
"information, check out the `signals video tutorial <https://youtu.be/"
"l0BkQxF7X3E>`_ on GDquest."
msgstr ""
"시그널은 옵저버(Observer) 패턴의 Godot 버전입니다. 시그널로 메시지를 전달할 "
"수 있습니다. 다른 노드는 시그널을 **방출(emits)**\\ 하고 정보를 받을 수 있는 "
"다른 물체와 연결할 수 있습니다. 시그널은 유저 인터페이스와 업적 달성 시스템"
"에 많이 사용하는 강력한 툴입니다. 그러나 남용하지는 마세요. 두 노드를 연결하"
"면 노드 간의 커플링이 생겨납니다. 연결이 많아지면 관리하기 어려워집니다. 자세"
"한 내용은 GDquest의 `시그널 영상 튜토리얼 <https://youtu.be/l0BkQxF7X3E>`_\\ "
"을 확인하세요."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:53
msgid "Download and explore the start project"
msgstr "시작 프로젝트 다운로드하고 탐색하기"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:55
msgid ""
"Download the Godot project: :download:`ui_code_life_bar.zip <files/"
"ui_code_life_bar.zip>`. It contains all the assets and scripts you need to "
"get started. Extract the .zip archive to get two folders: `start` and `end`."
msgstr ""
"Godot 프로젝트를 다운로드하세요: :download:`ui_code_life_bar.zip <files/"
"ui_code_life_bar.zip>`. 여기에는 시작하는 데 필요한 모든 애셋과 스크립트가 포"
"함되어 있습니다. .zip 파일의 압축을 해제하고 `start`\\ 와 `end`\\ 두 개의 폴"
"더를 가져오세요."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:58
msgid ""
"Load the ``start`` project in Godot. In the ``FileSystem`` dock, double "
"click on LevelMockup.tscn to open it. It's an RPG game's mockup where 2 "
"characters face each other. The pink enemy attacks and damages the green "
"square at regular time intervals, until its death. Feel free to try out the "
"game: the basic combat mechanics already work. But as the character isn't "
"connected to the life bar, the ``GUI`` doesn't do anything."
msgstr ""
"Godot에서 ``start`` 프로젝트를 불러오세요 ``파일시스템(FileSystem)`` 독에서 "
"LevelMockup.tscn을 두 번 클릭해서 여세요. 두 캐릭터가 서로 마주보고 있는 RPG "
"게임의 목업입니다. 분홍색 적은 녹색 사각형이 죽을 때까지 일정한 시간 간격으"
"로 공격해 피해를 줍니다. 한번 게임을 해보세요. 기본 전투 메커니즘은 이미 작동"
"하고 있습니다. 하지만 캐릭터가 체력 바에 연결되어 있지 않기 때문에 ``GUI``\\ "
"는 아무 것도 하지 않습니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:68
msgid ""
"This is typical of how you'd code a game: you implement the core gameplay "
"first, handle the player's death, and only then you'll add the interface. "
"That's because the UI listens to what's happening in the game. So it can't "
"work if other systems aren't in place yet. If you design the UI before you "
"prototype and test the gameplay, chances are it won't work well and you'll "
"have to re-create it from scratch."
msgstr ""
"다음은 게임을 코딩하는 일반적인 방법입니다: 먼저 핵심 게임 플레이를 구현하고 "
"플레이어의 사망을 다룬 뒤에 인터페이스를 추가합니다. UI는 게임에서 무슨 일이 "
"일어나는 지를 듣고 있기 때문입니다. 따라서 UI는 다른 시스템이 제 자리를 잡지 "
"못한다면 작동할 수 없습니다. 게임 플레이를 프로토타이핑하고 테스트하기 전에 "
"UI를 디자인하면 잘 작동하지 않을 수 있으며 그런 경우에 처음부터 다시 만들어"
"야 합니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:71
msgid "The scene contains a background sprite, a GUI, and two characters."
msgstr "씬에는 배경 스프라이트, GUI, 두 캐릭터가 있습니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:75
msgid "The scene tree, with the GUI scene set to display its children"
msgstr "GUI 씬이 자식으로 보이게 놓은 씬 트리"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:77
msgid ""
"The GUI scene encapsulates all of the game's Graphical User Interface. It "
"comes with a barebones script where we get the path to nodes that exist "
"inside the scene:"
msgstr ""
"GUI 씬은 게임의 그래픽 사용자 인터페이스 전체를 캡슐화 합니다. 씬 안에 존재하"
"는 노드의 경로를 얻는 단순한 스크립트와 함께 제공됩니다:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:105
msgid ""
"``number_label`` displays a life count as a number. It's a ``Label`` node"
msgstr "``number_label``\\ 은 체력을 숫자로 보여줍니다. ``Label`` 노드입니다"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:107
msgid "``bar`` is the life bar itself. It's a ``TextureProgress`` node"
msgstr "``bar``\\ 는 체력 바입니다. ``TextureProgress`` 노드입니다"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:108
msgid ""
"``tween`` is a component-style node that can animate and control any value "
"or method from any other node"
msgstr ""
"``tween``\\ 은 다른 노드의 값이나 메서드를 작동하고 제어할 수 있는 구성 요소 "
"스타일의 노드입니다"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:113
msgid ""
"The project uses a simple organization that works for game jams and tiny "
"games."
msgstr ""
"이 프로젝트는 게임 잼(jam)과 작은 게임을 위해 작동하는 간단한 구조를 사용합니"
"다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:115
msgid ""
"At the root of the project, in the `res://` folder, you will find the "
"`LevelMockup`. That's the main game scene and the one we will work with. All "
"the components that make up the game are in the `scenes/` folder. The "
"`assets/` folder contains the game sprites and the font for the HP counter. "
"In the `scripts/` folder you will find the enemy, the player, and the GUI "
"controller scripts."
msgstr ""
"프로젝트 루트의 `res://` 폴더에 `LevelMockup`\\ 이 있습니다. 이것이 주요 게"
"임 씬으로 우리가 작업할 씬입니다. 게임을 구성하는 모든 구성 요소는 `scenes/` "
"폴더에 있습니다. `assets/` 폴더에는 게임 스프라이트와 HP 카운터 글꼴이 들어 "
"있습니다. `scripts/` 폴더에서 적, 플레이어 및 GUI 컨트롤러 스크립트를 찾을 "
"수 있습니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:117
msgid ""
"Click the edit scene icon to the right of the node in the scene tree to open "
"the scene in the editor. You'll see the LifeBar and EnergyBar are sub-scenes "
"themselves."
msgstr ""
"씬 트리의 노드 오른쪽에 있는 씬 편집 아이콘을 클릭해 에디터에서 씬을 여세요. "
"LifeBar와 EnergyBar가 하위 씬으로 있는 것을 볼 수 있습니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:121
msgid "The scene tree, with the Player scene set to display its children"
msgstr "Player 씬이 자식으로 설정된 씬 트리"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:124
msgid "Set up the Lifebar with the Player's max\\_health"
msgstr "플레이어의 max\\_health로 Lifebar 설정하기"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:126
msgid ""
"We have to tell the GUI somehow what the player's current health is, to "
"update the lifebar's texture, and to display the remaining health in the HP "
"counter in the top left corner of the screen. To do this we send the "
"player's health to the GUI every time they take damage. The GUI will then "
"update the ``Lifebar`` and ``Number`` nodes with this value."
msgstr ""
"우리는 플레이어의 현재 체력 수치를 GUI에 알려야 하고, 생명 표시줄 텍스처를 업"
"데이트하고, 화면 왼쪽 위의 HP 카운터에 남은 체력을 표시해야 합니다. 이를 위"
"해 플레이어가 피해를 입을 때마다 플레이어의 체력을 GUI로 보냅니다. 그러면 GUI"
"가 ``Lifebar`` 및 ``Number`` 노드를 이 값으로 업데이트합니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:132
msgid ""
"We could stop here to display the number, but we need to initialize the "
"bar's ``max_value`` for it to update in the right proportions. The first "
"step is thus to tell the ``GUI`` what the green character's ``max_health`` "
"is."
msgstr ""
"여기서 멈추고 숫자를 보여주러 갈 수 있지만 바를 바른 비율로 업데이트하려면 바"
"의 ``max_value``\\ 를 초기화해야 합니다. 그러므로 먼저 초록색 캐릭터의 "
"``max_health``\\ 가 어느 정도인지 ``GUI``\\ 에 알려줘야 합니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:139
msgid ""
"The bar, a `TextureProgress`, has a `max_value` of `100` by default. If you "
"don't need to display the character's health with a number, you don't need "
"to change its `max_value` property. You send a percentage from the `Player` "
"to the `GUI` instead:  `health / max_health * 100`."
msgstr ""
"`TextureProgress` 막대의 `max_value` 는 기본적으로 `100`\\ 입니다. 캐릭터의 "
"체력을 숫자로 표시할 필요가 없다면 `max_value` 속성을 변경할 필요가 없습니"
"다. 대신 `Player`\\ 에서 `GUI`\\ 로 백분율(`health / max_health * 100`)을 전"
"송합니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:143
msgid ""
"Click the script icon to the right of the ``GUI`` in the Scene dock to open "
"its script. In the ``_ready`` function, we're going to store the "
"``Player``'s ``max_health`` in a new variable and use it to set the "
"``bar``'s ``max_value``:"
msgstr ""
"씬 독에서 ``GUI`` 오른쪽의 스크립트 아이콘을 클릭해 여세요. ``_ready`` 함수에"
"서 ``Player``\\ 의 ``max_health``\\ 를 새 변수에 저장하고 이를 사용해 ``bar``"
"\\ 의 ``max_value``\\ 를 설정합니다:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:164
msgid ""
"Let's break it down. ``$\"../Characters/Player\"`` is a shorthand that goes "
"one node up in the scene tree, and retrieves the ``Characters/Player`` node "
"from there. It gives us access to the node. The second part of the "
"statement, ``.max_health``, accesses the ``max_health`` on the Player node."
msgstr ""
"분석해 봅시다. ``$\"../Characters/Player\"``\\ 는 씬 트리의 한 노드 위로 올라"
"가서 거기에서 ``Characters/Player`` 노드를 검색하는 축약 표현입니다. 이 구문"
"은 노드에 대한 접근을 제공합니다. 명령문의 두 번째 부분인 ``.max_health``\\ "
"는 Player 노드의 ``max_health``\\ 에 접근합니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:170
msgid ""
"The second line assigns this value to ``bar.max_value``. You could combine "
"the two lines into one, but we'll need to use ``player_max_health`` again "
"later in the tutorial."
msgstr ""
"두 번째 줄은 이 값을 ``bar.max_value``\\ 에 할당합니다. 두 줄을 하나로 결합"
"할 수 있지만 나중에 튜토리얼 안에서 ``player_max_health``\\ 를 다시 사용해야 "
"하므로 놔둡니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:174
msgid ""
"``Player.gd`` sets the ``health`` to ``max_health`` at the start of the "
"game, so we could work with this. Why do we still use ``max_health``? There "
"are two reasons:"
msgstr ""
"``Player.gd``\\ 는 게임 시작 시 ``health``\\ 를 ``max_health``\\ 로 설정하므"
"로 작업을 계속할 수 있습니다. 왜 여전히 ``max_health``\\ 를 사용할까요? 두 가"
"지 이유가 있습니다:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:178
msgid ""
"We don't have the guarantee that ``health`` will always equal "
"``max_health``: a future version of the game may load a level where the "
"player already lost some health."
msgstr ""
"``health``\\ 가 항상 ``max_health``\\ 와 같다는 보장은 없습니다. 게임의 향후 "
"버전에서 플레이어가 이미 일부 체력을 잃은 채로 레벨을 불러올 지도 모릅니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:184
msgid ""
"When you open a scene in the game, Godot creates nodes one by one, following "
"the order in your Scene dock, from top to bottom. `GUI` and `Player` are not "
"part of the same node branch. To make sure they both exist when we access "
"each other, we have to use the `_ready` function. Godot calls `_ready` right "
"after it loaded all nodes, before the game starts. It's the perfect function "
"to set everything up and prepare the game session. Learn more about _ready: :"
"doc:`scripting_continued`"
msgstr ""
"게임에서 씬을 열 때 Godot는 씬 독의 순서에 따라 위에서 아래로 노드를 하나씩 "
"생성합니다. `GUI`\\ 와 `Player`\\ 는 같은 노드 분기에 있지 않습니다. 서로 접"
"근할 때 서로가 존재하는지 확인하려면 `_ready` 함수를 사용해야 합니다. Godot"
"는 게임이 시작되기 전에 모든 노드를 불러온 직후 `_ready`\\ 를 호출합니다. 이 "
"완벽한 함수는 모든 것을 설정하고 게임 세션을 준비합니다. _ready 함수에 대해 "
"더 알아보기: :doc:`scripting_continued`"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:188
msgid "Update health with a signal when the player takes a hit"
msgstr "플레이어가 피해를 입었을 때 시그널로 체력 업데이트하기"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:190
msgid ""
"Our GUI is ready to receive the ``health`` value updates from the "
"``Player``. To achieve this we're going to use **signals**."
msgstr ""
"우리의 GUI는 ``Player``\\ 로부터 ``health``\\ 값의 업데이트를 받을 준비가 되"
"었습니다. 그러기 위해서 **시그널(signals)**\\ 을 사용할 것입니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:195
msgid ""
"There are many useful built-in signals like `enter_tree` and `exit_tree`, "
"that all nodes emit when they are respectively created and destroyed. You "
"can also create your own using the `signal` keyword. On the `Player` node, "
"you'll find two signals we created for you: `died` and `health_changed`."
msgstr ""
"모든 노드는 각각 생성되거나 소멸될 때 방출하는 `enter_tree`\\ 나 `exit_tree` "
"같이 유용한 내장 시그널이 많이 있습니다. `signal` 키워드를 사용해 자신만의 시"
"그널을 만들 수도 있습니다. `Player` 노드에는 여러분을 위해 만들어둔 두 가지 "
"시그널 `died`\\ 와 `health_changed`\\ 를 찾을 수 있습니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:197
msgid ""
"Why don't we directly get the ``Player`` node in the ``_process`` function "
"and look at the health value? Accessing nodes this way creates tight "
"coupling between them. If you did it sparingly it may work. As your game "
"grows bigger, you may have many more connections. If you get nodes this way "
"it gets complex quickly. Not only that: you need to listen to the state "
"change constantly in the ``_process`` function. This check happens 60 times "
"a second and you'll likely break the game because of the order in which the "
"code runs."
msgstr ""
"``_process`` 함수에서 ``Player`` 노드를 직접 가져와서 체력 값을 확인하지 않"
"는 이유가 무엇일까요? 이러한 방식으로 노드에 액세스하면 노드 간에 긴밀한 결합"
"(coupling)이 생성됩니다. 적당히 그렇게 하면 효과가 있을 수 있습니다. 하지만 "
"게임이 커질수록 더 많은 연결이 생길 수 있습니다. 이런 식으로 노드를 가져오면 "
"프로젝트가 빠른 속도로 복잡해집니다. 뿐만 아니라 ``_process`` 함수에서 상태 "
"변화 여부를 지속적으로 수신하고 있어야 합니다. 이 검사는 1초에 60번 발생하며 "
"코드 실행 순서 때문에 게임이 중단될 수 있습니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:206
msgid ""
"On a given frame you may look at another node's property *before* it was "
"updated: you get a value from the last frame. This leads to obscure bugs "
"that are hard to fix. On the other hand, a signal is emitted right after a "
"change happened. It **guarantees** you're getting a fresh piece of "
"information. And you will update the state of your connected node *right "
"after* the change happened."
msgstr ""
"주어진 프레임에서 다른 노드의 속성이 업데이트되기 전에 값을 볼 수 있습니다. "
"그리고 여러분은 마지막 프레임에서 값을 얻습니다. 이것은 수정하기 어려운 모호"
"한 버그로 이어집니다. 반면에 시그널은 변화가 일어난 직후에 방출됩니다. 이는 "
"**여러분이 갱신된 정보를 얻는 것을 보장**\\ 합니다. 그리고 변경이 일어난 *직"
"후*\\ 에 연결된 노드의 상태를 업데이트할 것입니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:215
msgid ""
"The Observer pattern, that signals derive from, still adds a bit of coupling "
"between node branches. But it's generally lighter and more secure than "
"accessing nodes directly to communicate between two separate classes. It can "
"be okay for a parent node to get values from its children. But you'll want "
"to favor signals if you're working with two separate branches. Read Game "
"Programming Patterns for more information on the `Observer pattern <https://"
"gameprogrammingpatterns.com/observer.html>`_. The `full book <https://"
"gameprogrammingpatterns.com/contents.html>`_ is available online for free."
msgstr ""
"시그널에서 파생되는 옵저버 패턴은 노드 분기 간에 약간의 결합을 추가합니다. 그"
"러나 일반적으로 두 개의 별도 클래스 간에 통신하기 위해 노드에 직접 액세스하"
"는 것보다 가볍고 안전합니다. 부모 노드가 자식에서 값을 얻는 것은 괜찮을 수 있"
"습니다. 그러나 두 개의 별도 분기로 작업하는 경우 시그널을 선호할 것입니다. 게"
"임 프로그래밍 패턴에 대한 자세한 내용은 `관찰자 패턴 <https://"
"gameprogrammingpatterns.com/observer.html>`\\ 을 참조하세요. `전체 책 "
"<https://gameprogrammingpatterns.com/contents.html>`_\\ 는 온라인으로 무료로 "
"이용가능합니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:219
msgid ""
"With this in mind, let's connect the ``GUI`` to the ``Player``. Click on the "
"``Player`` node in the scene dock to select it. Head down to the Inspector "
"and click on the Node tab. This is the place to connect nodes to listen to "
"the one you selected."
msgstr ""
"이를 염두에 두고 ``GUI``\\ 를 ``Player``\\ 에 연결해 보겠습니다. 씬(Scene) 독"
"에서 ``Player`` 노드를 클릭해 선택하세요. 인스펙터(Inspector)로 이동해 노드"
"(Node) 탭을 클릭하세요. 여기가 여러분이 선택한 시그널을 받기 위해 노드를 연결"
"하는 곳입니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:224
msgid "The first section lists custom signals defined in ``Player.gd``:"
msgstr ""
"첫 번째 섹션은 ``Player.gd``\\ 에 정의된 사용자 지정 시그널 목록입니다:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:226
msgid ""
"``died`` is emitted when the character died. We will use it in a moment to "
"hide the UI."
msgstr ""
"``died``\\ 는 캐릭터가 죽었을 때 방출됩니다. UI를 감추는 용도로 사용할 것입니"
"다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:228
msgid "``health_changed`` is emitted when the character got hit."
msgstr "``health_changed``\\ 는 캐릭터가 피해를 입었을 때 방출됩니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:232
msgid "We're connecting to the health\\_changed signal"
msgstr "우리는 health\\_changed 시그널을 연결합니다"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:234
msgid ""
"Select ``health_changed`` and click on the Connect button in the bottom "
"right corner to open the Connect Signal window. On the left side you can "
"pick the node that will listen to this signal. Select the ``GUI`` node. The "
"right side of the screen lets you pack optional values with the signal. We "
"already took care of it in ``Player.gd``. In general I recommend not to add "
"too many arguments using this window as they're less convenient than doing "
"it from the code."
msgstr ""
"``health_changed``\\ 를 선택하고 오른쪽 아래 구석에 있는 연결(Connect) 버튼"
"을 클릭해 시그널 연결(Connect Signal) 창을 여세요. 왼쪽에서 이 시그널을 수신"
"할 노드를 선택할 수 있습니다. ``GUI`` 노드를 선택하세요. 화면 오른쪽에서는 시"
"그널에 추가적으로 값을 실을 수 있습니다. 우리는 이미 ``Player.gd``\\ 에서 처"
"리했습니다. 일반적으로 저는 코딩보다 덜 편리하므로 이 창으로 너무 많은 인수"
"를 추가하지 않기를 권장합니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:244
msgid "The Connect Signal window with the GUI node selected"
msgstr "GUI 노드가 선택된 시그널 연결 창"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:248
msgid ""
"You can optionally connect nodes from the code. However doing it from the "
"editor has two advantages:"
msgstr ""
"코드로도 노드를 연결할 수 있습니다. 하지만 에디터로 연결하면 두 가지 장점이 "
"있습니다:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:250
msgid "Godot can write new callback functions for you in the connected script"
msgstr "Godot는 여러분을 위해 연결된 스크립트에 새 콜백 함수를 작성해줍니다"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:251
msgid ""
"An emitter icon appears next to the node that emits the signal in the Scene "
"dock"
msgstr "씬 독에서 시그널을 방출하는 노드 옆에 방출 아이콘이 나타납니다"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:253
msgid ""
"At the bottom of the window you will find the path to the node you selected. "
"We're interested in the second row called \"Method in Node\". This is the "
"method on the ``GUI`` node that gets called when the signal is emitted. This "
"method receives the values sent with the signal and lets you process them. "
"If you look to the right, there is a \"Make Function\" radio button that is "
"on by default. Click the connect button at the bottom of the window. Godot "
"creates the method inside the ``GUI`` node. The script editor opens with the "
"cursor inside a new ``_on_Player_health_changed`` function."
msgstr ""
"창 아래에서 여러분이 선택한 노드의 경로를 찾을 수 있습니다. \"Method in Node"
"\"라는 두 번째 행에 관심이 있습니다. 이것은 신호가 방출될 때 호출되는 "
"``GUI`` 노드의 메서드입니다. 이 메서드는 시그널과 함께 전송된 값을 수신하고 "
"이를 처리할 수 있습니다. 오른쪽을 보면 기본적으로 활성화되어 있는 \"함수 만들"
"기(Make Function)\" 라디오 버튼이 있습니다. 창 아래쪽의 연결(Connect) 버튼을 "
"클릭하세요. Godot는 ``GUI`` 노드 안에 메서드를 생성합니다. 스크립트 에디터가 "
"새 ``_on_Player_health_changed`` 함수 안에 커서가 있는 상태로 열립니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:265
msgid ""
"When you connect nodes from the editor, Godot generates a method name with "
"the following pattern: ``_on_EmitterName_signal_name``. If you wrote the "
"method already, the \"Make Function\" option will keep it. You may replace "
"the name with anything you'd like."
msgstr ""
"에디터에서 노드를 연결하면 Godot는 ``_on_[방출하는_노드_이름]_[시그널_이름]``"
"\\ 패턴으로 메서드 이름을 생성합니다. 이미 메서드를 작성한 경우 \"함수 만들기"
"(Make Function)\" 설정이 그대로 유지됩니다. 함수 이름을 원하는 이름으로 바꿀 "
"수 있습니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:272
msgid "Godot writes the callback method for you and takes you to it"
msgstr "Godot는 콜백 메서드를 작성해줍니다"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:274
msgid ""
"Inside the parentheses after the function name, add a ``player_health`` "
"argument. When the player emits the ``health_changed`` signal, it will send "
"its current ``health`` alongside it. Your code should look like:"
msgstr ""
"함수 이름 뒤의 괄호 안에 ``player_health`` 인수를 추가하세요. 플레이어가 "
"``health_changed`` 시그널을 방출하면 현재 ``health``\\ 값을 함께 보냅니다. 코"
"드는 다음과 같아야 합니다:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:292
msgid ""
"The engine does not convert PascalCase to snake_case, for C# examples we'll "
"be using PascalCase for method names & camelCase for method parameters, "
"which follows the official `C# naming conventions. <https://docs.microsoft."
"com/en-us/dotnet/standard/design-guidelines/capitalization-conventions>`_"
msgstr ""
"엔진은 파스칼 표기법(PascalCase)을 스네이크 표기법(snake_case)으로 변환하지 "
"않기 때문에 C# 예제에서는 공식 `C# 명명 규칙. <https://docs.microsoft.com/en-"
"us/dotnet/standard/design-guidelines/capitalization-conventions>`_\\ 에 따라 "
"메서드 이름에는 파스칼 표기법(PascalCase), 메서드 매개 변수에는 카멜 표기법"
"(camelCase)을 사용할 것입니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:299
msgid ""
"In Player.gd, when the Player emits the health\\_changed signal, it also "
"sends its health value"
msgstr ""
"Player.gd에서 Player는 health\\_changed 시그널을 방출할 때 체력 값도 같이 보"
"냅니다"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:302
msgid ""
"Inside ``_on_Player_health_changed``, let's call a second function called "
"``update_health`` and pass it the ``player_health`` variable."
msgstr ""
"``_on_Player_health_changed`` 내부에서 ``update_health``\\ 라는 두 번째 함수"
"를 호출하고 ``player_health`` 변수를 전달해 봅시다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:307
msgid ""
"We could directly update the health value on `LifeBar` and `Number`. There "
"are two reasons to use this method instead:"
msgstr ""
"`LifeBar` 와 `Number` 에 체력 값을 직접 업데이트할 수도 있습니다. 대신에 이 "
"방법을 사용하는 두 가지 이유가 있습니다:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:309
msgid ""
"The name makes it clear for our future selves and teammates that when the "
"player took damage, we update the health count on the GUI"
msgstr ""
"메서드 이름이 플레이어가 피해를 입었을 때 GUI에서 체력 수치를 업데이트한다는 "
"사실을 미래의 여러분과 팀원에게 명확하게 보여줍니다"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:310
msgid "We will reuse this method a bit later"
msgstr "이 메서드를 나중에 다시 사용할 것입니다"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:312
msgid ""
"Create a new ``update_health`` method below ``_on_Player_health_changed``. "
"It takes a new\\_value as its only argument:"
msgstr ""
"새 메서드 ``update_health``\\ 를 ``_on_Player_health_changed`` 아래에 만드세"
"요. new\\_value를 유일한 인수로 가집니다:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:327
msgid "This method needs to:"
msgstr "이 메서드에는 다음 기능이 필요합니다:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:329
msgid ""
"set the ``Number`` node's ``text`` to ``new_value`` converted to a string"
msgstr ""
"``Number`` 노드의 ``text``\\ 를 문자열로 변환된 ``new_value``\\ 로 설정"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:331
msgid "set the ``TextureProgress``'s ``value`` to ``new_value``"
msgstr "``TextureProgress``\\ 의 ``value``\\ 를 ``new_value``\\ 로 설정"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:350
msgid ""
"``str`` is a built-in function that converts about any value to text. "
"``Number``'s ``text`` property requires a string, so we can't assign it to "
"``new_value`` directly"
msgstr ""
"``str``\\ 은 모든 값을 텍스트로 변환하는 내장 함수입니다. ``Number``\\ 의 "
"``text`` 속성에는 문자열이 필요하므로 체력 값을 ``new_value``\\ 에 바로 할당"
"할 수 없습니다"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:354
msgid ""
"Also call ``update_health`` at the end of the ``_ready`` function to "
"initialize the ``Number`` node's ``text`` with the right value at the start "
"of the game. Press :kbd:`F5` to test the game: the life bar updates with "
"every attack!"
msgstr ""
"또한 ``_ready`` 함수 끝에서 ``update_health``\\ 를 호출해서 게임 시작 시 "
"``Number`` 노드의 ``text``\\ 를 올바른 값으로 초기화해야 합니다. 게임을 테스"
"트하려면 :kbd:`F5`\\ 를 누르세요. 공격할 때마다 체력 바가 업데이트됩니다!"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:361
msgid ""
"Both the Number node and the TextureProgress update when the Player takes a "
"hit"
msgstr ""
"Player가 피해를 입을 때 Number 노드와 TextureProgress가 둘 다 업데이트됩니다"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:365
msgid "Animate the loss of life with the Tween node"
msgstr "Tween 노드로 체력 감소 애니메이션 적용하기"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:367
msgid ""
"Our interface is functional, but it could use some animation. That's a good "
"opportunity to introduce the ``Tween`` node, an essential tool to animate "
"properties. ``Tween`` animates anything you'd like from a start to an end "
"state over a certain duration. For example, it can animate the health on the "
"``TextureProgress`` from its current level to the ``Player``'s new "
"``health`` when the character takes damage."
msgstr ""
"인터페이스는 잘 작동하지만, 몇 가지 애니메이션을 사용할 수 있습니다. 속성 애"
"니메이션을 적용하는 데 필수적인 툴인 ``Tween`` 노드를 소개할 좋은 기회입니"
"다. ``Tween``\\ 은 여러분이 원하는 어떤 것이든지 시작부터 종료 상태까지 일정 "
"기간 동안 애니메이션을 적용합니다. 예를 들어 캐릭터가 피해를 입을 때 "
"``TextureProgress``\\ 의 체력 애니메이션을 현재 수준에서 ``Player``\\ 의 새로"
"운 ``health``\\ 까지 적용할 수 있습니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:374
msgid ""
"The ``GUI`` scene already contains a ``Tween`` child node stored in the "
"``tween`` variable. Let's now use it. We have to make some changes to "
"``update_health``."
msgstr ""
"``GUI`` 씬에는 이미 ``tween`` 변수가 저장된 자식 노드 ``Tween``\\ 가 포함되"
"어 있습니다. 이제 사용해 봅시다. ``update_health``\\ 를 약간 변경해야 합니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:378
msgid ""
"We will use the ``Tween`` node's ``interpolate_property`` method. It takes "
"seven arguments:"
msgstr ""
"``Tween`` 노드의 ``interpolate_property`` 메서드를 사용할 것입니다. 7개의 인"
"수가 필요합니다:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:381
msgid "A reference to the node who owns the property to animate"
msgstr "애니메이션을 적용할 속성을 소유한 노드에 대한 참조"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:382
msgid "The property's identifier as a string"
msgstr "속성 식별자 String 값"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:383
msgid "The starting value"
msgstr "시작 값"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:384
msgid "The end value"
msgstr "끝 값"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:385
msgid "The animation's duration in seconds"
msgstr "애니메이션 지속 시간 (초)"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:386
msgid "The type of the transition"
msgstr "전환(transition) 유형"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:387
msgid "The easing to use in combination with the equation."
msgstr "방정식과 함께 사용할 감속기(easing)."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:389
msgid ""
"The last two arguments combined correspond to an easing equation. This "
"controls how the value evolves from the start to the end point."
msgstr ""
"결합된 마지막 두 인수는 완화 방정식(easing equation)에 해당합니다. 이 식은 값"
"이 시작점에서 끝점까지 어떻게 증가하는지를 제어합니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:393
msgid ""
"Click the script icon next to the ``GUI`` node to open it again. The "
"``Number`` node needs text to update itself, and the ``Bar`` needs a float "
"or an integer. We can use ``interpolate_property`` to animate a number, but "
"not to animate text directly. We're going to use it to animate a new ``GUI`` "
"variable named ``animated_health``."
msgstr ""
"``GUI`` 노드 옆의 스크립트 아이콘을 클릭해서 다시 여세요. ``Number`` 노드는 "
"스스로 업데이트하는 텍스트가 필요하며 ``Bar``\\ 에는 부동 소수(float) 또는 정"
"수가 필요합니다. ``interpolate_property``\\ 를 사용해 숫자에 애니메이션을 적"
"용할 수 있지만 텍스트에 애니메이션을 직접 적용할 수는 없습니다. 이 메서드를 "
"``animated_health``\\ 라는 새로운 ``GUI`` 변수에 애니메이션을 적용하는데 사용"
"하려고 합니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:399
msgid ""
"At the top of the script, define a new variable, name it "
"``animated_health``, and set its value to 0. Navigate back to the "
"``update_health`` method and clear its content. Let's animate the "
"``animated_health`` value. Call the ``Tween`` node's "
"``interpolate_property`` method:"
msgstr ""
"스크립트 맨 위에서 새 변수를 정의하고 이름을 ``animated_health``\\ 로 지은 다"
"음 값을 0으로 설정하세요. 다시 ``update_health`` 메서드로 돌아가 내용을 지우"
"세요. ``animated_health`` 값에 애니메이션을 적용해 봅시다. ``Tween`` 노드의 "
"``interpolate_property`` 메서드를 호출하세요:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:421
msgid "Let's break down the call:"
msgstr "호출을 분석해 봅시다:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:427
msgid ""
"We target ``animated_health`` on ``self``, that is to say the ``GUI`` node. "
"``Tween``'s interpolate\\_property takes the property's name as a string. "
"That's why we write it as ``\"animated_health\"``."
msgstr ""
"``self``, 즉 ``GUI`` 노드에서 ``animated_health``\\ 를 대상으로 합니다. "
"``Tween``\\ 의 interpolate\\_property는 속성 이름을 문자열로 가져옵니다. 이것"
"이 우리가 ``\"animated_health\"``\\ 를 문자열로 쓴 이유입니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:435
msgid ""
"The starting point is the current value the bar's at. We still have to code "
"this part, but it's going to be ``animated_health``. The end point of the "
"animation is the ``Player``'s ``health`` after the ``health_changed``: "
"that's ``new_value``. And ``0.6`` is the animation's duration in seconds."
msgstr ""
"시작점은 바의 현재 값입니다. 여전히 이 부분은 코딩해야 하지만 곧 "
"``animated_health``\\ 가 될 것입니다. 애니메이션의 끝점은 ``health_changed`` "
"이후의 ``Player``\\ 의 ``health``\\ 가 되는데 이것이 ``new_value``\\ 입니다. "
"그리고 ``0.6``\\ 은 애니메이션의 지속 시간(초)입니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:441
msgid ""
"The animation will not play until we activated the ``Tween`` node with "
"``tween.start()``. We only have to do this once if the node is not active. "
"Add this code after the last line:"
msgstr ""
"애니메이션은 ``tween.start()``\\ 로 ``Tween`` 노드를 활성화할 때까지 재생되"
"지 않습니다. 노드가 활성화되어 있지 않으면 이 코드만 실행하면 됩니다. 마지막 "
"줄 뒤에 다음 코드를 추가합니다:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:460
msgid ""
"Although we could animate the `health` property on the `Player`, we "
"shouldn't. Characters should lose life instantly when they get hit. It makes "
"it a lot easier to manage their state, like to know when one died. You "
"always want to store animations in a separate data container or node. The "
"`tween` node is perfect for code-controlled animations. For hand-made "
"animations, check out `AnimationPlayer`."
msgstr ""
"`Player`\\ 에서 `health` 속성에 애니메이션을 적용할 수 있어도 그렇게 해서는 "
"안 됩니다. 캐릭터는 피해를 입으면 즉시 체력이 줄어들어야 합니다. 위의 방식이 "
"캐릭터가 언제 사망했는지 알 수 있는 것처럼 상태를 훨씬 쉽게 관리할 수 있습니"
"다. 여러분은 항상 별도의 데이터 컨테이너 또는 노드에 애니메이션을 저장하려고 "
"합니다. `tween` 노드는 코드로 제어되는 애니메이션에 완벽합 툴입니다. 수제 애"
"니메이션은, `AnimationPlayer`\\ 를 확인하세요."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:463
msgid "Assign the animated\\_health to the LifeBar"
msgstr "animated\\_health를 LifeBar에 지정하기"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:465
msgid ""
"Now the ``animated_health`` variable animates but we don't update the actual "
"``Bar`` and ``Number`` nodes anymore. Let's fix this."
msgstr ""
"이제 ``animated_health`` 변수에 애니메이션이 적용되지만 더 이상 실제 ``Bar``"
"\\ 와 ``Number``\\ 노드를 업데이트하지 않습니다. 이 문제를 해결해 봅시다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:468
msgid "So far, the update\\_health method looks like this:"
msgstr "지금까지 update\\_health 메서드는 다음과 같습니다:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:492
msgid ""
"In this specific case, because ``number_label`` takes text, we need to use "
"the ``_process`` method to animate it. Let's now update the ``Number`` and "
"``TextureProgress`` nodes like before, inside of ``_process``:"
msgstr ""
"특정한 경우 ``number_label``\\ 이 텍스트를 차지하기 때문에 우리는 "
"``_process`` 메서드로 텍스트에 애니메이션을 적용해야 합니다. 이제 전과 같이 "
"``_process``\\ 안에 ``Number``\\ 와 ``TextureProgress``\\ 노드를 업데이트합시"
"다:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:514
msgid ""
"`number_label` and `bar` are variables that store references to the `Number` "
"and `TextureProgress` nodes."
msgstr ""
"`number_label`\\ 과 `bar`\\ 는 각각 `Number`\\ 와 `TextureProgress`\\ 노드에 "
"대한 참조를 저장하는 변수들입니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:516
msgid ""
"Play the game to see the bar animate smoothly. But the text displays decimal "
"number and looks like a mess. And considering the style of the game, it'd be "
"nice for the life bar to animate in a choppier fashion."
msgstr ""
"게임을 실행하면 바에 애니메이션이 부드럽게 적용된 것을 볼 수 있습니다. 하지"
"만 텍스트는 소수를 표시하고 난잡해 보입니다. 그리고 게임의 스타일을 고려하면 "
"체력 바가 더 고르게 움직이는 것이 좋을 것입니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:522
msgid "The animation is smooth, but the number is broken"
msgstr "애니메이션은 부드럽지만 숫자는 망가졌습니다"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:524
msgid ""
"We can fix both problems by rounding out ``animated_health``. Use a local "
"variable named ``round_value`` to store the rounded ``animated_health``. "
"Then assign it to ``number_label.text`` and ``bar.value``:"
msgstr ""
"``animated_health``\\ 를 반올림해서 두 문제를 동시에 해결할 수 있습니다. "
"``round_value``\\ 라는 지역 변수를 사용해서 반올림된 ``animated_health``\\ "
"를 저장합니다. 그런 다음 이 값을 ``number_label.text``\\ 와 ``bar.value``\\ "
"에 할당합니다:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:546
msgid "Try the game again to see a nice blocky animation."
msgstr "게임을 다시 실행하면 멋진 블록 애니메이션을 볼 수 있습니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:550
msgid "By rounding out animated\\_health, we kill two birds with one stone"
msgstr "animated\\_health를 반올림해서 일석이조의 효과를 냈습니다"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:554
msgid ""
"Every time the player takes a hit, the ``GUI`` calls "
"``_on_Player_health_changed``, which in turn calls ``update_health``. This "
"updates the animation and the ``number_label`` and ``bar`` follow in "
"``_process``. The animated life bar that shows the health going down "
"gradually is a trick. It makes the GUI feel alive. If the ``Player`` takes 3 "
"damage, it happens in an instant."
msgstr ""
"플레이어가 피해를 입을 때마다, ``GUI``\\ 는 ``_on_Player_health_changed``\\ "
"를 호출하고 이는 차례로 ``update_health``\\ 를 호출합니다. 그러면 애니메이션"
"이 업데이트되고 ``_process``\\ 에서 ``number_label`` 및 ``bar``\\ 가 결과값"
"을 따라갑니다. 체력이 점차적으로 감소하는 것을 보여주는 애니메이션이 적용된 "
"체력 바는 트릭입니다. 애니메이션이 GUI가 살아있는 것처럼 느끼도록 만듭니다. "
"``Player``\\ 가 3 데미지를 입으면, 즉시 애니메이션이 적용됩니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:562
msgid "Fade the bar when the Player dies"
msgstr "Player가 사망할 때 체력바 사라지게 하기"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:564
msgid ""
"When the green character dies, it plays a death animation and fades out. At "
"this point, we shouldn't show the interface anymore. Let's fade the bar as "
"well when the character died. We will reuse the same ``Tween`` node as it "
"manages multiple animations in parallel for us."
msgstr ""
"초록색 캐릭터가 사망하면 사망 애니메이션을 재생하고 점진적으로 사라집니다"
"(fade out). 이 시점에서 인터페이스를 더 이상 표시하지 않아야 합니다. 캐릭터"
"가 죽었을 때 체력바도 점진적으로 사라집니다. 여러 애니메이션을 동시에 관리하"
"므로 동일한 ``Tween`` 노드를 재사용할 것입니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:569
msgid ""
"First, the ``GUI`` needs to connect to the ``Player``'s ``died`` signal to "
"know when it died. Press :kbd:`Ctrl + F1` to jump back to the 2D Workspace. "
"Select the ``Player`` node in the Scene dock and click on the Node tab next "
"to the Inspector."
msgstr ""
"먼저, ``GUI``\\ 는 ``Player``\\ 의 ``died``\\ 시그널에 연결해서 언제 사망했는"
"지 알아야 합니다. :kbd:`Ctrl + F1` 키를 눌러 2D 작업 공간으로 돌아가세요. 씬"
"(Scene) 독에서 ``Player`` 노드를 선택하고 인스펙터(Inspecter) 옆의 노드"
"(Node) 탭을 클릭하세요."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:574
msgid "Find the ``died`` signal, select it, and click the Connect button."
msgstr "``died`` 시그널을 찾아 선택하고, 연결(Connect) 버튼을 누르세요."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:578
msgid "The signal should already have the Enemy connected to it"
msgstr "시그널에는 이미 Enemy와 연결되어 있어야 합니다"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:580
msgid ""
"In the Connecting Signal window, connect to the ``GUI`` node again. The Path "
"to Node should be ``../../GUI`` and the Method in Node should show "
"``_on_Player_died``. Leave the Make Function option on and click Connect at "
"the bottom of the window. This will take you to the ``GUI.gd`` file in the "
"Script Workspace."
msgstr ""
"시그널 연결(Connecting Signal) 창에서, ``GUI`` 노드에 다시 연결하세요. 노드 "
"경로는 ``../../GUI``\\ 가 되어야 하고 노드의 메서드(Method in Node)는 "
"``_on_Player_died``\\ 로 표시되어야 합니다. 함수 만들기 설정을 그대로 둔 채"
"로 창 아래 연결(Connect) 버튼을 누르세요. 그러면 Script 작업 공간의 ``GUI."
"gd`` 파일로 이동합니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:588
msgid "You should get these values in the Connecting Signal window"
msgstr "시그널 연결(Connecting Signal) 창에서 이 값들을 입력해야 합니다"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:592
msgid ""
"You should see a pattern by now: every time the GUI needs a new piece of "
"information, we emit a new signal. Use them wisely: the more connections you "
"add, the harder they are to track."
msgstr ""
"지금쯤이면 패턴이 보일 것입니다. GUI에 새로운 정보가 필요할 때마다 새로운 시"
"그널을 방출합니다. 더 많은 연결을 추가할수록 추적하기가 더 어려워지므로 현명"
"하게 사용하세요."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:594
msgid ""
"To animate a fade on a UI element, we have to use its ``modulate`` property. "
"``modulate`` is a ``Color`` that multiplies the colors of our textures."
msgstr ""
"UI 요소가 점진적으로 사라지도록 애니메이션을 적용하려면 ``modulate`` 속성을 "
"사용해야 합니다. ``modulate``\\ 는 텍스처의 색상값을 곱하는 ``Color``\\ 입니"
"다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:600
msgid ""
"`modulate` comes from the `CanvasItem` class, All 2D and UI nodes inherit "
"from it. It lets you toggle the visibility of the node, assign a shader to "
"it, and modify it using a color with `modulate`."
msgstr ""
"`modulate`\\ 는 `CanvasItem` 클래스에서 나옵니다. 모든 2D와 UI 노드는 여기에 "
"상속됩니다. `CanvasItem` 클래스에서는 노드의 가시성을 켜고 끌 수 있고, 셰이더"
"를 지정하고, `modulate`\\ 에서 색상을 사용해 수정할 수 있습니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:602
msgid ""
"``modulate`` takes a ``Color`` value with 4 channels: red, green, blue and "
"alpha. If we darken any of the first three channels it darkens the "
"interface. If we lower the alpha channel, our interface fades out."
msgstr ""
"``modulate``\\ 는 빨강, 초록, 파랑, 알파의 4개 채널이 있는 ``Color`` 값을 가"
"집니다. 처음 세 채널 중 하나를 어둡게 하면 인터페이스가 어두워집니다. 알파 채"
"널을 낮추면 인터페이스가 희미해집니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:606
msgid ""
"We're going to tween between two color values: from a white with an alpha of "
"``1``, that is to say at full opacity, to a pure white with an alpha value "
"of ``0``, completely transparent. Let's add two variables at the top of the "
"``_on_Player_died`` method and name them ``start_color`` and ``end_color``. "
"Use the ``Color()`` constructor to build two ``Color`` values."
msgstr ""
"우리는 알파 값이 ``1``\\ 인 흰색, 즉 완전히 불투명한 상태에서 알파 값이 ``0``"
"\\ 인 순수한 흰색, 즉완전히 투명한 상태까지 두 색상 값을 트윈(tween)할 것입니"
"다. 두 변수를 ``_on_Player_died`` 메서드 맨 위에 추가하고 이 둘을 각각 "
"``start_color``\\ 와 ``end_color``\\ 라고 이름지으세요. ``Color()`` 생성자"
"(constructor)를 사용해서 두 ``Color`` 값을 만듭니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:628
msgid ""
"``Color(1.0, 1.0, 1.0)`` corresponds to white. The fourth argument, "
"respectively ``1.0`` and ``0.0`` in ``start_color`` and ``end_color``, is "
"the alpha channel."
msgstr ""
"``Color(1.0, 1.0, 1.0)``\\ 는 흰색에 해당합니다. 네 번째 인수인 "
"``start_color``\\ 와 ``end_color``\\ 의 ``1.0``과 ``0.0``은 알파 채널입니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:632
msgid ""
"We then have to call the ``interpolate_property`` method of the ``Tween`` "
"node again:"
msgstr ""
"그런 다음 ``Tween`` 노드의 ``interpolate_property`` 메서드를 다시 호출해야 합"
"니다:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:645
msgid ""
"This time, we change the ``modulate`` property and have it animate from "
"``start_color`` to the ``end_color``. The duration is of one second, with a "
"linear transition. Here's the complete ``_on_Player_died`` method:"
msgstr ""
"이번에는 ``modulate`` 속성을 변경하고 ``start_color``\\ 에서 ``end_color``\\ "
"로 애니메이션을 적용합니다. 지속 시간은 1초로 선형 전환입니다. 다음은 완전한 "
"``_on_Player_died`` 메서드입니다:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:669
msgid "And that is it. You may now play the game to see the final result!"
msgstr ""
"그리고 그게 전부입니다. 이제 게임을 플레이해서 최종 결과물을 볼 수 있습니다!"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:673
msgid "The final result. Congratulations for getting there!"
msgstr "최종 결과물. 여기까지 오신 것을 축하합니다!"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:677
msgid ""
"Using the exact same techniques, you can change the color of the bar when "
"the Player gets poisoned, turn the bar red when its health drops low, shake "
"the UI when they take a critical hit... the principle is the same: emit a "
"signal to forward the information from the `Player` to the `GUI` and let the "
"`GUI` process it."
msgstr ""
"똑같은 기술을 사용해서 Player가 중독되면 체력바의 색상을 변경하고, 생명력이 "
"낮아지면 체력바를 빨간색으로 바꾸고, 치명타를 맞으면 UI를 흔들 수 있습니다. "
"원리는 동일합니다. 시그널을 보내 `Player`\\ 에서 `GUI`\\ 로 정보를 전달하고 "
"`GUI`\\ 가 처리하도록 합니다."
