# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2020, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-05-04 09:58+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:4
msgid "Control the game's UI with code"
msgstr "코드를 통해 게임의 UI를 제어하기"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:7
msgid "Intro"
msgstr "소개"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:9
msgid ""
"In this tutorial, you will connect a character to a life bar and animate the "
"health loss."
msgstr ""
"이 튜토리얼에서, 당신은 캐릭터를 체력 막대와 연결하고 체력이 줄어드는 것을 구"
"현할 것입니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:14
msgid ""
"Here's what you'll create: the bar and the counter animate when the "
"character takes a hit. They fade when it dies."
msgstr ""
"이것이 우리가 만들 것입니다: 캐릭터가 맞을 때 움직이는 막대와 카운터. 캐릭터"
"가 죽으면 서서히 사라집니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:18
msgid "You will learn:"
msgstr "배울 것입니다:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:20
msgid "How to **connect** a character to a GUI with signals"
msgstr "어떻게 캐릭터를 GUI에 시그널을 통해 **연결** 하는가"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:21
msgid "How to **control** a GUI with GDscript"
msgstr "어떻게 GUI를 GDScript를 통해 **제어** 하는가"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:22
msgid "How to **animate** a life bar with the :ref:`Tween <class_Tween>` node"
msgstr ""
"어떻게 체력 막대를 :ref:`Tween <class_Tween>` 노드를 통해 **애니메이트"
"(animate)** 하는가"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:25
msgid ""
"If you want to learn how to set up the interface instead, check out the step-"
"by-step UI tutorials:"
msgstr ""
"어떻게 인터페이스를 설정하는 지를 배우고 싶다면, 단계별 UI 튜토리얼을 참고하"
"세요:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:28
msgid "Create a main menu screen"
msgstr "메인 메뉴 화면 만들기"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:29
msgid "Create a game user interface"
msgstr "게임 사용자 인터페이스 만들기"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:32
msgid ""
"When you code a game, you want to build the core gameplay first: the main "
"mechanics, player input, win and loss conditions. The UI comes a bit later. "
"You want to keep all the elements that make up your project separate if "
"possible. Each character should be in its own scene, with its own scripts, "
"and so should the UI elements. This prevents bugs, keeps your project "
"manageable, and allows different team members to work on different parts of "
"the game."
msgstr ""
"게임을 코딩할 때, 당신은 핵심 게임 플레이를 먼저 만들고 싶을 것입니다: 주요 "
"기능, 플레이어 입력, 승패 여부. UI는 나중에나 떠오를 겁니다. 당신은 프로젝트"
"를 만들기 위한 모든 요소들을 가능한 한 분리되도록 하고 싶을 것입니다. 각 캐릭"
"터는 자신의 씬에, 자신의 스크립트를 가지고 있어서, UI 요소가 되어야 합니다. "
"이것은 버그를 예방하고 프로젝트 관리를 유지하며, 다른 팀 구성원들이 게임의 다"
"른 부분을 작업하도록 만듭니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:40
msgid ""
"Once the core gameplay and the UI are ready, you'll need to connect them "
"somehow. In our example, we have the Enemy who attacks the Player at "
"constant time intervals. We want the life bar to update when the Player "
"takes damage."
msgstr ""
"일단 핵심 게임 플레이와 UI가 준비되었다면, 이 들을 어떤 방법으로 연결해야 합"
"니다. 우리의 예제에서는, 우리는 일정한 시간마다 플레이어를 공격하는 적을 가지"
"고 있습니다. 우리는 플레이어가 피해를 입을 때마다 체력 막대가 업데이트 되길 "
"원합니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:45
msgid "To do this, we will use **signals**."
msgstr "그러기 위해서, 우리는 **시그널(signals)** 을 사용할 것입니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:49
msgid ""
"Signals are Godot's version of the Observer pattern. They allow us to send "
"out some message. Other nodes can connect to the object that **emits** the "
"signal and receive the information. It's a powerful tool we use a lot for "
"User Interface and achievement systems. You don't want to use them "
"everywhere, though. Connecting two nodes adds some coupling between them. "
"When there's a lot of connections, they become hard to manage. For more "
"information, check out the `signals video tutorial <https://youtu.be/"
"l0BkQxF7X3E>`_ on GDquest."
msgstr ""
"시그널은 옵저버 패턴의 Godot 버전입니다. 그들로 메시지를 전달할 수 있습니다. "
"다른 노드들은 시그널을 **방출(emits)** 하고 정보를 받을 수 있는 다른 물체와 "
"연결할 수 있습니다. 이것은 사용자 인터페이스와 업적 달성 시스템에 많이 쓰일 "
"강력한 도구입니다. 그러나 그것들을 남용하기를 권하진 않습니다. 두 노드를 연결"
"하면 노드 간의 커플링이 생겨납니다. 많은 연결이 있다면, 관리하기가 어려워집니"
"다. GDquest의 `signals video tutorial <https://youtu.be/l0BkQxF7X3E>`_ 에서 "
"더 많은 정보를 보실 수 있습니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:53
msgid "Download and explore the start project"
msgstr "시작 프로젝트를 다운로드하고 탐구하기"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:55
msgid ""
"Download the Godot project: :download:`ui_code_life_bar.zip <files/"
"ui_code_life_bar.zip>`. It contains all the assets and scripts you need to "
"get started. Extract the .zip archive to get two folders: `start` and `end`."
msgstr ""
"Godot 프로젝트를 다운로드 하세요: :download:`ui_code_life_bar.zip <files/"
"ui_code_life_bar.zip>`. 시작할 모든 애셋과 스크립트가 포함되어 있습니다. ."
"zip 파일을 풀고 두 개의 폴더가 나옵니다: `start` 와 `end` 입니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:58
msgid ""
"Load the ``start`` project in Godot. In the ``FileSystem`` dock, double "
"click on LevelMockup.tscn to open it. It's an RPG game's mockup where 2 "
"characters face each other. The pink enemy attacks and damages the green "
"square at regular time intervals, until its death. Feel free to try out the "
"game: the basic combat mechanics already work. But as the character isn't "
"connected to the life bar, the ``GUI`` doesn't do anything."
msgstr ""
"Godot에서 ``start`` 프로젝트를 불러옵니다. ``파일 시스템`` 독에서 "
"LevelMockup.tscn을 더블 클릭해서 엽니다. 이것은 두 캐릭터가 마주 보고 있는 "
"RPG 게임의 모형입니다. 분홍색 적이 일정하게 공격하고 초록색 사각형이 맞는 것"
"을 반복합니다, 죽을 때 까지 말이죠. 게임을 한번 해보세요: 기본 전투 구조는 이"
"미 작동합니다. 하지만 캐릭터가 체력 막대와 연결되어 있지 않기 때문에 ``GUI``"
"\\ 는 아무것도 하지 않습니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:68
msgid ""
"This is typical of how you'd code a game: you implement the core gameplay "
"first, handle the player's death, and only then you'll add the interface. "
"That's because the UI listens to what's happening in the game. So it can't "
"work if other systems aren't in place yet. If you design the UI before you "
"prototype and test the gameplay, chances are it won't work well and you'll "
"have to re-create it from scratch."
msgstr ""
"이것은 게임을 코딩하는 일반적인 방법입니다: 먼저 핵심 게임 플레이를 구현합니"
"다, 그리고 플레이어의 사망을 다룹니다, 그런 뒤 인터페이스 만을 추가하는 것입"
"니다. UI는 게임에서 무엇이 일어나는지 듣기 때문입니다. 따라서 다른 시스템이 "
"제 자리를 잡지 못한다면 작동할 수 없습니다. 만일 게임 플레이를 테스트하지 않"
"은 채로 UI를 디자인 한다면, 잘 작동하지 않을 수 있으니 처음부터 다시 만들어"
"야 할 수도 있습니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:71
msgid "The scene contains a background sprite, a GUI, and two characters."
msgstr "씬에는 배경 스프라이트, GUI, 그리고 두 캐릭터가 있습니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:75
msgid "The scene tree, with the GUI scene set to display its children"
msgstr "GUI 씬이 자식으로 보이게 놓은 씬 트리"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:77
msgid ""
"The GUI scene encapsulates all of the game's Graphical User Interface. It "
"comes with a barebones script where we get the path to nodes that exist "
"inside the scene:"
msgstr ""
"GUI 씬은 게임 사용자 인터페이스 전체를 캡슐화 합니다. 씬 안에 존재하는 노드"
"의 경로를 얻는 스크립트와 함께 제공됩니다:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:105
msgid ""
"``number_label`` displays a life count as a number. It's a ``Label`` node"
msgstr "``number_label`` 은 체력을 숫자로 보여줍니다. ``Label`` 노드입니다"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:107
msgid "``bar`` is the life bar itself. It's a ``TextureProgress`` node"
msgstr "``bar`` 는 체력 막대입니다. ``TextureProgress`` 노드입니다"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:108
msgid ""
"``tween`` is a component-style node that can animate and control any value "
"or method from any other node"
msgstr ""
"``tween`` 은 다른 어떤 노드의 값이나 메서드를 제어하고 움직이게 할 수 있는 구"
"성 요소 스타일의 노드입니다"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:113
#, fuzzy
msgid ""
"The project uses a simple organization that works for game jams and tiny "
"games."
msgstr ""
"프로젝트는 게임 잼이나 작은 게임을 위해 작업하는 간단한 조직화를 사용합니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:115
msgid ""
"At the root of the project, in the `res://` folder, you will find the "
"`LevelMockup`. That's the main game scene and the one we will work with. All "
"the components that make up the game are in the `scenes/` folder. The "
"`assets/` folder contains the game sprites and the font for the HP counter. "
"In the `scripts/` folder you will find the enemy, the player, and the GUI "
"controller scripts."
msgstr ""
"프로젝트의 뿌리에서, `res://` 폴더에서, `LevelMockup` 을 찾으실 수 있습니다. "
"이것이 같이 작업할 메인 게임 씬입니다. 게임을 만들기 위한 모든 구성 요소는 "
"`scenes/` 폴더에 있습니다. `assets/` 폴더는 게임 스프라이트와 HP 카운터를 위"
"한 폰트가 들어있습니다. `scripts/` 폴더에서 적, 플레이어, 그리고 GUI 컨트롤"
"러 스크립트를 찾으실 수 있습니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:117
msgid ""
"Click the edit scene icon to the right of the node in the scene tree to open "
"the scene in the editor. You'll see the LifeBar and EnergyBar are sub-scenes "
"themselves."
msgstr ""
"편집기에서 씬 트리 오른쪽의 편집 씬 아이콘을 클릭해서 씬을 엽니다. LifeBar와 "
"EnergyBar 가 하위 씬으로 있는 것을 보실 수 있습니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:121
msgid "The scene tree, with the Player scene set to display its children"
msgstr "Player 씬이 자식으로 설정된 씬 트리"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:124
msgid "Set up the Lifebar with the Player's max\\_health"
msgstr "플레이어의 max\\_health로 Lifebar 설정하기"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:126
msgid ""
"We have to tell the GUI somehow what the player's current health is, to "
"update the lifebar's texture, and to display the remaining health in the HP "
"counter in the top left corner of the screen. To do this we send the "
"player's health to the GUI every time they take damage. The GUI will then "
"update the ``Lifebar`` and ``Number`` nodes with this value."
msgstr ""
"우리는 GUI가 플레이어의 현재 체력이 어떤지 알려주고, 체력 막대의 텍스처를 업"
"데이트하고, 화면 좌측 상단에서 HP 카운터가 남은 체력을 보여주어야 합니다. 그"
"러기 위해 우리는 플레이어가 피해를 입을 때마다 체력을 GUI로 보내야 합니다. "
"GUI는 ``Lifebar`` 와 ``Number`` 노드를 주어진 값으로 업데이트할 것입니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:132
msgid ""
"We could stop here to display the number, but we need to initialize the "
"bar's ``max_value`` for it to update in the right proportions. The first "
"step is thus to tell the ``GUI`` what the green character's ``max_health`` "
"is."
msgstr ""
"여기서 멈추고 숫자를 보여주러 갈 수 있지만, 그 전에 막대의 ``max_value`` 을 "
"초기화해야 정확한 크기로 업데이트할 수 있습니다. 그러므로 먼저 ``GUI`` 가 초"
"록색 캐릭터의 ``max_health`` 가 어느 정도인지 말해야 합니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:139
msgid ""
"The bar, a `TextureProgress`, has a `max_value` of `100` by default. If you "
"don't need to display the character's health with a number, you don't need "
"to change its `max_value` property. You send a percentage from the `Player` "
"to the `GUI` instead:  `health / max_health * 100`."
msgstr ""
"`TextureProgress` 막대는 `100` 의 `max_value` 를  기본적으로 갖고 있습니다. "
"캐릭터의 체력을 숫자로 표시하지 않아도 된다면, 그것의 `max_value` 속성을 바"
"꿀 필요가 없습니다. 대신 `Player` 의 퍼센트를 `GUI` 로 보냅니다: `health / "
"max_health * 100`."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:143
msgid ""
"Click the script icon to the right of the ``GUI`` in the Scene dock to open "
"its script. In the ``_ready`` function, we're going to store the "
"``Player``'s ``max_health`` in a new variable and use it to set the "
"``bar``'s ``max_value``:"
msgstr ""
"씬 독에서 ``GUI`` 오른쪽의 스크립트 아이콘을 클릭합니다. ``_ready`` 함수에"
"서, 우리는 ``Player`` 의 ``max_health`` 을 새 변수로 저장하고 그걸로 ``bar`` "
"의 ``max_value`` 를 설정합니다:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:164
msgid ""
"Let's break it down. ``$\"../Characters/Player\"`` is a shorthand that goes "
"one node up in the scene tree, and retrieves the ``Characters/Player`` node "
"from there. It gives us access to the node. The second part of the "
"statement, ``.max_health``, accesses the ``max_health`` on the Player node."
msgstr ""
"분석해봅시다. ``$\"../Characters/Player\"`` 는 씬 트리의 한 노드를 불러옵니"
"다, 그리고 ``Characters/Player`` 노드를 검색하는 속기입니다. 그것은 노드에게 "
"진입로를 제공합니다. 명령문의 두 번째 부분은, ``.max_health`` 로, Player 노드"
"에 ``max_health`` 를 접근합니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:170
msgid ""
"The second line assigns this value to ``bar.max_value``. You could combine "
"the two lines into one, but we'll need to use ``player_max_health`` again "
"later in the tutorial."
msgstr ""
"두 번째 줄을 ``bar.max_value`` 의 값을 지정합니다.이 두 줄을 하나로 묶을 수"
"도 있습니다, 하지만  이 튜토리얼에서 ``player_max_health`` 를 나중에도 사용해"
"야 할 것입니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:174
msgid ""
"``Player.gd`` sets the ``health`` to ``max_health`` at the start of the "
"game, so we could work with this. Why do we still use ``max_health``? There "
"are two reasons:"
msgstr ""
"``Player.gd`` 는 게임 시작 시 ``health`` 를 ``max_health`` 로 설정합니다, 따"
"라서 이것으로 작업할 수 있었습니다. 왜 여전히 ``max_health`` 를 사용하냐고"
"요? 두 가지 이유가 있습니다:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:178
msgid ""
"We don't have the guarantee that ``health`` will always equal "
"``max_health``: a future version of the game may load a level where the "
"player already lost some health."
msgstr ""
"``health`` 가 항상 ``max_health`` 와 같다는 보장은 없습니다: 게임의 미래 버전"
"에서는 플레이어가 이미 체력을 잃은 채로 레벨을 불러올 지도 모릅니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:184
msgid ""
"When you open a scene in the game, Godot creates nodes one by one, following "
"the order in your Scene dock, from top to bottom. `GUI` and `Player` are not "
"part of the same node branch. To make sure they both exist when we access "
"each other, we have to use the `_ready` function. Godot calls `_ready` right "
"after it loaded all nodes, before the game starts. It's the perfect function "
"to set everything up and prepare the game session. Learn more about _ready: :"
"doc:`scripting_continued`"
msgstr ""
"게임에서 씬을 열 때,Godot는 씬 독에서 위에서 아래로, 순서에 따라, 하나 씩 노"
"드를 만들어 냅니다. `GUI` 와 `Player` 는 같은 노드 분기에 있지 않습니다. 실"
"행 시에 그들이 함께 있게 만들기 위해선, 우리는 `_ready` 함수를 사용해야 합니"
"다. Godot는 게임이 시작하기 전, 모든 노드를 불러온 후에 `_ready` 를 부릅니"
"다. 모든 것을 설정하고 게임 세션을 준비하기에 최고의 함수입니다. _ready 에 대"
"해서는 :doc:`scripting_continued` 를 참고하세요"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:188
msgid "Update health with a signal when the player takes a hit"
msgstr "플레이어가 피해를 입었을 때 시그널로 체력을 업데이트하기"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:190
msgid ""
"Our GUI is ready to receive the ``health`` value updates from the "
"``Player``. To achieve this we're going to use **signals**."
msgstr ""
"우리의 GUI는 ``Player`` 에서 ``health`` 을 받을 준비가 되었습니다. 그러기 위"
"해 우리는 **시그널(signals)** 을 사용합니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:195
msgid ""
"There are many useful built-in signals like `enter_tree` and `exit_tree`, "
"that all nodes emit when they are respectively created and destroyed. You "
"can also create your own using the `signal` keyword. On the `Player` node, "
"you'll find two signals we created for you: `died` and `health_changed`."
msgstr ""
"많은 유용한 내장 시그널이 있습니다, `enter_tree` 와 `exit_tree` 는 모든 노드"
"가 각각 만들어지고 없어질 때 방출하는 것입니다. 또한 자신만의 `시그널` 키워드"
"를 만들어 사용할 수 있습니다. `Player` 노드에서 두 개의 시그널을 찾으실 수 있"
"습니다: `died` 와 `health_changed` 입니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:197
msgid ""
"Why don't we directly get the ``Player`` node in the ``_process`` function "
"and look at the health value? Accessing nodes this way creates tight "
"coupling between them. If you did it sparingly it may work. As your game "
"grows bigger, you may have many more connections. If you get nodes this way "
"it gets complex quickly. Not only that: you need to listen to the state "
"change constantly in the ``_process`` function. This check happens 60 times "
"a second and you'll likely break the game because of the order in which the "
"code runs."
msgstr ""
"왜 ``_process`` 함수에서 ``Player`` 노드를 바로 가져오지 않고 체력 값을 보"
"죠? 그 방법으로 노드를 접근하는 것은 그들을 단단히 연결합니다. 그걸 원한다면 "
"작동은 할 것입니다. 게임이 커질 수록, 많은 연결을 갖게 될 것입니다. 그 방법으"
"로 노드를 가져오는 것은 복잡해질 것입니다. 그 뿐만이 아니라: 당신은 "
"``_process`` 함수에서 끊임없는 상태 변화를 들어야 합니다. 이 확인은 1초 당 60"
"회이고 코드의 작동 순서 때문에 게임이 꺼질 수도 있습니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:206
msgid ""
"On a given frame you may look at another node's property *before* it was "
"updated: you get a value from the last frame. This leads to obscure bugs "
"that are hard to fix. On the other hand, a signal is emitted right after a "
"change happened. It **guarantees** you're getting a fresh piece of "
"information. And you will update the state of your connected node *right "
"after* the change happened."
msgstr ""
"특정 프레임에서 다른 노드의 속성을 업데이트 되기 *전인* 것을 볼 수 있습니다: "
"마지막 프레임에서 준 값을 가져옵니다. 이로 인해 수정하기 어려운 애매한 버그"
"가 발생합니다. 반면에, 시그널은 변화가 일어난 후에 바로 방출합니다. 당신이 깔"
"끔한 정보를 얻는다는 것을 **보증합니다** 그리고 연결한 노드의 상태가 변화가 "
"일어난 *바로 직후* 에 업데이트 될 것입니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:215
#, fuzzy
msgid ""
"The Observer pattern, that signals derive from, still adds a bit of coupling "
"between node branches. But it's generally lighter and more secure than "
"accessing nodes directly to communicate between two separate classes. It can "
"be okay for a parent node to get values from its children. But you'll want "
"to favor signals if you're working with two separate branches. Read Game "
"Programming Patterns for more information on the `Observer pattern <https://"
"gameprogrammingpatterns.com/observer.html>`_. The `full book <https://"
"gameprogrammingpatterns.com/contents.html>`_ is available online for free."
msgstr ""
"시그널이 파생된, 옵저버 패턴은, 여전히 노드 분기 간의 연결을 추가합니다. 하지"
"만 일반적으로 두 개의 분리된 클래스 사이를 연결하기 위해 직접 노드를 접근하"
"는 것보다 더 가볍고 더 안전합니다. 부모 노드가 자식 노드의 값을 가져올 수 있"
"습니다. 하지만 별도의 가지에서 이 작업을 한다면 시그널을 더 선호할 것입니다. "
"더 많은 정보는 `Observer pattern <http://gameprogrammingpatterns.com/"
"observer.html>`_ 에서 Game Programming Patterns 를 읽어보세요. `전체 책 "
"<http://gameprogrammingpatterns.com/contents.html>`_ 은 온라인에서 무료로 이"
"용할 수 있습니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:219
msgid ""
"With this in mind, let's connect the ``GUI`` to the ``Player``. Click on the "
"``Player`` node in the scene dock to select it. Head down to the Inspector "
"and click on the Node tab. This is the place to connect nodes to listen to "
"the one you selected."
msgstr ""
"이것을 염두해두고 ``GUI`` 를 ``Player``\\ 에 연결합시다. 씬 독에서 "
"``Player`` 노드를 클릭하여 선택합니다. 인스펙터(Inspecter)에서 노드(Node) 탭"
"을 클릭합니다. 여기가 당신이 선택한 시그널을 받기 위해 노드를 연결하는 곳입니"
"다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:224
msgid "The first section lists custom signals defined in ``Player.gd``:"
msgstr "첫 번째 섹션은 ``Player.gd`` 에 정의된 맞춤 시그널 목록입니다:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:226
msgid ""
"``died`` is emitted when the character died. We will use it in a moment to "
"hide the UI."
msgstr ""
"``died`` 는 캐릭터가 죽었을 때 방출합니다. 이것은 UI를 감추는 순간에 사용할 "
"것입니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:228
msgid "``health_changed`` is emitted when the character got hit."
msgstr "``health_changed`` 는 캐릭터가 피해를 입었을 때 방출됩니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:232
msgid "We're connecting to the health\\_changed signal"
msgstr "우리는  health\\_changed 시그널을 연결합니다"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:234
msgid ""
"Select ``health_changed`` and click on the Connect button in the bottom "
"right corner to open the Connect Signal window. On the left side you can "
"pick the node that will listen to this signal. Select the ``GUI`` node. The "
"right side of the screen lets you pack optional values with the signal. We "
"already took care of it in ``Player.gd``. In general I recommend not to add "
"too many arguments using this window as they're less convenient than doing "
"it from the code."
msgstr ""
"``health_changed`` 를 선택하고 오른쪽 아래 연결하기 버튼을 누르고 시그널 연"
"결 창을 엽니다. 왼쪽에서 이 시그널을 듣는 노드를 선택할 수 있습니다. ``GUI`` "
"노드를 선택합니다. 화면 오른쪽은 시그널과 함께 선택적인 값을 보낼 수 있습니"
"다. 우리는 이것을 이미 ``Player.gd`` 에서 다루었습니다. 일반적으로 저는 코딩"
"보다 덜 편리하므로 이 창으로 너무 많은 인수를 추가하지 않기를 권장합니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:244
msgid "The Connect Signal window with the GUI node selected"
msgstr "GUI 노드가 선택된 시그널 연결 창"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:248
msgid ""
"You can optionally connect nodes from the code. However doing it from the "
"editor has two advantages:"
msgstr ""
"선택적으로 코드로부터 노드를 연결할 수 있습니다. 하지만 편집기로 하면 두 가"
"지 이점이 있습니다:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:250
msgid "Godot can write new callback functions for you in the connected script"
msgstr "Godot는 연결된 스크립트에서 새 콜백 함수를 쓸 수 있습니다"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:251
msgid ""
"An emitter icon appears next to the node that emits the signal in the Scene "
"dock"
msgstr "씬 독에서 시그널을 방출하는 노드 옆에 방출 아이콘이 나타납니다"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:253
msgid ""
"At the bottom of the window you will find the path to the node you selected. "
"We're interested in the second row called \"Method in Node\". This is the "
"method on the ``GUI`` node that gets called when the signal is emitted. This "
"method receives the values sent with the signal and lets you process them. "
"If you look to the right, there is a \"Make Function\" radio button that is "
"on by default. Click the connect button at the bottom of the window. Godot "
"creates the method inside the ``GUI`` node. The script editor opens with the "
"cursor inside a new ``_on_Player_health_changed`` function."
msgstr ""
"창의 아래에 당신이 선택한 노드의 경로를 찾으실 수 있습니다. 우리는 \"Method "
"in Node\"라 부르는 두 번째 줄에 관심을 둘 겁니다. 이것은 ``GUI`` 노드에서 시"
"그널이 방출될 때 호출되는 메서드 입니다. 이 메서드는 시그널과 함께 전송된 값"
"을 받아 처리합니다. 오른쪽을 보시면, \"함수 만들기\" 버튼이 기본적으로 켜진 "
"채로 있습니다. 창 아래의 연결 버튼을 누릅니다. Godot는 ``GUI`` 노드 안에 메서"
"드를 만듭니다. 스크립트 편집기를 열면 새로운 ``_on_Player_health_changed`` 함"
"수가 안에 있습니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:265
msgid ""
"When you connect nodes from the editor, Godot generates a method name with "
"the following pattern: ``_on_EmitterName_signal_name``. If you wrote the "
"method already, the \"Make Function\" option will keep it. You may replace "
"the name with anything you'd like."
msgstr ""
"편집기에서 노드를 연결할 때, Godot는 메서드 이름을 다음과 같은 방식으로 만듭"
"니다: ``_on_방출하는노드이름_시그널_이름``. 이미 메서드를 적었다면, \"함수 만"
"들기\" 설정은 유지될 것입니다. 당신이 원하는 어떤 이름으로도 바꿀 수 있습니"
"다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:272
msgid "Godot writes the callback method for you and takes you to it"
msgstr "Godot는 콜백 메서드를 적어 사용자에게 전달합니다"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:274
msgid ""
"Inside the parentheses after the function name, add a ``player_health`` "
"argument. When the player emits the ``health_changed`` signal, it will send "
"its current ``health`` alongside it. Your code should look like:"
msgstr ""
"함수 이름 다음의 괄호 안에, ``player_health`` 인수를 추가하세요. 플레이어가 "
"``health_changed`` 시그널을 방출할 때, 현재 ``health``\\ 와 함께 보내질 것입"
"니다. 코드는 다음과 같아야 합니다:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:292
msgid ""
"The engine does not convert PascalCase to snake_case, for C# examples we'll "
"be using PascalCase for method names & camelCase for method parameters, "
"which follows the official `C# naming conventions. <https://docs.microsoft."
"com/en-us/dotnet/standard/design-guidelines/capitalization-conventions>`_"
msgstr ""
"엔진은 파스칼 표기법(PascalCase)을 스네이크 표기법(snake_case)으로 변환하지 "
"않기 때문에, C# 예제에서 메서드 이름에는 파스칼 표기법, 메서드 매개 변수에는 "
"카멜 표기법(camelCase)을 사용할 것입니다, 공식 `C# 명명 규칙. <https://docs."
"microsoft.com/en-us/dotnet/standard/design-guidelines/capitalization-"
"conventions>`_에 따르는 것입니다"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:299
msgid ""
"In Player.gd, when the Player emits the health\\_changed signal, it also "
"sends its health value"
msgstr ""
"Player.gd에서, Player가 health\\_changed 시그널을 방출할 때, 체력 값도 보냅니"
"다"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:302
msgid ""
"Inside ``_on_Player_health_changed``, let's call a second function called "
"``update_health`` and pass it the ``player_health`` variable."
msgstr ""
"``_on_Player_health_changed`` 안에서, ``update_health`` 라는 두 번째 함수를 "
"호출하고 거기에 ``player_health`` 변수를 전달하게 해봅시다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:307
msgid ""
"We could directly update the health value on `LifeBar` and `Number`. There "
"are two reasons to use this method instead:"
msgstr ""
"우리는 체력 값을 `LifeBar` 와 `Number` 에 직접 업데이트할 수 있습니다. 메서드"
"를 대신 사용하는 이유는 두 가지 입니다:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:309
msgid ""
"The name makes it clear for our future selves and teammates that when the "
"player took damage, we update the health count on the GUI"
msgstr ""
"플레이어가 피해를 입을 때, 이름은 체력 카운터를 업데이트 해야 하는 미래의 나"
"와 팀원에게 그것을 명확하게 해줍니다"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:310
msgid "We will reuse this method a bit later"
msgstr "이 메서드를 나중에 다시 사용할 것입니다"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:312
msgid ""
"Create a new ``update_health`` method below ``_on_Player_health_changed``. "
"It takes a new\\_value as its only argument:"
msgstr ""
"새로운 ``update_health`` 메서드를 ``_on_Player_health_changed`` 아래에 만듭니"
"다.  new\\_value를 유일한 인수로 갖습니다:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:327
msgid "This method needs to:"
msgstr "이 메서드에는 필요합니다:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:329
msgid ""
"set the ``Number`` node's ``text`` to ``new_value`` converted to a string"
msgstr ""
"``Number`` 노드의 ``text`` 를 문자열로 변환된 ``new_value`` 로 설정하는 것"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:331
msgid "set the ``TextureProgress``'s ``value`` to ``new_value``"
msgstr "``TextureProgress`` 의 ``value`` 를 ``new_value`` 로 설정하는 것"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:350
msgid ""
"``str`` is a built-in function that converts about any value to text. "
"``Number``'s ``text`` property requires a string, so we can't assign it to "
"``new_value`` directly"
msgstr ""
"``str``\\ 은 내장 함수로 어느 값을 문자로 변환합니다. ``Number``\\ 의 "
"``text`` 속성은 문자열을 요구하기 때문에 ``new_value``\\ 를 직접 지정할 수 없"
"습니다"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:354
#, fuzzy
msgid ""
"Also call ``update_health`` at the end of the ``_ready`` function to "
"initialize the ``Number`` node's ``text`` with the right value at the start "
"of the game. Press :kbd:`F5` to test the game: the life bar updates with "
"every attack!"
msgstr ""
"또한 ``update_health`` 를 ``_ready`` 함수의 마지막에 호출하여 게임의 시작에"
"서 ``Number`` 노드의 ``text`` 를 적당한 값으로 초기화합니다. F5를 누르면 게임"
"을 테스트합니다: 체력 막대가 매 공격마다 업데이트 됩니다!"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:361
msgid ""
"Both the Number node and the TextureProgress update when the Player takes a "
"hit"
msgstr ""
"Player가 피해를 입을 때 Number 노드와 TextureProgress가 둘 다 업데이트합니다"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:365
msgid "Animate the loss of life with the Tween node"
msgstr "Tween 노드로 체력이 감소하는 것을 애니메이트하기"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:367
msgid ""
"Our interface is functional, but it could use some animation. That's a good "
"opportunity to introduce the ``Tween`` node, an essential tool to animate "
"properties. ``Tween`` animates anything you'd like from a start to an end "
"state over a certain duration. For example, it can animate the health on the "
"``TextureProgress`` from its current level to the ``Player``'s new "
"``health`` when the character takes damage."
msgstr ""
"인터페이스는 작동하지만, 몇 가지 애니메이션을 사용할 수 있습니다. 지금이 속성"
"을 애니메이트 하는데 필수적인 도구, ``Tween`` 노드를 소개하기에 좋은 순간이네"
"요. ``Tween``\\ 은 어떤 것이든 처음부터 끝을 일정 기간 동안 애니메이트 합니"
"다. 예를 들어 캐릭터가 피해를 입을 때  ``Player``\\ 의 현재 새로운 ``health``"
"\\ 로 ``TextureProgress``\\ 에서 체력을 애니메이트 할 수 있습니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:374
msgid ""
"The ``GUI`` scene already contains a ``Tween`` child node stored in the "
"``tween`` variable. Let's now use it. We have to make some changes to "
"``update_health``."
msgstr ""
"``GUI`` 씬에는 이미 ``tween`` 변수가 저장된 ``Tween`` 노드 갖고 있습니다. 이"
"제 사용할 때입니다. 우리는 ``update_health`` 에 몇 가지 변화를 주어야 합니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:378
msgid ""
"We will use the ``Tween`` node's ``interpolate_property`` method. It takes "
"seven arguments:"
msgstr ""
"``Tween`` 노드의 ``interpolate_property`` 메서드를 사용할 겁니다. 그것은 일"
"곱 개의 인수들을 가집니다:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:381
msgid "A reference to the node who owns the property to animate"
msgstr "애니메이트 할 속성을 소유한 노드에 대한 참조"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:382
msgid "The property's identifier as a string"
msgstr "속성 식별자의 문자열"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:383
msgid "The starting value"
msgstr "시작 값"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:384
msgid "The end value"
msgstr "끝 값"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:385
msgid "The animation's duration in seconds"
msgstr "애니메이션의 지속 시간 (초)"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:386
msgid "The type of the transition"
msgstr "전환(transition) 유형"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:387
msgid "The easing to use in combination with the equation."
msgstr "방정식과 함께 사용하는 완화."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:389
msgid ""
"The last two arguments combined correspond to an easing equation. This "
"controls how the value evolves from the start to the end point."
msgstr ""
"마지막 두 인수들은 완화 식(easing equation)으로 동등하게 묶입니다. 이것은 시"
"작에서 끝까지 값이 얼마나 증가하는 지를 제어합니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:393
msgid ""
"Click the script icon next to the ``GUI`` node to open it again. The "
"``Number`` node needs text to update itself, and the ``Bar`` needs a float "
"or an integer. We can use ``interpolate_property`` to animate a number, but "
"not to animate text directly. We're going to use it to animate a new ``GUI`` "
"variable named ``animated_health``."
msgstr ""
"``GUI`` 노드 옆에 스크립트 아이콘을 클릭해서 다시 엽니다. ``Number`` 노드는 "
"스스로 업데이트하는 텍스트가 필요합니다, 그리고 ``Bar`` 는 실수 또는 정수가 "
"필요합니다. 우리는 ``interpolate_property`` 를 사용해서 숫자를 애니메이트 할 "
"것입니다, 텍스트에 직접 하진 않을 겁니다. 우리는 이것을 ``animated_health`` "
"라는 새로운 ``GUI`` 변수를 애니메이트 하는데 이용할 것입니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:399
msgid ""
"At the top of the script, define a new variable, name it "
"``animated_health``, and set its value to 0. Navigate back to the "
"``update_health`` method and clear its content. Let's animate the "
"``animated_health`` value. Call the ``Tween`` node's "
"``interpolate_property`` method:"
msgstr ""
"스크립트 맨 위에서, 새 변수를 정의합니다, 이름은 ``animated_health`` 입니다, "
"그리고 값을 0으로 설정합니다. 다시 ``update_health`` 메서드로 돌아와서 내용물"
"을 지웁니다. ``animated_health`` 값을 애니메이트 해 봅시다. ``Tween`` 노드의 "
"``interpolate_property`` 메서드를 호출합니다:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:421
msgid "Let's break down the call:"
msgstr "호출한 것을 파헤쳐 봅시다:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:427
msgid ""
"We target ``animated_health`` on ``self``, that is to say the ``GUI`` node. "
"``Tween``'s interpolate\\_property takes the property's name as a string. "
"That's why we write it as ``\"animated_health\"``."
msgstr ""
"``animated_health`` 를, ``self`` 에, 즉 ``GUI`` 노드를 타깃으로 합니다. "
"``Tween`` 의 interpolate\\_property는 속성의 이름을 문자열로 가져옵니다. 이것"
"이 우리가 ``\"animated_health\"`` 로 쓴 이유입니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:435
msgid ""
"The starting point is the current value the bar's at. We still have to code "
"this part, but it's going to be ``animated_health``. The end point of the "
"animation is the ``Player``'s ``health`` after the ``health_changed``: "
"that's ``new_value``. And ``0.6`` is the animation's duration in seconds."
msgstr ""
"시작 점은 막대의 현재 값입니다. 이 부분도 코딩을 해야 하지만, 곧 "
"``animated_health`` 가 될 것입니다. 애니메이션의 끝 점은 ``health_changed` 이"
"후의 ``Player`` 의 ``health`` 가 됩니다: 즉, ``new_value`` 입니다. 그리고 "
"``0.6`` 은 애니메이션의 지속 시간입니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:445
msgid ""
"The last two arguments are constants from the ``Tween`` class. "
"``TRANS_LINEAR`` means the animation should be linear. ``EASE_IN`` doesn't "
"do anything with a linear transition, but we must provide this last argument "
"or we'll get an error."
msgstr ""
"마지막 두 인수는 ``Tween`` 클래스의 상수입니다. ``TRANS_LINEAR`` 는 애니메이"
"션이 선형적인 것을 의미합니다. ``EASE_IN`` 선형 변환에선 아무것도 하지 않지"
"만, 꼭 이 마지막 인수를 채워야 에러가 나지 않습니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:450
msgid ""
"The animation will not play until we activated the ``Tween`` node with "
"``tween.start()``. We only have to do this once if the node is not active. "
"Add this code after the last line:"
msgstr ""
"애니메이션은 ``Tween`` 노드가 ``tween.start()`` 로 활성화되기 전 까지 재생되"
"지 않습니다. 노드가 활성화되어있지 않으면 이 작업만 하면 됩니다. 이 코드를 마"
"지막 줄 이후에 추가하세요:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:469
msgid ""
"Although we could animate the `health` property on the `Player`, we "
"shouldn't. Characters should lose life instantly when they get hit. It makes "
"it a lot easier to manage their state, like to know when one died. You "
"always want to store animations in a separate data container or node. The "
"`tween` node is perfect for code-controlled animations. For hand-made "
"animations, check out `AnimationPlayer`."
msgstr ""
"비록 `Player` 에서 `health` 속성을 애니메이트 할 수 있을지라도, 그렇게 해서"
"는 안 됩니다. 캐릭터는 피해를 입었을 때 즉시 체력이 줄어야 합니다. 한 명이 언"
"제 죽었는 지 알 수 있는 것처럼, 이 방식이 그들의 상태를 다루기에 훨씬 더 쉽습"
"니다. 당신은 애니메이션이 항상 분리된 데이터 컨테이너나 노드에 있기를 원합니"
"다. `tween` 노드는 코드로 제어되는 애니메이션에 완벽합니다. 수제 애니메이션"
"은, `AnimationPlayer` 를 확인하세요."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:472
msgid "Assign the animated\\_health to the LifeBar"
msgstr "animated\\_health를 LifeBar에 지정하기"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:474
msgid ""
"Now the ``animated_health`` variable animates but we don't update the actual "
"``Bar`` and ``Number`` nodes anymore. Let's fix this."
msgstr ""
"이제 ``animated_health`` 변수가 애니메이트 하지만 실제 ``Bar`` 와 ``Number`` "
"노드는 더 이상 업데이트 할 수 없습니다. 이것을 고칩시다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:477
msgid "So far, the update\\_health method looks like this:"
msgstr "지금까지, update\\_health 메서드는 이렇게 보입니다:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:501
msgid ""
"In this specific case, because ``number_label`` takes text, we need to use "
"the ``_process`` method to animate it. Let's now update the ``Number`` and "
"``TextureProgress`` nodes like before, inside of ``_process``:"
msgstr ""
"특정한 경우에서, ``number_label`` 이 텍스트를 차지하기 때문에, 우리는 "
"``_process`` 메서드로 그것을 애니메이트 해야 합니다. 이제 ``_process` 안에 "
"``Number`` 와 ``TextureProgress`` 노드를 전과 같이 업데이트 합시다:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:523
msgid ""
"`number_label` and `bar` are variables that store references to the `Number` "
"and `TextureProgress` nodes."
msgstr ""
"`number_label` 과 `bar` 는 `Number` 와 `TextureProgress` 노드에 참조로 저장"
"된 변수들입니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:525
msgid ""
"Play the game to see the bar animate smoothly. But the text displays decimal "
"number and looks like a mess. And considering the style of the game, it'd be "
"nice for the life bar to animate in a choppier fashion."
msgstr ""
"게임을 실행하시면 막대가 부드럽게 애니메이트 하는 것을 보실 수 있습니다. 하지"
"만 텍스트는 소수 숫자로 보여지고 난잡해 보입니다. 그리고 게임의 스타일을 고려"
"해서, 체력 막대가 더 멋진 방식으로 움직이면 좋을 것입니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:531
msgid "The animation is smooth, but the number is broken"
msgstr "애니메이션은 부드럽지만 숫자는 망가졌습니다"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:533
msgid ""
"We can fix both problems by rounding out ``animated_health``. Use a local "
"variable named ``round_value`` to store the rounded ``animated_health``. "
"Then assign it to ``number_label.text`` and ``bar.value``:"
msgstr ""
"``animated_health`` 를 반올림해서 이 문제들을 동시에 해결할 수 있습니다. "
"``round_value`` 라는 지역 변수를 사용해서 반올림 된 ``animated_health`` 를 저"
"장합니다. 그런 뒤 그것을 ``number_label.text`` 와 ``bar.value`` 에 지정합니"
"다:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:555
msgid "Try the game again to see a nice blocky animation."
msgstr "게임을 다시 실행하면 멋진 블록 애니메이션을 볼 수 있습니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:559
msgid "By rounding out animated\\_health, we kill two birds with one stone"
msgstr "animated\\_health를 반올림 해서 일석이조의 효과를 냈습니다"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:563
msgid ""
"Every time the player takes a hit, the ``GUI`` calls "
"``_on_Player_health_changed``, which in turn calls ``update_health``. This "
"updates the animation and the ``number_label`` and ``bar`` follow in "
"``_process``. The animated life bar that shows the health going down "
"gradually is a trick. It makes the GUI feel alive. If the ``Player`` takes 3 "
"damage, it happens in an instant."
msgstr ""
"매 시간 플레이어가 피해를 입을 때, ``GUI`` 는 ``_on_Player_health_changed`` "
"를 호출합니다, 그리고 그것은 ``update_health`` 를 호출합니다. 이것은 애니메이"
"션을 업데이트 하고 ``number_label`` 과 ``bar`` 가 ``_process`` 에서 따라옵니"
"다. 체력이 점차 줄어드는 애니메이트 된 체력 막대는 트릭입니다. 그것은 GUI가 "
"살아있는 것처럼 느끼도록 만듭니다. ``Player`` 가 3 데미지를 입으면, 즉각적으"
"로 발생합니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:571
msgid "Fade the bar when the Player dies"
msgstr "Player가 죽을 때 막대가 사라지게 하기"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:573
msgid ""
"When the green character dies, it plays a death animation and fades out. At "
"this point, we shouldn't show the interface anymore. Let's fade the bar as "
"well when the character died. We will reuse the same ``Tween`` node as it "
"manages multiple animations in parallel for us."
msgstr ""
"초록색 캐릭터가 죽을 때, 죽음 애니메이션을 재생하고 사라집니다. 이 점에서, 우"
"리는 인터페이스를 더 이상 표시해서는 안됩니다. 캐릭터가 죽을 때 처럼 막대를 "
"사라지게 해봅시다. 우리는 ``Tween`` 노드가 여러 애니메이션을 동시에 관리하므"
"로 같은 노드를 다시 사용할 것입니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:578
msgid ""
"First, the ``GUI`` needs to connect to the ``Player``'s ``died`` signal to "
"know when it died. Press :kbd:`F1` to jump back to the 2D Workspace. Select "
"the ``Player`` node in the Scene dock and click on the Node tab next to the "
"Inspector."
msgstr ""
"먼저, ``GUI`` 는 ``Player`` 의 ``died`` 시그널에 연결해서 언제 죽었는 지를 알"
"아야 합니다. :kbd:`F1` 키를 눌러 2D 작업 공간으로 돌아갑니다. 씬 독에서 "
"``Player`` 노드를 선택하고 인스펙터(Inspecter) 옆의 노드 탭을 클릭합니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:583
msgid "Find the ``died`` signal, select it, and click the Connect button."
msgstr "``died`` 시그널을 찾아서, 선택하고, 연결하기 버튼을 누릅니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:587
msgid "The signal should already have the Enemy connected to it"
msgstr "시그널에는 이미 Enemy와 연결되어 있어야 합니다"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:589
msgid ""
"In the Connecting Signal window, connect to the ``GUI`` node again. The Path "
"to Node should be ``../../GUI`` and the Method in Node should show "
"``_on_Player_died``. Leave the Make Function option on and click Connect at "
"the bottom of the window. This will take you to the ``GUI.gd`` file in the "
"Script Workspace."
msgstr ""
"시그널 연결 창에서, ``GUI`` 노드를 다시 연결합니다. 노드 경로는 ``../../"
"GUI`` 가 되어야 하고 Method in Node는 ``_on_Player_died`` 가 되어야 합니다. "
"함수 만들기 설정을 둔 채로 창 아래 연결 버튼을 누릅니다. 이걸로 Script 작업 "
"공간에서 ``GUI.gd`` 파일로 진입하게 됩니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:597
msgid "You should get these values in the Connecting Signal window"
msgstr "시그널 연결 창에서 이 값들을 받아야 합니다"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:601
msgid ""
"You should see a pattern by now: every time the GUI needs a new piece of "
"information, we emit a new signal. Use them wisely: the more connections you "
"add, the harder they are to track."
msgstr ""
"지금부터는 패턴을 보아야 합니다: 매 순간 GUI가 새로운 정보가 필요하면, 우리"
"는 새 시그널을 방출합니다. 그들을 현명하게 사용하세요: 더 많은 연결을 추가할"
"수록, 추적하는 일은 더 어려워집니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:603
msgid ""
"To animate a fade on a UI element, we have to use its ``modulate`` property. "
"``modulate`` is a ``Color`` that multiplies the colors of our textures."
msgstr ""
"UI 요소가 사라지도록 애니메이트 하기 위해, 우리는 그것의 ``modulate`` 속성을 "
"사용해야 합니다. ``modulate`` 는 ``Color`` 로 텍스처의 색상을 곱합니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:609
msgid ""
"`modulate` comes from the `CanvasItem` class, All 2D and UI nodes inherit "
"from it. It lets you toggle the visibility of the node, assign a shader to "
"it, and modify it using a color with `modulate`."
msgstr ""
"`modulate` 는 `CanvasItem` 클래스에서 나옵니다. 모든 2D와 UI  노드는 여기에 "
"상속됩니다. 이것은 노드의 가시성을 켜고 끌 수 있고, 셰이더를 지정하고, "
"`modulate` 에서 색상을 사용하여 수정할 수 있습니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:611
msgid ""
"``modulate`` takes a ``Color`` value with 4 channels: red, green, blue and "
"alpha. If we darken any of the first three channels it darkens the "
"interface. If we lower the alpha channel, our interface fades out."
msgstr ""
"``modulate``\\ 는 4개의 채널로 ``Color`` 값을 갖습니다: 빨강, 초록, 파랑, 그"
"리고 알파입니다. 처음 세 개의 채널들 중 하나를 어둡게 하면 그것은 인터페이스"
"에서 어두워집니다. 알파 채널을 낮추면 인터페이스는 희미해집니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:615
msgid ""
"We're going to tween between two color values: from a white with an alpha of "
"``1``, that is to say at full opacity, to a pure white with an alpha value "
"of ``0``, completely transparent. Let's add two variables at the top of the "
"``_on_Player_died`` method and name them ``start_color`` and ``end_color``. "
"Use the ``Color()`` constructor to build two ``Color`` values."
msgstr ""
"우리는 두 색상 값을 tween할 것입니다: 완전한 불투명을 의미하는, 흰색이고 "
"``1`` 의 알파 값에서, 완전한 투명을 의미하는, 흰색이지만 ``0`` 의 알파 값까"
"지 입니다. 두 변수를 ``_on_Player_died`` 메서드에 추가하고 이 둘을 각각 "
"``start_color`` 과 ``end_color`` 라고 이름짓습니다. ``Color()`` 생성자"
"(constructor)를 사용해서 두 ``Color`` 값을 만듭니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:637
msgid ""
"``Color(1.0, 1.0, 1.0)`` corresponds to white. The fourth argument, "
"respectively ``1.0`` and ``0.0`` in ``start_color`` and ``end_color``, is "
"the alpha channel."
msgstr ""
"``Color(1.0, 1.0, 1.0)`` 는 흰색과 같습니다. 네 번째 인수는, ``start_color`` "
"와 ``end_color`` 에서 각각 ``1.0`` 과 ``0.0`` 인, 알파 채널입니다."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:641
msgid ""
"We then have to call the ``interpolate_property`` method of the ``Tween`` "
"node again:"
msgstr ""
"우리는 ``Tween`` 노드의 ``interpolate_property`` 메서드를 다시 호출해야 합니"
"다:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:654
msgid ""
"This time, we change the ``modulate`` property and have it animate from "
"``start_color`` to the ``end_color``. The duration is of one second, with a "
"linear transition. Here again, because the transition is linear, the easing "
"does not matter. Here's the complete ``_on_Player_died`` method:"
msgstr ""
"이번엔 ``modulate`` 속성을 바꾸고 그것이 ``start_color``\\ 에서 ``end_color``"
"\\ 로 애니메이트 해야 합니다. 지속 시간은 1초로 선형 전환입니다. 다시 말하지"
"만, 전환이 선형이기 때문에 완화는 아무 문제가 없습니다. 이것이 완전한 "
"``_on_Player_died`` 메서드 입니다:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:679
msgid "And that is it. You may now play the game to see the final result!"
msgstr "그리고 됬습니다. 이제 게임을 실행해서 최종 결과물을 봅시다!"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:683
msgid "The final result. Congratulations for getting there!"
msgstr "최종 결과물. 여기까지 오신 것에 축하합니다!"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:687
msgid ""
"Using the exact same techniques, you can change the color of the bar when "
"the Player gets poisoned, turn the bar red when its health drops low, shake "
"the UI when they take a critical hit... the principle is the same: emit a "
"signal to forward the information from the `Player` to the `GUI` and let the "
"`GUI` process it."
msgstr ""
"똑같은 기법을 사용해서, Player가 독에 걸렸을 때 막대의 색상을 바꿀 수 있고, "
"체력이 천천히 줄어들 때 막대가 붉게 바뀌거나, 크리티컬 피해를 입을 때 UI가 흔"
"들리게 하거나... 원리는 같습니다: `Player` 의 정보를 `GUI` 로 보내고 `GUI` "
"가 이를 처리하는 시그널을 방출합니다."
