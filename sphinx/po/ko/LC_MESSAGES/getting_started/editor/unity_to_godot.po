# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2019, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-07-25 10:21+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../docs/getting_started/editor/unity_to_godot.rst:8
msgid "From Unity to Godot Engine"
msgstr "Unity에서 Godot 엔진까지"

#: ../../docs/getting_started/editor/unity_to_godot.rst:10
msgid ""
"This guide provides an overview of Godot Engine from the viewpoint of a "
"Unity user, and aims to help you migrate your existing Unity experience into "
"the world of Godot."
msgstr ""
"이 가이드는 Unity 사용자의 관점에서 Godot 엔진의 개요를 제공합니다, 그리고 존"
"재하는 Unity 경험을 Godot라는 세상에 옮기도록 돕는 것에 중점을 둡니다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:15
msgid ""
"This article talks about older versions of Unity. Nestable prefabs ('Nested "
"prefabs') were added to Unity 2018.3. Nestable prefabs are analogous to "
"Godot's scenes, and allow a more Godot-like approach to scene organisation."
msgstr ""

#: ../../docs/getting_started/editor/unity_to_godot.rst:18
msgid "Differences"
msgstr "차이점"

#: ../../docs/getting_started/editor/unity_to_godot.rst:21
msgid "Unity"
msgstr "Unity"

#: ../../docs/getting_started/editor/unity_to_godot.rst:21
msgid "Godot"
msgstr "Godot"

#: ../../docs/getting_started/editor/unity_to_godot.rst:23
msgid "License"
msgstr "라이선스"

#: ../../docs/getting_started/editor/unity_to_godot.rst:23
msgid ""
"Proprietary, closed, free license with revenue caps and usage restrictions"
msgstr "수익 상한과 사용 제한이 있는 독점적이고 폐쇄적인 무료 라이선스"

#: ../../docs/getting_started/editor/unity_to_godot.rst:23
msgid "MIT license, free and fully open source without any restriction"
msgstr "MIT 라이선스로, 어떤 제한 없이 무료이고 완전한 오픈 소스"

#: ../../docs/getting_started/editor/unity_to_godot.rst:25
msgid "OS (editor)"
msgstr "OS (편집기)"

#: ../../docs/getting_started/editor/unity_to_godot.rst:25
msgid "Windows, macOS, Linux (unofficial and unsupported)"
msgstr "Windows, macOS, Linux (비공식이고 지원되지 않음)"

#: ../../docs/getting_started/editor/unity_to_godot.rst:25
msgid "Windows, macOS, X11 (Linux, \\*BSD)"
msgstr "Windows, macOS, X11 (Linux, \\*BSD)"

#: ../../docs/getting_started/editor/unity_to_godot.rst:27
msgid "OS (export)"
msgstr "OS (내보내기)"

#: ../../docs/getting_started/editor/unity_to_godot.rst:27
msgid "**Desktop:** Windows, macOS, Linux"
msgstr "**데스크톱:** Windows, macOS, Linux"

#: ../../docs/getting_started/editor/unity_to_godot.rst:28
msgid "**Mobile:** Android, iOS, Windows Phone, Tizen"
msgstr "**모바일:** Android, iOS, Windows 폰, Tizen"

#: ../../docs/getting_started/editor/unity_to_godot.rst:29
msgid "**Web:** WebAssembly or asm.js"
msgstr "**웹:** WebAssembly이나 asm.js"

#: ../../docs/getting_started/editor/unity_to_godot.rst:30
msgid "**Consoles:** PS4, PS Vita, Xbox One, Xbox 360, Wii U, Nintendo 3DS"
msgstr "**콘솔:** PS4, PS Vita, Xbox One, Xbox 360, Wii U, Nintendo 3DS"

#: ../../docs/getting_started/editor/unity_to_godot.rst:31
msgid ""
"**VR:** Oculus Rift, SteamVR, Google Cardboard, Playstation VR, Gear VR, "
"HoloLens"
msgstr ""
"**VR:** Oculus Rift, SteamVR, Google Cardboard, Playstation VR, Gear VR, "
"HoloLens"

#: ../../docs/getting_started/editor/unity_to_godot.rst:32
msgid "**TV:** Android TV, Samsung SMART TV, tvOS"
msgstr "**TV:** Android TV, Samsung SMART TV, tvOS"

#: ../../docs/getting_started/editor/unity_to_godot.rst:27
msgid "**Desktop:** Windows, macOS, X11"
msgstr "**데스크톱:** Windows, macOS, X11"

#: ../../docs/getting_started/editor/unity_to_godot.rst:28
msgid "**Mobile:** Android, iOS"
msgstr "**모바일:** Android, iOS"

#: ../../docs/getting_started/editor/unity_to_godot.rst:29
msgid "**Web:** WebAssembly"
msgstr "**웹:** WebAssembly"

#: ../../docs/getting_started/editor/unity_to_godot.rst:30
msgid "**Console:** See :ref:`doc_consoles`"
msgstr "**콘솔:** :ref:`doc_consoles` 을 확인하세요"

#: ../../docs/getting_started/editor/unity_to_godot.rst:31
msgid "**VR:** Oculus Rift, SteamVR"
msgstr "**VR:** Oculus Rift, SteamVR"

#: ../../docs/getting_started/editor/unity_to_godot.rst:34
msgid "Scene system"
msgstr "씬 시스템"

#: ../../docs/getting_started/editor/unity_to_godot.rst:34
msgid "Component/Scene (GameObject > Component)"
msgstr "컴포넌트/씬(GameObject > Component)"

#: ../../docs/getting_started/editor/unity_to_godot.rst:35
msgid "Prefabs"
msgstr "프리펩"

#: ../../docs/getting_started/editor/unity_to_godot.rst:34
msgid ""
":ref:`Scene tree and nodes <doc_scenes_and_nodes>`, allowing scenes to be "
"nested and/or inherit other scenes"
msgstr ""
":ref:`Scene tree and nodes <doc_scenes_and_nodes>`, 씬을 중첩하거나 다른 씬"
"을 상속할 수 있습니다"

#: ../../docs/getting_started/editor/unity_to_godot.rst:37
msgid "Third-party tools"
msgstr "타사 도구"

#: ../../docs/getting_started/editor/unity_to_godot.rst:37
msgid "Visual Studio or VS Code"
msgstr "Visual Studio 혹은 VS Code"

#: ../../docs/getting_started/editor/unity_to_godot.rst:37
msgid ":ref:`External editors are possible <doc_external_editor>`"
msgstr ":ref:`External editors are possible <doc_external_editor>`"

#: ../../docs/getting_started/editor/unity_to_godot.rst:38
msgid ":ref:`Android SDK for Android export <doc_exporting_for_android>`"
msgstr ":ref:`Android SDK for Android export <doc_exporting_for_android>`"

#: ../../docs/getting_started/editor/unity_to_godot.rst:40
#, fuzzy
msgid "Notable advantages"
msgstr "**이점:**"

#: ../../docs/getting_started/editor/unity_to_godot.rst:40
msgid "Huge community"
msgstr "거대한 커뮤니티"

#: ../../docs/getting_started/editor/unity_to_godot.rst:41
msgid "Large assets store"
msgstr "넓은 애셋 스토어"

#: ../../docs/getting_started/editor/unity_to_godot.rst:40
msgid "Scene System"
msgstr "씬 시스템"

#: ../../docs/getting_started/editor/unity_to_godot.rst:41
msgid ":ref:`Animation Pipeline <doc_animations>`"
msgstr ":ref:`애니메이션 파이프라인 <doc_animations>`"

#: ../../docs/getting_started/editor/unity_to_godot.rst:42
msgid ":ref:`Easy to write Shaders <doc_shading_language>`"
msgstr ":ref:`쉽게 셰이더 작성하기 <doc_shading_language>`"

#: ../../docs/getting_started/editor/unity_to_godot.rst:43
msgid "Debug on Device"
msgstr "기기에서 디버그"

#: ../../docs/getting_started/editor/unity_to_godot.rst:50
msgid "The editor"
msgstr "편집기"

#: ../../docs/getting_started/editor/unity_to_godot.rst:52
#, fuzzy
msgid ""
"Godot Engine provides a rich-featured editor that allows you to build your "
"games. The pictures below display the default layouts of both editors with "
"colored blocks to indicate common functionalities."
msgstr ""
"Godot 엔진은 당신이 게임을 만들기 위한 풍부한 기능을 가진 에디터를 제공합니"
"다. 아래의 그림은 두 에디터 간 공통 기능을 표시하는 색칠된 사각형을 보여줍니"
"다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:58
#, fuzzy
msgid ""
"While both editors may seem similar, there are many differences below the "
"surface. Both let you organize the project using the filesystem, but Godot's "
"approach is simpler with a single configuration file, minimalist text "
"format, and no metadata. This makes Godot more friendly to VCS systems, such "
"as Git, Subversion, or Mercurial."
msgstr ""
"두 에디터가 비슷해 보이지만, 외양 아래에 많은 차이가 있습니다. 둘 다 파일 시"
"스템을 사용해서 프로젝트를 조직할 수 있지만, Godot의 접근은 하나의 구성 파"
"일, 미니멀리스트 텍스트 형식, 그리고 메타데이터가 없는 것으로 더 간단합니다. "
"이 모든 것이 Godot가 Git, Subversion, Mercurial와 같은 버전 관리 시스템에 훨"
"씬 더 친숙한 데 기여합니다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:63
#, fuzzy
msgid ""
"Godot's Scene panel is similar to Unity's Hierarchy panel but, as each node "
"has a specific function, the approach used by Godot is more visually "
"descriptive. It's easier to understand what a scene does at a glance."
msgstr ""
"Godot의 씬 패널은 유니티의 계층 패널과 비슷하지만,각 노드는 특정 기능을 갖고 "
"있기 때문에, Godot에서 사용하는 접근은 더 시작적으로 묘사됩니다. 즉, 특정 씬"
"이 한눈에 무엇을 하는지 더 쉽게 이해할 수 있습니다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:67
#, fuzzy
msgid ""
"The Inspector in Godot is more minimal, it shows only properties. Thanks to "
"this, objects can expose more useful parameters to the user without having "
"to hide functionality in language APIs. As a plus, Godot allows animating "
"any of those properties visually. Changing colors, textures, enumerations, "
"or even links to resources in real-time is possible without needing to write "
"code."
msgstr ""
"Godot의 인스펙터는 더 미니멀리스트하고 속성 만을 보여주기 위해 설계되었습니"
"다. 덕분에, 객체는 언어 API에서 기능성을 숨길 필요 없이 훨씬 더 넓은 유용한 "
"매개 변수를 사용자에게 내보낼 수 있습니다. 거기에, Godot는 어떤 시각적 속성"
"도 애니메이트 할 수 있기 때문에, 색상이나 텍스쳐, 열거, 혹은 심지어 리소스 링"
"크를 실시간으로 변경하는 것이 코드 없이 가능합니다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:72
#, fuzzy
msgid ""
"The Toolbar at the top of the screen is similar in both editors, offering "
"control over project playback. Projects in Godot run in a separate window, "
"rather than inside the editor (but the tree and objects can still be "
"explored in the debugger window)."
msgstr ""
"마지막으로, 화면 위의 툴바는 프로젝트 재생을 다루는 의미 상 비슷해 보입니다. "
"하지만 Godot의 프로젝트는 편집기 내부에서 실행되지 않고, 분리된 창에서 실행됩"
"니다 (하지만 디버거 창에서 트리와 객체를 계속 탐구할 수 있습니다)."

#: ../../docs/getting_started/editor/unity_to_godot.rst:76
#, fuzzy
msgid ""
"This approach has the disadvantage that in Godot the running game can't be "
"explored from different angles (though this may be supported in the future "
"and displaying collision gizmos in the running game is already possible), "
"but in exchange has several advantages:"
msgstr ""
"이 접근은 실행 중인 게임을 다른 각도롤 볼 수 없다는 단점이 있습니다 (이 기능"
"을 향후 지원할지도 모르고 실행 중인 게임에 충돌 기즈모를 보여주는 것이 이미 "
"가능합니다), 하지만 그 대가로 몇 가지 이점을 갖습니다:"

#: ../../docs/getting_started/editor/unity_to_godot.rst:80
msgid ""
"Running the project and closing it is fast (Unity has to save, run the "
"project, close the project, and then reload the previous state)."
msgstr ""
"프로젝트를 실행하고 종료하는 것이 빠릅니다 (Unity는 저장하고, 프로젝트를 실행"
"하고, 프로젝트를 종료하고, 그리고 이전 상태를 다시 불러와야 합니다)."

#: ../../docs/getting_started/editor/unity_to_godot.rst:81
msgid ""
"Live editing is a lot more useful because changes done to the editor take "
"effect immediately in the game and are not lost (nor have to be synced) when "
"the game is closed. This allows fantastic workflows, like creating levels "
"while you play them."
msgstr ""
"실시간 편집은 편집기에서 변경한 사항이 게임에 즉시 적용되고 게임을 끌 때 (동"
"기화 할 필요도 없이) 사라지지 않으니 훨씬 더 유용합니다. 이것으로 플레이 도"
"중 레벨을 만드는 등의 환상적인 워크플로가 가능합니다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:82
msgid "The editor is more stable because the game runs in a separate process."
msgstr "게임이 별도의 프로세스에서 실행되기 때문에 편집기는 더 안정적입니다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:84
#, fuzzy
msgid ""
"Finally, Godot's top toolbar includes a menu for remote debugging. These "
"options allow deployment to a device (connected phone, tablet, or browser "
"via HTML5), and debugging/live editing on it after the game is exported."
msgstr ""
"마지막으로, 상단 툴바는 원격 디버깅을 위한 메뉴가 있습니다. 이 설정은 기기에 "
"배포하기 쉽도록 만듭니다 (핸드폰, 태블릿, 혹은 HTML5를 통한 브라우저를 연"
"결), 그리고 게임을 내보낸 후 디버그/실시간 편집을 거기서 하도록 만듭니다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:89
msgid "The scene system"
msgstr "씬 시스템"

#: ../../docs/getting_started/editor/unity_to_godot.rst:91
#, fuzzy
msgid ""
"This is the most important difference between Unity and Godot and the "
"favourite feature of most Godot users."
msgstr ""
"유니티와 Godot와의 가장 중요한 차이점이자, Godot 사용자들이 가장 좋아하는 기"
"능입니다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:93
#, fuzzy
msgid ""
"Working on a 'level' in Unity usually means embedding all the required "
"assets in a scene and linking them together with components and scripts."
msgstr ""
"유니티의 씬 시스템은 필요한 씬에 모든 에셋을 포함하고 구성 요소와 스크립트를 "
"설정함으로써 그들을 연결하도록 구성되어 있습니다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:96
#, fuzzy
msgid ""
"Godot's scene system is superficially similar to Unity. A 'level' consists "
"of a collection of nodes, each with its own purpose: Sprite, Mesh, Light, "
"etc. However, in Godot the nodes are arranged in a tree. Each node can have "
"multiple children, which makes each a subscene of the main scene. This means "
"you can compose a whole scene with different scenes stored in different "
"files."
msgstr ""
"Godot의 씬 시스템은 다릅니다: 사실 노드로 이루어진 트리를 구성하고 있습니다. "
"각 노드는 용도를 지니고 있습니다: 스프라이트, 메시, 빛 등. 기본적으로 유니티"
"의 씬 시스템과 유사합니다. 하지만, 각 노드는 여러 개의 자식을 가질 수 있습니"
"다, 그리고 그 자식들을 각기 다른 하위 씬으로 만들 수 있습니다. 즉, 서로 다른 "
"파일에 저장된 여러 씬으로 전체 씬을 작업할 수 있습니다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:99
msgid ""
"For example, think of a platformer level. You would compose it with multiple "
"elements:"
msgstr ""
"예를 들어, 플랫포머 레벨을 생각해보자. 당신은 여러 요소들을 가지고 작업할 것"
"입니다:"

#: ../../docs/getting_started/editor/unity_to_godot.rst:101
msgid "Bricks"
msgstr "벽돌"

#: ../../docs/getting_started/editor/unity_to_godot.rst:102
msgid "Coins"
msgstr "동전"

#: ../../docs/getting_started/editor/unity_to_godot.rst:103
msgid "The player"
msgstr "플레이어"

#: ../../docs/getting_started/editor/unity_to_godot.rst:104
msgid "The enemies"
msgstr "적"

#: ../../docs/getting_started/editor/unity_to_godot.rst:106
msgid ""
"In Unity, you would put all the GameObjects in the scene: the player, "
"multiple instances of enemies, bricks everywhere to form the ground of the "
"level and then multiple instances of coins all over the level. You would "
"then add various components to each element to link them and add logic in "
"the level: For example, you'd add a BoxCollider2D to all the elements of the "
"scene so that they can collide. This principle is different in Godot."
msgstr ""
"Unity에서, 모든 GameObjects를 씬에 넣을 것입니다: 플레이어, 여러 인스턴스 된 "
"적, 레벨을 만드는 벽돌, 그리고 모든 레벨에 있는 여러 인스턴스 된 동전입니다. "
"그런 다음 각 요소들을 연결하고 레벨의 타당성을 주기 위한 다양한 구성 요소를 "
"추가할 것입니다: 예를 들어 모든 요소에 BoxCollider2D를 추가해서 씬의 모든 요"
"소가 충돌할 수 있도록 합니다. 이 원리가 Godot에서는 다릅니다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:111
#, fuzzy
msgid ""
"In Godot, you would split your whole scene into three separate, smaller "
"scenes, and instance them in the main scene."
msgstr ""
"Godot에서, 전체 씬을 3개의, 더 작은 씬으로 나누고, 그들을 메인 씬에 인스턴스 "
"합니다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:113
#, fuzzy
msgid "**A scene for the Player alone.**"
msgstr "**먼저, 플레이어만 있는 씬입니다.**"

#: ../../docs/getting_started/editor/unity_to_godot.rst:115
#, fuzzy
msgid ""
"Consider the player as an element we'd like to use in different parent "
"scenes (for instance 'level' scenes). In our case, the player element needs "
"at least an AnimatedSprite node. This node contains the sprite textures "
"necessary for various animations (for example, a walking animation)."
msgstr ""
"플레이어를 다른 레벨에도 재 사용 가능한 요소라고 생각해보세요. 특히 하나의 노"
"드로 구성됩니다: 다양한 애니메이션을 구성하기 위한 스프라이트 텍스쳐를 가진 "
"AnimatedSprite 노드 (예를 들면, 걷는 애니메이션)"

#: ../../docs/getting_started/editor/unity_to_godot.rst:117
#, fuzzy
msgid "**A scene for the Enemy.**"
msgstr "**두 번째, 적을 위한 씬입니다.**"

#: ../../docs/getting_started/editor/unity_to_godot.rst:119
#, fuzzy
msgid ""
"An enemy is also an element we'd like to use in several scenes. It's almost "
"the same as the Player node. The only differences are the script (it needs "
"'AI' routines to generate the enemy's behaviour) and the sprite textures "
"used by the AnimatedSprite node."
msgstr ""
"역시, 적은 다른 레벨에서 재 사용 가능합니다. Player 노드와 거의 똑같습니다 - "
"유일한 차이는 스크립트 입니다 (주로 AI를 다룹니다) 그리고 AnimatedSprite가 사"
"용되는 스프라이트 텍스쳐입니다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:123
#, fuzzy
msgid "**A Level scene.**"
msgstr "**마지막으로, 레벨 씬입니다.**"

#: ../../docs/getting_started/editor/unity_to_godot.rst:125
#, fuzzy
msgid ""
"A Level scene is composed of Bricks (for platforms), Coins (for the player "
"to collect) and a number of instances of the Enemy scene. Each instance is a "
"node in the Level scene tree. These instances are separate enemies, which "
"initially have shared behaviour and appearance as defined in the Enemy "
"scene. You can set different properties for each Enemy node (to change its "
"color, for example)."
msgstr ""
"이것은 (플랫폼을 위한)블럭, (플레이어가 집을)동전 그리고 이전의 Enemy 씬의 일"
"정한 수의 인스턴스로 구성되어 있습니다. 이들은 다른, 분리된 적으로, 행동과 양"
"상은 같은 Enemy 씬에서 정의된 것과 같을 것입니다. 각 인스턴스는 이제 레벨 씬 "
"트리의 노드로 취급됩니다. 물론, 각 Enemy 노드 마다 다른 속성을 설정할 수 있습"
"니다 (예를 들어, 색상을 바꾸는 것)."

#: ../../docs/getting_started/editor/unity_to_godot.rst:129
#, fuzzy
msgid ""
"4. **A Main scene.** The Main scene would be composed of one root node with "
"2 children: a Player instance node, and a Level instance node. The root node "
"can be anything, generally a \"root\" type such as \"Node\" which is the "
"most global type, or \"Node2D\" (root type of all 2D-related nodes), "
"\"Spatial\" (root type of all 3D-related nodes) or \"Control\" (root type of "
"all GUI-related nodes)."
msgstr ""
"마지막으로, 메인 씬은 이제 한 루트 노드와 2개의 자식으로 구성될 것입니다: "
"Player 인스턴스 노드, 그리고 레벨 인스턴스 노드입니다. 루트 노드는 어떤 것도 "
"될 수 있지만, 일반적으로 \"루트\" 타입은 가장 전역 타입인 \"Node\"나, (모든 "
"2D 관련 노드의 루트 타입인) \"Node2D\", (모든 3D 관련 노드의 루트 타입인) "
"\"Spatial\", (모든 GUI 관련 노드의 루트 타입인) \"Control\"이 됩니다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:135
msgid ""
"As you can see, every scene is organized as a tree. The same goes for nodes' "
"properties: you don't *add* a collision component to a node to make it "
"collidable like Unity does. Instead, you make this node a *child* of a new "
"specific node that has collision properties. Godot features various "
"collision types nodes, depending on the usage (see the :ref:`Physics "
"introduction <doc_physics_introduction>`)."
msgstr ""
"보시다시피, 모든 씬이 트리로 조직됩니다. 노드의 속성도 동일합니다: Unity처럼 "
"노드가 충돌 가능하도록 충돌 구성 요소를 *추가* 할 수는 없습니다. 대신 충돌 속"
"성을 가진 새로운 특정 노드를 *자식* 으로 만들 수 있습니다. Godot는 사용법에 "
"따른 다양한 충돌 타입 노드가 있습니다 (:ref:`물리 소개 "
"<doc_physics_introduction>`\\ 를 참고하세요)."

#: ../../docs/getting_started/editor/unity_to_godot.rst:140
#, fuzzy
msgid ""
"What are the advantages of this system? Wouldn't this system potentially "
"increase the depth of the scene tree? And doesn't Unity already allow you to "
"organize GameObjects by putting them inside empty GameObjects?"
msgstr ""
"문제: 이 시스템의 장점은 무엇일까요? 이 시스템이 잠재적으로 씬 트리의 깊이를 "
"증가시키지 않을까요? 게다가, 유니티는 비어있는 GameObjects에 그들을 넣어서 "
"GameObjects를 조직할 수 있습니다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:142
#, fuzzy
msgid ""
"Godot's system is closer to the well-known object-oriented paradigm: Godot "
"provides a number of nodes which are not clearly \"Game Objects\", but they "
"provide their children with their own capabilities: this is inheritance."
msgstr ""
"먼저, 이 시스템은 잘 알려진 객체 기반 어형 변화표와 근접합니다: Godot는 분명"
"하지 않은 \"Game Objects\"인 여러 노드들을 제공합니다, 하지만 그들은 자식에"
"게 자신의 능력을 제공합니다: 이것이 상속입니다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:143
#, fuzzy
msgid ""
"Godot allows the extraction of a subtree of a scene to make it a scene of "
"its own. So if a scene tree gets too deep, it can be split into smaller "
"subtrees. This is better for reusability, as you can include any subtree as "
"a child of any node. Putting multiple GameObjects in an empty GameObject in "
"Unity does not provide the same functionality."
msgstr ""
"두 번째로, 씬의 하위 트리를 추출하여 고유의 씬을 만들 수 있습니다, 이걸로 두 "
"번째와 세 번째 문제에 답할 수 있습니다: 비록 씬 트리가 너무 깊어지더라도, 더 "
"작은 하위 트리로 나눌 수 있습니다. 또한 하위 트리가 어떤 노드의 자식이든지 추"
"가될 수 있다는 점에서 재 사용 가능성에 더 좋은 해결책이 됩니다. 유니티에서 "
"빈 GameObject에 많은 노드를 넣는 것으로는 시각적인 조직과는 별개로, 이와 같"
"은 가능성을 제공하진 못합니다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:146
msgid "Project organization"
msgstr "프로젝트 조직"

#: ../../docs/getting_started/editor/unity_to_godot.rst:150
msgid ""
"There is no perfect project architecture. Any architecture can be made to "
"work in either Unity and Godot."
msgstr ""

#: ../../docs/getting_started/editor/unity_to_godot.rst:153
#, fuzzy
msgid ""
"However, a common architecture for Unity projects is to have one Assets "
"folder in the root directory that contains various folders, one per type of "
"asset: Audio, Graphics, Models, Materials, Scripts, Scenes, and so on."
msgstr ""
"하지만, 우리는 종종 유니티 프로젝트를 위한 공통 구조를 발견합니다, 하나의 "
"Assets 폴더가 루트 디렉토리로 하여 타입에 맞는 다양한 폴더를 가지고 있습니"
"다: Audio, Graphics, Models, Materials, Scripts, Scenes 등."

#: ../../docs/getting_started/editor/unity_to_godot.rst:156
#, fuzzy
msgid ""
"Since Godot allows splitting scenes into smaller scenes, each scene and "
"subscene existing as a file in the project, we recommend organizing your "
"project a bit differently. This wiki provides a page for this: :ref:"
"`doc_project_organization`."
msgstr ""
"앞에서 설명한 것처럼, Godot 씬 시스템은 씬을 더 작은 씬으로 분리합니다. 각 씬"
"과 하위 씬은 사실 프로젝트에서 하나의 씬 파일이기 때문에, 우리는 프로젝트를 "
"약간 다르게 구성하기를 추천합니다. 이 위키는 이것을 위한 페이지를 제공합니"
"다: :ref:`doc_project_organization`."

#: ../../docs/getting_started/editor/unity_to_godot.rst:161
msgid "Where are my prefabs?"
msgstr "프리펩은 어디갔나요?"

#: ../../docs/getting_started/editor/unity_to_godot.rst:163
#, fuzzy
msgid ""
"A prefab as provided by Unity is a 'template' element of the scene. It is "
"reusable, and each instance of the prefab that exists in the scene has an "
"existence of its own, but all of them have the same properties as defined by "
"the prefab."
msgstr ""
"유니티가 제공하는 프리펩의 개념은 씬의 '템플릿' 요소입니다. 그것은 씬에 존재"
"하는 재 사용이 가능하며 씬에 존재하는 프리펩의 각 인스턴스는 주체성이 있지"
"만, 이 모두는 프리펩에 의해 정의된 같은 속성을 지닙니다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:167
#, fuzzy
msgid ""
"Godot does not provide prefabs as such, but the same functionality is "
"provided by its scene system: The scene system is organized as a tree. Godot "
"allows you to save any subtree of a scene as a scene file. This new scene "
"can then be instanced as many times as you want, as a child of any node. Any "
"change you make to this new, separate scene will be applied to its "
"instances. However, any change you make to the instance will not have any "
"impact on the 'template' scene."
msgstr ""
"Godot는 그러한 프리펩을 제공하진 않지만, 씬 시스템 덕분에 그 기능이 있습니"
"다: 우리가 씬 시스템이 트리처럼 조직된 것을 보셨습니다. Godot는 씬의 하위 트"
"리를 자체 씬으로 저장하여 자체 파일로 저장합니다. 이 새로운 씬은 그 뒤 원하"
"는 만큼 인스턴스 될 수 있습니다. 이 새로운 씬에 준 변화는 모든 인스턴스에 적"
"용될 것입니다. 하지만 그 변화가 '템플릿' 씬에 영향을 주지는 않을 것입니다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:174
#, fuzzy
msgid ""
"To be precise, you can modify the parameters of an instance in the Inspector "
"panel. The nodes that compose this instance are initially locked. You can "
"unlock them if you need to by right-clicking the instance in the Scene tree "
"and selecting \"Editable children\" in the menu. You don't need to do this "
"to add *new* child nodes to this node. Remember that any new children will "
"belong to the instance, not to the 'template' scene on disk. If you want to "
"add new children to every instance of your 'template' scene, then you should "
"add them in the 'template' scene."
msgstr ""
"정확하게 말하면, 당신은 인스펙터 패널에서 인스턴스의 매개 변수를 수정할 수 있"
"습니다. 하지만, 비록 당신이 씬 트리에서 인스턴스를 우클릭하고 \"자식노드 편"
"집 가능\"를 선택하여 인스턴스를 잠금 해제할 수 있지만 이 인스턴스를 만드는 노"
"드는 잠겨있습니다. 새 자식 노드를 추가하려고 이 작업을 할 필요는 없지만 가능"
"은 합니다. 새 자식 은 인스턴스에 속해 있습니다, '템플릿' 씬이 아닙니다. '템플"
"릿' 씬의 모든 인스턴스에 새 자식을 추가하려면, '템플릿' 씬에 새 자식을 추가해"
"야 합니다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:184
msgid "Glossary correspondence"
msgstr "어휘 일치"

#: ../../docs/getting_started/editor/unity_to_godot.rst:186
msgid "GameObject -> Node"
msgstr "GameObject -> 노드"

#: ../../docs/getting_started/editor/unity_to_godot.rst:187
msgid "Add a component -> Inheriting"
msgstr "컴포넌트 추가 -> 상속"

#: ../../docs/getting_started/editor/unity_to_godot.rst:188
msgid "Prefab -> Reusable Scene file"
msgstr ""

#: ../../docs/getting_started/editor/unity_to_godot.rst:192
msgid "Scripting: GDScript, C# and Visual Script"
msgstr "스크립팅: GDScript, C# and Visual Script"

#: ../../docs/getting_started/editor/unity_to_godot.rst:195
msgid "Design"
msgstr "디자인"

#: ../../docs/getting_started/editor/unity_to_godot.rst:197
#, fuzzy
msgid ""
"Unity supports C#. C# benefits from its integration with Visual Studio and "
"has desirable features such as static typing."
msgstr ""
"이미 알고 계시겠지만, Unity는 C#을 지원합니다. C#은 Visual Studio 및 정적 타"
"입과 같은 다른 기능과의 통합을 통해 이익을 얻습니다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:199
#, fuzzy
msgid ""
"Godot provides its own scripting language, :ref:`GDScript <doc_scripting>` "
"as well as support for :ref:`Visual Script <toc-learn-scripting-"
"visual_script>` and :ref:`C# <doc_c_sharp>`. GDScript borrows its syntax "
"from Python, but is not related to it. If you wonder about the reasoning for "
"a custom scripting language, please read the :ref:`doc_gdscript` and :ref:"
"`doc_faq` pages. GDScript is strongly attached to the Godot API and doesn't "
"take long to learn: Between one evening for an experienced programmer and a "
"week for a complete beginner."
msgstr ""
"Godot는 독자적인 스크립트 언어를 제공합니다, :ref:`GDScript <doc_scripting>`"
"\\ 와 :ref:`Visual Script <toc-learn-scripting-visual_script>`, 그리고 :ref:"
"`doc_c_sharp`\\ 을 지원합니다. GDScript는 Python의 문법을 빌려오지만, 관련은 "
"없습니다. 커스텀 스크립트 언어를 쓰는 이유가 궁금하시다면, :ref:"
"`doc_gdscript`\\ 와 :ref:`doc_faq`\\ 페이지를 읽어주시기 바랍니다. GDScript"
"는 Godot API와 밀접하고 배우기 쉽습니다: 숙련된 프로그래머든지 막 개발을 시작"
"한 사람이든지 말입니다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:205
msgid ""
"Unity allows you to attach as many scripts as you want to a GameObject. Each "
"script adds a behaviour to the GameObject: For example, you can attach a "
"script so that it reacts to the player's controls, and another that controls "
"its specific game logic."
msgstr ""
"Unity는 GameObject에 원하는 만큼의 스크립트를 붙일 수 있습니다. 각 스크립트"
"는 GameObject에 행동을 추가합니다: 예를 들어 스크립트를 붙여서 플레이어의 조"
"작이나 특정 게임을 조작하는 다른 것을 넣을 수 있습니다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:209
msgid ""
"In Godot, you can only attach one script per node. You can use either an "
"external GDScript file or include the script directly in the node. If you "
"need to attach more scripts to one node, then you may consider two "
"solutions, depending on your scene and on what you want to achieve:"
msgstr ""
"Godot에서, 우리는 각 노드에 하나의 스크립트만 붙일 수 있습니다. 외부 "
"GDScript 파일이나 노드에 스크립트를 직접 넣어서 사용할 수 있습니다. 한 노드"
"에 더 많은 스크립트를 붙이고 싶다면, 씬이랑 원하는 것을 얻기 위해, 두 가지 방"
"안을 고려하셔야 합니다:"

#: ../../docs/getting_started/editor/unity_to_godot.rst:213
msgid ""
"either add a new node between your target node and its current parent, then "
"add a script to this new node."
msgstr ""
"대상 노드와 현재 부모 노드 사이에 새 노드를 추가 한 다음, 이 노드에 스크립트"
"를 추가합니다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:214
msgid ""
"or, you can split your target node into multiple children and attach one "
"script to each of them."
msgstr ""
"또는, 대상 노드를 여러 자식 노드로 분할하고 각각마다 하나의 스크립트를 붙일 "
"수 있습니다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:216
#, fuzzy
msgid ""
"As you can see, it can be easy to turn a scene tree to a mess. Consider "
"splitting any complicated scene into multiple, smaller branches."
msgstr ""
"보시다시피 씬 트리를 뒤죽박죽으로 만드는 것은 쉽습니다. 그렇기 때문에 실제 상"
"황을 반영하고 복잡한 씬을 여러 개의 작은 분기로 나누는 것이 중요합니다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:219
msgid "Connections: groups and signals"
msgstr "연결: 그룹과 시그널"

#: ../../docs/getting_started/editor/unity_to_godot.rst:221
msgid ""
"You can control nodes by accessing them via script and calling built-in or "
"user-defined functions on them. You can also place nodes in a group and call "
"functions on all nodes in this group. See more in the :ref:`scripting "
"documentation <doc_scripting_continued>`."
msgstr ""
"스크립트를 통해 노드에 액세스하고 노드에서 내장 함수나 사용자가 정의한 함수"
"를 호출하여 노드를 제어할 수 있습니다. 그리고 노드를 그룹에 배치하거나 이 그"
"룹에 있는 모든 노드에서 함수를 호출할 수도 있습니다. 자세한 것은 :ref:`스크립"
"팅 문서 <doc_scripting_continued>`\\ 를 참고하세요."

#: ../../docs/getting_started/editor/unity_to_godot.rst:226
msgid ""
"Nodes can send a signal when a specified action occurs. A signal can be set "
"to call any function. You can define custom signals and specify when they "
"are triggered. See more in the :ref:`signals documentation "
"<doc_gdscript_signals>`."
msgstr ""
"노드는 특정 동작이 발생할 때 시그널을 보냅니다. 시그널은 함수를 호출하도록 설"
"정될 수 있습니다. 커스텀 시그널을 정의하고 언제 시그널을 보낼 지를 지정할 수 "
"있습니다. 자세한 설명은 :ref:`시그널 문서 <doc_gdscript_signals>`\\ 를 참고하"
"세요."

#: ../../docs/getting_started/editor/unity_to_godot.rst:231
msgid "Script serialization"
msgstr "스크립트 직렬화"

#: ../../docs/getting_started/editor/unity_to_godot.rst:233
msgid "Unity can handle script serialization in two ways:"
msgstr "Unity는 두 가지 방법으로 스크립트 직렬화를 다룰 수 있습니다:"

#: ../../docs/getting_started/editor/unity_to_godot.rst:235
msgid ""
"Implicit: All public fields in a class are automatically serialized if the "
"type is a serializable type (``Dictionary`` is not serializable)."
msgstr ""
"Implicit(암시적):  한 클래스의 모든 퍼블릭 필드가 직렬화 할 수 있는 타입이면 "
"(``Dictionary``\\ 는 직렬화 할 수 없음) 자동으로 직렬화 됩니다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:236
msgid ""
"Explicit: Non-public fields can be serialized using the ``[SerializeField]`` "
"attribute."
msgstr ""
"Explicit(명시적): 비 퍼블릭 필드를 ``[SerializeField]`` 속성을 사용하여 직렬"
"화 되도록 할 수 있습니다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:238
msgid ""
"Godot also has a built-in script serialization system, but it works only "
"explicitly. You can serialize any serializable type (:ref:`built-in and "
"various engine types <doc_binary_serialization_api>`, including :ref:"
"`class_Array` and :ref:`class_Dictionary`) using the ``export`` keyword. See "
"the :ref:`exports documentation <doc_gdscript_exports>` for details."
msgstr ""
"Godot 또한 내장 스크립트 직렬화 시스템을 갖추고 있지만, 오직 명시적으로만 작"
"동합니다. 어떤 직렬화 가능한 타입이라도 (:ref:`class_Array`\\ 와 :ref:"
"`class_Dictionary`\\ 를 포함한, :ref:`내장 그리고 다양한 엔진 타입 "
"<doc_binary_serialization_api>`) ``export`` 키워드를 사용해 직렬화 할 수 있습"
"니다. 자세한 설명은 :ref:`내보내기 문서 <doc_gdscript_exports>`\\ 를 참고하세"
"요."

#: ../../docs/getting_started/editor/unity_to_godot.rst:243
msgid ""
"Unity also has a data type called ``ScriptableObject`` used to serialize "
"custom asset objects. Its equivalent in Godot is the base class for all "
"resources: :ref:`class_Resource`. Creating a script that inherits :ref:"
"`class_Resource` will allow you to create custom serializable objects. More "
"information about resources can be found :ref:`here <doc_resources>`."
msgstr ""
"Unity 또한 커스텀 애셋 객체를 직렬화 하기 위해 사용되는 ``ScriptableObject`` "
"라는 데이터 타입을 갖고 있습니다. Godot에서 이것은 모든 리소스의 기본 클래스"
"에 해당합니다: :ref:`class_Resource`. :ref:`class_Resource`\\ 를 상속하는 스"
"크립트를 만드는 것으로 커스텀 직렬화 가능한 객체를 만들 수 있게 됩니다. 리소"
"스에 관한 더 많은 정보는 :ref:`여기서 <doc_resources>` 볼 수 있습니다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:248
msgid "Using Godot in C++"
msgstr "C++로 Godot 사용하기"

#: ../../docs/getting_started/editor/unity_to_godot.rst:250
msgid ""
"Godot allows you to develop your project directly in C++ by using its API, "
"which is not possible with Unity at the moment. As an example, you can "
"consider Godot Engine's editor as a \"game\" written in C++ using the Godot "
"API."
msgstr ""
"Godot는 API를 사용하여 C++로 프로젝트를 직접 개발할 수 있게 해줍니다, 이는 현"
"재 Unity에서는 불가능합니다. 예를 들어 Godot 엔진의 편집기를 Godot API를 사용"
"하는 C++로 작성된 \"게임\"으로 간주할 수 있습니다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:253
msgid ""
"If you are interested in using Godot in C++, you may want to start reading "
"the :ref:`Developing in C++ <doc_introduction_to_godot_development>` page."
msgstr ""
"C++로 Godot를 사용하는 것에 관심이 있으시다면, :ref:`C++로 개발하기 "
"<doc_introduction_to_godot_development>` 페이지를 읽고 시작하시면 됩니다."
