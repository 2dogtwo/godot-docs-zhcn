# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2019, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-01-20 15:59+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../docs/getting_started/editor/unity_to_godot.rst:8
msgid "From Unity to Godot Engine"
msgstr "Unity에서 Godot 엔진까지"

#: ../../docs/getting_started/editor/unity_to_godot.rst:10
msgid ""
"This guide provides an overview of Godot Engine from the viewpoint of a "
"Unity user, and aims to help you migrate your existing Unity experience into "
"the world of Godot."
msgstr ""
"이 가이드는 Unity 사용자의 관점에서 Godot 엔진의 개요를 제공합니다, 그리고 존"
"재하는 Unity 경험을 Godot라는 세상에 옮기도록 돕는 것에 중점을 둡니다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:15
msgid ""
"This article talks about older versions of Unity. Nestable prefabs ('Nested "
"prefabs') were added to Unity 2018.3. Nestable prefabs are analogous to "
"Godot's scenes, and allow a more Godot-like approach to scene organisation."
msgstr ""
"이 문서는 예전 버전의 Unity에 대해 말하고 있습니다. 중첩할 수 있는 프리펩('중"
"첩된 프리펩')은 Unity 2018.3에 추가되었습니다. 중첩할 수 있는 프리펩은 Godot"
"의 씬과 유사합니다. 그리고 Godot와 유사하게 씬 조직으로 접근할 수 있습니다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:18
msgid "Differences"
msgstr "차이점"

#: ../../docs/getting_started/editor/unity_to_godot.rst:21
msgid "Unity"
msgstr "Unity"

#: ../../docs/getting_started/editor/unity_to_godot.rst:21
msgid "Godot"
msgstr "Godot"

#: ../../docs/getting_started/editor/unity_to_godot.rst:23
msgid "License"
msgstr "라이선스"

#: ../../docs/getting_started/editor/unity_to_godot.rst:23
msgid ""
"Proprietary, closed, free license with revenue caps and usage restrictions"
msgstr "수익 상한과 사용 제한이 있는 독점적이고 폐쇄적인 무료 라이선스"

#: ../../docs/getting_started/editor/unity_to_godot.rst:23
msgid "MIT license, free and fully open source without any restriction"
msgstr "MIT 라이선스로, 어떤 제한 없이 무료이고 완전한 오픈 소스"

#: ../../docs/getting_started/editor/unity_to_godot.rst:25
msgid "OS (editor)"
msgstr "OS (편집기)"

#: ../../docs/getting_started/editor/unity_to_godot.rst:25
msgid "Windows, macOS, Linux (unofficial and unsupported)"
msgstr "Windows, macOS, Linux (비공식이고 지원되지 않음)"

#: ../../docs/getting_started/editor/unity_to_godot.rst:25
msgid "Windows, macOS, X11 (Linux, \\*BSD)"
msgstr "Windows, macOS, X11 (Linux, \\*BSD)"

#: ../../docs/getting_started/editor/unity_to_godot.rst:27
msgid "OS (export)"
msgstr "OS (내보내기)"

#: ../../docs/getting_started/editor/unity_to_godot.rst:27
msgid "**Desktop:** Windows, macOS, Linux"
msgstr "**데스크톱:** Windows, macOS, Linux"

#: ../../docs/getting_started/editor/unity_to_godot.rst:28
msgid "**Mobile:** Android, iOS, Windows Phone, Tizen"
msgstr "**모바일:** Android, iOS, Windows 폰, Tizen"

#: ../../docs/getting_started/editor/unity_to_godot.rst:29
msgid "**Web:** WebAssembly or asm.js"
msgstr "**웹:** WebAssembly이나 asm.js"

#: ../../docs/getting_started/editor/unity_to_godot.rst:30
msgid "**Consoles:** PS4, PS Vita, Xbox One, Xbox 360, Wii U, Nintendo 3DS"
msgstr "**콘솔:** PS4, PS Vita, Xbox One, Xbox 360, Wii U, Nintendo 3DS"

#: ../../docs/getting_started/editor/unity_to_godot.rst:31
msgid ""
"**VR:** Oculus Rift, SteamVR, Google Cardboard, Playstation VR, Gear VR, "
"HoloLens"
msgstr ""
"**VR:** Oculus Rift, SteamVR, Google Cardboard, Playstation VR, Gear VR, "
"HoloLens"

#: ../../docs/getting_started/editor/unity_to_godot.rst:32
msgid "**TV:** Android TV, Samsung SMART TV, tvOS"
msgstr "**TV:** Android TV, Samsung SMART TV, tvOS"

#: ../../docs/getting_started/editor/unity_to_godot.rst:27
msgid "**Desktop:** Windows, macOS, X11"
msgstr "**데스크톱:** Windows, macOS, X11"

#: ../../docs/getting_started/editor/unity_to_godot.rst:28
msgid "**Mobile:** Android, iOS"
msgstr "**모바일:** Android, iOS"

#: ../../docs/getting_started/editor/unity_to_godot.rst:29
msgid "**Web:** WebAssembly"
msgstr "**웹:** WebAssembly"

#: ../../docs/getting_started/editor/unity_to_godot.rst:30
msgid "**Console:** See :ref:`doc_consoles`"
msgstr "**콘솔:** :ref:`doc_consoles` 을 확인하세요"

#: ../../docs/getting_started/editor/unity_to_godot.rst:31
msgid "**VR:** Oculus Rift, SteamVR"
msgstr "**VR:** Oculus Rift, SteamVR"

#: ../../docs/getting_started/editor/unity_to_godot.rst:34
msgid "Scene system"
msgstr "씬 시스템"

#: ../../docs/getting_started/editor/unity_to_godot.rst:34
msgid "Component/Scene (GameObject > Component)"
msgstr "컴포넌트/씬(GameObject > Component)"

#: ../../docs/getting_started/editor/unity_to_godot.rst:35
msgid "Prefabs"
msgstr "프리펩"

#: ../../docs/getting_started/editor/unity_to_godot.rst:34
msgid ""
":ref:`Scene tree and nodes <doc_scenes_and_nodes>`, allowing scenes to be "
"nested and/or inherit other scenes"
msgstr ""
":ref:`Scene tree and nodes <doc_scenes_and_nodes>`, 씬을 중첩하거나 다른 씬"
"을 상속할 수 있습니다"

#: ../../docs/getting_started/editor/unity_to_godot.rst:37
msgid "Third-party tools"
msgstr "타사 도구"

#: ../../docs/getting_started/editor/unity_to_godot.rst:37
msgid "Visual Studio or VS Code"
msgstr "Visual Studio 혹은 VS Code"

#: ../../docs/getting_started/editor/unity_to_godot.rst:37
msgid ":ref:`External editors are possible <doc_external_editor>`"
msgstr ":ref:`External editors are possible <doc_external_editor>`"

#: ../../docs/getting_started/editor/unity_to_godot.rst:38
msgid ":ref:`Android SDK for Android export <doc_exporting_for_android>`"
msgstr ":ref:`Android SDK for Android export <doc_exporting_for_android>`"

#: ../../docs/getting_started/editor/unity_to_godot.rst:40
msgid "Notable advantages"
msgstr "**주목할만한 이점:**"

#: ../../docs/getting_started/editor/unity_to_godot.rst:40
msgid "Huge community"
msgstr "거대한 커뮤니티"

#: ../../docs/getting_started/editor/unity_to_godot.rst:41
msgid "Large assets store"
msgstr "넓은 애셋 스토어"

#: ../../docs/getting_started/editor/unity_to_godot.rst:40
msgid "Scene System"
msgstr "씬 시스템"

#: ../../docs/getting_started/editor/unity_to_godot.rst:41
msgid ":ref:`Animation Pipeline <doc_animations>`"
msgstr ":ref:`애니메이션 파이프라인 <doc_animations>`"

#: ../../docs/getting_started/editor/unity_to_godot.rst:42
msgid ":ref:`Easy to write Shaders <doc_shading_language>`"
msgstr ":ref:`쉽게 셰이더 작성하기 <doc_shading_language>`"

#: ../../docs/getting_started/editor/unity_to_godot.rst:43
msgid "Debug on Device"
msgstr "기기에서 디버그"

#: ../../docs/getting_started/editor/unity_to_godot.rst:50
msgid "The editor"
msgstr "편집기"

#: ../../docs/getting_started/editor/unity_to_godot.rst:52
msgid ""
"Godot Engine provides a rich-featured editor that allows you to build your "
"games. The pictures below display the default layouts of both editors with "
"colored blocks to indicate common functionalities."
msgstr ""
"Godot 엔진은 게임을 제작하기 위한 풍부한 기능을 가진 편집기를 제공합니다. 밑"
"의 사진은 두 편집기의 기본 레이아웃을 보여줍니다. 같은 기능에는 같은 색으로 "
"된 블록으로 표시했습니다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:58
msgid ""
"While both editors may seem similar, there are many differences below the "
"surface. Both let you organize the project using the filesystem, but Godot's "
"approach is simpler with a single configuration file, minimalist text "
"format, and no metadata. This makes Godot more friendly to VCS systems, such "
"as Git, Subversion, or Mercurial."
msgstr ""
"두 편집기 모두 비슷해 보이지만, 내부를 보면 많은 차이점이 있습니다. 두 편집"
"기 모두 파일 시스템으로 프로젝트를 조직할 수 있게 해줍니다. 하지만 Godot의 접"
"근법은 더 간단합니다. 하나의 구성 파일, 최대한 간략하게 만든 문자 형식, 그리"
"고 메타데이터가 없죠. 이 점이 Godot를 Git, Subversion, Mercurial과 같은 버전 "
"관리 시스템(VCS)에 더 친근하게 만들어줍니다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:63
msgid ""
"Godot's Scene panel is similar to Unity's Hierarchy panel but, as each node "
"has a specific function, the approach used by Godot is more visually "
"descriptive. It's easier to understand what a scene does at a glance."
msgstr ""
"Godot의 씬 패널은 Unity의 계층 구조 패널과 유사합니다. 하지만 각 노드가 특정 "
"기능을 갖고 있는 Godot의 특성 상, 이 접근법은 Godot에서 더 시각적으로 이해하"
"기 좋습니다. 씬이 어떤 일을 하는 지 한눈에 이해하기가 더 쉽다는 뜻입니다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:67
msgid ""
"The Inspector in Godot is more minimal, it shows only properties. Thanks to "
"this, objects can expose more useful parameters to the user without having "
"to hide functionality in language APIs. As a plus, Godot allows animating "
"any of those properties visually. Changing colors, textures, enumerations, "
"or even links to resources in real-time is possible without needing to write "
"code."
msgstr ""
"Godot의 인스펙터(Inspector)는 더 간략합니다. 오직 속성만 보여주죠. 덕분에 객"
"체는 언어 API에서 기능을 숨길 필요없이 더 유용한 매개변수를 사용자에게 보여"
"줄 수 있습니다. 게다가 Godot는 모든 속성을 시각적으로 애니메이션을 줄 수 있습"
"니다. 색상을 바꾸거나, 텍스처, 열거, 심지어 리소스에 연결하는 것도 코드를 작"
"성할 필요없이 실시간으로 가능합니다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:72
msgid ""
"The Toolbar at the top of the screen is similar in both editors, offering "
"control over project playback. Projects in Godot run in a separate window, "
"rather than inside the editor (but the tree and objects can still be "
"explored in the debugger window)."
msgstr ""
"화면 상단의 툴바는 두 편집기 모두 유사합니다. 프로젝트 실행을 제어합니다. "
"Godot에서는 프로젝트가 편집기 내에서가 아닌 별개의 창에서 실행됩니다 (하지만 "
"트리와 객체는 디버거 창에서 탐색할 수 있습니다)."

#: ../../docs/getting_started/editor/unity_to_godot.rst:76
msgid ""
"This approach has the disadvantage that in Godot the running game can't be "
"explored from different angles (though this may be supported in the future "
"and displaying collision gizmos in the running game is already possible), "
"but in exchange has several advantages:"
msgstr ""
"이 접근은 실행 중인 게임을 다른 각도롤 볼 수 없다는 단점이 있습니다 (이 기능"
"을 향후 지원할지도 모르고 실행 중인 게임에 충돌 기즈모를 보여주는 것이 이미 "
"가능합니다), 하지만 그 대가로 몇 가지 이점을 갖습니다:"

#: ../../docs/getting_started/editor/unity_to_godot.rst:80
msgid ""
"Running the project and closing it is fast (Unity has to save, run the "
"project, close the project, and then reload the previous state)."
msgstr ""
"프로젝트를 실행하고 종료하는 것이 빠릅니다 (Unity는 저장하고, 프로젝트를 실행"
"하고, 프로젝트를 종료하고, 그리고 이전 상태를 다시 불러와야 합니다)."

#: ../../docs/getting_started/editor/unity_to_godot.rst:81
msgid ""
"Live editing is a lot more useful because changes done to the editor take "
"effect immediately in the game and are not lost (nor have to be synced) when "
"the game is closed. This allows fantastic workflows, like creating levels "
"while you play them."
msgstr ""
"실시간 편집은 편집기에서 변경한 사항이 게임에 즉시 적용되고 게임을 끌 때 (동"
"기화 할 필요도 없이) 사라지지 않으니 훨씬 더 유용합니다. 이것으로 플레이 도"
"중 레벨을 만드는 등의 환상적인 워크플로가 가능합니다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:82
msgid "The editor is more stable because the game runs in a separate process."
msgstr "게임이 별도의 프로세스에서 실행되기 때문에 편집기는 더 안정적입니다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:84
msgid ""
"Finally, Godot's top toolbar includes a menu for remote debugging. These "
"options allow deployment to a device (connected phone, tablet, or browser "
"via HTML5), and debugging/live editing on it after the game is exported."
msgstr ""
"마지막으로 Godot의 상단 툴바에는 원격 디버그를 위한 메뉴가 있습니다. 이 설정"
"으로 (폰, 태블릿에 연결된, 혹은 HTML5를 통한 브라우저와 같은) 기기 환경에서 "
"개발을 할 수 있습니다. 그리고 게임을 내보낸 후 디버깅/실시간 편집이 가능합니"
"다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:89
msgid "The scene system"
msgstr "씬 시스템"

#: ../../docs/getting_started/editor/unity_to_godot.rst:91
msgid ""
"This is the most important difference between Unity and Godot and the "
"favourite feature of most Godot users."
msgstr ""
"Unity와 Godot의 가장 큰 차이점이자 Godot 사용자가 가장 좋아하는 기능입니다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:93
msgid ""
"Working on a 'level' in Unity usually means embedding all the required "
"assets in a scene and linking them together with components and scripts."
msgstr ""
"Unity에서 'Level'에서 작업한다는 것은 보통 모든 필요한 에셋을 한 씬에 묶고, "
"구성 요소와 스크립트로 함께 연결하는 것을 의미합니다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:96
msgid ""
"Godot's scene system is superficially similar to Unity. A 'level' consists "
"of a collection of nodes, each with its own purpose: Sprite, Mesh, Light, "
"etc. However, in Godot the nodes are arranged in a tree. Each node can have "
"multiple children, which makes each a subscene of the main scene. This means "
"you can compose a whole scene with different scenes stored in different "
"files."
msgstr ""
"Godot의 씬 시스템은 Unity와 겉으로는 유사합니다. 'Level'은 노드 모음을 갖고 "
"있으면서, 각 노드는 용도를 지니고 있습니다: Sprite, Mesh, Light 등. 하지만 "
"Godot에서 노드는 트리로 정렬할 수 있습니다. 각 노드는 여러 자식을 가질 수 있"
"고, 자식은 메인 씬의 하위 씬으로 이루어질 수 있습니다. 이는 즉, 다른 파일에 "
"저장된 다른 씬으로 전체 씬을 작업할 수 있다는 것입니다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:99
msgid ""
"For example, think of a platformer level. You would compose it with multiple "
"elements:"
msgstr ""
"예를 들어, 플랫포머 레벨을 생각해보자. 당신은 여러 요소들을 가지고 작업할 것"
"입니다:"

#: ../../docs/getting_started/editor/unity_to_godot.rst:101
msgid "Bricks"
msgstr "벽돌"

#: ../../docs/getting_started/editor/unity_to_godot.rst:102
msgid "Coins"
msgstr "동전"

#: ../../docs/getting_started/editor/unity_to_godot.rst:103
msgid "The player"
msgstr "플레이어"

#: ../../docs/getting_started/editor/unity_to_godot.rst:104
msgid "The enemies"
msgstr "적"

#: ../../docs/getting_started/editor/unity_to_godot.rst:106
msgid ""
"In Unity, you would put all the GameObjects in the scene: the player, "
"multiple instances of enemies, bricks everywhere to form the ground of the "
"level and then multiple instances of coins all over the level. You would "
"then add various components to each element to link them and add logic in "
"the level: For example, you'd add a BoxCollider2D to all the elements of the "
"scene so that they can collide. This principle is different in Godot."
msgstr ""
"Unity에서, 모든 GameObjects를 씬에 넣을 것입니다: 플레이어, 여러 인스턴스 된 "
"적, 레벨을 만드는 벽돌, 그리고 모든 레벨에 있는 여러 인스턴스 된 동전입니다. "
"그런 다음 각 요소들을 연결하고 레벨의 타당성을 주기 위한 다양한 구성 요소를 "
"추가할 것입니다: 예를 들어 모든 요소에 BoxCollider2D를 추가해서 씬의 모든 요"
"소가 충돌할 수 있도록 합니다. 이 원리가 Godot에서는 다릅니다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:111
msgid ""
"In Godot, you would split your whole scene into three separate, smaller "
"scenes, and instance them in the main scene."
msgstr ""
"Godot에서는 전체 씬을 별개의, 더 작은 세 개의 씬으로 나눕니다. 그리고 메인 씬"
"으로 그 씬들을 인스턴스합니다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:113
msgid "**A scene for the Player alone.**"
msgstr "**플레이어만 있는 씬**"

#: ../../docs/getting_started/editor/unity_to_godot.rst:115
msgid ""
"Consider the player as an element we'd like to use in different parent "
"scenes (for instance 'level' scenes). In our case, the player element needs "
"at least an AnimatedSprite node. This node contains the sprite textures "
"necessary for various animations (for example, a walking animation)."
msgstr ""
"플레이어를 다른 부모 씬에서도 사용할 수 있는 요소라고 생각해보세요 (예를 들"
"어 'level' 씬이죠). 이 경우에는 플레이어 요소는 적어도 하나의 AnimatedSprite "
"노드가 필요합니다. 이 노드는 다양한 애니메이션을 주기 위해 스프라이트 텍스처"
"가 반드시 필요합니다 (예를 들어 걷는 애니메이션)."

#: ../../docs/getting_started/editor/unity_to_godot.rst:117
msgid "**A scene for the Enemy.**"
msgstr "**적을 위한 씬**"

#: ../../docs/getting_started/editor/unity_to_godot.rst:119
msgid ""
"An enemy is also an element we'd like to use in several scenes. It's almost "
"the same as the Player node. The only differences are the script (it needs "
"'AI' routines to generate the enemy's behaviour) and the sprite textures "
"used by the AnimatedSprite node."
msgstr ""
"적도 마찬가지로 다양한 씬에서 사용할 수 있는 요소입니다. 플레이어 노드랑 거"
"의 일치합니다. 유일한 차이점은 스크립트입니다 (적의 행동을 만드는 'AI' 루틴"
"이 필요하죠). 그리고 AnimatedSprite 노드에 쓰이는 스프라이트도 다를 것입니다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:123
msgid "**A Level scene.**"
msgstr "**레벨 씬.**"

#: ../../docs/getting_started/editor/unity_to_godot.rst:125
msgid ""
"A Level scene is composed of Bricks (for platforms), Coins (for the player "
"to collect) and a number of instances of the Enemy scene. Each instance is a "
"node in the Level scene tree. These instances are separate enemies, which "
"initially have shared behaviour and appearance as defined in the Enemy "
"scene. You can set different properties for each Enemy node (to change its "
"color, for example)."
msgstr ""
"레벨 씬은 (플랫폼 용도) 블럭과, (플레이어가 모으는) 코인, 그리고 많은 양의 "
"적 씬 인스턴스로 제작됩니다. 각 인스턴스는 레벨 씬 트리의 노드입니다. 이 인스"
"턴스는 개별적인 적으로, 적 씬에서 정의한 대로 초기 값으로 행동과 모습을 공유"
"합니다. 각 적 노드마다 다른 속성을 설정할 수 있습니다 (예를 들어, 색상을 바꾸"
"는 것이 있죠)."

#: ../../docs/getting_started/editor/unity_to_godot.rst:129
msgid ""
"4. **A Main scene.** The Main scene would be composed of one root node with "
"2 children: a Player instance node, and a Level instance node. The root node "
"can be anything, generally a \"root\" type such as \"Node\" which is the "
"most global type, or \"Node2D\" (root type of all 2D-related nodes), "
"\"Spatial\" (root type of all 3D-related nodes) or \"Control\" (root type of "
"all GUI-related nodes)."
msgstr ""
"4. **메인 씬.** 메인 씬은 하나의 루트 노드와 2 개의 자식으로 제작됩니다: 플레"
"이어 인스턴스 노드, 레벨 인스턴스 노드. 루트 나도는 아무거나 가능합니다. 일반"
"적으로 \"루트\" 유형인 노드가 있죠. 가장 전역 유형에 있는 \"Node\", (모든 2D "
"관련 노드의 루트 유형인) \"Node2D\", (모든 3D 관련 노드의 루트 유형인) "
"\"Spatial\", 혹은 (모든 GUI 관련 노드의 루트 유형인) \"Control\"이 있습니다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:135
msgid ""
"As you can see, every scene is organized as a tree. The same goes for nodes' "
"properties: you don't *add* a collision component to a node to make it "
"collidable like Unity does. Instead, you make this node a *child* of a new "
"specific node that has collision properties. Godot features various "
"collision types nodes, depending on the usage (see the :ref:`Physics "
"introduction <doc_physics_introduction>`)."
msgstr ""
"보시다시피, 모든 씬이 트리로 조직됩니다. 노드의 속성도 동일합니다: Unity처럼 "
"노드가 충돌 가능하도록 충돌 구성 요소를 *추가* 할 수는 없습니다. 대신 충돌 속"
"성을 가진 새로운 특정 노드를 *자식* 으로 만들 수 있습니다. Godot는 사용법에 "
"따른 다양한 충돌 타입 노드가 있습니다 (:ref:`물리 소개 "
"<doc_physics_introduction>`\\ 를 참고하세요)."

#: ../../docs/getting_started/editor/unity_to_godot.rst:140
msgid ""
"What are the advantages of this system? Wouldn't this system potentially "
"increase the depth of the scene tree? And doesn't Unity already allow you to "
"organize GameObjects by putting them inside empty GameObjects?"
msgstr ""
"이 시스템의 장점은 뭐가 있나요? 이 시스템이 잠재적으로 씬 트리의 깊이를 늘리"
"진 않을까요? 그리고 Unity는 이미 빈 GameObject에 GameObject를 넣는 것으로 이"
"를 조직하는 것이 가능할텐데요?"

#: ../../docs/getting_started/editor/unity_to_godot.rst:142
msgid ""
"Godot's system is closer to the well-known object-oriented paradigm: Godot "
"provides a number of nodes which are not clearly \"Game Objects\", but they "
"provide their children with their own capabilities: this is inheritance."
msgstr ""
"Godot의 시스템은 잘 알려진 객체 기반 패러다임과 근접합니다: Godot는 많은 노드"
"를 제공하지만 그것이 \"Game Objects\"라고 정의하기는 어렵습니다. 하지만 노드"
"는 자신의 자식에게 자신의 기능을 제공합니다: 이것이 상속입니다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:143
msgid ""
"Godot allows the extraction of a subtree of a scene to make it a scene of "
"its own. So if a scene tree gets too deep, it can be split into smaller "
"subtrees. This is better for reusability, as you can include any subtree as "
"a child of any node. Putting multiple GameObjects in an empty GameObject in "
"Unity does not provide the same functionality."
msgstr ""
"Godot는 씬의 하위 씬을 추출해서 자체적인 씬을 만드는 것이 가능합니다. 따라서 "
"씬 트리가 너무 깊어지면, 더 작은 하위 씬으로 분리하는 것이 가능합니다. 이 점"
"으로 노드와 자식이 있으면 하위 씬을 만들 수 있기 때문에 재활용성에 더 좋습니"
"다. Unity에서 빈 GameObject에 여러 GameObject를 넣는 방식은 같은 기능을 제공"
"하지 못합니다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:146
msgid "Project organization"
msgstr "프로젝트 조직"

#: ../../docs/getting_started/editor/unity_to_godot.rst:150
msgid ""
"There is no perfect project architecture. Any architecture can be made to "
"work in either Unity and Godot."
msgstr ""
"완벽한 프로젝트 구조라는 것은 없습니다. 어떤 구조라도 Unity와 Godot에서 작업"
"을 위해 만들 수 있습니다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:153
msgid ""
"However, a common architecture for Unity projects is to have one Assets "
"folder in the root directory that contains various folders, one per type of "
"asset: Audio, Graphics, Models, Materials, Scripts, Scenes, and so on."
msgstr ""
"하지만 Unity 프로젝트를 위한 일반적인 구조는 루트 디렉토리에 하나의 Assets 폴"
"더를 갖는 것입니다. 여기에는 다양한 폴더가 있으며 각 폴더마다 하나의 유형의 "
"파일이 있습니다: 오디오, 그래픽, 모델, 머티리얼, 스크립트, 장면 등."

#: ../../docs/getting_started/editor/unity_to_godot.rst:156
msgid ""
"Since Godot allows splitting scenes into smaller scenes, each scene and "
"subscene existing as a file in the project, we recommend organizing your "
"project a bit differently. This wiki provides a page for this: :ref:"
"`doc_project_organization`."
msgstr ""
"Godot는 씬을 더 작은 씬으로 분리할 수 있으므로, 프로젝트에서 각 씬과 하위 씬"
"은 하나의 파일로 존재합니다. 프로젝트를 조금 다르게 조직하는 것을 추천합니"
"다. 여기서는 프로젝트 조직을 알려주는 페이지를 알려 드리겠습니다: :ref:"
"`doc_project_organization`."

#: ../../docs/getting_started/editor/unity_to_godot.rst:161
msgid "Where are my prefabs?"
msgstr "프리펩은 어디갔나요?"

#: ../../docs/getting_started/editor/unity_to_godot.rst:163
msgid ""
"A prefab as provided by Unity is a 'template' element of the scene. It is "
"reusable, and each instance of the prefab that exists in the scene has an "
"existence of its own, but all of them have the same properties as defined by "
"the prefab."
msgstr ""
"Unity가 제공하는 프리펩의 개념은 씬의 '템플릿' 요소입니다. 다시 사용할 수 있"
"고, 장면에서 프리펩의 각 인스턴스는 스스로 존재합니다. 하지만 모든 인스턴스"
"는 프리펩에서 정의한 똑같은 속성을 갖고 있습니다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:167
msgid ""
"Godot does not provide prefabs as such, but the same functionality is "
"provided by its scene system: The scene system is organized as a tree. Godot "
"allows you to save any subtree of a scene as a scene file. This new scene "
"can then be instanced as many times as you want, as a child of any node. Any "
"change you make to this new, separate scene will be applied to its "
"instances. However, any change you make to the instance will not have any "
"impact on the 'template' scene."
msgstr ""
"Godot에서는 그러한 프리펩을 제공하지 않지만, 씬 시스템으로 같은 기능을 제공합"
"니다: 씬 시스템은 트리로 조직됩니다. Godot는 씬의 하위 트리를 씬 파일로 저장"
"할 수 있습니다. 이 새로운 씬은 노드의 자식으로 원하는 만큼 인스턴스할 수 있습"
"니다. 앞에서 만든 하위 트리로 만든 씬에서 일어난 변경 사항은 인스턴스로 적용"
"될 것입니다. 하지만 인스턴스에서 일어난 변경 사항은 '템플릿' 씬에게 영향을 주"
"지 않을 것입니다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:174
msgid ""
"To be precise, you can modify the parameters of an instance in the Inspector "
"panel. The nodes that compose this instance are initially locked. You can "
"unlock them if you need to by right-clicking the instance in the Scene tree "
"and selecting \"Editable children\" in the menu. You don't need to do this "
"to add *new* child nodes to this node. Remember that any new children will "
"belong to the instance, not to the 'template' scene on disk. If you want to "
"add new children to every instance of your 'template' scene, then you should "
"add them in the 'template' scene."
msgstr ""
"정확히는, 인스펙터(Inspector) 패널에서 인스턴스의 매개변수를 수정할 수 잇습니"
"다. 이 인스턴스를 만든 노드는 초기값이 고정되어 있습니다. 고정 값을 풀고 싶다"
"면 씬 트리에서 인스턴스를 우클릭한 뒤, 메뉴에서 \"편집할 수 있는 자식"
"(Editable children)\"을 선택하세요. 이 노드에 *새로운* 자식 노드를 추가할 필"
"요가 없습니다. 모든 새 자식은 인스턴스에 속하는 것이지, 디스크에 있는 '템플"
"릿' 씬에 속하는 것이 아님을 명심하세요. '템플릿' 씬의 모든 인스턴스에게 새 자"
"식을 추가하고 싶다면, 자식은 '템플릿' 씬에 추가해야 할 것입니다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:184
msgid "Glossary correspondence"
msgstr "어휘 일치"

#: ../../docs/getting_started/editor/unity_to_godot.rst:186
msgid "GameObject -> Node"
msgstr "GameObject -> 노드"

#: ../../docs/getting_started/editor/unity_to_godot.rst:187
msgid "Add a component -> Inheriting"
msgstr "컴포넌트 추가 -> 상속"

#: ../../docs/getting_started/editor/unity_to_godot.rst:188
msgid "Prefab -> Reusable Scene file"
msgstr "프리펩 -> 다시 사용할 수 있는 씬 파일"

#: ../../docs/getting_started/editor/unity_to_godot.rst:192
msgid "Scripting: GDScript, C# and Visual Script"
msgstr "스크립팅: GDScript, C# and Visual Script"

#: ../../docs/getting_started/editor/unity_to_godot.rst:195
msgid "Design"
msgstr "디자인"

#: ../../docs/getting_started/editor/unity_to_godot.rst:197
msgid ""
"Unity supports C#. C# benefits from its integration with Visual Studio and "
"has desirable features such as static typing."
msgstr ""
"Unity는 C#을 지원합니다. C#은 Visual Studio와의 통합의 이점이 있고 정적 타이"
"핑과 같은 바람직한 기능을 갖고 있습니다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:199
msgid ""
"Godot provides its own scripting language, :ref:`GDScript <doc_scripting>` "
"as well as support for :ref:`Visual Script <toc-learn-scripting-"
"visual_script>` and :ref:`C# <doc_c_sharp>`. GDScript borrows its syntax "
"from Python, but is not related to it. If you wonder about the reasoning for "
"a custom scripting language, please read the :ref:`doc_gdscript` and :ref:"
"`doc_faq` pages. GDScript is strongly attached to the Godot API and doesn't "
"take long to learn: Between one evening for an experienced programmer and a "
"week for a complete beginner."
msgstr ""
"Godot는 독자적인 스크립트 언어를 제공합니다, :ref:`GDScript <doc_scripting>`"
"\\ 와 :ref:`Visual Script <toc-learn-scripting-visual_script>`, 그리고 :ref:"
"`doc_c_sharp`. GDScript는 Python의 문법을 빌려왔지만 관련은 없습니다. 왜 맞"
"춤 스크립트 언어에 대해 궁금하다면, :ref:`doc_gdscript`\\ 와 :ref:`doc_faq` "
"페이지를 참고해주세요. GDScript는 Godot API와 강하게 연결되어 있으면서도 배우"
"는데 오래 걸리지 않습니다: 전문적인 프로그래머와 저번 주에 막 시작한 컴퓨터 "
"초보자에게도 말이죠."

#: ../../docs/getting_started/editor/unity_to_godot.rst:205
msgid ""
"Unity allows you to attach as many scripts as you want to a GameObject. Each "
"script adds a behaviour to the GameObject: For example, you can attach a "
"script so that it reacts to the player's controls, and another that controls "
"its specific game logic."
msgstr ""
"Unity는 GameObject에 원하는 만큼의 스크립트를 붙일 수 있습니다. 각 스크립트"
"는 GameObject에 행동을 추가합니다: 예를 들어 스크립트를 붙여서 플레이어의 조"
"작이나 특정 게임을 조작하는 다른 것을 넣을 수 있습니다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:209
msgid ""
"In Godot, you can only attach one script per node. You can use either an "
"external GDScript file or include the script directly in the node. If you "
"need to attach more scripts to one node, then you may consider two "
"solutions, depending on your scene and on what you want to achieve:"
msgstr ""
"Godot에서, 우리는 각 노드에 하나의 스크립트만 붙일 수 있습니다. 외부 "
"GDScript 파일이나 노드에 스크립트를 직접 넣어서 사용할 수 있습니다. 한 노드"
"에 더 많은 스크립트를 붙이고 싶다면, 씬이랑 원하는 것을 얻기 위해, 두 가지 방"
"안을 고려하셔야 합니다:"

#: ../../docs/getting_started/editor/unity_to_godot.rst:213
msgid ""
"either add a new node between your target node and its current parent, then "
"add a script to this new node."
msgstr ""
"대상 노드와 현재 부모 노드 사이에 새 노드를 추가 한 다음, 이 노드에 스크립트"
"를 추가합니다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:214
msgid ""
"or, you can split your target node into multiple children and attach one "
"script to each of them."
msgstr ""
"또는, 대상 노드를 여러 자식 노드로 분할하고 각각마다 하나의 스크립트를 붙일 "
"수 있습니다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:216
msgid ""
"As you can see, it can be easy to turn a scene tree to a mess. Consider "
"splitting any complicated scene into multiple, smaller branches."
msgstr ""
"보다시피, 씬 트리는 쉽게 엉망이 될 수 있습니다. 복잡한 씬을 여러 개의, 더 작"
"은 분기로 나누는 것을 생각해보세요."

#: ../../docs/getting_started/editor/unity_to_godot.rst:219
msgid "Connections: groups and signals"
msgstr "연결: 그룹과 시그널"

#: ../../docs/getting_started/editor/unity_to_godot.rst:221
msgid ""
"You can control nodes by accessing them via script and calling built-in or "
"user-defined functions on them. You can also place nodes in a group and call "
"functions on all nodes in this group. See more in the :ref:`scripting "
"documentation <doc_scripting_continued>`."
msgstr ""
"스크립트를 통해 노드에 접근하고 노드에서 내장 함수나 사용자가 정의한 함수를 "
"호출하여 노드를 제어할 수 있습니다. 그리고 노드를 그룹에 배치하거나 이 그룹"
"에 있는 모든 노드에서 함수를 호출할 수도 있습니다. 자세한 것은 :ref:`스크립"
"팅 문서 <doc_scripting_continued>`\\ 를 참고하세요."

#: ../../docs/getting_started/editor/unity_to_godot.rst:226
msgid ""
"Nodes can send a signal when a specified action occurs. A signal can be set "
"to call any function. You can define custom signals and specify when they "
"are triggered. See more in the :ref:`signals documentation "
"<doc_gdscript_signals>`."
msgstr ""
"노드는 특정 동작이 발생할 때 시그널을 보냅니다. 시그널은 함수를 호출하도록 설"
"정될 수 있습니다. 맞춤 시그널을 정의하고 언제 시그널을 보낼 지를 지정할 수 있"
"습니다. 자세한 설명은 :ref:`시그널 문서 <doc_gdscript_signals>`\\ 를 참고하세"
"요."

#: ../../docs/getting_started/editor/unity_to_godot.rst:231
msgid "Script serialization"
msgstr "스크립트 직렬화"

#: ../../docs/getting_started/editor/unity_to_godot.rst:233
msgid "Unity can handle script serialization in two ways:"
msgstr "Unity는 두 가지 방법으로 스크립트 직렬화를 다룰 수 있습니다:"

#: ../../docs/getting_started/editor/unity_to_godot.rst:235
msgid ""
"Implicit: All public fields in a class are automatically serialized if the "
"type is a serializable type (``Dictionary`` is not serializable)."
msgstr ""
"Implicit(암시적):  한 클래스의 모든 퍼블릭 필드가 직렬화 할 수 있는 타입이면 "
"(``Dictionary``\\ 는 직렬화 할 수 없음) 자동으로 직렬화 됩니다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:236
msgid ""
"Explicit: Non-public fields can be serialized using the ``[SerializeField]`` "
"attribute."
msgstr ""
"Explicit(명시적): 비 퍼블릭 필드를 ``[SerializeField]`` 속성을 사용하여 직렬"
"화 되도록 할 수 있습니다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:238
msgid ""
"Godot also has a built-in script serialization system, but it works only "
"explicitly. You can serialize any serializable type (:ref:`built-in and "
"various engine types <doc_binary_serialization_api>`, including :ref:"
"`class_Array` and :ref:`class_Dictionary`) using the ``export`` keyword. See "
"the :ref:`exports documentation <doc_gdscript_exports>` for details."
msgstr ""
"Godot 또한 내장 스크립트 직렬화 시스템을 갖추고 있지만, 오직 명시적으로만 작"
"동합니다. 어떤 직렬화 가능한 타입이라도 (:ref:`class_Array`\\ 와 :ref:"
"`class_Dictionary`\\ 를 포함한, :ref:`내장 그리고 다양한 엔진 타입 "
"<doc_binary_serialization_api>`) ``export`` 키워드를 사용해 직렬화 할 수 있습"
"니다. 자세한 설명은 :ref:`내보내기 문서 <doc_gdscript_exports>`\\ 를 참고하세"
"요."

#: ../../docs/getting_started/editor/unity_to_godot.rst:243
msgid ""
"Unity also has a data type called ``ScriptableObject`` used to serialize "
"custom asset objects. Its equivalent in Godot is the base class for all "
"resources: :ref:`class_Resource`. Creating a script that inherits :ref:"
"`class_Resource` will allow you to create custom serializable objects. More "
"information about resources can be found :ref:`here <doc_resources>`."
msgstr ""
"Unity 또한 맞춤 애셋 객체를 직렬화 하기 위해 사용되는 ``ScriptableObject`` 라"
"는 데이터 타입을 갖고 있습니다. Godot에서 이것은 모든 리소스의 기본 클래스에 "
"해당합니다: :ref:`class_Resource`. :ref:`class_Resource`\\ 를 상속하는 스크립"
"트를 만드는 것으로 맞춤 직렬화 가능한 객체를 만들 수 있게 됩니다. 리소스에 관"
"한 더 많은 정보는 :ref:`여기서 <doc_resources>` 볼 수 있습니다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:248
msgid "Using Godot in C++"
msgstr "C++로 Godot 사용하기"

#: ../../docs/getting_started/editor/unity_to_godot.rst:250
msgid ""
"Godot allows you to develop your project directly in C++ by using its API, "
"which is not possible with Unity at the moment. As an example, you can "
"consider Godot Engine's editor as a \"game\" written in C++ using the Godot "
"API."
msgstr ""
"Godot는 API를 사용하여 C++로 프로젝트를 직접 개발할 수 있게 해줍니다, 이는 현"
"재 Unity에서는 불가능합니다. 예를 들어 Godot 엔진의 편집기를 Godot API를 사용"
"하는 C++로 작성된 \"게임\"으로 간주할 수 있습니다."

#: ../../docs/getting_started/editor/unity_to_godot.rst:253
msgid ""
"If you are interested in using Godot in C++, you may want to start reading "
"the :ref:`Developing in C++ <doc_introduction_to_godot_development>` page."
msgstr ""
"C++로 Godot를 사용하는 것에 관심이 있으시다면, :ref:`C++로 개발하기 "
"<doc_introduction_to_godot_development>` 페이지를 읽고 시작하시면 됩니다."
