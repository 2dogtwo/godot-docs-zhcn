# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2019, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-01-20 10:29+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:4
msgid "Using KinematicBody2D"
msgstr "KinematicBody2D 사용하기"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:7
msgid "Introduction"
msgstr "소개"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:9
msgid ""
"Godot offers a number of collision objects to provide both collision "
"detection and response. Trying to decide which one to use for your project "
"can be confusing. You can avoid problems and simplify development if you "
"understand how each of them works and what their pros and cons are. In this "
"tutorial, we'll look at the :ref:`KinematicBody2D <class_KinematicBody2D>` "
"node and show some examples of how it can be used."
msgstr ""
"Godot은 충돌 감지와 반응성을 모두 제공하기 위해 많은 충돌 물체를 제공합니다. "
"프로젝트에 사용할 항목을 결정하는 것은 혼란스러울 수 있습니다. 각각의 작동 방"
"식 및 장단점이 무엇인지 이해한다면 문제를 피하고 개발을 간소화할 수 있습니"
"다. 이 튜토리얼에서는:ref:`KinematicBody2D <class_KinematicBody2D> 노드를 살"
"펴보고 사용 방법에 대한 몇 가지 예를 보여 드리겠습니다."

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:16
msgid ""
"This document assumes you're familiar with Godot's various physics bodies. "
"Please read :ref:`doc_physics_introduction` first."
msgstr ""
"이 문서는 당신이 Godot의 다양한 물리학 body들에 대해 잘 알고 있다고 가정합니"
"다. 먼저 :ref:`doc_physics_introduction`를 읽어주세요."

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:20
msgid "What is a kinematic body?"
msgstr "kinematic body란 무엇인가?"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:22
#, fuzzy
msgid ""
"``KinematicBody2D`` is for implementing bodies that are to be controlled via "
"code. They detect collisions with other bodies when moving, but are not "
"affected by engine physics properties, like gravity or friction. While this "
"means that you have to write some code to create their behavior, it also "
"means you have more precise control over how they move and react."
msgstr ""
"``KinematicBody2D``는 코드로 통제될 body를 구현하기 위한 것입니다. 이들은 이"
"동할 때 다른 body와의 충돌을 감지하지만, 중력이나 마찰과 같은 물리 엔진 특성"
"에 의해 영향을 받지 않습니다. 이것은 당신이 그것들의 행동을 만들어내기 위해 "
"몇 개의 코드를 써야 한다는 것을 의미하지만, 또한 그것들이 어떻게 움직이고 반"
"응하는지 더 정확히 제어할 수 있다는 것을 의미합니다."

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:28
msgid ""
"A `KinematicBody2D` can be affected by gravity and other forces, but you "
"must calculate the movement in code. The physics engine will not move a "
"`KinematicBody2D`."
msgstr ""
"`KinematicBody2D`는 중력과 다른 힘에 의해 영향을 받을 수 있지만 코드로 움직임"
"을 계산해야 합니다. 물리 엔진은 `KinematicBody2D`를 움직이지 않습니다."

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:33
#, fuzzy
msgid "Movement and collision"
msgstr "이동 및 충돌"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:35
msgid ""
"When moving a ``KinematicBody2D``, you should not set its ``position`` "
"property directly. Instead, you use the ``move_and_collide()`` or "
"``move_and_slide()`` methods. These methods move the body along a given "
"vector and will instantly stop if a collision is detected with another body. "
"After a KinematicBody2D has collided, any *collision response* must be coded "
"manually."
msgstr ""
"``KinematicBody2D``를 옮길 때 ``position``속성을 직접 설정해서는 안 됩니다. "
"대신 ``move_and_collide()`` 또는 ``move_and_slide()`` 매서드를 사용해야 합니"
"다. 이러한 방법은 주어진 벡터를 따라 body를 움직이며 충돌이 감지될 경우 즉시 "
"중지됩니다. KineticBody2D가 충돌한 후에는 *충돌 반응*을 수동으로 코딩해야 합"
"니다."

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:41
msgid ""
"Kinematic body movement should only be done in the ``_physics_process()`` "
"callback."
msgstr ""
"Kinematic body의 움직임은 ``_physics_process()`` 콜백 함수 로만 이루어져야 합"
"니다."

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:43
#, fuzzy
msgid ""
"The two movement methods serve different purposes, and later in this "
"tutorial, you'll see examples of how they work."
msgstr ""
"두 이동 메서드는 서로 다른 용도로 사용되며, 이 튜토리얼의 뒷부분에는 작동 방"
"법에 대한 예가 나와 있습니다."

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:47
msgid "``move_and_collide``"
msgstr ""

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:49
msgid ""
"This method takes one parameter: a :ref:`Vector2 <class_Vector2>` indicating "
"the body's relative movement. Typically, this is your velocity vector "
"multiplied by the frame timestep (``delta``). If the engine detects a "
"collision anywhere along this vector, the body will immediately stop moving. "
"If this happens, the method will return a :ref:`KinematicCollision2D "
"<class_KinematicCollision2D>` object."
msgstr ""
"이 메서드는 하나의 매개 변수를 가집니다: body의 상대적인 움직임을 나타내는 :"
"ref:`Vector2 <class_Vector2>`. 일반적으로 이것은 속도 벡터에 프레임 타임스탬"
"프(``delta``)를 곱한 것입니다. 엔진이 이 벡터를 따라 어느 곳에서든 충돌을 감"
"지하면 body는 즉시 작동을 멈춥니다. 이 경우 메서드는 :ref:"
"`KinematicCollision2D <class_KinematicCollision2D>` 개체를 반환합니다."

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:55
#, fuzzy
msgid ""
"``KinematicCollision2D`` is an object containing data about the collision "
"and the colliding object. Using this data, you can calculate your collision "
"response."
msgstr ""
"``KinematicCollision2D`` 는 충돌과 충돌하는 물체에 대한 데이터를 담고 있는 물"
"체입니다. 이 데이터를 사용하여 충돌 반응을 계산할 수 있습니다."

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:60
msgid "``move_and_slide``"
msgstr ""

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:62
msgid ""
"The ``move_and_slide()`` method is intended to simplify the collision "
"response in the common case where you want one body to slide along the "
"other. This is especially useful in platformers or top-down games, for "
"example."
msgstr ""
"``move_and_slide()`` 방법은 하나의 body가 다른 하나의 body를 따라 미끄러지도"
"록 하려는 일반적인 경우에서 충돌 반응을 단순화하기 위한 것입니다. 이것은 예"
"를 들어 플랫포머나 하향식 게임에서 특히 유용합니다."

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:66
msgid ""
"``move_and_slide()`` automatically calculates frame-based movement using "
"``delta``. Do *not* multiply your velocity vector by ``delta`` before "
"passing it to ``move_and_slide()``."
msgstr ""
"``move_and_slide()``는 ``delta``를 사용하여 프레임 기반 이동을 자동으로 계산"
"합니다. 속도 벡터를 ``move_and_slide()``에 전달하기 전에 ``delta`` 로 곱하지 "
"마십시오."

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:70
msgid ""
"In addition to the velocity vector, ``move_and_slide()`` takes a number of "
"other parameters allowing you to customize the slide behavior:"
msgstr ""
"속도 벡터 외에도 ``move_and_slide()``에는 여러 가지 다른 매개 변수가 포함되"
"어 있어 슬라이드 동작을 지정할 수 있습니다:"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:73
msgid "``floor_normal`` - *default value:* ``Vector2( 0, 0 )``"
msgstr ""

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:75
msgid ""
"This parameter allows you to define what surfaces the engine should consider "
"to be the floor. Setting this lets you use the ``is_on_floor()``, "
"``is_on_wall()``, and ``is_on_ceiling()`` methods to detect what type of "
"surface the body is in contact with. The default value means that all "
"surfaces are considered walls."
msgstr ""
"이 매개 변수를 사용하면 엔진이 바닥으로 간주해야 하는 표면을 정의할 수 있습니"
"다. 이를 설정하면 ``is_on_floor()``, `is_on_wall()``, ``is_on_ceiling()`` 매"
"서드를 사용하여 신체와 접촉하는 표면의 유형을 탐지할 수 있습니다. 기본값으론 "
"모든 표면이 벽으로 간주됩니다."

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:80
msgid "``slope_stop_min_velocity`` - *default value:* ``5``"
msgstr ""

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:82
msgid ""
"This is the minimum velocity when standing on a slope. This prevents a body "
"from sliding down a slope when standing still."
msgstr ""
"이것은 경사면에 서 있을 때의 최소 속도입니다. 이렇게 하면 정지 상태에서 body"
"가 비탈 아래로 미끄러지는 것을 방지할 수 있습니다."

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:85
msgid "``max_bounces`` - *default value:* ``4``"
msgstr ""

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:87
msgid ""
"This is the maximum number of collisions before the body stops moving. "
"Setting this too low may prevent movement entirely."
msgstr ""
"이것은 body가 움직임을 멈추기 전의 최대 충돌 횟수입니다. 이 값을 너무 낮게 설"
"정하면 이동이 완전히 차단될 수 있습니다."

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:90
msgid ""
"``floor_max_angle`` - *default value:* ``0.785398`` (in radians, equivalent "
"to ``45`` degrees)"
msgstr ""
"``floor_max_angle`` - *default value:* ``0.785398`` (라디안으론, ``45`` 도와 "
"같다)"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:92
msgid ""
"This is the maximum angle before a surface is no longer considered a \"floor"
"\"."
msgstr "이것은 지표면이 더 이상 \"바닥\"으로 간주되지 않는 최대 각도입니다."

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:95
msgid "``move_and_slide_with_snap``"
msgstr ""

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:97
msgid ""
"This method adds some additional functionality to ``move_and_slide()`` by "
"adding the ``snap`` parameter. As long as this vector is in contact with the "
"ground, the body will remain attached to the surface. Note that this means "
"you must disable snapping when jumping, for example. You can do this either "
"by setting ``snap`` to ``Vector2(0, 0)`` or by using ``move_and_slide()`` "
"instead."
msgstr ""
"이 방법은 ``snap`` 매개 변수를 추가하여 ``move_and_slide()``에 몇 가지 기능"
"을 더합니다. 이 벡터가 지면과 접촉하는 한 body는 표면에 부착된 상태를 유지합"
"니다. 이는 점프할 때 스냅을 비활성화해야 함을 의미합니다. ``snap``을"
"``Vector2(0, 0)`` 로 설정하거나 ``move_and_slide()`` 를 대신 사용하여 이 작업"
"을 수행할 수 있습니다."

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:104
msgid "Which movement method to use?"
msgstr "사용해야할 이동 매서드는 무엇입니까?"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:106
#, fuzzy
msgid ""
"A common question from new Godot users is: \"How do you decide which "
"movement function to use?\" Often, the response is to use "
"``move_and_slide()`` because it's \"simpler\", but this is not necessarily "
"the case. One way to think of it is that ``move_and_slide()`` is a special "
"case, and ``move_and_collide()`` is more general. For example, the following "
"two code snippets result in the same collision response:"
msgstr ""
"새로운 Godot 사용자들의 일반적인 질문은 다음과 같습니다: \"어떤 이동 기능을 "
"사용할지 어떻게 결정합니까?\" 종종 ``move_and_slide()``가 \"간단\"하기 때문"
"에 사용하라고 하지만, 반드시 그런 것은 아닙니다. 생각해 볼 수 있는 한 가지 방"
"법은``move_and_slide()``가 특별한 경우이고, ``move_and_collide()``가 더 일반"
"적이라는 것입니다. 예를 들어, 다음 두 코드 조각은 동일한 충돌 응답을 생성합니"
"다:"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:137
msgid ""
"Anything you do with ``move_and_slide()`` can also be done with "
"``move_and_collide()``, but it might take a little more code. However, as "
"we'll see in the examples below, there are cases where ``move_and_slide()`` "
"doesn't provide the response you want."
msgstr ""
"당신이 ``move_and_slide()``로 하는 것은 또한 ``move_and_collide()``로 할 수 "
"있지만 좀 더 많은 코드가 필요할 수도 있습니다. 그러나 아래 예에서 볼 수 있듯"
"이 ``move_and_slide()``가 당신이 원하는 대답을 제공하지 않는 경우도 있습니다."

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:142
msgid "Examples"
msgstr "예시"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:144
msgid ""
"To see these examples in action, download the sample project: :download:"
"`using_kinematic2d.zip <files/using_kinematic2d.zip>`."
msgstr ""
"예제가 실행되는것을 보기 위해선, 샘플 프로젝트를 다운로드하십시오: :download:"
"`using_kinematic2d.zip <files/using_kinematic2d.zip>`."

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:148
msgid "Movement and walls"
msgstr "이동 및 벽"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:150
#, fuzzy
msgid ""
"If you've downloaded the sample project, this example is in \"BasicMovement."
"tscn\"."
msgstr ""
"샘플 프로젝트를 다운로드했다면, 이 예는 \"BasicMovement.tscn\" 의 장면입니다."

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:152
#, fuzzy
msgid ""
"For this example, add a ``KinematicBody2D`` with two children: a ``Sprite`` "
"and a ``CollisionShape2D``. Use the Godot \"icon.png\" as the Sprite's "
"texture (drag it from the Filesystem dock to the *Texture* property of the "
"``Sprite``). In the ``CollisionShape2D``'s *Shape* property, select \"New "
"RectangleShape2D\" and size the rectangle to fit over the sprite image."
msgstr ""
"이 예시에서 ``KinematicBody2D``를 두 자식과 함께 추가합니다: ``Sprite``와 "
"``CollisionShape2D``. Godot \"icon.png\"를 Sprite의 텍스쳐 속성으로 사용합니"
"다 (파일 시스템 독에서 ``Sprite``의 *Texture* 속성으로 끌어다 놓으십시오). "
"``CollisionShape2D``의 *Shape* 속성에서 \"New RectangleShape2D\"를 선택하고 "
"스프라이트 이미지에 맞게 사각형 크기를 조정합니다."

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:158
msgid ""
"See :ref:`doc_2d_movement` for examples of implementing 2D movement schemes."
msgstr "2D 이동 계획을 구현하는 예는 :ref:`doc_2d_movement`을 참조하시오."

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:160
msgid "Attach a script to the KinematicBody2D and add the following code:"
msgstr "KineticBody2D에 스크립트를 연결하고 다음 코드를 추가합니다:"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:227
msgid ""
"Run this scene and you'll see that ``move_and_collide()`` works as expected, "
"moving the body along the velocity vector. Now let's see what happens when "
"you add some obstacles. Add a :ref:`StaticBody2D <class_StaticBody2D>` with "
"a rectangular collision shape. For visibility, you can use a sprite, a "
"Polygon2D, or turn on \"Visible Collision Shapes\" from the \"Debug\" menu."
msgstr ""
"이 장면을 보면 ``move_and_collide()``가 예상대로 작동하면서 body가 속도 벡터"
"를 따라 움직이는 것을 볼 수 있습니다. 이제 장애물을 추가하면 어떻게 되는지 봅"
"시다. 직사각형 충돌 모양으로 :ref:`StaticBody2D <class_StaticBody2D>`를 추가"
"합니다. 가시성을 위해 \"Debug\" 메뉴에서 스프라이트, Polygon2D를 사용하거나 "
"\"Visible Collision Shapes\"를 켤 수 있습니다."

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:233
msgid ""
"Run the scene again and try moving into the obstacle. You'll see that the "
"``KinematicBody2D`` can't penetrate the obstacle. However, try moving into "
"the obstacle at an angle and you'll find that the obstacle acts like glue - "
"it feels like the body gets stuck."
msgstr ""
"장면을 다시 실행하고 장애물 안으로 들어가 보십시오. 당신은 "
"``KinematicBody2D``가 장애물을 통과할 수 없다는 것을 알게 될 것입니다. 하지"
"만, 한 각도로 장애물 안으로 들어가 보세요. 그러면 장애물이 접착제처럼 작용한"
"다는 것을 알 수 있을 것입니다 - 마치 body가 달라붙는 것 같은 느낌이 듭니다."

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:237
msgid ""
"This happens because there is no *collision response*. "
"``move_and_collide()`` stops the body's movement when a collision occurs. We "
"need to code whatever response we want from the collision."
msgstr ""
"이 문제는 *충돌 대응*이 없기 때문에 발생합니다. ``move_and_collide()``는 충돌"
"이 일어날 때 몸의 움직임을 멈춥니다. 우리는 충돌 로부터 우리가 원하는 어떤 대"
"응도 코드화 할 필요가 있습니다."

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:241
msgid ""
"Try changing the function to ``move_and_slide(velocity)`` and running again. "
"Note that we removed ``delta`` from the velocity calculation."
msgstr ""
"함수를 ``move_and_slide(velocity)``로 변경하고 다시 실행해 보십시오. 속도 계"
"산에서 ``delta``를 제거했습니다."

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:244
msgid ""
"``move_and_slide()`` provides a default collision response of sliding the "
"body along the collision object. This is useful for a great many game types, "
"and may be all you need to get the behavior you want."
msgstr ""
"``move_and_slide()`` 는 충돌 물체를 따라 몸을 미끄러뜨리는 기본 충돌 반응을 "
"제공합니다. 이것은 많은 게임 유형에 유용하며, 여러분이 원하는 행동을 하기 위"
"해 필요한 모든 것일 수 있습니다."

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:249
msgid "Bouncing/reflecting"
msgstr ""

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:251
msgid ""
"What if you don't want a sliding collision response? For this example "
"(\"BounceandCollide.tscn\" in the sample project), we have a character "
"shooting bullets and we want the bullets to bounce off the walls."
msgstr ""
"슬라이딩 충돌 반응을 원하지 않을 경우 어떻게 해야 할까요? 이 예시(샘플 프로젝"
"트의 \"BounceandCollide.tscn\") 에서, 우리는 총알을 쏘는 캐릭터가 있고 총알"
"이 벽에서 튀어 나오길 바랍니다."

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:255
msgid ""
"This example uses three scenes. The main scene contains the Player and "
"Walls. The Bullet and Wall are separate scenes so that they can be instanced."
msgstr ""
"이 예시에서는 세 장면을 사용합니다. 메인 장면에는 플레이어와 벽이 포함됩니"
"다. 총알과 벽은 각각 다른 장면이기 때문에 예시로 들 수 있습니다."

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:258
msgid ""
"The Player is controlled by the `w` and `s` keys for forward and back. "
"Aiming uses the mouse pointer. Here is the code for the Player, using "
"``move_and_slide()``:"
msgstr ""
"플레이어는 앞뒤로 `w`와 `s` 키를 통해 제어됩니다. 조준은 마우스 포인터를 사용"
"합니다. 다음은 ``move_and_slide()``를 사용한 플레이어 코드입니다:"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:345
msgid "And the code for the Bullet:"
msgstr "그리고 총알에 대한 코드입니다:"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:407
#, fuzzy
msgid ""
"The action happens in ``_physics_process()``. After using "
"``move_and_collide()``, if a collision occurs, a ``KinematicCollision2D`` "
"object is returned (otherwise, the return is ``Nil``)."
msgstr ""
"이러한 동작은 ``_physics_process()``로 일어납니다. ``move_and_collide()``를 "
"사용한 후 충돌이 발생할 경우, ``KinematicCollision2D`` 개체가 반환됩니다 (그 "
"외의 경우에는, ``Nil``이 반환됩니다)."

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:411
msgid ""
"If there is a returned collision, we use the ``normal`` of the collision to "
"reflect the bullet's ``velocity`` with the ``Vector2.bounce()`` method."
msgstr ""
"만약 다시 충돌이 일어난다면, 우리는 충돌의 ``normal``을 총알의 ``velocity``"
"를  ``Vector2.bounce()`` 메서드로 반영하는 데 사용합니다."

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:414
msgid ""
"If the colliding object (``collider``) has a ``hit`` method, we also call "
"it. In the example project, we've added a flashing color effect to the Wall "
"to demonstrate this."
msgstr ""
"충돌물체(``collider``)가 ``hit`` 메서드를 갖고 있다면, 우리도 그것을 호출한"
"다. 예제 프로젝트에서는, 이를 시연하기 위해 벽에 깜박이는 색 효과를 추가했습"
"니다."

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:421
msgid "Platformer movement"
msgstr ""

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:423
msgid ""
"Let's try one more popular example: the 2D platformer. ``move_and_slide()`` "
"is ideal for quickly getting a functional character controller up and "
"running. If you've downloaded the sample project, you can find this in "
"\"Platformer.tscn\"."
msgstr ""
"인기 있는 예를 하나 더 들어 보겠습니다: 2D 플랫포머입니다. "
"``move_and_slide()``는 기능성 캐릭터 제어기를 신속하게 작동하는 데 이상적입니"
"다. 샘플 프로젝트를 다운로드한 경우, \"Platformer.tscn\"에서 찾을 수 있습니"
"다."

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:427
msgid ""
"For this example, we'll assume you have a level made of ``StaticBody2D`` "
"objects. They can be any shape and size. In the sample project, we're using :"
"ref:`Polygon2D <class_Polygon2D>` to create the platform shapes."
msgstr ""
"이 예에서는, ``StaticBody2D``로 구성된 레벨이 있다고 가정합니다. 그들은 어떤 "
"모양이나 크기가 될 수 있습니다. 샘플 프로젝트에서는, 플랫폼 모양을 만들기 위"
"해 :ref:`Polygon2D <class_Polygon2D>`를 사용하고 있습니다."

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:431
msgid "Here's the code for the player body:"
msgstr "플레이어 body의 코드는 다음과 같습니다:"

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:517
#, fuzzy
msgid ""
"When using ``move_and_slide()``, the function returns a vector representing "
"the movement that remained after the slide collision occurred. Setting that "
"value back to the character's ``velocity`` allows us to smoothly move up and "
"down slopes. Try removing ``velocity =`` and see what happens if you don't "
"do this."
msgstr ""
"이 기능은 ``move_and_slide()``를 사용할 때 슬라이드 충돌이 발생한 후에도 남"
"아 있는 움직임을 나타내는 벡터를 반환합니다. 그 값을 캐릭터의 ``velocity``로 "
"되돌리면 경사면을 부드럽게 오르내릴 수 있습니다. ``velocity =``를 없애보고 만"
"약 그렇게 하지 않으면 어떻게 되는지 확인해 보십시오."

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:522
msgid ""
"Also note that we've added ``Vector2(0, -1)`` as the floor normal. This is a "
"vector pointing straight upward. This means that if the character collides "
"with an object that has this normal, it will be considered a floor."
msgstr ""
"또한 우리는 ``Vector2(0, -1)``를 바닥의 정상으로 추가했습니다. 이것은 바로 위"
"쪽을 가리키는 벡터입니다. 즉, 캐릭터가 이와 같은 정상 상태의 개체와 충돌하면 "
"바닥으로 간주됩니다."

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:526
msgid ""
"Using the floor normal allows us to make jumping work, using "
"``is_on_floor()``. This function will only return ``true`` after a "
"``move_and_slide()`` collision where the colliding body's normal is within "
"45 degrees of the given floor vector (this can be adjusted by setting "
"``floor_max_angle``)."
msgstr ""
"바닥을 정상적으로 사용하면 ``is_on_floor()``을 사용함으로써 점프 작업을 할 "
"수 있습니다. 이 함수는 충돌 본체의 정상이 주어진 바닥 벡터에서 45도 이내인 "
"``move_and_slide()`` 충돌 후에만 ``true`` 를 반환합니다."

#: ../../docs/tutorials/physics/using_kinematic_body_2d.rst:531
#, fuzzy
msgid ""
"This also allows you to implement other features (like wall jumps) using "
"``is_on_wall()``, for example."
msgstr ""
"이를 통해 예를 들어 ``is_on_wall()`` 과 같이 벽 점프와 같은 다른 기능을 구현"
"할 수 있습니다."
