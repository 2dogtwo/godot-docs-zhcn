# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2018, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-06-13 14:08+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../docs/tutorials/math/rotations.rst:4
msgid "Rotations"
msgstr "Rotaciones"

#: ../../docs/tutorials/math/rotations.rst:6
msgid ""
"In the context of 3D transforms, rotations are the nontrivial and "
"complicated part. While it is possible to describe 3D rotations using "
"geometrical drawings and derive the rotation matrices, which is what most "
"people would be more familiar with, it offers a limited picture, and fails "
"to give any insight on related practical things such quaternions and SLERP. "
"For this reason, this document takes a different approach, a general "
"(although a little abstract at first) approach which was popularized by its "
"extensive use in local gauge theories in physics. That being said, the aim "
"of this text is to provide a minimal background to understand 2D and 3D "
"rotations in a general way and shed light on practical things such as gimbal "
"lock, quaternions and SLERP using an accessible language for programmers, "
"and not completeness or mathematical rigor."
msgstr ""
"En el contexto de las transformaciones 3D, las rotaciones son la parte no "
"trivial y complicada. Mientras que es posible describir rotaciones 3D usando "
"dibujos geométricos y derivar las matrices de rotación, que es con lo que la "
"mayoría de la gente estaría más familiarizada, ofrece una imagen limitada, y "
"no da ninguna idea de las cosas prácticas relacionadas tales como "
"cuaterniones y SLERP. Por esta razón, este documento adopta un enfoque "
"diferente, un enfoque general (aunque un poco abstracto al principio) que "
"fue popularizado por su uso extensivo en las teorías de los indicadores "
"locales en física. Dicho esto, el objetivo de este texto es proporcionar una "
"base mínima para entender las rotaciones 2D y 3D de una manera general y "
"arrojar luz sobre cosas prácticas como el bloqueo del cardán, los "
"cuaterniones y SLERP utilizando un lenguaje accesible para los "
"programadores, y no la integridad o el rigor matemático."

#: ../../docs/tutorials/math/rotations.rst:12
msgid "A crash course in Lie groups and algebras for programmers"
msgstr "Un curso intensivo en grupos de Lie y álgebra para programadores"

#: ../../docs/tutorials/math/rotations.rst:14
msgid ""
"Lie groups is a branch of mathematics which deals with rotations in a "
"systematic way. While it is a extensive subject and most programmers haven't "
"even heard of it, it is relevant in game development, because it provides a "
"coherent and unified view of 3D rotations."
msgstr ""
"Los grupos de Lie son una rama de las matemáticas que se ocupa de las "
"rotaciones de manera sistemática. Aunque es un tema extenso y la mayoría de "
"los programadores ni siquiera han oído hablar de él, es relevante en el "
"desarrollo de juegos, porque proporciona una visión coherente y unificada de "
"las rotaciones 3D."

#: ../../docs/tutorials/math/rotations.rst:20
msgid ""
"So let's start with small steps. Suppose that you want to make a tiny "
"rotation around some axis. For, concreteness let's say around  :math:`z`-"
"axis by an infinitesimal angle :math:`\\delta\\theta`. For small angles, as "
"illustrated in the figure, the rotation operator can be written as :math:"
"`R_z(\\delta\\theta) = I + \\delta \\theta \\boldsymbol e_z \\times` "
"(neglecting higher order terms :math:`\\mathcal O(\\delta\\theta^2)` ) "
"where :math:`I` is identity operator and :math:`\\boldsymbol e_z` is a unit "
"vector along the :math:`z`-axis, such that a vector :math:`\\boldsymbol v` "
"becomes"
msgstr ""
"Así que empecemos con pequeños pasos. Imaginemos que queremos hacer una "
"pequeña rotación alrededor de algún eje. Para concretar, digamos alrededor "
"del eje :math:`z` por un ángulo infinitesimal `:math:`\\delta\\theta`. Para "
"ángulos pequeños, como se ilustra en la figura, el operador de rotación "
"puede escribirse como :math:`R_z(\\delta\\theta) = I + \\delta \\theta "
"\\boldsymbol e_z \\times`donde :math:`I` es operador de identidad y :math:`"
"\\boldsymbol e_z` es un vector unitario a lo largo del eje :math:`z`, de "
"manera que un vector :math:`\\boldsymbol v` se convierte en"

#: ../../docs/tutorials/math/rotations.rst:26
msgid ""
"(If this isn't clear, you can verify this by looking at the figure: :math:`"
"\\boldsymbol v` is rotated into :math:`\\boldsymbol v'` in the plane (so the "
"rotation axis :math:`\\boldsymbol e_z` is pointing out of screen). The "
"overlap of two vectors is :math:`\\boldsymbol v \\cdot \\boldsymbol v' = "
"v^2\\cos\\delta\\theta \\approx v^2 + \\mathcal O(\\delta\\theta^2)` since "
"the rotation is just a tiny amount, so the part of :math:`\\boldsymbol v'` "
"parallel to :math:`\\boldsymbol v` is indeed :math:`\\boldsymbol v`. Here, :"
"math:`v = |\\boldsymbol v|`. What about the perpendicular part, which must "
"be :math:`\\boldsymbol v' - \\boldsymbol v`? Using the right-hand rule, the "
"direction is :math:`\\boldsymbol e_z \\times \\boldsymbol v/v`, and to the "
"first order in :math:`\\delta\\theta`, we can approximate the length of the "
"difference vector by the arc length (blue arc in the figure) which is :math:`"
"\\delta \\theta v`, so the perpendicular component :math:`\\delta \\theta "
"\\boldsymbol e_z \\times \\boldsymbol v` also checks out.)"
msgstr ""
"(Si esto no está claro, puedes verificar esto mirando la figura: :math:`"
"\\boldsymbol v` es rotado dentro de :math:`\\boldsymbol v'` en el plano (así "
"que el eje de rotación :math:`\\boldsymbol e_z` está apuntando fuera de la "
"pantalla). La superposición de dos vectores es :math:`\\boldsymbol v \\cdot "
"\\boldsymbol v' = v^2\\cos\\delta\\theta \\approx v^2 + \\mathcal O(\\delta"
"\\theta^2)` ya que la rotación es muy reducida, así que la parte de :math:`"
"\\boldsymbol v'`paralela a :math:`\\boldsymbol v` es en realidad :math:`"
"\\boldsymbol v`. Aquí,:math:`v = |\\boldsymbol v|`. ¿Qué hay de la parte "
"perpendicular, que debe ser :math:`\\boldsymbol v' - \\boldsymbol v`? Usando "
"la regla de la mano derecha, la dirección es :math:`\\boldsymbol e_z \\times "
"\\boldsymbol v/v`, y de primer orden en :math:`\\delta\\theta`, podemos "
"aproximar la longitud del vector de diferencia por la longitud del arco "
"(arco azul en la figura) que es :math:`\\delta \\theta v` así que el "
"componente perpendicular :math:`\\delta \\theta \\boldsymbol e_z \\times "
"\\boldsymbol v` también es comprobado.)"

#: ../../docs/tutorials/math/rotations.rst:28
msgid ""
"Now, a practical way of representing operators is by using matrices (note "
"that an `operator <https://en.wikipedia.org/wiki/Operator_(mathematics)>`_ "
"is not a matrix, and there are different mathematical objects other than "
"matrices which be used to represent operators, such as quaternions, a point "
"which we will come back to later when we're discussing `representations "
"<https://en.wikipedia.org/wiki/Group_representation>`_ . In terms of real :"
"math:`3 \\times 3` matrices, the identity operator :math:`I` simply "
"corresponds to a :math:`3 \\times 3` identity matrix, and the cross product :"
"math:`\\boldsymbol e_z \\times` can be represented as"
msgstr ""
"Ahora, una forma práctica de representar operadores es usando matrices (note "
"que un `operador <https://en.wikipedia.org/wiki/Operator_(mathematics)>`_ no "
"es una matriz, y hay diferentes objetos matemáticos aparte de las matrices "
"que se usan para representar operadores, tales como cuaterniones, un punto "
"al cual volveremos más tarde cuando estemos discutiendo `representaciones "
"<https://en.wikipedia.org/wiki/Group_representation>``_. En términos de "
"matrices reales de :matemáticas:`3 \\por 3`, el operador de identidad :math:"
"`I` simplemente corresponde a un :math:`3 \\times 3` matriz de identidad, y "
"el producto cruzado :math:`\\boldsymbol e_z \\times` puede representarse como"

#: ../../docs/tutorials/math/rotations.rst:38
msgid ""
"(If you're curious how you can find the matrix representation of an "
"operator :math:`A` in some set of real basis :math:`\\{ \\boldsymbol e_i\\}"
"`: the matrix element on :math:`i` th row :math:`j` th column is given by :"
"math:`\\boldsymbol e_i \\cdot (A \\boldsymbol e_j)`; the basis we use here "
"is :math:`\\{ \\boldsymbol e_x, \\boldsymbol e_y, \\boldsymbol e_z \\}`) It "
"is no accident that :math:`J_z` rotates a vector in the :math:`xy` plane "
"around the :math:`z`-axis by :math:`\\pi/2`; for an arbitrary axis :math:`"
"\\boldsymbol n`, the operator :math:`J_n \\cong \\boldsymbol n \\times` is a "
"rotation by :math:`\\pi/2` around that axis for vectors in the plane "
"perpendicular to :math:`\\boldsymbol n`."
msgstr ""
"(Si tienes curiosidad por saber cómo encontrar la representación matricial "
"de un operador :math:`A` en algún tipo de base real :math:`\\{ \\boldsymbol "
"e_i\\}`: el elemento matriz en :math:`i` fila anterior :math:`j` esta "
"columna viene dada por :math:`\\boldsymbol e_i \\cdot (A \\boldsymbol e_j)`; "
"la base que usamos aquí es :math:`\\{ \\boldsymbol e_x, \\boldsymbol e_y, "
"\\boldsymbol e_z \\}`) No es casualidad que :math:`J_z` rotará un vector en "
"el plano :math:`xy` alrededor del eje :math:`z` por :math:`\\pi/2`; para un "
"eje arbitrario :math:`\\boldsymbol n` el operador :math:`J_n \\cong "
"\\boldsymbol n \\times` es rotado por :math:`\\pi/2` alrededor de ese eje "
"para vectores en el plano perpendicular a :math:`\\boldsymbol n`."

#: ../../docs/tutorials/math/rotations.rst:41
msgid ""
"In terms of :math:`J_z`, we can express the infinitesimal rotation operator "
"around the :math:`z`-axis as"
msgstr ""
"En términos de :math:`J_z`, podemos expresar el operador de rotación "
"infinitesimal alrededor del eje :math:`z` como"

#: ../../docs/tutorials/math/rotations.rst:47
msgid ""
"So, how about finite rotations? We simply can apply this infinitesimal "
"rotation operator :math:`N` times to obtain a finite rotation :math:`\\theta "
"\\equiv N \\delta \\theta`:"
msgstr ""
"Entonces, ¿qué tal rotaciones finitas? Simplemente podemos aplicar este "
"operador de rotación infinitesimal :math:`N` veces para obtener una rotación "
"finita :math:`\\theta \\equiv N \\delta \\theta`:"

#: ../../docs/tutorials/math/rotations.rst:53
msgid ""
"(If you're confused about seeing a matrix as an exponent: the meaning of an "
"operator :math:`A` in `exponential map <https://en.wikipedia.org/wiki/"
"Exponential_map_(Lie_theory)>`_ is given by its series expansion as :math:"
"`e^A = 1 + A + A^2/2! + \\ldots` ). This is arguably the most important "
"relation in this write up, and lies at the heart of Lie groups, whose "
"significance will be clarified in a moment. But first, let's take step back "
"and observe the significance of this result: using a simple picture of an "
"infinitesimal rotation, we derived a general expression for arbitrary "
"rotations around the :math:`z`-axis. In fact, this gets even better. If we "
"repeated the same analysis for rotations around :math:`x`- and :math:`y`-"
"axes, we would have obtained similar results :math:`e^{\\theta J_x}` and :"
"math:`e^{\\theta J_y}` respectively, where"
msgstr ""
"(Si estás confundido acerca de ver una matriz como un exponente: el "
"significado de un operador :math:`A` en un `mapa exponencial <https://en."
"wikipedia.org/wiki/Exponential_map_(Lie_theory)>`_ está dado por la "
"expansión de su serie como :math:`e^A = 1 + A + A^2/2! + \\ldots` ). Esta es "
"posiblemente la relación más importante en este artículo, y se sitúa en el "
"corazón de los grupos de Mentiras, cuyo significado será aclarado "
"próximamente. Pero primero, demos un paso atrás y observemos el significado "
"de este resultado: usando una simple imagen de una rotación infinitesimal, "
"derivamos una expresión general para rotaciones arbitrarias alrededor del "
"eje :math:`z`. De hecho, esto se pone aún mejor. Si hubiéramos repetido el "
"mismo análisis para rotaciones alrededor de los ejes :math:`x` y :math:`y`, "
"habríamos obtenido resultados similares a :math:`e^{\\theta J_y}` y :math:"
"`e^{\\theta J_y}` respectivamente, donde"

#: ../../docs/tutorials/math/rotations.rst:68
msgid ""
"Or, if we did a rotation around an arbitrary axis :math:`\\boldsymbol n`, "
"the result would have been"
msgstr ""
"O, si hubiéramos hecho una rotación alrededor de un eje arbitrario :math:`"
"\\boldsymbol n`, el resultado habría sido"

#: ../../docs/tutorials/math/rotations.rst:74
msgid ""
"where :math:`\\boldsymbol J = (J_x, J_y, J_z)`. Note how the rotation axis :"
"math:`\\boldsymbol n` and rotation angle :math:`\\theta` plays a central "
"role in the final expression. Axis-angle is *the* parametrization for *all* "
"Lie groups, not just 3D rotations. (We will come back to this point later "
"when we're discussing Euler angle parametrization, which is an unnatural and "
"defective parametrization of rotations in 3D.)"
msgstr ""
"donde :math:`\\boldsymbol J = (J_x, J_y, J_z)`. Observa cómo el eje de "
"rotación :math:`\\boldsymbol n` y el ángulo de rotación :math:`\\theta` "
"juegan un papel central en la expresión final. Eje-ángulo es *la* "
"parametrización para *todos* los grupos de Lie, no sólo las rotaciones 3D. "
"(Volveremos a este punto más adelante cuando discutamos la parametrización "
"del ángulo de Euler, que es una parametrización antinatural y defectuosa de "
"las rotaciones en 3D.)"

#: ../../docs/tutorials/math/rotations.rst:77
msgid ""
"If you ever tried to derive the rotation matrix corresponding to a :math:`"
"\\theta` rotation around :math:`\\boldsymbol n`, you can appreciate the "
"simplicity and elegance of how we obtained this result. To be fair, we still "
"need to figure out how to actually use an operator sitting on top of an "
"exponent (by summing up the Taylor series), of course, but that's merely a "
"\"programmatic\" labor and you just need to follow the finite multiplication "
"table of :math:`J_i` operators. But this is much straightforward than trying "
"to draw geometric diagrams and angles and figure out the rotation matrix. "
"For the particular case of the algebra corresponding to rotations in 3D "
"Euclidean space that we've been talking about so far, the exponent can "
"simply be written as"
msgstr ""
"Si alguna vez has intentado derivar la matriz de rotación correspondiente a "
"una rotación :math:`\\theta` alrededor de :math:`\\boldsymbol n`, puedes "
"apreciar la simplicidad y elegancia de cómo obtuvimos este resultado. Para "
"ser justos, todavía necesitamos averiguar cómo usar un operador situado "
"encima de un exponente (resumiendo la serie de Taylor), por supuesto, pero "
"eso es meramente una labor \"programática\" y sólo necesitamos seguir la "
"tabla de multiplicación finita de operadores :math:`J_i`. Pero esto es mucho "
"más sencillo que tratar de dibujar diagramas geométricos y ángulos y "
"calcular la matriz de rotación. Para el caso particular del álgebra "
"correspondiente a las rotaciones en el espacio Euclídeo 3D del que hemos "
"estado hablando hasta ahora, el exponente puede escribirse simplemente como"

#: ../../docs/tutorials/math/rotations.rst:83
msgid ""
"which is known as Rodrigues' rotation formula. Note that we only ended up "
"with terms up to second order in :math:`\\boldsymbol n \\cdot \\boldsymbol "
"J` when we summed the series expansion; the reason is higher powers can be "
"reduced to 0th, 1st or 2nd order terms due to the relation :math:"
"`(\\boldsymbol n \\cdot \\boldsymbol J)^3 = -\\boldsymbol n \\cdot "
"\\boldsymbol J`, which makes summing up the series straightforward."
msgstr ""
"que se conoce como la fórmula de rotación de Rodrigues. Nótese que sólo "
"terminamos con términos de segundo orden en :math:`\\boldsymbol n \\cdot "
"\\boldsymbol J` cuando sumamos la expansión de la serie; la razón es que las "
"potencias superiores pueden ser reducidas a términos de 0º, 1er o 2º orden "
"debido a la relación :math:`(\\boldsymbol n \\cdot \\boldsymbol J)^3 = -"
"\\boldsymbol n \\cdot \\boldsymbol J`, lo que hace que resumir la serie sea "
"sencillo."

#: ../../docs/tutorials/math/rotations.rst:85
msgid ""
"The thing that sits on top of :math:`e`, which is a linear combination :math:"
"`J_i` operators (where :math:`i = x,y,z`), forms an algebra; in fact, it "
"forms a vector space whose basis \"vectors\" are :math:`J_i`. Furthermore, "
"the algebra is closed under the Lie bracket (which is essentially a "
"commutator: :math:`[a,b] = a b - ba`, and is something like a cross-product "
"in this vector space). In the particular case of 3D rotations, this "
"\"multiplication table\" is :math:`[J_x, J_y] = J_z` and its cyclic "
"permutations :math:`x\\to y, y\\to z, z\\to x`."
msgstr ""
"Lo que se encuentra encima de los operadores :math:`e`, que es una "
"combinación lineal :math:`J_i` (donde :math:`i = x,y,z`), forma un álgebra; "
"de hecho, forma un espacio vectorial cuyos \"vectores\" base son :math:"
"`J_i`. Además, el álgebra se cierra bajo el corchete de Lie (que es "
"esencialmente un conmutador: :math:`[a,b] = a b - ba`, y es algo así como un "
"producto cruzado en este espacio vectorial). En el caso particular de las "
"rotaciones 3D, esta \"tabla de multiplicación\" es :math:`[J_x, J_y] = J_z` "
"and its cyclic permutations :math:`x\\to y, y\\to z, z\\to x`."

#: ../../docs/tutorials/math/rotations.rst:87
msgid ""
"Rotations form what is called a `group <https://en.wikipedia.org/wiki/"
"Group_(mathematics>`_: simply put, it means that if you combine two "
"rotations, you get another rotation. And you can observe it here too: when "
"you put an element of the Lie algebra (which are simply linear combinations "
"of :math:`J_i` ) on top of :math:`e`, you get what is called a Lie group, "
"and the Lie algebra is said to *generate* the Lie group. For example, the "
"operator :math:`J_z \\equiv \\boldsymbol e_z \\times` is said to *generate* "
"the rotations around the :math:`z`-axis. The group of rotations in the 3D "
"Euclidean space is called SO(3)."
msgstr ""
"Las rotaciones forman lo que se llama un `grupo <https://es.wikipedia.org/"
"wiki/Grupo_(matem%C3%A1tica)>`_: en pocas palabras, significa que si "
"combinas dos rotaciones, obtienes otra rotación. Y puedes observarlo aquí "
"también: cuando pones un elemento del álgebra de Lie (que son simplemente "
"combinaciones lineales de :math:`J_i`) encima de :math:`e`, obtienes lo que "
"se llama un grupo de Lie, y se dice que el álgebra de Lie *genera* el grupo "
"de Lie. Por ejemplo, se dice que el operador :math:`J_z \\equiv \\boldsymbol "
"e_z \\times` *genera* las rotaciones alrededor del eje `z`. El grupo de "
"rotaciones en el espacio euclídeo 3D se llama SO(3)."

#: ../../docs/tutorials/math/rotations.rst:89
msgid ""
"The order of rotations in 2D don't matter: you can first rotate by :math:`"
"\\pi` and rotate by :math:`\\pi/2`, or do it in reverse order, and either "
"way, the result is a rotation by :math:`3 \\pi/2` in the plane. But the "
"order of rotations in 3D do matter, in general, when different rotation axes "
"are involved (see `this picture <https://i.stack.imgur.com/6vvFi.png>`_ for "
"an example) (rotations around the same axes do commute, of course). When the "
"ordering of group elements don't matter, that group is said to be Abelian, "
"and non-Abelian otherwise. SO(2) is an Abelian group, and SO(3) is a non-"
"Abelian group."
msgstr ""
"El orden de rotaciones en 2D no importa: primero puedes rotar por :math:`"
"\\pi` y rotar por :math:`\\pi/2`, o hacerlo en orden inverso, y de cualquier "
"manera, el resultado es una rotación por :math:`3 \\pi/2` en el plano. Pero "
"el orden de las rotaciones en 3D importa, en general, cuando se trata de "
"diferentes ejes de rotación (ver `esta imagen <https://i.stack.imgur."
"com/6vvFi.png>`_ para un ejemplo) (las rotaciones alrededor de los mismos "
"ejes viajan, por supuesto). Cuando el orden de los elementos del grupo no "
"importa, se dice que ese grupo es abeliano, y de otra manera no abeliano. "
"SO(2) es un grupo abeliano, y SO(3) es un grupo no-abeliano."

#: ../../docs/tutorials/math/rotations.rst:91
msgid ""
"Lie groups and algebras are *not* matrices. You can *represent* both by "
"using object which emulate their \"multiplication\" rules: this can be real "
"or complex matrices of varying dimensions, or something like quaternions. A "
"single Lie group/algebra have infinitely many different representations in "
"vector spaces in different dimensions (see `these <https://en.wikipedia.org/"
"wiki/Rotation_group_SO(3)#A_note_on_Lie_algebra>`_ for example for SO(3)). "
"Above, we use the 3D real representation of SO(3), which happens to be the "
"fundamental representation, and accidentally coincides with the adjoint "
"representation."
msgstr ""
"Los grupos de Lie y las algebras *no* son matrices. Se pueden *representar* "
"ambos usando objetos que emulen sus reglas de \"multiplicación\": pueden ser "
"matrices reales o complejas de dimensiones variables, o algo así como "
"cuaterniones. Un solo grupo de Lie/álgebra tiene infinitamente muchas "
"representaciones diferentes en espacios vectoriales de diferentes "
"dimensiones (ver `esto <https://en.wikipedia.org/wiki/"
"Rotation_group_SO(3)#A_note_on_Lie_algebra>`_ por ejemplo para SO(3)). "
"Arriba, utilizamos la representación real 3D de SO(3), que resulta ser la "
"representación fundamental, y coincide accidentalmente con la representación "
"adjunta."

#: ../../docs/tutorials/math/rotations.rst:94
msgid "Some mathematical remarks (feel free to skip)"
msgstr "Algunos comentarios matemáticos (siéntete libre de omitirlos)"

#: ../../docs/tutorials/math/rotations.rst:96
msgid ""
"There are many different Lie groups, corresponding to different symmetries, "
"and they all have different names. For example, the group which contains all "
"rotations in :math:`n`-dimensional Euclidean space is called SO(:math:`n`), "
"and has :math:`n (n-1)/2` linearly independent generators (yes, Lie groups "
"can handle rotations is higher dimensions as-is, and even in non-Euclidean "
"ones). This is called the *rank* of the Lie algebra. You can think of the "
"generators as independent axes of rotations. For 2D, we can only rotate in "
"the :math:`xy` plane meaning we have only 1 generator. For 3D, you can "
"rotate around 3 different planes/axes."
msgstr ""
"Hay muchos grupos de Lie diferentes, que corresponden a diferentes "
"simetrías, y todos tienen diferentes nombres. Por ejemplo, el grupo que "
"contiene todas las rotaciones en el espacio euclidiano :math:`n`-dimensional "
"se llama SO(:math:`n`), y tiene :math:`n (n-1)/2` generadores linealmente "
"independientes (sí, los grupos de Lie pueden manejar rotaciones de "
"dimensiones más altas tal cual, e incluso en los no euclidianos). Esto se "
"llama el *rango* del álgebra de Lie. Se puede pensar en los generadores como "
"ejes de rotación independientes. Para 2D, sólo podemos rotar en el plano :"
"math:`xy` lo que significa que sólo tenemos 1 generador. Para 3D, se puede "
"rotar alrededor de 3 planos/ejes diferentes."

#: ../../docs/tutorials/math/rotations.rst:98
msgid ""
"Lie groups have deep connections with symmetries, and have played central "
"role in theoretical physics since around mid 20th century."
msgstr ""
"Los grupos de Lie tienen profundas conexiones con las simetrías y han jugado "
"un papel central en la física teórica desde mediados del siglo XX."

#: ../../docs/tutorials/math/rotations.rst:100
msgid ""
"For example, if something is symmetric under 3D rotation, that something (in "
"physics, it is typically Lagrangian, which leads to conservation laws "
"through Noether's theorem) remains invariant under SO(3) transformations (we "
"will cover transformations below)."
msgstr ""
"Por ejemplo, si algo es simétrico bajo rotación 3D, ese algo (en física, es "
"típicamente lagrangiano, lo que lleva a las leyes de conservación a través "
"del teorema de Noether) permanece invariable bajo las transformaciones SO(3) "
"(cubriremos las transformaciones a continuación)."

#: ../../docs/tutorials/math/rotations.rst:103
msgid ""
"In the context of Lie groups and group theory in general, some common words "
"have specific meanings and a part of the math jargon: representation, "
"generator, group, algebra, parametrization, operator are such words. You "
"don't need to know their precise definitions to understand this write up; "
"just be aware that they are special terms and may not mean what you think "
"they mean. All of these terms a described in this write up in a colloquial "
"language."
msgstr ""
"En el contexto de los grupos de Lie y la teoría de grupos en general, "
"algunas palabras comunes tienen significados específicos y una parte de la "
"jerga matemática: representación, generador, grupo, álgebra, "
"parametrización, operador son tales palabras. No es necesario que conozcas "
"sus definiciones precisas para entender esta redacción; sólo ten en cuenta "
"que son términos especiales y pueden no significar lo que crees que "
"significan. Todos estos términos se describen en este artículo en un "
"lenguaje coloquial."

#: ../../docs/tutorials/math/rotations.rst:109
msgid "Representation of rotations"
msgstr "Representación de rotaciones"

#: ../../docs/tutorials/math/rotations.rst:111
msgid ""
"Representation of rotations is an independent concept from parametrization "
"of rotations. These two concepts are commonly conflated, which leads to the "
"current state of confusion among many programmers. People tend to associate "
"Euler angles parametrization with matrices (or sometimes even vectors!), and "
"axis-angle parametrization with quaternions."
msgstr ""
"La representación de rotaciones es un concepto independiente de la "
"parametrización de rotaciones. Estos dos conceptos son comúnmente mezclados, "
"lo que lleva al estado actual de confusión entre muchos programadores. La "
"gente tiende a asociar la parametrización de los ángulos de Euler con "
"matrices (¡o a veces incluso con vectores!), y la parametrización del eje-"
"ángulo con cuaterniones."

#: ../../docs/tutorials/math/rotations.rst:113
msgid ""
"In game engines, rotation operators are represented using either matrices, "
"or quaternions. *As will be clear in what follows, you can use a matrix or a "
"quaternion to represent a rotation parameterized using Euler angles, and "
"same goes for axis-angle parametrization.* Unfortunately, even graphics "
"programming books and documentations of expensive game engines often make a "
"mistake here, and this causes programmers to start comparing Euler angles (a "
"parametrization) to quaternions (a representation) and even discussing their "
"trade-offs, which is \"not even wrong\"."
msgstr ""
"En los motores de juego, los operadores de rotación se representan "
"utilizando matrices o cuaterniones. Desafortunadamente, incluso los libros "
"de programación de gráficos y las documentaciones de motores de juego caros "
"a menudo cometen un error aquí, y esto hace que los programadores comiencen "
"a comparar los ángulos de Euler (una parametrización) con los cuaterniones "
"(una representación) e incluso a discutir sus equilibrios, lo que \"ni "
"siquiera es incorrecto\"."

#: ../../docs/tutorials/math/rotations.rst:115
msgid ""
"`Representation <https://en.wikipedia.org/wiki/Group_representation>`_ here "
"refers to a technical term in group theory. So will many other things that "
"will be mentioned in what follows. To gain a basic understand of these "
"concepts, let's first go through simpler and better understood example of "
"rotations in 2D first."
msgstr ""
"`Representación de grupo <https://es.wikipedia.org/wiki/Representaci"
"%C3%B3n_de_grupo>`_ aquí se refiere a un término técnico de la teoría de "
"grupos. Así como muchas otras cosas que se mencionarán en lo que sigue. Para "
"obtener una comprensión básica de estos conceptos, primero pasemos a través "
"de ejemplos más simples y mejor entendidos de rotaciones en 2D."

#: ../../docs/tutorials/math/rotations.rst:119
msgid "Representation of rotations in 2D"
msgstr "Representación de rotaciones en 2D"

#: ../../docs/tutorials/math/rotations.rst:121
msgid ""
"Since there is only one possible axis of rotation in a two dimensional "
"plane, there is no Euler angle parametrization for them (or if you like, "
"there is only one Euler-angle). Rather, axis-angle parametrization is used, "
"with the axis being fixed to z-axis, which leaves only the angle of "
"rotation :math:`\\varphi` as a free parameter."
msgstr ""
"Dado que sólo hay un eje de rotación posible en un plano bidimensional, no "
"hay parametrización del ángulo de Euler para ellos (o si lo prefieres, sólo "
"hay un ángulo de Euler). En su lugar, se utiliza la parametrización eje-"
"ángulo, fijando el eje al eje z, lo que deja sólo el ángulo de rotación :"
"math:`\\varphi` como parámetro libre."

#: ../../docs/tutorials/math/rotations.rst:123
msgid ""
"A point in the 2D Euclidean space can be represented by a pair of 2D real "
"numbers as :math:`\\boldsymbol v = (x,y)` (called vector representation), or "
"they can alternatively be represented by a complex number as :math:`v = x + "
"\\imath y` where :math:`\\imath \\equiv \\sqrt{-1}` is the unit imaginary "
"number. In the vector representation, we can rotate the point through a "
"rotation matrix (an element of the Lie group SO(2), which can be represented "
"by :math:`2 \\times 2` orthogonal matrices with determinant +1) as follows:"
msgstr ""
"Un punto en el espacio 2D euclidiano puede ser representado por un par de "
"números reales 2D como :math:`\\boldsymbol v = (x,y)` (llamado "
"representación vectorial), o alternativamente pueden ser representados por "
"un número complejo como :math:`v = x + \\imath y` donde :math:`\\imath "
"\\equiv \\sqrt{-1}` es un número imaginario de la unidad. En la "
"representación vectorial, podemos rotar el punto a través de una matriz de "
"rotación (un elemento del grupo Lie SO(2), el cual puede ser representado "
"por matrices ortogonales :math:`2 \\times 2` con determinante +1) como sigue:"

#: ../../docs/tutorials/math/rotations.rst:133
msgid ""
"So for example, when :math:`\\theta=\\pi/2`, we get :math:`R(\\pi/2) "
"\\boldsymbol v = (-y,x)`."
msgstr ""
"Así, por ejemplo, cuando :math:`\\theta=\\pi/2`, obtenemos :math:`R(\\pi/2) "
"\\boldsymbol v = (-y,x)`."

#: ../../docs/tutorials/math/rotations.rst:135
msgid ""
"In the complex representation, a rotation is represented by  a unit complex "
"number :math:`e^{\\imath\\theta} = \\cos\\theta + \\imath \\sin\\theta`, "
"where we used `Euler's formula <https://en.wikipedia.org/wiki/Euler"
"%27s_formula>`_, is an element of the Lie group U(1), which can be "
"represented by complex numbers of unit norm. Again, for :math:`\\theta="
"\\pi/2`, you recover :math:`e^{\\imath\\pi/2}(x+\\imath y) = \\imath(x+"
"\\imath y) = (-y) + \\imath x`."
msgstr ""
"En la representación compleja, una rotación está representada por un número "
"complejo de unidades :math:`e^{\\imath\\theta} = \\cos\\theta + \\imath \\sin"
"\\theta`, donde usamos la `fórmula de Euler <https://es.wikipedia.org/wiki/F"
"%C3%B3rmula_de_Euler>`_, es un elemento del grupo de Lie U(1), que puede ser "
"representado por números complejos de la norma unitaria. Una vez más, para :"
"math:`\\theta=\\pi/2`, recuperas :math:`e^{\\imath\\pi/2}(x+\\imath y) = "
"\\imath(x+\\imath y) = (-y) + \\imath x`."

#: ../../docs/tutorials/math/rotations.rst:137
msgid ""
"Rotations in the complex number representation look simpler, but it's only "
"an illusion: the complications of performing a matrix multiplication is "
"absorbed by the introduction of something that lives outside of the realm of "
"real numbers, which follows a rather \"odd\" algebra: :math:`\\imath^2 = "
"-1`. The way complex numbers mimic 2D rotations can be made clearer if we "
"rewrite the rotation matrix in terms of"
msgstr ""
"Las rotaciones en la representación de números complejos parecen más "
"simples, pero es sólo una ilusión: las complicaciones de realizar una "
"multiplicación matricial son absorbidas por la introducción de algo que vive "
"fuera del reino de los números reales, que sigue a un álgebra bastante "
"\"extraña\": :math:`\\imath^2 = -1`. La manera en que los números complejos "
"imitan las rotaciones 2D puede ser más clara si reescribimos la matriz de "
"rotación en términos de"

#: ../../docs/tutorials/math/rotations.rst:151
msgid ""
"as :math:`R(\\theta) = I_2 \\cos\\theta  + J_z \\sin\\theta`, which can then "
"be compared to :math:`1 x + \\imath y` directly. Now we can see the "
"equivalence (the technical term is `isomorphism <https://en.wikipedia.org/"
"wiki/Group_isomorphism>`_ in this context) of the representations clearer "
"through their multiplication table: :math:`I_2 I_2 = I_2, I_2 J_z = J_z, J_z "
"I_2 = J_z, J_z J_z = -I_2` which behaves the same way as :math:`1 \\times 1 "
"= 1, 1 \\times \\imath = \\imath, \\imath \\times 1 = \\imath, \\imath "
"\\times \\imath = -1`. Also note that both :math:`\\imath` and :math:`J_z` "
"represent a :math:`\\pi/2` rotation. And as it should be, :math:`\\imath` "
"and :math:`J_z` behave the same under multiplication."
msgstr ""
"que puede ser comparada con :math:`R(\\theta) = I_2 \\cos\\theta  + J_z \\sin"
"\\theta`directamente. Ahora podemos ver la equivalencia (el término técnico "
"es `isomorfismo <https://en.wikipedia.org/wiki/Group_isomorphism>`_ en este "
"contexto) de las representaciones más claras a través de su tabla de "
"multiplicación: :math:`I_2 I_2 = I_2, I_2 J_z = J_z, J_z I_2 = J_z, J_z J_z "
"= -I_2` lo cual se comporta de la misma manera que :math:`1 \\times 1 = 1, 1 "
"\\times \\imath = \\imath, \\imath \\times 1 = \\imath, \\imath \\times "
"\\imath = -1`. También ten en cuenta que tanto :math:`\\imath` como :math:"
"`J_z` representan una rotación de  :math:`\\pi/2`. Y como debe ser, :math:`"
"\\imath` and :math:`J_z` se comportan igual en la multiplicación."

#: ../../docs/tutorials/math/rotations.rst:153
msgid ""
"Furthermore, by Taylor series expansion, it is straightforward to show that :"
"math:`R(\\theta) = e^{J_z \\theta}`."
msgstr ""
"Además, mediante la expansión de la serie de Taylor, es sencillo mostrar "
"que :math:`R(\\theta) = e^{J_z \\theta}`."

#: ../../docs/tutorials/math/rotations.rst:155
msgid "We have then the following table:"
msgstr "Tenemos entonces la siguiente tabla:"

#: ../../docs/tutorials/math/rotations.rst:160
#: ../../docs/tutorials/math/rotations.rst:292
msgid "What"
msgstr "Lo que"

#: ../../docs/tutorials/math/rotations.rst:160
msgid "Matrix representation of SO(2)"
msgstr "Representación de la matriz de SO(2)"

#: ../../docs/tutorials/math/rotations.rst:160
msgid "Complex representation of U(1)"
msgstr "Representación compleja de U(1)"

#: ../../docs/tutorials/math/rotations.rst:162
#: ../../docs/tutorials/math/rotations.rst:294
msgid "Vector"
msgstr "Vector"

#: ../../docs/tutorials/math/rotations.rst:162
msgid ":math:`(x,y)`"
msgstr ":math:`(x,y)`"

#: ../../docs/tutorials/math/rotations.rst:162
msgid ":math:`x+\\imath y`"
msgstr ":math:`x+\\imath y`"

#: ../../docs/tutorials/math/rotations.rst:164
#: ../../docs/tutorials/math/rotations.rst:296
msgid "Generator"
msgstr "Generador"

#: ../../docs/tutorials/math/rotations.rst:164
msgid ":math:`J_z \\cong \\begin{pmatrix} 0 & -1 \\\\ 1 & 0 \\end{pmatrix}`"
msgstr ":math:`J_z \\cong \\begin{pmatrix} 0 & -1 \\\\ 1 & 0 \\end{pmatrix}`"

#: ../../docs/tutorials/math/rotations.rst:164
msgid ":math:`J_z \\cong \\imath`"
msgstr ":math:`J_z \\cong \\imath`"

#: ../../docs/tutorials/math/rotations.rst:166
#: ../../docs/tutorials/math/rotations.rst:298
msgid "Rotation operator"
msgstr "Operador de rotación"

#: ../../docs/tutorials/math/rotations.rst:166
msgid ""
":math:`e^{J_z \\theta} \\equiv I_2 \\cos\\theta + J_z\\sin\\theta \\equiv "
"\\begin{pmatrix}\\cos\\theta & -\\sin\\theta \\\\\\sin\\theta & \\cos\\theta "
"\\end{pmatrix}`"
msgstr ""
":math:`e^{J_z \\theta} \\equiv I_2 \\cos\\theta + J_z\\sin\\theta \\equiv "
"\\begin{pmatrix}\\cos\\theta & -\\sin\\theta \\\\\\sin\\theta & \\cos\\theta "
"\\end{pmatrix}`"

#: ../../docs/tutorials/math/rotations.rst:166
msgid ""
":math:`e^{J_z \\theta} \\equiv e^{\\imath\\theta} = 1 \\cos\\theta + \\imath "
"\\sin\\theta`"
msgstr ""
":math:`e^{J_z \\theta} \\equiv e^{\\imath\\theta} = 1 \\cos\\theta + \\imath "
"\\sin\\theta`"

#: ../../docs/tutorials/math/rotations.rst:169
msgid ""
"Clearly, introduction of the unit imaginary number is enough to capture the "
"behavior of 2D rotation matrices. As a footnote remark, while the number :"
"math:`e^{\\imath\\theta}` can only represent a rotation matrix, it can't of "
"course represent an arbitrary :math:`2 \\times 2` matrix (meaning no "
"scaling, no shearing, etc): after all, U(1) isn't isomorphic to :math:`"
"\\text{GL}(2, \\mathbb R)`, the group of all (invertible) real :math:"
"`2\\times 2` matrices."
msgstr ""
"Claramente, la introducción del número imaginario unitario es suficiente "
"para capturar el comportamiento de las matrices de rotación 2D. Como nota al "
"pie de página, mientras que el número :math:`e^{{imath{theta}` sólo puede "
"representar una matriz de rotación, por supuesto no puede representar una "
"matriz arbitraria :math:`2 \\times 2` (lo que significa que no hay escalado, "
"roturas, etc): después de todo, U(1) no es isomorfo para `:math:`\\text{GL}"
"(2, \\mathbb R)`, el grupo de todas las matrices reales (invertibles) de :"
"math:`2\\times 2`."

#: ../../docs/tutorials/math/rotations.rst:171
msgid ""
"The equivalence of these two seemingly different way of representing vectors "
"and rotations in 2D lies in the `isomorphism between the Lie groups SO(2) "
"and U(1) <https://en.wikipedia.org/wiki/Circle_group#Isomorphisms>`_."
msgstr ""
"La equivalencia de estas dos formas aparentemente diferentes de representar "
"vectores y rotaciones en 2D radica en el `isomorfismo entre los grupos de "
"Lie SO(2) y U(1) <https://en.wikipedia.org/wiki/Circle_group#Isomorphisms>`_."

#: ../../docs/tutorials/math/rotations.rst:174
msgid ""
"Furthermore, in this representation, it is clear that you can do a \"smooth"
"\" rotation by slowly changing :math:`\\theta`, which is the 2D analogue of "
"SLERP (could as well be called Circular Linear Interpolation!). Note that if "
"you linearly interpolate the *elements* of two rotation matrices (that is, "
"linearly interpolating between :math:`R_{ij}` and :math:`R'_{ij}` ), you'll "
"get a weird trajectory with jerky motion; to do SLERP with a matrix, you "
"need to extract the angles from each matrix (which can only happen for "
"matrices whose entries have to form given by :math:`R(\\theta)` above; that "
"is, elements of SO(2)), interpolate between the angles linearly, and "
"construct the intermediate matrix using that angle."
msgstr ""
"Además, en esta representación, está claro que se puede hacer una rotación "
"\"suave\" cambiando lentamente :math:`\\theta`, que es el análogo 2D de "
"SLERP (¡también podría llamarse Interpolación Lineal Circular!). Si se "
"interpolan linealmente los *elementos* de dos matrices de rotación (es "
"decir, interpolando linealmente entre :math:`R_{ij}` y :math:`R'_{ij}` ), se "
"obtendrá una trayectoria extraña con un movimiento espasmódico; para hacer "
"SLERP con una matriz, es necesario extraer los ángulos de cada matriz (lo "
"que sólo puede ocurrir para matrices cuyas entradas tienen que formarse por :"
"math:`R(\\theta)` arriba; es decir, elementos de SO(2)), interpolar entre "
"los ángulos linealmente, y construir la matriz intermedia usando ese ángulo."

#: ../../docs/tutorials/math/rotations.rst:176
msgid ""
"The take-aways of this short visit to the more understandable 2D land are:"
msgstr ""
"Las ventajas más comprensibles de esta breve visita a la tierra 2D son:"

#: ../../docs/tutorials/math/rotations.rst:178
msgid ""
"There can be different (but \"equivalent\", of course) *representations* of "
"rotations: like matrices and complex numbers."
msgstr ""
"Puede haber diferentes (pero \"equivalentes\", por supuesto) "
"*representaciones* de rotaciones: como matrices y números complejos."

#: ../../docs/tutorials/math/rotations.rst:179
msgid ""
"Despite the fact that you can use complex numbers to represent vectors and "
"rotations in 2D, the *concept* of rotations in 2D doesn't require an "
"understanding/knowledge of complex numbers or Euler's formula."
msgstr ""
"A pesar de que se pueden usar números complejos para representar vectores y "
"rotaciones en 2D, el *concepto* de rotaciones en 2D no requiere un "
"entendimiento/conocimiento de números complejos o de la fórmula de Euler."

#: ../../docs/tutorials/math/rotations.rst:180
msgid ""
"The introduction of the imaginary :math:`\\imath` is not black magic: it's "
"just something that mimics :math:`2 \\times 2` matrix :math:`J_z`: :math:`1` "
"and :math:`\\imath` behave the same way as :math:`I_2` and :math:`J_z` under "
"multiplication (see the group multiplication table given above)."
msgstr ""
"La introducción del imaginario :math:`\\imath` no es magia negra: es algo "
"que se imita a la matriz de :math:`2 \\times 2` :math:`J_z`: `math:`1` y :"
"math:`\\imath` se comportan de la misma manera que :math:`I_2` and :math:"
"`J_z` en la multiplicación (ver la tabla de multiplicación de grupos "
"mostrada más arriba)."

#: ../../docs/tutorials/math/rotations.rst:182
msgid ""
"These are often sources of confusion in 3D: introducing a third dimension "
"means we have new rotation axes (rotations around X and Y axes) giving rise "
"to alternative parametrizations (such as Euler angles), and new generators :"
"math:`J_x` and :math:`J_y`, which will be the generalization of :math:`J_z` "
"above."
msgstr ""
"Éstas son a menudo fuentes de confusión en 3D: introducir una tercera "
"dimensión significa que tenemos nuevos ejes de rotación (rotaciones "
"alrededor de los ejes X e Y) dando lugar a parametrizaciones alternativas "
"(como los ángulos de Euler), y nuevos generadores :math:`J_x` y `mateh:"
"`J_y`, que será la generalización de :math:`J_z` arriba."

#: ../../docs/tutorials/math/rotations.rst:186
msgid "Some mathematical remarks (again, feel free to skip)"
msgstr ""
"Algunos comentarios matemáticos (de nuevo, siéntete libre de omitirlos)"

#: ../../docs/tutorials/math/rotations.rst:187
msgid ""
"The fact that SO(3) has 3 generators is an accident: SO(:math:`n`) has :math:"
"`n(n-1)/2` generators. Furthermore, the next step (after quaternions, which "
"is `another accident <https://en.wikipedia.org/wiki/"
"Spin_group#Accidental_isomorphisms>`_) of `Cayley-Dickson construction "
"<https://en.wikipedia.org/wiki/Cayley%E2%80%93Dickson_construction>`_ does "
"*not* correspond to a Lie algebra, but rather a non-associative algebra "
"called `octonions <https://en.wikipedia.org/wiki/Octonion>`_. Rather, in "
"arbitrary dimensions, the \"complex\" representation can be written using "
"the generators of Spin(:math:`n`), which is a double cover of SO(:math:`n`). "
"Also, throughout this page, when we say representation of SO(2), U(1) or any "
"other group, we are talking about the `*fundamental* <https://en.wikipedia."
"org/wiki/Fundamental_representation>`_ `irreducible representation <https://"
"en.wikipedia.org/wiki/Irreducible_representation>`_, corresponding to a "
"`Young diagram <https://en.wikipedia.org/wiki/Young_tableau>`_ with a single "
"box."
msgstr ""
"El hecho de que SO(3) tenga 3 generadores es un accidente: SO(:math:`n`) "
"tiene :math:`n(n-1)/2` generadores. Además, el siguiente paso (después de "
"los cuaternios, que es `otro accidente <https://en.wikipedia.org/wiki/"
"Spin_group#Accidental_isomorphisms>`_) de `construcción de Cayley-Dickson "
"<https://en.wikipedia.org/wiki/Cayley%E2%80%93Dickson_construction>`_ no "
"corresponde a un álgebra Lie, sino a un álgebra no asociativa llamada "
"`octonions <https://en.wikipedia.org/wiki/Octonion>`_. Más bien, en "
"dimensiones arbitrarias, la representación \"compleja\" puede ser escrita "
"usando los generadores de Spin(:math:`n`), que es una doble portada de SO(:"
"math:`n`). Además, a lo largo de esta página, cuando decimos representación "
"de SO(2), U(1) o cualquier otro grupo, estamos hablando de la `*fundamental* "
"<https://en.wikipedia.org/wiki/Fundamental_representation>`_ `representación "
"irreductible <https://en.wikipedia.org/wiki/Irreducible_representation>`_, "
"correspondiente a un `Diagrama joven <https://en.wikipedia.org/wiki/"
"Young_tableau>`_ con una sola casilla."

#: ../../docs/tutorials/math/rotations.rst:191
msgid "Representation of rotations in 3D"
msgstr "Representación de rotaciones en 3D"

#: ../../docs/tutorials/math/rotations.rst:193
msgid ""
"Let's first review how 3D rotations work using familiar vectors and matrices."
msgstr ""
"Primero repasemos cómo funcionan las rotaciones 3D usando vectores y "
"matrices ya conocidos."

#: ../../docs/tutorials/math/rotations.rst:195
msgid ""
"In 2D, we considered vectors lying in the :math:`xy` plane, and the only "
"axis we could can rotate them was the :math:`z`-axis. In 3D, we can perform "
"a rotation around any axis. And this doesn't just mean around :math:`x, y, "
"z` axes, the rotation can also be around an axis which is a linear "
"combination of those, where :math:`\\boldsymbol n` is the unit vector "
"(meaning :math:`\\boldsymbol n \\cdot \\boldsymbol n = 1` ) aligned with the "
"axis we want to perform the rotation."
msgstr ""
"En 2D, consideramos vectores que yacen en el plano :math:`xy`, y el único "
"eje que podíamos rotarlos era el eje :math:`z`. En 3D, podemos realizar una "
"rotación alrededor de cualquier eje. Y esto no sólo significa alrededor de "
"los ejes `x, y, z`, la rotación también puede ser alrededor de un eje que es "
"una combinación lineal de ellos, donde :math:`\\boldsymbol n` es el vector "
"unitario (es decir, :math:`\\boldsymbol n \\cdot \\boldsymbol n = 1` ) "
"alineado con el eje que queremos realizar la rotación."

#: ../../docs/tutorials/math/rotations.rst:198
msgid ""
"Just like the 2D rotation matrix, the 3D rotation matrix can also be derived "
"with some effort by drawing lots of arrows and angles and some linear "
"algebra, but this would be opaque and won't give us much insight to what's "
"going on. A less straightforward, but more rewarding way of deriving this "
"matrix is to understand the rotation group SO(3)."
msgstr ""
"Al igual que la matriz de rotación 2D, la matriz de rotación 3D también "
"puede ser derivada con un poco de esfuerzo dibujando muchas flechas y "
"ángulos y algo de álgebra lineal, pero esto sería opaco y no nos dará mucha "
"información de lo que está pasando. Una forma menos directa, pero más "
"gratificante de derivar esta matriz es entender el grupo de rotación SO(3)."

#: ../../docs/tutorials/math/rotations.rst:200
msgid ""
"SO(3) is the group of rotations in Euclidean 3D space (for which the "
"`signature <https://en.wikipedia.org/wiki/Metric_signature>`_ is :math:`(+1,"
"+1,+1)`), which preserve the magnitude and handedness of the vectors it acts "
"on. The most typical way to represent its elements is to use :math:`3 "
"\\times 3` real orthogonal matrices with determinant :math:`+1`. This :math:`"
"\\text{Mat}(3, \\mathbb R)` representation is called the fundamental "
"representation of SO(3)."
msgstr ""
"SO(3) es el grupo de rotaciones en el espacio 3D euclidiano (cuya `firma "
"<https://en.wikipedia.org/wiki/Metric_signature>`_ es :math:`(+1,+1,+1)`), "
"que conservan la magnitud y procedencia de los vectores sobre los que actúa. "
"La forma más típica de representar sus elementos es usar matrices "
"ortogonales reales de :math:`3 \\times 3` con determinante :math:`+1`. Esta "
"representación se llama la representación fundamental de SO(3)."

#: ../../docs/tutorials/math/rotations.rst:202
msgid ""
"To recap what we discussed earlier, SO(3) has 3 generators, :math:`J_x, J_y, "
"J_z` and we found that they can be represented using these :math:`3\\times "
"3` real matrices:"
msgstr ""
"Para recapitular lo que hablamos antes, SO(3) tiene 3 generadores, :math:"
"`J_x, J_y, J_z` y encontramos que pueden ser representados usando las "
"siguientes :math:`3\\times 3` matrices reales:"

#: ../../docs/tutorials/math/rotations.rst:223
msgid ""
"These matrices have the same \"multiplication table\" as :math:`J_i` "
"(they're isomorphic), so for all practical purposes, you can replace the "
"operators with their matrix representations."
msgstr ""
"Estos matrices tienen la misma \"tabla de multiplicación\" que :math:`J_i` "
"(son isomórficos), así que para todos los efectos prácticos, puede "
"reemplazar los operadores con sus representaciones matriciales."

#: ../../docs/tutorials/math/rotations.rst:225
msgid "We also found that an element of SO(3), that is, a rotation operator is"
msgstr ""
"También encontramos que un elemento de SO(3), es decir, un operador de "
"rotación es"

#: ../../docs/tutorials/math/rotations.rst:231
msgid ""
"If you want, you can plug-in the matrix representations for :math:`J_i` and "
"derive the complicated :math:`3\\times 3` rotation matrix which is"
msgstr ""
"Si quieres, puedes conectar las representaciones de la matriz para :math:"
"`J_i` y derivar la complicada matriz de rotación :math:`3\\times 3 que es"

#: ../../docs/tutorials/math/rotations.rst:242
msgid ""
"(Hint: you can use the relation :math:`(\\boldsymbol n \\cdot \\boldsymbol "
"J)^2 = \\boldsymbol n \\otimes \\boldsymbol n-I` to quickly evaluate the "
"last term in the Rodrigues' formula, where :math:`\\otimes` is the "
"`Kronecker product <https://en.wikipedia.org/wiki/Kronecker_product>`_ which "
"is also called `outer product <https://en.wikipedia.org/wiki/"
"Outer_product>`_ for vectors. Using the `half-angle formulae <https://en."
"wikipedia.org/wiki/List_of_trigonometric_identities#Half-angle_formulae>`_ "
"to rewrite :math:`\\sin\\varphi = 2 \\cos\\frac{\\varphi}{2} \\sin"
"\\frac{\\varphi}{2}`  and :math:`1-\\cos\\varphi = 2 \\sin^2\\frac{\\varphi}"
"{2}` in Rodrigues' formula, you can use cosine and sine terms as a visual "
"aid when comparing to the matrix form.)"
msgstr ""
"(Pista: puedes usar la relación :math:`(\\boldsymbol n \\cdot \\boldsymbol "
"J)^2 = \\boldsymbol n \\otimes \\boldsymbol n-I` para evaluar rápidamente el "
"último término de la fórmula de Rodrigues, donde :math:`\\otimes` es el "
"`producto de Kronecker <https://es.wikipedia.org/wiki/"
"Producto_de_Kronecker>`_ que también se llama `producto exterior <https://en."
"wikipedia.org/wiki/List_of_trigonometric_identities#Half-angle_formulae>`_ "
"para reescribir :math:`\\sin\\varphi = 2 \\cos\\frac{\\varphi}{2} \\sin"
"\\frac{\\varphi}{2}` y :math:`1-\\cos\\varphi = 2 \\sin^2\\frac{\\varphi}{2}"
"` en la fórmula de Rodrigues, se pueden usar términos de coseno y seno como "
"una ayuda visual cuando se compara con la forma de la matriz.)"

#: ../../docs/tutorials/math/rotations.rst:244
msgid ""
"However, we don't *have to* use matrices to represent SO(3) generators :math:"
"`J_i`. Remember how we used :math:`\\imath`, the imaginary unit to emulate :"
"math:`J_z` rather than using a :math:`2 \\times 2` matrix? As it turns out "
"we can do something similar here."
msgstr ""
"Sin embargo, no *tenemos que* usar matrices para representar generadores "
"SO(3) :math:`J_i`. ¿Recuerdas cómo usamos :math:`\\imath`, la unidad "
"imaginaria para emular :math:`J_z` en lugar de usar una matriz :math:`2 "
"\\times 2`? Resulta que podemos hacer algo similar aquí."

#: ../../docs/tutorials/math/rotations.rst:246
msgid ""
"`Hamilton <https://en.wikipedia.org/wiki/William_Rowan_Hamilton>`_ is mostly "
"commonly known for the omnipresent `Hamiltonian <https://en.wikipedia.org/"
"wiki/Hamiltonian_mechanics>`_ in physics. One of his less known "
"contributions is essentially an alternative way of representing 3D cross "
"product, which eventually gave in to popularity of usual vector `cross "
"products <https://en.wikipedia.org/wiki/Cross_product#History>`_. He "
"essentially realized that there are three different non-commuting rotations "
"in 3D, and gave a name to the generator for each. He identified the "
"operators :math:`\\{\\boldsymbol e_x \\times, \\boldsymbol e_y \\times, "
"\\boldsymbol e_z \\times\\}` as the elements of an algebra, naming them as :"
"math:`\\{i,j,k\\}`."
msgstr ""
"`Hamilton <https://es.wikipedia.org/wiki/William_Rowan_Hamilton>`_ es "
"comúnmente conocido por la omnipresente `mecánica Hamiltoniana <https://es."
"wikipedia.org/wiki/Mec%C3%A1nica_hamiltoniana>`_ en física. Una de sus "
"contribuciones menos conocidas es esencialmente una forma alternativa de "
"representar el producto vectorial 3D, que finalmente cedió a la popularidad "
"del vector habitual `productovectorial <https://en.wikipedia.org/wiki/"
"Cross_product#History>`_. Esencialmente se dio cuenta de que hay tres "
"rotaciones diferentes no conmutadas en 3D, y le dio un nombre al generador "
"para cada una. Identificó a los operadores :math:`\\{\\boldsymbol e_x "
"\\times, \\boldsymbol e_y \\times, \\boldsymbol e_z \\times\\}` como los "
"elementos de un álgebra, nombrándolos :math:`\\{i,j,k\\}`."

#: ../../docs/tutorials/math/rotations.rst:248
msgid ""
"This may sound trivial at this point, because we're equipped with all the "
"machinery of Lie groups and Lie algebras: apparently, quaternion units :math:"
"`\\{i,j,k\\}` are just another representation of the SO(3) generators, which "
"satisfy the Lie bracket. Well, no so fast. While the Lie *algebra* :math:`"
"\\mathfrak{so}(3)`, whose elements are the linear combination of :math:`J_i` "
"s are isomorphic to unit quaternions, but quaternions are :math:`1 w + x i + "
"y j + z k` in general, so there's also an identity part, which isn't a "
"vector that is a part of any Lie algebra. Quaternions look more like the "
"*group* SO(3) (when they're normalized, because SO(3) preserves vector "
"norms). But it actually isn't isomorphic to SO(3). It turns out that unit "
"quaternions are isomorphic to the group SU(2) (which is isomorphic to "
"Spin(3)), which in turn is a double cover of SO(3)."
msgstr ""
"Esto puede sonar trivial en este punto, porque estamos equipados con toda la "
"maquinaria de los grupos y algebras de Lie: aparentemente, las unidades de "
"cuaterniones :math:`\\{i,j,k\\}` son sólo otra representación de los "
"generadores de SO(3), que satisfacen el soporte de Lie. Bueno, no tan "
"rápido. Mientras que el *álgebra* de la Lie :math:`\\mathfrak{so}(3)`, cuyos "
"elementos son la combinación lineal de :math:`J_i` s son isomórficos a los "
"cuaterniones unitarios, pero los cuaterniones son :math:`1 w + x i + y j + z "
"k` en general, así que también hay una parte de identidad, que no es un "
"vector que es parte de cualquier álgebra de Lie. Las cuartniones se parecen "
"más al *grupo* SO(3) (cuando están normalizados, porque el SO(3) preserva "
"las normas vectoriales). Pero en realidad no es isomorfo al SO(3). Resulta "
"que los cuaterniones unitarios son isomórficos al grupo SU(2) (que es "
"isomórfico a Spin(3)), que a su vez es una doble cobertura de SO(3)."

#: ../../docs/tutorials/math/rotations.rst:251
msgid ""
"SU(2) is essentially the group of unitary rotations with determinant +1 "
"(called Special Unitary groups) which preserve the norm of complex vectors "
"it acts on, generated by `Pauli spin matrices <https://en.wikipedia.org/wiki/"
"Pauli_matrices>`_ :math:`\\sigma_i`, and :math:`i,j,k` correspond to :math:`"
"\\sigma_x/\\imath\\ \\sigma_y/\\imath, \\sigma_z/\\imath`. To exemplify, :"
"math:`R = e^{\\varphi \\boldsymbol n \\cdot \\boldsymbol J} \\in \\text{SO}"
"(3)` rotates a real vector by :math:`R \\boldsymbol v` and the corresponding "
"rotation :math:`U = e^{-\\imath\\varphi \\boldsymbol n \\cdot \\boldsymbol "
"\\sigma/2} \\in \\text{SU}(2)` rotates the same vector  through :math:`U "
"(\\boldsymbol v \\cdot \\boldsymbol \\sigma) U^\\dagger`. Note that :math:`U "
"\\to -U` achieves the same SO(3) rotation, SU(2) it's said to be a double "
"cover of SO(3) (this is mapping gives the adjoint representation of SU(2) by "
"the way). Here :math:`-\\imath\\boldsymbol \\sigma = -\\imath (\\sigma_x, "
"\\sigma_y, \\sigma_z) \\cong (i,j,k)`."
msgstr ""
"SU(2) es esencialmente el grupo de rotaciones unitarias con determinante +1 "
"(llamados grupos unitarios especiales) que preservan la norma de los "
"vectores complejos sobre los que actúa, generados por `Matrices de Pauli "
"<https://es.wikipedia.org/wiki/Matrices_de_Pauli>`_ :math:`\\sigma_i` y :"
"math:`i,j,k`corresponde a :math:`\\sigma_x/\\imath\\ \\sigma_y/\\imath, "
"\\sigma_z/\\imath`. Para ejemplificar, :math:`R = e^{\\varphi \\boldsymbol n "
"\\cdot \\boldsymbol J} \\in \\text{SO}(3)` rota un vector real por :math:`R "
"\\boldsymbol v` y la rotación correspondiente :math:`U = e^{-\\imath\\varphi "
"\\boldsymbol n \\cdot \\boldsymbol \\sigma/2} \\in \\text{SU}(2)` rota el "
"mismo vector a través de :math:`U (\\boldsymbol v \\cdot \\boldsymbol "
"\\sigma) U^\\dagger`. Hay que tener en cuenta que :math:`U \\to -U` logra la "
"misma rotación de SO(3), SU(2) se dice que es una cubierta doble de SO(3) "
"(este mapeo da la representación adjunta de SU(2)). Aquí :math:`-\\imath"
"\\boldsymbol \\sigma = -\\imath (\\sigma_x, \\sigma_y, \\sigma_z) \\cong (i,"
"j,k)`."

#: ../../docs/tutorials/math/rotations.rst:253
msgid ""
"SU(2) and SO(3) look the same locally (their tangent spaces dictated by "
"their Lie algebras are isomorphic), but they're different globally. While "
"this sounds like just a technicality, this has topological implications, but "
"we won't get into that much. The take away from this discussion is that unit "
"quaternions *can* be used emulate SO(3) rotations."
msgstr ""
"SU(2) y SO(3) se ven iguales localmente (sus espacios tangenciales dictados "
"por sus algebras de Lie son isomórficos), pero son diferentes globalmente. "
"Aunque esto suena como un tecnicismo, tiene implicaciones topológicas, pero "
"no vamos a entrar en detalles. La ventaja de esta discusión es que los "
"cuaterniones de la unidad *pueden* utilizarse para emular las rotaciones "
"SO(3)."

#: ../../docs/tutorials/math/rotations.rst:255
msgid ""
"But taking a step back, why do we bother *emulating* SO(3) at all? For "
"computational purposes, we already have something that works: the matrix "
"representation. Why do we need to both with a weird group that isn't even "
"exactly the same as SO(3)?"
msgstr ""
"Pero dando un paso atrás, ¿por qué nos molestamos en *emular* SO(3)? Para "
"fines computacionales, ya tenemos algo que funciona: la representación "
"matricial. ¿Por qué necesitamos ambos con un grupo raro que ni siquiera es "
"exactamente lo mismo que SO(3)?"

#: ../../docs/tutorials/math/rotations.rst:258
msgid ""
"The answer is the cost of computation, and this is two fold. First, you see, "
"a rotation operator has only 3 degrees of freedom: two for the unit vector "
"which is the rotation axis, and one for the rotation angle around that axis. "
"A :math:`3\\times 3` matrix, on the other hand has 9 elements. It's an "
"overkill. For example, whenever you multiply two rotations, you need to "
"multiply two :math:`3\\times 3` matrices, summing and multiplying every "
"single element. In terms of CPU cycles, this is wasted effort and we can be "
"more optimal. Second part is precision errors. The errors are worse in "
"matrix representation, because originally, we have only 3 degrees of "
"freedom,  which means we can have precision errors in axis and angle (only 3 "
"errors) but it's still an element of SO(3), whereas with matrices, we can "
"have errors in any one of the 9 elements in the matrix and so we can even "
"have a matrix that isn't even an element of SO(3). These errors can quickly "
"build up quickly especially if you're for example modifying the orientation "
"of an object every frame by doing a smooth interpolation between an initial "
"and a target orientation (discussed further in SLERP section)."
msgstr ""
"La respuesta es el costo de la computación, y esto es doble. Primero, un "
"operador de rotación tiene sólo 3 grados de libertad: dos para el vector "
"unitario que es el eje de rotación, y uno para el ángulo de rotación "
"alrededor de ese eje. Una :math:`3\\times 3`, por otro lado tiene 9 "
"elementos. Es una exageración. Por ejemplo, siempre que multipliques dos "
"rotaciones, necesitas multiplicar dos matrices :math:`3\\times 3`, sumando y "
"multiplicando cada elemento. En términos de ciclos de CPU, esto es un "
"esfuerzo desperdiciado y podemos ser más óptimos. La segunda parte son los "
"errores de precisión. Los errores son peores en la representación matricial, "
"porque originalmente, sólo tenemos 3 grados de libertad, lo que significa "
"que podemos tener errores de precisión en el eje y el ángulo (sólo 3 "
"errores), pero sigue siendo un elemento de SO(3), mientras que con las "
"matrices, podemos tener errores en cualquiera de los 9 elementos de la "
"matriz y así incluso podemos tener una matriz que ni siquiera es un elemento "
"de SO(3). Estos errores pueden acumularse rápidamente, especialmente si, por "
"ejemplo, está modificando la orientación de un objeto en cada fotograma "
"haciendo una interpolación suave entre una orientación inicial y una "
"orientación objetivo (discutida más adelante en la sección SLERP)."

#: ../../docs/tutorials/math/rotations.rst:260
msgid ""
"Sure, we know that elements of SO(3) can be represented by using orthogonal "
"matrices with determinant +1 (hence the name Special Orthogonal) such that :"
"math:`R R^T = I`; in plain language, this means the columns of :math:`R` "
"form an orthonormal set of vectors, so we can eliminate the errors if we "
"perform `Gram-Schmidt <https://en.wikipedia.org/wiki/Gram"
"%E2%80%93Schmidt_process>`_ orthonormalization once in a while, and force it "
"back into SO(3), such that it's an actual rotation matrix (albeit still "
"noisy in axis and angle). But this is expensive and still quite bad in terms "
"of errors."
msgstr ""
"Claro, sabemos que los elementos de SO(3) pueden ser representados usando "
"matrices ortogonales con determinante +1 (de ahí el nombre Ortogonal "
"Especial) de tal manera que  :math:`R R^T = I`; en lenguaje sencillo, esto "
"significa que las columnas de :math:`R` forman un conjunto ortonormal de "
"vectores, por lo que podemos eliminar los errores si realizamos `Gram-"
"Schmidt <https://es.wikipedia.org/wiki/Proceso_de_ortogonalizaci"
"%C3%B3n_de_Gram-Schmidt>`_ orthonormalization de vez en cuando, y forzarlo a "
"volver a SO(3), de tal forma que sea una matriz de rotación real (aunque "
"todavía muy ruidosa en el eje y el ángulo). Pero esto es costoso y bastante "
"malo en términos de posibles errores."

#: ../../docs/tutorials/math/rotations.rst:262
msgid ""
"So, what is the alternative then? Shall we go back to the Rodrigues' formula "
"and hardcode the behavior of :math:`J_i` into our program? A nicer "
"alternative is, we use SU(2) (which we know covers SO(3), twice in fact!), "
"because the equivalent of the Rodrigues' formula is much simpler:"
msgstr ""
"Entonces, ¿cuál es la alternativa? ¿Volvemos a la fórmula de Rodrigues y "
"codificamos el comportamiento de :math:`J_i` en nuestro programa? Una "
"alternativa más agradable es, utilizar SU(2) (que sabemos cubre SO(3), ¡dos "
"veces de hecho!), porque el equivalente de la fórmula de Rodrigues es mucho "
"más simple:"

#: ../../docs/tutorials/math/rotations.rst:268
msgid ""
"owing to the nice relation :math:`(\\boldsymbol n \\cdot \\boldsymbol "
"\\sigma)^2 = I` (something like this happens only at the third power with "
"SO(3) generators, remember? and it doesn't give identity), or if you prefer "
"quaternion version which is more commonly used to represent the isomorphic "
"group Spin(3), this is"
msgstr ""
"gracias a la buena relación :math:`(\\boldsymbol n \\cdot \\boldsymbol "
"\\sigma)^2 = I` (algo así ocurre sólo en la tercera potencia con generadores "
"SO(3), ¿recuerdas? y no nos da la identidad), o si prefieres la versión de "
"cuaternión que se usa más comúnmente para representar al grupo isomórfico "
"Spin(3), ésta es"

#: ../../docs/tutorials/math/rotations.rst:274
msgid ""
"In game engines, rather than storing the axis-angle :math:`(\\boldsymbol "
"n(\\phi,\\theta), \\varphi )` pair where :math:`\\phi,\\theta` are the "
"azimuthal and polar angles parametrizing the unit vector :math:`\\boldsymbol "
"n`, people typically store :math:`\\boldsymbol q= (q_0, q_x, q_y, q_z) "
"\\equiv (\\cos\\frac{\\varphi}{2}, \\sin\\frac{\\varphi}{2} n_x, \\sin"
"\\frac{\\varphi}{2} n_y, \\sin\\frac{\\varphi}{2} n_z)` such that :math:`U = "
"\\boldsymbol q  \\cdot (1, i, j, k)`, and enforce the condition :math:`|"
"\\boldsymbol q|=1` once in a while by renormalization (note that while you "
"can see many people referring to :math:`\\boldsymbol q` as a quaternion, "
"it's not; :math:`U` is the actual quaternion here and :math:`\\boldsymbol q` "
"is just an artificial vector containing the coefficients in the expansion of "
"the exponential map). Of course, if they store :math:`(\\varphi, \\phi, "
"\\theta)`, there is no need for a renormalization because such "
"parametrization guarantees the normalization, but this choice would come at "
"the cost of calculating a bunch of sines and cosines whenever you use them, "
"so this is a middle ground in terms of errors and speed."
msgstr ""
"En los motores de juego, en lugar de almacenar el ángulo del eje :math:"
"`(\\boldsymbol n(\\phi,\\theta), \\varphi )`par donde :math:`\\phi,"
"\\theta`son los ángulos acimut y polar que parametrizan el vector unitario :"
"math:`\\boldsymbol n`, la gente normalmente almacena :math:`\\boldsymbol q= "
"(q_0, q_x, q_y, q_z) \\equiv (\\cos\\frac{\\varphi}{2}, \\sin\\frac{\\varphi}"
"{2} n_x, \\sin\\frac{\\varphi}{2} n_y, \\sin\\frac{\\varphi}{2} n_z)` such "
"that :math:`U = \\boldsymbol q  \\cdot (1, i, j, k), para hacer cumplir la "
"condición :math:`|\\boldsymbol q|=1` de vez en cuando por renormalización "
"(nota que si bien puedes ver a muchas personas refiriéndose a :math:`"
"\\boldsymbol q` como un cuaternión, no lo es; :math:`U` es el cuaternión "
"real aquí y :math:`\\boldsymbol q` es sólo un vector artificial que contiene "
"los coeficientes en la expansión del mapa exponencial). Por supuesto, si "
"almacenan :math:`(\\varphi, \\phi, \\theta)`, no hay necesidad de una "
"renormalización porque tal parametrización garantiza la normalización, pero "
"esta elección vendría a costa de calcular un montón de senos y cosenos cada "
"vez que se utilizan, por lo que este es un término medio en términos de "
"errores y velocidad."

#: ../../docs/tutorials/math/rotations.rst:276
msgid "So, the take aways of this section are:"
msgstr "Así que, las ventajas de esta sección son:"

#: ../../docs/tutorials/math/rotations.rst:278
msgid ""
"Matrices can represent SO(3) just fine, but are a little too general and "
"extravagant in terms of CPU cycles and behave bad in the presence of "
"floating point errors, and errors can even lead to a matrix that doesn't "
"correspond to a rotation matrix at all!"
msgstr ""
"Las matrices pueden representar SO(3) muy bien, pero son demasiado generales "
"y extravagantes en términos de ciclos de CPU y se comportan mal en presencia "
"de errores de coma flotante ¡y los errores pueden incluso llevar a una "
"matriz que no corresponde en absoluto a una matriz de rotación!"

#: ../../docs/tutorials/math/rotations.rst:280
msgid ""
"For all practical purposes, we can use an element of SU(2) to represent an "
"SO(3) rotation. It's a double cover of SO(3), so we wouldn't be losing "
"anything in doing so. The main reason for choosing one over another is the "
"SO(3) Rodrigues' formula is a little nasty to work with whereas SU(2) "
"expansion is neat, clean and simple to work with."
msgstr ""
"A todos los efectos prácticos, podemos utilizar un elemento de SU(2) para "
"representar una rotación SO(3). Es una doble cobertura de SO(3), así que no "
"estaríamos perdiendo nada al hacerlo. La razón principal para elegir uno "
"sobre el otro es que la fórmula de Rodrigues SO(3) es un poco incómoda para "
"trabajar, mientras que la expansión de SU(2) es clara, limpia y fácil de "
"utilizar."

#: ../../docs/tutorials/math/rotations.rst:282
msgid ""
"Using matrices, you can practically do everything you do with quaternions, "
"vice versa. The real differences, as highlighted, are in computation trade-"
"offs, not mathematics."
msgstr ""
"Usando matrices, prácticamente se puede hacer todo lo que se hace con los "
"cuaterniones, y viceversa. Las diferencias reales, como se ha destacado, "
"están en las compensaciones de cálculo, no en las matemáticas."

#: ../../docs/tutorials/math/rotations.rst:284
msgid ""
"The relationship between quaternions and 3D rotation matrices is the roughly "
"the same as the relation between the complex number :math:`e^{\\imath\\theta}"
"` and a 2D rotation matrix. Just as the complex number :math:`\\imath \\cong "
"J_z` rotates by :math:`\\pi/2` (which is, as we saw, what a *generator* "
"does), :math:`i,j,k` (which are :math:`\\cong J_x, J_y, J_z`) rotate by :"
"math:`\\pi/2` around :math:`x, y, z` axes; they don't commute with each "
"other because in 3D, the order of rotations is important. Owing to this "
"isomorphism between their generators, an SO(3) rotation :math:`e^{\\varphi "
"\\boldsymbol n \\cdot \\boldsymbol J}` corresponds to the SU(2) rotation :"
"math:`e^{\\varphi \\boldsymbol n \\cdot (i,j,k)/2}`. This is a helpful "
"picture to gain an intuition on quaternions. While the SO(3) is familiar to "
"many people,  the \"Rodrigues' formula\" for the SU(2) one is much "
"preferable graphics programming due to it's simplicity, and hence you see "
"quaternions in game engines."
msgstr ""
"La relación entre los cuaterniones y las matrices de rotación 3D es "
"aproximadamente la misma que la relación entre el número complejo :math:"
"`e^{\\imath\\theta}` y una matriz de rotación 2D. Así como el complejo "
"número :math:`\\imath \\cong J_z` rota por :math:`\\pi/2` (que es, como "
"vimos, lo que hace un *generador*), :math:`i,j,k` (que son :math:`\\cong "
"J_x, J_y, J_z`) rotar por :math:`\\pi/2` alrededor de los ejes :math:`x, y, "
"z`; no se conmutan entre sí porque en 3D, el orden de las rotaciones es "
"importante. Debido a este isomorfismo entre sus generadores, una rotación "
"SO(3) :math:`e^{\\varphi \\boldsymbol n \\cdot \\boldsymbol J}` corresponde "
"a la rotación SU(2) :math:`e^{\\varphi \\boldsymbol n \\cdot (i,j,k)/2}`. "
"Esta es una imagen útil para tener una idea sobre los cuaterniones. Mientras "
"que el SO(3) es familiar para mucha gente, la \"fórmula de Rodrigues\" para "
"el SU(2) es mucho más recomendable para la programación de gráficos debido a "
"su simplicidad, y por lo tanto se ven cuaterniones en los motores de juego."

#: ../../docs/tutorials/math/rotations.rst:286
msgid ""
"This doesn't mean quaternions are a generalization of complex numbers in our "
"construction when considering rotations in a strict sense; they're rather "
"the 3D generalization of the 2D rotation generator in some loose sense "
"(loose, because SO(3) and SU(2) are different groups). There *is* a "
"construction which generalizes real numbers to complex numbers to "
"quaternions, called `Cayley-Dickson construction <https://en.wikipedia.org/"
"wiki/Cayley%E2%80%93Dickson_construction>`_, but it's next steps give off "
"topic objects octonions and sedenions (setting exceptional Lie groups aside "
"for octonions)."
msgstr ""
"Esto no significa que los cuaterniones son una generalización de números "
"complejos en nuestra construcción cuando consideramos las rotaciones en un "
"sentido estricto; son más bien la generalización 3D del generador de "
"rotación 2D en un sentido suelto (suelto, porque SO(3) y SU(2) son grupos "
"diferentes). Hay una construcción que generaliza números reales a números "
"complejos a cuaterniones, llamada `Construcción de Cayley-Dickson <https://"
"es.wikipedia.org/wiki/Construcci%C3%B3n_de_Cayley-Dickson>`_, pero son los "
"siguientes pasos los que producen los objetos tópicos octiones y sedeniones "
"(reservando grupos de Lie excepcionales para octoniones)."

#: ../../docs/tutorials/math/rotations.rst:288
msgid ""
"Note that we haven't said a word about Euler angles. In both matrix and "
"quaternion *representations*, we sticked to the axis-angle "
"*parametrization*. We will discuss different parametrizations in what "
"follows."
msgstr ""
"Nota que no hemos dicho una sola palabra sobre los ángulos de Euler. Tanto "
"en las *representaciones* de la matriz como en las de los cuaterniones, nos "
"ceñimos a la *parametrización* del ángulo del eje. Analizaremos diferentes "
"parametrizaciones más adelante."

#: ../../docs/tutorials/math/rotations.rst:292
#: ../../docs/tutorials/math/rotations.rst:417
msgid "Matrix representation of SO(3)"
msgstr "Representación de la matriz de SO(3)"

#: ../../docs/tutorials/math/rotations.rst:292
#: ../../docs/tutorials/math/rotations.rst:417
msgid "Quaternion representation of SU(2)"
msgstr "Representación por cuaterniones de SU(2)"

#: ../../docs/tutorials/math/rotations.rst:294
msgid ":math:`(x,y,z)`"
msgstr ":math:`(x,y,z)`"

#: ../../docs/tutorials/math/rotations.rst:294
msgid ""
":math:`\\sqrt{r}(\\cos\\frac{\\theta}{2}, e^{\\imath \\phi} \\sin"
"\\frac{\\theta}{2})`"
msgstr ""
":math:`\\sqrt{r}(\\cos\\frac{\\theta}{2}, e^{\\imath \\phi} \\sin"
"\\frac{\\theta}{2})`"

#: ../../docs/tutorials/math/rotations.rst:296
msgid ""
"Matrices for :math:`J_x, J_y, J_z  \\cong \\boldsymbol e_x \\times, "
"\\boldsymbol e_y \\times, \\boldsymbol e_z \\times`"
msgstr ""
"Matrices para :math:`J_x, J_y, J_z  \\cong \\boldsymbol e_x \\times, "
"\\boldsymbol e_y \\times, \\boldsymbol e_z \\times`"

#: ../../docs/tutorials/math/rotations.rst:296
msgid ":math:`i,j,k`"
msgstr ":math:`i,j,k`"

#: ../../docs/tutorials/math/rotations.rst:298
msgid ""
":math:`e^{\\varphi \\boldsymbol n \\cdot \\boldsymbol J}`, can expand with "
"Rodrigues' formula"
msgstr ""
":math:`e^{\\varphi \\boldsymbol n \\cdot \\boldsymbol J}`, puede expandirse "
"con la fórmula de Rodrigues"

#: ../../docs/tutorials/math/rotations.rst:298
msgid ""
":math:`e^{\\varphi \\boldsymbol n \\cdot (i,j,k)/2}` can expand with SU(2) "
"\"Rodrigues' formula\""
msgstr ""
":math:`e^{\\varphi \\boldsymbol n \\cdot (i,j,k)/2}` puede expandirse con la "
"fórmula de Rodrigues SU(2)"

#: ../../docs/tutorials/math/rotations.rst:301
msgid ""
"Above, :math:`r,\\theta,\\phi` are spherical coordinates corresponding to :"
"math:`x,y,z`."
msgstr ""
"En el ejemplo anterior, :math:`r,\\theta,\\phi` son coordenadas esféricas "
"correspondientes a :math:`x,y,z`."

#: ../../docs/tutorials/math/rotations.rst:304
msgid "A note about the SU(2) vector"
msgstr "Una nota sobre el vector SU(2)"

#: ../../docs/tutorials/math/rotations.rst:306
msgid ""
"We earlier mentioned that rotation of a real vector in SU(2) is done via :"
"math:`(R \\boldsymbol v) \\cdot \\boldsymbol \\sigma = U (\\boldsymbol v "
"\\cdot \\boldsymbol \\sigma) U^\\dagger`, and you may be wondering what the "
"complex vector  listed above :math:`|\\psi\\rangle = (\\cos\\frac{\\theta}"
"{2}, e^{\\imath \\phi} \\sin\\frac{\\theta}{2})` has to do with that. The "
"answer is, there vector :math:`|\\psi\\rangle` is the one a single :math:`U` "
"acts on, and in terms of it, we can rewrite  :math:`U (\\boldsymbol v \\cdot "
"\\boldsymbol \\sigma) U^\\dagger` as :math:`r U (|\\psi\\rangle \\otimes "
"\\langle \\psi|) U^\\dagger` up to some trivial identity term, where :math:`"
"\\langle \\psi| = |\\psi\\rangle^\\dagger` (this is the way complex vectors "
"are typically denoted in quantum mechanics and is called `bra-ket notation "
"<https://en.wikipedia.org/wiki/Bra%E2%80%93ket_notation>`_: bra is like the "
"vector and ket is the `conjugate transpose <https://en.wikipedia.org/wiki/"
"Hermitian_adjoint>`_, and people typically omit the :math:`\\otimes`  in "
"between because that's already implied when you multiply a ket with a bra, "
"and likewise there is no :math:`\\cdot` when you multiply a bra with ket "
"since that's also implied)."
msgstr ""
"Anteriormente mencionamos que la rotación de un vector real en SU(2) se "
"realiza a través de :math:`(R \\boldsymbol v) \\cdot \\boldsymbol \\sigma = "
"U (\\boldsymbol v \\cdot \\boldsymbol \\sigma) U^\\dagger`, y puede que te "
"estés preguntando qué tiene que ver el vector complejo :math:`|\\psi\\rangle "
"= (\\cos\\frac{\\theta}{2}, e^{\\imath \\phi} \\sin\\frac{\\theta}{2})` "
"mencionado anteriormente con esto. La respuesta es, que hay un vector :math:"
"`|\\psi\\rangle` is the one a single :math:`U` que actúa, y en términos de "
"esto, podemos reescribir :math:`U (\\boldsymbol v \\cdot \\boldsymbol "
"\\sigma) U^\\dagger` como :math:`r U (|\\psi\\rangle \\otimes \\langle "
"\\psi|) U^\\dagger` hasta algún término de identidad trivial, donde  :math:`"
"\\langle \\psi| = |\\psi\\rangle^\\dagger` (esta es la forma en que los "
"vectores complejos son típicamente denotados en la mecánica cuántica y se "
"llama `Notación bra-ket <https://es.wikipedia.org/wiki/Notaci%C3%B3n_bra-"
"ket>`_: el bra es como el vector y el ket es el `operador adjunto <https://"
"es.wikipedia.org/wiki/Operador_adjunto>`_, y la gente típicamente omite el :"
"math:`\\otimes` entremedio porque eso ya está implícito cuando multiplicas "
"un ket por un bra, y de la misma manera no hay :math:`\\cdot` cuando "
"multiplicas un bra por un ket ya que eso también está implícito)."

#: ../../docs/tutorials/math/rotations.rst:308
msgid ""
"So, notational concerns aside, long story short, the vector listed above is "
"in a generalized sense \"half\" of what we are rotating:"
msgstr ""
"Por lo tanto, dejando a un lado las preocupaciones notacionales, resumiendo, "
"el vector mencionado anteriormente es, en un sentido generalizado, \"la mitad"
"\" de lo que estamos rotando:"

#: ../../docs/tutorials/math/rotations.rst:314
msgid ""
"and each \"half\" goes to one of the :math:`U` s on each side of the "
"modified/generalized relation"
msgstr ""
"y cada \"mitad\" va a una de las  :math:`U` s a cada lado de la relación "
"modificada/generalizada"

#: ../../docs/tutorials/math/rotations.rst:320
msgid ""
"so everything is compatible, and :math:`|\\psi'\\rangle = U |"
"\\psi(\\boldsymbol v)\\rangle = |\\psi(R \\boldsymbol v)\\rangle` is "
"satisfied. This parametrization of an SU(2) vector is typically done in "
"spherical coordinates :math:`\\theta,\\phi` (for :math:`r=1`, because state "
"vectors are normalized in quantum mechanics), and the sphere is called "
"`Bloch sphere <https://en.wikipedia.org/wiki/Bloch_sphere>`_)."
msgstr ""
"así que todo es compatible, y :math:`|\\psi'\\rangle = U |\\psi(\\boldsymbol "
"v)\\rangle = |\\psi(R \\boldsymbol v)\\rangle` es satisfactorio. Esta "
"parametrización de un vector SU(2) se hace típicamente en coordenadas "
"esféricas :math:`\\theta,\\phi` (para :math:`r=1`, porque los vectores de "
"estado están normalizados en la mecánica cuántica), y la esfera se llama "
"`Esfera de Bloch <https://es.wikipedia.org/wiki/Esfera_de_Bloch>`_)."

#: ../../docs/tutorials/math/rotations.rst:323
msgid "Parametrization of rotations"
msgstr "Parametrización de rotaciones"

#: ../../docs/tutorials/math/rotations.rst:325
msgid ""
"From general arguments of linear independence, it is clear that a general "
"rotation in 3D requires 3 independent parameters, which is known as `Euler's "
"rotation theorem <https://en.wikipedia.org/wiki/Euler's_rotation_theorem>`_. "
"It is tempting to think rotations as three-dimensional vectors, but they are "
"rather `linear operators <https://en.wikipedia.org/wiki/Linear_map>`_ that "
"transform vectors."
msgstr ""
"A partir de argumentos generales de independencia lineal, está claro que una "
"rotación general en 3D requiere 3 parámetros independientes, lo que se "
"conoce como `Teorema de rotación de Euler <https://es.wikipedia.org/wiki/"
"Teorema_de_rotaci%C3%B3n_de_Euler`_. Es tentador pensar que las rotaciones "
"son vectores tridimensionales, pero son más bien `aplicaciones lineales "
"<https://es.wikipedia.org/wiki/Aplicaci%C3%B3n_lineal>`_ que transforman los "
"vectores."

#: ../../docs/tutorials/math/rotations.rst:328
msgid ""
"There are `different ways of parametrizing rotations <https://en.wikipedia."
"org/wiki/Charts_on_SO(3)#Parametrizations>`_ in the `3D Euclidean space "
"<https://en.wikipedia.org/wiki/Euclidean_space>`_ using 3 parameters, and we "
"will go through the two commonly used in game programming."
msgstr ""
"Hay `diferentes formas de parametrizar rotaciones <https://en.wikipedia.org/"
"wiki/Charts_on_SO(3)#Parametrizations>`_ en el `espacio euclídeo 3D <https://"
"es.wikipedia.org/wiki/Espacio_eucl%C3%ADdeo>`_ usando 3 parámetros, y "
"pasaremos por los dos más comunes en la programación de juegos."

#: ../../docs/tutorials/math/rotations.rst:332
msgid "Axis-angle parametrization: :math:`(\\phi, \\theta, \\varphi)`"
msgstr "Parametrización del eje-ángulo: :math:`(\\phi, \\theta, \\varphi)`"

#: ../../docs/tutorials/math/rotations.rst:334
msgid ""
"As we found out, this is the *de facto* parametrization of rotations in 3D "
"(or in fact, in any dimensions), which is also the direct generalization of "
"rotations in 2D, is this: choose an axis in 3D space (a unit vector to "
"specify a direction, which has two independent parameters, because its "
"length is conventionally fixed to 1) and is typically parametrized using "
"`polar and  azimuthal angles <https://en.wikipedia.org/wiki/"
"Spherical_coordinate_system>`_ as :math:`\\boldsymbol n(\\phi,\\theta) = "
"(\\sin\\theta \\cos\\phi, \\sin\\theta \\sin\\phi,\\cos\\theta)` and specify "
"the angle of rotation around that axis :math:`\\varphi` (which is the third "
"parameter) whose sense of rotation is fixed by the `right-hand rule <https://"
"en.wikipedia.org/wiki/Right-hand_rule>`_ (for a right-hand coordinate "
"system). For (embedded) 2D rotations in the :math:`xy`-plane, the rotation "
"axis is taken to be the z-axis, and we only need to specify the rotation "
"angle. In 3D, the rotation axis can be pointing toward any direction (since "
"the axis is a unit vector, you can think of it as a point on the unit "
"sphere, if you like). This way of parametrizing rotations is called axis-"
"angle parametrization, and is the easiest to picture intuitively."
msgstr ""
"Como hemos descubierto, se trata *de la* parametrización de las rotaciones "
"en 3D (o de hecho, en cualquier dimensión), que es también la generalización "
"directa de las rotaciones en 2D, es esto: elegir un eje en el espacio 3D (un "
"vector unitario para especificar una dirección, que tiene dos parámetros "
"independientes, ya que su longitud se fija convencionalmente a 1) y es "
"típicamente parametrizada utilizando `polar and  azimuthal angles <https://"
"en.wikipedia.org/wiki/Spherical_coordinate_system>`_ como :math:`"
"\\boldsymbol n(\\phi,\\theta) = (\\sin\\theta \\cos\\phi, \\sin\\theta \\sin"
"\\phi,\\cos\\theta)` y especificar el ángulo de rotación alrededor de ese "
"eje :math:`\\varphi` (que es el tercer parámetro) cuyo sentido de rotación "
"está fijado por la `regla de la mano derecha <https://es.wikipedia.org/wiki/"
"Regla_de_la_mano_derecha>`_ (para un sistema de coordenadas a la derecha). "
"Para rotaciones 2D (incrustadas) en el plano :math:`xy`, el eje de rotación "
"se toma como el eje z, y sólo necesitamos especificar el ángulo de rotación. "
"En 3D, el eje de rotación puede estar apuntando hacia cualquier dirección "
"(ya que el eje es un vector unitario, puedes pensar en él como un punto en "
"la esfera unitaria, si quieres). Esta forma de parametrizar las rotaciones "
"se llama parametrización eje-ángulo, y es la más fácil de visualizar de "
"forma intuitiva."

#: ../../docs/tutorials/math/rotations.rst:340
msgid ""
"Another advantage of the axis angle parametrization is, it is easy to "
"interpolate between two different rotations (let's call their parameters :"
"math:`\\boldsymbol n_1, \\varphi_1` and :math:`\\boldsymbol n_2, "
"\\varphi_2`), which is useful when you're changing the orientation of an "
"object, starting from a given initial orientation and going toward a final "
"one. A nice way of doing this is described in a later section where we "
"describe SLERP. It results in a smooth motion, rather than a \"jerky\" "
"motion which may start fast, go slow in the middle and go fast again etc. It "
"turns out that if a mass is transported this way, it experiences the least "
"amount of torque (compared to other possible trajectories). This way of "
"linearly interpolating rotations in the axis-angle parametrization is called "
"Spherical Linear Interpolation or SLERP, and is almost ubiquitously used in "
"games."
msgstr ""
"Otra ventaja de la parametrización del ángulo del eje es que es fácil "
"interpolar entre dos rotaciones diferentes (llamemos a sus parámetros :math:`"
"\\boldsymbol n_1, \\varphi_1` y :math:`\\boldsymbol n_2, \\varphi_2`), lo "
"cual es útil cuando se está cambiando la orientación de un objeto, "
"comenzando desde una orientación inicial dada y yendo hacia una final. Una "
"buena manera de hacer esto se describe en una sección posterior donde "
"describimos SLERP. El resultado es un movimiento suave, en lugar de un "
"movimiento \"brusco\" que puede empezar rápido, ir lento en el medio y "
"volver a ir rápido, etc. Resulta que si una masa se transporta de esta "
"manera, experimenta la menor cantidad de torsión (en comparación con otras "
"trayectorias posibles). Esta forma de interpolar linealmente las rotaciones "
"en la parametrización eje-ángulo se llama Interpolación Lineal Esférica o "
"SLERP, y es casi omnipresente en los juegos."

#: ../../docs/tutorials/math/rotations.rst:345
msgid ""
"Euler angles (and Tait-Bryan angles): :math:`(\\varphi_1, \\varphi_2, "
"\\varphi_3 )`"
msgstr ""
"Ángulos de Euler (y ángulos Tait-Bryan): :math:`(\\varphi_1, \\varphi_2, "
"\\varphi_3 )`"

#: ../../docs/tutorials/math/rotations.rst:347
msgid ""
"Another way of parametrizing 3D rotations is by considering a sequence of at "
"least 3 rotations around certain, fixed axes. This could be, for example "
"\"rotate around the :math:`Z`-axis by :math:`\\varphi_1`, then rotate around "
"the :math:`Y`-axis by :math:`\\varphi_2`, and finally rotate around the :"
"math:`x`-axis by :math:`\\varphi_3`\". Of course, these axes don't have to "
"be Z, then Y, then X. As long as two sequential rotations are not around the "
"same axis (in which case they would combine into a single rotation, hence "
"reducing the number of actually independent parameters by 1), they can be "
"anything. They don't even need to be aligned with any \"named\" axis. "
"Another thing important think to watch out is, if you imagine that there is "
"a local coordinate system \"painted\" on the object, as you go through the 3-"
"step rotation sequence, that local frame rotates with the object itself, "
"while the global frame of course remains as-is. The rotation angles "
"specified with respect to a global, fixed reference frame are sometimes "
"called Tait-Bryan angles. So when we're specifying a general rotation in "
"terms of 3 rotations around certain \"fixed\" axes, you need to specify "
"whether those axes refer to the global (called extrinsic, usually written "
"with an additional prime, :math:`X'` rather than :math:`X`,  after each "
"rotation ) or the local (called intrinsic) frame as well. Typically, "
"extrinsic is used as it is relatively easier to picture, and axes are chosen "
"to coincide with X,Y or Z. The 3 rotation angles used in such representation "
"of rotations is called Euler angles."
msgstr ""
"Otra forma de parametrizar rotaciones 3D es considerando una secuencia de al "
"menos 3 rotaciones alrededor de ciertos ejes fijos. Esto podría ser, por "
"ejemplo, \"rotar alrededor del eje :math:`Z por `math:``varphi_1`, luego "
"rotar alrededor del eje ``Y`` por `math:``varphi_2``, y finalmente rotar "
"alrededor del eje :math:`x` por ``math:`\\varphi_3``\". Por supuesto, estos "
"ejes no tienen que ser Z, luego Y, luego X. Mientras dos rotaciones "
"secuenciales no estén alrededor del mismo eje (en cuyo caso se combinarían "
"en una sola rotación, reduciendo así el número de parámetros realmente "
"independientes en 1), pueden ser cualquier cosa. Ni siquiera necesitan estar "
"alineados con ningún eje \"nominal\". Otra cosa importante que hay que tener "
"en cuenta es, si se imagina que hay un sistema de coordenadas local \"pintado"
"\" en el objeto, a medida que pasa por la secuencia de rotación de 3 pasos, "
"que el marco local gira con el objeto en sí, mientras que el marco global, "
"por supuesto, permanece como está. Los ángulos de rotación especificados con "
"respecto a un marco de referencia global y fijo se denominan a veces ángulos "
"de Tait-Bryan. Así que cuando estamos especificando una rotación general en "
"términos de 3 rotaciones alrededor de ciertos ejes \"fijos\", necesitamos "
"especificar si esos ejes se refieren al global (llamado extrínseco, "
"usualmente escrito con un primo adicional, :math:`X'` en lugar de :math:`X`, "
"después de cada rotación) o también al marco local (llamado intrínseco). "
"Típicamente, se utiliza extrínseco, ya que es más fácil de visualizar, y los "
"ejes se eligen para que coincidan con X, Y o Z. Los 3 ángulos de rotación "
"utilizados en esta representación de las rotaciones se llaman ángulos de "
"Euler."

#: ../../docs/tutorials/math/rotations.rst:354
msgid ""
"Ancient mechanical devices called gimbal (which are long obsolete in this "
"age) used to calculate realize 3D rotations in engineering applications in "
"vehicles increased the popularity of Euler angles. Furthermore, since the :"
"math:`3 \\times 3` rotation matrix around X,Y or Z axis is easier to write "
"down, it is commonly said that Euler angles are easier to understand when "
"compared to axis-angle representation (which is commonly, although not "
"necessarily, implemented through quaternions). While this may be true if "
"you're creating a linear algebra library from scratch, or filling in the "
"elements of the transformation matrix on your own, this is not the case when "
"writing games with game engines, such as Godot. The popularity of Euler "
"angles endured despite the fact that they, in fact, can not represent a "
"smooth transition between two different rotations by a smooth variation of "
"the three angles. The reason behind this lies in the fact that Euler angles "
"describe a chart on 3-torus, which is not a `covering map <https://en."
"wikipedia.org/wiki/Covering_space>`_ of SO(3), three dimensional rotations "
"(if this sounds too abstract, see the subsection about 3-torus and sphere "
"below). As the mapping from Euler angles to SO(3) is ill-defined at certain "
"points, during the smooth interpolation between two rotations, we may bump "
"into such points, and as a result the rank may drop to 2 or even 1 (which "
"mechanically corresponds to a situation in which two or three gimbals become "
"aligned as they go around), which is known as the `gimbal-lock <https://en."
"wikipedia.org/wiki/Gimbal_lock>`_ problem. Thus, while it's OK to use Euler "
"angles to represent a fixed rotation, they're not suitable for slowly "
"changing the orientation of objects. You can still do that if you put some "
"additional effort to avoid gimbal-lock, of course, but even if by some luck "
"you don't bump into such bad points, a linear interpolation between two sets "
"of Euler angles is going to result in a \"jerky\" motion."
msgstr ""
"Antiguos dispositivos mecánicos llamados cardanes (que son obsoletos desde "
"hace mucho tiempo en esta era) utilizados para calcular las rotaciones 3D en "
"aplicaciones de ingeniería en vehículos aumentaron la popularidad de los "
"ángulos de Euler. Además, dado que la matriz de rotación de :math:`3 \\times "
"3` alrededor del eje X,Y o Z es más fácil de escribir, comúnmente se dice "
"que los ángulos de Euler son más fáciles de entender cuando se comparan con "
"la representación eje-ángulo (la cual es normalmente, aunque no "
"necesariamente, implementada a través de cuaterniones). Si bien esto puede "
"ser cierto si está creando una biblioteca de álgebra lineal desde cero, o si "
"está rellenando los elementos de la matriz de transformación por su cuenta, "
"este no es el caso cuando escribe juegos con motores de juego, como Godot. "
"La popularidad de los ángulos de Euler perduró a pesar de que, de hecho, no "
"pueden representar una transición suave entre dos rotaciones diferentes por "
"una variación suave de los tres ángulos. La razón de esto radica en el hecho "
"de que los ángulos de Euler describen una gráfica en 3-toroides, que no es "
"un `espacio recubridor <https://es.wikipedia.org/wiki/Espacio_recubridor>`_ "
"de las rotaciones tridimensionales de SO(3), (si esto suena demasiado "
"abstracto, ver la subsección sobre 3-toroides y esfera abajo). Como el mapeo "
"de los ángulos de Euler a SO(3) está mal definido en ciertos puntos, durante "
"la interpolación suave entre dos rotaciones, podemos toparnos con tales "
"puntos, y como resultado el rango puede caer a 2 o incluso 1 (lo que "
"mecánicamente corresponde a una situación en la que dos o tres balancines se "
"alinean a medida que giran), lo que se conoce como el problema `bloqueo del "
"cardán <https://es.wikipedia.org/wiki/Bloqueo_del_card%C3%A1n`_. Por lo "
"tanto, aunque está bien utilizar los ángulos de Euler para representar una "
"rotación fija, no son adecuados para cambiar lentamente la orientación de "
"los objetos. Todavía se puede hacer eso si se hace un esfuerzo adicional "
"para evitar el bloqueo del cardán, por supuesto, pero incluso si con un poco "
"de suerte no se tropieza con tales puntos malos, una interpolación lineal "
"entre dos conjuntos de ángulos de Euler va a resultar en un movimiento "
"\"brusco\"."

#: ../../docs/tutorials/math/rotations.rst:361
msgid ""
"All in all, despite being an ill-defined parametrization for rotations, "
"Euler angles enjoyed a popularity due to gimbals."
msgstr ""
"En definitiva, a pesar de ser una parametrización mal definida para las "
"rotaciones, los ángulos de Euler gozaron de una popularidad debido a la "
"suspensión cardán."

#: ../../docs/tutorials/math/rotations.rst:363
msgid ""
"While Euler angles may not be too useful when calculating the rotation "
"operator (be it a matrix or a quaternion) in body dynamics, people still "
"find them useful to think about and describe the *orientation* of 3D objects "
"starting from the initial default *\"unrotated\"* state (it's difficult to "
"calculate the 3 Euler angles for driving an object from a non-trivial "
"initial orientation to a non-trivial final orientation ---it can't be "
"calculated intuitively in general, it is a task for computers). For this "
"reason, Godot's property editor uses Euler angles (in extrinsic YXZ "
"convention; if the node has a parent node, the YXZ axes refer to the local "
"axes of the parent) for the rotation property of a Transform --this is "
"pretty much the only place Euler angles are used in Godot."
msgstr ""
"Mientras que los ángulos de Euler pueden no ser demasiado útiles cuando se "
"calcula el operador de rotación (ya sea una matriz o un cuaternio) en la "
"dinámica corporal, la gente todavía los encuentra útiles para pensar y "
"describir la *orientación* de los objetos 3D a partir del estado por defecto "
"inicial *\"no girado \"* (es difícil calcular los 3 ángulos de Euler para "
"conducir un objeto desde una orientación inicial no trivial a una "
"orientación final no trivial; no se puede calcular intuitivamente en "
"general, es una tarea para las computadoras). Por esta razón, el editor de "
"propiedades de Godot utiliza los ángulos de Euler (en la convención "
"extrínseca YXZ; si el nodo tiene un nodo padre, los ejes YXZ se refieren a "
"los ejes locales del padre) para la propiedad de rotación de un Transform; "
"éste es prácticamente el único lugar donde los ángulos de Euler se usan en "
"Godot."

#: ../../docs/tutorials/math/rotations.rst:365
msgid ""
"So the answer to the question \"should I use Euler angles or axis-angle "
"parametrization in my game\" is: unless you're trying to *statically* orient "
"an object in a particular way starting from an *unrotated, default "
"orientation* (for which you can still use axis-angle parametrization in your "
"script, if you prefer), you shouldn't be using Euler angles. Major reasons "
"are:"
msgstr ""
"Así que la respuesta a la pregunta \"¿debería usar los ángulos de Euler o la "
"parametrización de ángulo de eje en mi juego?\" es: a menos que estés "
"intentando *estáticamente* orientar un objeto de una manera particular "
"empezando desde una *orientación no girada, por defecto* (para lo cual "
"puedes usar la parametrización de ángulo de eje en tu script, si lo "
"prefieres), no deberías usar los ángulos de Euler. Las razones principales "
"son:"

#: ../../docs/tutorials/math/rotations.rst:367
msgid ""
"Jerky interpolations. You can't interpolate two orientations smoothly "
"(torque-free) in a way that is reference independent (which doesn't depend "
"on how you choose the 3 fixed rotation axes)."
msgstr ""
"Interpolaciones bruscas. No es posible interpolar dos orientaciones "
"suavemente (sin torsión) de forma independiente de la referencia (lo que no "
"depende de cómo se seleccionen los 3 ejes de rotación fijos)."

#: ../../docs/tutorials/math/rotations.rst:368
msgid ""
"Gimbal lock. Rotation dynamics (which includes interpolations) can get worse "
"than jerky, you can get stuck in a weird coordinate singularity (the kind "
"which doesn't exist in axis-angle parametrization) and never reach your "
"target."
msgstr ""
"Bloqueo del cardán. La dinámica de rotación (que incluye interpolaciones) "
"puede ser peor que un movimiento brusco; puedes quedarte atrapado en una "
"singularidad de coordenadas extraña (del tipo que no existe en la "
"parametrización eje-ángulo) y nunca alcanzar tu objetivo."

#: ../../docs/tutorials/math/rotations.rst:372
msgid "A note about surface of 3-torus and sphere, and Gimbal lock"
msgstr ""
"Una nota sobre la superficie de 3-toroides y esfera, y el bloqueo del Cardán"

#: ../../docs/tutorials/math/rotations.rst:374
msgid ""
"What is a 3-torus, to begin with? The surface of a donut is a 2-torus, "
"referring to the fact that the surface itself is two-dimensional (although "
"curved), which is easy to visualize. However, it's difficult to visualize a "
"torus in higher dimensions. But as it turns out, there is another way of "
"thinking about torus, which generalizes to higher dimensions."
msgstr ""
"Para empezar, ¿qué significa 3-toroides? La superficie de una rosquilla es "
"de 2-toroides, refiriéndose al hecho de que la superficie en sí es "
"bidimensional (aunque curvada), lo cual es fácil de visualizar. Sin embargo, "
"es difícil visualizar un toroide en dimensiones más altas. Pero resulta que "
"hay otra forma de pensar sobre el toroides, que se generaliza a dimensiones "
"superiores."

#: ../../docs/tutorials/math/rotations.rst:376
msgid ""
"Imagine an ant walking on the surface of a donut illustrated below (image "
"borrowed from `here <https://en.wikipedia.org/wiki/Torus#/media/File:"
"Toroidal_coord.png>`_)."
msgstr ""
"Imagina una hormiga caminando sobre la superficie de la rosquilla que se "
"muestra a continuación (imagen tomada de `aquí <https://en.wikipedia.org/"
"wiki/Torus#/media/File:Toroidal_coord.png>`_)."

#: ../../docs/tutorials/math/rotations.rst:381
msgid ""
"If it keeps walking along either the red or the blue lines, it will "
"eventually come back to where it started. At any time, we can use two angles "
"to describe where the ant is: one angle (:math:`\\theta` which goes between :"
"math:`0` and :math:`2\\pi`) describing it's position along the red line, and "
"another one (:math:`\\phi`, again between :math:`0` and :math:`2\\pi`) for "
"the blue line. And note that we have periodicity: :math:`(\\theta,\\phi)`  "
"and :math:`(\\theta + 2\\pi N,\\phi + 2\\pi N)`  describe exactly the same "
"point on the donut for an integer :math:`N`. We have two angles, of course, "
"because we're talking about a two-dimensional surface. Now we're ready to "
"talk about :math:`n`-dimensional surfaces."
msgstr ""
"Si continúa caminando a lo largo de las líneas rojas o azules, eventualmente "
"regresará a donde comenzó. En cualquier momento, podemos usar dos ángulos "
"para describir dónde está la hormiga: uno (:math:`\\theta` que va entre :"
"math:`0` y :math:`2\\pi`) describiendo su posición a lo largo de la línea "
"roja, y otro (:math:`\\phi`, otra vez entre :math:`0` y :math:`2\\pi`) para "
"la línea azul. Y ten en cuenta que tenemos periodicidad: :math:`(\\theta,"
"\\phi)` y :math:`(\\theta + 2\\pi N,\\phi + 2\\pi N)` describen exactamente "
"el mismo punto en la rosquilla para un entero `mateh:`N`. Tenemos dos "
"ángulos, por supuesto, porque estamos hablando de una superficie "
"bidimensional. Ahora estamos listos para hablar de :math:`n`-superficies "
"dimensionales."

#: ../../docs/tutorials/math/rotations.rst:383
msgid ""
"If you have a set of :math:`n` \"coordinates\" (or angles) which are "
"periodic, just like :math:`\\theta` and :math:`\\phi` were (which is the "
"case for the three Euler angles), then people say those coordinates describe "
"a point on the surface of an :math:`n`-torus. (In the case that the period "
"of a \"coordinate\" is different than :math:`2\\pi`, that coordinate can be "
"scaled to make it so, such that it corresponds to an :math:`n`-torus)."
msgstr ""
"Si tenemos un conjunto de :math:`n` \"coordenadas\" (o ángulos) que son "
"periódicas, igual que lo fueron :math:`\\theta` y :math:`\\phi` (que es el "
"caso de los tres ángulos de Euler), entonces la gente dice que esas "
"coordenadas describen un punto en la superficie de un toroide-:math:`n`. (En "
"el caso de que el período de una \"coordenada\" sea diferente a :math:"
"`2\\pi`, esa coordenada puede ser escalada para hacerla así, de tal forma "
"que corresponda a un toroide-:math:`n`)."

#: ../../docs/tutorials/math/rotations.rst:385
msgid ""
"Now, back to our original issue. The axis of the axis-angle parametrization "
"(which is *the* natural way of parametrizing rotations, and is a one-to-one "
"covering map of SO(3); in fact, this is true for all Lie groups, not just "
"rotations in 3D) spans a sphere (every point in a ball of radius :math:`"
"\\pi` corresponds to a rotation in SO(3) where the rotation amount is mapped "
"to radius and rotation axis points is the direction from the origin; with "
"the additional caveat that if you flip the sign of the axis and angle "
"simultaneously, it maps to the same rotation), which is described using "
"spherical coordinates, whereas Euler angles span the surface of a 3-torus "
"(such that every point on the 3-torus corresponds to a rotation), which is "
"described by the three Euler angles. The problem here is, a sphere is "
"topologically different from a torus. In simple terms, this means that it's "
"impossible to deform a sphere to a torus \"smoothly\": at some point, you "
"have to punch a hole in it to make a donut from a ball (and you can never "
"\"punch a hole\" or change the topology when you stick with a "
"parametrization: if you use Euler angles, you're forever stuck walking the "
"surface of a 3-donut, and if you use axis-angle, you're forever stuck flying "
"inside the sphere)."
msgstr ""
"Ahora, volvamos a nuestro número original. El eje de la parametrización eje-"
"ángulo (que es *la* forma natural de parametrizar las rotaciones, y es un "
"mapa de cobertura uno a uno de SO(3); de hecho, esto es válido para todos "
"los grupos de Lie, no sólo para las rotaciones en 3D) abarca una esfera "
"(cada punto en una bola de radio :math:`\\pi` corresponde a una rotación en "
"SO(3) en la que la cantidad de rotación se mapea al radio y los puntos del "
"eje de rotación son la dirección desde el origen; con la advertencia "
"adicional de que si volteas el signo del eje y el ángulo simultáneamente, se "
"mapea a la misma rotación), que se describe usando coordenadas esféricas, "
"mientras que los ángulos de Euler abarcan la superficie de 3-toroides (de "
"tal forma que cada punto en los 3-toroides corresponde a una rotación), que "
"se describe con los tres ángulos de Euler. El problema aquí es que una "
"esfera es topológicamente diferente a un toroide. En términos simples, esto "
"significa que es imposible deformar una esfera a un toroide \"suavemente\": "
"en algún momento, tienes que hacer un agujero en ella para hacer una "
"rosquilla de una bola (y nunca puedes \"perforar un agujero\" o cambiar la "
"topología cuando te quedas con una parametrización: si usas los ángulos de "
"Euler, estás siempre atascado caminando por la superficie de 3-rosquillas, y "
"si usas un eje-ángulo, estás siempre atascado volando dentro de la esfera)."

#: ../../docs/tutorials/math/rotations.rst:389
msgid ""
"Why is this a problem at all? Because it means that a smooth walk (flight?) "
"inside the sphere doesn't always correspond to a smooth walk on the surface "
"of the 3-torus, vice versa: a 3-torus and sphere are globally different, "
"which is a fact you're bound to discover if you walk the parameter space by "
"a smoothly rotating a body using these parametrizations. Axis-angle "
"parametrization has singularities at the poles (where the azimuthal angle is "
"ill-defined) but that's fine because that's exactly how SO(3) is, after all, "
"axis-angle is how Lie groups are parametrized. Euler angle parametrization "
"also has singularities corresponding to points where two gimbals are "
"aligned, but those singularities are different from SO(3)'s poles."
msgstr ""
"¿Por qué es esto un problema? Porque significa que una caminata suave "
"(¿vuelo?) dentro de la esfera no siempre corresponde a una caminata suave en "
"la superficie de 3-toroides, viceversa: 3-toroides y una esfera son "
"completamente diferentes, lo cual es un hecho que estás obligado a descubrir "
"si caminas por el espacio de parámetros girando suavemente un cuerpo usando "
"estas parametrizaciones. La parametrización eje-ángulo tiene singularidades "
"en los polos (donde el ángulo acimutal está mal definido) pero eso está bien "
"porque así es exactamente como está SO(3), después de todo, el eje-ángulo es "
"como se parametrizan los grupos de Lie. La parametrización del ángulo de "
"Euler también tiene singularidades correspondientes a puntos en los que se "
"alinean dos cardanes, pero esas singularidades son diferentes de los polos "
"de SO(3)."

#: ../../docs/tutorials/math/rotations.rst:393
msgid ""
"Suppose that you're at a nice spot, a rotation that can be parametrized by "
"both axis-angle and Euler angles uniquely. Sometimes, it can just happen "
"that if you take a wrong step, you'll fall into a \"hole\" (meaning a "
"singularity at which infinitely many parameters correspond to the same "
"rotation, like at the poles, all choices for the azimuthal angle give the "
"same rotation, or the similar situation with gimbal lock) in one "
"parametrization, while you can continue a smooth journey in the other "
"parametrization. When you fall a \"hole\" using Euler angles, it's called "
"gimbal lock, and since there may not be a corresponding \"hole\" when you "
"take the similar step in the sphere, this tells us that Euler angles is a "
"defective parametrization of SO(3)."
msgstr ""
"Supón que estás en un buen punto, una rotación que puede ser parametrizada "
"por ambos ángulos de eje y Euler únicamente. A veces, puede ocurrir que si "
"das un paso equivocado, caigas en un \"agujero\" (es decir, una singularidad "
"en la que infinitamente muchos parámetros corresponden a la misma rotación, "
"como en los polos, todas las opciones para el ángulo acimutal dan la misma "
"rotación, o la situación similar con el bloqueo del cardán) en una "
"parametrización, mientras que puedes continuar un viaje suave en la otra "
"parametrización. Cuando se cae un \"agujero\" usando los ángulos de Euler, "
"se llama bloqueo de cardán, y como puede no haber un \"agujero\" "
"correspondiente cuando se da un paso similar en la esfera, esto nos dice que "
"los ángulos de Euler son una parametrización defectuosa de SO(3)."

#: ../../docs/tutorials/math/rotations.rst:395
msgid ""
"The root of the problem isn't just the fact that Euler angle parametrization "
"has singularties, just as axis-angle does which is fine on its own, but that "
"those singularities don't match with SO(3)'s singularities."
msgstr ""
"La raíz del problema no es sólo el hecho de que la parametrización del "
"ángulo de Euler tiene singularidades, como lo hace el eje-ángulo, que está "
"bien por sí solo, sino que esas singularidades no coinciden con las "
"singularidades de SO(3)."

#: ../../docs/tutorials/math/rotations.rst:398
msgid "This is the mathematical description of the gimbal-lock problem."
msgstr "Esta es la descripción matemática del problema del bloqueo del cardán."

#: ../../docs/tutorials/math/rotations.rst:400
msgid ""
"Here's an example of gimbal lock in Euler angle parametrization. Suppose "
"that one of the rotations is :math:`\\pi/2`, let's say the middle one. By "
"inserting an identity operator :math:`X(-\\pi/2) X(\\pi/2)` to the right "
"side and rearranging terms, we can show that"
msgstr ""
"He aquí un ejemplo de bloqueo del cardán en la parametrización del ángulo de "
"Euler. Supongamos que una de las rotaciones es :math:`\\pi/2`, digamos la "
"del medio. Insertando un operador de identidad :math:`X(-\\pi/2) X(\\pi/2)` "
"en el lado derecho y reorganizando los términos, podemos probar que"

#: ../../docs/tutorials/math/rotations.rst:406
msgid ""
"(see the section about active transformation below about how a rotation "
"matrix itself transforms, which also explains why and how a Z rotation turns "
"into a Y rotation when surrounded by :math:`\\pi/2` and :math:`-\\pi/2` X "
"rotations) which means we lost a degree of freedom: :math:`\\varphi_y-"
"\\varphi_z` effectively became a single parameter determining the Y rotation "
"and we completely lost the first Z rotation. You can follow similar steps to "
"show that when *any* of the YXZ Euler angles become :math:`\\pm \\pi/2`, you "
"get a gimbal lock."
msgstr ""
"(ver la sección sobre transformación activa más adelante sobre cómo se "
"transforma una matriz de rotación, que también explica por qué y cómo una "
"rotación Z se convierte en una rotación Y cuando está rodeada de :math:`"
"\\pi/2` y :math:`-\\pi/2` X rotaciones) lo que significa que perdimos un "
"grado de libertad: :math:`\\varphi_y-\\varphi_z` efectivamente se convirtió "
"en un único parámetro determinante de la rotación Y y perdimos completamente "
"la primera rotación Z. Puedes seguir pasos similares para mostrar que cuando "
"*cualquiera* de los ángulos YXZ Euler se convierten en :math:`\\pm \\pi/2`, "
"se obtiene un bloqueo de cardán."

#: ../../docs/tutorials/math/rotations.rst:408
msgid ""
"This happens for :math:`\\pm \\pi/2` simply because in the YXZ convention, "
"neighboring axes are related to each other by a :math:`\\pm \\pi/2` rotation "
"around the axis given by the other neighbor. For XZX convention, the gimbal "
"lock would happen at :math:`\\varphi_z = \\pm \\pi` for example."
msgstr ""
"Esto sucede para :math:`\\pm \\pi/2` simplemente porque en la convención "
"YXZ, los ejes vecinos están relacionados entre sí por una rotación de :math:`"
"\\pm \\pi/2` alrededor del eje dado por el otro vecino. Para la convención "
"XZX, el bloqueo del cardán ocurriría por ejemplo en :math:`\\varphi_z = \\pm "
"\\pi`."

#: ../../docs/tutorials/math/rotations.rst:412
msgid "Summary: representation versus parametrization"
msgstr "Resumen: representación vs parametrización"

#: ../../docs/tutorials/math/rotations.rst:414
msgid "We can sum it up in a table:"
msgstr "Podemos resumirlo en una tabla:"

#: ../../docs/tutorials/math/rotations.rst:417
msgid "Parametrization/Representation"
msgstr "Parametrización/Representación"

#: ../../docs/tutorials/math/rotations.rst:419
msgid "Axis-angle"
msgstr "Ejes-ángulo"

#: ../../docs/tutorials/math/rotations.rst:419
msgid ":math:`e^{\\varphi \\boldsymbol v \\cdot \\boldsymbol J}`"
msgstr ":math:`e^{\\varphi \\boldsymbol v \\cdot \\boldsymbol J}`"

#: ../../docs/tutorials/math/rotations.rst:419
msgid ":math:`e^{\\varphi \\boldsymbol v \\cdot (i,j,k)/2}`"
msgstr ":math:`e^{\\varphi \\boldsymbol v \\cdot (i,j,k)/2}`"

#: ../../docs/tutorials/math/rotations.rst:421
msgid "Euler-angles"
msgstr "Ángulos de Euler"

#: ../../docs/tutorials/math/rotations.rst:421
msgid ":math:`e^{\\varphi_3 J_y} e^{\\varphi_2 J_x} e^{\\varphi_1 J_z}`"
msgstr ":math:`e^{\\varphi_3 J_y} e^{\\varphi_2 J_x} e^{\\varphi_1 J_z}`"

#: ../../docs/tutorials/math/rotations.rst:421
msgid ":math:`e^{\\varphi_3 j/2} e^{\\varphi_2 i/2} e^{\\varphi_1 k/2}`"
msgstr ":math:`e^{\\varphi_3 j/2} e^{\\varphi_2 i/2} e^{\\varphi_1 k/2}`"

#: ../../docs/tutorials/math/rotations.rst:424
msgid ""
"where :math:`\\boldsymbol J`  denotes the matrix representation of the :math:"
"`\\boldsymbol J` operators (too lazy to introduce a new symbol for that). "
"YXZ Euler angles is chosen for concreteness (as it is the default convention "
"in Godot), and can be replaced by any three axes (as long as two neighboring "
"axes aren't the same)."
msgstr ""
"donde :math:`\\boldsymbol J` denota la representación matricial de los "
"operadores :math:`\\boldsymbol J` (demasiado perezosos para introducir un "
"nuevo símbolo para eso). Los ángulos de Euler XYZ se eligen para concretar "
"(ya que es la convención por defecto en Godot), y pueden ser reemplazados "
"por tres ejes cualquiera (siempre y cuando dos ejes vecinos no sean iguales)."

#: ../../docs/tutorials/math/rotations.rst:426
msgid ""
"In all cases listed in the above table, Rodrigues' formula (or it's analogue "
"for quaternions) given above can be used for practical purposes."
msgstr ""
"En todos los casos enumerados en la tabla anterior, la fórmula de Rodrigues "
"(o es análoga para los cuaterniones) indicada anteriormente puede utilizarse "
"con fines prácticos."

#: ../../docs/tutorials/math/rotations.rst:428
msgid ""
"In the context of 3D rotations, one representation isn't superior or "
"inferior to another. Whatever representation you're using, you are "
"representing exactly the same thing. A difference appears only when you "
"implement it on a computer: different representations have trade offs when "
"it comes to precision errors, CPU cycles and memory usage (for example, "
"accessing to rotation axis-angle with quaternions is trivial but requires "
"some algebra in matrix representation whereas the converse is true when "
"accessing the basis vectors, SLERP, composition of rotations and "
"orthonormalization is faster with quaternions but a conversion to matrix "
"representation, which isn't free, is always required because that's the "
"representation OpenGL uses and rotating a 3D vector is faster in matrix "
"representation since they are written in the same basis), and they may have "
"different characteristics when doing finite precision arithmetic with "
"floating point numbers. In principle, you can do everything you do with "
"quaternions using matrices, vice versa. The performance could be bad in one "
"representation, but the point is, there is nothing in their mathematics that "
"prevent you from doing that."
msgstr ""
"En el contexto de las rotaciones 3D, una representación no es superior o "
"inferior a otra. Cualquiera que sea la representación que estés usando, "
"estás representando exactamente lo mismo. Las diferencias sólo aparecen "
"cuando se implementan en una computadora: diferentes representaciones tienen "
"compensaciones cuando se trata de errores de precisión, ciclos de CPU y uso "
"de memoria (por ejemplo, acceder al ángulo del eje de rotación con "
"cuaterniones es trivial pero requiere algo de álgebra en la representación "
"de la matriz mientras que lo contrario es aplicable cuando se accede a los "
"vectores base, SLERP, la composición de rotaciones y ortonormalización es "
"más rápida con cuaterniones, pero siempre se requiere una conversión a "
"representación matricial, que no es libre, porque esa es la representación "
"que utiliza OpenGL y girar un vector 3D es más rápido en la representación "
"matricial ya que están escritos en la misma base), y pueden tener "
"características diferentes cuando se hace aritmética de precisión finita con "
"números de coma flotante. En principio, se puede hacer todo lo que se hace "
"con los cuaterniones utilizando matrices, y viceversa. El desempeño podría "
"ser malo en una representación, pero el punto es que no hay nada en sus "
"matemáticas que le impida hacer eso."

#: ../../docs/tutorials/math/rotations.rst:430
msgid ""
"Parametrizations, on the other hand, are vastly different. Axis-angle is the "
"\"one true\" parametrization of rotations. Euler angles, despite being a "
"defective parametrization of rotations, could be more intuitive for simple "
"(involving only 1 or 2 angles)  and *static* situations like orienting a "
"body/vehicle in the editor, but should be avoided for rotational *dynamics* "
"which would eventually lead to a gimbal lock."
msgstr ""
"Las parametrizaciones, por otro lado, son muy diferentes. El ángulo del eje "
"es la \"única\" parametrización verdadera de las rotaciones. Los ángulos de "
"Euler, a pesar de ser una parametrización defectuosa de las rotaciones, "
"podrían ser más intuitivos para situaciones simples (involucrando sólo 1 o 2 "
"ángulos) y *estáticas* como orientar una carrocería/vehículo en el editor, "
"pero deberían ser evitados por la *dinámica* rotacional que eventualmente "
"llevaría a un bloqueo del cardán."

#: ../../docs/tutorials/math/rotations.rst:434
msgid "Interpolating rotations"
msgstr "Interpolación de rotaciones"

#: ../../docs/tutorials/math/rotations.rst:436
msgid ""
"In games, it's common problem to interpolate between two different "
"orientation in a \"nice way\" which doesn't depend on arbitrary things like "
"how the reference frame, and which doesn't result in a \"jerky\" motion "
"(that is, a torque-free motion) such that the angular speed remains constant "
"during the interpolation. These are the properties that we seek when we say "
"\"nice\"."
msgstr ""
"En los juegos, es un problema común interpolar entre dos orientaciones "
"diferentes de una manera \"agradable\" que no depende de cosas arbitrarias "
"como el cuadro de referencia, y que no resulta en un movimiento \"brusco"
"\" (es decir, un movimiento sin torsión) tal que la velocidad angular "
"permanece constante durante la interpolación. Estas son las propiedades que "
"buscamos cuando decimos \"agradable\"."

#: ../../docs/tutorials/math/rotations.rst:438
msgid ""
"Formally, we'd like to interpolate between an initial rotation :math:`R_1 = "
"e^{\\lambda \\varphi_1 \\boldsymbol n_1 \\cdot \\boldsymbol J }` and a final "
"one :math:`R_2 = e^{\\varphi_2 \\boldsymbol n \\cdot \\boldsymbol J }` a "
"function of time, and what we're seeking is something that transforms one "
"into another smoothly, :math:`R(\\lambda)`, where :math:`\\lambda` is the "
"normalized time which is 0 at the beginning and 1 at the end. Clearly, we "
"must have :math:`R(\\lambda=0)=R_1` and :math:`R(\\lambda=1) = R_2`. Since "
"we also know that rotations form a group, we can relate :math:`R(\\lambda)` "
"to :math:`R_1` and :math:`R_2` using another rotation, such that we can for "
"example write"
msgstr ""
"Nos gustaría interpolar formalmente entre una rotación inicial :math:`R_1 = "
"e^{\\lambda \\varphi_1 \\boldsymbol n_1 \\cdot \\boldsymbol J }` y una "
"final :math:`R_2 = e^{\\varphi_2 \\boldsymbol n \\cdot \\boldsymbol J }` una "
"función de tiempo, y lo que estamos buscando es algo que se transforme el "
"uno en el otro suavemente, :math:`R(\\lambda)`, donde :math:`\\lambda` es el "
"tiempo normalizado, siendo 0 al principio y 1 al final. Claramente, debemos "
"tener :math:`R(\\lambda=0)=R_1` y :math:`R(\\lambda=1) = R_2`. Como ya "
"sabemos que las rotaciones forman un grupo, podemos relacionar :math:"
"`R(\\lambda)` con :math:`R_1` and :math:`R_2` usando otra rotación, de "
"manera que, por ejemplo, podamos escribir"

#: ../../docs/tutorials/math/rotations.rst:444
msgid ""
"This form makes sense because for :math:`\\lambda=0`, the interpolation "
"hasn't started and :math:`R(\\lambda)` automatically becomes :math:`R_1`. "
"But why not pick a different form for the exponent as a function of :math:`"
"\\lambda` which evaluates to 0 when :math:`\\lambda=0`? That's simply "
"because we don't want to have a jerky motion, meaning :math:`\\boldsymbol "
"\\omega \\cdot \\boldsymbol J =  R^T(\\lambda) \\dot R(\\lambda)`, where :"
"math:`\\boldsymbol \\omega` is the angular velocity vector, has to be a "
"constant, which can only happen if the time derivative of the exponent is "
"linear in time (in which case we obtain :math:`\\boldsymbol \\omega = "
"\\varphi \\boldsymbol n`). Or equivalently, you can simply observe that a "
"rotation around a fixed axis (fixed because otherwise if you tilt the "
"rotation axis in time, you'll again get a \"jerky motion\" due to `Euler "
"force <https://en.wikipedia.org/wiki/Euler_force>`_) with constant angular "
"speed is :math:`e^{\\boldsymbol \\omega t \\cdot \\boldsymbol J }` where the "
"exponent is linear in time."
msgstr ""
"Esta forma tiene sentido porque para :math:`\\lambda=0`, la interpolación no "
"ha comenzado y :math:`R(\\lambda)` se convierte automáticamente en :math:"
"`R_1`. Pero, ¿por qué no elegir una forma diferente para el exponente en "
"función de :math:`\\lambda` que se evalúa a 0 cuando :math:`\\lambda=0`? Eso "
"es simplemente porque no queremos tener un movimiento brusco, lo que "
"significa :math:`\\boldsymbol \\omega \\cdot \\boldsymbol J =  R^T(\\lambda) "
"\\dot R(\\lambda)`, dónde :math:`\\boldsymbol \\omega` es el vector de "
"velocidad angular, tiene que ser una constante, lo que sólo puede ocurrir si "
"la derivada temporal del exponente es lineal en el tiempo (en cuyo caso "
"obtenemos :math:`\\boldsymbol \\omega = \\varphi \\boldsymbol n`). O su "
"equivalente, simplemente se puede observar que una rotación alrededor de un "
"eje fijo (fijo porque de lo contrario, si inclinas el eje de rotación en el "
"tiempo, obtendrás de nuevo un \"movimiento brusco\" debido a la `Fuerza de "
"Euler <https://es.wikipedia.org/wiki/Fuerza_de_Euler`_) con velocidad "
"angular constante es :math:`e^{\\boldsymbol \\omega t \\cdot \\boldsymbol J }"
"` donde el exponente es lineal en el tiempo."

#: ../../docs/tutorials/math/rotations.rst:447
msgid ""
"But how do we choose :math:`\\boldsymbol n` and :math:`\\varphi`? Well, we "
"simply enforce that :math:`R(\\lambda)`  has to becomes :math:`R_2` at the "
"end, when :math:`\\lambda=1`. Although this looks like a difficult problem, "
"it's actually not. We first make a rearrangement:"
msgstr ""
"Pero, ¿cómo elegimos :math:`\\boldsymbol n` y :math:`\\varphi`? Bueno, "
"simplemente hacemos cumplir que :math:`R(\\lambda)` se convierta en :math:"
"`R_2` al final, cuando :math:`\\lambda=1`. Aunque esto parece un problema "
"difícil, en realidad no lo es. Primero lo reorganizaremos:"

#: ../../docs/tutorials/math/rotations.rst:453
msgid ""
"From this expression, it becomes evident that the solution is :math:"
"`e^{\\varphi \\boldsymbol n \\cdot \\boldsymbol J } = R_2 R_1^T`."
msgstr ""
"A partir de esta expresión, se hace evidente que la solución es :math:"
"`e^{\\varphi \\boldsymbol n \\cdot \\boldsymbol J } = R_2 R_1^T`."

#: ../../docs/tutorials/math/rotations.rst:455
msgid "We can also do the same thing in SU(2) and obtain:"
msgstr "También podemos hacer lo mismo en SU(2) y obtener:"

#: ../../docs/tutorials/math/rotations.rst:461
msgid "or isomorphically, in terms of quaternions:"
msgstr "o isomórficamente, en términos de cuaterniones:"

#: ../../docs/tutorials/math/rotations.rst:467
msgid ""
"For any Lie group, including SO(3) and SU(2), this \"nice\" interpolation is "
"called SLERP."
msgstr ""
"Para cualquier grupo de Lie, incluyendo SO(3) y SU(2), esta \"agradable\" "
"interpolación se llama SLERP."

#: ../../docs/tutorials/math/rotations.rst:469
msgid ""
"Note that at no step we made any reference to axes of some fixed reference "
"frame (as it is in the case of Euler angle parametrization, which are "
"defined with respect to certain \"special\" 3 axes), everything we did is "
"independent of the reference frame. Also note that this scheme can work for "
"any Lie group, and is independent of the representation used (matrix, "
"quaternion, ...)."
msgstr ""
"Nótese que en ningún paso hicimos referencia alguna a ejes de algún sistema "
"de referencia fijo (como es el caso de la parametrización del ángulo de "
"Euler, que se define respecto a ciertos ejes \"especiales\" de 3 ejes), todo "
"lo que hicimos es independiente del sistema de referencia. También hay que "
"tener en cuenta que este esquema puede funcionar para cualquier grupo Lie, y "
"es independiente de la representación utilizada (matriz, cuaternio, etc.)."

#: ../../docs/tutorials/math/rotations.rst:471
msgid ""
"After some tedious algebra (which involves using :math:`\\text{tr}(\\sigma_i "
"\\sigma_j) = 2 \\delta_{ij}`), this result can be simplified to"
msgstr ""
"Después de un poco de tediosa álgebra (que implica usar :math:`\\text{tr}"
"(\\sigma_i \\sigma_j) = 2 \\delta_{ij}`), este resultado puede simplificarse "
"a"

#: ../../docs/tutorials/math/rotations.rst:477
msgid ""
"when :math:`q_1 \\neq \\pm q_2`, where we introduced :math:`\\cos\\Omega "
"\\equiv \\cos\\frac{\\varphi_1}{2}\\cos\\frac{\\varphi_2}{2} + \\sin"
"\\frac{\\varphi_1}{2}\\sin\\frac{\\varphi_2}{2} \\boldsymbol n_1 \\cdot "
"\\boldsymbol n_2` (or equivalently, in terms of an artificial vector which "
"contains the coefficients of the quaternions, as we discussed above, :math:`"
"\\boldsymbol q_1 \\cdot \\boldsymbol q_2`). This result has a simple "
"geometric interpretation when a (unit) quaternion is taken to be a point on "
"the 3-sphere and when one introduces an inner product of the 4D Euclidean "
"space, but we'll skip that because it's a bit off topic in our treatment. "
"We'll however note that this is where the name *Spherical* Linear "
"intERpolation comes from, which refers to the 4D sphere."
msgstr ""
"cuando :math:`q_1 \\neq \\pm q_2`, donde introdujimos :math:`\\cos\\Omega "
"\\equiv \\cos\\frac{\\varphi_1}{2}\\cos\\frac{\\varphi_2}{2} + \\sin"
"\\frac{\\varphi_1}{2}\\sin\\frac{\\varphi_2}{2} \\boldsymbol n_1 \\cdot "
"\\boldsymbol n_2` (o equivalente, en términos de un vector artificial que "
"contiene los coeficientes de los cuaterniones, como hemos discutido "
"anteriormente, :math:`\\boldsymbol q_1 \\cdot \\boldsymbol q_2`). Este "
"resultado tiene una interpretación geométrica simple cuando se toma un "
"cuaternio (unidad) como un punto en la 3-esfera y cuando se introduce un "
"producto interno del espacio euclídeo 4D, pero nos saltaremos eso porque "
"está un poco fuera de tema en este tema. Sin embargo, observaremos que de "
"aquí proviene el nombre de interpolación lineal *Esférica*, que se refiere a "
"la esfera 4D."

#: ../../docs/tutorials/math/rotations.rst:482
msgid "Reference frames: global, parent-local, object-local"
msgstr "Marco de referencia: global, padre-local, objeto-local"

#: ../../docs/tutorials/math/rotations.rst:484
msgid ""
"A reference frame essentially how and where how place the origin and axes of "
"your coordinate system. In Godot, there are three different reference "
"frames. The first is the global reference frame. It exist as the \"anchor\" "
"frame, where all other frames can be defined with respect to. The other "
"types of reference frames appear when you have objects which have children "
"objects. Here's an example which illustrates these frames."
msgstr ""
"Un marco de referencia básicamente indica cómo y dónde colocar el origen y "
"los ejes de su sistema de coordenadas. En Godot, hay tres marcos de "
"referencia diferentes. El primero es el marco de referencia global. Existe "
"como el marco \"ancla\", donde se pueden definir todos los demás marcos con "
"respecto al mismo. Los otros tipos de marcos de referencia aparecen cuando "
"tiene objetos que tienen objetos hijos. He aquí un ejemplo que ilustra estos "
"marcos."

#: ../../docs/tutorials/math/rotations.rst:486
msgid ""
"Consider a ship in the ocean. You can imagine, however that there's a "
"coordinate system painted on the ground somewhere in the ship. This "
"coordinate system moves and rotates with the ship, so it's called ship's "
"local frame. Furthermore, we can attach a reference frame to passengers on "
"the ship (for example, let's say, for each passenger, their left is their :"
"math:`x`-axis and their forward is their :math:`z` axis, and their origin is "
"where they stand)."
msgstr ""
"Imagina un barco en el océano. Sin embargo, es posible imaginar que hay un "
"sistema de coordenadas pintado en el suelo en algún lugar del barco. Este "
"sistema de coordenadas se mueve y gira con el barco, por lo que se denomina "
"marco local del barco. Además, podemos adjuntar un marco de referencia a los "
"pasajeros del barco (por ejemplo, digamos que por cada pasajero, su "
"izquierda es su eje :math:`x` y al frente su eje :math:`z`, y su origen es "
"donde se encuentran)."

#: ../../docs/tutorials/math/rotations.rst:488
msgid ""
"The global coordinate system corresponds to a coordinate system world "
"painted somewhere on the ground in the world (let's say we live in a flat "
"world for simplicity). Then every object, including the ship and the "
"passengers have their own reference frames, they're called object-local "
"frames. But notice that for passengers, the most natural frame would be "
"where they are located (and how they're oriented) relative to the ship. "
"After all, when someone asks \"Where's Joe?\", you'd reply with something "
"like \"I saw him in the front deck\" rather than trying to look up GPS "
"coordinates (global frame) or saying something like \"7 meters to my five "
"o'clock\" (passenger/object-local). The ship is referred to as the parent-"
"local frame."
msgstr ""
"El sistema de coordenadas global corresponde a un mundo de sistemas de "
"coordenadas pintado en algún lugar del mundo (digamos que vivimos en un "
"mundo plano por simplicidad). Entonces cada objeto, incluyendo el barco y "
"los pasajeros tienen sus propios marcos de referencia, se llaman marcos "
"objeto-local. Pero hay que tener en cuenta que para los pasajeros, el marco "
"más natural sería el lugar donde se encuentran (y cómo están orientados) en "
"relación con el barco. Después de todo, cuando alguien pregunta \"¿Dónde "
"está Joe?\", respondes con algo como \"Lo vi en la cubierta de proa\" en "
"lugar de intentar buscar coordenadas GPS (marco global) o decir algo como "
"\"7 metros a mis cinco en punto\" (pasajero/objeto-local). El buque se "
"conoce como la estructura padre-local."

#: ../../docs/tutorials/math/rotations.rst:490
msgid ""
"In Godot, Basis matrices refer to the parent-local frame. If the object is "
"top level, then it's Basis is written in the global frame."
msgstr ""
"En Godot, las matrices de Basis (Base) se refieren al marco padre-local. Si "
"el objeto es de nivel superior, entonces su base se escribe en el marco "
"global."

#: ../../docs/tutorials/math/rotations.rst:495
msgid "Active and passive transformations"
msgstr "Transformaciones activas y pasivas"

#: ../../docs/tutorials/math/rotations.rst:497
msgid ""
"While operators (such as :math:`e^{\\varphi \\boldsymbol n \\cdot "
"\\boldsymbol J}` ) and vectors :math:`\\boldsymbol v` are \"out there\" and "
"are independent of the reference frame, their coordinates aren't. For "
"example, a vector can be aligned with the :math:`x`-axis in some frame  "
"whereas in can be aligned with :math:`y`-axis in another, if you choose to "
"draw your coordinate system differently. But the vector doesn't know about "
"your arbitrary choice of how and where you draw your coordinate system. When "
"we have multiple reference frames, it's important how the coordinates would "
"transform between them."
msgstr ""
"Mientras que los operadores (tales como :math:`e^{\\varphi \\boldsymbol n "
"\\cdot \\boldsymbol J}` ) y los vectores :math:`\\boldsymbol v` están \"ahí "
"fuera\" y son independientes del marco de referencia, sus coordenadas no lo "
"son. Por ejemplo, un vector puede alinearse con el eje :math:`x` en algún "
"cuadro mientras que en otro puede alinearse con el eje :math:`y` en otro si "
"decides dibujar tu sistema de coordenadas de forma diferente. Pero el vector "
"no sabe acerca de tu elección arbitraria de cómo y dónde dibujar tu sistema "
"de coordenadas. Cuando tenemos múltiples marcos de referencia, es importante "
"cómo se transforman las coordenadas entre ellos."

#: ../../docs/tutorials/math/rotations.rst:499
msgid ""
"For example, if you know that the coordinates of a vector :math:`"
"\\boldsymbol v` are given as :math:`v_x, v_y, v_z` in some reference frame, "
"you can obtain the coordinates in a different frame which is rotated which "
"respect to the first one around some :math:`\\boldsymbol n` axis by :math:`-"
"\\varphi` as"
msgstr ""
"Por ejemplo, si sabes que las coordenadas de un vector :math:`\\boldsymbol "
"v` se dan como :math:`v_x, v_y, v_z`en algún marco de referencia, puedes "
"obtener las coordenadas en un marco diferente que es girado con respecto al "
"primero alrededor de algún :math:`\\boldsymbol n` eje por :math:`-\\varphi` "
"como"

#: ../../docs/tutorials/math/rotations.rst:505
msgid ""
"where primed coordinates correspond to coordinates in the rotated *frame*. "
"You can also transform the matrix representations of operators. For "
"example, :math:`M_{ij} = \\boldsymbol e_i \\cdot M  \\boldsymbol e_j` but "
"what is the rotation matrix if we used the basis vectors of a different "
"frame :math:`\\{\\boldsymbol e_i'\\}`? To obtain the matrix representation "
"of :math:`M` in the new frame, you can do"
msgstr ""
"donde las coordenadas primarias corresponden a las coordenadas en el "
"*cuadro* girado. También se pueden transformar las representaciones "
"matriciales de los operadores. Por ejemplo, :math:`M_{ij} = \\boldsymbol e_i "
"\\cdot M  \\boldsymbol e_j` pero cual es la matriz de rotación si usamos los "
"vectores base de un marco diferente :math:`\\{\\boldsymbol e_i'\\}`? Para "
"obtener la representación matricial de :math:`M` en el nuevo marco se puede "
"hacer lo siguiente"

#: ../../docs/tutorials/math/rotations.rst:512
msgid "These are called passive transformations."
msgstr "Estas se llaman transformaciones pasivas."

#: ../../docs/tutorials/math/rotations.rst:514
msgid ""
"Now let's consider actually moving those objects (we consider only one "
"reference frame and it's fixed). We rotate a vector around some :math:`"
"\\boldsymbol n` axis by :math:`\\varphi`"
msgstr ""
"Ahora consideremos mover estos objetos (tenemos en cuenta sólo un marco de "
"referencia y está fijo). Giramos un vector alrededor de un eje del :math:`"
"\\boldsymbol n` por el eje :math:`\\varphi`"

#: ../../docs/tutorials/math/rotations.rst:520
msgid ""
"where primed coordinates are the coordinates of the rotated *vector*, in the "
"same reference frame. Similarly, for matrices"
msgstr ""
"donde las coordenadas de cebado son las coordenadas del *vector* rotado, en "
"el mismo sistema de referencia. Del mismo modo, para las matrices"

#: ../../docs/tutorials/math/rotations.rst:527
msgid "These are called active transformations."
msgstr "Estas se llaman transformaciones activas."

#: ../../docs/tutorials/math/rotations.rst:530
msgid ""
"Note how things fit nicely, for example, when you consider how a rotated "
"vector :math:`R_0 \\boldsymbol v_0` transforms:"
msgstr ""
"Nota cómo las cosas encajan perfectamente, por ejemplo, cuando consideras "
"cómo se transforma un vector rotado :math:`R_0 \\boldsymbol v_0`:"

#: ../../docs/tutorials/math/rotations.rst:536
msgid ""
"The left hand side is rotation of the vector :math:`(R_0 \\boldsymbol v_0)` "
"and the right hand side is the rotation of the vector :math:`v_0` and the "
"matrix :math:`R_0` that acts on it, which of course agree."
msgstr ""
"El lado izquierdo es la rotación del vector :math:`(R_0 \\boldsymbol v_0)` y "
"el lado derecho es la rotación del vector :math:`v_0` y la matriz :math:"
"`R_0` que actúa sobre él, lo que por supuesto está en consonancia."

#: ../../docs/tutorials/math/rotations.rst:539
msgid ""
"The rotation operator itself rotates in a expected way (you can use "
"Rodrigues' formula along with the equation above, if you prefer):"
msgstr ""
"El propio operador de rotación rota de una manera esperada (si lo prefieres, "
"puedes usar la fórmula de Rodrigues junto con la ecuación anterior):"

#: ../../docs/tutorials/math/rotations.rst:545
msgid ""
"For example, if we have a rotation around the :math:`z`-axis by :math:`"
"\\varphi_0 = \\varphi_z` and we would like to rotate it around the :math:`x`-"
"axis by :math:`\\varphi = \\pi/2`, we'd have"
msgstr ""
"Por ejemplo, si tenemos una rotación alrededor del eje :math:`z` por :math:`"
"\\varphi_0 = \\varphi_z` y nos gustaría rotarlo alrededor del eje :math:`x` "
"por :math:`\\varphi = \\pi/2`, tendríamos que"

#: ../../docs/tutorials/math/rotations.rst:551
msgid ""
"that is, the original rotation axis :math:`\\boldsymbol n_0 = \\boldsymbol "
"e_z` gets rotated around the :math:`x`-axis by :math:`\\varphi = \\pi/2` and "
"becomes a rotation around the :math:`y`-axis by :math:`-\\varphi_z`."
msgstr ""
"es decir, el eje de rotación original :math:`\\boldsymbol n_0 = \\boldsymbol "
"e_z` se rota alrededor del eje :math:`x` por :math:`\\varphi = \\pi/2` y se "
"convierte en una rotación alrededor del :math:`y`-axis by :math:`-"
"\\varphi_z`."
