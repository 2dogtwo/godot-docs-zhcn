# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2020, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-05-20 16:21+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:4
#, fuzzy
msgid "High-level multiplayer"
msgstr "Multijugador de alto nivel"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:7
#, fuzzy
msgid "High-level vs low-level API"
msgstr "Alto nivel VS bajo nivel API"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:9
msgid ""
"The following explains the differences of high- and low-level networking in "
"Godot as well as some fundamentals. If you want to jump in head-first and "
"add networking to your first nodes, skip to `Initializing the network`_ "
"below. But make sure to read the rest later on!"
msgstr ""
"A continuación se explican las diferencias de redes de alto y bajo nivel en "
"Godot, así como algunos aspectos fundamentales. Si deseas saltar de cabeza y "
"agregar redes a tus primeros nodos, salta a `Inicializando la red`_ a "
"continuación. ¡Pero asegúrate de leer el resto más tarde!"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:11
msgid ""
"Godot always supported standard low-level networking via UDP, TCP and some "
"higher level protocols such as SSL and HTTP. These protocols are flexible "
"and can be used for almost anything. However, using them to synchronize game "
"state manually can be a large amount of work. Sometimes that work can't be "
"avoided or is worth it, for example when working with a custom server "
"implementation on the backend. But in most cases, it's worthwhile to "
"consider Godot's high-level networking API, which sacrifices some of the "
"fine-grained control of low-level networking for greater ease of use."
msgstr ""
"Godot siempre soportó conexiones de red estándar de bajo nivel a través de "
"UDP, TCP y algunos protocolos de alto nivel como SSL y HTTP. Estos "
"protocolos son flexibles y se pueden utilizar para casi cualquier cosa. Sin "
"embargo, usarlos para sincronizar el estado del juego manualmente puede ser "
"una gran cantidad de trabajo. A veces ese trabajo no se puede evitar o vale "
"la pena, por ejemplo cuando se trabaja con una implementación de servidor "
"personalizada en el backend. Pero en la mayoría de los casos vale la pena "
"considerar la API de red de alto nivel de Godot, que sacrifica algo del "
"control detallado de la red de bajo nivel para una mayor facilidad de uso."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:14
msgid "This is due to the inherent limitations of the low-level protocols:"
msgstr ""
"Esto se debe a las limitaciones inherentes de los protocolos de bajo nivel:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:16
msgid ""
"TCP ensures packets will always arrive reliably and in order, but latency is "
"generally higher due to error correction. It's also quite a complex protocol "
"because it understands what a \"connection\" is, and optimizes for goals "
"that often don't suit applications like multiplayer games. Packets are "
"buffered to be sent in larger batches, trading less per-packet overhead for "
"higher latency. This can be useful for things like HTTP, but generally not "
"for games. Some of this can be configured and disabled (e.g. by disabling "
"\"Nagle's algorithm\" for the TCP connection)."
msgstr ""
"TCP asegura que los paquetes siempre llegarán de manera confiable y en "
"orden, pero la latencia generalmente es más alta debido a la corrección de "
"errores. También es un protocolo bastante complejo porque entiende lo que es "
"una \"conexión\" y se optimiza para los objetivos que a menudo no se adaptan "
"a aplicaciones como los juegos multijugador. Los paquetes se almacenan en el "
"búfer para enviarlos en lotes más grandes, intercambiando menos sobrecarga "
"por paquete para una mayor latencia. Esto puede ser útil para cosas como "
"HTTP, pero generalmente no para juegos. Parte de esto se puede configurar y "
"desactivar (por ejemplo, desactivando el \"algoritmo de Nagle\" para la "
"conexión TCP)."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:18
msgid ""
"UDP is a simpler protocol, which only sends packets (and has no concept of a "
"\"connection\"). No error correction makes it pretty quick (low latency), "
"but packets may be lost along the way or received in the wrong order. Added "
"to that, the MTU (maximum packet size) for UDP is generally low (only a few "
"hundred bytes), so transmitting larger packets means splitting them, "
"reorganizing them and retrying if a part fails."
msgstr ""
"UDP es un protocolo más simple que solo envía paquetes (y no tiene ningún "
"concepto de \"conexión\"). No poseer corrección de errores lo hace bastante "
"rápido (baja latencia), pero los paquetes pueden perderse en el camino o ser "
"recibidos en el orden incorrecto. Además de eso, el MTU (tamaño máximo de "
"paquete) para UDP es generalmente baja (solo unos pocos cientos de bytes), "
"por lo que la transmisión de paquetes más grandes significa dividirlos, "
"reorganizarlos y volver a intentar si una pieza falla."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:23
msgid ""
"In general, TCP can be thought of as reliable, ordered, and slow; UDP as "
"unreliable, unordered and fast. Because of the large difference in "
"performance, it often makes sense to re-build the parts of TCP wanted for "
"games (optional reliability and packet order), while avoiding the unwanted "
"parts (congestion/traffic control features, Nagle's algorithm, etc). Due to "
"this, most game engines come with such an implementation, and Godot is no "
"exception."
msgstr ""
"En general, se puede pensar que TCP es confiable, ordenado y lento; UDP como "
"no confiable, no ordenado y rápido. Debido a la gran diferencia en el "
"rendimiento, a menudo tiene sentido volver a construir las partes de TCP "
"deseadas para los juegos (confiabilidad opcional y orden de paquetes) "
"mientras se evitan las partes no deseadas (funciones de congestión/control "
"de tráfico, algoritmo de Nagle, etc.). Debido a esto, la mayoría de los "
"motores de juegos vienen con una implementación así, y Godot no es una "
"excepción."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:26
msgid ""
"In summary, you can use the low-level networking API for maximum control and "
"implement everything on top of bare network protocols or use the high-level "
"API based on :ref:`SceneTree <class_SceneTree>` that does most of the heavy "
"lifting behind the scenes in a generally optimized way."
msgstr ""
"En resumen, puedes usar la API de red de bajo nivel para obtener el máximo "
"control e implementar todo encima de los protocolos de red puros o usar la "
"API de alto nivel basada en :ref:`SceneTree <class_SceneTree>` que hace la "
"mayor parte del trabajo pesado detrás de las escenas de una manera "
"generalmente optimizada."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:28
msgid ""
"Most of Godot's supported platforms offer all or most of the mentioned high- "
"and low-level networking features. As networking is always largely hardware "
"and operating system dependent, however, some features may change or not be "
"available on some target platforms. Most notably, the HTML5 platform "
"currently only offers WebSocket support and lacks some of the higher level "
"features as well as raw access to low-level protocols like TCP and UDP."
msgstr ""
"La mayoría de las plataformas compatibles con Godot ofrecen todas o la "
"mayoría de las funciones de red de alto y bajo nivel mencionadas. Sin "
"embargo, como las redes siempre dependen en gran medida del hardware y del "
"sistema operativo, algunas funciones pueden cambiar o no estar disponibles "
"en algunas plataformas de destino. En particular, la plataforma HTML5 "
"actualmente solo ofrece compatibilidad con WebSocket y carece de algunas de "
"las características de mayor nivel, así como del acceso sin formato a "
"protocolos de bajo nivel como TCP y UDP."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:34
#, fuzzy
msgid ""
"More about TCP/IP, UDP, and networking: https://gafferongames.com/post/"
"udp_vs_tcp/"
msgstr ""
"Más sobre TCP/IP, UDP y redes: https://gafferongames.com/post/udp_vs_tcp/"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:37
#, fuzzy
msgid ""
"Gaffer On Games has a lot of useful articles about networking in Games "
"(`here <https://gafferongames.com/categories/game-networking/>`__), "
"including the comprehensive `introduction to networking models in games "
"<https://gafferongames.com/post/"
"what_every_programmer_needs_to_know_about_game_networking/>`__."
msgstr ""
"Gaffer On Games tiene muchos artículos útiles sobre la creación de redes en "
"Juegos (`aquí <https://gafferongames.com/tags/networking>`__), incluida la "
"exhaustiva `introduction to networking models in games <https://"
"gafferongames.com/post/"
"what_every_programmer_needs_to_know_about_game_networking/>`__ (introducción "
"a modelos de redes en juegos)."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:41
msgid ""
"If you want to use your low-level networking library of choice instead of "
"Godot's built-in networking, see here for an example: https://github.com/"
"PerduGames/gdnet3"
msgstr ""
"Si deseas utilizar tu biblioteca de redes de bajo nivel preferida en lugar "
"de la red integrada de Godot, consulta aquí un ejemplo: https://github.com/"
"PerduGames/gdnet3"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:45
msgid ""
"Adding networking to your game comes with some responsibility. It can make "
"your application vulnerable if done wrong and may lead to cheats or "
"exploits. It may even allow an attacker to compromise the machines your "
"application runs on and use your servers to send spam, attack others or "
"steal your users data if they play your game."
msgstr ""
"Agregar red a tu juego viene con algo de responsabilidad. Puede hacer que tu "
"aplicación sea vulnerable si se hace mal y puede generar trampas o exploits. "
"Incluso puede permitir que un atacante comprometa las máquinas en las que se "
"ejecuta tu aplicación y use tus servidores para enviar correo no deseado, "
"ataque a otros o robe los datos de tus usuarios si juegan tu juego."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:50
msgid ""
"This is always the case when networking is involved and has nothing to do "
"with Godot. You can of course experiment, but when you release a networked "
"application, always take care of any possible security concerns."
msgstr ""
"Este es siempre el caso cuando se trata de redes y no tiene nada que ver con "
"Godot. Por supuesto, puedes experimentar, pero cuando liberes una aplicación "
"en red, siempre ocúpate de cualquier posible problema de seguridad."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:55
msgid "Mid level abstraction"
msgstr "Abstracción de nivel medio"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:57
msgid ""
"Before going into how we would like to synchronize a game across the "
"network, it can be helpful to understand how the base network API for "
"synchronization works."
msgstr ""
"Antes de entrar en cómo nos gustaría sincronizar un juego en la red, puede "
"ser útil entender cómo funciona la base de la API de red  para la "
"sincronización."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:59
msgid ""
"Godot uses a mid-level object :ref:`NetworkedMultiplayerPeer "
"<class_NetworkedMultiplayerPeer>`. This object is not meant to be created "
"directly, but is designed so that several C++ implementations can provide it."
msgstr ""
"Godot usa un objeto de nivel medio :ref:`NetworkedMultiplayerPeer "
"<class_NetworkedMultiplayerPeer>`. Este objeto no esta hecho para crearse "
"directamente, sino que está diseñado para que varias implementaciones C++ "
"puedan proveerlo."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:62
msgid ""
"This object extends from :ref:`PacketPeer <class_PacketPeer>`, so it "
"inherits all the useful methods for serializing, sending and receiving data. "
"On top of that, it adds methods to set a peer, transfer mode, etc. It also "
"includes signals that will let you know when peers connect or disconnect."
msgstr ""
"Este objeto se extiende de :ref:`PacketPeer <class_PacketPeer>`, por lo que "
"hereda todos los métodos útiles para serializar, enviar y recibir datos. "
"Encima de eso, agrega métodos para configurar un peer, modo de "
"transferencia, etc. También incluye señales que le permitirán saber cuándo "
"se conectan o desconectan los peers."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:64
#, fuzzy
msgid ""
"This class interface can abstract most types of network layers, topologies "
"and libraries. By default, Godot provides an implementation based on ENet (:"
"ref:`NetworkedMultiplayerEnet <class_NetworkedMultiplayerENet>`), one based "
"on WebRTC (:ref:`WebRTCMultiplayer <class_WebRTCMultiplayer>`), and one "
"based on WebSocket (:ref:`WebSocketMultiplayerPeer "
"<class_WebSocketMultiplayerPeer>`), but this could be used to implement "
"mobile APIs (for ad hoc WiFi, Bluetooth) or custom device/console-specific "
"networking APIs."
msgstr ""
"Esta interfaz de clase puede abstraer la mayoría de los tipos de capas de "
"red, topologías y bibliotecas. Por defecto, Godot proporciona una "
"implementación basada en ENet (:ref:`NetworkedMultiplayerEnet "
"<class_NetworkedMultiplayerENet>`), pero esto podría usarse para implementar "
"APIs móviles (para adhoc WiFi, Bluetooth) o APIs personalizadas de red "
"específicas del dispositivo/consola."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:70
msgid ""
"For most common cases, using this object directly is discouraged, as Godot "
"provides even higher level networking facilities. Yet it is made available "
"in case a game has specific needs for a lower level API."
msgstr ""
"Para la mayoría de los casos comunes, se desaconseja usar este objeto "
"directamente, ya que Godot proporciona funciones de red de nivel aún más "
"alto. Sin embargo, está disponible en caso de que un juego tenga necesidades "
"específicas de un API de nivel inferior."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:74
msgid "Initializing the network"
msgstr "Inicializando la red"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:76
msgid ""
"The object that controls networking in Godot is the same one that controls "
"everything tree-related: :ref:`SceneTree <class_SceneTree>`."
msgstr ""
"El objeto que controla las redes en Godot es el mismo que controla todo lo "
"relacionado con el árbol: :ref:`SceneTree <class_SceneTree>`."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:78
#, fuzzy
msgid ""
"To initialize high-level networking, the SceneTree must be provided a "
"NetworkedMultiplayerPeer object."
msgstr ""
"Para inicializar redes de alto nivel, el SceneTree debe proporcionar un "
"objeto NetworkedMultiplayerPeer."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:80
msgid ""
"To create that object, it first has to be initialized as a server or client."
msgstr ""
"Para crear ese objeto, primero tiene que ser inicializado como un servidor o "
"cliente."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:82
msgid ""
"Initializing as a server, listening on the given port, with a given maximum "
"number of peers:"
msgstr ""
"Inicializando como un servidor, escuchando en el puerto dado, con un número "
"máximo de pares dado:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:90
msgid "Initializing as a client, connecting to a given IP and port:"
msgstr ""
"Inicializando como un cliente, conectándose a una IP y un puerto dados:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:98
msgid "Get the previously set network peer:"
msgstr ""

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:104
msgid "Checking whether the tree is initialized as a server or client:"
msgstr "Comprobando si el árbol se inicializó como servidor o cliente:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:110
msgid "Terminating the networking feature:"
msgstr "Terminar la función de red:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:116
msgid ""
"(Although it may make sense to send a message first to let the other peers "
"know you're going away instead of letting the connection close or timeout, "
"depending on your game.)"
msgstr ""
"(Aunque puede tener sentido enviar un mensaje primero para que los otros "
"compañeros sepan que te vas a ir en lugar de dejar que la conexión se cierre "
"o se agote el tiempo de espera, dependiendo de tu juego.)"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:119
msgid "Managing connections"
msgstr "Administrar conexiones"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:121
#, fuzzy
msgid ""
"Some games accept connections at any time, others during the lobby phase. "
"Godot can be requested to no longer accept connections at any point (see "
"``set_refuse_new_network_connections(bool)`` and related methods on :ref:"
"`SceneTree <class_SceneTree>`). To manage who connects, Godot provides the "
"following signals in SceneTree:"
msgstr ""
"Algunos juegos aceptan conexiones en cualquier momento, otros durante la "
"fase de lobby(vestíbulo). Se puede solicitar a Godot que ya no acepte "
"conexiones en ningún punto (mira `set_refuse_new_network_connections(bool)` "
"y métodos relacionados en :ref:`SceneTree <class_SceneTree>`). Para "
"administrar quién se conecta, Godot proporciona las siguientes señales en "
"SceneTree:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:124
msgid "Server and Clients:"
msgstr "Servidor y Clientes:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:126
#, fuzzy
msgid "``network_peer_connected(int id)``"
msgstr "`network_peer_connected(int id)`"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:127
#, fuzzy
msgid "``network_peer_disconnected(int id)``"
msgstr "`network_peer_disconnected(int id)`"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:129
msgid ""
"The above signals are called on every peer connected to the server "
"(including on the server) when a new peer connects or disconnects. Clients "
"will connect with a unique ID greater than 1, while network peer ID 1 is "
"always the server. Anything below 1 should be handled as invalid. You can "
"retrieve the ID for the local system via :ref:`SceneTree."
"get_network_unique_id() <class_SceneTree_method_get_network_unique_id>`. "
"These IDs will be useful mostly for lobby management and should generally be "
"stored, as they identify connected peers and thus players. You can also use "
"IDs to send messages only to certain peers."
msgstr ""
"Las señales anteriores se invocan en cada peer conectado al servidor "
"(incluso en el servidor) cuando un nuevo peer se conecta o desconecta. Los "
"clientes se conectarán con una ID única mayor que 1, mientras que la ID de "
"red peer 1 es siempre el servidor. Cualquier cosa por debajo de 1 debe "
"manejarse como inválida. Puedes recuperar la ID para el sistema local a "
"través de :ref:`SceneTree.get_network_unique_id() "
"<class_SceneTree_method_get_network_unique_id>`. Estas IDs serán útiles "
"sobre todo para la gestión del lobby y, en general, se deben almacenar ya "
"que identifican a los peers conectados y, por tanto, a los jugadores. "
"También puedes usar las IDs para enviar mensajes solo a ciertos peers."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:135
msgid "Clients:"
msgstr "Clientes:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:137
#, fuzzy
msgid "``connected_to_server``"
msgstr "Conexiones"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:138
#, fuzzy
msgid "``connection_failed``"
msgstr "Conexiones"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:139
#, fuzzy
msgid "``server_disconnected``"
msgstr "`network_peer_disconnected(int id)`"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:141
msgid ""
"Again, all these functions are mainly useful for lobby management or for "
"adding/removing players on the fly. For these tasks, the server clearly has "
"to work as a server and you have to perform tasks manually such as sending a "
"newly connected player information about other already connected players (e."
"g. their names, stats, etc)."
msgstr ""
"Una vez más, todas estas funciones son principalmente útiles para la gestión "
"del lobby o para agregar/quitar jugadores en el momento. Para estas tareas, "
"el servidor claramente tiene que funcionar como servidor y tu debes realizar "
"tareas manualmente, como enviar un jugador recién conectado o información "
"sobre otros jugadores que ya están conectados (por ejemplo, sus nombres, "
"estadísticas, etc.)."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:145
msgid ""
"Lobbies can be implemented any way you want, but the most common way is to "
"use a node with the same name across scenes in all peers. Generally, an "
"autoloaded node/singleton is a great fit for this, to always have access to, "
"e.g. \"/root/lobby\"."
msgstr ""
"Los lobbys pueden ser implementados de la forma que desees, pero la manera "
"más común es usar un nodo con el mismo nombre a través de escenas en todos "
"los peers. Generalmente, un nodo/singleton autocargado es ideal para esto, "
"para tener siempre acceso a, por ejemplo, \"/root/lobby\"."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:149
msgid "RPC"
msgstr ""

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:151
msgid ""
"To communicate between peers, the easiest way is to use RPCs (remote "
"procedure calls). This is implemented as a set of functions in :ref:`Node "
"<class_Node>`:"
msgstr ""
"Para comunicarse entre peers, la forma más fácil es usar RPC (llamadas de "
"procedimiento remoto). Esto se implementa como un conjunto de funciones en :"
"ref:`Node <class_Node>`:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:154
msgid "``rpc(\"function_name\", <optional_args>)``"
msgstr ""

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:155
msgid "``rpc_id(<peer_id>,\"function_name\", <optional_args>)``"
msgstr ""

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:156
msgid "``rpc_unreliable(\"function_name\", <optional_args>)``"
msgstr ""

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:157
msgid "``rpc_unreliable_id(<peer_id>, \"function_name\", <optional_args>)``"
msgstr ""

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:159
msgid "Synchronizing member variables is also possible:"
msgstr ""

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:161
msgid "``rset(\"variable\", value)``"
msgstr ""

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:162
msgid "``rset_id(<peer_id>, \"variable\", value)``"
msgstr ""

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:163
msgid "``rset_unreliable(\"variable\", value)``"
msgstr ""

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:164
msgid "``rset_unreliable_id(<peer_id>, \"variable\", value)``"
msgstr ""

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:166
msgid "Functions can be called in two fashions:"
msgstr "Las funciones se pueden llamar de dos maneras:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:168
msgid ""
"Reliable: the function call will arrive no matter what, but may take longer "
"because it will be re-transmitted in case of failure."
msgstr ""
"Confiable: la llamada a la función llegará sin importar qué, pero puede "
"llevar más tiempo porque se retransmitirá en caso de falla."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:169
msgid ""
"Unreliable: if the function call does not arrive, it will not be re-"
"transmitted; but if it arrives, it will do it quickly."
msgstr ""
"No Confiable: si la llamada de función no llega, no se retransmitirá, pero "
"si llega, lo hará rápidamente."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:171
msgid ""
"In most cases, reliable is desired. Unreliable is mostly useful when "
"synchronizing object positions (sync must happen constantly, and if a packet "
"is lost, it's not that bad because a new one will eventually arrive and it "
"would likely be outdated because the object moved further in the meantime, "
"even if it was resent reliably)."
msgstr ""
"En la mayoría de los casos, confiable es deseado. No confiable es útil "
"principalmente para sincronizar posiciones de objetos (la sincronización "
"debe ocurrir constantemente, y si se pierde un paquete, no es tan malo "
"porque finalmente llegará uno nuevo y es probable que esté desactualizado "
"porque, mientras tanto el objeto se movió aún más, incluso si fue reenviado "
"de manera confiable)."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:174
#, fuzzy
msgid ""
"There is also the ``get_rpc_sender_id`` function in ``SceneTree``, which can "
"be used to check which peer (or peer ID) sent an RPC."
msgstr ""
"También está la función `get_rpc_sender_id` en `SceneTree` que se puede usar "
"para verificar qué peer (o ID peer) envió una llamada RPC."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:177
msgid "Back to lobby"
msgstr "De vuelta al lobby"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:179
msgid ""
"Let's get back to the lobby. Imagine that each player that connects to the "
"server will tell everyone about it."
msgstr ""
"Volvamos al lobby. Imagina que cada jugador que se conecta al servidor se lo "
"cuenta a todos."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:225
#, fuzzy
msgid ""
"You might have already noticed something different, which is the usage of "
"the ``remote`` keyword on the ``register_player`` function:"
msgstr ""
"Ya habrás notado algo diferente, que es el uso de la palabra clave `remote` "
"en la función `register_player`:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:231
msgid ""
"This keyword has two main uses. The first is to let Godot know that this "
"function can be called from RPC. If no keywords are added, Godot will block "
"any attempts to call functions for security. This makes security work a lot "
"easier (so a client can't call a function to delete a file on another "
"client's system)."
msgstr ""
"Esta palabra clave tiene dos usos principales. El primero es dejar que Godot "
"sepa que esta función se puede llamar desde RPC. Si no se agregan palabras "
"clave, Godot bloqueará cualquier intento de invocar funciones por razones de "
"seguridad. Esto hace que la seguridad funcione mucho más fácilmente (por lo "
"que un cliente no puede llamar a una función para eliminar un archivo en el "
"sistema de otro cliente)."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:235
msgid ""
"The second use is to specify how the function will be called via RPC. There "
"are four different keywords:"
msgstr ""
"El segundo uso es especificar cómo se llamará la función a través de RPC. "
"Hay cuatro palabras clave diferentes:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:237
#, fuzzy
msgid "``remote``"
msgstr "remote"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:238
#, fuzzy
msgid "``remotesync``"
msgstr "`remotesync`"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:239
#, fuzzy
msgid "``master``"
msgstr "master"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:240
#, fuzzy
msgid "``puppet``"
msgstr "puppet"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:242
#, fuzzy
msgid ""
"The ``remote`` keyword means that the ``rpc()`` call will go via network and "
"execute remotely."
msgstr ""
"La palabra clave `remote` significa que la llamada `rpc()` irá a través de "
"la red y se ejecutará de forma remota."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:244
#, fuzzy
msgid ""
"The ``remotesync`` keyword means that the ``rpc()`` call will go via network "
"and execute remotely, but will also execute locally (do a normal function "
"call)."
msgstr ""
"La palabra clave `remotesync` significa que la llamada`rpc()` irá a través "
"de la red y se ejecutará de forma remota, pero también se ejecutará "
"localmente (realiza una llamada a función normal)."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:246
#, fuzzy
msgid ""
"The others will be explained further down. Note that you could also use the "
"``get_rpc_sender_id`` function on ``SceneTree`` to check which peer actually "
"made the RPC call to ``register_player``."
msgstr ""
"Los otros serán explicados más abajo. Tenga en cuenta que también puede usar "
"la función `get_rpc_sender_id` en` SceneTree` para verificar qué peer "
"realmente hizo la llamada RPC a `register_player`."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:249
msgid ""
"With this, lobby management should be more or less explained. Once you have "
"your game going, you will most likely want to add some extra security to "
"make sure clients don't do anything funny (just validate the info they send "
"from time to time, or before game start). For the sake of simplicity and "
"because each game will share different information, this is not shown here."
msgstr ""
"Con esto, la gestión del lobby debería estar más o menos explicada. Una vez "
"que tengas listo tu juego, lo más probable es que quieras agregar un poco de "
"seguridad adicional para asegurarse de que los clientes no hagan nada raro "
"(solo valida la información que envían de vez en cuando, o antes de que "
"comience el juego). Por razones de simplicidad y porque cada juego "
"compartirá información diferente, esto no se muestra aquí."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:254
msgid "Starting the game"
msgstr "Comenzando el juego"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:256
msgid ""
"Once enough players have gathered in the lobby, the server should probably "
"start the game. This is nothing special in itself, but we'll explain a few "
"nice tricks that can be done at this point to make your life much easier."
msgstr ""
"Una vez que se hayan reunido suficientes jugadores en el lobby, el servidor "
"probablemente debería comenzar el juego. Esto no es nada especial en sí "
"mismo, pero explicaremos algunos trucos agradables que se pueden hacer en "
"este punto para hacer tu vida mucho más fácil."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:260
msgid "Player scenes"
msgstr "Escenas del jugador"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:262
msgid ""
"In most games, each player will likely have its own scene. Remember that "
"this is a multiplayer game, so in every peer you need to instance **one "
"scene for each player connected to it**. For a 4 player game, each peer "
"needs to instance 4 player nodes."
msgstr ""
"En la mayoría de los juegos, cada jugador probablemente tendrá su propia "
"escena. Recuerda que este es un juego multijugador, por lo que en cada peer "
"debes incluir **una escena para cada jugador conectado a ella**. Para un "
"juego de 4 jugadores, cada peer necesita instaurar 4 nodos de jugador."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:265
msgid ""
"So, how to name such nodes? In Godot, nodes need to have a unique name. It "
"must also be relatively easy for a player to tell which node represents each "
"player ID."
msgstr ""
"Entonces, ¿cómo nombrar esos nodos? En Godot, los nodos deben tener un "
"nombre único. También debe ser relativamente fácil para un jugador decir qué "
"nodos representan cada ID de jugador."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:268
msgid ""
"The solution is to simply name the *root nodes of the instanced player "
"scenes as their network ID*. This way, they will be the same in every peer "
"and RPC will work great! Here is an example:"
msgstr ""
"La solución es simplemente nombrar el *nodo raíz de las escenas del jugador "
"instanciadas como su ID de red*. De esta forma, serán iguales en todos los "
"pares y RPC funcionará de maravilla. Aquí hay un ejemplo:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:297
msgid ""
"Depending on when you execute pre_configure_game(), you may need to change "
"any calls to ``add_child()`` to be deferred via ``call_deferred()``, as the "
"SceneTree is locked while the scene is being created (e.g. when ``_ready()`` "
"is being called)."
msgstr ""
"Dependiendo de cuándo ejecutes pre_configure_game(), es posible que "
"necesites cambiar algunas llamadas a ``add_child()`` a ser diferidas "
"mediante ``call_deferred()``, ya que SceneTree está bloqueado mientras se "
"está creando la escena (por ejemplo, cuando ``_ready()`` se está llamando)."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:301
msgid "Synchronizing game start"
msgstr "Sincronizando el inicio del juego"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:303
msgid ""
"Setting up players might take different amounts of time for every peer due "
"to lag, different hardware, or other reasons. To make sure the game will "
"actually start when everyone is ready, pausing the game until all players "
"are ready can be useful:"
msgstr ""
"Configurar los jugadores puede tomar una cantidad de tiempo diferente en "
"cada peer debido al lag(retraso), hardware diferente u otras razones. Para "
"asegurarte de que el juego realmente comience cuando todos estén listos, "
"pausar el juego hasta que todos los jugadores estén listos puede ser útil:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:312
msgid ""
"When the server gets the OK from all the peers, it can tell them to start, "
"as for example:"
msgstr ""
"Cuando el servidor obtiene el OK de todos los peers, puede indicarles que "
"comiencen, como por ejemplo:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:333
msgid "Synchronizing the game"
msgstr "Sincronizando el juego"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:335
msgid ""
"In most games, the goal of multiplayer networking is that the game runs "
"synchronized on all the peers playing it. Besides supplying an RPC and "
"remote member variable set implementation, Godot adds the concept of network "
"masters."
msgstr ""
"En la mayoría de los juegos, el objetivo de las redes multijugador es que el "
"juego se ejecute sincronizado con todos los peers que lo juegan. Además de "
"proporcionar un RPC y la implementación de un conjunto de variables miembro "
"remotas, Godot añade el concepto de red maestra."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:339
msgid "Network master"
msgstr "Red maestra"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:341
msgid ""
"The network master of a node is the peer that has the ultimate authority "
"over it."
msgstr ""
"La red maestra de un nodo es el peer que tiene la máxima autoridad sobre él."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:343
msgid ""
"When not explicitly set, the network master is inherited from the parent "
"node, which if not changed, is always going to be the server (ID 1). Thus "
"the server has authority over all nodes by default."
msgstr ""
"Cuando no se establece explícitamente la red maestra es heredada del nodo "
"padre, que si no se cambia siempre será el servidor (ID 1). Por tanto, el "
"servidor tiene autoridad sobre todos los nodos por defecto."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:345
#, fuzzy
msgid ""
"The network master can be set with the function :ref:`Node."
"set_network_master(id, recursive) <class_Node_method_set_network_master>` "
"(recursive is ``true`` by default and means the network master is "
"recursively set on all child nodes of the node as well)."
msgstr ""
"La red maestra se puede configurar con la función :ref:`Node."
"set_network_master(id, recursive) <class_Node_method_set_network_master>` "
"(recursive es verdadero de manera predeterminada y significa que la red "
"maestra también se establece recursivamente en todos los nodos hijos del "
"nodo también)."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:348
#, fuzzy
msgid ""
"Checking that a specific node instance on a peer is the network master for "
"this node for all connected peers is done by calling :ref:`Node."
"is_network_master() <class_Node_method_is_network_master>`. This will return "
"``true`` when executed on the server and ``false`` on all client peers."
msgstr ""
"Comprobar que una instancia de nodo específica en un peer es la red maestra "
"para este nodo, para todos los peers conectados se hace llamando a :ref:"
"`Node.is_network_master() <class_Node_method_is_network_master>`. Este "
"retornara verdadero cuando se ejecute en el servidor y falso en todos los "
"peers clientes."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:350
msgid ""
"If you have paid attention to the previous example, it's possible you "
"noticed that each peer was set to have network master authority for their "
"own player (Node) instead of the server:"
msgstr ""
"Si has prestado atención al ejemplo anterior, es posible que haya notado que "
"el peer local está configurado para tener autoridad de red maestra para su "
"propio (nodo) jugador en lugar del servidor:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:370
msgid ""
"Each time this piece of code is executed on each peer, the peer makes itself "
"master on the node it controls, and all other nodes remain as puppets with "
"the server being their network master."
msgstr ""
"Cada vez que esta pieza de código se ejecuta en cada peer, el peer se hace "
"maestro en el nodo que controla, y todos los otros nodos permanecen como "
"marionetas con el servidor siendo su red maestra."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:372
msgid ""
"To clarify, here is an example of how this looks in the `bomber demo "
"<https://github.com/godotengine/godot-demo-projects/tree/master/networking/"
"multiplayer_bomber>`_:"
msgstr ""
"Para aclarar, aquí hay un ejemplo de cómo se ve esto en el `bomber demo "
"<https://github.com/godotengine/godot-demo-projects/tree/master/networking/"
"multiplayer_bomber>`_:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:379
msgid "Master and puppet keywords"
msgstr "Palabras clave master y puppet"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:383
#, fuzzy
msgid ""
"The real advantage of this model is when used with the ``master``/``puppet`` "
"keywords in GDScript (or their equivalent in C# and Visual Script). "
"Similarly to the ``remote`` keyword, functions can also be tagged with them:"
msgstr ""
"La verdadera ventaja de este modelo es cuando se usa con las palabras clave "
"`master`/`puppet` en GDScript (o su equivalente en C# y Visual Script). "
"Similar a la palabra clave `remote`, las funciones también se pueden "
"etiquetar con ellas:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:386
msgid "Example bomb code:"
msgstr "Ejemplo de código de bomba:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:394
msgid "Example player code:"
msgstr "Ejemplo de código de jugador:"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:408
#, fuzzy
msgid ""
"In the above example, a bomb explodes somewhere (likely managed by whoever "
"is master). The bomb knows the bodies in the area, so it checks them and "
"checks that they contain an ``exploded`` function."
msgstr ""
"En el ejemplo anterior, una bomba explota en algún lugar (probablemente sea "
"administrada por quien sea master). La bomba conoce los cuerpos en el área, "
"por lo que los verifica y verifica que contengan una función 'exploded'."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:411
#, fuzzy
msgid ""
"If they do, the bomb calls ``exploded`` on it. However, the ``exploded`` "
"method in the player has a ``master`` keyword. This means that only the "
"player who is master for that instance will actually get the function."
msgstr ""
"Si lo tienen, la bomba llama 'exploded' en él. Sin embargo, el método "
"`exploded` en el jugador tiene una palabra clave`master`. Esto significa que "
"solo el jugador que es master para esa instancia realmente obtendrá la "
"función."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:414
#, fuzzy
msgid ""
"This instance, then, calls the ``stun`` method in the same instances of that "
"same player (but in different peers), and only those which are set as "
"puppet, making the player look stunned in all the peers (as well as the "
"current, master one)."
msgstr ""
"Esta instancia, entonces, llama a la función `stun` en las mismas instancias "
"de ese mismo jugador (pero en diferentes peers), y solo aquellos que se "
"establecen como puppet, haciendo que el jugador se vea aturdido en todos los "
"peers (así como en el actual , único master)."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:417
#, fuzzy
msgid ""
"Note that you could also send the ``stun()`` message only to a specific "
"player by using ``rpc_id(<id>, \"exploded\", bomb_owner)``. This may not "
"make much sense for an area-of-effect case like the bomb, but in other "
"cases, like single target damage."
msgstr ""
"Ten en cuenta que también puedes enviar el mensaje stun() solo a un jugador "
"específico utilizando rpc_id(<id>, \"exploded\", bomb_owner). Esto puede no "
"tener mucho sentido para un caso de área de efecto como el de la bomba, sino "
"en otros casos, como daño a un solo objetivo."

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:425
#, fuzzy
msgid "Exporting for dedicated servers"
msgstr "Exportar para la Web"

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:427
msgid ""
"Once you've made a multiplayer game, you may want to export it to run it on "
"a dedicated server with no GPU available. See :ref:"
"`doc_exporting_for_dedicated_servers` for more information."
msgstr ""

#: ../../docs/tutorials/networking/high_level_multiplayer.rst:433
msgid ""
"The code samples on this page aren't designed to run on a dedicated server. "
"You'll have to modify them so the server isn't considered to be a player. "
"You'll also have to modify the game starting mechanism so that the first "
"player who joins can start the game."
msgstr ""
