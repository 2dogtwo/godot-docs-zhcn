# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2020, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-05-20 16:21+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:4
msgid "Control the game's UI with code"
msgstr "コードを使用してゲームのUIを制御する"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:7
msgid "Intro"
msgstr "イントロ"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:9
msgid ""
"In this tutorial, you will connect a character to a life bar and animate the "
"health loss."
msgstr ""
"このチュートリアルでは、キャラクターをライフバーに接続し、その健康状態の表示"
"をライブバーで行います。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:14
msgid ""
"Here's what you'll create: the bar and the counter animate when the "
"character takes a hit. They fade when it dies."
msgstr ""
"ここで作成するのは、キャラクターがヒットを受けたときにバーとカウンターをアニ"
"メーションさせるものです。キャラクターが死ぬと徐々に消えます。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:18
msgid "You will learn:"
msgstr "次の方法について学習します:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:20
msgid "How to **connect** a character to a GUI with signals"
msgstr "シグナルを使ってキャラクターをGUIに **接続** する方法"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:21
msgid "How to **control** a GUI with GDscript"
msgstr "GDscriptを使用してGUIを **制御する** 方法"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:22
msgid "How to **animate** a life bar with the :ref:`Tween <class_Tween>` node"
msgstr ""
":ref:`Tween <class_Tween>`\\ ノードを使ってライフ バーを\\ **アニメーション化"
"する**\\ 方法"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:25
msgid ""
"If you want to learn how to set up the interface instead, check out the step-"
"by-step UI tutorials:"
msgstr ""
"代わりにインターフェイスを設定する方法を学びたい場合は、ステップバイステップ"
"のUIチュートリアルを参照してください:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:28
msgid "Create a main menu screen"
msgstr "メインメニュー画面の作成"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:29
msgid "Create a game user interface"
msgstr "ゲーム ユーザーインターフェイスの作成"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:32
msgid ""
"When you code a game, you want to build the core gameplay first: the main "
"mechanics, player input, win and loss conditions. The UI comes a bit later. "
"You want to keep all the elements that make up your project separate if "
"possible. Each character should be in its own scene, with its own scripts, "
"and so should the UI elements. This prevents bugs, keeps your project "
"manageable, and allows different team members to work on different parts of "
"the game."
msgstr ""
"ゲームをコーディングするときには、最初にゲームプレイのコアとなる部分、つまり"
"動作のメカニズム、プレイヤーの入力、勝敗条件を構築しなければなりません。その"
"後にUIを設計します。可能であれば、プロジェクトを構成するすべての要素を別々に"
"しておきます。各キャラクタは独自のシーンの中に、独自のスクリプトを持って存在"
"する必要があり、UI要素もそれと同様です。これによってバグを防ぎ、プロジェクト"
"を管理しやすくし、異なるチームメンバーがゲームのそれぞれの部分で作業できるよ"
"うになります。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:40
msgid ""
"Once the core gameplay and the UI are ready, you'll need to connect them "
"somehow. In our example, we have the Enemy who attacks the Player at "
"constant time intervals. We want the life bar to update when the Player "
"takes damage."
msgstr ""
"中核となるゲームプレイとUIの準備ができたら、何らかの方法でそれらを接続する必"
"要があります。この例では、一定の時間間隔でプレイヤーを攻撃する敵がいます。プ"
"レイヤーがダメージを受けたときは、ライフバーには更新してほしいでしょう。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:45
msgid "To do this, we will use **signals**."
msgstr "これを行うには、 **シグナル** を使用します。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:49
msgid ""
"Signals are Godot's version of the Observer pattern. They allow us to send "
"out some message. Other nodes can connect to the object that **emits** the "
"signal and receive the information. It's a powerful tool we use a lot for "
"User Interface and achievement systems. You don't want to use them "
"everywhere, though. Connecting two nodes adds some coupling between them. "
"When there's a lot of connections, they become hard to manage. For more "
"information, check out the `signals video tutorial <https://youtu.be/"
"l0BkQxF7X3E>`_ on GDquest."
msgstr ""
"シグナルは、ObserverパターンのGodot版です。メッセージを送信することができま"
"す。他のノードは、シグナルを **発信** するオブジェクトに接続して、情報を受信"
"できます。これは強力なツールで、ユーザーインターフェイスや実績システムで多用"
"されています。ただし、全ての場面で使用する必要はありません。 2つのノードを接"
"続すると、ノード間の結合度が増します。接続が多いと、それだけ管理するのが難し"
"くなります。詳細については、GDquestの \\ `signals video tutorial <https://"
"youtu.be/l0BkQxF7X3E>`_\\ (英語)をご覧ください。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:53
msgid "Download and explore the start project"
msgstr "スタートプロジェクトをダウンロードして参照する"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:55
msgid ""
"Download the Godot project: :download:`ui_code_life_bar.zip <files/"
"ui_code_life_bar.zip>`. It contains all the assets and scripts you need to "
"get started. Extract the .zip archive to get two folders: `start` and `end`."
msgstr ""
"Godotプロジェクトをダウンロード(:download:`ui_code_life_bar.zip <files/"
"ui_code_life_bar.zip>`)してください。チュートリアルに必要なすべての素材やスク"
"リプトが入っています。zipアーカイブを解凍して、2つのフォルダ `start` と "
"`end` を取得します。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:58
msgid ""
"Load the ``start`` project in Godot. In the ``FileSystem`` dock, double "
"click on LevelMockup.tscn to open it. It's an RPG game's mockup where 2 "
"characters face each other. The pink enemy attacks and damages the green "
"square at regular time intervals, until its death. Feel free to try out the "
"game: the basic combat mechanics already work. But as the character isn't "
"connected to the life bar, the ``GUI`` doesn't do anything."
msgstr ""
"Godotに ``start`` プロジェクトを読み込みます。 ``ファイルシステム`` ドック"
"で、LevelMockup.tscnをダブルクリックして開きます。 2人のキャラクターが向かい"
"合っているRPGゲームのモックアップです。ピンク色の敵は、死ぬまで一定の時間間隔"
"で緑色の正方形を攻撃し、ダメージを与えます。ゲームを試してみてください: 基本"
"的な戦闘の仕組みはすでに機能しています。ですが、キャラクターはライフバーに接"
"続されていないため、\\ ``GUI`` は何もしません。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:68
msgid ""
"This is typical of how you'd code a game: you implement the core gameplay "
"first, handle the player's death, and only then you'll add the interface. "
"That's because the UI listens to what's happening in the game. So it can't "
"work if other systems aren't in place yet. If you design the UI before you "
"prototype and test the gameplay, chances are it won't work well and you'll "
"have to re-create it from scratch."
msgstr ""
"これは、ゲームのコーディング方法の典型です。まず最初にゲームプレイのコアを実"
"装し、プレイヤー死亡の処理ができてから、ようやくインターフェイスを追加しま"
"す。なぜなら、UIはゲーム内で起こっていることに耳を傾けているからです。なの"
"で、他のシステムがまだ存在していない段階では動きません。ゲームプレイのプロト"
"タイプを作成してテストする前にUIを設計しても、多分うまく機能せずに最初からつ"
"くり直すはめになるでしょう。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:71
msgid "The scene contains a background sprite, a GUI, and two characters."
msgstr ""
"シーンには、背景スプライト、GUI、および2つのキャラクターが含まれています。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:75
msgid "The scene tree, with the GUI scene set to display its children"
msgstr "シーンツリー (GUIシーンの子を表示するように設定)"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:77
msgid ""
"The GUI scene encapsulates all of the game's Graphical User Interface. It "
"comes with a barebones script where we get the path to nodes that exist "
"inside the scene:"
msgstr ""
"GUIシーンは、ゲームのすべてのグラフィカル ユーザーインターフェイス(GUI)をカプ"
"セル化します。シーン内に存在するノードへのパスを取得するためのベアボーン スク"
"リプトが付属しています:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:105
msgid ""
"``number_label`` displays a life count as a number. It's a ``Label`` node"
msgstr ""
"``number_label`` は、残り体力を数値として表示します。 これは ``Label`` ノード"
"です"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:107
msgid "``bar`` is the life bar itself. It's a ``TextureProgress`` node"
msgstr ""
"``bar`` はライフバーそのものです。 これは ``TextureProgress`` ノードです"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:108
msgid ""
"``tween`` is a component-style node that can animate and control any value "
"or method from any other node"
msgstr ""
"``tween`` はコンポーネント スタイルなノードで、他のノードにある任意の値または"
"メソッドをアニメーション化および制御できます。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:113
#, fuzzy
msgid ""
"The project uses a simple organization that works for game jams and tiny "
"games."
msgstr ""
"このプロジェクトは、ゲームジャムや小さなゲームに適したシンプルな構造を使用し"
"ています。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:115
msgid ""
"At the root of the project, in the `res://` folder, you will find the "
"`LevelMockup`. That's the main game scene and the one we will work with. All "
"the components that make up the game are in the `scenes/` folder. The "
"`assets/` folder contains the game sprites and the font for the HP counter. "
"In the `scripts/` folder you will find the enemy, the player, and the GUI "
"controller scripts."
msgstr ""
"プロジェクトのルートの `res ://` フォルダに `LevelMockup` があります。これが"
"メインのゲームシーンであり、ここで作業します。ゲームを構成するすべてのコン"
"ポーネントは、 `scenes/` フォルダにあります。 `assets/` フォルダには、ゲーム"
"のスプライトとHPカウンタのフォントが含まれています。 `scripts/` フォルダに"
"は、敵のスクリプト、プレイヤーのスクリプト、GUIコントローラのスクリプトがあり"
"ます。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:117
msgid ""
"Click the edit scene icon to the right of the node in the scene tree to open "
"the scene in the editor. You'll see the LifeBar and EnergyBar are sub-scenes "
"themselves."
msgstr ""
"シーンツリーのノードの右側にあるシーン編集アイコンをクリックして、エディタで"
"シーンを開きます。 「LifeBar」と「EnergyBar」はそれ自体サブシーンです。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:121
msgid "The scene tree, with the Player scene set to display its children"
msgstr "シーンツリー (Playerシーンの子を表示するように設定)"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:124
msgid "Set up the Lifebar with the Player's max\\_health"
msgstr "プレイヤーのmax\\_healthを使用してライフバーをセットアップする"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:126
msgid ""
"We have to tell the GUI somehow what the player's current health is, to "
"update the lifebar's texture, and to display the remaining health in the HP "
"counter in the top left corner of the screen. To do this we send the "
"player's health to the GUI every time they take damage. The GUI will then "
"update the ``Lifebar`` and ``Number`` nodes with this value."
msgstr ""
"プレイヤーの現在の状態を何らかの方法でGUIに伝え、ライフバーのテクスチャを更新"
"し、残りの体力を画面左上のHPカウンターに表示する必要があります。そのために、"
"プレイヤーがダメージを受けるたびに、プレイヤーの体力をGUIに送信します。GUI"
"は、この値で ``Lifebar`` ノードと ``Number`` ノードを更新します。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:132
msgid ""
"We could stop here to display the number, but we need to initialize the "
"bar's ``max_value`` for it to update in the right proportions. The first "
"step is thus to tell the ``GUI`` what the green character's ``max_health`` "
"is."
msgstr ""
"ここで数字を表示させることもできますが、その前に、正しい比率で更新するため、"
"バーの max_value を初期化する必要があります。なので最初のステップは、緑のキャ"
"ラクターの ``max_health`` を ``GUI`` に伝えることです。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:139
msgid ""
"The bar, a `TextureProgress`, has a `max_value` of `100` by default. If you "
"don't need to display the character's health with a number, you don't need "
"to change its `max_value` property. You send a percentage from the `Player` "
"to the `GUI` instead:  `health / max_health * 100`."
msgstr ""
"`TextureProgress` であるバーは、デフォルトで `max_value` が `100` になってい"
"ます。 キャラクターの体力を数字で表示する必要がない場合は、その `max_value` "
"プロパティを変更する必要はありません。代わりに、 `Player` から `GUI` にパーセ"
"ンテージを送信します: \\ `health / max_health * 100`\\ 。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:143
msgid ""
"Click the script icon to the right of the ``GUI`` in the Scene dock to open "
"its script. In the ``_ready`` function, we're going to store the "
"``Player``'s ``max_health`` in a new variable and use it to set the "
"``bar``'s ``max_value``:"
msgstr ""
"シーンドック内の ``GUI`` の右側にあるスクリプトアイコンをクリックして、スクリ"
"プトを開きます。 ``_ready`` 関数にて、プレイヤーの ``max_health`` を新しい変"
"数に格納し、それを使って ``bar`` の ``max_value`` を設定します:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:164
msgid ""
"Let's break it down. ``$\"../Characters/Player\"`` is a shorthand that goes "
"one node up in the scene tree, and retrieves the ``Characters/Player`` node "
"from there. It gives us access to the node. The second part of the "
"statement, ``.max_health``, accesses the ``max_health`` on the Player node."
msgstr ""
"1つずつ見てみましょう。 ``$\"../Characters/Player\"`` は簡略記法で、シーンツ"
"リーで1つ上のノードに移動し、そこから ``Characters/Player`` ノードを取得しま"
"す。これにより目的のノードにアクセスできます。文の2番目の部分、 ``."
"max_health`` は、Playerノード上の ``max_health`` にアクセスします。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:170
msgid ""
"The second line assigns this value to ``bar.max_value``. You could combine "
"the two lines into one, but we'll need to use ``player_max_health`` again "
"later in the tutorial."
msgstr ""
"2行目は、この値を ``bar.max_value`` に割り当てます。 この2行を1つにまとめるこ"
"ともできますが、チュートリアルの後半でもう一度 ``player_max_health`` を使う必"
"要があります。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:174
msgid ""
"``Player.gd`` sets the ``health`` to ``max_health`` at the start of the "
"game, so we could work with this. Why do we still use ``max_health``? There "
"are two reasons:"
msgstr ""
"``Player.gd`` はゲーム開始時に ``health`` を ``max_health`` に設定するので、"
"このまま作業できます。なぜ ``max_health`` を使用しているのでしょう？　これに"
"は 2つの理由があります:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:178
msgid ""
"We don't have the guarantee that ``health`` will always equal "
"``max_health``: a future version of the game may load a level where the "
"player already lost some health."
msgstr ""
"``health`` が常に ``max_health`` と等しい保証はありません。このゲームの将来"
"バージョンでは、プレイヤーが体力をいくらか失った状態でも、次のレベルを読み込"
"めるようにするかもしれません。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:184
msgid ""
"When you open a scene in the game, Godot creates nodes one by one, following "
"the order in your Scene dock, from top to bottom. `GUI` and `Player` are not "
"part of the same node branch. To make sure they both exist when we access "
"each other, we have to use the `_ready` function. Godot calls `_ready` right "
"after it loaded all nodes, before the game starts. It's the perfect function "
"to set everything up and prepare the game session. Learn more about _ready: :"
"doc:`scripting_continued`"
msgstr ""
"ゲーム内でシーンを開くと、Godotはシーンドック内の順序に従って、上から下にノー"
"ドを1つずつ作成していきます。 `GUI` と `Player` は、同じノードブランチの一部"
"ではありません。これらが相互にアクセスするときに両方とも存在することを確認す"
"るには、 `_ready` 関数を使用する必要があります。Godotは、すべてのノードをロー"
"ドした直後、ゲームを開始する前に `_ready` を呼び出します。これは、すべてを設"
"定してゲームセッションを準備するには最適な関数です。\\ _ready の詳細について"
"は\\ :doc:`scripting_continued`\\ を参照して下さい。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:188
msgid "Update health with a signal when the player takes a hit"
msgstr "プレイヤーがヒットしたときにシグナルで体力を更新する"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:190
msgid ""
"Our GUI is ready to receive the ``health`` value updates from the "
"``Player``. To achieve this we're going to use **signals**."
msgstr ""
"GUIは ``Player`` から ``health`` の更新値を受け取る準備ができています。これを"
"実現するために、\\ **シグナル**\\ を使用します。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:195
msgid ""
"There are many useful built-in signals like `enter_tree` and `exit_tree`, "
"that all nodes emit when they are respectively created and destroyed. You "
"can also create your own using the `signal` keyword. On the `Player` node, "
"you'll find two signals we created for you: `died` and `health_changed`."
msgstr ""
"たくさんの便利な組み込みシグナルがあり、たとえば全てのノードが持つ\\ "
"`enter_tree` と `exit_tree` は、それぞれ作成されたときと破棄されたときに発信"
"します。\\ `signal` キーワードを使用すれば、独自のシグナルを作成することもで"
"きます。 `Player` ノードには、そうして用意された2つのシグナル `died` と "
"`health_changed` がすでにあります。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:197
msgid ""
"Why don't we directly get the ``Player`` node in the ``_process`` function "
"and look at the health value? Accessing nodes this way creates tight "
"coupling between them. If you did it sparingly it may work. As your game "
"grows bigger, you may have many more connections. If you get nodes this way "
"it gets complex quickly. Not only that: you need to listen to the state "
"change constantly in the ``_process`` function. This check happens 60 times "
"a second and you'll likely break the game because of the order in which the "
"code runs."
msgstr ""
"``_process`` 関数内で ``Player`` ノードを直接取得し、体力値を確認するのはどう"
"でしょう？　この方法でノードにアクセスすると、ノード間に緊密な結合ができてし"
"まいます。これは控えめにやれば、うまくいくかもしれません。しかし、ゲームが大"
"きくなるにつれて、より多くの接続をすることになるはずです。この方法でノードを"
"取得して行くと、すぐに複雑になってしまいます。問題はそれだけではありません: "
"``_process`` 関数内で、常に他のノードの状態変化を確認する必要があります。この"
"チェックは(60FPSのゲームなら)1秒間に60回行われ、コードには実行順序があるので"
"恐らくゲームが中断されることになるでしょう。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:206
msgid ""
"On a given frame you may look at another node's property *before* it was "
"updated: you get a value from the last frame. This leads to obscure bugs "
"that are hard to fix. On the other hand, a signal is emitted right after a "
"change happened. It **guarantees** you're getting a fresh piece of "
"information. And you will update the state of your connected node *right "
"after* the change happened."
msgstr ""
"特定のフレームで、更新「前」に別のノードのプロパティを参照すると、その直前の"
"フレームから値が取得されます。これは、修正が難しい不明瞭なバグにつながりま"
"す。一方、シグナルは変化が起こった直後に発せられます。新しい情報を **確実** "
"に入手できるのです。また、変更が行われた「直後」に、接続されたノードの状態を"
"更新します。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:215
#, fuzzy
msgid ""
"The Observer pattern, that signals derive from, still adds a bit of coupling "
"between node branches. But it's generally lighter and more secure than "
"accessing nodes directly to communicate between two separate classes. It can "
"be okay for a parent node to get values from its children. But you'll want "
"to favor signals if you're working with two separate branches. Read Game "
"Programming Patterns for more information on the `Observer pattern <https://"
"gameprogrammingpatterns.com/observer.html>`_. The `full book <https://"
"gameprogrammingpatterns.com/contents.html>`_ is available online for free."
msgstr ""
"Observerパターンは、シグナルの基盤ですが、ノードのブランチ間に若干の結合を追"
"加します。しかし大抵の場合、2つの異なるクラス間での通信においては、ノードに直"
"接アクセスするよりも軽量で安全です。親ノードから子の値を取得することは問題あ"
"りません。しかし、2つの別々のブランチをまたいで作業しているなら、シグナルを優"
"先したほうがいいでしょう。Observerパターンの詳細については、Game Programming "
"Patternsの `Observer pattern <http://gameprogrammingpatterns.com/observer."
"html>`_ (英語)を参照してください。\\ `full book <http://"
"gameprogrammingpatterns.com/contents.html>`_\\ はオンラインで無料で入手できま"
"す。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:219
msgid ""
"With this in mind, let's connect the ``GUI`` to the ``Player``. Click on the "
"``Player`` node in the scene dock to select it. Head down to the Inspector "
"and click on the Node tab. This is the place to connect nodes to listen to "
"the one you selected."
msgstr ""
"これを念頭に置いて、 ``GUI`` を ``Player`` に接続しましょう。まずシーンドック"
"の ``Player`` ノードをクリックして選択します。インスペクタに移動し、「ノー"
"ド」タブをクリックします。ここは、選択したノードからのシグナルを受信待機させ"
"るために、ノードを接続する場所です。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:224
msgid "The first section lists custom signals defined in ``Player.gd``:"
msgstr ""
"最初のセクションでは、 ``Player.gd`` で定義されているカスタムシグナルを一覧表"
"示します:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:226
msgid ""
"``died`` is emitted when the character died. We will use it in a moment to "
"hide the UI."
msgstr ""
"キャラクターが死んだときには ``died`` が出力されます。 このシグナルは後で、UI"
"を非表示にするために使用します。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:228
msgid "``health_changed`` is emitted when the character got hit."
msgstr "``health_changed`` は、キャラクタがヒットを受けたときに放出されます。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:232
msgid "We're connecting to the health\\_changed signal"
msgstr "これから「health\\_changed」シグナルに接続します"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:234
msgid ""
"Select ``health_changed`` and click on the Connect button in the bottom "
"right corner to open the Connect Signal window. On the left side you can "
"pick the node that will listen to this signal. Select the ``GUI`` node. The "
"right side of the screen lets you pack optional values with the signal. We "
"already took care of it in ``Player.gd``. In general I recommend not to add "
"too many arguments using this window as they're less convenient than doing "
"it from the code."
msgstr ""
"``health_changed`` を選択し、右下隅の「接続」ボタンをクリックして、「シグナル"
"の接続」ウィンドウを開きます。左側で、この信号を受信待機するノードを選択でき"
"ます。 ``GUI`` ノードを選択します。画面の右側にて、オプションの値を信号に加え"
"ることができます。これについては、すでに ``Player.gd`` 内で済ませてあります。"
"コード内にて行うよりも不便なので、このウィンドウを使うなら、通常は引数を追加"
"しすぎないようにすることをお勧めします。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:244
msgid "The Connect Signal window with the GUI node selected"
msgstr "GUIノードが選択された「シグナル接続」ウィンドウ"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:248
msgid ""
"You can optionally connect nodes from the code. However doing it from the "
"editor has two advantages:"
msgstr ""
"必要に応じて、コード内でノードを接続できます。ただし、エディタから実行するこ"
"とには次の利点2つがあります:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:250
msgid "Godot can write new callback functions for you in the connected script"
msgstr ""
"Godotはあなたに代わって、接続されたスクリプト内に新しいコールバック関数を書け"
"ます"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:251
msgid ""
"An emitter icon appears next to the node that emits the signal in the Scene "
"dock"
msgstr ""
"シーンドック内で、信号を発信するノードの横に発信元アイコンが表示されます"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:253
msgid ""
"At the bottom of the window you will find the path to the node you selected. "
"We're interested in the second row called \"Method in Node\". This is the "
"method on the ``GUI`` node that gets called when the signal is emitted. This "
"method receives the values sent with the signal and lets you process them. "
"If you look to the right, there is a \"Make Function\" radio button that is "
"on by default. Click the connect button at the bottom of the window. Godot "
"creates the method inside the ``GUI`` node. The script editor opens with the "
"cursor inside a new ``_on_Player_health_changed`` function."
msgstr ""
"ウィンドウの下部に、選択したノードへのパスが表示されます。\"Method in Node"
"\"と呼ばれる 2 行目に注目して下さい。これは、シグナルが出力されるときに呼び出"
"される ``GUI`` ノード上のメソッドです。このメソッドは、シグナルと共に送信され"
"た値を受け取り、それらを処理できるようにします。右側を見ると、デフォルトで"
"「関数を作成」ラジオボタンがオンになっています。ウィンドウの下部にある接続ボ"
"タンをクリックします。Godot は ``GUI`` ノード内にメソッドを作成します。スクリ"
"プトエディタが開き、新しい ``_on_Player_health_changed`` 関数内にカーソルが置"
"かれます。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:265
msgid ""
"When you connect nodes from the editor, Godot generates a method name with "
"the following pattern: ``_on_EmitterName_signal_name``. If you wrote the "
"method already, the \"Make Function\" option will keep it. You may replace "
"the name with anything you'd like."
msgstr ""
"エディタからノードを接続すると、Godotは ``_on_EmitterName_signal_name "
"(_on_(発信元名)_(シグナル名))`` のパターンでメソッド名を生成します。すでにそ"
"のメソッドが書かれている場合は、「関数を作成」オプションが有効であっても内容"
"は保持されます。この名前は任意の名前に置き換えることができます。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:272
msgid "Godot writes the callback method for you and takes you to it"
msgstr "Godotはコールバック メソッドを作成し、あなたに見せます"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:274
msgid ""
"Inside the parentheses after the function name, add a ``player_health`` "
"argument. When the player emits the ``health_changed`` signal, it will send "
"its current ``health`` alongside it. Your code should look like:"
msgstr ""
"関数名の後の括弧内に ``player_health`` 引数を追加してください。プレイヤーが "
"``health_changed`` シグナルを発信すると、現在の ``health`` も一緒に送信しま"
"す。コードは次のようになります。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:292
msgid ""
"The engine does not convert PascalCase to snake_case, for C# examples we'll "
"be using PascalCase for method names & camelCase for method parameters, "
"which follows the official `C# naming conventions. <https://docs.microsoft."
"com/en-us/dotnet/standard/design-guidelines/capitalization-conventions>`_"
msgstr ""
"エンジンは PascalCase を snake_case に変換しません。C#の例では、メソッド名に "
"PascalCase を、メソッドパラメータに camelCase を使用しています。これは公式の"
"\\ `C#命名規則 <https://docs.microsoft.com/ja-jp/dotnet/standard/design-"
"guidelines/capitalization-conventions>`_\\ に従うものです。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:299
msgid ""
"In Player.gd, when the Player emits the health\\_changed signal, it also "
"sends its health value"
msgstr ""
"Player.gdでは、Playerがhealth\\_changedシグナルを発信すると、その体力値も送信"
"します"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:302
msgid ""
"Inside ``_on_Player_health_changed``, let's call a second function called "
"``update_health`` and pass it the ``player_health`` variable."
msgstr ""
"``_on_Player_health_changed`` 内で、 ``update_health`` と呼ばれる2番目の関数"
"を呼び出して、 ``player_health`` 変数を渡します。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:307
msgid ""
"We could directly update the health value on `LifeBar` and `Number`. There "
"are two reasons to use this method instead:"
msgstr ""
"`LifeBar`と`Number`の体力値を直接更新できます。 代わりにこの方法を使用する理"
"由は2つあります:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:309
msgid ""
"The name makes it clear for our future selves and teammates that when the "
"player took damage, we update the health count on the GUI"
msgstr ""
"この名前は、プレイヤーがダメージを受けたときに GUI の体力(health)カウントを更"
"新することを、将来の自分自身やチームメイトのために明確にします"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:310
msgid "We will reuse this method a bit later"
msgstr "この方法は少し後で再利用します"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:312
msgid ""
"Create a new ``update_health`` method below ``_on_Player_health_changed``. "
"It takes a new\\_value as its only argument:"
msgstr ""
"``_on_Player_health_changed`` の下に新しい ``update_health`` メソッドを作成し"
"ます。唯一の引数としてnew\\_valueを取ります:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:327
msgid "This method needs to:"
msgstr "このメソッドは以下を行う必要があります:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:329
msgid ""
"set the ``Number`` node's ``text`` to ``new_value`` converted to a string"
msgstr ""
"``Number`` ノードの ``text`` を文字列に変換された ``new_value`` に設定します"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:331
msgid "set the ``TextureProgress``'s ``value`` to ``new_value``"
msgstr "``TextureProgress`` の ``value`` を ``new_value`` に設定します"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:350
msgid ""
"``str`` is a built-in function that converts about any value to text. "
"``Number``'s ``text`` property requires a string, so we can't assign it to "
"``new_value`` directly"
msgstr ""
"``str`` は、ほぼすべての値をテキストに変換する組み込み関数です。 ``Number`` "
"の ``text`` プロパティには文字列が必要なので、それを ``new_value`` に直接割り"
"当てることはできません"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:354
msgid ""
"Also call ``update_health`` at the end of the ``_ready`` function to "
"initialize the ``Number`` node's ``text`` with the right value at the start "
"of the game. Press :kbd:`F5` to test the game: the life bar updates with "
"every attack!"
msgstr ""
"また、\\ ``_ready`` 関数の最後で ``update_health`` を呼び出して、ゲームの開始"
"時に適切な値で ``Number`` ノードの ``text`` を初期化します。\\ :kbd:`F5` を押"
"してゲームをテストします。攻撃を受けるたびにライフバーが更新されます！"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:361
msgid ""
"Both the Number node and the TextureProgress update when the Player takes a "
"hit"
msgstr ""
"Playerがヒットすると、NumberノードとTextureProgressの両方が更新されます"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:365
msgid "Animate the loss of life with the Tween node"
msgstr "Tweenノードを使用した、自機損失のアニメーション"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:367
msgid ""
"Our interface is functional, but it could use some animation. That's a good "
"opportunity to introduce the ``Tween`` node, an essential tool to animate "
"properties. ``Tween`` animates anything you'd like from a start to an end "
"state over a certain duration. For example, it can animate the health on the "
"``TextureProgress`` from its current level to the ``Player``'s new "
"``health`` when the character takes damage."
msgstr ""
"このインターフェイスは機能していますが、いくつかのアニメーションを使用するこ"
"とができます。これは、プロパティをアニメーション化するために不可欠なツールで"
"ある ``Tween`` ノードを導入する良い機会です。 ``Tween`` は、一定の期間にわ"
"たって開始状態から終了状態まで、必要なものをアニメーション化します。たとえ"
"ば、キャラクタがダメージを受けたときに、 ``TextureProgress`` の体力(health)を"
"現在のレベルから ``Player`` の新しい ``health`` にアニメートできます。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:374
msgid ""
"The ``GUI`` scene already contains a ``Tween`` child node stored in the "
"``tween`` variable. Let's now use it. We have to make some changes to "
"``update_health``."
msgstr ""
"``GUI`` シーンには、 ``tween`` 変数に格納されている ``Tween`` 子ノードが既に"
"含まれています。それでは、それを使用してみましょう。 ``update_health`` にいく"
"つかの変更を加える必要があります。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:378
msgid ""
"We will use the ``Tween`` node's ``interpolate_property`` method. It takes "
"seven arguments:"
msgstr ""
"``Tween`` ノードの ``interpolate_property`` メソッドを使用します。引数は7つあ"
"ります:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:381
msgid "A reference to the node who owns the property to animate"
msgstr "アニメーションするプロパティを所有するノードへの参照"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:382
msgid "The property's identifier as a string"
msgstr "文字列としてのプロパティの識別子"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:383
msgid "The starting value"
msgstr "開始値"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:384
msgid "The end value"
msgstr "終了値"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:385
msgid "The animation's duration in seconds"
msgstr "アニメーションの継続時間(秒)"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:386
msgid "The type of the transition"
msgstr "トランジションのタイプ"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:387
msgid "The easing to use in combination with the equation."
msgstr "方程式と組み合わせて使用するイージング。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:389
msgid ""
"The last two arguments combined correspond to an easing equation. This "
"controls how the value evolves from the start to the end point."
msgstr ""
"最後の 2 つの引数を組み合わせると、イージング方程式に対応します。これにより、"
"始点から終点まで間に値がどのように変化するかを制御します。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:393
msgid ""
"Click the script icon next to the ``GUI`` node to open it again. The "
"``Number`` node needs text to update itself, and the ``Bar`` needs a float "
"or an integer. We can use ``interpolate_property`` to animate a number, but "
"not to animate text directly. We're going to use it to animate a new ``GUI`` "
"variable named ``animated_health``."
msgstr ""
"``GUI`` ノードの横にあるスクリプト・アイコンをクリックして再度開きます。 "
"``Number`` ノード自体を更新するにはテキストが必要で、 ``Bar`` には浮動小数点"
"または整数が必要です。 ``interpolate_property`` を使用して数値をアニメーショ"
"ンすることはできますが、テキストを直接アニメーションさせることはできません。"
"これを使用して、 ``animated_health`` という名前の新しい ``GUI変数`` をアニ"
"メーション化します。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:399
msgid ""
"At the top of the script, define a new variable, name it "
"``animated_health``, and set its value to 0. Navigate back to the "
"``update_health`` method and clear its content. Let's animate the "
"``animated_health`` value. Call the ``Tween`` node's "
"``interpolate_property`` method:"
msgstr ""
"スクリプトの先頭で、新しい変数を定義し、 ``animated_health`` という名前を付"
"け、値を0に設定します。 ``update_health`` メソッドに戻り、その内容をクリアし"
"ます。 ``animated_health`` 値をアニメートします。 ``Tween`` ノードの "
"``interpolate_property`` メソッドを呼び出します:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:421
msgid "Let's break down the call:"
msgstr "呼出を中断しましょう:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:427
msgid ""
"We target ``animated_health`` on ``self``, that is to say the ``GUI`` node. "
"``Tween``'s interpolate\\_property takes the property's name as a string. "
"That's why we write it as ``\"animated_health\"``."
msgstr ""
"``animated_health`` を ``self`` 、つまり ``GUI`` ノードをターゲットにしま"
"す。 ``Tween`` の ``interpolation_property`` は、プロパティの名前を文字列とし"
"て取得します。 ですので ``\"animated_health\"`` とします。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:435
msgid ""
"The starting point is the current value the bar's at. We still have to code "
"this part, but it's going to be ``animated_health``. The end point of the "
"animation is the ``Player``'s ``health`` after the ``health_changed``: "
"that's ``new_value``. And ``0.6`` is the animation's duration in seconds."
msgstr ""
"開始点は、バーの現在の値です。この部分はまだコーディングする必要があります"
"が、 ``animated_health`` になります。アニメーションの終了点は、 "
"``health_changed`` 後の ``Player`` の ``health`` 、つまり ``new_value`` で"
"す。 ``0.6`` はアニメーションの秒単位の長さです。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:445
msgid ""
"The last two arguments are constants from the ``Tween`` class. "
"``TRANS_LINEAR`` means the animation should be linear. ``EASE_IN`` doesn't "
"do anything with a linear transition, but we must provide this last argument "
"or we'll get an error."
msgstr ""
"最後の2つの引数は、 ``Tween`` クラスの定数です。 ``TRANS_LINEAR`` は、アニ"
"メーションがリニアでなければならないことを意味します。 ``EASE_IN`` は線形遷移"
"では何も行いませんが、この最後の引数を指定しないとエラーが発生します。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:450
msgid ""
"The animation will not play until we activated the ``Tween`` node with "
"``tween.start()``. We only have to do this once if the node is not active. "
"Add this code after the last line:"
msgstr ""
"``tween.start()`` で ``Tween`` ノードをアクティブにするまでアニメーションは再"
"生されません。ノードがアクティブでない場合は、これを一度だけ実行する必要があ"
"ります。 最後の行の後にこのコードを追加します:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:469
msgid ""
"Although we could animate the `health` property on the `Player`, we "
"shouldn't. Characters should lose life instantly when they get hit. It makes "
"it a lot easier to manage their state, like to know when one died. You "
"always want to store animations in a separate data container or node. The "
"`tween` node is perfect for code-controlled animations. For hand-made "
"animations, check out `AnimationPlayer`."
msgstr ""
"`Player` の `health` プロパティをアニメートすることはできますが、そうすべきで"
"はありません。キャラクターは命中するとすぐにライフを失います。これにより、い"
"つ死亡したかを知りたいなど、状態を管理しやすくなります。アニメーションは常に"
"別のデータ コンテナーまたはノードに格納する必要があります。 `tween` ノード"
"は、コードで制御されたアニメーションに最適です。自作のアニメーションについて"
"は、 `AnimationPlayer` をご覧ください。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:472
msgid "Assign the animated\\_health to the LifeBar"
msgstr "LifeBarにanimated\\_healthを割り当て"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:474
msgid ""
"Now the ``animated_health`` variable animates but we don't update the actual "
"``Bar`` and ``Number`` nodes anymore. Let's fix this."
msgstr ""
"``animated_health`` 変数はアニメーションされますが、実際の ``Bar`` ノードと"
"``Number`` ノードは更新されません。これを修正しましょう。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:477
msgid "So far, the update\\_health method looks like this:"
msgstr "これまでのところ、update\\_healthメソッドは次のようになります:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:501
msgid ""
"In this specific case, because ``number_label`` takes text, we need to use "
"the ``_process`` method to animate it. Let's now update the ``Number`` and "
"``TextureProgress`` nodes like before, inside of ``_process``:"
msgstr ""
"この例では、 ``number_label`` はテキストを取るため、 ``_process`` メソッドを"
"使ってアニメーションする必要があります。前と同じように、 ``_process`` 内の "
"``Number`` ノードと ``TextureProgress`` ノードを更新します:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:523
msgid ""
"`number_label` and `bar` are variables that store references to the `Number` "
"and `TextureProgress` nodes."
msgstr ""
"`number_label` と `bar` は、 `Number` ノードと `TextureProgress` ノードへの参"
"照を格納する変数です。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:525
msgid ""
"Play the game to see the bar animate smoothly. But the text displays decimal "
"number and looks like a mess. And considering the style of the game, it'd be "
"nice for the life bar to animate in a choppier fashion."
msgstr ""
"ゲームをプレイして、バーがスムーズにアニメーションされるのを確認します。しか"
"し、テキストに小数点以下が表示され、混乱しているように見えます。また、ゲーム"
"のスタイルを考慮すると、ライフバーがより途切れやすい方法でアニメーションされ"
"るとよいでしょう。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:531
msgid "The animation is smooth, but the number is broken"
msgstr "アニメーションは滑らかですが、番号の表示が乱れています"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:533
msgid ""
"We can fix both problems by rounding out ``animated_health``. Use a local "
"variable named ``round_value`` to store the rounded ``animated_health``. "
"Then assign it to ``number_label.text`` and ``bar.value``:"
msgstr ""
"``animated_health`` を四捨五入することで両方の問題を解決できます。 "
"``round_value`` という名前のローカル変数を使用して、丸められた "
"``animated_health`` を格納します。 それを ``number_label.text`` と ``bar."
"value`` に割り当てます:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:555
msgid "Try the game again to see a nice blocky animation."
msgstr ""
"もう一度ゲームを実行すると、ブロックのようなアニメーションが表示されます。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:559
msgid "By rounding out animated\\_health, we kill two birds with one stone"
msgstr "animated\\_healthの四捨五入と文字列へ変換を一緒に行えば、一石二鳥です"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:563
msgid ""
"Every time the player takes a hit, the ``GUI`` calls "
"``_on_Player_health_changed``, which in turn calls ``update_health``. This "
"updates the animation and the ``number_label`` and ``bar`` follow in "
"``_process``. The animated life bar that shows the health going down "
"gradually is a trick. It makes the GUI feel alive. If the ``Player`` takes 3 "
"damage, it happens in an instant."
msgstr ""
"プレイヤーがヒットするたびに、 ``GUI`` は ``_on_Player_health_changed`` を呼"
"び出し、その ``_ on_Player_health_changed`` は ``update_health`` を呼び出しま"
"す。これにより、アニメーションが更新され、 ``_ process`` の ``number_label`` "
"と ``bar`` が更新されます。健康状態が徐々に低下する、アニメーションするライフ"
"バーは、単に見た目上のトリックですが、それによってGUIが生き生きと感じられま"
"す。もしも ``Player`` が3つのダメージを受けた場合、一瞬で発生します。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:571
msgid "Fade the bar when the Player dies"
msgstr "自機損失時にバーを消す"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:573
msgid ""
"When the green character dies, it plays a death animation and fades out. At "
"this point, we shouldn't show the interface anymore. Let's fade the bar as "
"well when the character died. We will reuse the same ``Tween`` node as it "
"manages multiple animations in parallel for us."
msgstr ""
"緑のキャラクタが消滅すると、消滅アニメーションが再生されて消えます。この時点"
"では、インタフェースは表示されません。キャラクターが死んだら、バーも消去しま"
"しょう。複数のアニメーションを並行して管理するため、同じ ``Tween`` ノードを再"
"利用します。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:578
msgid ""
"First, the ``GUI`` needs to connect to the ``Player``'s ``died`` signal to "
"know when it died. Press :kbd:`F1` to jump back to the 2D Workspace. Select "
"the ``Player`` node in the Scene dock and click on the Node tab next to the "
"Inspector."
msgstr ""
"まず、 ``GUI`` は ``Player`` の ``died`` シグナルに接続して、いつ死亡したかを"
"知る必要があります。 :kbd:`F1` を押して2Dワークスペースに戻ります。シーンドッ"
"クで ``Player`` ノードを選択し、インスペクタの隣にあるノードタブをクリックし"
"ます。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:583
msgid "Find the ``died`` signal, select it, and click the Connect button."
msgstr "``died`` シグナルを見つけて選択し、接続ボタンをクリックします。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:587
msgid "The signal should already have the Enemy connected to it"
msgstr "シグナルにはすでに敵が接続しているはずです"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:589
msgid ""
"In the Connecting Signal window, connect to the ``GUI`` node again. The Path "
"to Node should be ``../../GUI`` and the Method in Node should show "
"``_on_Player_died``. Leave the Make Function option on and click Connect at "
"the bottom of the window. This will take you to the ``GUI.gd`` file in the "
"Script Workspace."
msgstr ""
"シグナルの接続ウィンドウで、 ``GUI`` ノードにもう一度接続します。ノードへのパ"
"スは ``../../GUI`` 、ノード内のメソッドは ``_on_Player_died`` と表示されま"
"す。関数作成オプションをオンのままにして、ウィンドウ下部の接続をクリックしま"
"す。 これにより、スクリプトワークスペースの ``GUI.gd`` ファイルに移動します。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:597
msgid "You should get these values in the Connecting Signal window"
msgstr "これらの値は、シグナルの接続ウィンドウに表示されます"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:601
msgid ""
"You should see a pattern by now: every time the GUI needs a new piece of "
"information, we emit a new signal. Use them wisely: the more connections you "
"add, the harder they are to track."
msgstr ""
"GUIが新しい情報を必要とするたびに、新しいシグナルを発信します。より多くのコネ"
"クションを追加すればするほど、それらを追跡するのは難しくなります。上手く使い"
"ましょう。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:603
msgid ""
"To animate a fade on a UI element, we have to use its ``modulate`` property. "
"``modulate`` is a ``Color`` that multiplies the colors of our textures."
msgstr ""
"UI要素でフェードをアニメーションするには、その ``modulate`` プロパティを使用"
"する必要があります。 ``modulate`` はテクスチャの色を乗算する ``Color`` です。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:609
msgid ""
"`modulate` comes from the `CanvasItem` class, All 2D and UI nodes inherit "
"from it. It lets you toggle the visibility of the node, assign a shader to "
"it, and modify it using a color with `modulate`."
msgstr ""
"`modulate` は `CanvasItem` クラスから取得され、すべての2DノードとUIノードはこ"
"れを継承します。ノードの表示/非表示を切り替え、シェーダを割り当て、 "
"`modulate` で色を使用して修正することができます。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:611
msgid ""
"``modulate`` takes a ``Color`` value with 4 channels: red, green, blue and "
"alpha. If we darken any of the first three channels it darkens the "
"interface. If we lower the alpha channel, our interface fades out."
msgstr ""
"``modulate`` は、赤、緑、青、アルファの4つのチャンネルを持つ ``Color`` 値を取"
"ります。最初の3つのチャネルのいずれかを暗くすると、インターフェイスが暗くなり"
"ます。アルファチャンネルを下げると、インターフェイスがフェードアウトします。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:615
msgid ""
"We're going to tween between two color values: from a white with an alpha of "
"``1``, that is to say at full opacity, to a pure white with an alpha value "
"of ``0``, completely transparent. Let's add two variables at the top of the "
"``_on_Player_died`` method and name them ``start_color`` and ``end_color``. "
"Use the ``Color()`` constructor to build two ``Color`` values."
msgstr ""
"2つのカラー値の間でTweenを行います。1つはアルファが ``1`` の白、つまり完全に"
"不透明な状態、もう1つはアルファが ``0`` の完全に透明な白です。 "
"``_on_Player_die`` メソッドの先頭に2つの変数を追加し、それぞれに "
"``start_color`` と ``end_color`` という名前を付けます。 ``Color()`` コンスト"
"ラクタを使用して、2つの ``Color`` 値を構築します。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:637
msgid ""
"``Color(1.0, 1.0, 1.0)`` corresponds to white. The fourth argument, "
"respectively ``1.0`` and ``0.0`` in ``start_color`` and ``end_color``, is "
"the alpha channel."
msgstr ""
"``Color(1.0、1.0、1.0)`` は白に対応します。 4番目の引数、 ``start_color`` と "
"``end_color`` のそれぞれ ``1.0`` と ``0.0`` は、アルファチャンネルです。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:641
msgid ""
"We then have to call the ``interpolate_property`` method of the ``Tween`` "
"node again:"
msgstr ""
"次に、 ``Tween`` ノードの ``interpolate_property`` メソッドをもう一度呼び出す"
"必要があります:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:654
msgid ""
"This time, we change the ``modulate`` property and have it animate from "
"``start_color`` to the ``end_color``. The duration is of one second, with a "
"linear transition. Here again, because the transition is linear, the easing "
"does not matter. Here's the complete ``_on_Player_died`` method:"
msgstr ""
"今回は、\\ ``modulate`` プロパティを変更し、\\ ``start_color`` から "
"``end_color`` にアニメートします。継続時間は1秒で、線形の遷移があります。ここ"
"でも、遷移は線形であるため、イージングは重要ではありません。完全な "
"``_on_Player_died`` メソッドは次のとおりです:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:679
msgid "And that is it. You may now play the game to see the final result!"
msgstr "以上です。これでゲームをプレイして最終結果を確認できます！"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:683
msgid "The final result. Congratulations for getting there!"
msgstr "最終結果。上手くいきましたね！"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:687
msgid ""
"Using the exact same techniques, you can change the color of the bar when "
"the Player gets poisoned, turn the bar red when its health drops low, shake "
"the UI when they take a critical hit... the principle is the same: emit a "
"signal to forward the information from the `Player` to the `GUI` and let the "
"`GUI` process it."
msgstr ""
"まったく同じテクニックを使用して、プレイヤーが毒になったときにバーの色を変更"
"し、体力が低下したときにバーを赤にし、彼らがクリティカルヒットしたときにUIを"
"振動させることができます。 `Player` からの情報を `GUI` に転送し、 `GUI` に処"
"理させます。"
