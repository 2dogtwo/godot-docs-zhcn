# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-11-29 23:14+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Custom drawing in 2D"
msgstr "2D 中的自訂繪圖"

msgid "Introduction"
msgstr "前言"

msgid ""
"Godot has nodes to draw sprites, polygons, particles, and all sorts of "
"stuff. For most cases, this is enough. If there's no node to draw something "
"specific you need, you can make any 2D node (for example, :ref:`Control "
"<class_Control>` or :ref:`Node2D <class_Node2D>` based) draw custom commands."
msgstr ""
"Godot 有用於繪製精靈、多邊形、粒子以及各種東西的節點。在大多數情況下，這就已"
"經足夠了，但並不總是這樣。可別因為不存在繪製*某種特定*東西的節點，而在恐懼、"
"焦慮、憤怒……中哭泣。要知道，任何 2D 節點（不管它是繼承自 :ref:`Control "
"<class_Control>` 還是 :ref:`Node2D <class_Node2D>`）都可以很輕鬆地繪製自訂命"
"令。而且這*真的*非常容易操作。"

msgid ""
"Custom drawing in a 2D node is *really* useful. Here are some use cases:"
msgstr "2D 節點中的自訂繪製*非常*有用。下面是一些用例："

msgid ""
"Drawing shapes or logic that existing nodes can't do, such as an image with "
"trails or a special animated polygon."
msgstr ""
"繪製現有節點型別無法完成的形狀或邏輯，例如帶有軌跡或特殊動態多邊形的圖像。"

msgid ""
"Visualizations that are not that compatible with nodes, such as a tetris "
"board. (The tetris example uses a custom draw function to draw the blocks.)"
msgstr ""
"與節點不太相容的呈現方式，比如俄羅斯方塊的棋盤。（俄羅斯方塊的例子使用的是自"
"訂繪製函式來繪製方塊。）"

msgid ""
"Drawing a large number of simple objects. Custom drawing avoids the overhead "
"of using a large number of nodes, possibly lowering memory usage and "
"improving performance."
msgstr ""
"繪製大量簡單的物件。自訂繪製避免了使用大量節點的開銷，能降低記憶體佔用，並提"
"高性能。"

msgid ""
"Making a custom UI control. There are plenty of controls available, but when "
"you have unusual needs, you will likely need a custom control."
msgstr "製作自訂的 UI 控制項，以滿足很多可用的控制項之外的特別需求。"

msgid "Drawing"
msgstr "繪製"

msgid ""
"Add a script to any :ref:`CanvasItem <class_CanvasItem>` derived node, like :"
"ref:`Control <class_Control>` or :ref:`Node2D <class_Node2D>`. Then override "
"the ``_draw()`` function."
msgstr ""
"新增一個腳本到任何 :ref:`CanvasItem <class_CanvasItem>` 的衍生節點，如 :ref:"
"`Control <class_Control>` 或 :ref:`Node2D <class_Node2D>`。然後重載 "
"``_draw()`` 函式。"

msgid ""
"Draw commands are described in the :ref:`CanvasItem <class_CanvasItem>` "
"class reference. There are plenty of them."
msgstr ""
"繪製命令在 :ref:`CanvasItem <class_CanvasItem>` 的類參考中有所描述，數量很"
"多。"

msgid "Updating"
msgstr "更新"

msgid ""
"The ``_draw()`` function is only called once, and then the draw commands are "
"cached and remembered, so further calls are unnecessary."
msgstr ""
"``_draw()`` 函式只呼叫一次, 然後繪製命令被快取並記住, 因此不需要進一步呼叫."

msgid ""
"If re-drawing is required because a state or something else changed, call :"
"ref:`CanvasItem.queue_redraw() <class_CanvasItem_method_queue_redraw>` in "
"that same node and a new ``_draw()`` call will happen."
msgstr ""
"如果因為狀態或其他方面的變化而需要重新繪製，在目前節點中呼叫 :ref:"
"`CanvasItem.update() <class_CanvasItem_method_update>` ，觸發新的 "
"``_draw()`` 呼叫。"

msgid ""
"Here is a little more complex example, a texture variable that will be "
"redrawn if modified:"
msgstr "這是一個更複雜的範例，一個被修改就會重新繪製的紋理變數："

msgid ""
"In some cases, it may be desired to draw every frame. For this, call "
"``queue_redraw()`` from the ``_process()`` callback, like this:"
msgstr ""
"在某些情況下, 可能需要繪製每一影格. 為此, 只需從 ``_process()`` 回呼函式呼叫 "
"``update()`` , 如下所示:"

msgid "Coordinates"
msgstr "座標"

msgid ""
"The drawing API uses the CanvasItem's coordinate system, not necessarily "
"pixel coordinates. Which means it uses the coordinate space created after "
"applying the CanvasItem's transform. Additionally, you can apply a custom "
"transform on top of it by using :ref:"
"`draw_set_transform<class_CanvasItem_method_draw_set_transform>` or :ref:"
"`draw_set_transform_matrix<class_CanvasItem_method_draw_set_transform_matrix>`."
msgstr ""
"繪圖 API 使用 CanvasItem 的坐標系統，不一定是像素座標。這意味著它使用在應用 "
"CanvasItem 的變換後建立的座標空間。此外，你可以使用 :ref:"
"`draw_set_transform<class_CanvasItem_method_draw_set_transform>` 或 :ref:"
"`draw_set_transform_matrix<class_CanvasItem_method_draw_set_transform_matrix>` "
"在它上面應用自訂變換。"

msgid ""
"When using ``draw_line``, you should consider the width of the line. When "
"using a width that is an odd size, the position should be shifted by ``0.5`` "
"to keep the line centered as shown below."
msgstr ""
"使用 ``draw_line`` 時，應考慮線條的寬度。如果使用的寬度是奇數，則應將位置移"
"動 ``0.5`` 以保持線條居中，如下圖所示。"

msgid "The same applies to the ``draw_rect`` method with ``filled = false``."
msgstr "這同樣適用於使用 ``filled = false`` 的 ``draw_rect`` 方法。"

msgid "An example: drawing circular arcs"
msgstr "範例：繪製圓弧"

msgid ""
"We will now use the custom drawing functionality of the Godot Engine to draw "
"something that Godot doesn't provide functions for. As an example, Godot "
"provides a ``draw_circle()`` function that draws a whole circle. However, "
"what about drawing a portion of a circle? You will have to code a function "
"to perform this and draw it yourself."
msgstr ""
"我們現在將使用 Godot 引擎的自訂繪圖功能來繪製 Godot 未提供函式的內容。比如，"
"Godot 提供了 ``draw_circle()`` 函式，它可以繪製一個完整的圓。但是，畫一個圓的"
"一部分怎麼說？你必須編寫一個函式來執行此操作，自己繪製它。"

msgid "Arc function"
msgstr "弧函式"

msgid ""
"An arc is defined by its support circle parameters, that is, the center "
"position and the radius. The arc itself is then defined by the angle it "
"starts from and the angle at which it stops. These are the 4 arguments that "
"we have to provide to our drawing function. We'll also provide the color "
"value, so we can draw the arc in different colors if we wish."
msgstr ""
"弧由其所在的圓的參數定義. 即: 中心位置和半徑. 弧本身由開始的角度和停止的角度"
"來定義. 這些是我們必須為繪圖提供的4個參數. 我們還將提供顏色值, 因此我們可以根"
"據需要繪製不同顏色的圓弧."

msgid ""
"Basically, drawing a shape on the screen requires it to be decomposed into a "
"certain number of points linked from one to the next. As you can imagine, "
"the more points your shape is made of, the smoother it will appear, but the "
"heavier it will also be in terms of processing cost. In general, if your "
"shape is huge (or in 3D, close to the camera), it will require more points "
"to be drawn without it being angular-looking. On the contrary, if your shape "
"is small (or in 3D, far from the camera), you may decrease its number of "
"points to save processing costs; this is known as *Level of Detail (LOD)*. "
"In our example, we will simply use a fixed number of points, no matter the "
"radius."
msgstr ""
"基本上, 在螢幕上繪製形狀需要將其分解為一定量首位相接的點. 你可以預見到, 點越"
"多, 它就越平滑, 但處理開銷就越大. 一般來說, 如果你的形狀很大(或者在3D場景中靠"
"近相機), 則需要繪製更多的點才不會看起來像是有棱角的. 相反, 如果你的形狀很小"
"(或在3D場景裡遠離相機), 你可以減少其點數以節省處理成本. 這稱為 *多層次細節"
"(Level of Detail, LoD)* . 在我們的範例中, 無論半徑如何, 我們都只使用固定數量"
"的點."

msgid ""
"Remember the number of points our shape has to be decomposed into? We fixed "
"this number in the ``nb_points`` variable to a value of ``32``. Then, we "
"initialize an empty ``PackedVector2Array``, which is simply an array of "
"``Vector2``\\ s."
msgstr ""
"還記得我們的形狀必須分解成多少點嗎？我們將「nb_points」變數中的這個數字固定為"
"「32」。然後，我們初始化一個空的“PackedVector2Array”，它只是一個“Vector2”陣"
"列。"

msgid ""
"The next step consists of computing the actual positions of these 32 points "
"that compose an arc. This is done in the first for-loop: we iterate over the "
"number of points for which we want to compute the positions, plus one to "
"include the last point. We first determine the angle of each point, between "
"the starting and ending angles."
msgstr ""
"下一步包括計算構成弧的這32個點的實際位置. 這是在第一個for迴圈中完成的: 我們反"
"覆運算我們想要計算位置的點的數量, 後面+1來包括最後一個點. 我們首先確定起點和"
"終點之間每個點的角度."

msgid ""
"The reason why each angle is decreased by 90° is that we will compute 2D "
"positions out of each angle using trigonometry (you know, cosine and sine "
"stuff...). However, ``cos()`` and ``sin()`` use radians, not degrees. The "
"angle of 0° (0 radian) starts at 3 o'clock, although we want to start "
"counting at 12 o'clock. So we decrease each angle by 90° in order to start "
"counting from 12 o'clock."
msgstr ""
"每個角度減小90°的原因是我們將使用三角函式計算每個角度的2D位置(你知道, 餘弦和"
"正弦之類的東西......). 但是, 為了簡單, ``cos()`` 和 ``sin()`` 使用弧度, 而不"
"是度數作為參數. 雖然我們想在12點鐘位置開始計數, 但0°(0弧度)的角度從3點鐘位置"
"開始. 因此我們將每個角度減小90°, 以便從12點位置開始計數."

msgid ""
"The actual position of a point located on a circle at angle ``angle`` (in "
"radians) is given by ``Vector2(cos(angle), sin(angle))``. Since ``cos()`` "
"and ``sin()`` return values between -1 and 1, the position is located on a "
"circle of radius 1. To have this position on our support circle, which has a "
"radius of ``radius``, we simply need to multiply the position by ``radius``. "
"Finally, we need to position our support circle at the ``center`` position, "
"which is performed by adding it to our ``Vector2`` value. Finally, we insert "
"the point in the ``PackedVector2Array`` which was previously defined."
msgstr ""
"以角度 ``angle`` (單位是弧度)位於圓上的點的實際位置由 ``Vector2(cos(angle), "
"sin(angle))`` 給出. 由於 ``cos()`` 和 ``sin()`` 返回介於-1和1之間的值, 因此位"
"置位於半徑為1的圓上. 要將此位置放在我們的半徑為 ``radius`` 的輔助圓上, 我們只"
"需要將那個位置乘以 ``radius`` . 最後, 我們需要將我們的輔助圓定位在 "
"``center`` 位置, 這是通過將其與我們的 ``Vector2`` 相加來實作的. 最後, 我們在"
"之前定義的 ``PoolVector2Array`` 中插入這個點."

msgid ""
"Now, we need to actually draw our points. As you can imagine, we will not "
"simply draw our 32 points: we need to draw everything that is between each "
"of them. We could have computed every point ourselves using the previous "
"method, and drew it one by one. But this is too complicated and inefficient "
"(except if explicitly needed), so we simply draw lines between each pair of "
"points. Unless the radius of our support circle is big, the length of each "
"line between a pair of points will never be long enough to see them. If that "
"were to happen, we would simply need to increase the number of points."
msgstr ""
"現在, 我們需要實際繪製我們的點. 你可以想像, 我們不會簡單地畫出我們的32個點: "
"我們需要繪製每一點之間的所有內容. 我們可以使用前面的方法自己計算每個點, 然後"
"逐個繪製. 但這太複雜和低效了(除非確實需要). 因此, 我們只需在每對點之間繪製線"
"條. 除非我們的輔助圓的半徑很大, 否則一對點之間每條線的長度永遠不會長到足以看"
"到它們. 如果發生這種情況, 我們只需要增加點的個數就可以了."

msgid "Draw the arc on the screen"
msgstr "在螢幕上繪製弧形"

msgid ""
"We now have a function that draws stuff on the screen; it is time to call it "
"inside the ``_draw()`` function:"
msgstr ""
"我們現在有一個在螢幕上繪製內容的函式; 是時候在 ``_draw()`` 函式中呼叫它了:"

msgid "Result:"
msgstr "結果："

msgid "Arc polygon function"
msgstr "弧多邊形函式"

msgid ""
"We can take this a step further and not only write a function that draws the "
"plain portion of the disc defined by the arc, but also its shape. The method "
"is exactly the same as before, except that we draw a polygon instead of "
"lines:"
msgstr ""
"我們可以更進一步, 不僅僅繪製一個由弧定義的扇形的邊緣, 還可以繪製其形體. 該方"
"法與以前完全相同, 只是我們繪製的是多邊形而不是線條:"

msgid "Dynamic custom drawing"
msgstr "動態自訂繪圖"

msgid ""
"All right, we are now able to draw custom stuff on the screen. However, it "
"is static; let's make this shape turn around the center. The solution to do "
"this is simply to change the angle_from and angle_to values over time. For "
"our example, we will simply increment them by 50. This increment value has "
"to remain constant or else the rotation speed will change accordingly."
msgstr ""
"好吧, 我們現在能夠在螢幕上繪製自訂內容. 然而, 它是靜態的; 我們讓這個形狀圍繞"
"中心轉動吧. 這樣做的方法就是隨著時間的推移改變angle_from和angle_to值. 對於我"
"們的範例, 我們將簡單地將它們遞增50. 此差異量值必須保持不變, 否則旋轉速度將相"
"應地改變."

msgid ""
"First, we have to make both angle_from and angle_to variables global at the "
"top of our script. Also note that you can store them in other nodes and "
"access them using ``get_node()``."
msgstr ""
"首先, 我們必須在我們的angle_from和angle_to變數變成全域變數, 放在腳本頂部. 另"
"請注意, 您可以將它們儲存在其他節點中並使用 ``get_node()`` 存取它們."

msgid "We make these values change in the _process(delta) function."
msgstr "我們在_process(delta)函式中更改這些值."

msgid ""
"We also increment our angle_from and angle_to values here. However, we must "
"not forget to ``wrap()`` the resulting values between 0 and 360°! That is, "
"if the angle is 361°, then it is actually 1°. If you don't wrap these "
"values, the script will work correctly, but the angle values will grow "
"bigger and bigger over time until they reach the maximum integer value Godot "
"can manage (``2^31 - 1``). When this happens, Godot may crash or produce "
"unexpected behavior."
msgstr ""
"我們也在這裡增加angle_from和angle_to值. 但是, 我們不能忘記將結果 ``wrap()`` "
"在0到360°之間！ 也就是說, 如果角度是361°, 那麼它實際上是1°. 如果您不包裝這些"
"值, 腳本將正常工作, 但角度值將隨著時間的推移變得越來越大, 直到它們達到Godot可"
"以管理的最大整數值(``2^31 - 1``). 當發生這種情況時,Godot可能會當機或產生意外"
"行為."

msgid ""
"Finally, we must not forget to call the ``queue_redraw()`` function, which "
"automatically calls ``_draw()``. This way, you can control when you want to "
"refresh the frame."
msgstr ""
"最後, 我們一定不要忘記呼叫 ``queue_redraw()`` 函式, 它會自動呼叫 "
"``_draw()`` 。這樣, 你就可以控制何時去更新這一影格。"

msgid ""
"Also, don't forget to modify the ``_draw()`` function to make use of these "
"variables:"
msgstr "另外, 不要忘記修改 ``_draw()`` 函式來使用這些變數:"

msgid ""
"Let's run! It works, but the arc is rotating insanely fast! What's wrong?"
msgstr "我們運作吧！ 它工作正常, 但弧線旋轉快得瘋掉了！ 怎麼了？"

msgid ""
"The reason is that your GPU is actually displaying the frames as fast as it "
"can. We need to \"normalize\" the drawing by this speed; to achieve that, we "
"have to make use of the ``delta`` parameter of the ``_process()`` function. "
"``delta`` contains the time elapsed between the two last rendered frames. It "
"is generally small (about 0.0003 seconds, but this depends on your "
"hardware), so using ``delta`` to control your drawing ensures that your "
"program runs at the same speed on everybody's hardware."
msgstr ""
"原因是你的GPU實際上正在盡可能快地顯示影格. 我們需要以這個速度為基準 \"標準化"
"\" 繪圖的速度. 為了實作這個效果, 我們必須使用 ``_process()`` 函式的 "
"``delta`` 參數. ``delta`` 包含最後兩個渲染影格之間經過的時間. 它通常很小(約"
"0.0003秒, 但這取決於你的硬體). 因此, 使用 ``delta`` 來控制繪圖可確保程式在每"
"個人的硬體上以相同的速度運作."

msgid ""
"In our case, we simply need to multiply our ``rotation_angle`` variable by "
"``delta`` in the ``_process()`` function. This way, our 2 angles will be "
"increased by a much smaller value, which directly depends on the rendering "
"speed."
msgstr ""
"在我們的範例中, 我們只需要在 ``_process()`` 函式中將 ``rotation_angle`` 變數"
"乘以 ``delta`` . 這樣, 我們的2個角度會以一個小得多的值遞增, 值的大小直接取決"
"於渲染速度."

msgid "Let's run again! This time, the rotation displays fine!"
msgstr "讓我們再運作一次！ 這次, 旋轉顯示正常！"

msgid "Antialiased drawing"
msgstr "**抗鋸齒：**"

msgid ""
"Godot offers method parameters in :ref:"
"`draw_line<class_CanvasItem_method_draw_line>` to enable antialiasing, but "
"not all custom drawing methods offer this ``antialiased`` parameter."
msgstr ""
"Godot在 :ref:`draw_line<class_CanvasItem_method_draw_line>`中提供方法參數來啟"
"用抗鋸齒功能，但並非所有自訂繪圖方法都提供這個 ``抗鋸齒（antialiased）`` 參"
"數。"

msgid ""
"For custom drawing methods that don't provide an ``antialiased`` parameter, "
"you can enable 2D MSAA instead, which affects rendering in the entire "
"viewport. This provides high-quality antialiasing, but a higher performance "
"cost and only on specific elements. See :ref:`doc_2d_antialiasing` for more "
"information."
msgstr ""
"對於不提供 ``抗鋸齒（antialiased）`` 參數的自訂繪圖方法，你可以啟用 2D MSAA，"
"這會影響整個視口的渲染。這個功能（2D MSAA）提供了高品質的抗鋸齒，但性能成本更"
"高，而且只適用於特定元素。參見 :ref:`doc_2d_antialiasing` 以瞭解更多資訊。"

msgid "Tools"
msgstr "工具"

msgid ""
"Drawing your own nodes might also be desired while running them in the "
"editor. This can be used as a preview or visualization of some feature or "
"behavior. See :ref:`doc_running_code_in_the_editor` for more information."
msgstr ""
"在編輯器中運作節點時，可能也會用到繪圖。可以用於某些功能或行為的預覽或視覺"
"化。詳情請參閱 :ref:`doc_running_code_in_the_editor`。"

msgid "Translation status"
msgstr "翻譯狀態"
