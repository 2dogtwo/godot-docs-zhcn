# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2021, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-11-19 11:09+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:4
msgid "Design interfaces with the Control nodes"
msgstr "利用 Control 節點設計界面"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:6
msgid ""
"Computer displays, mobile phones, and TV screens come in all shapes and "
"sizes. To ship a game, you'll need to support different screen ratios and "
"resolutions. It can be hard to build responsive interfaces that adapt to all "
"platforms. Thankfully, Godot comes with robust tools to design and manage a "
"responsive User Interface."
msgstr ""
"電腦螢幕、手機、電視螢幕等有著不同的形狀與尺寸。要發佈遊戲就需要能支援各種不"
"同的螢幕長寬比與解析度。要製作能適用於所有平台的回應式 (Responsive) 界面有可"
"能很困難。幸好，Godot 提供了強大的工具能夠設計與管理回應式使用者介面。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:14
msgid "Godot's editor is made with the engine's UI framework"
msgstr "Godot 的編輯器是使用引擎的 UI 框架製作的"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:16
msgid "This guide will get you started with UI design. You will learn:"
msgstr "這篇教學將帶你瞭解 UI 設計。你將學會："

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:18
msgid "The five most useful control nodes to build your games' interface"
msgstr "製作遊戲界面最實用的五個 Control 節點"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:19
msgid "How to work with the anchor of UI elements"
msgstr "如何使用 UI 元素的錨點"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:20
msgid ""
"How to efficiently place and arrange your user interface using containers"
msgstr "如何使用 Container 有效率地排列與擺放界面"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:22
msgid ""
"The five most common containers (you can learn more about containers in the :"
"ref:`GUI Containers <doc_gui_containers>` documentation page)."
msgstr ""
"五個最常見的 Container （有關 Container 的更多內容可以參考 :ref:`GUI "
"Containers <doc_gui_containers>` 說明文件頁面）。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:25
msgid ""
"To learn how to control the interface and connect it to other scripts, read :"
"ref:`Build your first game UI in Godot <doc_ui_game_user_interface>`."
msgstr ""
"要學習如何控制界面與將界面與其他腳本連接，請參考 :ref:`在 Godot 中製作第一個"
"遊戲 UI <doc_ui_game_user_interface>` 。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:28
msgid ""
"To design your UI, you'll use the Control nodes. These are the nodes with "
"green icons in the editor. There are dozens of them, for creating anything "
"from life bars to complex applications. Godot's editor itself is built using "
"Control nodes."
msgstr ""
"要設計 UI，需要使用 Control 節點。Control 節點就是在編輯器中有綠色圖示的節"
"點。Godot 中有數十種的 Control 節點，可以用來製作出血槽甚至是複雜的應用程式等"
"任何的東西。Godot 編輯器本身也是使用 Control 節點製作的。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:32
msgid ""
"Control nodes have unique properties that allow them to work well with one "
"another. Other visual nodes, like Node2D and Sprite don't have these "
"capabilities. So to make your life easier use Control nodes wherever "
"possible when building your UIs."
msgstr ""
"Control 節點有獨特的屬性能夠，能夠讓一個 Control 節點與另一個 Control 節點互"
"相配合。其他如 Node2D 與 Sprite 的視覺節點就沒有這樣的功能。所以想輕鬆一點的"
"話就請在製作 UI 時儘量使用 Control 節點吧。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:36
msgid "All control nodes share the same main properties:"
msgstr "所有的 Control 節點都具有這幾個相同的主屬性："

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:38
msgid "Anchor"
msgstr "Anchor：錨點"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:39
msgid "Bounding rectangle"
msgstr "Bouding Rectangle：邊界矩形"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:40
msgid "Focus and focus neighbor"
msgstr "Focus 與 Focus Neighbor：焦點與相鄰焦點"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:41
msgid "Size flags"
msgstr "Size Flags：大小標誌"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:42
msgid "Margin"
msgstr "Margin：外邊距"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:43
msgid "The optional UI theme"
msgstr "可選的 UI 主題"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:45
msgid ""
"Once you understand the basics of the Control node, it will take you less "
"time to learn all the nodes that derive from it."
msgstr ""
"瞭解了 Control 節點的基礎後，以後學習其他從 Control 節點衍生而來的其他節點就"
"能更快速。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:50
msgid "The 5 most common UI elements"
msgstr "五個最常見的 UI 元素"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:52
msgid ""
"Godot ships with dozens of Control nodes. A lot of them are here to help you "
"build editor plugins and applications."
msgstr ""
"Godot 附帶了數十種 Control 節點。而其中許多節點都是用來讓你可以製作編輯器外掛"
"與應用程式的。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:55
msgid ""
"For most games, you'll only need five types of UI elements, and a few "
"Containers. These five Control nodes are:"
msgstr ""
"對於大多數的遊戲來說，只會需要五種 UI 元素以及少數幾個 Container。這五個 "
"Control 節點為："

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:58
msgid "Label: for displaying text"
msgstr "Label：標籤，用來顯示文字"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:59
msgid ""
"TextureRect: used mostly for backgrounds, or everything that should be a "
"static image"
msgstr "TextureRect：紋理貼圖矩形，通常用來作背景，或是其他顯示靜態圖片的地方"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:61
msgid ""
"TextureProgress: for lifebars, loading bars, horizontal, vertical or radial"
msgstr ""
"TextureProgress：紋理貼圖進度條，用於血槽、載入進度條，可以是任何水平、垂直、"
"或放射性的"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:63
msgid "NinePatchRect: for scalable panels"
msgstr "NinePatchRect：9-Patch 矩形，用於可縮放的面板"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:64
msgid "TextureButton: to create buttons"
msgstr "TextureButton：紋理貼圖按鈕，用於製作按鈕"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:68
msgid "The 5 most common Control nodes for UI design"
msgstr "用於 UI 設計的五個最常見的 Control 節點"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:71
msgid "TextureRect"
msgstr "\\ TextureRect"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:73
msgid ""
"**TextureRect** displays a texture or image inside a UI. It seems similar to "
"the Sprite node, but it offers multiple scaling modes. Set the Stretch Mode "
"property to change its behavior:"
msgstr ""
"**TextureRect** 可以在 UI 中顯示紋理貼圖或圖片。看起來很像 Sprite 節點，但 "
"TextureRect 提供了多種縮放模式。修改 Stretch Mode（拉伸模式）屬性即可更改行"
"為："

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:77
msgid ""
"``Scale On Expand (compat)`` scales the texture to fit the node's bounding "
"rectangle, only if ``expand`` property is ``true``; otherwise, it behaves "
"like ``Keep`` mode. Default mode for backwards compatibility."
msgstr ""
"``Scale On Expand (compat)`` ：延展時縮放（相容），僅當 ``expand`` 屬性設為 "
"``true`` 時將紋理貼圖縮放至符合節點的邊界矩形。其餘情況則與 ``Keep`` 模式行為"
"相同。為向下相容性，該模式為預設。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:80
msgid "``Scale`` scales the texture to fit the node's bounding rectangle."
msgstr "``Scale`` ：縮放，將紋理貼圖縮放至節點的邊界矩形。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:81
msgid "``Tile`` makes the texture repeat, but it won't scale."
msgstr "``Tile`` ：平鋪，重複紋理貼圖，但不進行縮放。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:82
msgid ""
"``Keep`` and ``Keep Centered`` force the texture to remain at its original "
"size, in the top left corner or the center of the frame respectively."
msgstr ""
"``Keep`` 與 ``Keep Centered`` ：保持與保持居中，強制紋理貼圖保持原始大小，分"
"別置於框架的左上角或中間。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:85
msgid ""
"``Keep Aspect`` and ``Keep Aspect Centered`` scales the texture but force it "
"to remain its original aspect ratio, in the top left corner or the center of "
"the frame respectively."
msgstr ""
"``Keep Aspect`` 與 ``Keep Aspect Centered`` ：保持長寬比與居中保持長寬比，將"
"紋理貼圖縮放但強制其維持原始的長寬比，分別置於框架的左上角或中間。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:87
msgid ""
"``Keep Aspect Covered`` works just like ``Keep Aspect Centered`` but the "
"shorter side fits the bounding rectangle and the other one clips to the "
"node's limits."
msgstr ""
"``Keep Aspect Covered`` ：保持長寬比覆蓋，行為與 ``Keep Aspect Centered`` 相"
"同，但短邊會配合邊界矩形，另一邊則會超出節點邊界並剪裁掉。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:90
msgid ""
"As with Sprite nodes, you can modulate the TextureRect's color. Click the "
"``Modulate`` property and use the color picker."
msgstr ""
"與 Sprite 節點一樣，TextureRect 的顏色也可以調整。點擊 ``Modulate`` （調變）"
"屬性後使用色彩選擇器。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:95
msgid "TextureRect modulated with a red color"
msgstr "使用紅色調變的 TextureRect"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:98
msgid "TextureButton"
msgstr "\\ TextureButton"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:100
msgid ""
"**TextureButton** is like TextureRect, except it has 6 texture slots: one "
"for each of the button's states. Most of the time, you'll use the Normal, "
"Pressed, and Hover textures. Focused is useful if your interface listens to "
"the keyboard's input. The sixth image slot, the Click Mask, lets you define "
"the clickable area using a 1-bit, pure black and white image."
msgstr ""
"**TextureButton** 類似 TextureRect，不同的地方是 TextureButton 有六個紋理貼圖"
"欄位，每個按鈕的狀態都有一個貼圖。大多數情況下，會使用到 Normal (正常)、"
"Pressed (按下) 與 Hover (懸停) 的貼圖。Focused (聚焦) 適用於會監聽鍵盤事件的"
"界面。第六個圖片欄位為 Click Mask (點擊遮色片)，可使用 1-Bit 的純黑白圖片來定"
"義可點擊的區域。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:107
msgid ""
"In the Base Button section, you'll find a few checkboxes that change how the "
"button behaves. When ``Toggle Mode`` is on, the button will toggle between "
"active and normal states when you press it. ``Disabled`` makes it disabled "
"by default, in which case it will use the ``Disabled`` texture. "
"TextureButton shares a few properties with the texture frame: it has a "
"``modulate`` property, to change its color, and ``Resize`` and ``Stretch`` "
"modes to change its scale behavior."
msgstr ""
"在 Base Button 的部分有幾個勾選框可以改變按鈕的行為。當開啟 ``Toggle Mode`` "
"（切換模式）時，點擊按鈕時會在啟用 (Active) 與正常 (Normal) 狀態間切換。 "
"``Disabled`` （禁用）會讓按鈕在預設時禁用，這時候會使用 ``Disabled`` 紋理貼"
"圖。TextureButton 也有一些與紋理框架相同的屬性： ``Modulate`` （調變）屬性可"
"更改色彩， ``Resize`` （調整大小）與 ``Stretch`` （伸縮）模式可以更改其縮放的"
"行為。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:117
msgid "TextureButton and its 5 texture slots"
msgstr "TextureButton 與其五個紋理貼圖欄位"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:120
msgid "TextureProgress"
msgstr "\\ TextureProgress"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:122
msgid ""
"**TextureProgress** layers up to 3 sprites to create a progress bar. The "
"Under and Over textures sandwich the Progress one, which displays the bar's "
"value."
msgstr ""
"**TextureProgress** 可使用最多三個圖層的 Sprite 來建立進度條。 Under 與 Over "
"紋理貼圖中間夾著顯示進度條數值的 Progress 貼圖。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:126
msgid ""
"The ``Mode`` property controls the direction in which the bar grows: "
"horizontally, vertically, or radially. If you set it to radial, the "
"``Initial Angle`` and ``Fill Degrees`` properties let you limit the range of "
"the gauge."
msgstr ""
"``Mode`` 屬性可以控制進度條的方向：水平、垂直、或放射狀。若設為放射狀，則可使"
"用 ``Initial Angle`` （初始角度）與 ``Fill Degress`` （填充角度）來限制放射的"
"範圍。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:131
msgid ""
"To animate the bar, you'll want to look at the Range section. Set the "
"``Min`` and ``Max`` properties to define the range of the gauge. For "
"instance, to represent a character's life, you'll want to set ``Min`` to ``0,"
"`` and ``Max`` to the character's maximum life. Change the ``Value`` "
"property to update the bar. If you leave the ``Min`` and ``Max`` values to "
"the default of ``0`` and ``100,`` and set the ``Value`` property to ``40``, "
"40% of the ``Progress`` texture will show up, and 60% of it will stay hidden."
msgstr ""
"若要在進度條中使用動畫，可使用 Range 下的屬性。 ``Min`` 與 ``Max`` 屬性可用來"
"定義進度條的範圍。舉例來說，角色的血槽可以設定 ``Min`` 為 0，而 ``Max`` 則根"
"據角色的最大生命來設定。更改 ``Value`` 屬性即可更新進度條。若將 ``Min`` 與 "
"``Max`` 設為預設的 ``0`` 與 ``100`` ，則將 ``Value`` 屬性設為 ``40`` ，則將顯"
"示 40% 的 ``Progress`` 紋理貼圖，剩下 60% 保持不顯示。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:141
msgid "TextureProgress bar, two thirds filled"
msgstr "TextureProgress 進度條，填滿三分之二"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:144
msgid "Label"
msgstr "標籤"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:146
msgid ""
"**Label** prints text to the screen. You'll find all its properties in the "
"Label section, in the Inspector. Write the text in the ``Text`` property, "
"and check Autowrap if you want it to respect the textbox's size. If Autowrap "
"is off, you won't be able to scale the node. You can align the text "
"horizontally and vertically with Align and Valign, respectively."
msgstr ""
"**Label** 將文字顯示在畫面上。所有的屬性都列屬性面板中的 Label 段落下。文字可"
"寫在 ``Text`` 屬性裡，而若要依據文字框的大小來調整，則可勾選 Autowrap（自動斷"
"行）。若關閉 Autowrap，則將無法縮放節點。可以使用 Align（對齊）與 Valign（垂"
"直對齊）屬性來調整文字在垂直與水平方向的對齊方法。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:155
msgid "Picture of a Label"
msgstr "Label 的圖片"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:158
msgid "NinePatchRect"
msgstr "\\ NinePatchRect"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:160
msgid ""
"**NinePatchRect** takes a texture split in 3 rows and 3 columns. The center "
"and the sides tile when you scale the texture, but it never scales the "
"corners. It is useful to build panels, dialog boxes and scalable backgrounds "
"for your UI."
msgstr ""
"**NinePatchRect`` 將紋理貼圖分隔成三行三列。中間與側面的貼圖會在縮放貼圖時平"
"鋪，而角落的貼圖則不會被縮放。適合用來製作 UI 中的面板、對話框、與可伸縮的背"
"景。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:167
msgid "NinePatchRect scaled with the min\\_size property"
msgstr "使用 min\\_size 屬性縮放的 NinePatchRect"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:170
msgid "There are two workflows to build responsive UIs"
msgstr "製作回應式 UI 的兩個工作流程"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:172
msgid ""
"There are two workflows to build scalable and flexible interfaces in Godot:"
msgstr "在 Godot 中有兩個工作流程可用來建立可擴充與彈性的界面："

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:174
#, fuzzy
msgid ""
"**Place UI elements precisely with anchors:** Use the **Layout** menu to "
"place and resize a UI element relative to its parent."
msgstr "使用畫面配置選單在母節點中錨定、放置與調整 UI 元素的大小。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:175
msgid ""
"**Arrange control nodes automatically with containers:** Use container nodes "
"to automatically scale and place UI elements."
msgstr ""

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:177
msgid ""
"The two approaches are not always compatible. Because a container controls "
"its children, you cannot use the layout menu on them. Each container has a "
"specific effect, so you may need to nest several of them to get a working "
"interface. With the layout approach you work from the bottom up, on the "
"children. As you don't insert extra containers in the scene it can make for "
"cleaner hierarchies, but it's harder to arrange items in a row, column, "
"grid, etc."
msgstr ""
"這兩種方法並非完全相容。由於 Container 會控制其子節點，所以無法在 Container "
"節點上使用畫面配置選單。各種 Container 都有特定的效果，所以製作界面時就會需要"
"嵌套多層 Container。若使用畫面配置選單的話，就能由下至上地 (Bottom Up) 從子節"
"點開始製作界面，因為不需要額外在場景中插入 Container，所以架構也會比較清楚。"
"但這種方式也比較難能以行、列、或以網格系統等方式來排列 UI。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:179
msgid ""
"As you create UIs for your games and tools, you'll develop a sense for what "
"fits best in each situation."
msgstr "在為遊戲與工具建立 UI 後你就能漸漸掌握各種狀況下要用什麼方式最適合。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:183
msgid "Place UI elements precisely with anchors"
msgstr "使用錨點精確地擺放 UI 元素"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:185
msgid ""
"Control nodes have a position and size, but they also have anchors and "
"margins. Anchors define the origin, or the reference point, for the Left, "
"Top, Right and Bottom edges of the node. Change any of the 4 anchors to "
"change the reference point of the margins."
msgstr ""
"Control 節點有位置與大小，同時也有錨點與外邊距。錨點定義相對於節點左邊 "
"(Left)、上面 (Top)、右邊 (Right)、與下面 (Bottom) 的原點（或稱為參考點）。更"
"改這四個錨點即可更改外邊距的參考點。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:192
msgid "The anchor property"
msgstr "錨點屬性"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:195
msgid "How to change the anchor"
msgstr "如何更改錨點"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:197
msgid ""
"Like any properties, you can edit the 4 anchor points in the Inspector, but "
"this is not the most convenient way. When you select a control node, the "
"layout menu appears above the viewport, in the toolbar. It gives you a list "
"of icons to set all 4 anchors with a single click, instead of using the "
"inspector's 4 properties. The layout menu will only show up when you select "
"a control node."
msgstr ""
"與其他屬性一樣，可以在屬性面板中編輯四個錨點。但這種方法不是最方便的。當選擇"
"一個 Control 節點後，檢視區上方的工具列會出現畫面配置選單。通過畫面配置選單中"
"的各個圖示，就只需要點擊一下便可設定四個錨點值，而不需自己在屬性面板中調整。"
"畫面配置選單只會在選擇 Control 節點後出現。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:206
msgid "The layout menu in the viewport"
msgstr "檢視區中的畫面配置選單"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:209
msgid "Anchors are relative to the parent container"
msgstr "節點相對於其母容器"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:211
msgid ""
"Each anchor is a value between 0 and 1. For the left and top anchors, a "
"value of 0 means that without any margin, the node's edges will align with "
"the left and top edges of its parent. For the right and bottom edges, a "
"value of 1 means they'll align with the parent container's right and bottom "
"edges. On the other hand, margins represent a distance to the anchor "
"position in pixels, while anchors are relative to the parent container's "
"size."
msgstr ""
"每個錨點的值都介於 0 與 1。左邊 (Left) 與上面 (Top) 的錨點中，值為 0 則代表沒"
"有任何外邊距。節點的邊距會保持與母節點中的左側與上面的邊緣對齊。而右邊 "
"(Right) 與下面 (Bottom) 的錨點，值為 1 則代表會與母容器的右邊與下面的邊緣對"
"齊。換句話說，外邊距代表了至錨點的距離，單位為像素。而錨點則是相對於母容器的"
"大小。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:221
msgid ""
"Margins are relative to the anchor position, which is relative to the "
"anchors. In practice, you'll often let the container update margins for you"
msgstr ""
"外邊距相對於錨點位置，而錨點位置則相對於錨點。在實務上通常會使用容器來更新邊"
"距"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:226
msgid "Margins change with the anchor"
msgstr "外邊距會跟著錨點變化"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:228
msgid ""
"Margins update automatically when you move or resize a control node. They "
"represent the distance from the control node's edges to its anchor, which is "
"relative to the parent control node or container. That's why your control "
"nodes should always be inside a container, as we'll see in a moment. If "
"there's no parent, the margins will be relative to the node's own bounding "
"Rectangle, set in the Rect section, in the inspector."
msgstr ""
"外邊距會自動在移動或縮放 Control 節點時更新。外邊距表示從節點邊緣至錨點的距"
"離，錨點則相對於母 Control 節點或母 Container 節點。這就是為什麼應該要把 "
"Control 節點放在 Container 內的原因，我們稍後會討論到這點。若沒有母節點時，外"
"邊距會相對於節點自己的定界 Rectangle。該值設定於屬性面板中的 Rect 段落下。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:238
msgid "Margins on a CenterContainer set to the \"Full Rect\" anchor"
msgstr "在 CenterContainer 設定「 Full Rect 」錨點的外邊距"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:240
msgid ""
"Try to change the anchors or nest your Control nodes inside Containers: the "
"margins will update. You'll rarely need to edit the margins manually. Always "
"try to find a container to help you first; Godot comes with nodes to solve "
"all the common cases for you. Need to add space between a lifebar and the "
"border of the screen? Use the MarginContainer. Want to build a vertical "
"menu? Use the VBoxContainer. More on these below."
msgstr ""
"試著更改錨點或將 Control 節點嵌套於 Container 內後會發現外邊距跟著更新。通常"
"外邊距不需要手動修改。首先應該找找有沒有適合的 Container，Godot 有許多能解決"
"所有常見情況的節點：需要在血槽與畫面邊緣間加點空白？可以用 MarginContainer。"
"要製作垂直選單？可以使用 VBoxContainer。更多詳細資訊請參考下文。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:249
msgid "Use size tags to change how UI elements fill the available space"
msgstr "使用大小標籤來改變 UI 元素填充空間的方式"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:251
msgid ""
"Every control node has Size Flags. They tell containers how the UI elements "
"should scale. If you add the \"Fill\" flag to the Horizontal or Vertical "
"property, the node's bounding box will take all the space it can, but it'll "
"respect its siblings and retain its size. If there are 3 TextureRect nodes "
"in an HBoxContainer, with the \"Fill\" flags on both axes, they'll each take "
"up to a third of the available space, but no more. The container will take "
"over the node and resize it automatically."
msgstr ""
"所有的 Control 節點都有大小旗標 (Size Flag)。這些旗標用來控制 Container 如何"
"縮放其中的 UI 元素。若在 Horizontal（水平）或 Vertical（垂直）屬性上新增"
"「Fill」旗標，則節點的定界框會佔用所有可用的空間，但同時也會顧慮其他同級節點"
"並保留同級節點的大小。若在兩個方向都設定了「Fill」旗標的 HBoxContainer 中有三"
"個 TextureRect 節點，則這三個節點都只會佔用最多三分之一的可用空間。Container "
"會控制節點並自動縮放這些節點。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:261
msgid "3 UI elements in an HBoxContainer, they align horizontally"
msgstr "HBoxContainer 中的三個 UI 元素，水平對齊"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:263
msgid ""
"The \"Expand\" flag lets the UI element take all the space it can, and push "
"against its siblings. Its bounding rectangle will grow against the edges of "
"its parent, or until it's blocked by another UI node."
msgstr ""
"「Expand」旗標會讓 UI 元素佔滿所有可用的空間，並擠壓同級元素。定界框會一直沿"
"著母節點的邊緣增長，除非被另一個 UI 元素阻擋。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:269
msgid ""
"The same example as above, but the center node has the \"Expand\" size flag"
msgstr "與上方的範例相同，但中間的節點加上了「 Expand 」大小旗標"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:272
msgid ""
"You'll need some practice to understand the size tags, as their effect can "
"change quite a bit depending on how you set up your interface."
msgstr ""
"要瞭解大小旗標需要一些練習，因為設定大小旗標的效果會根據設定界面方式的不同而"
"有很大的不同。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:276
msgid "Arrange control nodes automatically with containers"
msgstr "使用 Container 來自動排列 Control 節點"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:278
msgid ""
"Containers automatically arrange all children Control nodes including other "
"containers in rows, columns, and more. Use them to add padding around your "
"interface or center nodes in their bounding rectangles. All built-in "
"containers update in the editor, so you can see the effect instantly."
msgstr ""
"Container 會自動以行列形式排列包含其他 Container 在內的所有子 Control 節點。"
"使用 Container 節點來在界面周圍新增內邊距 (Padding) 或是用來將節點在定界框內"
"置中。所有內建的 Container 都會在編輯器內更新，所以所有改動都會立即反映。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:284
msgid ""
"Containers have a few special properties to control how they arrange UI "
"elements. To change them, navigate down to the Custom Constants section in "
"the Inspector."
msgstr ""
"Container 有一些用來控制如何排列 UI 元素的特殊屬性。要修改這些屬性，請看到屬"
"性面板中的 Custom Contants（自定常數）段落。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:289
msgid "The 5 most useful containers"
msgstr "五個最實用的 Container"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:291
msgid ""
"If you build tools, you might need all of the containers. But for most "
"games, a handful will be enough:"
msgstr ""
"在製作工具的時候可能會需要用到所有的 Container。但大多數遊戲只需要其中幾種就"
"夠了："

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:294
#, fuzzy
msgid "MarginContainer, to add margins around parts of the UI"
msgstr "MarginContainer，外邊距容器，用來在 UI 的外圍新增外邊距"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:295
msgid "CenterContainer, to center its children in its bounding box"
msgstr "CenterContainer，置中容器，用來將子元素放在定界框中間"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:296
msgid ""
"VboxContainer and HboxContainer, to arrange UI elements in rows or columns"
msgstr ""
"VboxContainer 與 HboxContainer，垂直框容器與水平框容器，用來以行或列排列 UI "
"元素"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:298
msgid "GridContainer, to arrange Controls nodes in a grid-like pattern"
msgstr "GridContainer，柵欄容器，用來以類似柵欄系統的方式排列 Control 節點"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:300
msgid ""
"CenterContainer centers all its children inside of its bounding rectangle. "
"It's one you typically use for title screens, if you want the options to "
"stay in the center of the viewport. As it centers everything, you'll often "
"want a single container nested inside it. If you use textures and buttons "
"instead, they'll stack up."
msgstr ""
"CenterContainer 會將所有子節點置中與其定界框內。標題畫面通常會使用到這個容"
"器，或是要將選項放在檢視區的中間時使用。CenterContainer 會將所有東西都置中，"
"所以通常會在裡面嵌套另一個容器。若改用紋理貼圖或按鈕，則會堆疊在一起。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:308
msgid ""
"CenterContainer in action. The life bar centers inside its parent container."
msgstr "實際使用 CenterContainer 的例子。血槽放置於母容器中。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:311
msgid ""
"The MarginContainer adds a margin on any side of the child nodes. Add a "
"MarginContainer that encompasses the entire viewport to add a separation "
"between the edge of the window and the UI. You can set a margin on the top, "
"left, right, or bottom side of the container. No need to tick the checkbox: "
"click the corresponding value box and type any number. It will activate "
"automatically."
msgstr ""
"MarginContainer 會在子節點的每個邊都加上外邊距。新增一個圍繞整個檢視區的 "
"MarginContainer 即可為視窗邊緣與 UI 之間加上空白。可以在容器的上右下左各個邊"
"緣都加上外邊距。不需要勾選勾選框：只需點擊相應的數值輸入框並輸入任何數字，之"
"後會自動啟用。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:320
msgid "The MarginContainer adds a 40px margin around the Game User Interface"
msgstr "MarginContainer 在遊戲 UI 的周圍加上了 40px 的外邊距"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:322
msgid ""
"There are two BoxContainers: VBoxContainer and HBoxContainer. You cannot add "
"the BoxContainer node itself, as it is a helper class, but you can use "
"vertical and horizontal box containers. They arrange nodes either in rows or "
"columns. Use them to line up items in a shop, or to build complex grids with "
"rows and columns of different sizes, as you can nest them to your heart's "
"content."
msgstr ""
"有兩種 BoxContainer：VBoxContainer 與 HBoxContainer。由於 BoxContainer 屬於 "
"Helper 類別，所以 BoxContainer 無法直接使用。可以使用垂直與水平的 Box "
"Container。這兩個 Container 會以行或列的形式來排列子節點。可使用這兩種容器來"
"排列商店裡的物品、或是依照你所想像的方式進行嵌套來建立有不同大小的行與列的複"
"雜柵欄系統。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:331
msgid "The HBoxContainer horizontally aligns UI elements"
msgstr "HBoxContainer 水平對齊 UI 元素"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:333
msgid ""
"VBoxContainer automatically arranges its children into a column. It puts "
"them one after the other. If you use the separation parameter, it will leave "
"a gap between its children. HBoxContainer arranges UI elements in a row. "
"It's similar to the VBoxContainer, with an extra ``add_spacer`` method to "
"add a spacer control node before its first child or after its last child, "
"from a script."
msgstr ""
"VBoxContainer 自動會一個列中排列子節點的，將各個節點一個接一個排放。若使用 "
"Speration（分隔）參數，則會在子節點間加上間隔。HBoxContainer 則會在一行間排列"
"子節點，並且可使用額外的 ``add_spacer`` 方法來在腳本中為第一個子節點前或最後"
"一個子節點後新增 Spacer Control 節點。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:340
msgid ""
"The GridContainer lets you arrange UI elements in a grid-like pattern. You "
"can only control the number of columns it has, and it will set the number of "
"rows by itself, based on its children's count. If you have nine children and "
"three columns, you will have 9÷3 = 3 rows. Add three more children and "
"you'll have four rows. In other words, it will create new rows as you add "
"more textures and buttons. Like the box containers, it has two properties to "
"set the vertical and horizontal separation between the rows and columns "
"respectively."
msgstr ""
"GridContainer 可以用類似柵欄系統的方式來排列 UI 元素。其中只有列數能控制，行"
"數會自動依據子節點的數量來調整。若有九個子節點，列數設為三，則最後會有 9÷3 = "
"3 行。再新增三個子節點則會變成四行。換句話說，每當新增了更多紋理貼圖與按鈕後"
"行數也會隨之增加。如同 Box 容器，GridContainer 有兩個屬性分別用來設縱向的行間"
"隔與橫向的列間隔。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:351
msgid "A GridContainer with 2 columns. It sizes each column automatically."
msgstr "有兩個列的 GridContainer。各個列的大小為自動設定的。"

#: ../../docs/getting_started/step_by_step/ui_introduction_to_the_ui_system.rst:353
#, fuzzy
msgid ""
"Godot's UI system is complex, and has a lot more to offer. To learn how to "
"design more advanced interfaces, head to the :ref:`GUI section "
"<doc_user_interface>` of the docs."
msgstr ""
"Godot 的 UI 系統很複雜，且除了此處提到的之外還有更多。欲瞭解如何設計更多進階"
"的界面，請參閱說明文件中的 :ref:`GUI 段落 <toc-learn-features-gui>` 。"
