# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2020, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-09-28 16:14+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:4
msgid "Control the game's UI with code"
msgstr "使用程式控制遊戲的 UI"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:7
msgid "Intro"
msgstr "簡介"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:9
msgid ""
"In this tutorial, you will connect a character to a life bar and animate the "
"health loss."
msgstr "在這篇教學中我們會將角色連接到血槽，並在生命值損失顯示動畫。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:14
msgid ""
"Here's what you'll create: the bar and the counter animate when the "
"character takes a hit. They fade when it dies."
msgstr ""
"我們要做的：血槽與數字會在角色被攻擊時播放動畫，且會在角色死亡的時候淡出。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:18
msgid "You will learn:"
msgstr "你將學習："

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:20
msgid "How to **connect** a character to a GUI with signals"
msgstr "如何通過訊號將角色 **連接** 到 GUI"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:21
msgid "How to **control** a GUI with GDscript"
msgstr "如何使用 GDScript **控制** GUI"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:22
msgid "How to **animate** a life bar with the :ref:`Tween <class_Tween>` node"
msgstr "如何使用 :ref:`Tween <class_Tween>` 節點來 **動畫化** 血條"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:25
msgid ""
"If you want to learn how to set up the interface instead, check out the step-"
"by-step UI tutorials:"
msgstr "如果你想學習有關製作界面，請參考按部就班 UI 教學："

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:28
msgid ":doc:`ui_main_menu`"
msgstr "\\ :doc:`ui_main_menu`"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:29
msgid ":doc:`ui_game_user_interface`"
msgstr "\\ :doc:`ui_game_user_interface`"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:32
msgid ""
"When you code a game, you want to build the core gameplay first: the main "
"mechanics, player input, win and loss conditions. The UI comes a bit later. "
"You want to keep all the elements that make up your project separate if "
"possible. Each character should be in its own scene, with its own scripts, "
"and so should the UI elements. This prevents bugs, keeps your project "
"manageable, and allows different team members to work on different parts of "
"the game."
msgstr ""
"在編寫遊戲程式碼時，我們通常會先製作遊戲過程的核型程式，如遊戲的主要機制、玩"
"家輸入、判斷勝利與失敗的條件等。UI 通常都是比較後面才會做的。我們通常會希望將"
"遊戲中的各個元素都儘可能拆開來，將每個角色都放在各自的場景中，有各自的腳本。"
"UI 元素也是一樣。這樣一來可以防止 Bug，並讓專案好管理，且能夠讓不同的團隊成員"
"都能各自處理遊戲中不同的部分。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:40
msgid ""
"Once the core gameplay and the UI are ready, you'll need to connect them "
"somehow. In our example, we have the Enemy who attacks the Player at "
"constant time intervals. We want the life bar to update when the Player "
"takes damage."
msgstr ""
"一旦準備好核心的遊戲功能與 UI，我們就需要用某種方式來把遊戲功能與 UI 連接起"
"來。舉例而言，若我們有敵人會定期攻擊玩家，則我們就要讓血槽會在玩家被攻擊的時"
"候一起更新。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:45
msgid "To do this, we will use **signals**."
msgstr "要做到這點，我們會使用 **訊號** 。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:49
msgid ""
"Signals are Godot's version of the Observer pattern. They allow us to send "
"out some message. Other nodes can connect to the object that **emits** the "
"signal and receive the information. It's a powerful tool we use a lot for "
"User Interface and achievement systems. You don't want to use them "
"everywhere, though. Connecting two nodes adds some coupling between them. "
"When there's a lot of connections, they become hard to manage. For more "
"information, check out the `signals video tutorial <https://youtu.be/"
"l0BkQxF7X3E>`_ on GDquest."
msgstr ""
"訊號就是 Godot 版本的 Observer 設計模式（觀察者模式）。訊號允許我們能送出某種"
"訊息，而其他的節點則可以連接物件來 **送出 (Emit)** 訊號與接收資訊。訊號對於使"
"用者界面與成就系統來說是很強大的工具，但我們通常不會給所有地方都用上訊號。連"
"接兩個節點會增加節點間的耦合度。當有大量的連接時，節點就變得難以管理。更多資"
"訊請參考 GDquest 的 `影片訊號教學（英語）<https://youtu.be/l0BkQxF7X3E>`_ 。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:53
msgid "Download and explore the start project"
msgstr "下載並摸索起始專案"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:55
msgid ""
"Download the Godot project: :download:`ui_code_life_bar.zip <files/"
"ui_code_life_bar.zip>`. It contains all the assets and scripts you need to "
"get started. Extract the .zip archive to get two folders: `start` and `end`."
msgstr ""
"下載這個 Godot 專案： :download:`ui_code_life_bar.zip <files/"
"ui_code_life_bar.zip>` 。這個專案包含了所有需要用到的資源與腳本。解壓縮 .zip "
"檔會有兩個資料夾： `start` 與 `end` 。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:58
msgid ""
"Load the ``start`` project in Godot. In the ``FileSystem`` dock, double "
"click on LevelMockup.tscn to open it. It's an RPG game's mockup where 2 "
"characters face each other. The pink enemy attacks and damages the green "
"square at regular time intervals, until its death. Feel free to try out the "
"game: the basic combat mechanics already work. But as the character isn't "
"connected to the life bar, the ``GUI`` doesn't do anything."
msgstr ""
"在 Godot 中載入 ``start`` 專案。到 ``檔案系統`` Dock 中點兩下來打開 "
"LevelMockup.tscn。這個場景是一個 RPG 遊戲的打樣，裡面有兩個角色面對面。粉紅色"
"的敵人會定期攻擊綠色方塊並造成傷害，直到綠色方塊死亡。你可以試玩一下這個已經"
"有基本戰鬥機制的遊戲。但，角色還沒有與血槽關聯起來， ``GUI`` 沒有任何作用。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:68
msgid ""
"This is typical of how you'd code a game: you implement the core gameplay "
"first, handle the player's death, and only then you'll add the interface. "
"That's because the UI listens to what's happening in the game. So it can't "
"work if other systems aren't in place yet. If you design the UI before you "
"prototype and test the gameplay, chances are it won't work well and you'll "
"have to re-create it from scratch."
msgstr ""
"這就是我們編寫遊戲程式的典型方法：先實作遊戲的核心，再處理玩家的死亡，然後才"
"新增遊戲界面。這是因為 UI 是監聽遊戲裡發生的事的，所以若其他部分的系統還沒做"
"好 UI 就無法運作。如果在做好遊戲原型與測試遊戲之前就先設計了 UI，那很有可能最"
"後會沒辦法用這個 UI 而需從頭開始重新設計。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:71
msgid "The scene contains a background sprite, a GUI, and two characters."
msgstr "這個場景包含了一個背景 Sprite、GUI、以及兩個角色。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:75
msgid "The scene tree, with the GUI scene set to display its children"
msgstr "場景樹，設定了讓 GUI 場景顯示其子節點"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:77
msgid ""
"The GUI scene encapsulates all of the game's Graphical User Interface. It "
"comes with a barebones script where we get the path to nodes that exist "
"inside the scene:"
msgstr ""
"GUI 場景封裝了所有遊戲的圖形界面，附帶的腳本預先寫好了取得節點路徑的程式："

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:105
msgid ""
"``number_label`` displays a life count as a number. It's a ``Label`` node"
msgstr "``number_label`` 用來顯示剩餘的生命值。為一個 ``Label`` 節點"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:107
msgid "``bar`` is the life bar itself. It's a ``TextureProgress`` node"
msgstr "``bar`` 是血槽本身。為一個 ``TextureProgress`` 節點"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:108
msgid ""
"``tween`` is a component-style node that can animate and control any value "
"or method from any other node"
msgstr ""
"``tween`` 是一個類似元件的節點，用來動畫化其他節點或控制其他節點的任何數值或"
"方法"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:113
msgid ""
"The project uses a simple organization that works for game jams and tiny "
"games."
msgstr "這個專案使用了適合給 Game Jams 或小型遊戲的組織方法。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:115
msgid ""
"At the root of the project, in the `res://` folder, you will find the "
"`LevelMockup`. That's the main game scene and the one we will work with. All "
"the components that make up the game are in the `scenes/` folder. The "
"`assets/` folder contains the game sprites and the font for the HP counter. "
"In the `scripts/` folder you will find the enemy, the player, and the GUI "
"controller scripts."
msgstr ""
"在專案的根目錄 `res://` 資料夾內有一個 `LabelMockup` 。這個場景是我們要處理的"
"遊戲的主要場景。所有構成遊戲的元件都放在 `scenes/` 資料夾內。 `assets/` 資料"
"夾包含了遊戲的 Sprite 以及給 HP 計數器用的字體。 `scripts/` 資料夾內有敵人、"
"玩家、以及 GUI 控制器 (Controller) 腳本。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:117
msgid ""
"Click the edit scene icon to the right of the node in the scene tree to open "
"the scene in the editor. You'll see the LifeBar and EnergyBar are sub-scenes "
"themselves."
msgstr ""
"點擊場景樹中節點右邊的編輯場景圖示來在編輯器內打開場景。LifeBar 與 EnergyBar "
"本身就是子場景。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:121
msgid "The scene tree, with the Player scene set to display its children"
msgstr "場景樹，Player 場景設定為顯示其子節點"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:124
msgid "Set up the Lifebar with the Player's max\\_health"
msgstr "使用玩家的 max\\_health 來設定 Lifebar"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:126
msgid ""
"We have to tell the GUI somehow what the player's current health is, to "
"update the lifebar's texture, and to display the remaining health in the HP "
"counter in the top left corner of the screen. To do this we send the "
"player's health to the GUI every time they take damage. The GUI will then "
"update the ``Lifebar`` and ``Number`` nodes with this value."
msgstr ""
"我們必須用某種方式告訴 GUI 目前玩家的血量為何，並更新 Lifebar 的貼圖，然後在"
"螢幕左上角的 HP 計數器上顯示剩餘的生命值。要做到這點我們必須在每次玩家受到傷"
"害時將玩家的生命值傳送給 GUI。GUI 接著用收到的值來更新 ``Lifebar`` 與 "
"``Number`` 節點。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:132
msgid ""
"We could stop here to display the number, but we need to initialize the "
"bar's ``max_value`` for it to update in the right proportions. The first "
"step is thus to tell the ``GUI`` what the green character's ``max_health`` "
"is."
msgstr ""
"我們可以直接來更新顯示的數字，但在此之前必須先初始化計量槽的 ``max_value`` 才"
"能讓更新的比例正確。所以第一步應該是告訴 ``GUI`` 綠色角色的 ``max_health`` 值"
"為何。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:139
msgid ""
"The bar, a `TextureProgress`, has a `max_value` of `100` by default. If you "
"don't need to display the character's health with a number, you don't need "
"to change its `max_value` property. You send a percentage from the `Player` "
"to the `GUI` instead:  `health / max_health * 100`."
msgstr ""
"預設情況下，計量槽 `TextureProgress` 的 `max_value` 為 `100` 。若不需要以數字"
"方式顯示玩家的生命值的話則不需要更改 `max_value` 屬性。可以直接改為從 "
"`Player` 傳送百分比給 `GUI` ： `health / max_health * 100` 。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:143
msgid ""
"Click the script icon to the right of the ``GUI`` in the Scene dock to open "
"its script. In the ``_ready`` function, we're going to store the "
"``Player``'s ``max_health`` in a new variable and use it to set the "
"``bar``'s ``max_value``:"
msgstr ""
"點擊場景 Dock 中 ``GUI`` 右邊的腳本圖示來打開腳本。 我們要在 ``_ready`` 函式"
"中將 ``Player`` 的 ``Max_health`` 保存在一個新變數裡，然後用這個變數來設定 "
"``bar`` 的 ``max_value`` ："

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:164
msgid ""
"Let's break it down. ``$\"../Characters/Player\"`` is a shorthand that goes "
"one node up in the scene tree, and retrieves the ``Characters/Player`` node "
"from there. It gives us access to the node. The second part of the "
"statement, ``.max_health``, accesses the ``max_health`` on the Player node."
msgstr ""
"讓我們把它拆開來看。 ``$\"../Characters/Player\"`` 是取得節點的簡寫，先從節點"
"樹上的上一層開始搜尋，然後找到 ``Characters/Player`` 節點。陳述式的第二個部"
"分 ``.max_health`` 表示在 Player 節點上存取 ``max_health`` 屬性。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:170
msgid ""
"The second line assigns this value to ``bar.max_value``. You could combine "
"the two lines into one, but we'll need to use ``player_max_health`` again "
"later in the tutorial."
msgstr ""
"第二行將剛才取得的值賦值給 ``bar.max_value`` 。雖然可以把這兩行簡寫成一行，但"
"因為這個教學之後還會用到 ``player_max_health`` ，所以我們先這樣寫。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:174
msgid ""
"``Player.gd`` sets the ``health`` to ``max_health`` at the start of the "
"game, so we could work with this. Why do we still use ``max_health``? There "
"are two reasons:"
msgstr ""
"``Player.gd`` 在遊戲開始時將 ``health`` 設定成了 ``max_health`` ，所以我們可"
"以直接用 ``health`` 。但為什麼我們後面還要用到 ``max_health`` 呢？有兩個原"
"因："

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:178
msgid ""
"We don't have the guarantee that ``health`` will always equal "
"``max_health``: a future version of the game may load a level where the "
"player already lost some health."
msgstr ""
"我們沒辦法保證 ``health`` 的值永遠與 ``max_health`` 相同，遊戲之後可能會出一"
"個新版本是關卡載入時玩家的生命值就已經受損。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:184
msgid ""
"When you open a scene in the game, Godot creates nodes one by one, following "
"the order in your Scene dock, from top to bottom. `GUI` and `Player` are not "
"part of the same node branch. To make sure they both exist when we access "
"each other, we have to use the `_ready` function. Godot calls `_ready` right "
"after it loaded all nodes, before the game starts. It's the perfect function "
"to set everything up and prepare the game session. Learn more about _ready: :"
"doc:`scripting_continued`"
msgstr ""
"當在遊戲內打開場景時，Godot 會以場景 Dock 內由上而下的順序來依次建立節點。 "
"`GUI` 與 `Player` 並不再相同的節點分支上，所以為了保證我們在存取這兩個節點時"
"他們都存在，我們要用 `_ready` 函式。Godot 會在所有節點都載入後與遊戲開始之間"
"呼叫 `_ready` ，所以這裡便是設定所有東西與準備遊戲流程的最佳時機。有關 "
"_ready 的更多資訊請參考 :doc:`scripting_continued`"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:188
msgid "Update health with a signal when the player takes a hit"
msgstr "當玩家收到傷害時使用訊號來更新生命值"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:190
msgid ""
"Our GUI is ready to receive the ``health`` value updates from the "
"``Player``. To achieve this we're going to use **signals**."
msgstr ""
"GUI 已經準備要來接收 ``Player`` 傳來更新過的 ``health`` 值了。我們要使用 **訊"
"號** 來實作。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:195
msgid ""
"There are many useful built-in signals like `enter_tree` and `exit_tree`, "
"that all nodes emit when they are respectively created and destroyed. You "
"can also create your own using the `signal` keyword. On the `Player` node, "
"you'll find two signals we created for you: `died` and `health_changed`."
msgstr ""
"Godot 內有許多實用的內建訊號，如 ``enter_tree`` 與 ``exit_tree`` 這兩個訊號分"
"別會在任何節點建立與銷毀時發出。我們也可以通過 ``signal`` 關鍵字來建立自定訊"
"號。你可以在 ``Player`` 節點內看到兩個我們預先幫你做好的訊號： ``died`` 與 "
"``health_changed`` 。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:197
msgid ""
"Why don't we directly get the ``Player`` node in the ``_process`` function "
"and look at the health value? Accessing nodes this way creates tight "
"coupling between them. If you did it sparingly it may work. As your game "
"grows bigger, you may have many more connections. If you get nodes this way "
"it gets complex quickly. Not only that: you need to listen to the state "
"change constantly in the ``_process`` function. This check happens 60 times "
"a second and you'll likely break the game because of the order in which the "
"code runs."
msgstr ""
"那我們為什麼不直接在 ``_process`` 函式內取得 ``Player`` 節點然後再讀生命值"
"呢？因為這樣直接存取節點會增加程式的耦合度。如果只是偶爾這樣寫的話或許沒什麼"
"問題。但一旦遊戲變得更大，則代表需要建立更多的連接。若以這種方式取得節點則馬"
"上就會讓遊戲變得很複雜。不僅如此，還必須在 ``_process`` 函式內定期追蹤狀態變"
"化，而這個追蹤每秒都會執行 60 次，這樣很可能馬上就會因為程式執行的順序而讓遊"
"戲壞掉。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:206
msgid ""
"On a given frame you may look at another node's property *before* it was "
"updated: you get a value from the last frame. This leads to obscure bugs "
"that are hard to fix. On the other hand, a signal is emitted right after a "
"change happened. It **guarantees** you're getting a fresh piece of "
"information. And you will update the state of your connected node *right "
"after* the change happened."
msgstr ""
"對於特定的一幀上存取另一個節點 **更新前** 的屬性，則取得的值便是該節點上一個"
"幀的狀態。這樣會讓 Bug 變得難以理解而且難修正。而且，訊號是在更新後才送出的，"
"所以便能 **保證** 取得的資訊總是最新的，而且更新連接的節點的狀態時也是在改變"
"發生後 **馬上** 進行的。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:215
msgid ""
"The Observer pattern, that signals derive from, still adds a bit of coupling "
"between node branches. But it's generally lighter and more secure than "
"accessing nodes directly to communicate between two separate classes. It can "
"be okay for a parent node to get values from its children. But you'll want "
"to favor signals if you're working with two separate branches. Read Game "
"Programming Patterns for more information on the `Observer pattern <https://"
"gameprogrammingpatterns.com/observer.html>`_. The `full book <https://"
"gameprogrammingpatterns.com/contents.html>`_ is available online for free."
msgstr ""
"Observer 設計模式——也就是原版的「訊號」功能——也還是會增加節點間的耦合度。但通"
"常來說耦合度更低而且也比為了在兩個不同的類別間通訊而直接存取節點來得安全。如"
"果是從母節點取得子節點的值的話還好，但如果是兩個不同的節點分支則最好還是使用"
"訊號。你可以在 Game Programming Patterns 內瞭解更多有關 `Observer 設計模式"
"（英語） <https://gameprogrammingpatterns.com/observer.html>`_ 的內容。 `全書"
"（英語） <https://gameprogrammingpatterns.com/contents.html>`_ 也可以在線上免"
"費閱讀。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:219
msgid ""
"With this in mind, let's connect the ``GUI`` to the ``Player``. Click on the "
"``Player`` node in the scene dock to select it. Head down to the Inspector "
"and click on the Node tab. This is the place to connect nodes to listen to "
"the one you selected."
msgstr ""
"瞭解到這點後，我們來將 ``GUI`` 連接到 ``Player`` 上。在場景 Dock 中點擊 "
"``Player`` 來選擇，然後到屬性面板點擊節點分頁。這裡就是用來連接節點以及監聽所"
"選節點的地方。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:224
msgid "The first section lists custom signals defined in ``Player.gd``:"
msgstr "第一個部分列出了 ``Player.gd`` 內定義的自定訊號："

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:226
msgid ""
"``died`` is emitted when the character died. We will use it in a moment to "
"hide the UI."
msgstr "``died`` 會在角色死亡時送出。我們稍後會用這個訊號來隱藏 UI。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:228
msgid "``health_changed`` is emitted when the character got hit."
msgstr "``health_changed`` 會在角色受到攻擊時送出。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:232
msgid "We're connecting to the health\\_changed signal"
msgstr "我們現在要連接的是 health\\_changed 訊號"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:234
msgid ""
"Select ``health_changed`` and click on the Connect button in the bottom "
"right corner to open the Connect Signal window. On the left side you can "
"pick the node that will listen to this signal. Select the ``GUI`` node. The "
"right side of the screen lets you pack optional values with the signal. We "
"already took care of it in ``Player.gd``. In general I recommend not to add "
"too many arguments using this window as they're less convenient than doing "
"it from the code."
msgstr ""
"先選擇 ``health_changed`` 然後點擊右下角的連接按鈕便會打開連接訊號視窗。視窗"
"的左側可以選擇要監聽訊號的節點，這裡選 ``GUI`` 節點。視窗的右邊則可以選擇訊號"
"送出時要一併送出的可選值，但這個我們已經在 ``Player.gd`` 內處理了。通常來說我"
"不建議在這個視窗內增加太多的引數，因為從程式碼內來做會比較方便。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:244
msgid "The Connect Signal window with the GUI node selected"
msgstr "選擇了 GUI 節點的連接訊號視窗"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:248
msgid ""
"You can optionally connect nodes from the code. However doing it from the "
"editor has two advantages:"
msgstr "另外也可以使用程式碼來連接訊號，但通過編輯器來連接有兩個好處："

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:250
msgid "Godot can write new callback functions for you in the connected script"
msgstr "Godot 在連接的腳本上幫你寫一個新的回呼函式"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:251
msgid ""
"An emitter icon appears next to the node that emits the signal in the Scene "
"dock"
msgstr "發送訊號的圖示會在場景 Dock 中顯示在送出訊號的節點旁邊"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:253
msgid ""
"At the bottom of the window you will find the path to the node you selected. "
"We're interested in the second row called \"Method in Node\". This is the "
"method on the ``GUI`` node that gets called when the signal is emitted. This "
"method receives the values sent with the signal and lets you process them. "
"If you look to the right, there is a \"Make Function\" radio button that is "
"on by default. Click the connect button at the bottom of the window. Godot "
"creates the method inside the ``GUI`` node. The script editor opens with the "
"cursor inside a new ``_on_Player_health_changed`` function."
msgstr ""
"視窗的底部可以看到所選擇的節點的路徑。我們這裡可以注意到第二行為「節點中的方"
"法」，這裡顯示的就是訊號送出時會在 ``GUI`` 節點中呼叫的方法，會接收訊號送出的"
"值並讓你進行處理。右邊有一個預設勾選的「建立函式」單選框。點擊視窗底部的連接"
"按鈕，Godot 會在 ``GUI`` 節點內建立方法，並打開腳本編輯器，將遊標移動到新建立"
"的 ``_on_Player_health_changed`` 函式內。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:265
msgid ""
"When you connect nodes from the editor, Godot generates a method name with "
"the following pattern: ``_on_EmitterName_signal_name``. If you wrote the "
"method already, the \"Make Function\" option will keep it. You may replace "
"the name with anything you'd like."
msgstr ""
"從編輯器上連接訊號時，Godot 會以 ``_on_發送者名稱_訊號名稱`` 這樣的格式來建立"
"方法。若已經寫好這個函式的話，則「建立函式」仍然會保留已經寫好的函式。你可以"
"任意替換掉預設的名字。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:272
msgid "Godot writes the callback method for you and takes you to it"
msgstr "Godot 會幫你建立好回呼方法並把打開"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:274
msgid ""
"Inside the parentheses after the function name, add a ``player_health`` "
"argument. When the player emits the ``health_changed`` signal, it will send "
"its current ``health`` alongside it. Your code should look like:"
msgstr ""
"在函式名稱的括號後新增一個 ``player_health`` 引數。當 Player 送出了 "
"``health_changed`` 訊號，會將 Player 目前的 ``health`` 也一起送出。現在，你的"
"程式碼應該長這樣："

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:292
msgid ""
"The engine does not convert PascalCase to snake_case, for C# examples we'll "
"be using PascalCase for method names & camelCase for method parameters, "
"which follows the official `C# naming conventions. <https://docs.microsoft."
"com/en-us/dotnet/standard/design-guidelines/capitalization-conventions>`_"
msgstr ""
"Godot 不會將 PascalCase 大駝峰法轉換成 snake_case 底線分隔。C# 的例子內的方法"
"名稱我們會使用 PascaCase，方法參數則使用 camelCase，遵守 `C# 命名慣例 "
"<https://docs.microsoft.com/zh-tw/dotnet/standard/design-guidelines/"
"capitalization-conventions>`_"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:299
msgid ""
"In Player.gd, when the Player emits the health\\_changed signal, it also "
"sends its health value"
msgstr ""
"Player.gd 中，當 Player 送出 health\\_changed 訊號時也會一併送出 health 值"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:302
msgid ""
"Inside ``_on_Player_health_changed``, let's call a second function called "
"``update_health`` and pass it the ``player_health`` variable."
msgstr ""
"讓我們在 ``_on_Player_health_changed`` 中呼叫第二個函式 ``update_health`` ，"
"並代入 ``player_health`` 變數。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:307
msgid ""
"We could directly update the health value on `LifeBar` and `Number`. There "
"are two reasons to use this method instead:"
msgstr ""
"我們大可以直接在 ``LifeBar`` 與 ``Number`` 上更新生命值，但我們在這裡使用這種"
"方法有兩個原因："

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:309
msgid ""
"The name makes it clear for our future selves and teammates that when the "
"player took damage, we update the health count on the GUI"
msgstr ""
"函式的名稱可以讓未來的你與你的隊友們瞭解當玩家收到傷害時會更新 GUI 上的生命值"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:310
msgid "We will reuse this method a bit later"
msgstr "稍後會重複使用這個方法"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:312
msgid ""
"Create a new ``update_health`` method below ``_on_Player_health_changed``. "
"It takes a new\\_value as its only argument:"
msgstr ""
"在 ``_on_Player_health_changed`` 下方新增一個新的 ``update_health``方法，只接"
"受一個 new_value 引數："

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:327
msgid "This method needs to:"
msgstr "這個方法需要用來："

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:329
msgid ""
"set the ``Number`` node's ``text`` to ``new_value`` converted to a string"
msgstr "將 ``Numebr`` 節點的 ``text`` 設為轉換為字串的 ``new_value``"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:331
msgid "set the ``TextureProgress``'s ``value`` to ``new_value``"
msgstr "將 ``TextureProgress`` 的 ``value`` 設為 ``new_value``"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:350
msgid ""
"``str`` is a built-in function that converts about any value to text. "
"``Number``'s ``text`` property requires a string, so we can't assign it to "
"``new_value`` directly"
msgstr ""
"``str`` 是內建的函式，用來將任何數值轉換為字串。 ``Number`` 的 ``text`` 屬性"
"必須為一個字串，所以我們沒辦法直接將 ``new_value`` 指派給他"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:354
msgid ""
"Also call ``update_health`` at the end of the ``_ready`` function to "
"initialize the ``Number`` node's ``text`` with the right value at the start "
"of the game. Press :kbd:`F5` to test the game: the life bar updates with "
"every attack!"
msgstr ""
"另外，在 ``_ready`` 的結尾呼叫 ``update_health`` 來在遊戲開始時將 ``Number`` "
"節點的 ``text`` 屬性初始化為正確的值。按 :kbd:`F5` 來測試遊戲，血槽現在應該會"
"在每次被攻擊時更新了！"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:361
msgid ""
"Both the Number node and the TextureProgress update when the Player takes a "
"hit"
msgstr "Number 與 TextureProgress 節點現在在 Player 被攻擊時都會更新了"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:365
msgid "Animate the loss of life with the Tween node"
msgstr "使用 Tween 節點來動畫化生命受損"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:367
msgid ""
"Our interface is functional, but it could use some animation. That's a good "
"opportunity to introduce the ``Tween`` node, an essential tool to animate "
"properties. ``Tween`` animates anything you'd like from a start to an end "
"state over a certain duration. For example, it can animate the health on the "
"``TextureProgress`` from its current level to the ``Player``'s new "
"``health`` when the character takes damage."
msgstr ""
"界面現在會動了，但我們還可以給他加點動畫。現在是介紹用來動畫化屬性的必要工具 "
"``Tween`` 節點登場的好時機。 ``Tween`` 可以將任何屬性動畫化，在某段時間內將某"
"個起始點的值逐步增加到結束點。例如，可以使用 Tween 在角色受到攻擊時將 "
"``TextureProgress`` 上的生命值從目前的狀態動畫化到 ``Player`` 的新 "
"``health`` 值。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:374
msgid ""
"The ``GUI`` scene already contains a ``Tween`` child node stored in the "
"``tween`` variable. Let's now use it. We have to make some changes to "
"``update_health``."
msgstr ""
"``GUI`` 場景已經包含了一個儲存在 ``tween`` 變數上的 ``Tween`` 子節點了。讓我"
"們來用用它。但我們必須先在 ``update_health`` 上做點修改。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:378
msgid ""
"We will use the ``Tween`` node's ``interpolate_property`` method. It takes "
"seven arguments:"
msgstr ""
"我們要用到 ``Tween`` 節點的 ``interpolate_property`` 方法，這個方法有七個引"
"數："

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:381
msgid "A reference to the node who owns the property to animate"
msgstr "節點參照，要動畫化的屬性的節點"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:382
msgid "The property's identifier as a string"
msgstr "屬性的識別子，以字串傳入"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:383
msgid "The starting value"
msgstr "起始值"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:384
msgid "The end value"
msgstr "終止值"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:385
msgid "The animation's duration in seconds"
msgstr "動畫時間，以秒為單位"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:386
msgid "The type of the transition"
msgstr "轉場類型"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:387
msgid "The easing to use in combination with the equation."
msgstr "與方程結合使用的緩動 (Easing) 方式。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:389
msgid ""
"The last two arguments combined correspond to an easing equation. This "
"controls how the value evolves from the start to the end point."
msgstr ""
"緩動方程 (Easing Equation) 是由最後兩個引數組合成的。即，用來控制數值如何從起"
"始值變化至終止值。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:393
msgid ""
"Click the script icon next to the ``GUI`` node to open it again. The "
"``Number`` node needs text to update itself, and the ``Bar`` needs a float "
"or an integer. We can use ``interpolate_property`` to animate a number, but "
"not to animate text directly. We're going to use it to animate a new ``GUI`` "
"variable named ``animated_health``."
msgstr ""
"再次點擊 ``GUI`` 節點旁邊的腳本圖示來打開腳本。 ``Number`` 節點需要使用字串來"
"更新自己，而 ``Bar`` 需要的則是浮點數或整數。我們可以使用 "
"``interpolate_property`` 來動畫化數字，但無法直接動畫化字串。所以我們要用來動"
"畫化 ``GUI`` 上的一個新變數 ``animated_health`` 。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:399
msgid ""
"At the top of the script, define a new variable, name it "
"``animated_health``, and set its value to 0. Navigate back to the "
"``update_health`` method and clear its content. Let's animate the "
"``animated_health`` value. Call the ``Tween`` node's "
"``interpolate_property`` method:"
msgstr ""
"在腳本開頭定義一個新變數，命名為 ``animated_health`` ，並將值設為 0。然後回"
"到 ``update_health`` 方法並清空原本的內容。現在我們來動畫化 "
"``animated_health`` 的值。呼叫 ``Tween`` 節點的 ``interpolate_property`` 方"
"法："

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:421
msgid "Let's break down the call:"
msgstr "讓我們把這段程式碼拆開來看："

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:427
msgid ""
"We target ``animated_health`` on ``self``, that is to say the ``GUI`` node. "
"``Tween``'s interpolate\\_property takes the property's name as a string. "
"That's why we write it as ``\"animated_health\"``."
msgstr ""
"我們將目標設為 ``self`` ——也就使 ``GUI`` 節點——上的 ``animated_health`` 。 "
"``Tween`` 的 interpolate\\_property 接受字串形式的屬性名。所以我們需要寫成 ``"
"\"animated_health\"`` 。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:435
msgid ""
"The starting point is the current value the bar's at. We still have to code "
"this part, but it's going to be ``animated_health``. The end point of the "
"animation is the ``Player``'s ``health`` after the ``health_changed``: "
"that's ``new_value``. And ``0.6`` is the animation's duration in seconds."
msgstr ""
"起始值為目前計量槽的值，這部分還需要寫，但總之這個值會是 "
"``animated_health`` 。動畫結束點則為 ``Player`` 在 ``health_changed`` 後的 "
"``health`` 值，也就是 ``new_value`` 。0.6 則為動畫時長，單位為秒。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:441
msgid ""
"The animation will not play until we activated the ``Tween`` node with "
"``tween.start()``. We only have to do this once if the node is not active. "
"Add this code after the last line:"
msgstr ""
"動畫必須要使用 ``tween.start()`` 啟用 ``Tween`` 節點後才會開始播放。如果節點"
"還沒啟用的話，只需要執行一次即可。在最後一行後面加上這段程式碼："

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:460
msgid ""
"Although we could animate the `health` property on the `Player`, we "
"shouldn't. Characters should lose life instantly when they get hit. It makes "
"it a lot easier to manage their state, like to know when one died. You "
"always want to store animations in a separate data container or node. The "
"`tween` node is perfect for code-controlled animations. For hand-made "
"animations, check out `AnimationPlayer`."
msgstr ""
"雖然我們大可直接動畫化 ``Player`` 上的 ``health`` 屬性，但不該這麼做。角色是"
"在收到攻擊後馬上損失生命值的，這樣一來在如判斷角色死亡時機這類的狀態管理會更"
"輕鬆。通常我們都會在另一個資料容器或節點上來做動畫化。 ``Tween`` 節點很適合用"
"來做以程式碼控制的動畫。如果要手動製作動畫，請參考 ``AnimationPlayer`` 。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:463
msgid "Assign the animated\\_health to the LifeBar"
msgstr "將 animated\\_health 指派給 LifeBar"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:465
msgid ""
"Now the ``animated_health`` variable animates but we don't update the actual "
"``Bar`` and ``Number`` nodes anymore. Let's fix this."
msgstr ""
"現在 ``animated_health`` 變數已經動畫化了，但我們卻沒去更新真正的 ``Bar`` 與 "
"``Number`` 節點了。讓我們來修正一下。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:468
msgid "So far, the update\\_health method looks like this:"
msgstr "到目前為止，update\\_health 方法看起來應該像這樣："

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:492
msgid ""
"In this specific case, because ``number_label`` takes text, we need to use "
"the ``_process`` method to animate it. Let's now update the ``Number`` and "
"``TextureProgress`` nodes like before, inside of ``_process``:"
msgstr ""
"在這個例子中，由於 ``numebr_label`` 只接受字串，所以我們需要使用 "
"``_process`` 方法來動畫化。來像之前一樣更新 ``Number`` 與 "
"``TextureProgress`` 節點，但這一次在 ``_process`` 中："

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:514
msgid ""
"`number_label` and `bar` are variables that store references to the `Number` "
"and `TextureProgress` nodes."
msgstr ""
"``number_label`` 與 ``bar`` 是保存了 ``Number`` 與 ``TextureProgress`` 節點參"
"照的變數。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:516
msgid ""
"Play the game to see the bar animate smoothly. But the text displays decimal "
"number and looks like a mess. And considering the style of the game, it'd be "
"nice for the life bar to animate in a choppier fashion."
msgstr ""
"執行遊戲就可以看到動畫很順暢地播放了，但 Text 顯示了十進位數字，而且看起來很"
"亂。另外，考慮到遊戲風格，血槽的動畫效果如果能動得更粗糙一點會更好。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:522
msgid "The animation is smooth, but the number is broken"
msgstr "動畫很流暢，但數字壞了"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:524
msgid ""
"We can fix both problems by rounding out ``animated_health``. Use a local "
"variable named ``round_value`` to store the rounded ``animated_health``. "
"Then assign it to ``number_label.text`` and ``bar.value``:"
msgstr ""
"這兩個問題都可以通過將 ``animated_health`` 四捨五入來修正。使用區域變數 "
"``round_value`` 來保存四捨五入後的 ``animated_health`` ，然後再指派給 "
"``number_label.text`` 與 ``bar.value`` ："

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:546
msgid "Try the game again to see a nice blocky animation."
msgstr "再執行一次遊戲看看，現在動畫變得有點塊狀，很好看。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:550
msgid "By rounding out animated\\_health, we kill two birds with one stone"
msgstr "將 animated\\_health 四捨五入，一石二鳥修正了兩個問題"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:554
msgid ""
"Every time the player takes a hit, the ``GUI`` calls "
"``_on_Player_health_changed``, which in turn calls ``update_health``. This "
"updates the animation and the ``number_label`` and ``bar`` follow in "
"``_process``. The animated life bar that shows the health going down "
"gradually is a trick. It makes the GUI feel alive. If the ``Player`` takes 3 "
"damage, it happens in an instant."
msgstr ""
"玩家每次受到攻擊時 ``GUI`` 都會呼叫 ``_on_Player_health_changed`` ，而裡面又"
"會呼叫 ``update_health`` 並更新動畫，隨後在 ``_process`` 內也一併 "
"``number_label`` 與 ``bar`` 更新。將血條動畫化來讓生命值一點一點減少算是一種"
"技巧，能讓 GUI 更生動。若 ``Player`` 一次受到 3 個傷害，則動畫會瞬間發生。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:562
msgid "Fade the bar when the Player dies"
msgstr "Player 死亡時淡出血槽"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:564
msgid ""
"When the green character dies, it plays a death animation and fades out. At "
"this point, we shouldn't show the interface anymore. Let's fade the bar as "
"well when the character died. We will reuse the same ``Tween`` node as it "
"manages multiple animations in parallel for us."
msgstr ""
"當綠色角色死亡時播放死亡動畫並淡出。這時，我們就不該再繼續顯示界面了。讓我們"
"在角色死亡的時候淡出血槽。由於 ``Tween`` 節點可以同時平行處理多個動畫，所以我"
"們會重複使用相同的 ``Tween`` 節點。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:569
msgid ""
"First, the ``GUI`` needs to connect to the ``Player``'s ``died`` signal to "
"know when it died. Press :kbd:`F1` to jump back to the 2D Workspace. Select "
"the ``Player`` node in the Scene dock and click on the Node tab next to the "
"Inspector."
msgstr ""
"首先我們需要將 ``GUI`` 連接到 ``Player`` 的 ``died`` 訊號，才能知道玩家何時死"
"掉的。按 :kbd:`F1` 來跳回到 2D 工作區。在場景 Dock 中選擇 ``Player`` 並點擊屬"
"性面板旁邊的節點分頁。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:574
msgid "Find the ``died`` signal, select it, and click the Connect button."
msgstr "找到 ``died`` 訊號並選擇，然後點擊連接按鈕。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:578
msgid "The signal should already have the Enemy connected to it"
msgstr "訊號應該已經連接到 Enemy 上了"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:580
msgid ""
"In the Connecting Signal window, connect to the ``GUI`` node again. The Path "
"to Node should be ``../../GUI`` and the Method in Node should show "
"``_on_Player_died``. Leave the Make Function option on and click Connect at "
"the bottom of the window. This will take you to the ``GUI.gd`` file in the "
"Script Workspace."
msgstr ""
"再次在連接訊號視窗中選擇 ``GUI`` 節點。節點路徑應該顯示為 ``../../GUI`` ，而"
"節點中方法應該顯示 ``_on_Player_died`` 。保持建立函式選項勾選，然後點擊視窗底"
"部的連接按鈕。接著會在腳本工作區內打開 ``GUI.gd`` 。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:588
msgid "You should get these values in the Connecting Signal window"
msgstr "連接訊號視窗內應該顯示這些值"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:592
msgid ""
"You should see a pattern by now: every time the GUI needs a new piece of "
"information, we emit a new signal. Use them wisely: the more connections you "
"add, the harder they are to track."
msgstr ""
"現在你應該看出模式了：每當 GUI 需要新的資訊時，我們就會發出新訊號。但請小心使"
"用，因為建立越多連接則代表越難追蹤。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:594
msgid ""
"To animate a fade on a UI element, we have to use its ``modulate`` property. "
"``modulate`` is a ``Color`` that multiplies the colors of our textures."
msgstr ""
"要讓 UI 元素動畫淡出，我們必須使用 ``modulate`` 屬性。 ``modulate`` 是 "
"``Color`` 型別，用來將紋理貼圖與給定的顏色相乘。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:600
msgid ""
"`modulate` comes from the `CanvasItem` class, All 2D and UI nodes inherit "
"from it. It lets you toggle the visibility of the node, assign a shader to "
"it, and modify it using a color with `modulate`."
msgstr ""
"``modulate`` 繼承自 ``CanvasItem`` 類別，所有的 2D 與 UI 節點都繼承自 "
"CanvasItem。可以使用 ``modulate`` 來設定節點的可見性、指派著色器、或是更改顏"
"色。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:602
msgid ""
"``modulate`` takes a ``Color`` value with 4 channels: red, green, blue and "
"alpha. If we darken any of the first three channels it darkens the "
"interface. If we lower the alpha channel, our interface fades out."
msgstr ""
"``modulate`` 接受有四個通道的 ``Color`` 值：Red 紅色、Green 綠色、Blue 藍色、"
"與 Alpha 透明度。若將前三個通道變暗，則界面會變暗。若降低 Alpha 通道，則界面"
"會淡出。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:606
msgid ""
"We're going to tween between two color values: from a white with an alpha of "
"``1``, that is to say at full opacity, to a pure white with an alpha value "
"of ``0``, completely transparent. Let's add two variables at the top of the "
"``_on_Player_died`` method and name them ``start_color`` and ``end_color``. "
"Use the ``Color()`` constructor to build two ``Color`` values."
msgstr ""
"我們需要在兩個色彩間 Tween，起始值為 Alpha 為 ``1`` （即完全不透明）的白色，"
"終止值則為 Alpha 值為 ``0`` （即完全透明）的白色。來在 ``_on_Player_died`` 方"
"法最上面新增兩個變數，名為 ``start_color`` 與 ``end_color`` 。使用 "
"``Color()`` 建構函式來建立兩個 ``Color`` 值。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:628
msgid ""
"``Color(1.0, 1.0, 1.0)`` corresponds to white. The fourth argument, "
"respectively ``1.0`` and ``0.0`` in ``start_color`` and ``end_color``, is "
"the alpha channel."
msgstr ""
"``Color(1.0, 1.0, 1.0)`` 對應為白色。第四個引數，在 ``start_color`` 與 "
"``end_color`` 中分別為 ``1.0`` 與 ``0.0`` 為 Alpha 通道。"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:632
msgid ""
"We then have to call the ``interpolate_property`` method of the ``Tween`` "
"node again:"
msgstr "接著我們需要再次呼叫 ``Tween`` 節點的 ``interpolate_property`` 方法："

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:645
msgid ""
"This time, we change the ``modulate`` property and have it animate from "
"``start_color`` to the ``end_color``. The duration is of one second, with a "
"linear transition. Here's the complete ``_on_Player_died`` method:"
msgstr ""
"這次我們需要動畫化的是 ``modulate`` 屬性，從 ``start_color`` 漸變到 "
"``end_color`` 。持續時間為一秒鐘，並使用線性動畫。完整的 ``_on_Player_died`` "
"方法長這樣："

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:669
msgid "And that is it. You may now play the game to see the final result!"
msgstr "就這樣。現在可以執行遊戲來看看最終成果了！"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:673
msgid "The final result. Congratulations for getting there!"
msgstr "最終成果。恭喜你完成了！"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:677
msgid ""
"Using the exact same techniques, you can change the color of the bar when "
"the Player gets poisoned, turn the bar red when its health drops low, shake "
"the UI when they take a critical hit... the principle is the same: emit a "
"signal to forward the information from the `Player` to the `GUI` and let the "
"`GUI` process it."
msgstr ""
"使用完全相同的基數，也可以在 Player 中毒時更改血槽的顏色、或是在殘血時將血槽"
"改為紅色、更或是當受到致命一擊時晃動 UI……等。這些都是使用相同的概念：通過訊號"
"從 ``Player`` 送出資訊給 ``GUI`` 並讓 ``GUI`` 處理這些資訊。"
