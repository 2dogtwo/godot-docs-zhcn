# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2021, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-03-31 15:34+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../docs/getting_started/step_by_step/signals.rst:1
msgid "Signal"
msgstr "訊號"

#: ../../docs/getting_started/step_by_step/signals.rst:7
msgid "Signals"
msgstr "訊號"

#: ../../docs/getting_started/step_by_step/signals.rst:10
msgid "Introduction"
msgstr "簡介"

#: ../../docs/getting_started/step_by_step/signals.rst:12
msgid ""
"Signals are Godot's version of the *observer* pattern. They allow a node to "
"send out a message that other nodes can listen for and respond to. For "
"example, rather than continuously checking a button to see if it's being "
"pressed, the button can emit a signal when it's pressed."
msgstr ""
"訊號是 Godot 版本的 **觀察者** (Observer) 設計模式。使用訊號可以讓一個節點送"
"出訊息，然後讓其他節點能監聽該訊息並進行回應。舉例來說，有了訊號就不需要一直"
"重複檢查同一個按鈕來確認按鈕有沒有被按下，而可以通過讓按鈕送出訊號來通知其他"
"人按鈕被按下了。"

#: ../../docs/getting_started/step_by_step/signals.rst:17
msgid ""
"You can read more about the observer pattern here: https://"
"gameprogrammingpatterns.com/observer.html"
msgstr ""
"欲瞭解更多有關觀察者模式的資訊，請參考：https://gameprogrammingpatterns.com/"
"observer.html"

#: ../../docs/getting_started/step_by_step/signals.rst:19
msgid ""
"Signals are a way to *decouple* your game objects, which leads to better "
"organized and more manageable code. Instead of forcing game objects to "
"expect other objects to always be present, they can instead emit signals "
"that all interested objects can subscribe to and respond to."
msgstr ""
"訊號是一種 **解耦** 遊戲物件的方法，可以更好地組織與管理程式碼。不需要強制讓"
"某個遊戲物件去配合數個物件，而是讓物件發出訊號，所有需要反應的物件都可以訂閱"
"訊號並進行回應。"

#: ../../docs/getting_started/step_by_step/signals.rst:24
msgid ""
"Below you can see some examples of how you can use signals in your own "
"projects."
msgstr "下方的例子說明了如何能在專案內使用訊號。"

#: ../../docs/getting_started/step_by_step/signals.rst:27
msgid "Timer example"
msgstr "計時器範例"

#: ../../docs/getting_started/step_by_step/signals.rst:29
msgid ""
"To see how signals work, let's try using a :ref:`Timer <class_Timer>` node. "
"Create a new scene with a Node2D and two children: a Timer and a :ref:"
"`Sprite <class_Sprite>`. In the Scene dock, rename Node2D to TimerExample."
msgstr ""
"為了瞭解訊號怎麼運作的，來試試看 :ref:`Timer <class_Timer>` (計時器) 節點。先"
"建立場景，並設定一個 Node2D 與兩個子節點：Timer 與 :ref:`Sprite "
"<class_Sprite>` 。接著在場景 Dock 內把 Node2D 重命名為 TimerExample (計時器範"
"例)。"

#: ../../docs/getting_started/step_by_step/signals.rst:33
msgid ""
"For the Sprite's texture, you can use the Godot icon, or any other image you "
"like. Do so by selecting ``Load`` in the Sprite's Texture attribute drop-"
"down menu. Attach a script to the root node, but don't add any code to it "
"yet."
msgstr ""
"可以用 Godot 的圖示或其他喜歡的圖片來設定 Sprite 紋理貼圖。要設定紋理貼圖，請"
"在 Sprite 的 Texture (紋理貼圖) 下拉選單內選擇 [載入] 。之後在根節點上附加腳"
"本，但在這裡先不要新增任何程式碼。"

#: ../../docs/getting_started/step_by_step/signals.rst:37
msgid "Your scene tree should look like this:"
msgstr "現在，場景樹應該會長這樣："

#: ../../docs/getting_started/step_by_step/signals.rst:41
msgid ""
"In the Timer node's properties, check the \"On\" box next to *Autostart*. "
"This will cause the timer to start automatically when you run the scene. You "
"can leave the *Wait Time* at 1 second."
msgstr ""
"來看看 Timer 節點的屬性，先把 **Autostart** (自動開始) 旁邊的 [開啟] 勾選框打"
"勾。這樣會讓計時器在場景執行的時候自動開始。而 **Wait Time** (等待時間) 可以"
"保持預設的 1 秒。"

#: ../../docs/getting_started/step_by_step/signals.rst:45
msgid ""
"Next to the \"Inspector\" tab is a tab labeled \"Node\". Click on this tab "
"and you'll see all of the signals that the selected node can emit. In the "
"case of the Timer node, the one we're concerned with is \"timeout\". This "
"signal is emitted whenever the Timer reaches ``0``."
msgstr ""
"在屬性面板分頁旁邊有一個叫做 [節點] 的分頁。點開這個分頁，會看到目前選擇節點"
"可送出的所有訊號。在本例中，我們需要的是「timeout」訊號。這個訊號會在 Timer "
"倒數到 0 的時候送出。"

#: ../../docs/getting_started/step_by_step/signals.rst:52
msgid ""
"Click on the \"timeout()\" signal and click \"Connect...\" at the bottom of "
"the signals panel. You'll see the following window, where you can define how "
"you want to connect the signal:"
msgstr ""
"點擊「timeout()」訊號，然後選擇訊號面板下方的 [連接...]。接下來會看到下面這個"
"視窗，可以設定要如何連接訊號："

#: ../../docs/getting_started/step_by_step/signals.rst:58
msgid ""
"On the left side, you'll see the nodes in your scene and can select the node "
"that you want to \"listen\" for the signal. Note that the Timer node is "
"blue, this is a visual indication that it's the node that is emitting the "
"signal. Select the root node."
msgstr ""
"視窗左邊是場景中的節點，可以選擇一個節點來「監聽」訊號。請注意，Timer 節點顯"
"示為藍色的，這代表 Timer 是送出訊號的節點。這裡先選擇根節點。"

#: ../../docs/getting_started/step_by_step/signals.rst:63
msgid ""
"The target node *must* have a script attached or you'll receive an error "
"message."
msgstr "目標節點 **必須有** 附加腳本，不然會顯示錯誤訊息。"

#: ../../docs/getting_started/step_by_step/signals.rst:66
msgid ""
"If you toggle the Advanced menu, you'll see on the right side that you can "
"bind an arbitrary number of arguments of (possibly) different types. This "
"can be useful when you have more than one signal connected to the same "
"method, as each signal propagation will result in different values for those "
"extra call arguments."
msgstr ""
"如果打開「進階」選單，就可以看到右邊能選擇要綁定的引數數量以及引數 (可用) 的"
"型別。這個功能適用於同一個方法連接多個不同訊號的情況，因為每個訊號在傳遞時都"
"會依據這裡設定的額外呼叫引數來代入不同的值。"

#: ../../docs/getting_started/step_by_step/signals.rst:70
msgid ""
"On the bottom of the window is a field labeled \"Receiver Method\". This is "
"the name of the function in the target node's script that you want to use. "
"By default, Godot will create this function using the naming convention "
"``_on_<node_name>_<signal_name>`` but you can change it if you wish."
msgstr ""
"視窗底下有一個 [Receiver 方法] 欄位，這個欄位表示目標節點腳本中的接收函式名"
"稱。預設 Godot 會使用 ``_on_<節點名稱>_<訊號名稱>`` 這樣的命名格式，但也可以"
"自己修改 Receiver 方法名稱。"

#: ../../docs/getting_started/step_by_step/signals.rst:75
msgid ""
"Click \"Connect\" and you'll see that the function has been created in the "
"script:"
msgstr "點擊 [連接] 後，就可以看到腳本中建立了函式："

#: ../../docs/getting_started/step_by_step/signals.rst:96
msgid ""
"Now we can replace the placeholder code with whatever code we want to run "
"when the signal is received. Let's make the Sprite blink:"
msgstr ""
"現在我們可以把預設代入的程式碼改成收到訊號後要執行的程式。來讓 Sprite 閃爍一"
"下："

#: ../../docs/getting_started/step_by_step/signals.rst:121
msgid ""
"Run the scene and you'll see the Sprite blinking on and off every second. "
"You can change the Timer's *Wait Time* property to alter this."
msgstr ""
"執行場景後就看到 Sprite 一秒閃爍一次。可以修改 Timer 的 **Wait Time** (等待時"
"間) 屬性來更改頻率。"

#: ../../docs/getting_started/step_by_step/signals.rst:125
msgid "Connecting signals in code"
msgstr "使用程式碼來連接訊號"

#: ../../docs/getting_started/step_by_step/signals.rst:127
msgid ""
"You can also make the signal connection in code rather than with the editor. "
"This is usually necessary when you're instancing nodes via code and so you "
"can't use the editor to make the connection."
msgstr ""
"除了使用編輯器界面，也可以使用程式碼來建立訊號連接。如果用程式碼來實體化節點"
"的話，通常也必須使用程式碼來建立訊號連接，因為這種情況下沒辦法用編輯器界面。"

#: ../../docs/getting_started/step_by_step/signals.rst:131
msgid ""
"First, disconnect the signal by selecting the connection in the Timer's "
"\"Node\" tab and clicking disconnect."
msgstr ""
"首先，要先把 Timer 的訊號斷開。選擇 Timer 節點後，打開 [節點] 分頁，選擇連接"
"並點擊 [中斷]。"

#: ../../docs/getting_started/step_by_step/signals.rst:136
msgid ""
"To make the connection in code, we can use the ``connect`` function. We'll "
"put it in ``_ready()`` so that the connection will be made on run. The "
"syntax of the function is ``<source_node>.connect(<signal_name>, "
"<target_node>, <target_function_name>)``. Here is the code for our Timer "
"connection:"
msgstr ""
"要使用程式碼建立連接，可以使用 ``connect`` 函式。我們寫在 ``_ready()`` 函式"
"內，這樣一來連接就會在執行的時候建立。這個函式的語法是 ``<來源節點>.connect(<"
"訊號名稱>, <目標節點>, <目標函式名稱>)`` 。下列程式碼會建立本例中的 Timer 連"
"接："

#: ../../docs/getting_started/step_by_step/signals.rst:171
msgid "Custom signals"
msgstr "自定訊號"

#: ../../docs/getting_started/step_by_step/signals.rst:173
msgid "You can also declare your own custom signals in Godot:"
msgstr "Godot 中可以宣告自定訊號："

#: ../../docs/getting_started/step_by_step/signals.rst:192
msgid ""
"Once declared, your custom signals will appear in the Inspector and can be "
"connected in the same way as a node's built-in signals."
msgstr ""
"宣告後，自定訊號會出現在屬性面板上，並可以用與內建訊號相同的方式建立連接。"

#: ../../docs/getting_started/step_by_step/signals.rst:195
msgid "To emit a signal via code, use the ``emit_signal`` function:"
msgstr "使用 ``emit_signal`` 函式來通過程式碼送出訊號："

#: ../../docs/getting_started/step_by_step/signals.rst:222
msgid ""
"A signal can also optionally declare one or more arguments. Specify the "
"argument names between parentheses:"
msgstr "訊號也可以宣告一個或多個引數。在括號中指定引數的名稱："

#: ../../docs/getting_started/step_by_step/signals.rst:243
msgid ""
"The signal arguments show up in the editor's node dock, and Godot can use "
"them to generate callback functions for you. However, you can still emit any "
"number of arguments when you emit signals. So it's up to you to emit the "
"correct values."
msgstr ""
"訊號的引數會顯示在編輯器的節點 Dock 中。Godot 會使用訊號引數來產生回呼函式。"
"但送出訊號時一樣可以送出任意數量的引數，可自行決定是否要送出正確的數量。"

#: ../../docs/getting_started/step_by_step/signals.rst:248
msgid ""
"To pass values, add them as the second argument to the ``emit_signal`` "
"function:"
msgstr "若需要傳遞數值，可將數值放在 ``emit_signal`` 函式的第二個引數內："

#: ../../docs/getting_started/step_by_step/signals.rst:276
msgid "Conclusion"
msgstr "結論"

#: ../../docs/getting_started/step_by_step/signals.rst:278
msgid ""
"Many of Godot's built-in node types provide signals you can use to detect "
"events. For example, an :ref:`Area2D <class_Area2D>` representing a coin "
"emits a ``body_entered`` signal whenever the player's physics body enters "
"its collision shape, allowing you to know when the player collected it."
msgstr ""
"許多 Godot 內建的型別都提供各種訊號可用來偵測事件。例如，當金幣 :ref:`Area2D "
"<class_Area2D>` 物件送出 ``body_entered`` 訊號，就表示玩家物理形體進入了金幣"
"的碰撞區域，代表玩家蒐集到金幣。"

#: ../../docs/getting_started/step_by_step/signals.rst:283
msgid ""
"In the next section, :ref:`doc_your_first_game`, you'll build a complete "
"game including several uses of signals to connect different game components."
msgstr ""
"在下一個章節 :ref:`doc_your_first_game` 中，我們將製作一個完整的遊戲，其中會"
"用到訊號來連接各個不同的遊戲元件。"
