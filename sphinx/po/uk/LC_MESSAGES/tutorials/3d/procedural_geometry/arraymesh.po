# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2022, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-08 13:53+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using the ArrayMesh"
msgstr "Використання ArrayMesh"

msgid ""
"This tutorial will present the basics of using an :ref:`ArrayMesh "
"<class_arraymesh>`"
msgstr "Цей урок дасть основи використання :ref:`ArrayMesh <class_arraymesh>`"

msgid ""
"To do so, we will use the function :ref:`add_surface_from_arrays() "
"<class_ArrayMesh_method_add_surface_from_arrays>`, which takes up to four "
"parameters. The first two are required, while the second two are optional."
msgstr ""
"Ми будемо використовувати функцію :ref:`add_surface_from_arrays() "
"<class_ArrayMesh_method_add_surface_from_arrays>`, яка приймає до чотирьох "
"параметрів. Перші два обов'язкові, а другі два - необов'язкові."

msgid ""
"The first is the ``PrimitiveType``, this is an OpenGL concept that instructs "
"the GPU how to arrange the primitive based on the vertices given whether it "
"is triangles, lines, points, etc. A complete list can be found under the :"
"ref:`Mesh <class_mesh>` class reference page."
msgstr ""
"Перший - ``PrimitiveType``, це концепція OpenGL, яка інструктує графічний "
"процесор, як розташувати примітив на основі вершин, враховуючи, чи це "
"трикутники, лінії, точки тощо. Повний список можна знайти на сторінці "
"посилання на клас :ref:`Mesh <class_mesh>`."

msgid ""
"The second is the actual Array that stores the mesh information. The array "
"is a normal Godot array that is constructed with empty brackets ``[]``. It "
"stores a ``Pool**Array`` (e.g. PoolVector3Array, PoolIntArray, etc.) for "
"each type of information."
msgstr ""
"Другий - це фактичний Масив, який зберігає інформацію про меш. Це звичайний "
"масив Godot, побудований з порожніми дужками ``[]``. Він зберігає "
"``Pool**Array`` (наприклад, PoolVector3Array, PoolIntArray тощо) для кожного "
"типу інформації."

msgid "``ARRAY_VERTEX`` = 0 | PoolVector3Array or PoolVector2Array"
msgstr "``ARRAY_VERTEX`` = 0 | PoolVector3Array, або PoolVector2Array"

msgid "``ARRAY_NORMAL`` = 1 | PoolVector3Array"
msgstr "``ARRAY_NORMAL`` = 1 | PoolVector3Array"

msgid ""
"``ARRAY_TANGENT`` = 2 | PoolRealArray of groups of 4 floats. First 3 floats "
"determine the tangent, and the last the binormal direction as -1 or 1."
msgstr ""
"``ARRAY_TANGENT`` = 2 | PoolRealArray з групи з 4-х десяткових. Перші 3 "
"десяткові визначають тангенс, а останній - бінормальний напрямок типу -1, "
"або 1."

msgid "``ARRAY_COLOR`` = 3 | PoolColorArray"
msgstr "``ARRAY_COLOR`` = 3 | PoolColorArray"

msgid "``ARRAY_TEX_UV`` = 4 | PoolVector2Array or PoolVector3Array"
msgstr "``ARRAY_TEX_UV`` = 4 | PoolVector2Array, або PoolVector3Array"

msgid "``ARRAY_TEX_UV2`` = 5 | PoolVector2Array or PoolVector3Array"
msgstr "``ARRAY_TEX_UV2`` = 5 | PoolVector2Array, або PoolVector3Array"

msgid ""
"``ARRAY_BONES`` = 6 | PoolRealArray of groups of 4 floats or PoolIntArray of "
"groups of 4 ints. Each group lists indexes of 4 bones that affects a given "
"vertex."
msgstr ""
"``ARRAY_BONES`` = 6 | PoolRealArray з групи з 4-х десяткових, або "
"PoolIntArray з групи з 4-х цілих. Кожна група перераховує індекси 4-х "
"кісток, які впливають на задану вершину."

msgid ""
"``ARRAY_WEIGHTS`` = 7 | PoolRealArray of groups of 4 floats. Each float "
"lists the amount of weight an determined bone on ``ARRAY_BONES`` has on a "
"given vertex."
msgstr ""
"``ARRAY_WEIGHTS`` = 7 | PoolRealArray з групи з 4-х десяткових. Кожне "
"десяткове вказує силу ваги кістки, визначеної в ``ARRAY_BONES``, на задану "
"вершину."

msgid "``ARRAY_INDEX`` = 8 | PoolIntArray"
msgstr "``ARRAY_INDEX`` = 8 | PoolIntArray"

msgid ""
"The Array of vertices is always required. All the others are optional and "
"will only be used if included."
msgstr ""
"Масив вершин (ARRAY_VERTEX) завжди обов'язковий. Всі інші є необов'язковими "
"і будуть використовуватися тільки в тому випадку, якщо включені."

msgid ""
"Each array needs to have the same number of elements as the vertex array "
"except for the index array. For arrays like tangents, an element is a group "
"of 4 floats. So the array size will be four times the size of the vertex "
"array size, but they will have the same number of elements"
msgstr ""
"Кожен масив повинен мати таку ж кількість елементів, що і масив вершин, за "
"винятком масиву індексів (ARRAY_INDEX). В масивах, що містять, наприклад, "
"тангенси (ARRAY_TANGENT), кожен елемент являє собою групу з 4 десяткових. "
"Таким чином, розмір такого масиву буде в чотири рази більше розміру масиву "
"вершин, але вони будуть мати однакову кількість елементів"

msgid "The index array is unique."
msgstr "Масив індексів унікальний."

msgid ""
"The third parameter is an array of blendshapes for the Mesh to use. While "
"this tutorial does not cover using blendshapes, it is possible to specify "
"them when creating a surface from arrays."
msgstr ""
"Третій параметр - це масив змішаних форм *(blendshapes)*, які Меш може "
"використовувати. Хоча цей урок не охоплює їх використання, можна вказати їх "
"при створенні поверхні з масивів."

msgid ""
"The last parameter is the compress flags which specifies which arrays to "
"store with half as many bits. The values can be found in the classref for :"
"ref:`VisualServer <class_visualserver>` under :ref:`ArrayFormat "
"<enum_visualserver_arrayformat>`."
msgstr ""
"Останнім параметром є мітки стиснення, які визначають, які масиви зберігати "
"з половиною бітів. Значення можна знайти в :ref:`VisualServer "
"<class_visualserver>` в розділі :ref:`ArrayFormat "
"<enum_visualserver_arrayformat>`."

msgid ""
"For normal usage you will find it is best to leave the last two parameters "
"empty."
msgstr ""
"Ви виявите, що, для нормального використання, найкраще залишити останні два "
"параметри порожніми."

msgid "ArrayMesh"
msgstr "ArrayMesh"

msgid ""
"Add an :ref:`ArrayMesh <class_arraymesh>` to a MeshInstance. Normally, "
"adding an ArrayMesh in the editor is not useful, but in this case it allows "
"as to access the ArrayMesh from code without creating one."
msgstr ""
"Додайте :ref:`ArrayMesh <class_arraymesh>` в MeshInstance. Як правило, "
"додавання ArrayMesh в редактор не є корисним, але це дозволяє отримати "
"доступ до масиву ArrayMesh з коду, без створення самого меша."

msgid "Next, add a script to the MeshInstance."
msgstr "Далі додайте скрипт до MeshInstance."

msgid "Under ``_ready()``, create a new Array."
msgstr "Під ``_ready()`` створіть новий масив."

msgid ""
"This will be the array that we keep our surface information in, it will hold "
"all the arrays of data that the surface needs. Godot will expect it to be of "
"size ``Mesh.ARRAY_MAX``, so resize it accordingly."
msgstr ""
"Це буде масив, в якому ми зберігаємо інформацію про нашу поверхню, він буде "
"містити всі масиви даних, які потрібні поверхні. Godot очікує, що він буде "
"розміром з ``Mesh.ARRAY_MAX``, тому змініть його відповідно."

msgid "Next create the arrays for each data type you will use."
msgstr ""
"Далі створіть масиви для кожного типу даних, які ви будете використовувати."

msgid ""
"Once you have filled your data arrays with your geometry you can create a "
"mesh by adding each array to ``surface_array`` and then committing to the "
"mesh."
msgstr ""
"Після того, як ви заповнили свої масиви даних геометрією, ви можете створити "
"меш, додавши кожен масив до ``surface_array`` *(масиву поверхні)*."

msgid ""
"In this example, we used ``Mesh.PRIMITIVE_TRIANGLES``, but you can use any "
"primitive type available from mesh."
msgstr ""
"У цьому прикладі ми використовували ``Mesh.PRIMITIVE_TRIANGLES``, але ви "
"можете використовувати будь-який тип примітиву, доступний для меша."

msgid "Put together the full code looks like:"
msgstr "Зібрати воєдино повний код виглядає так:"

msgid ""
"The code that goes in the middle can be whatever you want. Below we will "
"present some example code that could go in the middle."
msgstr ""
"Код в середині, може бути інший, залежно від вашого бажання. Нижче ми "
"наведемо кілька прикладів коду, який може піти в середині."

msgid "Generating geometry"
msgstr "Генерування геометрії"

msgid ""
"Here is sample code for generating a sphere. Although the code is presented "
"in GDScript, there is nothing Godot specific about the approach to "
"generating it. This implementation has nothing in particular to do with "
"ArrayMeshes and is just a generic approach to generating a sphere. If you "
"are having trouble understanding it or want to learn more about procedural "
"geometry in general, you can use any tutorial that you find online."
msgstr ""
"Ось зразок коду для створення сфери. Хоча код представлений в GDScript, "
"немає нічого специфічного для Godot в підході до його створення. Ця "
"реалізація не має нічого спільного з ArrayMesh-ами і є лише загальним "
"підходом до створення сфери. Якщо у вас виникли проблеми з розумінням, або "
"ви хочете дізнатися більше про процедурну геометрію, ви можете "
"використовувати будь-який урок, який знайдете в Інтернеті."

msgid "Combined with the code above, this code will generate a sphere."
msgstr "У поєднанні з наведеним вище кодом цей код буде генерувати сферу."

msgid ""
"When it comes to generating geometry with the ArrayMesh you need to "
"understand what goes in each array and then you can follow tutorials for any "
"language/engine and convert it into Godot."
msgstr ""
"Коли справа доходить до генерування геометрії з ArrayMesh, вам потрібно "
"зрозуміти, що відбувається в кожному масиві, а потім ви зможете знайомитися "
"з уроками для будь-якої мови/рушія та конвертувати їх в Godot."

msgid "Saving"
msgstr "Збереження"

msgid ""
"Finally, Godot provides a single method to save ArrayMeshes using the :ref:"
"`ResourceSaver <class_resourcesaver>` class. This is useful when you want to "
"generate a mesh and then use it later without having to re-generate."
msgstr ""
"Нарешті, Godot надає єдиний метод збереження ArrayMesh-ів за допомогою "
"класу :ref:`ResourceSaver <class_resourcesaver>`. Це корисно, коли ви хочете "
"створити меш, а потім використовувати його пізніше без необхідності повторно "
"генерувати."

msgid "Translation status"
msgstr "Стан перекладу"
