# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2020, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-01-07 14:35+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:4
msgid "Control the game's UI with code"
msgstr "Керування користувацьким інтерфейсом з коду"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:7
msgid "Intro"
msgstr "Вступ"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:9
#, fuzzy
msgid ""
"In this tutorial, you will connect a character to a life bar and animate the "
"health loss."
msgstr ""
"У цьому уроці ви підключите персонажа до шкали здоров'я і оживите втрату "
"здоров'я."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:14
#, fuzzy
msgid ""
"Here's what you'll create: the bar and the counter animate when the "
"character takes a hit. They fade when it dies."
msgstr ""
"Ось що ви створите: анімація шкали та лічильника, коли персонаж отримує "
"пошкодження. Коли персонаж помре, вони зникнуть."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:18
msgid "You will learn:"
msgstr "Ви навчитеся:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:20
#, fuzzy
msgid "How to **connect** a character to a GUI with signals"
msgstr "**підключати** персонажа до графічного інтерфейсу з допомогою сигналів"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:21
#, fuzzy
msgid "How to **control** a GUI with GDscript"
msgstr "**керувати** графічним інтерфейсом з допомогою GDscript"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:22
#, fuzzy
msgid "How to **animate** a life bar with the :ref:`Tween <class_Tween>` node"
msgstr ""
"**анімувати** шкалу здоров'я з допомогою вузла :ref:`Tween <class_Tween>` "
"node"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:25
#, fuzzy
msgid ""
"If you want to learn how to set up the interface instead, check out the step-"
"by-step UI tutorials:"
msgstr ""
"Якщо ви хочете навчитися налаштовувати інтерфейс, то перегляньте уроки по "
"інтерфейсу користувача:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:28
msgid ":doc:`ui_main_menu`"
msgstr ""

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:29
msgid ":doc:`ui_game_user_interface`"
msgstr ""

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:32
#, fuzzy
msgid ""
"When you code a game, you want to build the core gameplay first: the main "
"mechanics, player input, win and loss conditions. The UI comes a bit later. "
"You want to keep all the elements that make up your project separate if "
"possible. Each character should be in its own scene, with its own scripts, "
"and so should the UI elements. This prevents bugs, keeps your project "
"manageable, and allows different team members to work on different parts of "
"the game."
msgstr ""
"Коли ви програмуєте гру, ви спершу хочете побудувати основний геймплей: "
"основні механізми, введення гравця, умови виграшу та програшу. Інтерфейс "
"користувача з’являється трохи пізніше. Ви хочете, щоб усі елементи, що "
"складають ваш проект, залишалися окремими, якщо це можливо. Кожен персонаж "
"повинен бути у власній сцені, зі своїми скриптами, так же і з елементами "
"інтерфейсу користувача. Це запобігає помилкам, зберігає ваш проект керованим "
"та дозволяє різним членам команди працювати в різних частинах гри."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:40
#, fuzzy
msgid ""
"Once the core gameplay and the UI are ready, you'll need to connect them "
"somehow. In our example, we have the Enemy who attacks the Player at "
"constant time intervals. We want the life bar to update when the Player "
"takes damage."
msgstr ""
"Після того, як основний геймплей та інтерфейс готові, вам потрібно буде "
"якось з'єднати їх. У нашому зразку є ворог, який атакує гравця через "
"постійні інтервали часу. Ми хочемо, щоб шкала здоров'я оновлювалася, коли "
"гравець отримує пошкодження."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:45
msgid "To do this, we will use **signals**."
msgstr "Для цього ми будемо використовувати **сигнали**."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:49
#, fuzzy
msgid ""
"Signals are Godot's version of the Observer pattern. They allow us to send "
"out some message. Other nodes can connect to the object that **emits** the "
"signal and receive the information. It's a powerful tool we use a lot for "
"User Interface and achievement systems. You don't want to use them "
"everywhere, though. Connecting two nodes adds some coupling between them. "
"When there's a lot of connections, they become hard to manage. For more "
"information, check out the `signals video tutorial <https://youtu.be/"
"l0BkQxF7X3E>`_ on GDquest."
msgstr ""
"Сигнали є версією Godot у шаблоні спостерігача. Вони дозволяють нам "
"надсилати якесь повідомлення. Інші вузли можуть підключитися до об'єкта, "
"який **випромінює** сигнал і отримувати інформацію. Це потужний інструмент, "
"який ми часто будемо використовувати для інтерфейсу користувача та систем "
"досягнення. Ви можете не використовувати їх скрізь. Зв'язок між двома "
"вузлами додає деяке сполучення між ними. Коли зв'язків багато, ними стає "
"важко керувати. Для отримання додаткової інформації перегляньте `signals "
"video tutorial <https://youtu.be/l0BkQxF7X3E>`_ на GDquest."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:53
msgid "Download and explore the start project"
msgstr "Завантажте та вивчіть стартовий проект"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:55
#, fuzzy
msgid ""
"Download the Godot project: :download:`ui_code_life_bar.zip <files/"
"ui_code_life_bar.zip>`. It contains all the assets and scripts you need to "
"get started. Extract the .zip archive to get two folders: `start` and `end`."
msgstr ""
"Завантажте проект Godot: :download:`ui_code_life_bar.zip <files/"
"ui_code_life_bar.zip>`. Він містить усі ресурси та скрипти, необхідні для "
"початку роботи. Витягніть архів .zip, щоб отримати дві теки: `початок` і "
"`кінець`."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:58
#, fuzzy
msgid ""
"Load the ``start`` project in Godot. In the ``FileSystem`` dock, double "
"click on LevelMockup.tscn to open it. It's an RPG game's mockup where 2 "
"characters face each other. The pink enemy attacks and damages the green "
"square at regular time intervals, until its death. Feel free to try out the "
"game: the basic combat mechanics already work. But as the character isn't "
"connected to the life bar, the ``GUI`` doesn't do anything."
msgstr ""
"Завантажте проект ``start`` у Godot. На панелі Файлова система двічі "
"клацніть на ``LevelMockup.tscn``, щоб відкрити її. Це макет RPG гри, де 2 "
"персонажі стикаються один з одним. Рожевий ворог атакує і наносить "
"пошкодження зеленому квадрату через регулярні проміжки часу, аж до його "
"загибелі. Не соромтеся спробувати гру: основна бойова механіка вже працює. "
"Але оскільки персонаж не пов'язаний зі шкалою здоров'я, ``GUI`` нічого не "
"робить."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:68
#, fuzzy
msgid ""
"This is typical of how you'd code a game: you implement the core gameplay "
"first, handle the player's death, and only then you'll add the interface. "
"That's because the UI listens to what's happening in the game. So it can't "
"work if other systems aren't in place yet. If you design the UI before you "
"prototype and test the gameplay, chances are it won't work well and you'll "
"have to re-create it from scratch."
msgstr ""
"Це типово для програмування гри: спочатку ви реалізуєте основний геймплей, "
"відпрацьовуєте смерть гравця, а вже потім додасте інтерфейс. Це тому, що "
"інтерфейс користувача слухає, що відбувається в грі. Тому він не може "
"працювати, якщо інші системи ще не створені. Якщо ви спроектували інтерфейс, "
"перш ніж створили і протестувати геймплей, то, швидше за все, він не "
"працюватиме добре, і вам доведеться його створити з нуля."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:71
msgid "The scene contains a background sprite, a GUI, and two characters."
msgstr ""
"Сцена містить спрайт з фоном гри, графічний інтерфейс та два персонажі."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:75
#, fuzzy
msgid "The scene tree, with the GUI scene set to display its children"
msgstr ""
"Дерево сцени із графічним інтерфейсом, призначеним для відображення його "
"нащадків"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:77
#, fuzzy
msgid ""
"The GUI scene encapsulates all of the game's Graphical User Interface. It "
"comes with a barebones script where we get the path to nodes that exist "
"inside the scene:"
msgstr ""
"Сцена GUI включає в себе весь графічний інтерфейс користувача гри. Вона "
"постачається із каркасом скрипту, де ми отримуємо шлях до вузлів, які "
"існують всередині сцени:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:105
#, fuzzy
msgid ""
"``number_label`` displays a life count as a number. It's a ``Label`` node"
msgstr ""
"``number_label`` відображає кількість здоров'я у вигляді числа. Це вузол "
"``Label``"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:107
#, fuzzy
msgid "``bar`` is the life bar itself. It's a ``TextureProgress`` node"
msgstr "``bar`` - це сама шкала здоров'я. Це вузол ``TextureProgress``"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:108
#, fuzzy
msgid ""
"``tween`` is a component-style node that can animate and control any value "
"or method from any other node"
msgstr ""
"``tween`` це вузол у стилі компонента, який може анімувати та керувати будь-"
"яким значенням, або методом, з будь-якого іншого вузла"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:113
#, fuzzy
msgid ""
"The project uses a simple organization that works for game jams and tiny "
"games."
msgstr ""
"Проект використовує просту організацію, яка підходить для невеликих ігор."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:115
#, fuzzy
msgid ""
"At the root of the project, in the `res://` folder, you will find the "
"`LevelMockup`. That's the main game scene and the one we will work with. All "
"the components that make up the game are in the `scenes/` folder. The "
"`assets/` folder contains the game sprites and the font for the HP counter. "
"In the `scripts/` folder you will find the enemy, the player, and the GUI "
"controller scripts."
msgstr ""
"У корені проекту, в теці ``res://`` ви знайдете ``LevelMockup``. Це головна "
"ігрова сцена і та, з якою ми будемо працювати. Усі компоненти, що складають "
"гру, знаходяться у теці ``scenes/``. Тека ``assets/`` містить ігрові спрайти "
"і шрифт для лічильника HP. У теці ``scripts/`` ви знайдете скрипти ворога, "
"гравця та контролера графічного інтерфейсу."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:117
#, fuzzy
msgid ""
"Click the edit scene icon to the right of the node in the scene tree to open "
"the scene in the editor. You'll see the LifeBar and EnergyBar are sub-scenes "
"themselves."
msgstr ""
"Клацніть піктограму редагування сцени праворуч від вузла в дереві сцени, щоб "
"відкрити сцену в редакторі. Ви побачите, що ``LifeBar`` та ``EnergyBar`` є "
"під-сценами."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:121
#, fuzzy
msgid "The scene tree, with the Player scene set to display its children"
msgstr ""
"Дерево сцени, зі сценою гравця, встановленою для відображення його нащадків"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:124
#, fuzzy
msgid "Set up the Lifebar with the Player's max\\_health"
msgstr ""
"Налаштування Lifebar (Шкали здоров'я) за допомогою max_health (Максимальне "
"здоров'я) Player"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:126
#, fuzzy
msgid ""
"We have to tell the GUI somehow what the player's current health is, to "
"update the lifebar's texture, and to display the remaining health in the HP "
"counter in the top left corner of the screen. To do this we send the "
"player's health to the GUI every time they take damage. The GUI will then "
"update the ``Lifebar`` and ``Number`` nodes with this value."
msgstr ""
"Ми мусимо якось сказати GUI, який у гравця поточний стан здоров'я, щоб "
"оновити текстуру шкали здоров'я та відобразити залишок здоров'я на "
"лічильнику HP у верхньому лівому куті екрана. Для цього ми надсилаємо "
"здоров'я гравця в графічний інтерфейс кожного разу, коли він отримує "
"пошкодження. Потім графічний інтерфейс оновить вузли ``Lifebar`` і "
"``Number`` відносно цього значення."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:132
#, fuzzy
msgid ""
"We could stop here to display the number, but we need to initialize the "
"bar's ``max_value`` for it to update in the right proportions. The first "
"step is thus to tell the ``GUI`` what the green character's ``max_health`` "
"is."
msgstr ""
"Ми могли б зупинитися на відображенні числа, але нам потрібно ініціалізувати "
"``max_value`` шкали для її оновлення в правильних пропорціях. Таким чином "
"перший крок - сказати ``GUI`` який ``max_health`` має зелений персонаж "
"(Гравець)."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:139
#, fuzzy
msgid ""
"The bar, a `TextureProgress`, has a `max_value` of `100` by default. If you "
"don't need to display the character's health with a number, you don't need "
"to change its `max_value` property. You send a percentage from the `Player` "
"to the `GUI` instead:  `health / max_health * 100`."
msgstr ""
"Шкала, `TextureProgress`, за замовчуванням має `max_value` `100`. Якщо вам "
"не потрібно відображати здоров'я персонажа цифрою, вам не потрібно змінювати "
"його властивість `max_value`. Замість цього ви надсилаєте відсоток від "
"`Player` до `GUI`: `health / max_health * 100`."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:143
#, fuzzy
msgid ""
"Click the script icon to the right of the ``GUI`` in the Scene dock to open "
"its script. In the ``_ready`` function, we're going to store the "
"``Player``'s ``max_health`` in a new variable and use it to set the "
"``bar``'s ``max_value``:"
msgstr ""
"Клацніть піктограму скрипта праворуч від ``GUI`` на панелі Сцена, щоб "
"відкрити його скрипт. У функції ``_ready``, ми будемо зберігати "
"``max_health`` нашого ``Player`` в новій змінній і використовувати її, щоб "
"встановити ``max_value`` ``bar``:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:164
#, fuzzy
msgid ""
"Let's break it down. ``$\"../Characters/Player\"`` is a shorthand that goes "
"one node up in the scene tree, and retrieves the ``Characters/Player`` node "
"from there. It gives us access to the node. The second part of the "
"statement, ``.max_health``, accesses the ``max_health`` on the Player node."
msgstr ""
"Давайте розберемося. ``$\"../Characters/Player\"`` це скорочення, яке "
"піднімається на один вузол вище по дереві сцени і виймає звідти вузол "
"``Characters/Player``. Це дає нам доступ до вузла. Друга частина, ``."
"max_health``, дає доступ до вузла гравця ``max_health``."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:170
#, fuzzy
msgid ""
"The second line assigns this value to ``bar.max_value``. You could combine "
"the two lines into one, but we'll need to use ``player_max_health`` again "
"later in the tutorial."
msgstr ""
"Другий рядок присвоює це значення ``bar.max_value``. Ви можете поєднати два "
"рядки в один, але нам потрібно буде скористатися ``player_max_health`` знову "
"далі в уроці."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:174
#, fuzzy
msgid ""
"``Player.gd`` sets the ``health`` to ``max_health`` at the start of the "
"game, so we could work with this. Why do we still use ``max_health``? There "
"are two reasons:"
msgstr ""
"``Player.gd`` встановлює ``health`` в ``max_health`` на початку гри, так що "
"ми могли б працювати з ним. Чому ми використовуємо ``max_health``? Є дві "
"причини:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:178
#, fuzzy
msgid ""
"We don't have the guarantee that ``health`` will always equal "
"``max_health``: a future version of the game may load a level where the "
"player already lost some health."
msgstr ""
"У нас немає гарантії, що ``health`` завжди буде рівною ``max_health``: "
"майбутня версія гри може завантажити рівень, в якому гравець вже втратив "
"певну кількість здоров'я."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:184
#, fuzzy
msgid ""
"When you open a scene in the game, Godot creates nodes one by one, following "
"the order in your Scene dock, from top to bottom. `GUI` and `Player` are not "
"part of the same node branch. To make sure they both exist when we access "
"each other, we have to use the `_ready` function. Godot calls `_ready` right "
"after it loaded all nodes, before the game starts. It's the perfect function "
"to set everything up and prepare the game session. Learn more about _ready: :"
"doc:`scripting_continued`"
msgstr ""
"Коли ви відкриваєте сцену в грі, Godot створює вузли по черзі, дотримуючись "
"порядку їх розміщення в Сцені, зверху вниз. `GUI` та `Player` не є частиною "
"однієї гілки вузла. Щоб переконатися, що вони обидва існують, коли ми "
"отримуємо доступ до них, ми повинні використовувати функцію `_ready`. Godot "
"викличе `_ready` вже після завантаження всіх вузлів, перед початком гри. Це "
"ідеальна функція налаштувати все і підготувати ігрову сесію. Дізнайтеся "
"більше про _ready: :doc:`scripting_continued`"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:188
#, fuzzy
msgid "Update health with a signal when the player takes a hit"
msgstr "Оновлення здоров'я з допомогою сигнала, коли гравець отримує удар"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:190
#, fuzzy
msgid ""
"Our GUI is ready to receive the ``health`` value updates from the "
"``Player``. To achieve this we're going to use **signals**."
msgstr ""
"Наш графічний інтерфейс готовий отримувати оновлення значень ``health`` від "
"``Player``. Для цього ми будемо використовувати **сигнали**."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:195
#, fuzzy
msgid ""
"There are many useful built-in signals like `enter_tree` and `exit_tree`, "
"that all nodes emit when they are respectively created and destroyed. You "
"can also create your own using the `signal` keyword. On the `Player` node, "
"you'll find two signals we created for you: `died` and `health_changed`."
msgstr ""
"Існує багато корисних вбудованих сигналів, таких як `enter_tree` та "
"`exit_tree`, які випромінюють всі вузли, коли вони, відповідно, створюються "
"та знищуються. Ви також можете створити власний сигнал за допомогою "
"ключового слова `signal`. На вузлі `Player` ви знайдете два сигнали, які ми "
"створили для вас: `died` (помер) і `health_changed` (зміна здоров'я)."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:197
#, fuzzy
msgid ""
"Why don't we directly get the ``Player`` node in the ``_process`` function "
"and look at the health value? Accessing nodes this way creates tight "
"coupling between them. If you did it sparingly it may work. As your game "
"grows bigger, you may have many more connections. If you get nodes this way "
"it gets complex quickly. Not only that: you need to listen to the state "
"change constantly in the ``_process`` function. This check happens 60 times "
"a second and you'll likely break the game because of the order in which the "
"code runs."
msgstr ""
"Чому ми не отримуємо безпосередньо вузол ``Player`` у функції ``_process`` "
"та не дивимось на значення здоров'я? Доступ до вузлів таким чином створює "
"щільне з'єднання між ними. Якщо ви зробите це економно, це може спрацювати. "
"Але по мірі збільшення вашої гри у вас може ставати все більше зв'язків. "
"Якщо ви отримуєте вузли таким чином, ваші зв'язки швидко стануть "
"заплутаними. Більше того: вам потрібно постійно відстежувати зміни стану у "
"функції ``_process``. Ця перевірка відбувається 60 разів на секунду, і ви, "
"швидше за все, погіршите гру через порядок виконання коду."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:206
#, fuzzy
msgid ""
"On a given frame you may look at another node's property *before* it was "
"updated: you get a value from the last frame. This leads to obscure bugs "
"that are hard to fix. On the other hand, a signal is emitted right after a "
"change happened. It **guarantees** you're getting a fresh piece of "
"information. And you will update the state of your connected node *right "
"after* the change happened."
msgstr ""
"У заданому кадрі ви можете переглянути властивість іншого вузла *до* його "
"оновлення: ви отримаєте значення з останнього кадру. Це призводить до "
"незрозумілих помилок, які важко виправити. З іншого боку, сигнал "
"випромінюється відразу після того, як відбулася зміна. Це **гарантує** "
"отримання нової інформації. І ви оновите стан підключеного вузла відразу "
"*після* того, як зміни відбулися."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:215
#, fuzzy
msgid ""
"The Observer pattern, that signals derive from, still adds a bit of coupling "
"between node branches. But it's generally lighter and more secure than "
"accessing nodes directly to communicate between two separate classes. It can "
"be okay for a parent node to get values from its children. But you'll want "
"to favor signals if you're working with two separate branches. Read Game "
"Programming Patterns for more information on the `Observer pattern <https://"
"gameprogrammingpatterns.com/observer.html>`_. The `full book <https://"
"gameprogrammingpatterns.com/contents.html>`_ is available online for free."
msgstr ""
"Шаблон спостерігача, від якого походить сигнали, все ще додає трохи зв'язки "
"між гілками вузлів. Але це зазвичай легше і безпечніше, ніж отримати доступ "
"до вузлів безпосередньо для спілкування між двома окремими класами. Для "
"батьківського вузла може бути нормально отримати значення від його нащадків. "
"Але вам краще віддати перевагу сигналам, якщо ви працюєте з двома окремими "
"гілками. Прочитайте шаблони програмування ігор для отримання додаткової "
"інформації `Observer pattern <http://gameprogrammingpatterns.com/observer."
"html>`_. Повна книга <http://gameprogrammingpatterns.com/contents.html>`_ "
"доступна в Інтернеті безкоштовно."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:219
#, fuzzy
msgid ""
"With this in mind, let's connect the ``GUI`` to the ``Player``. Click on the "
"``Player`` node in the scene dock to select it. Head down to the Inspector "
"and click on the Node tab. This is the place to connect nodes to listen to "
"the one you selected."
msgstr ""
"Зважаючи на це, давайте підключимо ``GUI`` до ``Player``. Клацніть на вузлі "
"``Player`` в сцені, щоб вибрати його. Перейдіть до Інспектора та натисніть "
"на вкладку Вузол. Це місце де підключаються вузли для прослуховування "
"обраного вами."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:224
msgid "The first section lists custom signals defined in ``Player.gd``:"
msgstr ""
"У першому розділі перелічені спеціальні сигнали, визначені у ``Player.gd``:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:226
#, fuzzy
msgid ""
"``died`` is emitted when the character died. We will use it in a moment to "
"hide the UI."
msgstr ""
"``died`` випромінюється, коли персонаж помер. Ми скористаємося ним, щоб "
"приховати інтерфейс користувача."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:228
#, fuzzy
msgid "``health_changed`` is emitted when the character got hit."
msgstr "``health_changed`` випромінюється, коли персонаж отримує удар."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:232
#, fuzzy
msgid "We're connecting to the health\\_changed signal"
msgstr "Ми підключаємось до сигналу health\\_changed"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:234
#, fuzzy
msgid ""
"Select ``health_changed`` and click on the Connect button in the bottom "
"right corner to open the Connect Signal window. On the left side you can "
"pick the node that will listen to this signal. Select the ``GUI`` node. The "
"right side of the screen lets you pack optional values with the signal. We "
"already took care of it in ``Player.gd``. In general I recommend not to add "
"too many arguments using this window as they're less convenient than doing "
"it from the code."
msgstr ""
"Виберіть ``health_changed`` і натисніть кнопку Приєднати в правому нижньому "
"куті, щоб відкрити вікно З'єднання сигналу з методом. Ліворуч ви можете "
"вибрати вузол, який буде прослуховувати цей сигнал. Виберіть вузол ``GUI``. "
"Права частина екрана дозволяє упакувати додаткові значення за допомогою "
"сигналу. Про це ми вже подбали в ``Player.gd``. Як правило, я рекомендую не "
"додавати занадто багато аргументів, використовуючи це вікно, оскільки це "
"менш зручно, ніж з коду."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:244
#, fuzzy
msgid "The Connect Signal window with the GUI node selected"
msgstr "Вікно З'єднання сигналу з обраним вузлом GUI"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:248
msgid ""
"You can optionally connect nodes from the code. However doing it from the "
"editor has two advantages:"
msgstr ""
"Ви можете з'єднати вузли з коду. Однак підключення з редактора має дві "
"переваги:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:250
#, fuzzy
msgid "Godot can write new callback functions for you in the connected script"
msgstr ""
"Godot може записати нові функції зворотного виклику для вас у підключеному "
"скрипті"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:251
#, fuzzy
msgid ""
"An emitter icon appears next to the node that emits the signal in the Scene "
"dock"
msgstr ""
"На панелі Сцена поруч із вузлом, який випромінює сигнал, з’являється "
"піктограма випромінювача"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:253
#, fuzzy
msgid ""
"At the bottom of the window you will find the path to the node you selected. "
"We're interested in the second row called \"Method in Node\". This is the "
"method on the ``GUI`` node that gets called when the signal is emitted. This "
"method receives the values sent with the signal and lets you process them. "
"If you look to the right, there is a \"Make Function\" radio button that is "
"on by default. Click the connect button at the bottom of the window. Godot "
"creates the method inside the ``GUI`` node. The script editor opens with the "
"cursor inside a new ``_on_Player_health_changed`` function."
msgstr ""
"У нижній частині вікна ви знайдете шлях до обраного вами вузла. Нас цікавить "
"другий ряд під назвою \"Метод у вузлі\". Це метод на вузлі ``GUI``, який "
"викликається, коли сигнал випромінюється. Цей метод отримує значення, "
"надіслані разом із сигналом, і дозволяє обробити їх. (Якщо ви подивитеся "
"праворуч, є перемикач \"Зробити функцію\", який за замовчуванням увімкнено. "
"((Нема в версії Godot 3.2))) Клацніть кнопку З'єднати в нижній частині "
"вікна. Godot створює метод всередині вузла ``GUI``. Одразу відкривається "
"редактор скриптів з курсором всередині нової функції "
"``_on_Player_health_changed``."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:265
#, fuzzy
msgid ""
"When you connect nodes from the editor, Godot generates a method name with "
"the following pattern: ``_on_EmitterName_signal_name``. If you wrote the "
"method already, the \"Make Function\" option will keep it. You may replace "
"the name with anything you'd like."
msgstr ""
"При підключенні вузлів з редактора, Godot генерує ім'я методу по такій "
"схемі: ``_on_НазваВипромінювача_назва_сигнала``. Якщо ви вже написали метод, "
"параметр «Зробити функцію» збереже його. Ви можете замінити ім'я на інше."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:272
#, fuzzy
msgid "Godot writes the callback method for you and takes you to it"
msgstr "Godot пише для вас метод зворотного виклику і дає його вам"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:274
msgid ""
"Inside the parentheses after the function name, add a ``player_health`` "
"argument. When the player emits the ``health_changed`` signal, it will send "
"its current ``health`` alongside it. Your code should look like:"
msgstr ""
"Всередині дужок після назви функції додайте аргумент ``player_health``. Коли "
"гравець випромінює сигнал ``health_changed``, він надсилатиме разом із ним "
"поточний ``health``. Ваш код повинен виглядати так:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:292
msgid ""
"The engine does not convert PascalCase to snake_case, for C# examples we'll "
"be using PascalCase for method names & camelCase for method parameters, "
"which follows the official `C# naming conventions. <https://docs.microsoft."
"com/en-us/dotnet/standard/design-guidelines/capitalization-conventions>`_"
msgstr ""
"Движок не перетворює PascalCase в snake_case, для прикладів C# ми будемо "
"використовувати PascalCase для імен методів, і camelCase для параметрів "
"методу, дотримуючись таким чином офіційних `умов іменування в C#. <https://"
"docs.microsoft.com/en-us/dotnet/standard/design-guidelines/capitalization-"
"conventions>`_"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:299
msgid ""
"In Player.gd, when the Player emits the health\\_changed signal, it also "
"sends its health value"
msgstr ""
"У Player.gd, коли Player випромінює сигнал health\\_changed, він також "
"надсилає значення його здоров'я"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:302
msgid ""
"Inside ``_on_Player_health_changed``, let's call a second function called "
"``update_health`` and pass it the ``player_health`` variable."
msgstr ""
"Всередині ``_on_Player_health_changed`` викличемо другу функцію під назвою "
"``update_health`` і передамо їй змінну ``player_health``."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:307
msgid ""
"We could directly update the health value on `LifeBar` and `Number`. There "
"are two reasons to use this method instead:"
msgstr ""
"Ми могли б безпосередньо оновити значення здоров’я на `LifeBar` та `Number`. "
"Існує дві причини використовувати цей метод:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:309
msgid ""
"The name makes it clear for our future selves and teammates that when the "
"player took damage, we update the health count on the GUI"
msgstr ""
"Назва дає зрозуміти нашим майбутнім колегам та товаришам по команді, що коли "
"гравець отримав пошкодження, ми оновлюємо стан здоров'я на графічному "
"інтерфейсі"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:310
msgid "We will reuse this method a bit later"
msgstr "Ми використаємо цей метод трохи пізніше"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:312
msgid ""
"Create a new ``update_health`` method below ``_on_Player_health_changed``. "
"It takes a new\\_value as its only argument:"
msgstr ""
"Створіть новий ``update_health`` метод нижче ``_on_Player_health_changed``. "
"Він приймає new\\_value в якості єдиного аргумента:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:327
msgid "This method needs to:"
msgstr "Цей метод буде:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:329
msgid ""
"set the ``Number`` node's ``text`` to ``new_value`` converted to a string"
msgstr ""
"встановлювати ``text`` вузла ``Number`` на ``new_value`` конвертоване в текст"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:331
msgid "set the ``TextureProgress``'s ``value`` to ``new_value``"
msgstr "встановлювати ``value`` в ``TextureProgress`` на ``new_value``"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:350
msgid ""
"``str`` is a built-in function that converts about any value to text. "
"``Number``'s ``text`` property requires a string, so we can't assign it to "
"``new_value`` directly"
msgstr ""
"``str`` це вбудована функція, яка перетворює будь-яке значення в текст. "
"Властивості ``text`` у ``Number``потрібний текст, тому ми не можемо "
"призначити їй ``new_value`` безпосередньо"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:354
msgid ""
"Also call ``update_health`` at the end of the ``_ready`` function to "
"initialize the ``Number`` node's ``text`` with the right value at the start "
"of the game. Press :kbd:`F5` to test the game: the life bar updates with "
"every attack!"
msgstr ""
"Також викличте ``update_health`` в кінці функції ``_ready``, щоб "
"ініціалізувати ``text`` вузла ``Number`` з правильним значенням на початку "
"гри. Натисніть :kbd:`F5`, щоб перевірити гру: шкала здоров'я оновлюється з "
"кожною атакою!"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:361
msgid ""
"Both the Number node and the TextureProgress update when the Player takes a "
"hit"
msgstr "І Number, і TextureProgress оновлюються коли Player отримує удар"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:365
msgid "Animate the loss of life with the Tween node"
msgstr "Анімація втрати здоров'я за допомогою вузла Tween"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:367
msgid ""
"Our interface is functional, but it could use some animation. That's a good "
"opportunity to introduce the ``Tween`` node, an essential tool to animate "
"properties. ``Tween`` animates anything you'd like from a start to an end "
"state over a certain duration. For example, it can animate the health on the "
"``TextureProgress`` from its current level to the ``Player``'s new "
"``health`` when the character takes damage."
msgstr ""
"Наш інтерфейс функціональний, але він може використовувати деяку анімацію. "
"Це хороша можливість познайомитися з вузлом ``Tween``, важливим інструментом "
"для анімації властивостей. ``Tween`` анімує все, що завгодно, від початку до "
"кінця, протягом певної тривалості. Наприклад, він може анімувати здоров'я "
"``TextureProgress`` від поточного до нового значення ``health`` пошкодженого "
"``Player``."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:374
msgid ""
"The ``GUI`` scene already contains a ``Tween`` child node stored in the "
"``tween`` variable. Let's now use it. We have to make some changes to "
"``update_health``."
msgstr ""
"Сцена ``GUI`` вже містить вузол ``Tween``, який було збережено в змінній "
"``tween``. Давайте зараз скористаємося цим. Ми повинні внести деякі зміни в "
"``update_health``."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:378
msgid ""
"We will use the ``Tween`` node's ``interpolate_property`` method. It takes "
"seven arguments:"
msgstr ""
"Ми будемо використовувати метод вузла ``Tween`` ``interpolate_property``. "
"Він бере сім аргументів:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:381
msgid "A reference to the node who owns the property to animate"
msgstr "Посилання на вузол, властивість якого належить анімувати"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:382
msgid "The property's identifier as a string"
msgstr "Ідентифікатор властивості в виді тексту"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:383
msgid "The starting value"
msgstr "Вихідне значення"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:384
msgid "The end value"
msgstr "Кінцеве значення"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:385
msgid "The animation's duration in seconds"
msgstr "Тривалість анімації в секундах"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:386
msgid "The type of the transition"
msgstr "Тип переходу"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:387
msgid "The easing to use in combination with the equation."
msgstr "Послаблення для використання в поєднанні з рівнянням."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:389
msgid ""
"The last two arguments combined correspond to an easing equation. This "
"controls how the value evolves from the start to the end point."
msgstr ""
"Останні два аргументи в поєднані являють собою спрощену рівність. Вони "
"контролюють, як значення змінюється від початку до кінця."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:393
msgid ""
"Click the script icon next to the ``GUI`` node to open it again. The "
"``Number`` node needs text to update itself, and the ``Bar`` needs a float "
"or an integer. We can use ``interpolate_property`` to animate a number, but "
"not to animate text directly. We're going to use it to animate a new ``GUI`` "
"variable named ``animated_health``."
msgstr ""
"Клацніть піктограму скрипту поруч із вузлом ``GUI``, щоб відкрити його "
"знову. Вузол ``Number`` потребує тексту, щоб оновитися, а ``Bar`` потребує "
"десяткового, або цілого числа. Ми можемо використовувати "
"``interpolate_property`` для анімації числа, але не для тексту напряму. Ми "
"будемо використовувати його для анімації нової змінної ``GUI`` під назвою "
"``animated_health``."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:399
msgid ""
"At the top of the script, define a new variable, name it "
"``animated_health``, and set its value to 0. Navigate back to the "
"``update_health`` method and clear its content. Let's animate the "
"``animated_health`` value. Call the ``Tween`` node's "
"``interpolate_property`` method:"
msgstr ""
"У верхній частині скрипту визначте нову змінну, назвіть її "
"``animated_health`` та встановіть її значення на 0. Поверніться назад до "
"методу ``update_health`` та очистіть його вміст. Давайте анімуємо значення "
"``animated_health``. Викличте метод ``interpolate_property`` вузла ``Tween``:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:421
msgid "Let's break down the call:"
msgstr "Давайте розберемо цей виклик:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:427
msgid ""
"We target ``animated_health`` on ``self``, that is to say the ``GUI`` node. "
"``Tween``'s interpolate\\_property takes the property's name as a string. "
"That's why we write it as ``\"animated_health\"``."
msgstr ""
"Ми націлюємося на ``animated_health`` у ``self``, тобто в вузлі ``GUI``. "
"``interpolate_property`` вузла ``Tween`` приймає ім'я властивості у вигляді "
"тексту. Ось чому ми пишемо ``\"animated_health\"``."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:435
msgid ""
"The starting point is the current value the bar's at. We still have to code "
"this part, but it's going to be ``animated_health``. The end point of the "
"animation is the ``Player``'s ``health`` after the ``health_changed``: "
"that's ``new_value``. And ``0.6`` is the animation's duration in seconds."
msgstr ""
"Початковою точкою є поточне значення шкали. Нам ще належить кодувати цю "
"частину, але це буде ``animated_health``. Кінцевою точкою анімації є "
"``health`` ``Player`` (життя гравця) після ``health_changed`` (зміни_життя): "
"це ``new_value``. І ``0.6`` це тривалість анімації в секундах."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:441
msgid ""
"The animation will not play until we activated the ``Tween`` node with "
"``tween.start()``. We only have to do this once if the node is not active. "
"Add this code after the last line:"
msgstr ""
"Анімація не буде відтворюватися, поки ми не активуємо вузол ``Tween``з "
"допомогою ``tween.start()``. Це потрібно зробити лише один раз, якщо вузол "
"не активний. Додайте цей код після останнього рядка:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:460
msgid ""
"Although we could animate the `health` property on the `Player`, we "
"shouldn't. Characters should lose life instantly when they get hit. It makes "
"it a lot easier to manage their state, like to know when one died. You "
"always want to store animations in a separate data container or node. The "
"`tween` node is perfect for code-controlled animations. For hand-made "
"animations, check out `AnimationPlayer`."
msgstr ""
"Хоча ми могли б анімувати властивість `health` (здоров'я) на `Player` "
"(гравцеві), ми не повинні цього робити. Персонажі повинні втрачати життя "
"миттєво при попаданні під удар. Це набагато спрощує керування їх станами. "
"Вам завжди краще зберігати анімацію в окремому контейнері даних, або вузлі. "
"Вузол `tween` ідеально підходить для коду контролювання анімації. Для "
"анімації ручної роботи перегляньте `AnimationPlayer`."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:463
msgid "Assign the animated\\_health to the LifeBar"
msgstr "Призначення animated\\_health LifeBar"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:465
msgid ""
"Now the ``animated_health`` variable animates but we don't update the actual "
"``Bar`` and ``Number`` nodes anymore. Let's fix this."
msgstr ""
"Тепер змінна ``animated_health`` анімована, але ми більше не оновлюємо вузли "
"``Bar`` та ``Number``. Давайте виправимо це."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:468
msgid "So far, the update\\_health method looks like this:"
msgstr "Поки що метод ``update_health`` виглядає приблизно так:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:492
msgid ""
"In this specific case, because ``number_label`` takes text, we need to use "
"the ``_process`` method to animate it. Let's now update the ``Number`` and "
"``TextureProgress`` nodes like before, inside of ``_process``:"
msgstr ""
"У цьому конкретному випадку, оскільки ``number_label`` бере текст, нам "
"потрібно використовувати метод ``_process`` для її анімації. Тепер оновимо "
"вузли ``Number`` і ``TextureProgress``, як і раніше, але всередині "
"``_process``:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:514
msgid ""
"`number_label` and `bar` are variables that store references to the `Number` "
"and `TextureProgress` nodes."
msgstr ""
"`number_label` та `bar` - це змінні, які зберігають посилання на вузли "
"`Number` та `TextureProgress`."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:516
msgid ""
"Play the game to see the bar animate smoothly. But the text displays decimal "
"number and looks like a mess. And considering the style of the game, it'd be "
"nice for the life bar to animate in a choppier fashion."
msgstr ""
"Запустіть гру, щоб бачити анімацію шкали. Але в тексті відображається "
"десяткове число і це схоже на безлад. А зважаючи на стиль гри, було б "
"непогано, щоб шкала здоров'я анімувалася поривчастим способом."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:522
msgid "The animation is smooth, but the number is broken"
msgstr "Гладка анімація, проте недоладне число"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:524
msgid ""
"We can fix both problems by rounding out ``animated_health``. Use a local "
"variable named ``round_value`` to store the rounded ``animated_health``. "
"Then assign it to ``number_label.text`` and ``bar.value``:"
msgstr ""
"Ми можемо виправити обидві проблеми шляхом заокруглення ``animated_health``. "
"Використовуйте локальну змінну з назвою ``round_value`` для зберігання "
"заокругленого значення ``animated_health``. Потім призначте значення "
"``number_label.text`` та ``bar.value``:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:546
msgid "Try the game again to see a nice blocky animation."
msgstr "Спробуйте гру ще раз, щоб побачити приємну анімацію."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:550
msgid "By rounding out animated\\_health, we kill two birds with one stone"
msgstr "Заокруглюючи animated_health ми вбиваємо двох зайців одним пострілом"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:554
msgid ""
"Every time the player takes a hit, the ``GUI`` calls "
"``_on_Player_health_changed``, which in turn calls ``update_health``. This "
"updates the animation and the ``number_label`` and ``bar`` follow in "
"``_process``. The animated life bar that shows the health going down "
"gradually is a trick. It makes the GUI feel alive. If the ``Player`` takes 3 "
"damage, it happens in an instant."
msgstr ""
"Кожен раз, коли гравець приймає удар, ``GUI`` викликає "
"``_on_Player_health_changed``, який в свою чергу викликає ``update_health``. "
"Це послідовно оновлює анімацію ``number_label`` та ``bar`` в ``_process``. "
"Анімація шкали життя, яка показує, що здоров'я поступово знижується, є "
"хитрістю. Це оживляє GUI. Якщо ``Player`` отримує 3 пошкодження, гравець "
"помирає, а шкала стає порожня."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:562
msgid "Fade the bar when the Player dies"
msgstr "Зникнення шкали при смерті гравця"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:564
msgid ""
"When the green character dies, it plays a death animation and fades out. At "
"this point, we shouldn't show the interface anymore. Let's fade the bar as "
"well when the character died. We will reuse the same ``Tween`` node as it "
"manages multiple animations in parallel for us."
msgstr ""
"Коли зелений персонаж вмирає, він відтворює анімацію смерті і згасає. На "
"даний момент нам більше не треба показувати інтерфейс. Давайте, при смерті "
"персонажа, шкалу також сховаємо. Ми повторно використаємо той самий вузол "
"``Tween``, який паралельно управляє декількома анімаціями."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:569
msgid ""
"First, the ``GUI`` needs to connect to the ``Player``'s ``died`` signal to "
"know when it died. Press :kbd:`F1` to jump back to the 2D Workspace. Select "
"the ``Player`` node in the Scene dock and click on the Node tab next to the "
"Inspector."
msgstr ""
"Спершу, ``GUI`` необхідно підключитися до сигналу ``Player`` ``died``, щоб "
"знати, коли він помер. Натисніть :kbd:`F1` щоб повернутися до робочої "
"області 2D. Виберіть вузол ``Player`` на панелі Сцена та натисніть на "
"вкладку Вузол біля Інспектора."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:574
msgid "Find the ``died`` signal, select it, and click the Connect button."
msgstr "Знайдіть сигнал ``died``, виберіть його та натисніть кнопку Приєднати."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:578
msgid "The signal should already have the Enemy connected to it"
msgstr "Сигнал вже має бути підключеним до Enemy"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:580
msgid ""
"In the Connecting Signal window, connect to the ``GUI`` node again. The Path "
"to Node should be ``../../GUI`` and the Method in Node should show "
"``_on_Player_died``. Leave the Make Function option on and click Connect at "
"the bottom of the window. This will take you to the ``GUI.gd`` file in the "
"Script Workspace."
msgstr ""
"У вікні З'єднання сигналу знову підключіться до вузла ``GUI``. В полі Метод-"
"отримувач має бути ``_on_Player_died``. Натисніть «З'єднати» внизу вікна. Це "
"перенесе вас до файлу ``GUI.gd`` в робочій області скриптів."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:588
msgid "You should get these values in the Connecting Signal window"
msgstr "Ви повинні отримати такі значення у вікні З'єднання сигналу"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:592
msgid ""
"You should see a pattern by now: every time the GUI needs a new piece of "
"information, we emit a new signal. Use them wisely: the more connections you "
"add, the harder they are to track."
msgstr ""
"Ви вже повинні простежити схему: щоразу, коли GUI потребує нової інформації, "
"ми випромінюємо новий сигнал. Використовуйте їх розумно: чим більше ви "
"додасте з'єднань, тим важче буде відстежувати їх."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:594
msgid ""
"To animate a fade on a UI element, we have to use its ``modulate`` property. "
"``modulate`` is a ``Color`` that multiplies the colors of our textures."
msgstr ""
"Щоб анімувати зникнення елемента інтерфейсу, ми повинні використовувати його "
"властивість ``modulate``. ``modulate`` це ``Color``, який множить кольори "
"наших текстур."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:600
msgid ""
"`modulate` comes from the `CanvasItem` class, All 2D and UI nodes inherit "
"from it. It lets you toggle the visibility of the node, assign a shader to "
"it, and modify it using a color with `modulate`."
msgstr ""
"`modulate` походить від класу `CanvasItem`, від нього успадковуються всі 2D "
"та UI-вузли. Він дозволяє перемикати видимість вузла, призначати йому шейдер "
"і змінювати його за допомогою кольору `modulate`."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:602
msgid ""
"``modulate`` takes a ``Color`` value with 4 channels: red, green, blue and "
"alpha. If we darken any of the first three channels it darkens the "
"interface. If we lower the alpha channel, our interface fades out."
msgstr ""
"``modulate`` приймає значення ``Color`` з 4-ох каналів: червоний, зелений, "
"синій та альфа. Якщо затемнити будь-який з перших трьох каналів, він "
"затемнить інтерфейс. Якщо ми знизимо альфа-канал, наш інтерфейс стане "
"прозорим."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:606
msgid ""
"We're going to tween between two color values: from a white with an alpha of "
"``1``, that is to say at full opacity, to a pure white with an alpha value "
"of ``0``, completely transparent. Let's add two variables at the top of the "
"``_on_Player_died`` method and name them ``start_color`` and ``end_color``. "
"Use the ``Color()`` constructor to build two ``Color`` values."
msgstr ""
"Ми збираємось анімувати значення кольорів: від білого з альфа ``1``, тобто з "
"повною непрозорістю, до чисто білого із значенням альфа ``0``, повною "
"прозорістю. Додамо дві змінні у верхній частині методу ``_on_Player_died`` "
"та назвемо їх ``start_color`` та ``end_color``. Використовуйте конструктор "
"``Color()`` для побудови двох значень ``Color``."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:628
msgid ""
"``Color(1.0, 1.0, 1.0)`` corresponds to white. The fourth argument, "
"respectively ``1.0`` and ``0.0`` in ``start_color`` and ``end_color``, is "
"the alpha channel."
msgstr ""
"``Color(1.0, 1.0, 1.0)`` відповідає білому. Четвертим аргументом, відповідно "
"``1.0`` і ``0.0`` в ``start_color`` і ``end_color``, є альфа-канал."

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:632
msgid ""
"We then have to call the ``interpolate_property`` method of the ``Tween`` "
"node again:"
msgstr ""
"Потім нам доведеться знову викликати метод ``interpolate_property`` вузла "
"``Tween``:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:645
msgid ""
"This time, we change the ``modulate`` property and have it animate from "
"``start_color`` to the ``end_color``. The duration is of one second, with a "
"linear transition. Here's the complete ``_on_Player_died`` method:"
msgstr ""
"Цього разу ми змінимо властивість ``modulate`` і попросимо її анімувати з "
"``start_color`` до ``end_color``. Тривалість становить одну секунду, з "
"лінійним переходом. Знову ж таки, оскільки перехід лінійний, плавність "
"значення не має. Ось повний метод ``_on_Player_died``:"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:669
msgid "And that is it. You may now play the game to see the final result!"
msgstr ""
"І це все. Тепер ви можете запустити гру, щоб побачити кінцевий результат!"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:673
msgid "The final result. Congratulations for getting there!"
msgstr "Кінцевий результат. Вітаємо з успіхом!"

#: ../../docs/getting_started/step_by_step/ui_code_a_life_bar.rst:677
msgid ""
"Using the exact same techniques, you can change the color of the bar when "
"the Player gets poisoned, turn the bar red when its health drops low, shake "
"the UI when they take a critical hit... the principle is the same: emit a "
"signal to forward the information from the `Player` to the `GUI` and let the "
"`GUI` process it."
msgstr ""
"Використовуючи ті самі методи, ви можете змінити колір шкали, коли гравець "
"отруїться, перетворити шкалу на червону, коли його здоров'я знизиться, "
"стрясти інтерфейс користувача, коли він отримує критичний удар ... принцип "
"однаковий: випромінюйте сигнал, щоб переслати інформацію від гравця до "
"графічного інтерфейсу та дозволити інтерфейсу обробити його."
