# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2021, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-07-13 14:01+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../docs/getting_started/workflow/best_practices/godot_interfaces.rst:4
msgid "Godot interfaces"
msgstr "Інтерфейси Godot"

#: ../../docs/getting_started/workflow/best_practices/godot_interfaces.rst:6
msgid ""
"Often one needs scripts that rely on other objects for features. There are 2 "
"parts to this process:"
msgstr ""
"Часто потрібні скрипти, які покладаються на інші об'єкти для функцій. Цей "
"процес має 2 частини:"

#: ../../docs/getting_started/workflow/best_practices/godot_interfaces.rst:9
msgid "Acquiring a reference to the object that presumably has the features."
msgstr "Отримання посилання на об’єкт, який, імовірно, має особливості."

#: ../../docs/getting_started/workflow/best_practices/godot_interfaces.rst:11
msgid "Accessing the data or logic from the object."
msgstr "Доступ до даних або логіки від об’єкта."

#: ../../docs/getting_started/workflow/best_practices/godot_interfaces.rst:13
msgid "The rest of this tutorial outlines the various ways of doing all this."
msgstr "Решта цього посібника описує різні способи зробити все це."

#: ../../docs/getting_started/workflow/best_practices/godot_interfaces.rst:16
msgid "Acquiring object references"
msgstr "Отримання посилань на об’єкти"

#: ../../docs/getting_started/workflow/best_practices/godot_interfaces.rst:18
msgid ""
"For all :ref:`Object <class_Object>`\\s, the most basic way of referencing "
"them is to get a reference to an existing object from another acquired "
"instance."
msgstr ""
"Для всіх :ref:`Об'єктів <class_Object>` основним способом посилання на них, "
"є отримання посилання на існуючий об’єкт з іншого придбаного екземпляра."

#: ../../docs/getting_started/workflow/best_practices/godot_interfaces.rst:32
msgid ""
"The same principle applies for :ref:`Reference <class_Reference>` objects. "
"While users often access :ref:`Node <class_Node>` and :ref:`Resource "
"<class_Resource>` this way, alternative measures are available."
msgstr ""
"Той самий принцип застосовується до :ref:`Посилань <class_Reference>`. Таким "
"же чином користувачі часто отримують доступ до :ref:`Вузлів <class_Node>` "
"та :ref:`Ресурсів <class_Resource>`, але доступні альтернативні способи."

#: ../../docs/getting_started/workflow/best_practices/godot_interfaces.rst:36
msgid ""
"Instead of property or method access, one can get Resources by load access."
msgstr ""
"Замість доступу до властивостей або методів можна отримати Ресурси за "
"допомогою доступу до завантаження."

#: ../../docs/getting_started/workflow/best_practices/godot_interfaces.rst:115
msgid "Note the following:"
msgstr "Пам'ятайте наступне:"

#: ../../docs/getting_started/workflow/best_practices/godot_interfaces.rst:117
msgid "There are many ways in which a language can load such resources."
msgstr "Існує багато способів, якими мова може завантажити такі ресурси."

#: ../../docs/getting_started/workflow/best_practices/godot_interfaces.rst:119
msgid ""
"When designing how objects will access data, don't forget that one can pass "
"resources around as references as well."
msgstr ""
"Розробляючи спосіб доступу об'єктів до даних, не забувайте, що можна "
"передавати ресурси як посилання."

#: ../../docs/getting_started/workflow/best_practices/godot_interfaces.rst:122
msgid ""
"Keep in mind that loading a resource fetches the cached resource instance "
"maintained by the engine. To get a new object, one must :ref:`duplicate "
"<class_Resource_method_duplicate>` an existing reference or instantiate one "
"from scratch with ``new()``."
msgstr ""
"Майте на увазі, що завантаження ресурсу отримує кешований екземпляр ресурсу, "
"який підтримує движок. Щоб отримати новий об'єкт, потрібно :ref:"
"`продублювати<class_Resource_method_duplicate>` існуюче посилання або "
"створити його з нуля з допомогою ``new()``."

#: ../../docs/getting_started/workflow/best_practices/godot_interfaces.rst:127
msgid "Nodes likewise have an alternative access point: the SceneTree."
msgstr "Вузли також мають альтернативну точку доступу: Дерево Сцен."

#: ../../docs/getting_started/workflow/best_practices/godot_interfaces.rst:245
msgid "Accessing data or logic from an object"
msgstr "Доступ до даних або логіки від об’єкта"

#: ../../docs/getting_started/workflow/best_practices/godot_interfaces.rst:247
msgid ""
"Godot's scripting API is duck-typed. This means that if a script executes an "
"operation, Godot doesn't validate that it supports the operation by "
"**type**. It instead checks that the object **implements** the individual "
"method."
msgstr ""
"API скриптів Godot є качиною типізацією. Це означає, що якщо скрипт виконує "
"операцію, Godot не перевіряє, чи підтримується операція за **типом**. "
"Натомість він перевіряє, чи **реалізує об'єкт** індивідуальний метод."

#: ../../docs/getting_started/workflow/best_practices/godot_interfaces.rst:251
msgid ""
"For example, the :ref:`CanvasItem <class_CanvasItem>` class has a "
"``visible`` property. All properties exposed to the scripting API are in "
"fact a setter and getter pair bound to a name. If one tried to access :ref:"
"`CanvasItem.visible <class_CanvasItem_property_visible>`, then Godot would "
"do the following checks, in order:"
msgstr ""
"Наприклад, клас :ref:`CanvasItem <class_CanvasItem>` має властивість "
"``visible``. Усі властивості, які піддаються API скриптів, насправді є "
"парами сеттер та геттер, прив'язаними до імені. Якби хтось спробував "
"отримати доступ до :ref:`CanvasItem.visible "
"<class_CanvasItem_property_visible>`, то Godot зробив би наступні перевірки "
"по порядку:"

#: ../../docs/getting_started/workflow/best_practices/godot_interfaces.rst:257
msgid ""
"If the object has a script attached, it will attempt to set the property "
"through the script. This leaves open the opportunity for scripts to override "
"a property defined on a base object by overriding the setter method for the "
"property."
msgstr ""
"Якщо до об'єкта прикріплений скрипт, він спробує встановити властивість за "
"допомогою скрипта. Це залишає відкритою можливість для скриптів замінити "
"властивість, визначену на базовому об’єкті, замінивши метод сеттера для "
"властивості."

#: ../../docs/getting_started/workflow/best_practices/godot_interfaces.rst:262
msgid ""
"If the script does not have the property, it performs a HashMap lookup in "
"the ClassDB for the \"visible\" property against the CanvasItem class and "
"all of its inherited types. If found, it will call the bound setter or "
"getter. For more information about HashMaps, see the :ref:`data preferences "
"<doc_data_preferences>` docs."
msgstr ""
"Якщо скрипт не має властивості, він виконує пошук HashMap у ClassDB для "
"властивості \"visible\" класу CanvasItem та всіх його успадкованих типів. "
"При знаходженні, він викличе пов’язаного сетера або геттера. Для отримання "
"додаткової інформації про HashMaps дивіться документи по :ref:`налаштуванні "
"даних<doc_data_preferences>`."

#: ../../docs/getting_started/workflow/best_practices/godot_interfaces.rst:268
msgid ""
"If not found, it does an explicit check to see if the user wants to access "
"the \"script\" or \"meta\" properties."
msgstr ""
"Якщо пошук буде не вдалий, він явно перевіряє, чи хоче користувач отримати "
"доступ до властивостей \"script\" або \"meta\"."

#: ../../docs/getting_started/workflow/best_practices/godot_interfaces.rst:271
msgid ""
"If not, it checks for a ``_set``/``_get`` implementation (depending on type "
"of access) in the CanvasItem and its inherited types. These methods can "
"execute logic that gives the impression that the Object has a property. This "
"is also the case with the ``_get_property_list`` method."
msgstr ""
"Якщо ні, то він перевіряє наявність реалізації ``_set``/``_get`` (залежно "
"від типу доступу) у CanvasItem та його успадкованих типах. Ці методи можуть "
"виконувати логіку, яка створює враження, що Об'єкт має властивість. Це також "
"стосується метода ``_get_property_list``."

#: ../../docs/getting_started/workflow/best_practices/godot_interfaces.rst:276
msgid ""
"Note that this happens even for non-legal symbol names such as in the case "
"of :ref:`TileSet <class_TileSet>`'s \"1/tile_name\" property. This refers to "
"the name of the tile with ID 1, i.e. :ref:`TileSet.tile_get_name(1) "
"<class_TileSet_method_tile_get_name>`."
msgstr ""
"Зауважте, що це відбувається навіть для неприйнятних іменами символів, "
"наприклад, у випадку властивості :ref:`TileSet <class_TileSet>` \"1/tile_name"
"\". Це стосується назви плитки з ідентифікатором 1, тобто :ref:`TileSet."
"tile_get_name(1) <class_TileSet_method_tile_get_name>`."

#: ../../docs/getting_started/workflow/best_practices/godot_interfaces.rst:281
msgid ""
"As a result, this duck-typed system can locate a property either in the "
"script, the object's class, or any class that object inherits, but only for "
"things which extend Object."
msgstr ""
"Як результат, система качиної типізації, може знаходити властивість або у "
"скрипт, і в класі об’єкта, і в будь-якому класі, який об’єкт успадковує, але "
"лише для речей, які розширюють Об’єкт."

#: ../../docs/getting_started/workflow/best_practices/godot_interfaces.rst:285
msgid ""
"Godot provides a variety of options for performing runtime checks on these "
"accesses:"
msgstr "Godot пропонує безліч варіантів для виконання таких перевірок:"

#: ../../docs/getting_started/workflow/best_practices/godot_interfaces.rst:288
msgid ""
"A duck-typed property access. These will property check (as described "
"above). If the operation isn't supported by the object, execution will halt."
msgstr ""
"Доступ до властивості качиної типізації. Це буде перевірка властивостей (як "
"описано вище). Якщо об'єкт не підтримує операцію, виконання зупиняється."

#: ../../docs/getting_started/workflow/best_practices/godot_interfaces.rst:316
msgid ""
"A method check. In the case of :ref:`CanvasItem.visible "
"<class_CanvasItem_property_visible>`, one can access the methods, "
"``set_visible`` and ``is_visible`` like any other method."
msgstr ""
"Перевірка метода. У випадку з :ref:`CanvasItem.visible "
"<class_CanvasItem_property_visible>`, можна отримати доступ до методів "
"``set_visible`` і ``is_visible`` як до будь-якого іншого методу."

#: ../../docs/getting_started/workflow/best_practices/godot_interfaces.rst:454
msgid ""
"Outsource the access to a :ref:`FuncRef <class_FuncRef>`. These may be "
"useful in cases where one needs the max level of freedom from dependencies. "
"In this case, one relies on an external context to setup the method."
msgstr ""
"Передача доступу до :ref:`FuncRef <class_FuncRef>`. Це може бути корисними у "
"випадках, коли потрібен максимальний рівень позбавлення від залежностей. У "
"цьому випадку для налаштування методу використовується зовнішній контекст."

#: ../../docs/getting_started/workflow/best_practices/godot_interfaces.rst:513
msgid ""
"These strategies contribute to Godot's flexible design. Between them, users "
"have a breadth of tools to meet their specific needs."
msgstr ""
"Цим стратегіям сприяє гнучка архітектура Godot. Окрім них користувачі мають "
"широкий спектр інструментів для задоволення своїх конкретних потреб."
