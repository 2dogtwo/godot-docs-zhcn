# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2020, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-08-11 13:45+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../docs/tutorials/optimization/cpu_optimization.rst:4
msgid "CPU Optimizations"
msgstr "Optimisations CPU"

#: ../../docs/tutorials/optimization/cpu_optimization.rst:7
msgid "Measuring performance"
msgstr "Mesure des performances"

#: ../../docs/tutorials/optimization/cpu_optimization.rst:9
msgid ""
"To know how to speed up our program, we have to know where the \"bottlenecks"
"\" are. Bottlenecks are  the slowest parts of the program that limit the "
"rate that everything can progress. This allows us to concentrate our efforts "
"on optimizing the areas which will give us the greatest speed improvement, "
"instead of spending a lot of time optimizing functions that will lead to "
"small performance improvements."
msgstr ""
"Pour savoir comment accélérer notre programme, nous devons savoir où se "
"trouvent les \"goulets d'étranglement\". Les goulets d'étranglement sont les "
"parties les plus lentes du programme qui limitent la vitesse à laquelle tout "
"peut progresser. Cela nous permet de concentrer nos efforts sur "
"l'optimisation des domaines qui nous donneront la plus grande amélioration "
"de la vitesse, au lieu de passer beaucoup de temps à optimiser des fonctions "
"qui conduiront à de petites améliorations des performances."

#: ../../docs/tutorials/optimization/cpu_optimization.rst:16
msgid ""
"For the CPU, the easiest way to identify bottlenecks is to use a profiler."
msgstr ""
"Pour le CPU, le moyen le plus simple d'identifier les goulets d'étranglement "
"est d'utiliser un profileur."

#: ../../docs/tutorials/optimization/cpu_optimization.rst:19
msgid "CPU profilers"
msgstr "CPU profileurs"

#: ../../docs/tutorials/optimization/cpu_optimization.rst:21
msgid ""
"Profilers run alongside your program and take timing measurements to work "
"out what proportion of time is spent in each function."
msgstr ""
"Les profileurs fonctionnent en parallèle de votre programme et prennent des "
"mesures de temps pour déterminer la proportion de temps passé dans chaque "
"fonction."

#: ../../docs/tutorials/optimization/cpu_optimization.rst:24
msgid ""
"The Godot IDE conveniently has a built in profiler. It does not run every "
"time you start your project, and must be manually started and stopped. This "
"is because, in common with most profilers, recording these timing "
"measurements can slow down your project significantly."
msgstr ""
"L'IDE Godot dispose d'un profileur intégré. Il ne fonctionne pas à chaque "
"fois que vous démarrez votre projet, et doit être démarré et arrêté "
"manuellement. En effet, comme pour la plupart des profileurs, "
"l'enregistrement de ces mesures de temps peut ralentir considérablement "
"votre projet."

#: ../../docs/tutorials/optimization/cpu_optimization.rst:29
msgid "After profiling, you can look back at the results for a frame."
msgstr ""
"Après le profilage, vous pouvez consulter les résultats pour une image."

#: ../../docs/tutorials/optimization/cpu_optimization.rst:33
msgid "`These are the results of a profile of one of the demo projects.`"
msgstr "`Voici les résultats d'un profil d'un des projets de démonstration.`"

#: ../../docs/tutorials/optimization/cpu_optimization.rst:35
msgid ""
"We can see the cost of built-in processes such as physics and audio, as well "
"as seeing the cost of our own scripting functions at the bottom."
msgstr ""
"Nous pouvons voir le coût des processus intégrés tels que la physique et "
"l'audio, ainsi que le coût de nos propres fonctions de script en bas."

#: ../../docs/tutorials/optimization/cpu_optimization.rst:39
msgid ""
"When a project is running slowly, you will often see an obvious function or "
"process taking a lot more time than others. This is your primary bottleneck, "
"and you can usually increase speed by optimizing this area."
msgstr ""
"Lorsqu'un projet se déroule lentement, vous verrez souvent une fonction ou "
"un processus évident prendre beaucoup plus de temps que d'autres. C'est "
"votre principal goulot d'étranglement, et vous pouvez généralement augmenter "
"la vitesse en optimisant cette partie."

#: ../../docs/tutorials/optimization/cpu_optimization.rst:43
msgid ""
"For more info about using the profiler within Godot see :ref:"
"`doc_debugger_panel`."
msgstr ""
"Pour plus d'informations sur l'utilisation du profileur dans Godot, voir :"
"ref:`doc_debugger_panel`."

#: ../../docs/tutorials/optimization/cpu_optimization.rst:47
msgid "External profilers"
msgstr "Profileurs externes"

#: ../../docs/tutorials/optimization/cpu_optimization.rst:49
msgid ""
"Although the Godot IDE profiler is very convenient and useful, sometimes you "
"need more power, and the ability to profile the Godot engine source code "
"itself."
msgstr ""
"Bien que le profileur de l'IDE Godot soit très pratique et utile, il faut "
"parfois plus de puissance et la capacité de profiler le code source du "
"moteur Godot lui-même."

#: ../../docs/tutorials/optimization/cpu_optimization.rst:52
msgid ""
"You can use a number of third party profilers to do this including Valgrind, "
"VerySleepy, Visual Studio and Intel VTune."
msgstr ""
"Pour ce faire, vous pouvez utiliser un certain nombre de profileurs tiers, "
"notamment Valgrind, VerySleepy, Visual Studio et Intel VTune."

#: ../../docs/tutorials/optimization/cpu_optimization.rst:55
msgid ""
"You may need to compile Godot from source in order to use a third party "
"profiler so that you have program database information available. You can "
"also use a debug build, however, note that the results of profiling a debug "
"build will be different to a release build, because debug builds are less "
"optimized. Bottlenecks are often in a different place in debug builds, so "
"you should profile release builds wherever possible."
msgstr ""
"Vous devrez peut-être compiler Godot à partir des sources pour utiliser un "
"profileur tiers afin de disposer des informations de la base de données du "
"programme. Vous pouvez également utiliser une compilation de débogage, "
"cependant, notez que les résultats du profilage d'une compilation de "
"débogage seront différents de ceux d'une compilation de version, car les "
"compilations de débogage sont moins optimisées. Les goulots d'étranglement "
"se trouvent souvent à un endroit différent dans les versions de débogage, "
"c'est pourquoi vous devez profiler les versions de publication chaque fois "
"que cela est possible."

#: ../../docs/tutorials/optimization/cpu_optimization.rst:65
msgid "`These are example results from Callgrind, part of Valgrind, on Linux.`"
msgstr ""
"`Voici des exemples de résultats de Callgrind, qui fait partie de Valgrind, "
"sur Linux.`"

#: ../../docs/tutorials/optimization/cpu_optimization.rst:67
msgid ""
"From the left, Callgrind is listing the percentage of time within a function "
"and its children (Inclusive), the percentage of time spent within the "
"function itself, excluding child functions (Self), the number of times the "
"function is called, the function name, and the file or module."
msgstr ""
"De gauche à droite, Callgrind indique le pourcentage de temps passé dans une "
"fonction et ses enfants (Inclusive), le pourcentage de temps passé dans la "
"fonction elle-même, à l'exclusion des fonctions enfants (Self), le nombre de "
"fois que la fonction est appelée, le nom de la fonction et le fichier ou "
"module."

#: ../../docs/tutorials/optimization/cpu_optimization.rst:72
msgid ""
"In this example we can see nearly all time is spent under the `Main::"
"iteration()` function, this is the master function in the Godot source code "
"that is called repeatedly, and causes frames to be drawn, physics ticks to "
"be simulated, and nodes and scripts to be updated. A large proportion of the "
"time is spent in the functions to render a canvas (66%), because this "
"example uses a 2d benchmark. Below this we see that almost 50% of the time "
"is spent outside Godot code in `libglapi`, and `i965_dri` (the graphics "
"driver). This tells us the a large proportion of CPU time is being spent in "
"the graphics driver."
msgstr ""
"Dans cet exemple, nous pouvons voir que presque tout le temps est passé sous "
"la fonction `Main::iteration()`, c'est la fonction maître du code source "
"Godot qui est appelée de façon répétée, et qui provoque le dessin de trames, "
"la simulation des tics physiques, et la mise à jour de nœuds et de scripts. "
"Une grande partie du temps est consacrée aux fonctions de rendu d'un canevas "
"(66%), car cet exemple utilise un benchmark 2d. En dessous, nous voyons que "
"presque 50% du temps est passé en dehors du code Godot dans `libglapi`, et "
"`i965_dri` (le pilote graphique). Cela nous indique qu'une grande partie du "
"temps CPU est passé dans le pilote graphique."

#: ../../docs/tutorials/optimization/cpu_optimization.rst:82
msgid ""
"This is actually an excellent example because in an ideal world, only a very "
"small proportion of time would be spent in the graphics driver, and this is "
"an indication that there is a problem with too much communication and work "
"being done in the graphics API. This profiling lead to the development of 2d "
"batching, which greatly speeds up 2d by reducing bottlenecks in this area."
msgstr ""
"C'est en fait un excellent exemple car dans un monde idéal, seule une très "
"petite partie du temps serait consacrée au pilote graphique, et cela indique "
"qu'il y a un problème trop de communication et de trop travail fait dans "
"l'API graphique. Ce profilage a conduit au développement du traitement par "
"lot 2d, qui accélère considérablement la 2d en réduisant les goulots "
"d'étranglement dans ce domaine."

#: ../../docs/tutorials/optimization/cpu_optimization.rst:89
msgid "Manually timing functions"
msgstr "Chronométrer manuellement des fonctions"

#: ../../docs/tutorials/optimization/cpu_optimization.rst:91
msgid ""
"Another handy technique, especially once you have identified the bottleneck "
"using a profiler, is to manually time the function or area under test. The "
"specifics vary according to language, but in GDScript, you would do the "
"following:"
msgstr ""
"Une autre technique pratique, surtout lorsque vous avez identifié le goulot "
"d'étranglement à l'aide d'un profileur, consiste à chronométrer manuellement "
"la fonction ou la zone testée. Les spécificités varient selon le langage, "
"mais en GDScript, vous feriez ce qui suit :"

#: ../../docs/tutorials/optimization/cpu_optimization.rst:107
msgid ""
"You may want to consider using other functions for time if another time unit "
"is more suitable, for example :ref:`OS.get_system_time_secs "
"<class_OS_method_get_system_time_secs>` if the function will take many "
"seconds."
msgstr ""
"Vous pouvez envisager d'utiliser d'autres fonctions pour le temps si une "
"autre unité de temps est plus appropriée, par exemple :ref:`OS."
"get_system_time_secs <class_OS_method_get_system_time_secs>` si la fonction "
"prendra plusieurs secondes."

#: ../../docs/tutorials/optimization/cpu_optimization.rst:111
msgid ""
"When manually timing functions, it is usually a good idea to run the "
"function many times (say ``1000`` or more times), instead of just once "
"(unless it is a very slow function). A large part of the reason for this is "
"that timers often have limited accuracy, and CPUs will schedule processes in "
"a haphazard manner, so an average over a series of runs is more accurate "
"than a single measurement."
msgstr ""
"Lorsque vous chronométrez manuellement des fonctions, il est généralement "
"judicieux d'exécuter la fonction plusieurs fois (disons ``1000`` ou plus), "
"au lieu d'une seule fois (à moins qu'il ne s'agisse d'une fonction très "
"lente). Cela s'explique en grande partie par le fait que les chronomètres "
"ont souvent une précision limitée, et que les CPU organisent les processus "
"de manière aléatoire, de sorte qu'une moyenne sur une série d'exécutions est "
"plus précise qu'une mesure unique."

#: ../../docs/tutorials/optimization/cpu_optimization.rst:117
msgid ""
"As you attempt to optimize functions, be sure to either repeatedly profile "
"or time them as you go. This will give you crucial feedback as to whether "
"the optimization is working (or not)."
msgstr ""
"Lorsque vous essayez d'optimiser les fonctions, veillez à les profiler ou à "
"les chronométrer au fur et à mesure. Cela vous permettra d'obtenir un retour "
"d'information crucial pour savoir si l'optimisation fonctionne (ou non)."

#: ../../docs/tutorials/optimization/cpu_optimization.rst:122
msgid "Caches"
msgstr "Caches"

#: ../../docs/tutorials/optimization/cpu_optimization.rst:124
msgid ""
"Something else to be particularly aware of, especially when comparing timing "
"results of two different versions of a function, is that the results can be "
"highly dependent on whether the data is in the CPU cache or not. CPUs don't "
"load data directly from main memory, because although main memory can be "
"huge (many GBs), it is very slow to access. Instead CPUs load data from a "
"smaller, higher speed bank of memory, called cache. Loading data from cache "
"is super fast, but every time you try and load a memory address that is not "
"stored in cache, the cache must make a trip to main memory and slowly load "
"in some data. This delay can result in the CPU sitting around idle for a "
"long time, and is referred to as a \"cache miss\"."
msgstr ""
"Il faut également être particulièrement attentif, notamment lorsque l'on "
"compare les résultats de chronométrage de deux versions différentes d'une "
"fonction, au fait que les résultats peuvent être très dépendants du fait que "
"les données se trouvent ou non dans le cache de l'unité centrale. Les CPU ne "
"chargent pas les données directement à partir de la mémoire principale, car "
"bien que la mémoire principale puisse être énorme (plusieurs Go), elle est "
"très lente à accéder. Les CPU chargent plutôt des données à partir d'une "
"banque de mémoire plus petite et plus rapide, appelée cache. Le chargement "
"de données à partir de la mémoire cache est super rapide, mais chaque fois "
"que vous essayez de charger une adresse mémoire qui n'est pas stockée dans "
"la mémoire cache, la mémoire cache doit faire un voyage vers la mémoire "
"principale et charger lentement certaines données. Ce retard peut faire que "
"l'unité centrale reste inactive pendant un long moment, ce que l'on appelle "
"un \"cache miss\"."

#: ../../docs/tutorials/optimization/cpu_optimization.rst:135
msgid ""
"This means that the first time you run a function, it may run slowly, "
"because the data is not in cache. The second and later times, it may run "
"much faster because the data is in cache. So always use averages when "
"timing, and be aware of the effects of cache."
msgstr ""
"Cela signifie que la première fois que vous exécutez une fonction, elle peut "
"être lente, car les données ne sont pas en mémoire cache. La deuxième fois "
"et les suivantes, elle peut s'exécuter beaucoup plus rapidement parce que "
"les données sont en mémoire cache. Il faut donc toujours utiliser des "
"moyennes lors du chronométrage, et être conscient des effets de cache."

#: ../../docs/tutorials/optimization/cpu_optimization.rst:140
msgid ""
"Understanding caching is also crucial to CPU optimization. If you have an "
"algorithm (routine) that loads small bits of data from randomly spread out "
"areas of main memory, this can result in a lot of cache misses, a lot of the "
"time, the CPU will be waiting around for data instead of doing any work. "
"Instead, if you can make your data accesses localised, or even better, "
"access memory in a linear fashion (like a continuous list), then the cache "
"will work optimally and the CPU will be able to work as fast as possible."
msgstr ""
"La compréhension de la mise en cache est également cruciale pour "
"l'optimisation CPU. Si vous disposez d'un algorithme (routine) qui charge de "
"petits morceaux de données à partir de zones de la mémoire principale "
"réparties de manière aléatoire, cela peut entraîner de nombreux cache "
"misses, la plupart du temps, le CPU attendra des données au lieu d'effectuer "
"un travail quelconque. Au lieu de cela, si vous pouvez faire en sorte que "
"vos accès aux données soient localisés, ou mieux encore, si vous accédez à "
"la mémoire de manière linéaire (comme une liste continue), alors le cache "
"fonctionnera de manière optimale et le CPU pourra travailler aussi vite que "
"possible."

#: ../../docs/tutorials/optimization/cpu_optimization.rst:148
msgid ""
"Godot usually takes care of such low-level details for you. For example, the "
"Server APIs make sure data is optimized for caching already for things like "
"rendering and physics. But you should be especially aware of caching when "
"using GDNative."
msgstr ""
"Godot s'occupe généralement de ces détails de bas niveau pour vous. Par "
"exemple, les API du serveur s'assurent que les données sont déjà optimisées "
"pour la mise en cache pour des choses comme le rendu et la physique. Mais "
"vous devez être particulièrement attentif à la mise en cache lorsque vous "
"utilisez GDNative."

#: ../../docs/tutorials/optimization/cpu_optimization.rst:154
msgid "Languages"
msgstr "Langages"

#: ../../docs/tutorials/optimization/cpu_optimization.rst:156
msgid ""
"Godot supports a number of different languages, and it is worth bearing in "
"mind that there are trade-offs involved - some languages are designed for "
"ease of use, at the cost of speed, and others are faster but more difficult "
"to work with."
msgstr ""
"Godot prend en charge un certain nombre de langues différentes, et il "
"convient de garder à l'esprit qu'il y a des compromis à faire : certains "
"langages sont conçues pour être faciles à utiliser, au prix de la rapidité, "
"et d'autres sont plus rapides mais plus difficiles à utiliser."

#: ../../docs/tutorials/optimization/cpu_optimization.rst:161
msgid ""
"Built-in engine functions run at the same speed regardless of the scripting "
"language you choose. If your project is making a lot of calculations in its "
"own code, consider moving those calculations to a faster language."
msgstr ""
"Les fonctions intégrées du moteur fonctionnent à la même vitesse, quel que "
"soit le langage de script que vous choisissez. Si votre projet effectue "
"beaucoup de calculs dans son propre code, envisagez de déplacer ces calculs "
"vers un langage plus rapide."

#: ../../docs/tutorials/optimization/cpu_optimization.rst:166
msgid "GDScript"
msgstr "GDScript"

#: ../../docs/tutorials/optimization/cpu_optimization.rst:168
msgid ""
"GDScript is designed to be easy to use and iterate, and is ideal for making "
"many types of games. However, ease of use is considered more important than "
"performance, so if you need to make heavy calculations, consider moving some "
"of your project to one of the other languages."
msgstr ""
"Le GDScript est conçu pour être facile à utiliser et à itérer, et est idéal "
"pour réaliser de nombreux types de jeux. Toutefois, la facilité "
"d'utilisation est considérée comme plus importante que la performance, donc "
"si vous devez faire des calculs lourds, pensez à déplacer une partie de "
"votre projet vers l'un des autres langages."

#: ../../docs/tutorials/optimization/cpu_optimization.rst:174
msgid "C#"
msgstr "C#"

#: ../../docs/tutorials/optimization/cpu_optimization.rst:176
msgid ""
"C# is popular and has first class support in Godot. It offers a good "
"compromise between speed and ease of use."
msgstr ""
"Le C# est populaire et bénéficie d'un soutien de premier ordre dans Godot. "
"Il offre un bon compromis entre vitesse et facilité d'utilisation."

#: ../../docs/tutorials/optimization/cpu_optimization.rst:180
msgid "Other languages"
msgstr "Autres langages"

#: ../../docs/tutorials/optimization/cpu_optimization.rst:182
msgid ""
"Third parties provide support for several other languages, including `Rust "
"<https://github.com/godot-rust/godot-rust>`_ and `Javascript <https://github."
"com/GodotExplorer/ECMAScript>`_."
msgstr ""
"Des tiers fournissent un support pour plusieurs autres langages, notamment "
"`Rust <https://github.com/godot-rust/godot-rust>`_ et `Javascript <https://"
"github.com/GodotExplorer/ECMAScript>`_."

#: ../../docs/tutorials/optimization/cpu_optimization.rst:187
msgid "C++"
msgstr "C++"

#: ../../docs/tutorials/optimization/cpu_optimization.rst:189
msgid ""
"Godot is written in C++. Using C++ will usually result in the fastest code, "
"however, on a practical level, it is the most difficult to deploy to end "
"users' machines on different platforms. Options for using C++ include "
"GDNative, and custom modules."
msgstr ""
"Godot est écrit en C++. L'utilisation du C++ permet généralement d'obtenir "
"le code le plus rapide, mais d'un point de vue pratique, il est le plus "
"difficile à déployer sur les machines des utilisateurs finaux sur "
"différentes plateformes. Les options d'utilisation du C++ comprennent "
"GDNative et les modules personnalisés."

#: ../../docs/tutorials/optimization/cpu_optimization.rst:195
msgid "Threads"
msgstr "Sujets"

#: ../../docs/tutorials/optimization/cpu_optimization.rst:197
msgid ""
"Consider using threads when making a lot of calculations that can run "
"parallel to one another. Modern CPUs have multiple cores, each one capable "
"of doing a limited amount of work. By spreading work over multiple threads "
"you can move further towards peak CPU efficiency."
msgstr ""
"Pensez à utiliser des threads lorsque vous effectuez de nombreux calculs qui "
"peuvent être parallèles les uns aux autres. Les CPU modernes ont plusieurs "
"cœurs, chacun capable d'effectuer une quantité de travail limitée. En "
"répartissant le travail sur plusieurs threads, vous pouvez aller plus loin "
"vers une efficacité maximale du CPU."

#: ../../docs/tutorials/optimization/cpu_optimization.rst:202
msgid ""
"The disadvantage of threads is that you have to be incredibly careful. As "
"each CPU core operates independently, they can end up trying to access the "
"same memory at the same time. One thread can be reading to a variable while "
"another is writing. Before you use threads make sure you understand the "
"dangers and how to try and prevent these race conditions."
msgstr ""
"L'inconvénient des threads est qu'il faut être incroyablement prudent. Comme "
"chaque cœur de CPU fonctionne indépendamment, ils peuvent finir par essayer "
"d'accéder à la même mémoire en même temps. Un thread peut lire une variable "
"alors qu'un autre est en train d'écrire. Avant d'utiliser les threads, "
"assurez-vous de bien comprendre les dangers et comment essayer de prévenir "
"ces conditions de concurrence."

#: ../../docs/tutorials/optimization/cpu_optimization.rst:208
msgid "For more information on threads see :ref:`doc_using_multiple_threads`."
msgstr ""
"Pour plus d'informations sur les threads, voir :ref:"
"`doc_using_multiple_threads`."

#: ../../docs/tutorials/optimization/cpu_optimization.rst:211
msgid "SceneTree"
msgstr "L'arbre de scène"

#: ../../docs/tutorials/optimization/cpu_optimization.rst:213
msgid ""
"Although Nodes are an incredibly powerful and versatile concept, be aware "
"that every node has a cost. Built in functions such as `_process()` and "
"`_physics_process()` propagate through the tree. This housekeeping can "
"reduce performance when you have very large numbers of nodes."
msgstr ""
"Bien que les nœuds soient un concept incroyablement puissant et polyvalent, "
"sachez que chaque nœud a un coût. Des fonctions intégrées telles que "
"`_processus()` et `_processus_physique()` se propagent dans l'arbre. Cette "
"gestion interne peut réduire les performances lorsque vous avez un très "
"grand nombre de nœuds."

#: ../../docs/tutorials/optimization/cpu_optimization.rst:218
msgid ""
"Each node is handled individually in the Godot renderer so sometimes a "
"smaller number of nodes with more in each can lead to better performance."
msgstr ""
"Chaque nœud est traité individuellement dans le moteur de rendu Godot, de "
"sorte que parfois un nombre plus petit de nœuds avec plus dans chacun peut "
"conduire à une meilleure performance."

#: ../../docs/tutorials/optimization/cpu_optimization.rst:221
msgid ""
"One quirk of the :ref:`SceneTree <class_SceneTree>` is that you can "
"sometimes get much better performance by removing nodes from the SceneTree, "
"rather than by pausing or hiding them. You don't have to delete a detached "
"node. You can for example, keep a reference to a node, detach it from the "
"scene tree, then reattach it later. This can be very useful for adding and "
"removing areas from a game for example."
msgstr ""
"L'une des bizarreries de :ref:`SceneTree <class_SceneTree>` est que vous "
"pouvez parfois obtenir de bien meilleures performances en enlevant des nœuds "
"de l'arbre de scène, plutôt qu'en les mettant en pause ou en les cachant. "
"Vous n'avez pas besoin de supprimer un noeud détaché. Vous pouvez par "
"exemple conserver une référence à un nœud, le détacher de l'arbre des "
"scènes, puis le rattacher plus tard. Cela peut être très utile pour ajouter "
"et supprimer des zones d'un jeu par exemple."

#: ../../docs/tutorials/optimization/cpu_optimization.rst:228
msgid ""
"You can avoid the SceneTree altogether by using Server APIs. For more "
"information, see :ref:`doc_using_servers`."
msgstr ""
"Vous pouvez éviter complètement SceneTree en utilisant les API serveur. Pour "
"plus d'informations, voir :ref:`doc_using_servers`."

#: ../../docs/tutorials/optimization/cpu_optimization.rst:232
msgid "Physics"
msgstr "Physique"

#: ../../docs/tutorials/optimization/cpu_optimization.rst:234
msgid ""
"In some situations physics can end up becoming a bottleneck, particularly "
"with complex worlds, and large numbers of physics objects."
msgstr ""
"Dans certaines situations, la physique peut finir par devenir un goulot "
"d'étranglement, en particulier avec des mondes complexes et un grand nombre "
"d'objets physiques."

#: ../../docs/tutorials/optimization/cpu_optimization.rst:237
msgid "Some techniques to speed up physics:"
msgstr "Quelques techniques pour accélérer la physique :"

#: ../../docs/tutorials/optimization/cpu_optimization.rst:239
msgid ""
"Try using simplified versions of your rendered geometry for physics. Often "
"this won't be noticeable for end users, but can greatly increase performance."
msgstr ""
"Essayez d'utiliser des versions simplifiées de votre géométrie rendue pour "
"la physique. Souvent, les utilisateurs finaux ne s'en apercevront pas, mais "
"cela peut améliorer considérablement les performances."

#: ../../docs/tutorials/optimization/cpu_optimization.rst:241
msgid ""
"Try removing objects from physics when they are out of view / outside the "
"current area, or reusing physics objects (maybe you allow 8 monsters per "
"area, for example, and reuse these)."
msgstr ""
"Essayez de retirer des objets de la physique lorsqu'ils sont hors de vue / "
"en dehors de la zone actuelle, ou de réutiliser des objets de la physique "
"(peut-être que vous autorisez 8 monstres par zone, par exemple, et que vous "
"les réutilisez)."

#: ../../docs/tutorials/optimization/cpu_optimization.rst:245
msgid ""
"Another crucial aspect to physics is the physics tick rate. In some games "
"you can greatly reduce the tick rate, and instead of for example, updating "
"physics 60 times per second, you may update it at 20, or even 10 ticks per "
"second. This can greatly reduce the CPU load."
msgstr ""
"Un autre aspect crucial de la physique est le taux de taux de "
"rafraîchissement de la physique. Dans certains jeux, vous pouvez réduire "
"considérablement le taux de taux de rafraîchissement, et au lieu, par "
"exemple, de mettre à jour la physique 60 fois par seconde, vous pouvez la "
"mettre à jour à 20, voire 10 fois par seconde. Cela peut réduire "
"considérablement la charge du CPU."

#: ../../docs/tutorials/optimization/cpu_optimization.rst:250
msgid ""
"The downside of changing physics tick rate is you can get jerky movement or "
"jitter when the physics update rate does not match the frames rendered."
msgstr ""
"L'inconvénient de la modification du taux de rafraîchissement de la physique "
"est que vous pouvez obtenir un mouvement saccadé ou du jitter lorsque le "
"taux de rafraîchissement de la physique ne correspond pas à celui du rendu "
"des images."

#: ../../docs/tutorials/optimization/cpu_optimization.rst:253
msgid ""
"The solution to this problem is 'fixed timestep interpolation', which "
"involves smoothing the rendered positions and rotations over multiple frames "
"to match the physics. You can either implement this yourself or use a third-"
"party addon. Interpolation is a very cheap operation, performance wise, "
"compared to running a physics tick, orders of magnitude faster, so this can "
"be a significant win, as well as reducing jitter."
msgstr ""
"La solution à ce problème est la 'fixed timestep interpolation', qui "
"consiste à lisser les positions et les rotations rendues sur plusieurs "
"trames pour qu'elles correspondent à la physique. Vous pouvez soit "
"l'implémenter vous-même, soit utiliser un addon tiers. L'interpolation est "
"une opération très peu coûteuse, en termes de performances, par rapport au "
"rafraîchissement de la physique, des ordres de grandeur plus rapides, donc "
"cela peut être un gain important, ainsi que la réduction du jitter."
