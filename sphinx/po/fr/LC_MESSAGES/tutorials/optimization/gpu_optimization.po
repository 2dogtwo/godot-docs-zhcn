# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2020, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-08-11 13:45+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:4
msgid "GPU Optimizations"
msgstr "Optimisations GPU"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:7
msgid "Introduction"
msgstr "Introduction"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:9
msgid ""
"The demand for new graphics features and progress almost guarantees that you "
"will encounter graphics bottlenecks. Some of these can be CPU side, for "
"instance in calculations inside the Godot engine to prepare objects for "
"rendering. Bottlenecks can also occur on the CPU in the graphics driver, "
"which sorts instructions to pass to the GPU, and in the transfer of these "
"instructions. And finally bottlenecks also occur on the GPU itself."
msgstr ""
"La demande de nouvelles fonctionnalités graphiques et de progrès garantit "
"presque que vous rencontrerez des goulots d'étranglement graphiques. "
"Certains d'entre eux peuvent être du côté du CPU, par exemple dans les "
"calculs à l'intérieur du moteur Godot pour préparer les objets pour le "
"rendu. Des goulots d'étranglement peuvent également se produire dans le CPU "
"dans le pilote graphique, qui trie les instructions à transmettre au GPU, et "
"dans le transfert de ces instructions. Et enfin, des goulots d'étranglement "
"se produisent également sur le GPU lui-même."

#: ../../docs/tutorials/optimization/gpu_optimization.rst:16
msgid ""
"Where bottlenecks occur in rendering is highly hardware specific. Mobile "
"GPUs in particular may struggle with scenes that run easily on desktop."
msgstr ""
"Les goulets d'étranglement dans le rendu sont très spécifiques au matériel. "
"Les GPU mobiles, en particulier, peuvent avoir du mal à rendre des scènes "
"qui s'exécutent facilement sur un ordinateur de bureau."

#: ../../docs/tutorials/optimization/gpu_optimization.rst:19
msgid ""
"Understanding and investigating GPU bottlenecks is slightly different to the "
"situation on the CPU, because often you can only change performance "
"indirectly, by changing the instructions you give to the GPU, and it may be "
"more difficult to take measurements. Often the only way of measuring "
"performance is by examining changes in frame rate."
msgstr ""
"La compréhension et l'étude des goulets d'étranglement du GPU sont "
"légèrement différentes de la situation sur le CPU, car souvent vous ne "
"pouvez modifier les performances qu'indirectement, en changeant les "
"instructions que vous donnez au GPU, et il peut être plus difficile de "
"prendre des mesures. Souvent, la seule façon de mesurer les performances est "
"d'examiner les changements de fréquence d'images."

#: ../../docs/tutorials/optimization/gpu_optimization.rst:26
msgid "Drawcalls, state changes, and APIs"
msgstr "Drawcalls, les changements d'état et APIs"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:28
msgid ""
"The following section is not relevant to end-users, but is useful to provide "
"background information that is relevant in later sections."
msgstr ""
"La section suivante ne concerne pas les utilisateurs finaux, mais elle est "
"utile pour fournir des informations générales qui seront utiles dans les "
"sections suivantes."

#: ../../docs/tutorials/optimization/gpu_optimization.rst:31
msgid ""
"Godot sends instructions to the GPU via a graphics API (OpenGL, GLES2, "
"GLES3, Vulkan). The communication and driver activity involved can be quite "
"costly, especially in OpenGL. If we can provide these instructions in a way "
"that is preferred by the driver and GPU, we can greatly increase performance."
msgstr ""
"Godot envoie des instructions au GPU via une API graphique (OpenGL, GLES2, "
"GLES3, Vulkan). La communication et l'activité du pilote qui en découle "
"peuvent être assez coûteuses, surtout dans OpenGL. Si nous pouvons fournir "
"ces instructions de la manière préférée par le pilote et le GPU, nous "
"pouvons considérablement augmenter les performances."

#: ../../docs/tutorials/optimization/gpu_optimization.rst:36
msgid ""
"Nearly every API command in OpenGL requires a certain amount of validation, "
"to make sure the GPU is in the correct state. Even seemingly simple commands "
"can lead to a flurry of behind the scenes housekeeping. Therefore the name "
"of the game is reduce these instructions to a bare minimum, and group "
"together similar objects as much as possible so they can be rendered "
"together, or with the minimum number of these expensive state changes."
msgstr ""
"Presque chaque commande API dans OpenGL nécessite une certaine quantité de "
"validation, pour s'assurer que le GPU est dans le bon état. Même des "
"commandes apparemment simples peuvent entraîner une avalanche de tâches "
"internes en coulisses. C'est pourquoi le jeu est de réduire ces instructions "
"au strict minimum, et de regrouper autant que possible les objets similaires "
"afin qu'ils puissent être rendus ensemble, ou avec le minimum de ces coûteux "
"changements d'état."

#: ../../docs/tutorials/optimization/gpu_optimization.rst:44
msgid "2D batching"
msgstr "Traitement 2D par lots"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:46
msgid ""
"In 2d, the costs of treating each item individually can be prohibitively "
"high - there can easily be thousands on screen. This is why 2d batching is "
"used - multiple similar items are grouped together and rendered in a batch, "
"via a single drawcall, rather than making a separate drawcall for each item. "
"In addition this means that state changes, material and texture changes can "
"be kept to a minimum."
msgstr ""
"En 2d, les coûts de traitement de chaque élément individuellement peuvent "
"être prohibitifs - il peut facilement y en avoir des milliers à l'écran. "
"C'est la raison pour laquelle le traitement par lots en 2d est utilisé : "
"plusieurs éléments similaires sont regroupés et rendus en un lot, par un "
"seul drawcall, plutôt que de faire un drawcall distinct pour chaque élément. "
"En outre, cela signifie que les changements d'état, de matériau et de "
"texture peuvent être réduits au minimum."

#: ../../docs/tutorials/optimization/gpu_optimization.rst:53
msgid "For more information on 2D batching see :ref:`doc_batching`."
msgstr ""
"Pour plus d'informations sur le traitement 2D par lots, voir :ref:"
"`doc_batching`."

#: ../../docs/tutorials/optimization/gpu_optimization.rst:56
msgid "3D batching"
msgstr "Traitement 3D par lots"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:58
msgid ""
"In 3d, we still aim to minimize draw calls and state changes, however, it "
"can be more difficult to batch together several objects into a single draw "
"call. 3d meshes tend to comprise hundreds or thousands of triangles, and "
"combining large meshes at runtime is prohibitively expensive. The costs of "
"joining them quickly exceeds any benefits as the number of triangles grows "
"per mesh. A much better alternative is to join meshes ahead of time (static "
"meshes in relation to each other). This can either be done by artists, or "
"programmatically within Godot."
msgstr ""
"En 3d, nous visons toujours à minimiser les draw calls et les changements "
"d'état, cependant, il peut être plus difficile de regrouper plusieurs objets "
"en un seul draw call. Les maillages 3d ont tendance à comprendre des "
"centaines ou des milliers de triangles, et combiner de grands maillages à "
"l'exécution est d'un coût prohibitif. Le coût de leur assemblage dépasse "
"rapidement les avantages éventuels, car le nombre de triangles par maille "
"augmente. Une bien meilleure solution consiste à joindre les mailles à "
"l'avance (mailles statiques les unes par rapport aux autres). Cela peut être "
"fait soit par les artistes, soit de manière logiciel dans Godot."

#: ../../docs/tutorials/optimization/gpu_optimization.rst:66
msgid ""
"There is also a cost to batching together objects in 3d. Several objects "
"rendered as one cannot be individually culled. An entire city that is off "
"screen will still be rendered if it is joined to a single blade of grass "
"that is on screen. So attempting to batch together 3d objects should take "
"account of their location and effect on culling. Despite this, the benefits "
"of joining static objects often outweigh other considerations, especially "
"for large numbers of low poly objects."
msgstr ""
"Le traitement par lots d'objets en 3d a également un coût. Plusieurs objets "
"rendus comme un seul ne peuvent pas être occultés individuellement. Une "
"ville entière qui est hors écran sera quand même rendue si elle est jointe à "
"un seul brin d'herbe qui est à l'écran. Pour tenter de regrouper des objets "
"en 3D, il faut donc tenir compte de leur emplacement et de leur effet sur "
"l'occlusion. Malgré cela, les avantages de joindre des objets statiques "
"l'emportent souvent sur d'autres considérations, en particulier pour un "
"grand nombre d'objets à peu de polygones."

#: ../../docs/tutorials/optimization/gpu_optimization.rst:74
msgid ""
"For more information on 3D specific optimizations, see :ref:"
"`doc_optimizing_3d_performance`."
msgstr ""
"Pour plus d'informations sur les optimisations spécifiques à la 3D, voir :"
"ref:`doc_optimizing_3d_performance`."

#: ../../docs/tutorials/optimization/gpu_optimization.rst:78
msgid "Reuse Shaders and Materials"
msgstr "Réutilisation des Shaders et des Materials"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:80
msgid ""
"The Godot renderer is a little different to what is out there. It's designed "
"to minimize GPU state changes as much as possible. :ref:`SpatialMaterial "
"<class_SpatialMaterial>` does a good job at reusing materials that need "
"similar shaders but, if custom shaders are used, make sure to reuse them as "
"much as possible. Godot's priorities are:"
msgstr ""
"Le moteur de rendu de Godot est un peu différent de ce qu'y existe ailleurs. "
"Il est conçu pour minimiser autant que possible les changements d'état du "
"GPU. :ref:`SpatialMaterial <class_SpatialMaterial>` fait un bon travail pour "
"réutiliser les matériaux qui nécessitent des shaders similaires mais, si des "
"shaders personnalisés sont utilisés, assurez-vous de les réutiliser autant "
"que possible. Les priorités de Godot sont :"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:86
msgid ""
"**Reusing Materials**: The fewer different materials in the scene, the "
"faster the rendering will be. If a scene has a huge amount of objects (in "
"the hundreds or thousands) try reusing the materials or in the worst case "
"use atlases."
msgstr ""
"**Réutilisation des matériaux** : Moins il y a de matériaux différents dans "
"la scène, plus le rendu sera rapide. Si une scène a une quantité énorme "
"d'objets (des centaines ou des milliers), essayez de réutiliser les "
"matériaux ou dans le pire des cas, utilisez des atlas."

#: ../../docs/tutorials/optimization/gpu_optimization.rst:90
msgid ""
"**Reusing Shaders**: If materials can't be reused, at least try to re-use "
"shaders (or SpatialMaterials with different parameters but the same "
"configuration)."
msgstr ""
"**Reusing Shaders** : Si les matériaux ne peuvent pas être réutilisés, "
"essayez au moins de réutiliser les shaders (ou des SpatialMaterials avec des "
"paramètres différents mais avec la même configuration)."

#: ../../docs/tutorials/optimization/gpu_optimization.rst:94
msgid ""
"If a scene has, for example, ``20,000`` objects with ``20,000`` different "
"materials each, rendering will be slow. If the same scene has ``20,000`` "
"objects, but only uses ``100`` materials, rendering will be much faster."
msgstr ""
"Si une scène a, par exemple, ``20,000`` objets avec ``20,000`` matériaux "
"différents chacun, le rendu sera lent. Si la même scène contient ``20,000`` "
"objets, mais n'utilise que ``100`` matériaux, le rendu sera beaucoup plus "
"rapide."

#: ../../docs/tutorials/optimization/gpu_optimization.rst:99
msgid "Pixel cost vs vertex cost"
msgstr "Coût en pixel contre coût en sommet"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:101
msgid ""
"You may have heard that the lower the number of polygons in a model, the "
"faster it will be rendered. This is *really* relative and depends on many "
"factors."
msgstr ""
"Vous avez peut-être entendu dire que plus le nombre de polygones dans un "
"modèle est faible, plus le rendu est rapide. C'est *vraiment* relatif et "
"cela dépend de nombreux facteurs."

#: ../../docs/tutorials/optimization/gpu_optimization.rst:104
msgid ""
"On a modern PC and console, vertex cost is low. GPUs originally only "
"rendered triangles, so every frame all the vertices:"
msgstr ""
"Sur un PC et une console modernes, le coût du sommet est faible. À "
"l'origine, les GPU ne rendaient que les triangles, donc chaque image tous "
"les sommets :"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:107
msgid "Had to be transformed by the CPU (including clipping)."
msgstr "A dû être transformé par le CPU (y compris le clipping)."

#: ../../docs/tutorials/optimization/gpu_optimization.rst:109
msgid "Had to be sent to the GPU memory from the main RAM."
msgstr "Doit être envoyé à la mémoire du GPU depuis la RAM principale."

#: ../../docs/tutorials/optimization/gpu_optimization.rst:111
msgid ""
"Now all this is handled inside the GPU, so the performance is much higher. "
"3D artists usually have the wrong feeling about polycount performance "
"because 3D DCCs (such as Blender, Max, etc.) need to keep geometry in CPU "
"memory in order for it to be edited, reducing actual performance. Game "
"engines rely on the GPU more so they can render many triangles much more "
"efficiently."
msgstr ""
"De nos jours, tout cela est géré à l'intérieur du GPU, donc les performances "
"sont extrêmement élevées. Les artistes 3D ont généralement le mauvais "
"sentiment au sujet de la performance du nombre de polygone parce que les DCC "
"3D (tels que Blender, Max, etc.) ont besoin de garder la géométrie dans la "
"mémoire CPU pour qu'elle puisse être éditée, réduisant ainsi la performance "
"réelle. Les moteurs de jeu font davantage appel au GPU, ce qui leur permet "
"de rendre de nombreux triangles de manière beaucoup plus efficace."

#: ../../docs/tutorials/optimization/gpu_optimization.rst:117
msgid ""
"On mobile devices, the story is different. PC and Console GPUs are brute-"
"force monsters that can pull as much electricity as they need from the power "
"grid. Mobile GPUs are limited to a tiny battery, so they need to be a lot "
"more power efficient."
msgstr ""
"Sur les appareils mobiles, l'histoire est différente. Les GPU PC et Console "
"sont des monstres de force brute qui peuvent tirer autant d'électricité "
"qu'ils en ont besoin du réseau électrique. Les GPU mobiles sont limités à "
"une minuscule batterie, ils doivent donc être beaucoup plus économes en "
"énergie."

#: ../../docs/tutorials/optimization/gpu_optimization.rst:122
msgid ""
"To be more efficient, mobile GPUs attempt to avoid *overdraw*. This means, "
"the same pixel on the screen being rendered more than once. Imagine a town "
"with several buildings, GPUs don't know what is visible and what is hidden "
"until they draw it. A house might be drawn and then another house in front "
"of it (rendering happened twice for the same pixel!). PC GPUs normally don't "
"care much about this and just throw more pixel processors to the hardware to "
"increase performance (but this also increases power consumption)."
msgstr ""
"Pour être plus efficaces, les GPU mobiles tentent d'éviter les *overdraw*. "
"Cela signifie que le même pixel à l'écran est rendu plus d'une fois. "
"Imaginez une ville avec plusieurs bâtiments, les GPU ne savent pas ce qui "
"est visible et ce qui est caché jusqu'à ce qu'ils le dessinent. Une maison "
"peut être dessinée, puis une autre maison devant elle (le rendu a eu lieu "
"deux fois pour le même pixel !). Les GPU PC ne s'en soucient normalement pas "
"beaucoup et se contentent d'ajouter des processeurs de pixels au hardware "
"pour augmenter les performances (mais cela augmente aussi la consommation "
"d'énergie)."

#: ../../docs/tutorials/optimization/gpu_optimization.rst:130
msgid ""
"Using more power is not an option on mobile so mobile devices use a "
"technique called \"Tile Based Rendering\" which divides the screen into a "
"grid. Each cell keeps the list of triangles drawn to it and sorts them by "
"depth to minimize *overdraw*. This technique improves performance and "
"reduces power consumption, but takes a toll on vertex performance. As a "
"result, fewer vertices and triangles can be processed for drawing."
msgstr ""
"Sur mobile, tirer plus de puissance n'est pas une option, donc une technique "
"appelée \"Tile Based Rendering\" est utilisée, qui divise l'écran en grille. "
"Chaque cellule conserve la liste des triangles qui y sont dessinés et les "
"trie par profondeur pour minimiser l'*overdraw*. Cette technique améliore "
"les performances et réduit la consommation d'énergie, mais a un impact sur "
"les performances des sommets. Par conséquent, moins de sommets et de "
"triangles peuvent être traités pour le dessin."

#: ../../docs/tutorials/optimization/gpu_optimization.rst:137
msgid ""
"Additionally, Tile Based Rendering struggles when there are small objects "
"with a lot of geometry within a small portion of the screen. This forces "
"mobile GPUs to put a lot of strain on a single screen tile which "
"considerably decreases performance as all the other cells must wait for it "
"to complete in order to display the frame."
msgstr ""
"De plus, le Tile Based Rendering a des difficultés quand il y a de petits "
"objets avec beaucoup de géométrie dans une petite partie de l'écran. Cela "
"oblige les GPU mobiles à mettre beaucoup de pression sur une seule cellule "
"de l'écran, ce qui diminue considérablement les performances car toutes les "
"autres cellules doivent attendre qu'elle soit terminée pour pouvoir afficher "
"l'image."

#: ../../docs/tutorials/optimization/gpu_optimization.rst:143
msgid ""
"In summary, do not worry about vertex count on mobile, but avoid "
"concentration of vertices in small parts of the screen. If a character, NPC, "
"vehicle, etc. is far away (so it looks tiny), use a smaller level of detail "
"(LOD) model."
msgstr ""
"Pour faire court, ne vous inquiétez pas trop du nombre de sommet sur mobile, "
"mais évitez de concentrer les sommets sur de petites parties de l'écran. Si, "
"par exemple, un personnage, un PNJ, un véhicule, etc. est éloigné (donc il "
"semble minuscule), utilisez plutôt un modèle à plus petit niveau de détail "
"(LOD)."

#: ../../docs/tutorials/optimization/gpu_optimization.rst:147
msgid "Pay attention to the additional vertex processing required when using:"
msgstr ""
"Faites attention au traitement supplémentaire des vertex requis lors de "
"l'utilisation :"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:149
msgid "Skinning (skeletal animation)"
msgstr "Skinning (animation squelettique)"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:150
msgid "Morphs (shape keys)"
msgstr "Morphs (clés de forme)"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:151
msgid "Vertex-lit objects (common on mobile)"
msgstr "Objets éclairés par les sommets (communs sur mobile)"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:154
msgid "Pixel / fragment shaders - fill rate"
msgstr "Pixel / fragment shaders - taux de remplissage"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:156
msgid ""
"In contrast to vertex processing, the costs of fragment shading has "
"increased dramatically over the years. Screen resolutions have increased "
"(the area of a 4K screen is ``8,294,400`` pixels, versus ``307,200`` for an "
"old ``640x480`` VGA screen, that is 27x the area), but also the complexity "
"of fragment shaders has exploded. Physically based rendering requires "
"complex calculations for each fragment."
msgstr ""
"Contrairement au traitement des sommets, le coût des sahders de fragments a "
"augmenté de façon spectaculaire au fil des ans. Les résolutions d'écran ont "
"augmenté (la surface d'un écran 4K est de ``8,294,400`` pixels, contre "
"``307,200`` pixels pour un ancien écran VGA ``640x480``, soit 27 fois la "
"surface), mais la complexité des shaders de fragments a également explosé. "
"Le rendu basé sur la physique nécessite des calculs complexes pour chaque "
"fragment."

#: ../../docs/tutorials/optimization/gpu_optimization.rst:163
msgid ""
"You can test whether a project is fill rate limited quite easily. Turn off "
"vsync to prevent capping the frames per second, then compare the frames per "
"second when running with a large window, to running with a postage stamp "
"sized window (you may also benefit from similarly reducing your shadow map "
"size if using shadows). Usually you will find the fps increases quite a bit "
"using a small window, which indicates you are to some extent fill rate "
"limited. If on the other hand there is little to no increase in fps, then "
"your bottleneck lies elsewhere."
msgstr ""
"Vous pouvez vérifier assez facilement si un projet est limité en termes de "
"taux de remplissage. Désactivez vsync pour éviter de limiter le nombre "
"d'images par seconde, puis comparez les images par seconde lorsque vous "
"utilisez une grande fenêtre, à celles d'une fenêtre de la taille d'un timbre-"
"poste (vous pouvez également réduire de la même manière la taille de votre "
"carte des ombres si vous utilisez des ombres). En général, vous constaterez "
"que le nombre d'images par seconde augmente considérablement lorsque vous "
"utilisez une petite fenêtre, ce qui indique que votre taux de remplissage "
"est limité dans une certaine mesure. Si, en revanche, le nombre d'images par "
"seconde augmente peu ou pas du tout, alors votre goulot d'étranglement est "
"ailleurs."

#: ../../docs/tutorials/optimization/gpu_optimization.rst:172
msgid ""
"You can increase performance in a fill rate limited project by reducing the "
"amount of work the GPU has to do. You can do this by simplifying the shader "
"(perhaps turn off expensive options if you are using a :ref:`SpatialMaterial "
"<class_SpatialMaterial>`), or reducing the number and size of textures used."
msgstr ""
"Vous pouvez augmenter les performances dans un projet avec taux de "
"remplissage limité en réduisant la quantité de travail que le GPU doit "
"effectuer. Vous pouvez le faire en simplifiant le shader (peut-être en "
"désactivant les options coûteuses si vous utilisez un :ref:`SpatialMaterial "
"<class_SpatialMaterial>`), ou en réduisant le nombre et la taille des "
"textures utilisées."

#: ../../docs/tutorials/optimization/gpu_optimization.rst:177
msgid "Consider shipping simpler shaders for mobile."
msgstr "Envisagez d'utiliser des shaders plus simples pour les mobiles."

#: ../../docs/tutorials/optimization/gpu_optimization.rst:180
msgid "Reading textures"
msgstr "Lecture des textures"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:182
msgid ""
"The other factor in fragment shaders is the cost of reading textures. "
"Reading textures is an expensive operation (especially reading from several "
"in a single fragment shader), and also consider the filtering may add "
"expense to this (trilinear filtering between mipmaps, and averaging). "
"Reading textures is also expensive in power terms, which is a big issue on "
"mobiles."
msgstr ""
"L'autre facteur qui intervient dans les shaders de fragments est le coût de "
"la lecture des textures. La lecture des textures est une opération coûteuse "
"(en particulier la lecture de plusieurs textures dans un seul fragment "
"shader), et il faut également tenir compte du fait que le filtrage peut "
"ajouter des frais à cette opération (filtrage trilinéaire entre les mipmaps, "
"et calcul de moyenne). La lecture des textures est également coûteuse en "
"termes de puissance, ce qui est un gros problème sur les mobiles."

#: ../../docs/tutorials/optimization/gpu_optimization.rst:189
msgid "Texture compression"
msgstr "Compression de texture"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:191
msgid ""
"Godot compresses textures of 3D models when imported (VRAM compression) by "
"default. Video RAM compression is not as efficient in size as PNG or JPG "
"when stored, but increases performance enormously when drawing."
msgstr ""
"Godot compresse les textures des modèles 3D lorsqu'il sont (compression "
"VRAM) par défaut. La compression Video RAM n'est pas aussi efficace en "
"taille que PNG ou JPG lorsqu'elle est stockée, mais augmente "
"considérablement les performances lors du dessin."

#: ../../docs/tutorials/optimization/gpu_optimization.rst:195
msgid ""
"This is because the main goal of texture compression is bandwidth reduction "
"between memory and the GPU."
msgstr ""
"En effet, l'objectif principal de la compression de texture est la réduction "
"de la bande passante entre la mémoire et le GPU."

#: ../../docs/tutorials/optimization/gpu_optimization.rst:198
msgid ""
"In 3D, the shapes of objects depend more on the geometry than the texture, "
"so compression is generally not noticeable. In 2D, compression depends more "
"on shapes inside the textures, so the artifacts resulting from 2D "
"compression are more noticeable."
msgstr ""
"En 3D, les formes des objets dépendent plus de la géométrie que de la "
"texture, la compression n'est donc généralement pas perceptible. En 2D, la "
"compression dépend davantage des formes à l'intérieur des textures, de sorte "
"que les artefacts résultant de la compression 2D sont plus visibles."

#: ../../docs/tutorials/optimization/gpu_optimization.rst:203
msgid ""
"As a warning, most Android devices do not support texture compression of "
"textures with transparency (only opaque), so keep this in mind."
msgstr ""
"En guise d'avertissement, la plupart des appareils Android ne prennent pas "
"en charge la compression de texture des textures avec transparence "
"(seulement opaque), gardez ceci à l'esprit."

#: ../../docs/tutorials/optimization/gpu_optimization.rst:207
msgid "Post processing / shadows"
msgstr "Post-traitement / ombres"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:209
msgid ""
"Post processing effects and shadows can also be expensive in terms of "
"fragment shading activity. Always test the impact of these on different "
"hardware."
msgstr ""
"Les effets de post-traitement et les ombres peuvent également être coûteux "
"en termes d'activité des shaders de fragments. Testez toujours l'impact de "
"ces effets sur différents matériels."

#: ../../docs/tutorials/optimization/gpu_optimization.rst:212
msgid ""
"Reducing the size of shadow maps can increase performance, both in terms of "
"writing, and reading the maps."
msgstr ""
"La réduction de la taille des cartes des ombres peut améliorer les "
"performances, tant en termes d'écriture que de lecture des cartes."

#: ../../docs/tutorials/optimization/gpu_optimization.rst:216
msgid "Transparency / blending"
msgstr "Transparence / mélange"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:218
msgid ""
"Transparent items present particular problems for rendering efficiency. "
"Opaque items (especially in 3d) can be essentially rendered in any order and "
"the Z-buffer will ensure that only the front most objects get shaded. "
"Transparent or blended objects are different - in most cases they cannot "
"rely on the Z-buffer and must be rendered in \"painter's order\" (i.e. from "
"back to front) in order to look correct."
msgstr ""
"Les éléments transparents posent des problèmes particuliers d'efficacité de "
"rendu. Les objets opaques (surtout en 3d) peuvent être rendus dans n'importe "
"quel ordre et le tampon Z garantit que seuls les objets les plus visibles "
"sont traité par un shader. Les objets transparents ou mélangés sont "
"différents - dans la plupart des cas, ils ne peuvent pas compter sur le "
"tampon Z et doivent être rendus dans \"l'ordre du peintre\" (c'est-à-dire de "
"l'arrière vers l'avant) pour avoir une apparence correcte."

#: ../../docs/tutorials/optimization/gpu_optimization.rst:225
msgid ""
"The transparent items are also particularly bad for fill rate, because every "
"item has to be drawn, even if later transparent items will be drawn on top."
msgstr ""
"Les éléments transparents sont aussi particulièrement mauvais pour le taux "
"de remplissage, car chaque élément doit être dessiné, même si plus tard des "
"éléments transparents seront dessinés par-dessus."

#: ../../docs/tutorials/optimization/gpu_optimization.rst:228
msgid ""
"Opaque items don't have to do this. They can usually take advantage of the Z-"
"buffer by writing to the Z-buffer only first, then only performing the "
"fragment shader on the 'winning' fragment, the item that is at the front at "
"a particular pixel."
msgstr ""
"Les objets opaques n'ont pas à faire cela. Ils peuvent généralement tirer "
"parti du tampon Z en écrivant d'abord dans le tampon Z, puis en exécutant le "
"shader de fragment sur le fragment 'gagnant', l'élément qui se trouve à "
"l'avant d'un pixel particulier."

#: ../../docs/tutorials/optimization/gpu_optimization.rst:233
msgid ""
"Transparency is particularly expensive where multiple transparent items "
"overlap. It is usually better to use as small a transparent area as possible "
"in order to minimize these fill rate requirements, especially on mobile, "
"where fill rate is very expensive. Indeed, in many situations, rendering "
"more complex opaque geometry can end up being faster than using transparency "
"to \"cheat\"."
msgstr ""
"La transparence est particulièrement coûteuse lorsque plusieurs éléments "
"transparents se chevauchent. Il est généralement préférable d'utiliser une "
"zone transparente aussi petite que possible afin de minimiser ces exigences "
"de taux de remplissage, en particulier sur les téléphones portables, où le "
"taux de remplissage est très coûteux. En effet, dans de nombreuses "
"situations, rendre une géométrie opaque plus complexe peut s'avérer plus "
"rapide que d'utiliser la transparence pour \"tricher\"."

#: ../../docs/tutorials/optimization/gpu_optimization.rst:240
msgid "Multi-Platform Advice"
msgstr "Conseil multi-plateforme"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:242
msgid ""
"If you are aiming to release on multiple platforms, test `early` and test "
"`often` on all your platforms, especially mobile. Developing a game on "
"desktop but attempting to port to mobile at the last minute is a recipe for "
"disaster."
msgstr ""
"Si vous avez l'intention de publier sur plusieurs plates-formes, testez `au "
"début` et `souvent` sur toutes vos plates-formes, en particulier mobiles. "
"Développer un jeu sur un ordinateur de bureau puis essayer de le porter sur "
"le mobile à la dernière minute est une recette pour le désastre."

#: ../../docs/tutorials/optimization/gpu_optimization.rst:246
msgid ""
"In general you should design your game for the lowest common denominator, "
"then add optional enhancements for more powerful platforms. For example, you "
"may want to use the GLES2 backend for both desktop and mobile platforms "
"where you target both."
msgstr ""
"En général, vous devez concevoir votre jeu pour le plus petit dénominateur "
"commun, puis ajouter des améliorations optionnelles pour des plates-formes "
"plus puissantes. Par exemple, vous pouvez vouloir utiliser le backend GLES2 "
"pour les plateformes de bureau et les plateformes mobiles dans le cas où "
"vous ciblez les deux."

#: ../../docs/tutorials/optimization/gpu_optimization.rst:252
msgid "Mobile / tile renderers"
msgstr "Rendus mobile / tuile"

#: ../../docs/tutorials/optimization/gpu_optimization.rst:254
msgid ""
"GPUs on mobile devices work in dramatically different ways from GPUs on "
"desktop. Most mobile devices use tile renderers. Tile renderers split up the "
"screen into regular sized tiles that fit into super fast cache memory, and "
"reduce the reads and writes to main memory."
msgstr ""
"Les GPU des appareils mobiles fonctionnent de manière radicalement "
"différente des GPU des ordinateurs de bureau. La plupart des appareils "
"mobiles utilisent des rendus de tuiles. Ces derniers divisent l'écran en "
"tuiles de taille normale qui s'intègrent dans une mémoire cache super rapide "
"et réduisent les opérations de lecture et d'écriture dans la mémoire "
"principale."

#: ../../docs/tutorials/optimization/gpu_optimization.rst:259
msgid ""
"There are some downsides though, it can make certain techniques much more "
"complicated and expensive to perform. Tiles that rely on the results of "
"rendering in different tiles or on the results of earlier operations being "
"preserved can be very slow. Be very careful to test the performance of "
"shaders, viewport textures and post processing."
msgstr ""
"Il y a cependant quelques inconvénients, car certaines techniques peuvent "
"être beaucoup plus compliquées et coûteuses à mettre en œuvre. Les tuiles "
"qui reposent sur les résultats du rendu de différentes tuiles ou sur la "
"préservation des résultats d'opérations antérieures peuvent être très "
"lentes. Soyez très attentifs à tester les performances des shaders, des "
"textures de viewport et du post-traitement."
