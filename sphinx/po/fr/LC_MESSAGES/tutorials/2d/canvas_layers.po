# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2019, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-07-15 18:11+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../docs/tutorials/2d/canvas_layers.rst:4
msgid "Canvas layers"
msgstr "Couches du canevas"

#: ../../docs/tutorials/2d/canvas_layers.rst:7
msgid "Viewport and Canvas items"
msgstr "Eléments de fenêtre et de canevas"

#: ../../docs/tutorials/2d/canvas_layers.rst:9
msgid ""
"Regular 2D nodes, such as :ref:`Node2D <class_Node2D>` or :ref:`Control "
"<class_Control>` both inherit from :ref:`CanvasItem <class_CanvasItem>`, "
"which is the base for all 2D nodes. CanvasItems can be arranged in trees. "
"Each item will inherit its parent's transform. This means that when the "
"parent is moved, the children will move too."
msgstr ""
"Les nœuds 2D ordinaires, tels que :ref:`Node2D <class_Node2D>` ou :ref:"
"`Control <class_Control>` héritent tous deux de :ref:`CanvasItem "
"<class_CanvasItem>`, qui est la base de tous les nœuds 2D. Les objets "
"CanvasItems peuvent être organisés en arborescences. Ils hériteront de la "
"transformation de leurs parents. Cela signifie que lors du déplacement du "
"parent, les enfants seront également déplacés."

#: ../../docs/tutorials/2d/canvas_layers.rst:16
msgid ""
"CanvasItem nodes, and nodes inheriting from them, are direct or indirect "
"children of a :ref:`Viewport <class_Viewport>`, and will be displayed "
"through it."
msgstr ""
"Les nœuds CanvasItem, et les nœuds qui héritent d'eux sont des enfants "
"directs ou indirects d'une :ref:`Fenêtre d'affichage <class_Viewport>`, et "
"seront affichés à travers elle."

#: ../../docs/tutorials/2d/canvas_layers.rst:19
msgid ""
"A Viewport has the property :ref:`Viewport.canvas_transform "
"<class_Viewport_property_canvas_transform>`, which allows applying a custom :"
"ref:`Transform2D <class_Transform2D>` transform to the CanvasItem hierarchy "
"it contains. Nodes such as :ref:`Camera2D <class_Camera2D>` work by changing "
"that transform."
msgstr ""
"La fenêtre d'affichage a la propriété :ref:`Viewport.canvas_transform "
"<class_Viewport_property_canvas_transform>`, qui permet d'appliquer une "
"transformation personnalisée :ref:`Transform2D <class_Transform2D>` à la "
"hiérarchie CanvasItem qui la contient. Des nœuds tels que :ref:`Camera2D "
"<class_Camera2D>`, fonctionnent en modifiant cette transformation."

#: ../../docs/tutorials/2d/canvas_layers.rst:25
msgid ""
"Effects like scrolling are best achieved by manipulating the canvas "
"transform property. This approach is more efficient than moving the root "
"canvas item (and hence the whole scene)."
msgstr ""
"Les effets comme le défilement sont mieux réalisés en manipulant la "
"propriété de transformation de canevas. Cette approche est plus efficace que "
"de déplacer l’élément de canevas racine (et donc toute la scène)."

#: ../../docs/tutorials/2d/canvas_layers.rst:28
msgid ""
"Usually though, we don't want *everything* in the game or app to be subject "
"to the canvas transform. Examples of this are:"
msgstr ""
"Habituellement, cependant, nous ne voulons pas que *tout* dans le jeu ou "
"l’application soit soumis à la transformation du canevas. Voici quelques "
"exemples :"

#: ../../docs/tutorials/2d/canvas_layers.rst:31
msgid ""
"**Parallax Backgrounds**: Backgrounds that move slower than the rest of the "
"stage."
msgstr ""
"**Arrière-plans de parallaxe**: Arrière-plans qui bougent plus lentement que "
"le reste de la scène."

#: ../../docs/tutorials/2d/canvas_layers.rst:33
msgid ""
"**UI**: Think of a user interface (UI) or Heads-up display (HUD) "
"superimposed on our view of the game world. We want a life counter, score "
"display and other elements to retain their screen positions even when our "
"view of the game world is changing."
msgstr ""
"* * UI * *: pensez à une interface utilisateur (UI) ou à un Heads-up display "
"(HUD) superposé sur notre vision du monde du jeu. Nous voulons un compteur "
"de vie,  un affichage de score et d’autres éléments pour conserver leurs "
"positions à l'écran, même lorsque notre vision du monde du jeu change."

#: ../../docs/tutorials/2d/canvas_layers.rst:34
msgid ""
"**Transitions**: We may want visual effects used for transitions (fades, "
"blends) to remain at a fixed screen location."
msgstr ""
"**Transitions**: Nous pouvons vouloir des effets visuels utilisés pour les "
"transitions (fondus, mélanges) pour rester à un emplacement d’écran fixe."

#: ../../docs/tutorials/2d/canvas_layers.rst:36
msgid "How can these problems be solved in a single scene tree?"
msgstr ""
"Comment ces problèmes peuvent-ils être résolus dans une arborescence de "
"scène unique ?"

#: ../../docs/tutorials/2d/canvas_layers.rst:39
msgid "CanvasLayers"
msgstr "Couches de canevas"

#: ../../docs/tutorials/2d/canvas_layers.rst:41
msgid ""
"The answer is :ref:`CanvasLayer <class_CanvasLayer>`, which is a node that "
"adds a separate 2D rendering layer for all its children and grand-children. "
"Viewport children will draw by default at layer \"0\", while a CanvasLayer "
"will draw at any numeric layer. Layers with a greater number will be drawn "
"above those with a smaller number. CanvasLayers also have their own "
"transform and do not depend on the transform of other layers. This allows "
"the UI to be fixed in screen-space while our view on the game world changes."
msgstr ""
"La réponse est :ref:`CanvasLayer <class_CanvasLayer>`, qui est un nœud qui "
"ajoute un calque de rendu 2D distinct pour tous ses enfants et ses petits-"
"enfants. Les enfants de la fenêtre d'affichage dessineront par défaut au "
"calque \"0\", tandis qu’un CanvasLayer est dessiné à n’importe quelle couche "
"numérique. Les calques avec un plus grand nombre seront dessinés au-dessus "
"de ceux avec un plus petit nombre. Les CanvasLayer ont également leur propre "
"transformation et ne dépendent pas de la transformation des autres calques. "
"Cela permet de fixer l'interface utilisateur sur place pendant que le monde "
"bouge."

#: ../../docs/tutorials/2d/canvas_layers.rst:50
msgid ""
"An example of this is creating a parallax background. This can be done with "
"a CanvasLayer at layer \"-1\". The screen with the points, life counter and "
"pause button can also be created at layer \"1\"."
msgstr ""
"Un exemple de ceci est la création d'un fond en parallaxe. Cela peut être "
"fait avec un CanvasLayer au calque \"-1\". L'écran avec les points, le "
"compteur de durée de vie et le bouton de pause peuvent également être créés "
"au calque \"1\"."

#: ../../docs/tutorials/2d/canvas_layers.rst:54
msgid "Here's a diagram of how it looks:"
msgstr "Voici un diagramme de sa représentation :"

#: ../../docs/tutorials/2d/canvas_layers.rst:58
msgid ""
"CanvasLayers are independent of tree order, and they only depend on their "
"layer number, so they can be instantiated when needed."
msgstr ""
"Les CanvasLayers sont indépendants de l'ordre des arborescences, ils "
"dépendent uniquement de leur numéro de couche, ainsi Ils peuvent être "
"instanciés si nécessaire."

#: ../../docs/tutorials/2d/canvas_layers.rst:61
msgid ""
"CanvasLayers aren't necessary to control the drawing order of nodes. The "
"standard way to ensuring that a node is  correctly drawn 'in front' or "
"'behind' others is to manipulate the order of the nodes in the scene panel. "
"Perhaps counterintuitively, the topmost nodes in the scene panel are drawn "
"on *behind* lower ones in the viewport. 2d nodes also have a property for "
"controlling their drawing order (see :ref:`Node2D.z_index "
"<class_Node2D_property_z_index>`)."
msgstr ""
"CanvasLayers n'est pas nécessaire pour contrôler l'ordre de dessin des "
"nœuds. La façon standard de s'assurer qu'un nœud est correctement dessiné \" "
"devant \" ou \" derrière \" les autres est de manipuler l'ordre des nœuds "
"dans le panneau de scène. Contre-intuitivement peut-être, les nœuds les plus "
"en haut du panneau de scène sont dessinés sur les nœuds inférieurs *en "
"arrière* de la fenêtre d'affichage. Les nœuds 2d ont également une propriété "
"pour contrôler leur ordre de dessin (voir :ref:`Node2D.z_index "
"<class_Node2D_property_z_index>`)."
