# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2021, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-12-21 17:14+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Canvas layers"
msgstr "Слои холста"

msgid "Viewport and Canvas items"
msgstr "Узлы Viewport и CanvasItem"

#, fuzzy
msgid ""
":ref:`CanvasItem <class_CanvasItem>` is the base for all 2D nodes, be it "
"regular 2D nodes, such as :ref:`Node2D <class_Node2D>`, or :ref:`Control "
"<class_Control>`. Both inherit from :ref:`CanvasItem <class_CanvasItem>`. "
"You can arrange canvas items in trees. Each item will inherit its parent's "
"transform: when the parent moves, its children move too."
msgstr ""
"Обычные 2D-узлы, такие как :ref:`Node2D <class_Node2D>` или :ref:`Control "
"<class_Control>` , наследуются от :ref:`CanvasItem <class_CanvasItem>`, "
"который является базой для всех 2D-узлов. Узлы CanvasItem можно группировать "
"в деревья. Каждый узел при этом будет наследовать преобразования своего "
"родителя. Это означает, что когда родитель перемещается, дети тоже будут "
"перемещаться."

#, fuzzy
msgid ""
"CanvasItem nodes, and nodes inheriting from them, are direct or indirect "
"children of a :ref:`Viewport <class_Viewport>`, that display them."
msgstr ""
"Узлы CanvasItem и узлы, унаследованные от них, являются прямыми или "
"косвенными дочерними элементами объекта :ref:`Viewport <class_Viewport>` и "
"будут отображаться через него."

#, fuzzy
msgid ""
"A Viewport has the property :ref:`Viewport.canvas_transform "
"<class_Viewport_property_canvas_transform>`, allows to apply a custom :ref:"
"`Transform2D <class_Transform2D>` transform to the CanvasItem hierarchy it "
"contains. Nodes such as :ref:`Camera2D <class_Camera2D>` work by changing "
"that transform."
msgstr ""
"Viewport имеет свойство :ref:`Viewport.canvas_transform "
"<class_Viewport_property_canvas_transform>`, которое позволяет применять "
"настраиваемое преобразование :ref:`Transform2D <class_Transform2D>` к "
"иерархии CanvasItem, которую он содержит. Такие узлы, как :ref:`Camera2D "
"<class_Camera2D>` работают, изменяя это преобразование."

#, fuzzy
msgid ""
"To achieve effects like scrolling, manipulating the canvas transform "
"property is more efficient than moving the root canvas item and the entire "
"scene with it."
msgstr ""
"Такие эффекты, как прокрутка, лучше всего достигаются путём изменения "
"свойства преобразования холста. Этот подход более эффективен, чем "
"перемещение корневого элемента холста (и, следовательно, всей сцены)."

msgid ""
"Usually though, we don't want *everything* in the game or app to be subject "
"to the canvas transform. For example:"
msgstr ""
"Однако обычно мы не хотим, чтобы *всё* в игре или приложении подвергалось "
"преобразованию холста. Примеры:"

msgid ""
"**Parallax Backgrounds**: Backgrounds that move slower than the rest of the "
"stage."
msgstr ""
"**Параллакс-фоны**: Фоновые изображения которые двигаются медленнее "
"остальной сцены."

#, fuzzy
msgid ""
"**UI**: Think of a user interface (UI) or head-up display (HUD) superimposed "
"on our view of the game world. We want a life counter, score display and "
"other elements to retain their screen positions even when our view of the "
"game world changes."
msgstr ""
"**Интерфейс**: пользовательский интерфейс (UI) или Heads-up display (HUD) "
"накладываются поверх изображения игрового мира. Мы хотим, чтобы счётчик "
"жизней, отображение очков и другие элементы сохраняли свои позиции на экране "
"независимо от перемещений персонажа."

msgid ""
"**Transitions**: We may want visual effects used for transitions (fades, "
"blends) to remain at a fixed screen location."
msgstr ""
"**Переходы**: нам может понадобиться, чтобы эффекты, используемые для "
"переходов (затухания, смешивания), постоянно оставались в определённой части "
"окна."

msgid "How can these problems be solved in a single scene tree?"
msgstr "Как можно решить эти проблемы в едином дереве сцены?"

msgid "CanvasLayers"
msgstr "Узел CanvasLayer"

msgid ""
"The answer is :ref:`CanvasLayer <class_CanvasLayer>`, which is a node that "
"adds a separate 2D rendering layer for all its children and grand-children. "
"Viewport children will draw by default at layer \"0\", while a CanvasLayer "
"will draw at any numeric layer. Layers with a greater number will be drawn "
"above those with a smaller number. CanvasLayers also have their own "
"transform and do not depend on the transform of other layers. This allows "
"the UI to be fixed in screen-space while our view on the game world changes."
msgstr ""
"Ответом будет :ref:`CanvasLayer <class_CanvasLayer>` - это узел, который "
"добавляет отдельный слой 2D-рендеринга для всех своих дочерних и внучатых "
"элементов. По умолчанию дочерние элементы Viewport будут рисоваться на "
"нулевом слое, а CanvasLayer - на любом слое с номером, отличным от нуля. "
"Слои с большим номером будут нарисованы над слоями с меньшим номером. При "
"этом каждый CanvasLayer имеет собственное преобразование и не зависит от "
"преобразования других слоёв. Это позволяет зафиксировать пользовательский "
"интерфейс в пространстве экрана, в то время как изображение игрового мира "
"будет изменяется."

msgid ""
"An example of this is creating a parallax background. This can be done with "
"a CanvasLayer at layer \"-1\". The screen with the points, life counter and "
"pause button can also be created at layer \"1\"."
msgstr ""
"Примером этого является создание параллакс-фона. Его можно сделать с помощью "
"CanvasLayer на слое «-1». А отображение очков, счётчика жизней и кнопки "
"паузы при этом можно расположить на слое «1»."

msgid "Here's a diagram of how it looks:"
msgstr "Вот схема того, как это выглядит:"

msgid ""
"CanvasLayers are independent of tree order, and they only depend on their "
"layer number, so they can be instantiated when needed."
msgstr ""
"Обработка узлов CanvasLayer не зависит от их порядкового номера в дереве "
"сцены - только от номера их слоя; поэтому они могут создаться по мере "
"необходимости."

msgid ""
"CanvasLayers aren't necessary to control the drawing order of nodes. The "
"standard way to ensuring that a node is  correctly drawn 'in front' or "
"'behind' others is to manipulate the order of the nodes in the scene panel. "
"Perhaps counterintuitively, the topmost nodes in the scene panel are drawn "
"on *behind* lower ones in the viewport. 2d nodes also have a property for "
"controlling their drawing order (see :ref:`Node2D.z_index "
"<class_Node2D_property_z_index>`)."
msgstr ""
"Для управления порядком рисования узлов CanvasLayer не требуется. Обычно, "
"чтобы переместить узел на передний или на задний план, достаточно "
"переместить его в дереве сцены. Это может показаться неочевидным, но чем "
"выше узел в дереве на панели сцены, тем дальше от зрителя он рисуется. Кроме "
"того, 2D-узлы имеют специальный параметр для управления порядком рисования "
"(см. :ref:`Node2D.z_index <class_Node2D_property_z_index>`)."
