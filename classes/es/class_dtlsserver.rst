:github_url: hide

.. Generated automatically by doc/tools/make_rst.py in Godot's source tree.
.. DO NOT EDIT THIS FILE, but the DTLSServer.xml source instead.
.. The source is found in doc/classes or modules/<name>/doc_classes.

.. _class_DTLSServer:

DTLSServer
==========

**Inherits:** :ref:`Reference<class_Reference>` **<** :ref:`Object<class_Object>`

Clase de ayuda para implementar un servidor DTLS.

Descripción
----------------------

Esta clase se utiliza para almacenar el estado de un servidor DTLS. Al :ref:`setup<class_DTLSServer_method_setup>` convierte los :ref:`PacketPeerUDP<class_PacketPeerUDP>` conectados a :ref:`PacketPeerDTLS<class_PacketPeerDTLS>` aceptándolos a través del :ref:`take_connection<class_DTLSServer_method_take_connection>` como clientes DTLS. Bajo el capó, esta clase se utiliza para almacenar el estado de DTLS y las cookies del servidor. La razón por la que el estado y las cookies son necesarios está fuera del alcance de esta documentación.

A continuación un pequeño ejemplo de cómo utilizarlo:

::

    # server.gd
    extends Node
    
    var dtlsServidor := DTLSServer.new()
    var udpServidor := UDPServer.new()
    var pares = []
    
    func _ready():
        UDPServidor.listen(4242)
        var clave = load("clave.key") # Tu clave privada.
        var certificado = load("certificado.crt") # Tu certificado X509.
        dtlsServidor.setup(clave, certificado)
    
    func _process(delta):
        while udpServidor.is_connection_available():
            var par : PacketPeerUDP = udpServidor.take_connection()
            var dtls_par : PacketPeerDTLS = dtlsServidor.take_connection(par)
            if dtls_par.get_status() != PacketPeerDTLS.STATUS_HANDSHAKING:
                continue # Es normal que aproximadamente la mitad de las conexiones fallen debido al intercambio de cookies.
            print("Par conectado!")
            pares.append(dtls_par)
        for p in pares:
            p.poll() # Debe hacer poll para actualizar el estado.
            if p.get_status() == PacketPeerDTLS.STATUS_CONNECTED:
                while p.get_available_packet_count() > 0:
                    print("Mensaje recibido desde el cliente: %s" % p.get_packet().get_string_from_utf8())
                    p.put_packet("Hola cliente DTLS".to_utf8())

::

    # client.gd
    extends Node
    
    var dtls := PacketPeerDTLS.new()
    var udp := PacketPeerUDP.new()
    var conectado = false
    
    func _ready():
        udp.connect_to_host("127.0.0.1", 4242)
        dtls.connect_to_peer(udp, false) # Usa verdadero en producción para la validación del certifícado!
    
    func _process(delta):
        dtls.poll()
        if dtls.get_status() == PacketPeerDTLS.STATUS_CONNECTED:
            if !conectado:
                # Intenta conectar con el servidor
                dtls.put_packet("La respuesta es ... 42!".to_utf8())
            while dtls.get_available_packet_count() > 0:
                print("Conectado: %s" % dtls.get_packet().get_string_from_utf8())
                conectado = true

Métodos
--------------

+---------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| :ref:`Error<enum_@GlobalScope_Error>`       | :ref:`setup<class_DTLSServer_method_setup>` **(** :ref:`CryptoKey<class_CryptoKey>` key, :ref:`X509Certificate<class_X509Certificate>` certificate, :ref:`X509Certificate<class_X509Certificate>` chain=null **)** |
+---------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| :ref:`PacketPeerDTLS<class_PacketPeerDTLS>` | :ref:`take_connection<class_DTLSServer_method_take_connection>` **(** :ref:`PacketPeerUDP<class_PacketPeerUDP>` udp_peer **)**                                                                                     |
+---------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

Descripciones de Métodos
------------------------------------------------

.. _class_DTLSServer_method_setup:

- :ref:`Error<enum_@GlobalScope_Error>` **setup** **(** :ref:`CryptoKey<class_CryptoKey>` key, :ref:`X509Certificate<class_X509Certificate>` certificate, :ref:`X509Certificate<class_X509Certificate>` chain=null **)**

Configurar el servidor de DTLS para usar el ``private_key`` dado y proporcionar el ``certificate`` dado a los clientes. Puede pasar el parámetro opcional ``chain`` para proporcionar información adicional de la cadena de CA junto con el certificado.

----

.. _class_DTLSServer_method_take_connection:

- :ref:`PacketPeerDTLS<class_PacketPeerDTLS>` **take_connection** **(** :ref:`PacketPeerUDP<class_PacketPeerUDP>` udp_peer **)**

Try to initiate the DTLS handshake with the given ``udp_peer`` which must be already connected (see :ref:`PacketPeerUDP.connect_to_host<class_PacketPeerUDP_method_connect_to_host>`).

\ **Note:** You must check that the state of the return PacketPeerUDP is :ref:`PacketPeerDTLS.STATUS_HANDSHAKING<class_PacketPeerDTLS_constant_STATUS_HANDSHAKING>`, as it is normal that 50% of the new connections will be invalid due to cookie exchange.

.. |virtual| replace:: :abbr:`virtual (This method should typically be overridden by the user to have any effect.)`
.. |const| replace:: :abbr:`const (This method has no side effects. It doesn't modify any of the instance's member variables.)`
.. |vararg| replace:: :abbr:`vararg (This method accepts any number of arguments after the ones described here.)`
