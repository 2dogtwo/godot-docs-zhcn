:github_url: hide

.. Generated automatically by doc/tools/make_rst.py in Godot's source tree.
.. DO NOT EDIT THIS FILE, but the RigidBody.xml source instead.
.. The source is found in doc/classes or modules/<name>/doc_classes.

.. _class_RigidBody:

RigidBody
=========

**Inherits:** :ref:`PhysicsBody<class_PhysicsBody>` **<** :ref:`CollisionObject<class_CollisionObject>` **<** :ref:`Spatial<class_Spatial>` **<** :ref:`Node<class_Node>` **<** :ref:`Object<class_Object>`

**Inherited By:** :ref:`VehicleBody<class_VehicleBody>`

Cuerpo físico cuya posición se determina a través de la simulación física en el espacio 3D.

Descripción
----------------------

This is the node that implements full 3D physics. This means that you do not control a RigidBody directly. Instead, you can apply forces to it (gravity, impulses, etc.), and the physics simulation will calculate the resulting movement, collision, bouncing, rotating, etc.

A RigidBody has 4 behavior :ref:`mode<class_RigidBody_property_mode>`\ s: Rigid, Static, Character, and Kinematic.

\ **Note:** Don't change a RigidBody's position every frame or very often. Sporadic changes work fine, but physics runs at a different granularity (fixed Hz) than usual rendering (process callback) and maybe even in a separate thread, so changing this from a process loop may result in strange behavior. If you need to directly affect the body's state, use :ref:`_integrate_forces<class_RigidBody_method__integrate_forces>`, which allows you to directly access the physics state.

If you need to override the default physics behavior, you can write a custom force integration function. See :ref:`custom_integrator<class_RigidBody_property_custom_integrator>`.

With Bullet physics (the default), the center of mass is the RigidBody3D center. With GodotPhysics, the center of mass is the average of the :ref:`CollisionShape<class_CollisionShape>` centers.

Tutoriales
--------------------

- :doc:`Physics introduction <../tutorials/physics/physics_introduction>`

- `3D Truck Town Demo <https://godotengine.org/asset-library/asset/524>`__

- `3D Physics Tests Demo <https://godotengine.org/asset-library/asset/675>`__

Propiedades
----------------------

+-----------------------------------------------+--------------------------------------------------------------------------------------+------------------------+
| :ref:`float<class_float>`                     | :ref:`angular_damp<class_RigidBody_property_angular_damp>`                           | ``-1.0``               |
+-----------------------------------------------+--------------------------------------------------------------------------------------+------------------------+
| :ref:`Vector3<class_Vector3>`                 | :ref:`angular_velocity<class_RigidBody_property_angular_velocity>`                   | ``Vector3( 0, 0, 0 )`` |
+-----------------------------------------------+--------------------------------------------------------------------------------------+------------------------+
| :ref:`bool<class_bool>`                       | :ref:`axis_lock_angular_x<class_RigidBody_property_axis_lock_angular_x>`             | ``false``              |
+-----------------------------------------------+--------------------------------------------------------------------------------------+------------------------+
| :ref:`bool<class_bool>`                       | :ref:`axis_lock_angular_y<class_RigidBody_property_axis_lock_angular_y>`             | ``false``              |
+-----------------------------------------------+--------------------------------------------------------------------------------------+------------------------+
| :ref:`bool<class_bool>`                       | :ref:`axis_lock_angular_z<class_RigidBody_property_axis_lock_angular_z>`             | ``false``              |
+-----------------------------------------------+--------------------------------------------------------------------------------------+------------------------+
| :ref:`bool<class_bool>`                       | :ref:`axis_lock_linear_x<class_RigidBody_property_axis_lock_linear_x>`               | ``false``              |
+-----------------------------------------------+--------------------------------------------------------------------------------------+------------------------+
| :ref:`bool<class_bool>`                       | :ref:`axis_lock_linear_y<class_RigidBody_property_axis_lock_linear_y>`               | ``false``              |
+-----------------------------------------------+--------------------------------------------------------------------------------------+------------------------+
| :ref:`bool<class_bool>`                       | :ref:`axis_lock_linear_z<class_RigidBody_property_axis_lock_linear_z>`               | ``false``              |
+-----------------------------------------------+--------------------------------------------------------------------------------------+------------------------+
| :ref:`float<class_float>`                     | :ref:`bounce<class_RigidBody_property_bounce>`                                       |                        |
+-----------------------------------------------+--------------------------------------------------------------------------------------+------------------------+
| :ref:`bool<class_bool>`                       | :ref:`can_sleep<class_RigidBody_property_can_sleep>`                                 | ``true``               |
+-----------------------------------------------+--------------------------------------------------------------------------------------+------------------------+
| :ref:`bool<class_bool>`                       | :ref:`contact_monitor<class_RigidBody_property_contact_monitor>`                     | ``false``              |
+-----------------------------------------------+--------------------------------------------------------------------------------------+------------------------+
| :ref:`int<class_int>`                         | :ref:`contacts_reported<class_RigidBody_property_contacts_reported>`                 | ``0``                  |
+-----------------------------------------------+--------------------------------------------------------------------------------------+------------------------+
| :ref:`bool<class_bool>`                       | :ref:`continuous_cd<class_RigidBody_property_continuous_cd>`                         | ``false``              |
+-----------------------------------------------+--------------------------------------------------------------------------------------+------------------------+
| :ref:`bool<class_bool>`                       | :ref:`custom_integrator<class_RigidBody_property_custom_integrator>`                 | ``false``              |
+-----------------------------------------------+--------------------------------------------------------------------------------------+------------------------+
| :ref:`float<class_float>`                     | :ref:`friction<class_RigidBody_property_friction>`                                   |                        |
+-----------------------------------------------+--------------------------------------------------------------------------------------+------------------------+
| :ref:`float<class_float>`                     | :ref:`gravity_scale<class_RigidBody_property_gravity_scale>`                         | ``1.0``                |
+-----------------------------------------------+--------------------------------------------------------------------------------------+------------------------+
| :ref:`float<class_float>`                     | :ref:`linear_damp<class_RigidBody_property_linear_damp>`                             | ``-1.0``               |
+-----------------------------------------------+--------------------------------------------------------------------------------------+------------------------+
| :ref:`Vector3<class_Vector3>`                 | :ref:`linear_velocity<class_RigidBody_property_linear_velocity>`                     | ``Vector3( 0, 0, 0 )`` |
+-----------------------------------------------+--------------------------------------------------------------------------------------+------------------------+
| :ref:`float<class_float>`                     | :ref:`mass<class_RigidBody_property_mass>`                                           | ``1.0``                |
+-----------------------------------------------+--------------------------------------------------------------------------------------+------------------------+
| :ref:`Mode<enum_RigidBody_Mode>`              | :ref:`mode<class_RigidBody_property_mode>`                                           | ``0``                  |
+-----------------------------------------------+--------------------------------------------------------------------------------------+------------------------+
| :ref:`PhysicsMaterial<class_PhysicsMaterial>` | :ref:`physics_material_override<class_RigidBody_property_physics_material_override>` |                        |
+-----------------------------------------------+--------------------------------------------------------------------------------------+------------------------+
| :ref:`bool<class_bool>`                       | :ref:`sleeping<class_RigidBody_property_sleeping>`                                   | ``false``              |
+-----------------------------------------------+--------------------------------------------------------------------------------------+------------------------+
| :ref:`float<class_float>`                     | :ref:`weight<class_RigidBody_property_weight>`                                       | ``9.8``                |
+-----------------------------------------------+--------------------------------------------------------------------------------------+------------------------+

Métodos
--------------

+---------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------+
| void                      | :ref:`_integrate_forces<class_RigidBody_method__integrate_forces>` **(** :ref:`PhysicsDirectBodyState<class_PhysicsDirectBodyState>` state **)** |virtual| |
+---------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------+
| void                      | :ref:`add_central_force<class_RigidBody_method_add_central_force>` **(** :ref:`Vector3<class_Vector3>` force **)**                                         |
+---------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------+
| void                      | :ref:`add_force<class_RigidBody_method_add_force>` **(** :ref:`Vector3<class_Vector3>` force, :ref:`Vector3<class_Vector3>` position **)**                 |
+---------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------+
| void                      | :ref:`add_torque<class_RigidBody_method_add_torque>` **(** :ref:`Vector3<class_Vector3>` torque **)**                                                      |
+---------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------+
| void                      | :ref:`apply_central_impulse<class_RigidBody_method_apply_central_impulse>` **(** :ref:`Vector3<class_Vector3>` impulse **)**                               |
+---------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------+
| void                      | :ref:`apply_impulse<class_RigidBody_method_apply_impulse>` **(** :ref:`Vector3<class_Vector3>` position, :ref:`Vector3<class_Vector3>` impulse **)**       |
+---------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------+
| void                      | :ref:`apply_torque_impulse<class_RigidBody_method_apply_torque_impulse>` **(** :ref:`Vector3<class_Vector3>` impulse **)**                                 |
+---------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------+
| :ref:`bool<class_bool>`   | :ref:`get_axis_lock<class_RigidBody_method_get_axis_lock>` **(** :ref:`BodyAxis<enum_PhysicsServer_BodyAxis>` axis **)** |const|                           |
+---------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------+
| :ref:`Array<class_Array>` | :ref:`get_colliding_bodies<class_RigidBody_method_get_colliding_bodies>` **(** **)** |const|                                                               |
+---------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------+
| :ref:`Basis<class_Basis>` | :ref:`get_inverse_inertia_tensor<class_RigidBody_method_get_inverse_inertia_tensor>` **(** **)**                                                           |
+---------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------+
| void                      | :ref:`set_axis_lock<class_RigidBody_method_set_axis_lock>` **(** :ref:`BodyAxis<enum_PhysicsServer_BodyAxis>` axis, :ref:`bool<class_bool>` lock **)**     |
+---------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------+
| void                      | :ref:`set_axis_velocity<class_RigidBody_method_set_axis_velocity>` **(** :ref:`Vector3<class_Vector3>` axis_velocity **)**                                 |
+---------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------+

Señales
--------------

.. _class_RigidBody_signal_body_entered:

- **body_entered** **(** :ref:`Node<class_Node>` body **)**

Emitted when a collision with another :ref:`PhysicsBody<class_PhysicsBody>` or :ref:`GridMap<class_GridMap>` occurs. Requires :ref:`contact_monitor<class_RigidBody_property_contact_monitor>` to be set to ``true`` and :ref:`contacts_reported<class_RigidBody_property_contacts_reported>` to be set high enough to detect all the collisions. :ref:`GridMap<class_GridMap>`\ s are detected if the :ref:`MeshLibrary<class_MeshLibrary>` has Collision :ref:`Shape<class_Shape>`\ s.

\ ``body`` the :ref:`Node<class_Node>`, if it exists in the tree, of the other :ref:`PhysicsBody<class_PhysicsBody>` or :ref:`GridMap<class_GridMap>`.

----

.. _class_RigidBody_signal_body_exited:

- **body_exited** **(** :ref:`Node<class_Node>` body **)**

Emitted when the collision with another :ref:`PhysicsBody<class_PhysicsBody>` or :ref:`GridMap<class_GridMap>` ends. Requires :ref:`contact_monitor<class_RigidBody_property_contact_monitor>` to be set to ``true`` and :ref:`contacts_reported<class_RigidBody_property_contacts_reported>` to be set high enough to detect all the collisions. :ref:`GridMap<class_GridMap>`\ s are detected if the :ref:`MeshLibrary<class_MeshLibrary>` has Collision :ref:`Shape<class_Shape>`\ s.

\ ``body`` the :ref:`Node<class_Node>`, if it exists in the tree, of the other :ref:`PhysicsBody<class_PhysicsBody>` or :ref:`GridMap<class_GridMap>`.

----

.. _class_RigidBody_signal_body_shape_entered:

- **body_shape_entered** **(** :ref:`RID<class_RID>` body_rid, :ref:`Node<class_Node>` body, :ref:`int<class_int>` body_shape_index, :ref:`int<class_int>` local_shape_index **)**

Emitted when one of this RigidBody's :ref:`Shape<class_Shape>`\ s collides with another :ref:`PhysicsBody<class_PhysicsBody>` or :ref:`GridMap<class_GridMap>`'s :ref:`Shape<class_Shape>`\ s. Requires :ref:`contact_monitor<class_RigidBody_property_contact_monitor>` to be set to ``true`` and :ref:`contacts_reported<class_RigidBody_property_contacts_reported>` to be set high enough to detect all the collisions. :ref:`GridMap<class_GridMap>`\ s are detected if the :ref:`MeshLibrary<class_MeshLibrary>` has Collision :ref:`Shape<class_Shape>`\ s.

\ ``body_rid`` the :ref:`RID<class_RID>` of the other :ref:`PhysicsBody<class_PhysicsBody>` or :ref:`MeshLibrary<class_MeshLibrary>`'s :ref:`CollisionObject<class_CollisionObject>` used by the :ref:`PhysicsServer<class_PhysicsServer>`.

\ ``body`` the :ref:`Node<class_Node>`, if it exists in the tree, of the other :ref:`PhysicsBody<class_PhysicsBody>` or :ref:`GridMap<class_GridMap>`.

\ ``body_shape_index`` the index of the :ref:`Shape<class_Shape>` of the other :ref:`PhysicsBody<class_PhysicsBody>` or :ref:`GridMap<class_GridMap>` used by the :ref:`PhysicsServer<class_PhysicsServer>`. Get the :ref:`CollisionShape<class_CollisionShape>` node with ``body.shape_owner_get_owner(body_shape_index)``.

\ ``local_shape_index`` the index of the :ref:`Shape<class_Shape>` of this RigidBody used by the :ref:`PhysicsServer<class_PhysicsServer>`. Get the :ref:`CollisionShape<class_CollisionShape>` node with ``self.shape_owner_get_owner(local_shape_index)``.

\ **Note:** Bullet physics cannot identify the shape index when using a :ref:`ConcavePolygonShape<class_ConcavePolygonShape>`. Don't use multiple :ref:`CollisionShape<class_CollisionShape>`\ s when using a :ref:`ConcavePolygonShape<class_ConcavePolygonShape>` with Bullet physics if you need shape indices.

----

.. _class_RigidBody_signal_body_shape_exited:

- **body_shape_exited** **(** :ref:`RID<class_RID>` body_rid, :ref:`Node<class_Node>` body, :ref:`int<class_int>` body_shape_index, :ref:`int<class_int>` local_shape_index **)**

Emitted when the collision between one of this RigidBody's :ref:`Shape<class_Shape>`\ s and another :ref:`PhysicsBody<class_PhysicsBody>` or :ref:`GridMap<class_GridMap>`'s :ref:`Shape<class_Shape>`\ s ends. Requires :ref:`contact_monitor<class_RigidBody_property_contact_monitor>` to be set to ``true`` and :ref:`contacts_reported<class_RigidBody_property_contacts_reported>` to be set high enough to detect all the collisions. :ref:`GridMap<class_GridMap>`\ s are detected if the :ref:`MeshLibrary<class_MeshLibrary>` has Collision :ref:`Shape<class_Shape>`\ s.

\ ``body_rid`` the :ref:`RID<class_RID>` of the other :ref:`PhysicsBody<class_PhysicsBody>` or :ref:`MeshLibrary<class_MeshLibrary>`'s :ref:`CollisionObject<class_CollisionObject>` used by the :ref:`PhysicsServer<class_PhysicsServer>`. :ref:`GridMap<class_GridMap>`\ s are detected if the Meshes have :ref:`Shape<class_Shape>`\ s.

\ ``body`` the :ref:`Node<class_Node>`, if it exists in the tree, of the other :ref:`PhysicsBody<class_PhysicsBody>` or :ref:`GridMap<class_GridMap>`.

\ ``body_shape_index`` the index of the :ref:`Shape<class_Shape>` of the other :ref:`PhysicsBody<class_PhysicsBody>` or :ref:`GridMap<class_GridMap>` used by the :ref:`PhysicsServer<class_PhysicsServer>`. Get the :ref:`CollisionShape<class_CollisionShape>` node with ``body.shape_owner_get_owner(body_shape_index)``.

\ ``local_shape_index`` the index of the :ref:`Shape<class_Shape>` of this RigidBody used by the :ref:`PhysicsServer<class_PhysicsServer>`. Get the :ref:`CollisionShape<class_CollisionShape>` node with ``self.shape_owner_get_owner(local_shape_index)``.

\ **Note:** Bullet physics cannot identify the shape index when using a :ref:`ConcavePolygonShape<class_ConcavePolygonShape>`. Don't use multiple :ref:`CollisionShape<class_CollisionShape>`\ s when using a :ref:`ConcavePolygonShape<class_ConcavePolygonShape>` with Bullet physics if you need shape indices.

----

.. _class_RigidBody_signal_sleeping_state_changed:

- **sleeping_state_changed** **(** **)**

Emitida cuando el motor físico cambia el estado de sueño del cuerpo.

\ **Nota:** Cambiar el valor :ref:`sleeping<class_RigidBody_property_sleeping>` no activará esta señal. Sólo se emite si el motor de física cambia el estado de sueño o si se utiliza ``emit_signal("sleeping_state_changed")``.

Enumeraciones
--------------------------

.. _enum_RigidBody_Mode:

.. _class_RigidBody_constant_MODE_RIGID:

.. _class_RigidBody_constant_MODE_STATIC:

.. _class_RigidBody_constant_MODE_CHARACTER:

.. _class_RigidBody_constant_MODE_KINEMATIC:

enum **Mode**:

- **MODE_RIGID** = **0** --- Modo de cuerpo rígido. Este es el estado "natural" de un cuerpo rígido. Es afectado por fuerzas, y puede moverse, rotar y ser afectado por el código de usuario.

- **MODE_STATIC** = **1** --- Static mode. The body behaves like a :ref:`StaticBody<class_StaticBody>`, and can only move by user code.

- **MODE_CHARACTER** = **2** --- Modo de cuerpo de personaje. Se comporta como un cuerpo rígido, pero no puede girar.

- **MODE_KINEMATIC** = **3** --- Kinematic body mode. The body behaves like a :ref:`KinematicBody<class_KinematicBody>`, and can only move by user code.

Descripciones de Propiedades
--------------------------------------------------------

.. _class_RigidBody_property_angular_damp:

- :ref:`float<class_float>` **angular_damp**

+-----------+-------------------------+
| *Default* | ``-1.0``                |
+-----------+-------------------------+
| *Setter*  | set_angular_damp(value) |
+-----------+-------------------------+
| *Getter*  | get_angular_damp()      |
+-----------+-------------------------+

Damps RigidBody's rotational forces.

See :ref:`ProjectSettings.physics/3d/default_angular_damp<class_ProjectSettings_property_physics/3d/default_angular_damp>` for more details about damping.

----

.. _class_RigidBody_property_angular_velocity:

- :ref:`Vector3<class_Vector3>` **angular_velocity**

+-----------+-----------------------------+
| *Default* | ``Vector3( 0, 0, 0 )``      |
+-----------+-----------------------------+
| *Setter*  | set_angular_velocity(value) |
+-----------+-----------------------------+
| *Getter*  | get_angular_velocity()      |
+-----------+-----------------------------+

The body's rotational velocity in axis-angle format. The magnitude of the vector is the rotation rate in *radians* per second.

----

.. _class_RigidBody_property_axis_lock_angular_x:

- :ref:`bool<class_bool>` **axis_lock_angular_x**

+-----------+----------------------+
| *Default* | ``false``            |
+-----------+----------------------+
| *Setter*  | set_axis_lock(value) |
+-----------+----------------------+
| *Getter*  | get_axis_lock()      |
+-----------+----------------------+

Bloquea la rotación del cuerpo en el eje X.

----

.. _class_RigidBody_property_axis_lock_angular_y:

- :ref:`bool<class_bool>` **axis_lock_angular_y**

+-----------+----------------------+
| *Default* | ``false``            |
+-----------+----------------------+
| *Setter*  | set_axis_lock(value) |
+-----------+----------------------+
| *Getter*  | get_axis_lock()      |
+-----------+----------------------+

Bloquea la rotación del cuerpo en el eje Y.

----

.. _class_RigidBody_property_axis_lock_angular_z:

- :ref:`bool<class_bool>` **axis_lock_angular_z**

+-----------+----------------------+
| *Default* | ``false``            |
+-----------+----------------------+
| *Setter*  | set_axis_lock(value) |
+-----------+----------------------+
| *Getter*  | get_axis_lock()      |
+-----------+----------------------+

Bloquea la rotación del cuerpo en el eje Z.

----

.. _class_RigidBody_property_axis_lock_linear_x:

- :ref:`bool<class_bool>` **axis_lock_linear_x**

+-----------+----------------------+
| *Default* | ``false``            |
+-----------+----------------------+
| *Setter*  | set_axis_lock(value) |
+-----------+----------------------+
| *Getter*  | get_axis_lock()      |
+-----------+----------------------+

Bloquea el movimiento del cuerpo en el eje X.

----

.. _class_RigidBody_property_axis_lock_linear_y:

- :ref:`bool<class_bool>` **axis_lock_linear_y**

+-----------+----------------------+
| *Default* | ``false``            |
+-----------+----------------------+
| *Setter*  | set_axis_lock(value) |
+-----------+----------------------+
| *Getter*  | get_axis_lock()      |
+-----------+----------------------+

Bloquea el movimiento del cuerpo en el eje Y.

----

.. _class_RigidBody_property_axis_lock_linear_z:

- :ref:`bool<class_bool>` **axis_lock_linear_z**

+-----------+----------------------+
| *Default* | ``false``            |
+-----------+----------------------+
| *Setter*  | set_axis_lock(value) |
+-----------+----------------------+
| *Getter*  | get_axis_lock()      |
+-----------+----------------------+

Bloquea el movimiento del cuerpo en el eje Z.

----

.. _class_RigidBody_property_bounce:

- :ref:`float<class_float>` **bounce**

+----------+-------------------+
| *Setter* | set_bounce(value) |
+----------+-------------------+
| *Getter* | get_bounce()      |
+----------+-------------------+

The body's bounciness. Values range from ``0`` (no bounce) to ``1`` (full bounciness).

Deprecated, use :ref:`PhysicsMaterial.bounce<class_PhysicsMaterial_property_bounce>` instead via :ref:`physics_material_override<class_RigidBody_property_physics_material_override>`.

----

.. _class_RigidBody_property_can_sleep:

- :ref:`bool<class_bool>` **can_sleep**

+-----------+----------------------+
| *Default* | ``true``             |
+-----------+----------------------+
| *Setter*  | set_can_sleep(value) |
+-----------+----------------------+
| *Getter*  | is_able_to_sleep()   |
+-----------+----------------------+

If ``true``, the body can enter sleep mode when there is no movement. See :ref:`sleeping<class_RigidBody_property_sleeping>`.

\ **Note:** A RigidBody3D will never enter sleep mode automatically if its :ref:`mode<class_RigidBody_property_mode>` is :ref:`MODE_CHARACTER<class_RigidBody_constant_MODE_CHARACTER>`. It can still be put to sleep manually by setting its :ref:`sleeping<class_RigidBody_property_sleeping>` property to ``true``.

----

.. _class_RigidBody_property_contact_monitor:

- :ref:`bool<class_bool>` **contact_monitor**

+-----------+------------------------------+
| *Default* | ``false``                    |
+-----------+------------------------------+
| *Setter*  | set_contact_monitor(value)   |
+-----------+------------------------------+
| *Getter*  | is_contact_monitor_enabled() |
+-----------+------------------------------+

If ``true``, the RigidBody will emit signals when it collides with another RigidBody. See also :ref:`contacts_reported<class_RigidBody_property_contacts_reported>`.

----

.. _class_RigidBody_property_contacts_reported:

- :ref:`int<class_int>` **contacts_reported**

+-----------+----------------------------------+
| *Default* | ``0``                            |
+-----------+----------------------------------+
| *Setter*  | set_max_contacts_reported(value) |
+-----------+----------------------------------+
| *Getter*  | get_max_contacts_reported()      |
+-----------+----------------------------------+

El número máximo de contactos que serán reportados. Requiere que :ref:`contact_monitor<class_RigidBody_property_contact_monitor>` sea ``true``.

\ **Nota:** El número de contactos es diferente al número de colisiones. Las colisiones entre bordes paralelos resultará en dos contactos (uno en cada extremo), y las colisiones entre caras paralelas resultará en cuatro contactos (uno en cada esquina).

----

.. _class_RigidBody_property_continuous_cd:

- :ref:`bool<class_bool>` **continuous_cd**

+-----------+-----------------------------------------------+
| *Default* | ``false``                                     |
+-----------+-----------------------------------------------+
| *Setter*  | set_use_continuous_collision_detection(value) |
+-----------+-----------------------------------------------+
| *Getter*  | is_using_continuous_collision_detection()     |
+-----------+-----------------------------------------------+

Si ``true``, se utiliza la detección continua de colisiones.

La detección de colisión continua trata de predecir dónde colisionará un cuerpo en movimiento, en lugar de moverlo y corregir su movimiento si colisionara. La detección de colisión continua es más precisa, y pierde menos impactos de objetos pequeños y de movimiento rápido. No usar la detección de colisión continua es más rápido de calcular, pero puede pasar por alto los objetos pequeños y de movimiento rápido.

----

.. _class_RigidBody_property_custom_integrator:

- :ref:`bool<class_bool>` **custom_integrator**

+-----------+----------------------------------+
| *Default* | ``false``                        |
+-----------+----------------------------------+
| *Setter*  | set_use_custom_integrator(value) |
+-----------+----------------------------------+
| *Getter*  | is_using_custom_integrator()     |
+-----------+----------------------------------+

Si ``true``, la integración de la fuerza interna se desactivará (como la gravedad o la fricción del aire) para este cuerpo. Aparte de la respuesta a la colisión, el cuerpo sólo se moverá según lo determinado por la función :ref:`_integrate_forces<class_RigidBody_method__integrate_forces>`, si está definida.

----

.. _class_RigidBody_property_friction:

- :ref:`float<class_float>` **friction**

+----------+---------------------+
| *Setter* | set_friction(value) |
+----------+---------------------+
| *Getter* | get_friction()      |
+----------+---------------------+

The body's friction, from 0 (frictionless) to 1 (max friction).

Deprecated, use :ref:`PhysicsMaterial.friction<class_PhysicsMaterial_property_friction>` instead via :ref:`physics_material_override<class_RigidBody_property_physics_material_override>`.

----

.. _class_RigidBody_property_gravity_scale:

- :ref:`float<class_float>` **gravity_scale**

+-----------+--------------------------+
| *Default* | ``1.0``                  |
+-----------+--------------------------+
| *Setter*  | set_gravity_scale(value) |
+-----------+--------------------------+
| *Getter*  | get_gravity_scale()      |
+-----------+--------------------------+

This is multiplied by the global 3D gravity setting found in **Project > Project Settings > Physics > 3d** to produce RigidBody's gravity. For example, a value of 1 will be normal gravity, 2 will apply double gravity, and 0.5 will apply half gravity to this object.

----

.. _class_RigidBody_property_linear_damp:

- :ref:`float<class_float>` **linear_damp**

+-----------+------------------------+
| *Default* | ``-1.0``               |
+-----------+------------------------+
| *Setter*  | set_linear_damp(value) |
+-----------+------------------------+
| *Getter*  | get_linear_damp()      |
+-----------+------------------------+

The body's linear damp. Cannot be less than -1.0. If this value is different from -1.0, any linear damp derived from the world or areas will be overridden.

See :ref:`ProjectSettings.physics/3d/default_linear_damp<class_ProjectSettings_property_physics/3d/default_linear_damp>` for more details about damping.

----

.. _class_RigidBody_property_linear_velocity:

- :ref:`Vector3<class_Vector3>` **linear_velocity**

+-----------+----------------------------+
| *Default* | ``Vector3( 0, 0, 0 )``     |
+-----------+----------------------------+
| *Setter*  | set_linear_velocity(value) |
+-----------+----------------------------+
| *Getter*  | get_linear_velocity()      |
+-----------+----------------------------+

The body's linear velocity in units per second. Can be used sporadically, but **don't set this every frame**, because physics may run in another thread and runs at a different granularity. Use :ref:`_integrate_forces<class_RigidBody_method__integrate_forces>` as your process loop for precise control of the body state.

----

.. _class_RigidBody_property_mass:

- :ref:`float<class_float>` **mass**

+-----------+-----------------+
| *Default* | ``1.0``         |
+-----------+-----------------+
| *Setter*  | set_mass(value) |
+-----------+-----------------+
| *Getter*  | get_mass()      |
+-----------+-----------------+

La masa del cuerpo.

----

.. _class_RigidBody_property_mode:

- :ref:`Mode<enum_RigidBody_Mode>` **mode**

+-----------+-----------------+
| *Default* | ``0``           |
+-----------+-----------------+
| *Setter*  | set_mode(value) |
+-----------+-----------------+
| *Getter*  | get_mode()      |
+-----------+-----------------+

El modo corporal. Consulte :ref:`Mode<enum_RigidBody_Mode>` para conocer los posibles valores.

----

.. _class_RigidBody_property_physics_material_override:

- :ref:`PhysicsMaterial<class_PhysicsMaterial>` **physics_material_override**

+----------+--------------------------------------+
| *Setter* | set_physics_material_override(value) |
+----------+--------------------------------------+
| *Getter* | get_physics_material_override()      |
+----------+--------------------------------------+

El material de la física se sobreescribe para el cuerpo.

Si se asigna un material a esta propiedad, se utilizará en lugar de cualquier otro material de física, como por ejemplo uno heredado.

----

.. _class_RigidBody_property_sleeping:

- :ref:`bool<class_bool>` **sleeping**

+-----------+---------------------+
| *Default* | ``false``           |
+-----------+---------------------+
| *Setter*  | set_sleeping(value) |
+-----------+---------------------+
| *Getter*  | is_sleeping()       |
+-----------+---------------------+

Si ``true``, el cuerpo no se moverá y no calculará fuerzas hasta que sea despertado por otro cuerpo a través de, por ejemplo, una colisión, o utilizando los métodos :ref:`apply_impulse<class_RigidBody_method_apply_impulse>` o :ref:`add_force<class_RigidBody_method_add_force>`.

----

.. _class_RigidBody_property_weight:

- :ref:`float<class_float>` **weight**

+-----------+-------------------+
| *Default* | ``9.8``           |
+-----------+-------------------+
| *Setter*  | set_weight(value) |
+-----------+-------------------+
| *Getter*  | get_weight()      |
+-----------+-------------------+

El peso del cuerpo basado en su masa y la gravedad 3D global. Los valores globales se establecen en **Proyecto > Configuración del proyecto > Física > 3d**.

Descripciones de Métodos
------------------------------------------------

.. _class_RigidBody_method__integrate_forces:

- void **_integrate_forces** **(** :ref:`PhysicsDirectBodyState<class_PhysicsDirectBodyState>` state **)** |virtual|

Llamado durante el procesamiento de la física, que permite leer y modificar con seguridad el estado de simulación del objeto. Por defecto, funciona además del comportamiento físico habitual, pero la propiedad :ref:`custom_integrator<class_RigidBody_property_custom_integrator>` te permite deshabilitar el comportamiento por defecto y hacer una integración de fuerza totalmente personalizada para un cuerpo.

----

.. _class_RigidBody_method_add_central_force:

- void **add_central_force** **(** :ref:`Vector3<class_Vector3>` force **)**

Añade una fuerza direccional constante (es decir, aceleración) sin afectar a la rotación.

Esto equivale a ``add_force(force, Vector3(0,0,0))``.

----

.. _class_RigidBody_method_add_force:

- void **add_force** **(** :ref:`Vector3<class_Vector3>` force, :ref:`Vector3<class_Vector3>` position **)**

Añade una fuerza direccional constante (es decir, aceleración) sin afectar a la rotación.

Esto equivale a ``add_force(force, Vector3(0,0,0))``.

----

.. _class_RigidBody_method_add_torque:

- void **add_torque** **(** :ref:`Vector3<class_Vector3>` torque **)**

Añade una fuerza de rotación constante (es decir, un motor) sin afectar a la posición.

----

.. _class_RigidBody_method_apply_central_impulse:

- void **apply_central_impulse** **(** :ref:`Vector3<class_Vector3>` impulse **)**

Aplica un impulso direccional sin afectar a la rotación.

Esto equivale a ``apply_impulse(Vector3(0,0,0), impulse)``.

----

.. _class_RigidBody_method_apply_impulse:

- void **apply_impulse** **(** :ref:`Vector3<class_Vector3>` position, :ref:`Vector3<class_Vector3>` impulse **)**

Aplica un impulso posicionado al cuerpo. ¡Un impulso es independiente del tiempo! Aplicar un impulso en cada cuadro resultaría en una fuerza dependiente del cuadro. Por esta razón, sólo debe utilizarse cuando se simulan impactos únicos. La posición utiliza la rotación del sistema de coordenadas globales, pero está centrada en el origen del objeto.

----

.. _class_RigidBody_method_apply_torque_impulse:

- void **apply_torque_impulse** **(** :ref:`Vector3<class_Vector3>` impulse **)**

Aplica un impulso de torsión que se verá afectado por la masa y la forma del cuerpo. Esto hará girar el cuerpo alrededor del vector de ``impulse`` pasado.

----

.. _class_RigidBody_method_get_axis_lock:

- :ref:`bool<class_bool>` **get_axis_lock** **(** :ref:`BodyAxis<enum_PhysicsServer_BodyAxis>` axis **)** |const|

Devuelve ``true`` si el eje lineal o rotativo especificado está bloqueado.

----

.. _class_RigidBody_method_get_colliding_bodies:

- :ref:`Array<class_Array>` **get_colliding_bodies** **(** **)** |const|

Retorna una lista de los cuerpos que colisionan con éste. Requiere que :ref:`contact_monitor<class_RigidBody_property_contact_monitor>` sea ``true``, y que :ref:`contacts_reported<class_RigidBody_property_contacts_reported>` sea lo suficientemente alto para detectar todas las colisiones.

\ **Nota:** El resultado de esta prueba no es inmediato después de mover los objetos. Para un mejor rendimiento, la lista de superposiciones se actualiza una vez por cuadro y antes del paso de física. Considere la posibilidad de utilizar señales en su lugar.

----

.. _class_RigidBody_method_get_inverse_inertia_tensor:

- :ref:`Basis<class_Basis>` **get_inverse_inertia_tensor** **(** **)**

Returns the inverse inertia tensor basis. This is used to calculate the angular acceleration resulting from a torque applied to the RigidBody.

----

.. _class_RigidBody_method_set_axis_lock:

- void **set_axis_lock** **(** :ref:`BodyAxis<enum_PhysicsServer_BodyAxis>` axis, :ref:`bool<class_bool>` lock **)**

Bloquea el eje lineal o rotacional especificado.

----

.. _class_RigidBody_method_set_axis_velocity:

- void **set_axis_velocity** **(** :ref:`Vector3<class_Vector3>` axis_velocity **)**

Establece una velocidad del eje. La velocidad en el eje vectorial dado se fijará como la longitud del vector dado. Esto es útil para el comportamiento de salto.

.. |virtual| replace:: :abbr:`virtual (This method should typically be overridden by the user to have any effect.)`
.. |const| replace:: :abbr:`const (This method has no side effects. It doesn't modify any of the instance's member variables.)`
.. |vararg| replace:: :abbr:`vararg (This method accepts any number of arguments after the ones described here.)`
