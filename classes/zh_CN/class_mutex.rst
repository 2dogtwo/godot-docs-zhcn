:github_url: hide

.. DO NOT EDIT THIS FILE!!!
.. Generated automatically from Godot engine sources.
.. Generator: https://github.com/godotengine/godot/tree/master/doc/tools/make_rst.py.
.. XML source: https://github.com/godotengine/godot/tree/master/doc/classes/Mutex.xml.

.. _class_Mutex:

Mutex
=====

**Inherits:** :ref:`RefCounted<class_RefCounted>` **<** :ref:`Object<class_Object>`

二元 :ref:`Semaphore<class_Semaphore>`\ ，用于在多 :ref:`Thread<class_Thread>` 间进行同步。

.. rst-class:: classref-introduction-group

Description
-----------

同步互斥器（mutex 来源于 mutual exclusion，即互斥）。可用于在多 :ref:`Thread<class_Thread>` 间进行同步，等价于二元 :ref:`Semaphore<class_Semaphore>`\ 。能够确保同时只有一个线程能够访问临界区。

这是一种可重入的互斥器，也就是说同一个线程能够将其多次上锁，只要也进行相同次数的解锁即可。

\ **警告：**\ 互斥器必须谨慎使用才能避免死锁。

\ **警告：**\ 为了能够正确清理，避免崩溃和死锁，必须满足以下条件：

- **Mutex** 的引用计数到达零，将被销毁时，必须没有线程将其锁定（包括发生析构的线程）。

- :ref:`Thread<class_Thread>` 的引用计数达到零，将被销毁时，必须没有锁定任何互斥器。

.. rst-class:: classref-introduction-group

Tutorials
---------

- :doc:`使用多线程 <../tutorials/performance/using_multiple_threads>`

- :doc:`线程安全的 API <../tutorials/performance/thread_safe_apis>`

.. rst-class:: classref-reftable-group

Methods
-------

.. table::
   :widths: auto

   +-------------------------+----------------------------------------------------------+
   | void                    | :ref:`lock<class_Mutex_method_lock>` **(** **)**         |
   +-------------------------+----------------------------------------------------------+
   | :ref:`bool<class_bool>` | :ref:`try_lock<class_Mutex_method_try_lock>` **(** **)** |
   +-------------------------+----------------------------------------------------------+
   | void                    | :ref:`unlock<class_Mutex_method_unlock>` **(** **)**     |
   +-------------------------+----------------------------------------------------------+

.. rst-class:: classref-section-separator

----

.. rst-class:: classref-descriptions-group

Method Descriptions
-------------------

.. _class_Mutex_method_lock:

.. rst-class:: classref-method

void **lock** **(** **)**

锁定此 **Mutex**\ ，直到被当前所有者解锁为止。

\ **注意：**\ 如果线程已经拥有互斥锁的所有权，该函数将无阻塞地返回。

.. rst-class:: classref-item-separator

----

.. _class_Mutex_method_try_lock:

.. rst-class:: classref-method

:ref:`bool<class_bool>` **try_lock** **(** **)**

尝试锁定该 **Mutex**\ ，但不会阻塞。成功时返回 ``true``\ ，否则返回 ``false``\ 。

\ **注意：**\ 如果该线程已经拥有了该互斥器的所有权，则函数返回 ``true``\ 。

.. rst-class:: classref-item-separator

----

.. _class_Mutex_method_unlock:

.. rst-class:: classref-method

void **unlock** **(** **)**

解锁该 **Mutex**\ ，将其留给其他线程。

\ **注意：**\ 如果一个线程在已经拥有互斥器的情况下多次调用 :ref:`lock<class_Mutex_method_lock>` 或 :ref:`try_lock<class_Mutex_method_try_lock>`\ ，则也必须调用相同次数的 :ref:`unlock<class_Mutex_method_unlock>` 才能正确解锁。

\ **警告：**\ 在给定的线程中调用 :ref:`unlock<class_Mutex_method_unlock>` 的次数超过调用 :ref:`lock<class_Mutex_method_lock>` 的次数，导致尝试解锁未加锁的互斥器，是错误的行为，可能引起崩溃和死锁。

.. |virtual| replace:: :abbr:`virtual (This method should typically be overridden by the user to have any effect.)`
.. |const| replace:: :abbr:`const (This method has no side effects. It doesn't modify any of the instance's member variables.)`
.. |vararg| replace:: :abbr:`vararg (This method accepts any number of arguments after the ones described here.)`
.. |constructor| replace:: :abbr:`constructor (This method is used to construct a type.)`
.. |static| replace:: :abbr:`static (This method doesn't need an instance to be called, so it can be called directly using the class name.)`
.. |operator| replace:: :abbr:`operator (This method describes a valid operator to use with this type as left-hand operand.)`
.. |bitfield| replace:: :abbr:`BitField (This value is an integer composed as a bitmask of the following flags.)`
